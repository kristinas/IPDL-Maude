***( IPDL

  Copyright : (C) 2022-23, Kristina Sojakova, Mihai Codescu
  License   : GNU General Public License v3.0 or later (GPL-3.0-or-later)
  Authors   : Mihai Codescu <mscodescu@gmail.com>
              Kristina Sojakova <sojakova.kristina@gmail.com>

Two-Party GMW Protocol
See Sec. 8 in doc/case-studies.pdf

)

load ../src/strategies

mod GMW2 is
 including APPROX-EQUALITY .
 protecting LIST{NatPairs} .

 op sumF : -> SigElem .
 eq sumF = 'xor : (bool * bool) ~> bool .
 *** xor is +
 
 op mulF : -> SigElem .
 eq mulF = 'and : (bool * bool) ~> bool .
 *** and is *
 
 op negF : -> SigElem .
 eq negF = 'neg : bool ~> bool .
 
 op flipF : -> SigElem .
 eq flipF = 'flip : unit ~>> bool .
 
 op secSig : -> Signature .
 eq secSig = sumF mulF negF flipF .
 
 var i j l k n : Nat .
 
 sort Gate .
 
 op input-gate : Nat Nat -> Gate [ctor] . *** 0 for Alice 1 for Bob
 op not-gate : Nat -> Gate [ctor] .
 op xor-gate : Nat Nat -> Gate [ctor] .
 op and-gate : Nat Nat -> Gate [ctor] .
 
 sort Circuit . *** list of gates
 subsort Gate < Circuit .
 op emptyCircuit : -> Circuit [ctor] .
 op __ : Circuit Circuit -> Circuit [ctor assoc id: emptyCircuit] .

 op wellFormed : Circuit Nat -> Bool .
 
 var circuit : Circuit .
 
 op C : -> Circuit . *** the circuit acting as parameter 

 eq wellFormed(emptyCircuit, 0) = true .
 ceq wellFormed(circuit input-gate(i, j), s(n)) = true 
  if wellFormed(circuit, n) .
 ceq wellFormed(circuit not-gate(k), s(n)) = true
  if wellFormed(circuit, n) /\ k < n . 
 ceq wellFormed(circuit and-gate(k, l), s(n)) = true
  if wellFormed(circuit, n) /\ k < n /\ l < n .
 ceq wellFormed(circuit xor-gate(k, l), s(n)) = true
  if wellFormed(circuit, n) /\ k < n /\ l < n .  
  
 ops N M K : -> Nat .
 eq K = M + N .
 
 *** underspecified predicate
 op isOutputWire : Nat -> Bool .
 
 op isAliceInput : Nat -> Bool .
 op isBobInput : Nat -> Bool .
 op isNotGate : Nat -> Bool .
 op isXorGate : Nat -> Bool .
 op isAndGate : Nat -> Bool .
 
 eq isAliceInput(i) = isAliceInputAux(C, i) .
 
 op isAliceInputAux : Circuit Nat -> Bool .
 eq isAliceInputAux(emptyCircuit, 0) = false .
 eq isAliceInputAux(emptyCircuit, s(i)) = false .
 eq isAliceInputAux(gate circuit, s(i)) = isAliceInputAux(circuit, i) .
 eq isAliceInputAux(input-gate(k, 0) circuit, 0) = true .
 eq isAliceInputAux(gate circuit, 0) = false [owise] .
 
 eq isBobInput(i) = isBobInputAux(C, i) .
 
 op isBobInputAux : Circuit Nat -> Bool .
 eq isBobInputAux(emptyCircuit, 0) = false .
 eq isBobInputAux(emptyCircuit, s(i)) = false .
 eq isBobInputAux(gate circuit, s(i)) = isBobInputAux(circuit, i) .
 eq isBobInputAux(input-gate(k, 1) circuit, 0) = true .
 eq isBobInputAux(gate circuit, 0) = false [owise] .
 
 eq isNotGate(i) = isNotGateAux(C, i) .
 
 op isNotGateAux : Circuit Nat -> Bool .
 eq isNotGateAux(emptyCircuit, 0) = false .
 eq isNotGateAux(emptyCircuit, s(i)) = false .
 eq isNotGateAux(gate circuit, s(i)) = isNotGateAux(circuit, i) .
 eq isNotGateAux(not-gate(k) circuit, 0) = true .
 eq isNotGateAux(gate circuit, 0) = false [owise] .
 
 eq isXorGate(i) = isXorGateAux(C, i) .
 
 op isXorGateAux : Circuit Nat -> Bool .
 eq isXorGateAux(emptyCircuit, 0) = false .
 eq isXorGateAux(emptyCircuit, s(i)) = false .
 eq isXorGateAux(gate circuit, s(i)) = isXorGateAux(circuit, i) .
 eq isXorGateAux(xor-gate(k, l) circuit, 0) = true .
 eq isXorGateAux(gate circuit, 0) = false [owise] .
 
 op isAndGateAux : Circuit Nat -> Bool .
 eq isAndGateAux(emptyCircuit, 0) = false .
 eq isAndGateAux(emptyCircuit, s(i)) = false .
 eq isAndGateAux(gate circuit, s(i)) = isAndGateAux(circuit, i) .
 eq isAndGateAux(and-gate(k, l) circuit, 0) = true .
 eq isAndGateAux(gate circuit, 0) = false [owise] .
 
 *** helpers
 *** get the gate at the start of the circuit, after i pops
 *** i must be at most the length of circuit
 *** the circuit must be non-empty
 
 var gate : Gate .
 
 op gateAt : Circuit Nat -> Gate .
 eq gateAt(gate circuit, 0) = gate .
 eq gateAt(gate circuit, s(n)) = gateAt(circuit, n) .
 
 *** the wires of a gate, as a list
 op wiresOf : Gate -> List{NatPairs} .
 eq wiresOf(input-gate(i, j)) = (0 ;; i) .
 eq wiresOf(not-gate(i)) = (0 ;; i) .
 eq wiresOf(and-gate(k, l)) = (0 ;; k) (1 ;; l) .
 eq wiresOf(xor-gate(k, l)) = (0 ;; k) (1 ;; l) .
 
 *** list as an unsafe map
 var natPairs : List{NatPairs} .
 op _@@_ : List{NatPairs} Nat -> Nat .
 eq ( (i ;; k) natPairs) @@ i = k .
 ceq ( (l ;; k) natPairs) @@ i = natPairs @@ i if l =/= i .
 
 *** wire 0 of the circuit C at a given gate
 op wire0 : Nat -> Nat .
 eq wire0(i) = wiresOf(gateAt(C, i)) @@ 0 .
 
 *** wire 1 of the circuit C at a given gate
 op wire1 : Nat -> Nat .
 eq wire1(i) = wiresOf(gateAt(C, i)) @@ 1 .


 *** here we connect 'wire0 with wire0 
 var nt : NatTerm .
 var f : Map{Qid, NatTerm} .
 ceq evalTerm (fun 'wire0 nt) f = wire0(evalTerm nt f) 
  if (evalTerm nt f) : Nat .
 eq evalTerm (fun 'wire0 nt) f = fun 'wire0 nt [owise] . 
 ceq evalTerm (fun 'wire1 nt) f = wire1(evalTerm nt f) 
  if (evalTerm nt f) : Nat .
 eq evalTerm (fun 'wire1 nt) f = fun 'wire1 nt [owise] . 
  
 *** here we connect 'isAliceInput with isAliceInput etc.
 var A : Set{BoolTerm} .
 eq evalBoolTerm(apply 'isOutputWire nt, A, f) = 
    isOutputWire(evalTerm nt f) . 
 eq evalBoolTerm(apply 'isAliceInput nt, A, f) = 
    isAliceInput(evalTerm nt f) . 
 eq evalBoolTerm(apply 'isBobInput nt, A, f) = 
    isBobInput(evalTerm nt f) . 
 eq evalBoolTerm(apply 'isNotGate nt, A, f) = 
    isNotGate(evalTerm nt f) . 
 eq evalBoolTerm(apply 'isXorGate nt, A, f) = 
    isXorGate(evalTerm nt f) . 
 eq evalBoolTerm(apply 'isAndGate nt, A, f) = 
    isAndGate(evalTerm nt f) .      

 *** here we record the assumptions on indices
 var q : Qid .
 
 ceq A |= fun 'wire0 nt <T N with f = true 
   if (apply 'isAliceInput (evalTerm nt f)) in A [label aliceIndex].
 ceq A |= fun 'wire0 nt <T M with f = true 
    if (apply 'isBobInput (evalTerm nt f)) in A .
 ceq A |= fun 'wire0 nt <T N + M with f = true 
    if (apply 'isNotGate (evalTerm nt f)) in A [label notIndex].
 ceq A |= fun 'wire0 nt <T N + M with f = true 
    if (apply 'isXorGate (evalTerm nt f)) in A .
 ceq A |= fun 'wire1 nt <T N + M with f = true 
    if (apply 'isXorGate (evalTerm nt f)) in A .   
 ceq A |= fun 'wire0 nt <T N + M with f = true 
    if (apply 'isAndGate (evalTerm nt f)) in A [label andIndex] .
 ceq A |= fun 'wire1 nt <T N + M with f = true 
    if (apply 'isAndGate (evalTerm nt f)) in A .
 eq A |= fun 'wire0 i <T n with f = (A |= i <T n with f) .
 
 *** generic assumptions shared by both proofs
 op genA : -> Set{BoolTerm} .
 eq genA = ( neg (apply 'isXorGate 0), 
             neg (apply 'isAndGate 0), 
             neg (apply 'isNotGate 0),
             0 <T K )
 .            
 
 
*** ideal protocol

 op wiresIdeal : -> Protocol .
 eq wiresIdeal =
  family ('Wires[bound K]) 'k (bound K) ::=
  (  *** start group
   family ('Wire[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 'k]), return 'inA0, 'inA0  )
  )
  ;;
  (when (apply 'isBobInput 'k) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 'k]), return 'inB0, 'inB0  )
  )
  ;;
  (when (apply 'isNotGate 'k) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 'k]),
     return (ap 'neg 'x),
     'x  
     )
  )
  ;;
  (when (apply 'isXorGate 'k) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'xor pair('x, 'y)),
    'x 'y   
    )
  )
  ;;
  (when (apply 'isAndGate 'k) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'and pair('x, 'y)),
    'x 'y   
    )
  )
 ) *** end group 
 .  
 
 op ideal : -> Protocol .
 eq ideal = 
   newfamily ('Wire[bound K]) 'k (bound K) : bool in
   ( *** start new
   (family (('In-A ^^ 'id .. 'adv)[bound N]) 'k (bound N) ::= 
     nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA  )
   ) 
   ||
   (family (('InRcvd-B ^^ 'id .. 'adv)[bound M]) 'k (bound M) ::= 
     nf('x : bool <- read ('In-B['k]),
        return (),
        'x  )
   )
   || 
   wiresIdeal
   || 
   (family ('Out-A[bound K]) 'k (bound K) ::=
      (when (apply 'isOutputWire 'k) --> 
          nf( 'wi : bool <- read ('Wire['k]), return 'wi, 'wi  )
      )
      ;;
      (otherwise --> nf('oai : bool <- read ('Out-A['k]), return 'oai, 'oai  )
      )  
    ) 
    || 
   (family ('Out-B[bound K]) 'k (bound K) ::=
      (when (apply 'isOutputWire 'k) --> 
         nf( 'wi : bool <- read ('Wire['k]), return 'wi, 'wi  )
      )
      ;;
      (otherwise --> nf('obi : bool <- read ('Out-B['k]), return 'obi, 'obi  )
      )  
    )
    ||
    (family (('Out-A ^^ 'id .. 'adv)[bound K]) 'k (bound K) ::= 
        nf('oai : bool <- read ('Out-A['k]), return 'oai, 'oai  )
    )     
   ) *** end new
 . 

 *** sim
 
 op sim : -> Protocol .
 eq sim = 
     newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
     newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
     newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
     newfamily ('Share-A[bound K]) 'k (bound K) : bool in
     (simInitial || simInductive || simFinal)
.     

op simInitial : -> Protocol .
eq simInitial = 
 (
 family (('In-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::=
   nf('inA : bool <- read (('In-A ^^ 'id .. 'adv)['k]) , return 'inA, 'inA   )
 )
 ||
 (
 family (('InRcvd-B ^^ 'B .. 'adv)[bound M]) 'k (bound M) ::=
   nf('inB : unit <- read (('InRcvd-B ^^ 'id .. 'adv)['k]) , return 'inB, 'inB   )
 )
 ||
 (
 family ('InputShare-A-A[bound N]) 'k (bound N) ::=
   nf('x : bool <- read (('In-A ^^ 'id .. 'adv)['k]),
      samp ('flip < () >) ,
      'x  
     )
 )
 ||
 (
 family ('InputShare-A-B[bound M]) 'k (bound M) ::=
   nf('x : unit <- read (('InRcvd-B ^^ 'id .. 'adv)['k]),
      samp ('flip < () >) ,
      'x  
     )
 )
 ||
 (
 family (('InputShare-A-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::=
   nf('inA : bool <- read ('InputShare-A-A['k]),
      return 'inA,
      'inA  
     )
 )
 ||
 (
 family (('InputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::=
   nf('inB : bool <- read ('InputShare-A-B['k]),
      return 'inB,
      'inB  
     )
 )
 ||
 (
 family (('SendInputShare-B-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::=
   nf(('xa : bool <- read ('InputShare-A-A['k]))
      ('x : bool <- read (('In-A ^^ 'id .. 'adv)['k])),
      return (ap 'xor pair('xa, 'x)),
      'xa 'x  
     )
 )
 ||
 (
 family (('SendInputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::=
   nf('x : bool <- read ('InputShare-A-B['k]),
      return 'x,
      'x  
     )
 )
.


op simFinal : -> Protocol .
eq simFinal = 
  (family (('SendFinalShare-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::=
    (when (apply 'isOutputWire 'k) --> 
      nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa  )
    )
    ;;
    (otherwise --> 
      nf('sa : bool <- read (('SendFinalShare-A ^^ 'A .. 'adv)['k]), return 'sa, 'sa  )
    )
  )
  ||
  (family (('SendFinalShare-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::=
    (when (apply 'isOutputWire 'k) --> 
      nf(('xa : bool <- read ('Share-A['k]))
         ('x : bool <- read (('Out-A ^^ 'id .. 'adv)['k])), 
         return (ap 'xor pair('xa, 'x)), 
         'xa 'x  )
    )
    ;;
    (otherwise --> 
      nf('sa : bool <- read (('SendFinalShare-B ^^ 'A .. 'adv)['k]), return 'sa, 'sa  )
    )
  )
  ||
   ( family (('Out-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::=
   nf('outA : bool <- read (('Out-A ^^ 'id .. 'adv)['k]),
      return 'outA,
      'outA  
     )
 )

.

op simInductive : -> Protocol .
eq simInductive = 
 family ('Sim[bound K]) 'k (bound K) ::= ( *** start group
  (family ('OTBit-A-B[bound K]) 'k (bound K) ::=
    (when (apply 'isAndGate 'k)  --> 
          nf(
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
           samp ('flip < () >),
           'xa 'ya  
           )
    )
    ;;
    (otherwise -->  
      nf( 'otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb   )
    )
  )
  ||
  (family ('Share-A[bound K]) 'k (bound K) ::=
        (when (apply 'isAliceInput 'k) --> 
          nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]),
             return 'is,
             'is  )
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
          nf(
           'is : bool <- read ('InputShare-A-B[fun 'wire0 'k]),
           return 'is,
           'is  
          )
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
             return 'sa,
             'sa  
            )
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
           return (ap 'xor pair('xa, 'ya)),
           'xa 'ya  
          )
        )
        ;;
        (when (apply 'isAndGate 'k) -->
          nf( 
          ('ba : bool <- read ('OTBit-A-B['k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair(ap 'and pair('xa, 'ya) , 'ba)),
          'ba 'xa 'ya  
          )
        )
  )
  ||
  (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb  )
        )
        ;;
        (otherwise --> 
          nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), return 'otb, 'otb  )
        )
      )
  ||
      (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
        nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa  )
      ) 
  ||
      (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
           return 'ba,
           'ba 'xa 'ya  
          )
        )
        ;;
        (otherwise --> 
          nf('otm : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]),
             return 'otm,
             'otm  
            )
        )    
      )
      ||
      (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
          ('ba : bool <- read ('OTBit-A-B['k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, 'xa)),
          'ba 'xa 'ya  
          )
        )
        ;;
        (otherwise --> 
          nf('otm : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]),
             return 'otm,
             'otm  
            )
        )
      )   
      ||
      (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
           nf(
          ('ba : bool <- read ('OTBit-A-B['k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, 'ya)),
          'ba 'xa 'ya  
          )
        )
        ;;
        (otherwise --> nf('otm : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]),
             return 'otm,
             'otm  
            )
        )
      )
      ||
      (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))),
          'ba 'xa 'ya  
          )
        )
        ;;
        (otherwise --> nf('otm : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]),
             return 'otm,
             'otm  
            )
        )
      )  
      ||
     (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::=
       (when (apply 'isAndGate 'k) --> 
       nf(
       'c0 : bool <- read ('Share-A[fun 'wire0 'k]),
       return (),
       'c0  
       )
       )
       ;;
       (otherwise --> 
         nf('otc : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]),
            return 'otc,
            'otc  
           )
       )
     )
     ||
     (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
        nf(
       'c1 : bool <- read ('Share-A[fun 'wire1 'k]),
       return (),
       'c1  
       )
       )
       ;;
       (otherwise --> nf('otc : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]),
            return 'otc,
            'otc  
           )
       )
       
     )  
    ) *** end group     
.

*** idealPlusSim is just composition

op idealPlusSim : -> Protocol .
eq idealPlusSim = 
 newfamily (('In-A ^^ 'id .. 'adv)[bound N]) 'k (bound N) : bool in
 newfamily (('InRcvd-B ^^ 'id .. 'adv)[bound M]) 'k (bound M) : unit in
 newfamily (('Out-A ^^ 'id .. 'adv)[bound K]) 'k (bound K) : bool in
 (ideal || sim) 
.
 
*** here we start spelling out real 

 op aliceInitial  : -> Protocol .
 eq aliceInitial = 
    (family (('In-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
       nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA  )
    )
    ||
    (family ('InputShare-A-A[bound N]) 'k (bound N) ::= 
       nf(
       'x : bool <- read ('In-A['k]),
       samp ('flip < () >),
       'x  ) 
    )
    ||
    (family ('InputShare-A-B[bound M]) 'k (bound M) ::= 
      nf('sis : bool <- read ('SendInputShare-A-B['k]), 
         return 'sis, 
         'sis  )
    )
    ||
    (family (('InputShare-A-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
      nf(
       'is : bool <- read ('InputShare-A-A['k]),
       return 'is,
       'is  ) 
    )
    ||
    (family (('InputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::=
           nf(
       'is : bool <- read ('InputShare-A-B['k]),
       return 'is,
       'is  ) 
    )
    ||
    (family ('SendInputShare-B-A[bound N]) 'k (bound N) ::= 
       nf(
       ('x : bool <- read ('In-A['k]))
       'xa : bool <- read ('InputShare-A-A['k]),
       return (ap 'xor pair('x, 'xa)),
       'x 'xa  )
    )
    ||
    (family (('SendInputShare-B-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
       nf('sis : bool <- read ('SendInputShare-B-A['k]), 
         return 'sis, 
         'sis  )
    )
    ||
    (family (('SendInputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::= 
         nf('sis : bool <- read ('SendInputShare-A-B['k]), 
         return 'sis, 
         'sis  )
    )
 .  
 
 *** InRcvd-B ^^ 'B .. 'adv is unit! the rest is bool
 op bobInitial : -> Protocol .
 eq bobInitial =
    (family (('InRcvd-B ^^ 'B .. 'adv)[bound M]) 'k (bound M) ::= 
       nf('x : bool <- read ('In-B['k]) , return (), 'x  )
    )
    ||
    (family ('InputShare-B-A[bound N]) 'k (bound N) ::=
       nf('sis : bool <- read ('SendInputShare-B-A['k]), 
         return 'sis, 
         'sis  )
    )
    ||
    (family ('InputShare-B-B[bound M]) 'k (bound M) ::= 
      nf(
       ('x : bool <- read ('In-B['k]) )
       ('xa : bool <- read ('SendInputShare-A-B['k])),
       return (ap 'xor pair('x, 'xa)),
       'x 'xa   
      )
    )
    ||
    (family ('SendInputShare-A-B[bound M]) 'k (bound M) ::= 
       nf('x : bool <- read ('In-B['k]),  samp ('flip < () >), 'x  )
    )
 .
 
 *** alice inductive
 
 op aliceInductive : -> Protocol .
 eq aliceInductive =
  family ('A[bound K]) 'k (bound K) ::= ( *** start group
      (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
         (when (apply 'isAndGate 'k) -->
           nf( 
            ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
            ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
           samp ('flip < () >),
           'xa 'ya  
           )
         )
         ;;
         (otherwise --> 
           nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb  )
         )     
      )
      ||
      (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb  )
        )
        ;;
        (otherwise --> 
          nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), return 'otb, 'otb  )
        )
      )
      ||
      (family ('Share-A[bound K]) 'k (bound K) ::=
        (when (apply 'isAliceInput 'k) --> 
          nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
         nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
             return 'sa, 'sa  )
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('xa, 'ya)),
          'xa 'ya  
          )
        )
        ;;
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair(ap 'and pair('xa, 'ya) , 'ba)),
          'ba 'xa 'ya  
          )
        )
      )
      ||
      (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
        nf('sa : bool <- read ('Share-A['k]), 
             return 'sa, 'sa  )
      )
      ||
      (family ('OTMsg-A-B-0[bound K]) 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return 'ba,
          'ba 'xa 'ya  
          )
        )
        ;;
        (otherwise --> 
          nf('otm : bool <- read ('OTMsg-A-B-0['k]), 
             return 'otm, 'otm  )
        )
      )
      ||
      (family ('OTMsg-A-B-1[bound K]) 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, 'xa)),
          'ba 'xa 'ya  
          )
        )
        ;;
        (otherwise -->
         nf('otm : bool <- read ('OTMsg-A-B-1['k]), 
             return 'otm, 'otm  ) 
        )
      )   
      ||
      (family ('OTMsg-A-B-2[bound K]) 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, 'ya)),
          'ba 'xa 'ya  
          )
        )
        ;;
        (otherwise -->
         nf('otm : bool <- read ('OTMsg-A-B-2['k]), 
             return 'otm, 'otm  )
        )
      )
      ||
      (family ('OTMsg-A-B-3[bound K]) 'k (bound K) ::=
        (when (apply 'isAndGate 'k) -->
          nf( 
          ('ba : bool <- read ('OTBit-A-B['k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))),
          'ba 'xa 'ya  
          )
        )
        ;;
        (otherwise --> 
          nf('otm : bool <- read ('OTMsg-A-B-3['k]), 
             return 'otm, 'otm  )
        )
      )
  ) *** end group    
 .
 
 *** bob inductive
 
 op bobInductive : -> Protocol .
 eq bobInductive = 
 family ('B[bound K]) 'k (bound K) ::= ( *** start group
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf('oto : bool <- read ('OTOut-B-A['k]), return 'oto, 'oto  )
    )
    ;;
    (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb  )
    )
  )
  ||
  (family ('OTChoice-B-A-0[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire0 'k]), return 'sb, 'sb  )
    )
    ;;
    (otherwise --> 
      nf('otc : bool <- read ('OTChoice-B-A-0['k]), return 'otc, 'otc  )
    )
  )
  ||
  (family ('OTChoice-B-A-1[bound K]) 'k (bound K) ::=
    (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire1 'k]), return 'sb, 'sb  )
    )
    ;;
    (otherwise -->
      nf('otc : bool <- read ('OTChoice-B-A-1['k]), return 'otc, 'otc  )
    )
  )
  ||
  (family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
          nf('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
          nf('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('xb : bool <- read ('Share-B[fun 'wire0 'k]),
             return (ap 'neg 'xb),
             'xb  )
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
          ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k])) ,
          return (ap 'xor pair('xb, 'yb)),
          'xb 'yb   
          )
        )
        ;;
        (when (apply 'isAndGate 'k) --> 
          nf(
          ('bb : bool <- read ('OTBit-B-A['k]))
          ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('yb : bool <- read ('Share-B[fun 'wire1 'k])) ,
          return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))),
          'bb 'xb 'yb  
          )
        )
  )
  ) *** end group
 .
 
 *** alice final
 
 
 op aliceFinal : -> Protocol .
 eq aliceFinal =
    (family ('SendFinalShare-A[bound K]) 'k (bound K) ::=
       (when (apply 'isOutputWire 'k) --> 
         nf('sa : bool <- read ('Share-A['k]), 
         return 'sa,
         'sa  
         )
       ) 
       ;; 
       (otherwise --> 
         nf('sfs : bool <- read ('SendFinalShare-A['k]), 
         return 'sfs,
         'sfs  
         )
       ) 
    )
    ||
    (family (('SendFinalShare-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::=
      nf('sfs : bool <- read ('SendFinalShare-A['k]), 
         return 'sfs,
         'sfs  
         )
    )
    ||
    (family (('SendFinalShare-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::=
      nf('sfs : bool <- read ('SendFinalShare-B['k]), 
         return 'sfs,
         'sfs  
         )
    )
    ||
    (family ('Out-A[bound K]) 'k (bound K) ::=
      nf(
      ('xa : bool <- read ('SendFinalShare-A['k]))
      ('xb : bool <- read ('SendFinalShare-B['k])),
      return (ap 'xor pair('xa, 'xb)),
      'xa 'xb  
      )
    )
    ||
    (family (('Out-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
      nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA   )
    )  
 .
 
 *** bob final
 
 op bobFinal : -> Protocol .
 eq bobFinal = 
   (family ('SendFinalShare-B[bound K]) 'k (bound K) ::=
       (when (apply 'isOutputWire 'k) -->
          nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb  )
       ) 
       ;; 
       (otherwise --> 
         nf('s : bool <- read ('SendFinalShare-B['k]), return 's, 's  )
       ) 
    )
    ||
    (family ('Out-B[bound K]) 'k (bound K) ::=
      nf(
       ('xa : bool <- read ('SendFinalShare-A['k]))
       ('xb : bool <- read ('SendFinalShare-B['k])),
       return (ap 'xor pair('xa, 'xb)),
       'xa 'xb   
      )
    )
 .
 
 op 1OutOf4 : -> Protocol .
 eq 1OutOf4 = 
  family ('1OutOf4OT[bound K]) 'k (bound K) ::= ( *** start group
    (family ('OTOut-B-A[bound K]) 'k (bound K) ::= 
      nf(
       ('m0 : bool <- read ( 'OTMsg-A-B-0['k]))
       ('m1 : bool <- read ( 'OTMsg-A-B-1['k]))
       ('m2 : bool <- read ( 'OTMsg-A-B-2['k]))
       ('m3 : bool <- read ( 'OTMsg-A-B-3['k]))
       ('c0 : bool <- read ( 'OTChoice-B-A-0['k]))
       ('c1 : bool <- read ( 'OTChoice-B-A-1['k])),
      if 'c0 then
        (if 'c1 then return 'm3 else return 'm2)
      else
        (if 'c1 then return 'm1 else return 'm0),
       'm0 'm1 'm2 'm3 'c0 'c1      
      )
     )
     ||
     (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
       nf ('otm : bool <- read ('OTMsg-A-B-0['k]), return 'otm, 'otm  )
     )   
     ||
     (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
       nf ('otm : bool <- read ('OTMsg-A-B-1['k]), return 'otm, 'otm  )
     )
     ||
     (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
       nf ('otm : bool <- read ('OTMsg-A-B-2['k]), return 'otm, 'otm  )
     )
     ||
     (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
       nf ('otm : bool <- read ('OTMsg-A-B-3['k]), return 'otm, 'otm  )
     )
     ||
     (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::=
       nf(
       'c0 : bool <- read ('OTChoice-B-A-0['k]),
       return (),
       'c0  
       )
     )
     ||
     (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::=
       nf(
       'c1 : bool <- read ('OTChoice-B-A-1['k]),
       return (),
       'c1  )
     )
   ) *** end group  
 .
 
 *** alice
 
 op alice : -> Protocol .
 eq alice = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  ( *** start new
  aliceInitial 
  ||
  aliceInductive
  ||
  aliceFinal
  ) *** end new
 .
 
 op bob : -> Protocol .
 eq bob =
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
 ( *** start new
  bobInitial 
  ||
  bobInductive
  ||
  bobFinal
  ) *** end new
 .
 
 op real : -> Protocol .
 eq real =
  newfamily ('SendInputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('SendInputShare-B-A)[bound N] 'k (bound N) : bool in
  newfamily ('OTMsg-A-B-0[bound K]) 'k (bound K) : bool in
  newfamily ('OTMsg-A-B-1[bound K]) 'k (bound K) : bool in
  newfamily ('OTMsg-A-B-2[bound K]) 'k (bound K) : bool in
  newfamily ('OTMsg-A-B-3[bound K]) 'k (bound K) : bool in
  newfamily ('OTOut-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('OTChoice-B-A-0[bound K]) 'k (bound K) : bool in
  newfamily ('OTChoice-B-A-1[bound K]) 'k (bound K) : bool in
  newfamily ('SendFinalShare-A[bound K]) 'k (bound K) : bool in
  newfamily ('SendFinalShare-B[bound K]) 'k (bound K) : bool in
  (alice || bob || 1OutOf4)
 .
 
 *******************************
 *** here we restructure real
 *******************************
 
 op restrInitial : -> Protocol .
 eq restrInitial = 
  newfamily ('SendInputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('SendInputShare-B-A[bound N]) 'k (bound N) : bool in
   (aliceInitial || bobInitial)
 . 
 
 op restrInductive : -> Protocol .
 eq restrInductive = 
  newfamily ('OTMsg-A-B-0[bound K]) 'k (bound K) : bool in
  newfamily ('OTMsg-A-B-1[bound K]) 'k (bound K) : bool in
  newfamily ('OTMsg-A-B-2[bound K]) 'k (bound K) : bool in
  newfamily ('OTMsg-A-B-3[bound K]) 'k (bound K) : bool in
  newfamily ('OTOut-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('OTChoice-B-A-0[bound K]) 'k (bound K) : bool in
  newfamily ('OTChoice-B-A-1[bound K]) 'k (bound K) : bool in
  (aliceInductive || bobInductive || 1OutOf4)
 .
 
 op restrFinal : -> Protocol .
 eq restrFinal = 
  newfamily ('SendFinalShare-A[bound K]) 'k (bound K) : bool in
  newfamily ('SendFinalShare-B[bound K]) 'k (bound K) : bool in
   (aliceFinal || bobFinal)
 . 
 
 op restr : -> Protocol .
 eq restr = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial || restrInductive || restrFinal) 
 .
 
 *************************************************
 *** auxiliaries
 *************************************************
 
 op restrInitial1 : -> Protocol .
 eq restrInitial1 =
    newNF({('SendInputShare-A-B[bound M]) 'k : bool} 
          {('SendInputShare-B-A[bound N]) 'k : bool}, 
    (family (('In-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
       nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA  )
    ) 
    || 
    (family (('InRcvd-B ^^ 'B .. 'adv)[bound M]) 'k (bound M) ::= 
       nf('x : bool <- read ('In-B['k]), return (), 'x  )
    ) 
    || 
    (family ('InputShare-A-A[bound N]) 'k (bound N) ::= 
       nf('x : bool <- read ('In-A['k]), samp ('flip < () >), 'x  )
    ) 
    || 
    (family (('InputShare-A-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
      nf('is : bool <- read ('InputShare-A-A['k]), return 'is, 'is  )
    ) 
    ||
    (family ('InputShare-A-B[bound M]) 'k (bound M) ::= 
      nf('sis : bool <- read ('SendInputShare-A-B['k]), return 'sis, 'sis  )
    ) 
    || 
    (family (('InputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::= 
      nf('is : bool <- read ('InputShare-A-B['k]), return 'is, 'is  )
    ) 
    || 
    (family ('InputShare-B-A[bound N]) 'k (bound N) ::= 
      nf('sis : bool <- read ('SendInputShare-B-A['k]), return 'sis, 'sis  )
    ) 
    || 
    (family ('InputShare-B-B[bound M]) 'k (bound M) ::= 
      nf(('x : bool <- read ('In-B['k])) 
          'xa : bool <- read ('InputShare-A-B['k]), 
          return (ap 'xor pair('x, 'xa)), 
          'x 'xa  )
    ) 
    || 
    (family ('SendInputShare-A-B[bound M]) 'k (bound M) ::= 
      nf('x : bool <- read ('In-B['k]), samp ('flip < () >), 'x  )
    ) 
    || 
    (family (('SendInputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::=  
      nf('sis : bool <- read ('InputShare-A-B['k]), return 'sis, 'sis  )
    ) 
    || 
    (family ('SendInputShare-B-A[bound N]) 'k (bound N) ::= 
      nf(('x : bool <- read ('In-A['k])) 
          'xa : bool <- read ('InputShare-A-A['k]), 
          return (ap 'xor pair('x, 'xa)), 
          'x 'xa  )
    ) 
    || 
    (family (('SendInputShare-B-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
      nf('sis : bool <- read ('InputShare-B-A['k]), return 'sis, 'sis  )
    )  , 
    (fam ('SendInputShare-A-B[bound M])) (fam ('SendInputShare-B-A[bound N]))  )   
 .    

 op restrInitial2 : -> Protocol .
 eq restrInitial2 =
    (family (('In-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
       nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA  )
    ) 
    || 
    (family (('InRcvd-B ^^ 'B .. 'adv)[bound M]) 'k (bound M) ::= 
       nf('x : bool <- read ('In-B['k]), return (), 'x  )
    ) 
    || 
    (family ('InputShare-A-A[bound N]) 'k (bound N) ::= 
       nf('x : bool <- read ('In-A['k]), samp ('flip < () >), 'x  )
    ) 
    || 
    (family (('InputShare-A-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
      nf('is : bool <- read ('InputShare-A-A['k]), return 'is, 'is  )
    ) 
    ||
    (family ('InputShare-A-B[bound M]) 'k (bound M) ::=
      nf('x : bool <- read ('In-B['k]), samp ('flip < () >), 'x  )
    ) 
    || 
    (family (('InputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::= 
      nf('is : bool <- read ('InputShare-A-B['k]), return 'is, 'is  )
    ) 
    || 
    (family ('InputShare-B-A[bound N]) 'k (bound N) ::= 
      nf(('x : bool <- read ('In-A['k])) 
          'xa : bool <- read ('InputShare-A-A['k]), 
          return (ap 'xor pair('x, 'xa)), 
          'x 'xa  
        )
    ) 
    || 
    (family ('InputShare-B-B[bound M]) 'k (bound M) ::= 
      nf(('x : bool <- read ('In-B['k])) 
          'xa : bool <- read ('InputShare-A-B['k]), 
          return (ap 'xor pair('x, 'xa)), 
          'x 'xa  )
    ) 
    || 
    (family (('SendInputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::=  
      nf('sis : bool <- read ('InputShare-A-B['k]), return 'sis, 'sis  )
    ) 
    || 
    (family (('SendInputShare-B-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
      nf('sis : bool <- read ('InputShare-B-A['k]), return 'sis, 'sis  )
    )
 .    


********************************
*** splitting restrInductive
********************************

op indAlice : -> Protocol .
eq indAlice = 
family ('indAlice[bound K]) 'k (bound K) ::=
 (
  (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
 ) *** end indAlice
 
.

op indBob : -> Protocol .
eq indBob = 
 family ('indBob[bound K]) 'k (bound K) ::=
 (
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]), 
         return 'is, 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]), 
          return 'is, 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf('xb : bool <- read ('Share-B[fun 'wire0 'k]), 
          return (ap 'neg 'xb), 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
           'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'yb  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
          'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'xb 'yb  )
    )
  ) *** end Share-B
 ) *** end indBob
.

op indAdv : -> Protocol .
eq indAdv = 
 family ('indAdv[bound K]) 'k (bound K) ::=
 (
 (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire0 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv
 ) *** end indAdv
. 

op ind1OutOf4OT : -> Protocol .
eq ind1OutOf4OT = 
 family ('ind1OutOf4OT[bound K]) 'k (bound K) ::=
 (
  (family ('OTChoice-B-A-0[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire0 'k]), 
         return 'sb, 'sb  )
    ) 
    ;; 
    (otherwise --> 
      nf('otc : bool <- read ('OTChoice-B-A-0['k]), 
         return 'otc, 'otc  )
    )
  ) *** end OTChoice-0
  ||
  (family ('OTChoice-B-A-1[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return 'sb, 'sb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otc : bool <- read ('OTChoice-B-A-1['k]), return 'otc, 'otc  )
   )
  ) *** end OTChoice-1
  ||
  (family ('OTMsg-A-B-0[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return 'ba, 'ba 'xa 'ya  )
    ) 
    ;; 
    (otherwise --> 
      nf('otm : bool <- read ('OTMsg-A-B-0['k]), return 'otm, 'otm  )
    )
  ) *** end msg-0
  ||
  (family ('OTMsg-A-B-1[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('otm : bool <- read ('OTMsg-A-B-1['k]), return 'otm, 'otm  )
   )
  ) *** end msg-1
  ||
  (family ('OTMsg-A-B-2[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('otm : bool <- read ('OTMsg-A-B-2['k]), return 'otm, 'otm  )
   )
  ) *** end msg-2
  || 
  (family ('OTMsg-A-B-3[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
         'ba 'xa 'ya  )
    ) 
    ;; 
    (otherwise --> 
      nf('otm : bool <- read ('OTMsg-A-B-3['k]), return 'otm, 'otm  )
    )
  ) *** end msg-3
  ||
  (family ('OTOut-B-A[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
          'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                              ap 'xor pair(ap 'and pair('xa, 'yb), 
                                           ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
    ) 
    ;;
    (otherwise --> 
       nf(('c0 : bool <- read ('OTChoice-B-A-0['k])) 
          ('c1 : bool <- read ('OTChoice-B-A-1['k])) 
          ('m0 : bool <- read ('OTMsg-A-B-0['k])) 
          ('m1 : bool <- read ('OTMsg-A-B-1['k])) 
          ('m2 : bool <- read ('OTMsg-A-B-2['k])) 
           'm3 : bool <- read ('OTMsg-A-B-3['k]), 
           if 'c0 then
               if 'c1 then return 'm3 
                      else return 'm2 
                  else 
               if 'c1 then return 'm1 
                      else return 'm0, 
          'm0 'm1 'm2 'm3 'c0 'c1  )
    )
  ) *** end out
 ) *** end 1OutOf4OT
.

op restrIndSplit : -> Protocol .
eq restrIndSplit =
  newfamily ('OTMsg-A-B-0[bound K]) 'k (bound K) : bool in
  newfamily ('OTMsg-A-B-1[bound K]) 'k (bound K) : bool in
  newfamily ('OTMsg-A-B-2[bound K]) 'k (bound K) : bool in
  newfamily ('OTMsg-A-B-3[bound K]) 'k (bound K) : bool in
  newfamily ('OTOut-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('OTChoice-B-A-0[bound K]) 'k (bound K) : bool in
  newfamily ('OTChoice-B-A-1[bound K]) 'k (bound K) : bool in
    (indAlice || indBob || indAdv || ind1OutOf4OT)
.

op restrIndSplitSym : -> Protocol .
eq restrIndSplitSym =
  (indAlice || indBob || indAdv )
.

op restrIndSplitSymNew : -> Protocol .
eq restrIndSplitSymNew = 
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K])'k (bound K) : unit in
  (
  restrIndSplitSym
  ||
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb  )
  )
  ||
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
    nf('bb : bool <- read ('OTBit-B-A['k]), return (), 'bb  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
  ||
  (family ('ShareOK-B[bound K]) 'k (bound K) ::= 
    nf('xb : bool <- read ('Share-B['k]), return (), 'xb  )
  )
  )
.  

op restrIndSplitSymNew1 : -> Protocol .
eq restrIndSplitSymNew1 = 
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M])'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  indAlice 
  ||
  indBob 
  ||
  indAdv1
  ||
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb  )
  )
  ||
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
    nf('bb : bool <- read ('OTBit-B-A['k]), return (), 'bb  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
  ||
  (family ('ShareOK-B[bound K]) 'k (bound K) ::= 
    nf('xb : bool <- read ('Share-B['k]), return (), 'xb  )
  )

  )
.  

*** more sym protocols

*** indAdv1

op indAdv1 : -> Protocol .
eq indAdv1 = 
(
  family ('indAdv[bound K]) 'k (bound K) ::=
 (
 (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
  )
  )
  .

*** indAdv2 
op indAdv2 : -> Protocol .
eq indAdv2 = 
(
  family ('indAdv[bound K]) 'k (bound K) ::=
 (
 (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
  )
  )
  .

*** indBob1

op indBob1 : -> Protocol .
eq indBob1 = 
 family ('indBob[bound K]) 'k (bound K) ::=
 (
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'x 'yb 'y  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'b 'xb 'x 'yb 'y  )
    )
  ) *** end Share-B
 ) *** end indBob1
.

*** indBob2
 
op indBob2 : -> Protocol .
eq indBob2 = 
 family ('indBob[bound K]) 'k (bound K) ::=
 (
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
 ) *** end indBob2
.
 
*** indBob3
 
op indBob3 : -> Protocol .
eq indBob3 = 
 family ('indBob[bound K]) 'k (bound K) ::=
 (
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    nf(('xa : bool <- read ('Share-A['k])) 
       'x : bool <- read ('Wire['k]), 
      return (ap 'xor pair('xa, 'x)), 'xa 'x  )
  ) *** end Share-B
 ) *** end indBob3
.
 
 
*** new2

op new2 : -> Protocol .
eq new2 =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb  )
  )
  ||
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
    nf('bb : bool <- read ('OTBit-B-A['k]), return (), 'bb  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
  ||
  (family ('ShareOK-B[bound K]) 'k (bound K) ::= 
    nf('xb : bool <- read ('Share-B['k]), return (), 'xb  )
  ) 
  ) *** end new
.

*** new3

 op bobOKInt : -> Protocol .
 eq bobOKInt =  
  family ('BobOK[bound K]) 'k (bound K) ::=
   ( *** start bobok
   (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba 'xa 'ya 'xb 'yb  
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot  )
     )
   )
   ||
   (family ('ShareOK-B[bound K]) 'k (bound K) ::=
     nf('xb : bool <- read ('Share-B['k]), return (), 'xb  )
   )
   
   ) *** end bobokint
 . 

 op bobOK : -> Protocol .
 eq bobOK =  
  family ('BobOK[bound K]) 'k (bound K) ::=
   ( *** start bobok
   (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba 'xa 'ya 'xb 'yb  
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot  )
     )
   )
   ||
   (family ('ShareOK-B[bound K]) 'k (bound K) ::=
     (when (apply 'isAliceInput 'k) --> 
          nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
          nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]),
             return 'xb,
             'xb  )
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
          return (),
          'xb 'yb   
          )
        )
        ;;
        (when (apply 'isAndGate 'k) --> 
          nf(
          ('bb : unit <- read ('OTBitOK-B-A['k]))
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
          return (),
          'bb 'xb 'yb  
          )
        )
   )
   
   ) *** end bobok
 . 
 
 op bobOKBase : -> Protocol .
 eq bobOKBase =  
  family ('BobOK[bound K]) 'k (bound K) ::=
   ( *** start bobok
   (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba 'xa 'ya 'xb 'yb  
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot  )
     )
   )
   ||
   ('ShareOK-B[0] ::=
      (when (apply 'isAliceInput 0) --> 
          nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 0]), 
             return 'is, 'is  )
       )
        ;;
        (when (apply 'isBobInput 0) --> 
          nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 0]), 
             return 'is, 'is  )
        )      
   )
   
   ) *** end bobokbase
 . 
 
 op bobOKInd : -> Protocol .
 eq bobOKInd =  
  family ('BobOK[bound K]) 'k (bound K) ::=
   ( *** start bobok
   (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba 'xa 'ya 'xb 'yb  
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot  )
     )
   )
   ||
   ('ShareOK-B['B] ::=
      (when (apply 'isAliceInput 'B) --> 
          nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 'B]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isBobInput 'B) --> 
          nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 'B]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isNotGate 'B) --> 
          nf('xb : unit <- read ('ShareOK-B[fun 'wire0 'B]),
             return 'xb,
             'xb  )
        )
        ;;
        (when (apply 'isXorGate 'B) --> 
          nf(
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'B])) ,
          return (),
          'xb 'yb   
          )
        )
        ;;
        (when (apply 'isAndGate 'B) --> 
          nf(
          ('bb : unit <- read ('OTBitOK-B-A['B]))
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B]))
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'B])) ,
          return (),
          'bb 'xb 'yb  
          )
        )   
   )
   ||
   (family ('ShareOK-B[bound 'B]) 'k (bound 'B) ::= 
      nf('xb : bool <- read ('Share-B['k]), 
     return (), 'xb  )
   )
   
   ) *** end bobokind
 .
 
 op new3Int : -> Protocol .
 eq new3Int =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  bobOKInt
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb  )
  )
  ||
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
  ) *** end new
.
 
 op new3 : -> Protocol .
 eq new3 =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb  )
  )
  ||
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
  ) *** end new
.

op bobOKOT : -> Protocol .
eq bobOKOT =  
   ('OTBitOK-B-A[ 'B ] ::= 
      nf('bb : bool <- read ('OTBit-B-A['B]), 
        return (),
        'bb  )
   )
   ||
   ('ShareOK-B[ 'B] ::= 
              (when (apply 'isAliceInput 'B) --> 
          nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 'B]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isBobInput 'B) --> 
          nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 'B]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isNotGate 'B) --> 
          nf('xb : unit <- read ('ShareOK-B[fun 'wire0 'B]),
             return 'xb,
             'xb  )
        )
        ;;
        (when (apply 'isXorGate 'B) --> 
          nf(
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'B])) ,
          return (),
          'xb 'yb   
          )
        )
        ;;
        (when (apply 'isAndGate 'B) --> 
          nf(
          ('bb : unit <- read ('OTBitOK-B-A['B]))
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B]))
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'B])) ,
          return (),
          'bb 'xb 'yb  
          )
        )
   )
   ||
  ***  start group
  *** family ('BobOK[bound K]) 'k (bound 'B) ::= 
   (
   (family ('OTBitOK-B-A[bound K]) 'k (bound 'B) ::= 
     nf('bb : bool <- read ('OTBit-B-A['k]), 
        return (),
        'bb  )
   )
   ||
   (family ('ShareOK-B[bound K]) 'k (bound 'B) ::=
     nf('xb : bool <- read ('Share-B['k]), 
     return (), 'xb  )
   )
   )
  *** ) *** end group
 .

op bobOKOT3IndStart : -> Protocol .
eq bobOKOT3IndStart  =  
   ('OTBitOK-B-A[ 'B ] ::= 
      (when (apply 'isAndGate 'B) --> 
      nf(('ba : unit <- read ('OTBitOK-A-B['B])) 
         ('xa : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
         ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B]))
         ('ya : unit <- read ('ShareOK-A[fun 'wire1 'B])) 
         ('yb : unit <- read ('ShareOK-B[fun 'wire1 'B])), 
         return (), 
         'ba 'xa 'ya 'xb 'yb  )
    ) 
    ;; 
    (otherwise --> 
      nf('ot : unit <- read ('OTBitOK-B-A['B]), 
         return 'ot, 'ot  )
    )
   )
   ||
   ('ShareOK-B[ 'B] ::= 
              (when (apply 'isAliceInput 'B) --> 
          nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 'B]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isBobInput 'B) --> 
          nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 'B]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isNotGate 'B) --> 
          nf('xb : unit <- read ('ShareOK-B[fun 'wire0 'B]),
             return 'xb,
             'xb  )
        )
        ;;
        (when (apply 'isXorGate 'B) --> 
          nf(
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'B])) ,
          return (),
          'xb 'yb   
          )
        )
        ;;
        (when (apply 'isAndGate 'B) --> 
          nf(
          ('bb : unit <- read ('OTBitOK-B-A['B]))
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B]))
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'B])) ,
          return (),
          'bb 'xb 'yb  
          )
        )
   )
   ||
   ( *** start group
   family ('BobOK[bound 'B]) 'k (bound 'B) ::= 
   (
   (family ('OTBitOK-B-A[bound 'B]) 'k (bound 'B) ::= 
     nf('bb : bool <- read ('OTBit-B-A['k]), 
        return (),
        'bb  )
   )
   ||
   (family ('ShareOK-B[bound 'B]) 'k (bound 'B) ::=
     nf('xb : bool <- read ('Share-B['k]), 
     return (), 'xb  )
   )
   )
   ) *** end group

 .

*** induction proof starts with this term
op new3OTIndStart : -> Protocol .
eq new3OTIndStart = 
  bobOKOT3IndStart
  ||
  *** indAlice
  (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
   ) *** end share-A
 || 
  *** indBob1
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'x 'yb 'y  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'b 'xb 'x 'yb 'y  )
    )
  ) *** end Share-B
 ||
  *** indAdv1
  (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv ; end of indAdv1, the rest are the internals
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb  )
  )
  ||
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
.

op bobOKOT3IndEnd : -> Protocol .
eq bobOKOT3IndEnd  =  
   ('OTBitOK-B-A[ 'B ] ::= 
      nf('bb : bool <- read ('OTBit-B-A['B]), 
        return (),
        'bb  )
   )
   ||
   ('ShareOK-B[ 'B] ::= 
             nf('xb : bool <- read ('Share-B['B]), 
     return (), 'xb  )
   )
   ||
   ( *** start group
   family ('BobOK[bound 'B]) 'k (bound 'B) ::= 
   (
   (family ('OTBitOK-B-A[bound 'B]) 'k (bound 'B) ::= 
     nf('bb : bool <- read ('OTBit-B-A['k]), 
        return (),
        'bb  )
   )
   ||
   (family ('ShareOK-B[bound 'B]) 'k (bound 'B) ::=
     nf('xb : bool <- read ('Share-B['k]), 
     return (), 'xb  )
   )
   )
   ) *** end group

 .


*** induction proof ends with this term
op new3OTIndEnd : -> Protocol .
eq new3OTIndEnd = 
  bobOKOT3IndEnd
  ||
  *** indAlice
  (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
   ) *** end share-A
 || 
  *** indBob1
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'x 'yb 'y  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'b 'xb 'x 'yb 'y  )
    )
  ) *** end Share-B
 ||
  *** indAdv1
  (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('TBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv ; end of indAdv1, the rest are the internals
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb  )
  )
  ||
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
.


*** intermediate induction protocol

op new3OT : -> Protocol .
eq new3OT = 
  bobOKOT
  ||
  *** indAlice
  (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
   ) *** end share-A
 || 
  *** indBob1
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'x 'yb 'y  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'b 'xb 'x 'yb 'y  )
    )
  ) *** end Share-B
 ||
  *** indAdv1
  (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv ; end of indAdv1, the rest are the internals
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb  )
  )
  ||
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
.

op bobOKOTInd : -> Protocol .
eq bobOKOTInd =  
   ('OTBitOK-B-A[ 'B ] ::= 
      nf('bb : bool <- read ('OTBit-B-A['B]), 
        return (),
        'bb  )
   )
   ||
   ('ShareOK-B[ 'B] ::= 
       nf('xb : bool <- read ('Share-B['B]), 
          return (), 'xb  )       
   )
   ||
   (family ('OTBitOK-B-A[bound 'B]) 'k (bound 'B) ::= 
     nf('bb : bool <- read ('OTBit-B-A['k]), 
        return (),
        'bb  )
   )
   ||
   (family ('ShareOK-B[bound 'B]) 'k (bound 'B) ::=
     nf('xb : bool <- read ('Share-B['k]), 
     return (), 'xb  )
   )

 .


op new3OTInd : -> Protocol .
eq new3OTInd = 
  bobOKOTInd
  ||
  *** indAlice
  (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
   ) *** end share-A
 || 
  *** indBob1
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'x 'yb 'y  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'b 'xb 'x 'yb 'y  )
    )
  ) *** end Share-B
 ||
  *** indAdv1
  (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv ; end of indAdv1, the rest are the internals
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb  )
  )
  ||
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
.


op new3Base : -> Protocol .
eq new3Base =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  new 'ShareOK-B[0] : unit in
  (
  bobOKBase
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb  )
  )
  ||
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
  ) *** end new
.

op new3Ind : -> Protocol .
 eq new3Ind =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  bobOKInd
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb  )
  )
  ||
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
  ) *** end new
.

op new3Base0 : -> Protocol .
 eq new3Base0 =
  ('ShareOK-B[0] ::= 
  nf('xb : bool <- read ('Share-B[0]), 
     return (), 'xb  )
)
||
(family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba 'xa 'ya 'xb 'yb  
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot  )
     )
   )
||
(family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb  )
  )
  ||
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
  ||
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'x 'yb 'y  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'b 'xb 'x 'yb 'y  )
    )
  ) *** end Share-B
  ||
  (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
 ||
  (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
.  

op new3Ind0 : -> Protocol .
 eq new3Ind0 =
  ('ShareOK-B['B] ::= 
  nf('xb : bool <- read ('Share-B['B]), 
     return (), 'xb  )
)
||
(family ('ShareOK-B[bound K]) 'k (bound 'B) ::=
  nf('xb : bool <- read ('Share-B['k]), 
     return (), 'xb  )
)
||
(family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba 'xa 'ya 'xb 'yb  
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot  )
     )
   )
||
(family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb  )
  )
  ||
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
  ||
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'x 'yb 'y  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'b 'xb 'x 'yb 'y  )
    )
  ) *** end Share-B
  ||
  (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
 ||
  (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
.  

 
*** new4 

 op new4 : -> Protocol .
 eq new4 =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x 'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x 'xa  )
  )
  ||
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
  ) *** end new
.

*** new4Int

 op new4Int : -> Protocol .
 eq new4Int =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  aliceOKInt 
  ||
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x 'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x 'xa  )
  )
  ) *** end new
.

op aliceOKInt : -> Protocol .
 eq aliceOKInt = 
  family ('AliceOK[bound K]) 'k 'k (bound K) ::=
   ( *** start aliceok
   (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( 
           ('ak : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('al : unit <- read ('ShareOK-A[fun 'wire1 'k])),
           return (),
           'ak 'al  
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-A-B['k]), 
                      return 'ot,
                      'ot  )
     )
   )
   ||
   (family ('ShareOK-A[bound K]) 'k (bound K) ::=
     nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
   )
   ) *** end aliceok
 .
*** new5base

op new5base : -> Protocol .
eq new5base =

 ('ShareOK-A[0] ::= 
   nf('xa : bool <- read ('Share-A[0]), 
      return (), 'xa  
     )
 )
 ||
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
   nf('x : bool <- read ('In-A['k]), return (), 'x  )
 ) 
 || 
 (family ('InOK-B[bound M]) 'k (bound M) ::= 
   nf('x : bool <- read ('In-B['k]), return (), 'x  )
 ) 
 || 
 (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
   nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
 ) 
 || 
 (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
   nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
 ) 
 || 
 (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
   nf(('x : unit <- read ('InOK-A['k])) 
       'xa : unit <- read ('InputShareOK-A-A['k]), 
       return (), 
       'x 'xa  )
 ) 
 || 
 (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
   nf(('x : unit <- read ('InOK-B['k])) 
       'xa : unit <- read ('InputShareOK-A-B['k]), 
       return (), 'x 'xa  )
 ) 
 || 
 (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-A-B['k]),
         return 'otb, 'otb  ))
) 
|| 
(family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf('otb : bool <- read ('OTBit-A-B['k]), 
       return 'otb, 'otb  )
  ) 
  ;; 
  (otherwise --> 
    nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
       return 'otb, 'otb  ))
) 
|| 
(family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                               ap 'and pair('xb, 'ya)))),
        'ba 'xa 'ya 'xb 'yb  )
  ) 
  ;; 
  (otherwise --> 
    nf('otb : bool <- read ('OTBit-B-A['k]), 
       return 'otb, 'otb  )
  )
) 
|| 
(family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
        'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
        return (), 'ak 'al  )
  ) 
  ;; 
  (otherwise --> nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot  )
  )
) 
|| 
(family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : unit <- read ('OTBitOK-A-B['k])) 
       ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
       ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'ba 'xa 'ya 'xb 'yb  )
  ) 
  ;; 
  (otherwise --> 
    nf('ot : unit <- read ('OTBitOK-B-A['k]), 
       return 'ot, 'ot  )
  )
) 
|| 
(family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
        return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
)    
|| 
(family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
       return (), 'sb  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  ))
) 
|| 
(family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return 'ba, 'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  ))
) 
|| 
(family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family ('Share-A[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
       return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
       return 'sa, 'sa  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba 'xa 'ya  )
  )
) 
|| 
(family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
  nf('sa : bool <- read ('Share-A['k]), 
     return 'sa, 'sa  )
) 
|| 
(family ('Share-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
        return 'is, 'x 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
    nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
        return 'is, 'x 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'xb : bool <- read ('Share-B[fun 'wire0 'k]),
        return (ap 'neg 'xb), 'x 'xb  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('xb, 'yb)), 
        'xb 'x 'yb 'y  )
  ) 
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb 'b 'xb 'x 'yb 'y  )
  ) 
)
|| 
(family ('ShareOK-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
       return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
       return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
       return 'xb, 'xb  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'xb 'yb  )
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('bb : unit <- read ('OTBitOK-B-A['k])) 
       ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'bb 'xb 'yb  ) 
  )
)
.

*** new5step

op new5step : -> Protocol .
eq new5step =
 
 ('ShareOK-A['B] ::= 
   nf('xa : bool <- read ('Share-A['B]), 
      return (), 'xa  
     )
 )
 ||
 (family ('ShareOK-A[bound K]) 'k (bound 'B) ::=
   nf('xa : bool <- read ('Share-A['k]),
      return (), 'xa  
     )
 ) 
 ||
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
   nf('x : bool <- read ('In-A['k]), return (), 'x  )
 ) 
 || 
 (family ('InOK-B[bound M]) 'k (bound M) ::= 
   nf('x : bool <- read ('In-B['k]), return (), 'x  )
 ) 
 || 
 (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
   nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
 ) 
 || 
 (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
   nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
 ) 
 || 
 (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
   nf(('x : unit <- read ('InOK-A['k])) 
       'xa : unit <- read ('InputShareOK-A-A['k]), 
       return (), 
       'x 'xa  )
 ) 
 || 
 (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
   nf(('x : unit <- read ('InOK-B['k])) 
       'xa : unit <- read ('InputShareOK-A-B['k]), 
       return (), 'x 'xa  )
 ) 
 || 
 (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-A-B['k]),
         return 'otb, 'otb  ))
) 
|| 
(family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf('otb : bool <- read ('OTBit-A-B['k]), 
       return 'otb, 'otb  )
  ) 
  ;; 
  (otherwise --> 
    nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
       return 'otb, 'otb  ))
) 
|| 
(family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                               ap 'and pair('xb, 'ya)))),
        'ba 'xa 'ya 'xb 'yb  )
  ) 
  ;; 
  (otherwise --> 
    nf('otb : bool <- read ('OTBit-B-A['k]), 
       return 'otb, 'otb  )
  )
) 
|| 
(family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
        'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
        return (), 'ak 'al  )
  ) 
  ;; 
  (otherwise --> nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot  )
  )
) 
|| 
(family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : unit <- read ('OTBitOK-A-B['k])) 
       ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
       ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'ba 'xa 'ya 'xb 'yb  )
  ) 
  ;; 
  (otherwise --> 
    nf('ot : unit <- read ('OTBitOK-B-A['k]), 
       return 'ot, 'ot  )
  )
) 
|| 
(family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
        return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
)    
|| 
(family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
       return (), 'sb  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  ))
) 
|| 
(family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return 'ba, 'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  ))
) 
|| 
(family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family ('Share-A[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
       return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
       return 'sa, 'sa  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba 'xa 'ya  )
  )
) 
|| 
(family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
  nf('sa : bool <- read ('Share-A['k]), 
     return 'sa, 'sa  )
) 
|| 
(family ('Share-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
        return 'is, 'x 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
    nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
        return 'is, 'x 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'xb : bool <- read ('Share-B[fun 'wire0 'k]),
        return (ap 'neg 'xb), 'x 'xb  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('xb, 'yb)), 
        'xb 'x 'yb 'y  )
  ) 
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb 'b 'xb 'x 'yb 'y  )
  ) 
)
|| 
(family ('ShareOK-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
       return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
       return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
       return 'xb, 'xb  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'xb 'yb  )
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('bb : unit <- read ('OTBitOK-B-A['k])) 
       ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'bb 'xb 'yb  ) 
  )
)
.

*** new4Intstep

op new4Intstep : -> Protocol .
eq new4Intstep =
 
 ('ShareOK-A['B] ::= 
     nf(('ba : unit <- read ('OTBitOK-A-B['B ])) 
       ('xa : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
        'ya : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
        return (), 'ba 'xa 'ya  )
 )
 ||
 (family ('ShareOK-A[bound K]) 'k (bound 'B) ::=
   nf('xa : bool <- read ('Share-A['k]),
      return (), 'xa  
     )
 ) 
 ||
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
   nf('x : bool <- read ('In-A['k]), return (), 'x  )
 ) 
 || 
 (family ('InOK-B[bound M]) 'k (bound M) ::= 
   nf('x : bool <- read ('In-B['k]), return (), 'x  )
 ) 
 || 
 (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
   nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
 ) 
 || 
 (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
   nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
 ) 
 || 
 (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
   nf(('x : unit <- read ('InOK-A['k])) 
       'xa : unit <- read ('InputShareOK-A-A['k]), 
       return (), 
       'x 'xa  )
 ) 
 || 
 (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
   nf(('x : unit <- read ('InOK-B['k])) 
       'xa : unit <- read ('InputShareOK-A-B['k]), 
       return (), 'x 'xa  )
 ) 
 || 
 (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-A-B['k]),
         return 'otb, 'otb  ))
) 
|| 
(family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf('otb : bool <- read ('OTBit-A-B['k]), 
       return 'otb, 'otb  )
  ) 
  ;; 
  (otherwise --> 
    nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
       return 'otb, 'otb  ))
) 
|| 
(family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                               ap 'and pair('xb, 'ya)))),
        'ba 'xa 'ya 'xb 'yb  )
  ) 
  ;; 
  (otherwise --> 
    nf('otb : bool <- read ('OTBit-B-A['k]), 
       return 'otb, 'otb  )
  )
) 
|| 
(family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
        'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
        return (), 'ak 'al  )
  ) 
  ;; 
  (otherwise --> nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot  )
  )
) 
|| 
(family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : unit <- read ('OTBitOK-A-B['k])) 
       ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
       ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'ba 'xa 'ya 'xb 'yb  )
  ) 
  ;; 
  (otherwise --> 
    nf('ot : unit <- read ('OTBitOK-B-A['k]), 
       return 'ot, 'ot  )
  )
) 
|| 
(family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
        return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
)    
|| 
(family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
       return (), 'sb  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  ))
) 
|| 
(family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return 'ba, 'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  ))
) 
|| 
(family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family ('Share-A[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
       return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
       return 'sa, 'sa  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba 'xa 'ya  )
  )
) 
|| 
(family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
  nf('sa : bool <- read ('Share-A['k]), 
     return 'sa, 'sa  )
) 
|| 
(family ('Share-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
        return 'is, 'x 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
    nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
        return 'is, 'x 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'xb : bool <- read ('Share-B[fun 'wire0 'k]),
        return (ap 'neg 'xb), 'x 'xb  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('xb, 'yb)), 
        'xb 'x 'yb 'y  )
  ) 
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb 'b 'xb 'x 'yb 'y  )
  ) 
)
|| 
(family ('ShareOK-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
       return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
       return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
       return 'xb, 'xb  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'xb 'yb  )
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('bb : unit <- read ('OTBitOK-B-A['k])) 
       ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'bb 'xb 'yb  ) 
  )
)
.

*** new5

 op new5 : -> Protocol .
 eq new5 =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  aliceOK
  ||
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x 'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x 'xa  )
  )
  ) *** end new
.

*** for the induction proof
*** new5IndInt

op aliceOKIndInt : -> Protocol .
eq aliceOKIndInt = 
  ('OTBitOK-A-B['B] ::=
    nf('ba : bool <- read ('OTBit-A-B['B]), 
        return (), 'ba  )
  )
  ||
  ('ShareOK-A['B] ::= 
        (when (apply 'isAliceInput 'B) --> 
          nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 'B]),
             return 'is,
             'is  )
        )
        ;;
        (when (apply 'isBobInput 'B) --> 
          nf(
           'is : unit <- read ('InputShareOK-A-B[fun 'wire0 'B]),
           return 'is,
           'is  
          )
        )
        ;;
        (when (apply 'isNotGate 'B) --> 
          nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'B]),
             return 'sa,
             'sa  
            )
        )
        ;;
        (when (apply 'isXorGate 'B) --> 
          nf(
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'B]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'B])),
           return (),
           'xa 'ya  
          )
        )
        ;;
        (when (apply 'isAndGate 'B) -->
          nf( 
          ('ba : unit <- read ('OTBitOK-A-B['B]))
          ('xa : unit <- read ('ShareOK-A[fun 'wire0 'B]))
          ('ya : unit <- read ('ShareOK-A[fun 'wire1 'B])),
          return (),
          'ba 'xa 'ya  
          )
        )
  )
  ||
  ( *** group start
  family ('AliceOK[bound K]) 'k 'k (bound 'B) ::=
   ( *** start aliceok
   (family ('OTBitOK-A-B[bound K]) 'k (bound 'B) ::= 
     nf('ba : bool <- read ('OTBit-A-B['k]), 
        return (), 'ba  )
   )
   ||
   (family ('ShareOK-A[bound K]) 'k (bound 'B) ::=
     nf('xa : bool <- read ('Share-A['k]), 
        return (), 'xa  )
   )
   ) *** end aliceok
  ) *** group end 
 .

 op new5IndInt : -> Protocol .
 eq new5IndInt =
  (
  aliceOKIndInt
  ||
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x 'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x 'xa  )
  )
  ) *** end new
.

*** new5IndStart

op aliceOKIndStart : -> Protocol .
eq aliceOKIndStart = 
  ('OTBitOK-A-B['B] ::=
    (when (apply 'isAndGate 'B) -->
       nf( 
           ('ak : unit <- read ('ShareOK-A[fun 'wire0 'B]))
           ('al : unit <- read ('ShareOK-A[fun 'wire1 'B])),
           return (),
           'ak 'al  
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-A-B['B]), 
                      return 'ot,
                      'ot  )
     )
  )
  ||
  ('ShareOK-A['B] ::= 
        (when (apply 'isAliceInput 'B) --> 
          nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 'B]),
             return 'is,
             'is  )
        )
        ;;
        (when (apply 'isBobInput 'B) --> 
          nf(
           'is : unit <- read ('InputShareOK-A-B[fun 'wire0 'B]),
           return 'is,
           'is  
          )
        )
        ;;
        (when (apply 'isNotGate 'B) --> 
          nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'B]),
             return 'sa,
             'sa  
            )
        )
        ;;
        (when (apply 'isXorGate 'B) --> 
          nf(
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'B]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'B])),
           return (),
           'xa 'ya  
          )
        )
        ;;
        (when (apply 'isAndGate 'B) -->
          nf( 
          ('ba : unit <- read ('OTBitOK-A-B['B]))
          ('xa : unit <- read ('ShareOK-A[fun 'wire0 'B]))
          ('ya : unit <- read ('ShareOK-A[fun 'wire1 'B])),
          return (),
          'ba 'xa 'ya  
          )
        )
  )
  ||
  ( *** group start
  family ('AliceOK[bound K]) 'k 'k (bound 'B) ::=
   ( *** start aliceok
   (family ('OTBitOK-A-B[bound K]) 'k (bound 'B) ::= 
     nf('ba : bool <- read ('OTBit-A-B['k]), 
        return (), 'ba  )
   )
   ||
   (family ('ShareOK-A[bound K]) 'k (bound 'B) ::=
     nf('xa : bool <- read ('Share-A['k]), 
        return (), 'xa  )
   )
   ) *** end aliceok
  ) *** group end 
 .

 op new5IndStart : -> Protocol .
 eq new5IndStart =
  (
  aliceOKIndStart
  ||
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x 'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x 'xa  )
  )
  ) *** end new
.


*** new5IndEnd
op aliceOKIndEnd : -> Protocol .
eq aliceOKIndEnd = 
  ('OTBitOK-A-B['B] ::=
     nf('ba : bool <- read ('OTBit-A-B['B]), 
        return (), 'ba  )
  )
  ||
  ('ShareOK-A['B] ::= 
     nf('xa : bool <- read ('Share-A['B]), 
        return (), 'xa  )  
  )
  ||
  ( *** group start
  family ('AliceOK[bound K]) 'k 'k (bound 'B) ::=
   ( *** start aliceok
   (family ('OTBitOK-A-B[bound K]) 'k (bound 'B) ::= 
     nf('ba : bool <- read ('OTBit-A-B['k]), 
        return (), 'ba  )
   )
   ||
   (family ('ShareOK-A[bound K]) 'k (bound 'B) ::=
     nf('xa : bool <- read ('Share-A['k]), 
        return (), 'xa  )
   )
   ) *** end aliceok
  ) *** group end 
 .

 op new5IndEnd : -> Protocol .
 eq new5IndEnd =
  (
  aliceOKIndEnd
  ||
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x 'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x 'xa  )
  )
  ) *** end new
.

*** new5Ind0
op aliceOKInd0 : -> Protocol .
eq aliceOKInd0 = 
  ('OTBitOK-A-B['B] ::=
     nf('ba : bool <- read ('OTBit-A-B['B]), 
        return (), 'ba  )
  )
  ||
  ('ShareOK-A['B] ::= 
     nf('xa : bool <- read ('Share-A['B]), 
        return (), 'xa  )  
  )
  ||
   (family ('OTBitOK-A-B[bound K]) 'k (bound 'B) ::= 
     nf('ba : bool <- read ('OTBit-A-B['k]), 
        return (), 'ba  )
   )
   ||
   (family ('ShareOK-A[bound K]) 'k (bound 'B) ::=
     nf('xa : bool <- read ('Share-A['k]), 
        return (), 'xa  )
   )
 .

 op new5Ind0 : -> Protocol .
 eq new5Ind0 =
 ***(
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
 ) 
  (
  aliceOKInd0
  ||
  *** bobOK
  (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba 'xa 'ya 'xb 'yb  
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot  )
     )
   )
   ||
   (family ('ShareOK-B[bound K]) 'k (bound K) ::=
     (when (apply 'isAliceInput 'k) --> 
          nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
          nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]),
             return 'xb,
             'xb  )
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
          return (),
          'xb 'yb   
          )
        )
        ;;
        (when (apply 'isAndGate 'k) --> 
          nf(
          ('bb : unit <- read ('OTBitOK-B-A['k]))
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
          return (),
          'bb 'xb 'yb  
          )
        )
   )
  ||
  *** indAlice
  (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
 || 
 *** indBob1
 (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'x 'yb 'y  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'b 'xb 'x 'yb 'y  )
    )
  ) *** end Share-B
 ||
 *** indAdv1
 (
 (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
  )
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x 'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x 'xa  )
  )
  ) *** end new
.


 
*** new6

 op new6 : -> Protocol .
 eq new6 =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  aliceOK
  ||
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('x : unit <- read ('InOK-A['k]), return 'x, 'x  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('x : unit <- read ('InOK-B['k]), return 'x, 'x  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x 'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x 'xa  )
  )
  ) *** end new
. 

*** new7

 op new7 : -> Protocol .
 eq new7 =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  ( *** start new
  aliceOK
  ||
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('x : unit <- read ('InOK-A['k]), return 'x, 'x  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('x : unit <- read ('InOK-B['k]), return 'x, 'x  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 

*** new7indstart

op bobOK7IndStart : -> Protocol .
eq bobOK7IndStart =  
   ('OTBitOK-B-A[ 'B ] ::= 
      (when (apply 'isAndGate 'B) --> 
      nf(('ba : unit <- read ('OTBitOK-A-B['B])) 
         ('xa : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
         ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
         ('ya : unit <- read ('ShareOK-A[fun 'wire1 'B])) 
          'yb : unit <- read ('ShareOK-B[fun 'wire1 'B]), 
         return (), 
         'ba 'xa 'ya 'xb 'yb  )
      ) 
      ;; 
      (otherwise --> 
        nf('ot : unit <- read ('OTBitOK-B-A['B]), 
           return 'ot, 'ot  )
      )
   )
   ||
   ('ShareOK-B[ 'B] ::= 
        (when (apply 'isAliceInput 'B) --> 
          nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 'B]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isBobInput 'B) --> 
          nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 'B]), 
             return 'is, 'is  )
        )
        ;;
        (when (apply 'isNotGate 'B) --> 
          nf('xb : unit <- read ('ShareOK-B[fun 'wire0 'B]),
             return 'xb,
             'xb  )
        )
        ;;
        (when (apply 'isXorGate 'B) --> 
          nf(
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'B])) ,
          return (),
          'xb 'yb   
          )
        )
        ;;
        (when (apply 'isAndGate 'B) --> 
          nf(
          ('bb : unit <- read ('OTBitOK-B-A['B]))
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B]))
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'B])) ,
          return (),
          'bb 'xb 'yb  
          )
        )
   )
   ||
  ***  start group
  (family ('BobOK[bound K]) 'k (bound 'B) ::= 
   (
   (family ('OTBitOK-B-A[bound K]) 'k (bound 'B) ::= 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), 
        return 'ot, 'ot  )
   )
   ||
   (family ('ShareOK-B[bound K]) 'k (bound 'B) ::=
     nf('sa : unit <- read ('ShareOK-A['k]), 
        return 'sa, 'sa  )
   )
   )
  ) *** end group
 .

op new7IndStart : -> Protocol .
eq new7IndStart =
  (
  aliceOK
  ||
  bobOK7IndStart
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('x : unit <- read ('InOK-A['k]), return 'x, 'x  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('x : unit <- read ('InOK-B['k]), return 'x, 'x  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 

*** new7indend

op bobOK7IndEnd : -> Protocol .
eq bobOK7IndEnd =  
   ('OTBitOK-B-A[ 'B ] ::= 
      nf('ot : unit <- read ('OTBitOK-A-B['B]), 
        return 'ot, 'ot  )
   )
   ||
   ('ShareOK-B[ 'B] ::= 
        nf('sa : unit <- read ('ShareOK-A['B]), 
        return 'sa, 'sa  )
   )
   ||
  ***  start group
  (family ('BobOK[bound K]) 'k (bound 'B) ::= 
   (
   (family ('OTBitOK-B-A[bound K]) 'k (bound 'B) ::= 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), 
        return 'ot, 'ot  )
   )
   ||
   (family ('ShareOK-B[bound K]) 'k (bound 'B) ::=
     nf('sa : unit <- read ('ShareOK-A['k]), 
        return 'sa, 'sa  )
   )
   )
  ) *** end group
 .

op new7IndEnd : -> Protocol .
eq new7IndEnd =
  (
  aliceOK
  ||
  bobOK7IndEnd
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('x : unit <- read ('InOK-A['k]), return 'x, 'x  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('x : unit <- read ('InOK-B['k]), return 'x, 'x  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 


*** new7ind0

op bobOK7Ind0 : -> Protocol .
eq bobOK7Ind0 =  
   ('OTBitOK-B-A[ 'B ] ::= 
      (when (apply 'isAndGate 'B) --> 
  nf(('ba : unit <- read ('OTBitOK-A-B['B])) 
     ('xa : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
     ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
     ('ya : unit <- read ('ShareOK-A[fun 'wire1 'B])) 
      'yb : unit <- read ('ShareOK-B[fun 'wire1 'B]), 
      return (), 
      'ba 'xa 'ya 'xb 'yb  )
) 
;; 
 (otherwise --> 
   nf('ot : unit <- read ('OTBitOK-B-A['B]),  
      return 'ot, 'ot  )
 )
   )
   ||
   ('ShareOK-B[ 'B] ::= 
        nf('sa : unit <- read ('ShareOK-A['B]), 
        return 'sa, 'sa  )
   )
   ||
   
   (family ('OTBitOK-B-A[bound K]) 'k (bound 'B) ::= 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), 
        return 'ot, 'ot  )
   )
   ||
   (family ('ShareOK-B[bound K]) 'k (bound 'B) ::=
     nf('sa : unit <- read ('ShareOK-A['k]), 
        return 'sa, 'sa  )
   )
   
 .

op new7Ind0 : -> Protocol .
eq new7Ind0 =
  (
  *** aliceOK
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( 
           ('ak : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('al : unit <- read ('ShareOK-A[fun 'wire1 'k])),
           return (),
           'ak 'al  
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-A-B['k]), 
                      return 'ot,
                      'ot  )
     )
   )
   ||
   (family ('ShareOK-A[bound K]) 'k (bound K) ::=
     (when (apply 'isAliceInput 'k) --> 
          nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 'k]),
             return 'is,
             'is  )
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
          nf(
           'is : unit <- read ('InputShareOK-A-B[fun 'wire0 'k]),
           return 'is,
           'is  
          )
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]),
             return 'sa,
             'sa  
            )
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])),
           return (),
           'xa 'ya  
          )
        )
        ;;
        (when (apply 'isAndGate 'k) -->
          nf( 
          ('ba : unit <- read ('OTBitOK-A-B['k]))
          ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
          ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])),
          return (),
          'ba 'xa 'ya  
          )
        )
   )
  ||
  bobOK7Ind0
  ||
  *** indAlice
  (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
 || 
  *** indBob1
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'x 'yb 'y  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'b 'xb 'x 'yb 'y  )
    )
  ) *** end Share-B
 ||
 *** indAdv1
 (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
 *** ok here
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('x : unit <- read ('InOK-A['k]), return 'x, 'x  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('x : unit <- read ('InOK-B['k]), return 'x, 'x  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 


*** new7base

op new7base : -> Protocol .
eq new7base =
    (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
 ) 
 || 
 (family ('InOK-B[bound M]) 'k (bound M) ::= 
   nf('x : bool <- read ('In-B['k]), return (), 'x  )
 ) 
 || 
 (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
   nf('x : unit <- read ('InOK-A['k]), return 'x, 'x  )
 ) 
 || 
 (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
   nf('x : unit <- read ('InOK-B['k]), return 'x, 'x  )
 ) 
 || 
 (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
   nf('xa : unit <- read ('InputShareOK-A-A['k]), return 'xa, 'xa  )
 ) 
 || 
 (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
   nf('xa : unit <- read ('InputShareOK-A-B['k]), return 'xa, 'xa  )
 ) 
 || 
 (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 
         'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb  )
   )
 ) 
 || 
 (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise -->
    nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), return 'otb, 'otb  )
   )
 ) 
 || 
 (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                                ap 'and pair('xb, 'ya)))), 
         'ba 'xa 'ya 'xb 'yb  )
    ) 
    ;; 
    (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb  )
    ) 
 )
 || 
 (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'ak 'al  )
   ) 
   ;; 
   (otherwise --> 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot  )
   )
 ) 
 || 
 (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : unit <- read ('OTBitOK-A-B['k])) 
        ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
        ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
        ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;; 
   (otherwise --> 
     nf('ot : unit <- read ('OTBitOK-B-A['k]), return 'ot, 'ot  )
   )
 ) 
 || 
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) -->
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : unit  <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) 
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'sb  )
   )
   ;; 
   (otherwise --> 
     nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) 
 || 
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return 'ba, 'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  ))
) 
|| 
(family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
||
(family ('Share-A[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
       return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
       return 'sa, 'sa  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba 'xa 'ya  )
  )
) 
|| 
(family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
  nf('sa : bool <- read ('Share-A['k]), 
     return 'sa, 'sa  )
) 
||  
(family ('Share-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
        return 'is, 'x 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
    nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
        return 'is, 'x 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'xb : bool <- read ('Share-B[fun 'wire0 'k]),
        return (ap 'neg 'xb), 'x 'xb  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('xb, 'yb)), 
        'xb 'x 'yb 'y  )
  ) 
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb 'b 'xb 'x 'yb 'y  )
  ) 
)
|| 
(family ('ShareOK-A[bound K]) 'k (bound K) ::= 
   (when (apply 'isAliceInput 'k) --> 
     nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 'k]), 
        return 'is, 'is  )
   ) 
   ;; 
   (when (apply 'isBobInput 'k) --> 
     nf('is : unit <- read ('InputShareOK-A-B[fun 'wire0 'k]), 
        return 'is, 'is  )
   ) 
   ;; 
   (when (apply 'isNotGate 'k) --> 
     nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]),
        return 'sa, 'sa  )
   ) 
   ;; 
   (when (apply 'isXorGate 'k) --> 
     nf(('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'ya : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'xa 'ya  )
   ) 
   ;; 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : unit <- read ('OTBitOK-A-B['k])) 
        ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'ya : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'ba 'xa 'ya  )
   )
 )
 ||
 ('ShareOK-B[0] ::= nf('sa : unit <- read ('ShareOK-A[0]), return 'sa, 'sa  )
 )
.

*** new7step

op new7step : -> Protocol .
eq new7step =
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
 ) 
 || 
 (family ('InOK-B[bound M]) 'k (bound M) ::= 
   nf('x : bool <- read ('In-B['k]), return (), 'x  )
 ) 
 || 
 (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
   nf('x : unit <- read ('InOK-A['k]), return 'x, 'x  )
 ) 
 || 
 (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
   nf('x : unit <- read ('InOK-B['k]), return 'x, 'x  )
 ) 
 || 
 (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
   nf('xa : unit <- read ('InputShareOK-A-A['k]), return 'xa, 'xa  )
 ) 
 || 
 (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
   nf('xa : unit <- read ('InputShareOK-A-B['k]), return 'xa, 'xa  )
 ) 
 || 
 (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 
         'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb  )
   )
 ) 
 || 
 (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise -->
    nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), return 'otb, 'otb  )
   )
 ) 
 || 
 (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                                ap 'and pair('xb, 'ya)))), 
         'ba 'xa 'ya 'xb 'yb  )
    ) 
    ;; 
    (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb  )
    ) 
 )
 || 
 (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'ak 'al  )
   ) 
   ;; 
   (otherwise --> 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot  )
   )
 ) 
 || 
 (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : unit <- read ('OTBitOK-A-B['k])) 
        ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
        ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
        ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;; 
   (otherwise --> 
     nf('ot : unit <- read ('OTBitOK-B-A['k]), return 'ot, 'ot  )
   )
 ) 
 || 
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) -->
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : unit  <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) 
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'sb  )
   )
   ;; 
   (otherwise --> 
     nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) 
 || 
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return 'ba, 'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  ))
) 
|| 
(family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
||
(family ('Share-A[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
       return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
       return 'sa, 'sa  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba 'xa 'ya  )
  )
) 
|| 
(family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
  nf('sa : bool <- read ('Share-A['k]), 
     return 'sa, 'sa  )
) 
||  
(family ('Share-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
        return 'is, 'x 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
    nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
        return 'is, 'x 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'xb : bool <- read ('Share-B[fun 'wire0 'k]),
        return (ap 'neg 'xb), 'x 'xb  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('xb, 'yb)), 
        'xb 'x 'yb 'y  )
  ) 
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb 'b 'xb 'x 'yb 'y  )
  ) 
)
|| 
(family ('ShareOK-A[bound K]) 'k (bound K) ::= 
   (when (apply 'isAliceInput 'k) --> 
     nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 'k]), 
        return 'is, 'is  )
   ) 
   ;; 
   (when (apply 'isBobInput 'k) --> 
     nf('is : unit <- read ('InputShareOK-A-B[fun 'wire0 'k]), 
        return 'is, 'is  )
   ) 
   ;; 
   (when (apply 'isNotGate 'k) --> 
     nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]),
        return 'sa, 'sa  )
   ) 
   ;; 
   (when (apply 'isXorGate 'k) --> 
     nf(('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'ya : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'xa 'ya  )
   ) 
   ;; 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : unit <- read ('OTBitOK-A-B['k])) 
        ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'ya : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'ba 'xa 'ya  )
   )
 )
 ||
 (family ('ShareOK-B[bound K]) 'k (bound 'B) ::= 
   nf('sa : unit <- read ('ShareOK-A['k]), return 'sa, 'sa  )
 )
 ||
 ('ShareOK-B['B] ::= 
    nf('sa : unit <- read ('ShareOK-A['B]), return 'sa, 'sa  )
 )
.

*** new8

 op bobOKOTBit : -> Protocol .
 eq bobOKOTBit =  
  family ('BobOK[bound K]) 'k (bound K) ::=
   ( *** start bobok
   (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba 'xa 'ya 'xb 'yb  
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot  )
     )
   )
   ||
   (family ('ShareOK-B[bound K]) 'k (bound K) ::=
     nf('sa : unit <- read ('ShareOK-A['k]), 
        return 'sa,
        'sa  )
   )
   
   ) *** end bobok
 .

 op new8 : -> Protocol .
 eq new8 =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  aliceOK
  ||
  bobOKOTBit
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('x : unit <- read ('InOK-A['k]), return 'x, 'x  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('x : unit <- read ('InOK-B['k]), return 'x, 'x  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 

*** new9

 op bobOKNoGroup : -> Protocol .
 eq bobOKNoGroup =  
  
   (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
      nf('ot : unit <- read ('OTBitOK-A-B['k]), 
                      return 'ot,
                      'ot  )
   )
   ||
   (family ('ShareOK-B[bound K]) 'k (bound K) ::=
     nf('sa : unit <- read ('ShareOK-A['k]), 
        return 'sa,
        'sa  )
   )
 
 .

 op new9 : -> Protocol .
 eq new9 =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  aliceOK
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('x : unit <- read ('InOK-A['k]), return 'x, 'x  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('x : unit <- read ('InOK-B['k]), return 'x, 'x  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 

*** new10

 op new10 : -> Protocol .
 eq new10 =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  aliceOK
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 

*** new10Ind0

 op new10Ind0 : -> Protocol .
 eq new10Ind0 =
  (
  aliceOKInd0
  ||
  bobOKNoGroup
  ||
  *** indAlice
  (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
   ) *** end share-A
 || 
  *** indBob1
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'x 'yb 'y  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'b 'xb 'x 'yb 'y  )
    )
  ) *** end Share-B
 ||
  *** indAdv1
  (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv ; end of indAdv1, the rest are the internals
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 



*** new10IndInt

 op new10IndInt : -> Protocol .
 eq new10IndInt =
  (
  aliceOKIndInt
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 

*** new10IndStart

 op new10IndStart : -> Protocol .
 eq new10IndStart =
  (
  aliceOKIndStart
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 

*** new10IndEnd

 op new10IndEnd : -> Protocol .
 eq new10IndEnd =
  (
  aliceOKIndEnd
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 



*** new10Int

 op aliceOKNoGroupInt : -> Protocol .
 eq aliceOKNoGroupInt = 
 (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
     nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'ak 'al  )
   ) 
   ;; 
   (otherwise --> 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot  )
   )
  ) 
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
 .

 op new10Int : -> Protocol .
 eq new10Int =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  aliceOKNoGroupInt
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 

*** new11

 op aliceOKNoGroup : -> Protocol .
 eq aliceOKNoGroup = 
  (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  )
  )
  ||
  (family ('ShareOK-A[bound K]) 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
  )
 .

 op new11 : -> Protocol .
 eq new11 =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  aliceOKNoGroup
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 

*** new10base

 op new10base : -> Protocol .
 eq new10base = 
 (family (('In-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
  nf('inA : bool <- read ('In-A['k]), 
     return 'inA, 'inA  )
) 
|| 
(family ('InOK-A[bound N]) 'k (bound N) ::= 
  nf('x : bool <- read ('In-A['k]), return (), 'x  )
) 
|| (family ('InOK-B[bound M]) 'k (bound M) ::= 
     nf('x : bool <- read ('In-B['k]), return (), 'x  )) 
|| (family (('InRcvd-B ^^ 'B .. 'adv)[bound M]) 'k (bound M) ::= 
     nf('x : bool <- read ('In-B['k]), return (), 'x  )) 
|| (family ('InputShare-A-A[bound N]) 'k (bound N) ::= 
     nf('x : bool <- read ('In-A['k]), samp ('flip < () >), 'x  )
   ) 
|| (family (('InputShare-A-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
     nf('is : bool <- read ('InputShare-A-A['k]), return 'is, 'is  )) 
|| (family ('InputShare-A-B[bound M]) 'k (bound M) ::= 
      nf('x : bool <- read ('In-B['k]), samp ('flip < () >), 'x  )
   ) 
|| (family (('InputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::= 
     nf('is : bool <- read ('InputShare-A-B['k]), return 'is, 'is  )) 
|| (family ('InputShare-B-A[bound N]) 'k (bound N) ::= 
     nf(('x : bool <- read ('In-A['k])) 
         'xa : bool <- read ('InputShare-A-A['k]), 
         return (ap 'xor pair('x, 'xa)), 
         'x 'xa  )
   ) 
|| (family ('InputShare-B-B[bound M]) 'k (bound M) ::= 
     nf(('x : bool <- read ('In-B['k])) 
         'xa : bool <- read ('InputShare-A-B['k]), 
         return (ap 'xor pair('x, 'xa)), 
         'x 'xa  )
   ) 
|| (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
     nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )) 
|| (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
     nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )) 
|| (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
     nf('xa : unit <- read ('InputShareOK-A-A['k]), return 'xa, 'xa  )) 
|| (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
     nf('xa : unit <- read ('InputShareOK-A-B['k]), return 'xa, 'xa  )) 
|| (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 
         'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb  )
   )
 ) 
|| (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise -->
    nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), return 'otb, 'otb  )
   )
 ) 
 || 
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                                ap 'and pair('xb, 'ya)))), 
         'ba 'xa 'ya 'xb 'yb  )
    ) 
    ;; 
    (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb  )
    ) 
 )
 || 
 (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'ak 'al  )
   ) 
   ;; 
   (otherwise --> 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot  )
   )
 ) 
 || 
  (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
    nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot  )) 
||
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) -->
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : unit  <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) 
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'sb  )
   )
   ;; 
   (otherwise --> 
     nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) 
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return 'ba, 'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  ))
) 
|| 
(family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
)  
 || 
 (family ('Out-A[bound K]) 'k (bound K) ::= 
   (when (apply 'isOutputWire 'k) --> 
     nf(('sa : bool <- read ('Share-A['k])) 
         'sb : bool <- read ('Share-B['k]),
         return (ap 'xor pair('sa, 'sb)), 'sa 'sb  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('Out-A['k]), return 'x3, 'x3  )
   )
 ) 
 || 
 (family (('Out-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA  )) 
 || 
 (family ('Out-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf(('sa : bool <- read ('Share-A['k])) 
         'sb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('sa, 'sb)), 
         'sa 'sb  )
  ) 
  ;; 
  (otherwise --> nf('x3 : bool <- read ('Out-B['k]), return 'x3, 'x3  )
  )
)  
||
(family (('SendFinalShare-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isOutputWire 'k) --> 
      nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : bool <- read (('SendFinalShare-A ^^ 'A .. 'adv)['k]), return 'x3, 'x3  )
   )
) 
|| 
(family (('SendFinalShare-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('SendFinalShare-B ^^ 'A .. 'adv)['k]), return 'x3, 'x3  ) 
    )
)
|| 
(family (('SendInputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::= 
  nf('sis : bool <- read ('InputShare-A-B['k]), return 'sis, 'sis  )) 
|| 
(family (('SendInputShare-B-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
  nf('sis : bool <- read ('InputShare-B-A['k]), return 'sis, 'sis  )) 
|| 
(family ('Share-A[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
       return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
       return 'sa, 'sa  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba 'xa 'ya  )
  )
) 
|| 
(family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
  nf('sa : bool <- read ('Share-A['k]), 
     return 'sa, 'sa  )
) 
|| 

(family ('Share-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
        return 'is, 'x 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
    nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
        return 'is, 'x 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'xb : bool <- read ('Share-B[fun 'wire0 'k]),
        return (ap 'neg 'xb), 'x 'xb  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('xb, 'yb)), 
        'xb 'x 'yb 'y  )
  ) 
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb 'b 'xb 'x 'yb 'y  )
  ) 
)
|| (family ('ShareOK-B[bound K]) 'k (bound K) ::= 
    nf('sa : unit <- read ('ShareOK-A['k]), return 'sa, 'sa  )
   )
    
|| ('ShareOK-A[0] ::= 
       nf('xa : bool <- read ('Share-A[0]), return (), 'xa  )
   )
 .
 
 op new10step : -> Protocol .
 eq new10step =
  (family (('In-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
  nf('inA : bool <- read ('In-A['k]), 
     return 'inA, 'inA  )
) 
|| 
(family ('InOK-A[bound N]) 'k (bound N) ::= 
  nf('x : bool <- read ('In-A['k]), return (), 'x  )
) 
|| (family ('InOK-B[bound M]) 'k (bound M) ::= 
     nf('x : bool <- read ('In-B['k]), return (), 'x  )) 
|| (family (('InRcvd-B ^^ 'B .. 'adv)[bound M]) 'k (bound M) ::= 
     nf('x : bool <- read ('In-B['k]), return (), 'x  )) 
|| (family ('InputShare-A-A[bound N]) 'k (bound N) ::= 
     nf('x : bool <- read ('In-A['k]), samp ('flip < () >), 'x  )
   ) 
|| (family (('InputShare-A-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
     nf('is : bool <- read ('InputShare-A-A['k]), return 'is, 'is  )) 
|| (family ('InputShare-A-B[bound M]) 'k (bound M) ::= 
      nf('x : bool <- read ('In-B['k]), samp ('flip < () >), 'x  )
   ) 
|| (family (('InputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::= 
     nf('is : bool <- read ('InputShare-A-B['k]), return 'is, 'is  )) 
|| (family ('InputShare-B-A[bound N]) 'k (bound N) ::= 
     nf(('x : bool <- read ('In-A['k])) 
         'xa : bool <- read ('InputShare-A-A['k]), 
         return (ap 'xor pair('x, 'xa)), 
         'x 'xa  )
   ) 
|| (family ('InputShare-B-B[bound M]) 'k (bound M) ::= 
     nf(('x : bool <- read ('In-B['k])) 
         'xa : bool <- read ('InputShare-A-B['k]), 
         return (ap 'xor pair('x, 'xa)), 
         'x 'xa  )
   ) 
|| (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
     nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )) 
|| (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
     nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )) 
|| (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
     nf('xa : unit <- read ('InputShareOK-A-A['k]), return 'xa, 'xa  )) 
|| (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
     nf('xa : unit <- read ('InputShareOK-A-B['k]), return 'xa, 'xa  )) 
|| (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 
         'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb  )
   )
 ) 
|| (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise -->
    nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), return 'otb, 'otb  )
   )
 ) 
 || 
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                                ap 'and pair('xb, 'ya)))), 
         'ba 'xa 'ya 'xb 'yb  )
    ) 
    ;; 
    (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb  )
    ) 
 )
 || 
 (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'ak 'al  )
   ) 
   ;; 
   (otherwise --> 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot  )
   )
 ) 
 || 
  (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
    nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot  )) 
||
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) -->
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), return (), 'sb  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : unit  <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) 
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'sb  )
   )
   ;; 
   (otherwise --> 
     nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) 
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return 'ba, 'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  ))
) 
|| 
(family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
)  
 || 
 (family ('Out-A[bound K]) 'k (bound K) ::= 
   (when (apply 'isOutputWire 'k) --> 
     nf(('sa : bool <- read ('Share-A['k])) 
         'sb : bool <- read ('Share-B['k]),
         return (ap 'xor pair('sa, 'sb)), 'sa 'sb  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('Out-A['k]), return 'x3, 'x3  )
   )
 ) 
 || 
 (family (('Out-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA  )) 
 || 
 (family ('Out-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf(('sa : bool <- read ('Share-A['k])) 
         'sb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('sa, 'sb)), 
         'sa 'sb  )
  ) 
  ;; 
  (otherwise --> nf('x3 : bool <- read ('Out-B['k]), return 'x3, 'x3  )
  )
)  
||
(family (('SendFinalShare-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isOutputWire 'k) --> 
      nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : bool <- read (('SendFinalShare-A ^^ 'A .. 'adv)['k]), return 'x3, 'x3  )
   )
) 
|| 
(family (('SendFinalShare-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('SendFinalShare-B ^^ 'A .. 'adv)['k]), return 'x3, 'x3  ) 
    )
)
|| 
(family (('SendInputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::= 
  nf('sis : bool <- read ('InputShare-A-B['k]), return 'sis, 'sis  )) 
|| 
(family (('SendInputShare-B-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
  nf('sis : bool <- read ('InputShare-B-A['k]), return 'sis, 'sis  )) 
|| 
(family ('Share-A[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
       return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
       return 'sa, 'sa  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba 'xa 'ya  )
  )
) 
|| 
(family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
  nf('sa : bool <- read ('Share-A['k]), 
     return 'sa, 'sa  )
) 
|| 

(family ('Share-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
        return 'is, 'x 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
    nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
        return 'is, 'x 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'xb : bool <- read ('Share-B[fun 'wire0 'k]),
        return (ap 'neg 'xb), 'x 'xb  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('xb, 'yb)), 
        'xb 'x 'yb 'y  )
  ) 
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb 'b 'xb 'x 'yb 'y  )
  ) 
)
|| (family ('ShareOK-B[bound K]) 'k (bound K) ::= 
    nf('sa : unit <- read ('ShareOK-A['k]), return 'sa, 'sa  )
   )

|| ('ShareOK-A['B] ::= 
   nf('xa : bool <- read ('Share-A['B]), 
      return (), 'xa  
     )
 )
 ||
 (family ('ShareOK-A[bound K]) 'k (bound 'B) ::=
   nf('xa : bool <- read ('Share-A['k]),
      return (), 'xa  
     )
 )
 .

*** new12

 op new12 : -> Protocol .
 eq new12 =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  aliceOKNoGroup
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob2
 ||
  indAdv1
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 

*** new13

 op new13 : -> Protocol .
 eq new13 =
  newfamily ('InOK-A[bound N]) 'k (bound N) : unit in
  newfamily ('InOK-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-A-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-A-B[bound M]) 'k (bound M) : unit in
  newfamily ('InputShareOK-B-A[bound N]) 'k (bound N) : unit in
  newfamily ('InputShareOK-B-B[bound M]) 'k (bound M) : unit in
  newfamily ('OTBitOK-A-B[bound K]) 'k (bound K) : unit in
  newfamily ('OTBitOK-B-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-A[bound K]) 'k (bound K) : unit in
  newfamily ('ShareOK-B[bound K]) 'k (bound K) : unit in
  (
  aliceOKNoGroup
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob2
 ||
  indAdv2
 || 
  (family ('InOK-A[bound N]) 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x  )
  )
  ||
  (family ('InOK-B[bound M]) 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x  )
  )
  ||
  (family ('InputShareOK-A-A[bound N]) 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-A-B[bound M]) 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
  )
  ||
  (family ('InputShareOK-B-A[bound N]) 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa  )
  )
  ||
  (family ('InputShareOK-B-B[bound M]) 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa  )
  )
  ) *** end new
. 

*** new14

 op new14 : -> Protocol .
 eq new14 =
  
  indAlice
 || 
  indBob2
 ||
  indAdv2
 
. 

*** new15 

op new15 : -> Protocol .
eq new15 = 
  indAlice
 || 
  indBob3
 ||
  indAdv2
.

*** new15base

op new15base : -> Protocol .
eq new15base =
  (family (('In-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
  nf('inA : bool <- read ('In-A['k]), 
     return 'inA, 'inA  ))
|| 
(family (('InRcvd-B ^^ 'B .. 'adv)[bound M]) 'k (bound M) ::=  
  nf('x : bool <- read ('In-B['k]),
     return (), 'x  ))
|| 

(family ('InputShare-A-A[bound N]) 'k (bound N) ::=
  nf('x : bool <- read ('In-A['k]), 
     samp ('flip < () >), 'x  ))
|| 
(family (('InputShare-A-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::=
  nf('is : bool <- read ('InputShare-A-A['k]), 
     return 'is, 'is  ))
|| 
(family ('InputShare-A-B[bound M]) 'k (bound M) ::=
  nf('x : bool <- read ('In-B['k]), 
     samp ('flip < () >), 'x  ))
|| 
(family (('InputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::=
  nf('is : bool <- read ('InputShare-A-B['k]), 
     return 'is, 'is  ))
|| 
(family ('InputShare-B-A[bound N]) 'k (bound N) ::=
    nf(('x : bool <- read ('In-A['k])) 
        'xa : bool <- read ('InputShare-A-A['k]), 
        return (ap 'xor pair('x, 'xa)), 'x 'xa  )
)
|| 
(family ('InputShare-B-B[bound M]) 'k (bound M) ::=
  nf(('x : bool <- read ('In-B['k])) 
      'xa : bool <- read ('InputShare-A-B['k]), 
      return (ap 'xor pair('x, 'xa)), 'x 'xa  ))
|| 
(family ('OTBit-A-B[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) -->
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 'xa 'ya  )
  ) 
  ;; 
  (otherwise -->
  nf('otb : bool <- read ('OTBit-A-B['k]), 
     return 'otb, 'otb  )
  )
)
|| 
(family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) -->
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )) ;;
  (otherwise -->
    nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), return 'otb, 'otb  )
  )
)
|| 
(family ('OTBit-B-A[bound K]) 'k  (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) -->
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
      ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
      ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
       'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
       return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                              ap 'and pair('xb, 'ya)))), 
       'ba 'xa 'ya 'xb 'yb  )
 ) 
 ;; 
 (otherwise -->
  nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb  )
 )
)
|| 
(family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
 (when (apply 'isAndGate 'k) -->
   nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), return (), 'xa  )
 ) 
 ;; 
  (otherwise -->
     nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), return 'x3, 'x3  )
  )
)
|| 
(family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) -->
    nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), return (), 'xa  )
  ) 
  ;; 
  (otherwise -->
    nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
)
|| 
(family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) --> 
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
       return 'ba, 'ba 'xa 'ya  )
 ) 
 ;; 
 (otherwise --> 
   nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), return 'x3, 'x3  )
 )
)
|| 
(family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) --> 
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
       return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
 ) 
 ;; 
 (otherwise -->
  nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
     return 'x3, 'x3  )
 )
)    
|| 
(family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise -->
    nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), return 'x3, 'x3  )
  )
)
|| 
(family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) -->
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
       return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
       'ba 'xa 'ya  )
 ) 
 ;; 
 (otherwise -->
   nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
      return 'x3, 'x3  )
 )
)
|| 
(family ('Out-A[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
    nf('w : bool <- read ('Wire['k]), return 'w, 'w  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('Out-A['k]), return 'x3, 'x3  )
  )
)
|| 
(family (('Out-A ^^ 'A .. 'adv)[bound K]) 'k (bound (N + M)) ::=
  nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA  ))
|| 
(family ('Out-B[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
   nf('w : bool <- read ('Wire['k]), return 'w, 'w  )
  ) 
  ;; 
  (otherwise -->
   nf('x3 : bool <- read ('Out-B['k]), return 'x3, 'x3  )
  )
)
|| 
(family (('SendFinalShare-A ^^ 'A .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
    nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa  )
  ) 
  ;; 
  (otherwise -->
    nf('x3 : bool <- read (('SendFinalShare-A ^^ 'A .. 'adv)['k]), return 'x3, 'x3  )
  )
)
|| 
(family (('SendFinalShare-B ^^ 'A .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
    nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb  )
  ) 
  ;;
  (otherwise -->
     nf('x3 : bool <- read (('SendFinalShare-B ^^ 'A .. 'adv)['k]), return 'x3, 'x3  )
  )
)  
|| 
(family (('SendInputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::=
  nf('sis : bool <- read ('InputShare-A-B['k]), return 'sis, 'sis  )
)
|| 
(family (('SendInputShare-B-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::=
  nf('sis : bool <- read ('InputShare-B-A['k]), return 'sis, 'sis  ))
|| 
(family ('Share-A[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isAliceInput 'k) -->
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
     nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
        return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) -->
     nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), return 'sa, 'sa  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) -->
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )
  ) 
  ;; 
  (when (apply 'isAndGate 'k) -->
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
         'ba 'xa 'ya  )
  )
)    
|| 
(family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound (N + M)) ::=
  nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa  )
)
|| 
(family ('Wire[bound K]) 'k (bound (N + M)) ::=
  nf(('xa : bool <- read ('Share-A['k])) 
      'xb : bool <- read ('Share-B['k]), 
      return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
)
|| 
('Share-B[0] ::= 
   nf(('xa : bool <- read ('Share-A[0])) 
       'x : bool <- read ('Wire[0]), 
      return (ap 'xor pair('xa, 'x)), 'xa 'x  )
) 
.

*** new15step

op new15step : -> Protocol .
eq new15step =
(family (('In-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::= 
  nf('inA : bool <- read ('In-A['k]), 
     return 'inA, 'inA  ))
|| 
(family (('InRcvd-B ^^ 'B .. 'adv)[bound M]) 'k (bound M) ::=  
  nf('x : bool <- read ('In-B['k]),
     return (), 'x  ))
|| 

(family ('InputShare-A-A[bound N]) 'k (bound N) ::=
  nf('x : bool <- read ('In-A['k]), 
     samp ('flip < () >), 'x  ))
|| 
(family (('InputShare-A-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::=
  nf('is : bool <- read ('InputShare-A-A['k]), 
     return 'is, 'is  ))
|| 
(family ('InputShare-A-B[bound M]) 'k (bound M) ::=
  nf('x : bool <- read ('In-B['k]), 
     samp ('flip < () >), 'x  ))
|| 
(family (('InputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::=
  nf('is : bool <- read ('InputShare-A-B['k]), 
     return 'is, 'is  ))
|| 
(family ('InputShare-B-A[bound N]) 'k (bound N) ::=
    nf(('x : bool <- read ('In-A['k])) 
        'xa : bool <- read ('InputShare-A-A['k]), 
        return (ap 'xor pair('x, 'xa)), 'x 'xa  )
)
|| 
(family ('InputShare-B-B[bound M]) 'k (bound M) ::=
  nf(('x : bool <- read ('In-B['k])) 
      'xa : bool <- read ('InputShare-A-B['k]), 
      return (ap 'xor pair('x, 'xa)), 'x 'xa  ))
|| 
(family ('OTBit-A-B[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) -->
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 'xa 'ya  )
  ) 
  ;; 
  (otherwise -->
  nf('otb : bool <- read ('OTBit-A-B['k]), 
     return 'otb, 'otb  )
  )
)
|| 
(family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) -->
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )) ;;
  (otherwise -->
    nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), return 'otb, 'otb  )
  )
)
|| 
(family ('OTBit-B-A[bound K]) 'k  (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) -->
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
      ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
      ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
       'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
       return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                              ap 'and pair('xb, 'ya)))), 
       'ba 'xa 'ya 'xb 'yb  )
 ) 
 ;; 
 (otherwise -->
  nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb  )
 )
)
|| 
(family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
 (when (apply 'isAndGate 'k) -->
   nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), return (), 'xa  )
 ) 
 ;; 
  (otherwise -->
     nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), return 'x3, 'x3  )
  )
)
|| 
(family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) -->
    nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), return (), 'xa  )
  ) 
  ;; 
  (otherwise -->
    nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
       return 'x3, 'x3  )
  )
)
|| 
(family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) --> 
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
       return 'ba, 'ba 'xa 'ya  )
 ) 
 ;; 
 (otherwise --> 
   nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), return 'x3, 'x3  )
 )
)
|| 
(family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) --> 
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
       return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
 ) 
 ;; 
 (otherwise -->
  nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
     return 'x3, 'x3  )
 )
)    
|| 
(family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
  ) 
  ;; 
  (otherwise -->
    nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), return 'x3, 'x3  )
  )
)
|| 
(family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) -->
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
       return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
       'ba 'xa 'ya  )
 ) 
 ;; 
 (otherwise -->
   nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
      return 'x3, 'x3  )
 )
)
|| 
(family ('Out-A[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
    nf('w : bool <- read ('Wire['k]), return 'w, 'w  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('Out-A['k]), return 'x3, 'x3  )
  )
)
|| 
(family (('Out-A ^^ 'A .. 'adv)[bound K]) 'k (bound (N + M)) ::=
  nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA  ))
|| 
(family ('Out-B[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
   nf('w : bool <- read ('Wire['k]), return 'w, 'w  )
  ) 
  ;; 
  (otherwise -->
   nf('x3 : bool <- read ('Out-B['k]), return 'x3, 'x3  )
  )
)
|| 
(family (('SendFinalShare-A ^^ 'A .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
    nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa  )
  ) 
  ;; 
  (otherwise -->
    nf('x3 : bool <- read (('SendFinalShare-A ^^ 'A .. 'adv)['k]), return 'x3, 'x3  )
  )
)
|| 
(family (('SendFinalShare-B ^^ 'A .. 'adv)[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
    nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb  )
  ) 
  ;;
  (otherwise -->
     nf('x3 : bool <- read (('SendFinalShare-B ^^ 'A .. 'adv)['k]), return 'x3, 'x3  )
  )
)  
|| 
(family (('SendInputShare-A-B ^^ 'A .. 'adv)[bound M]) 'k (bound M) ::=
  nf('sis : bool <- read ('InputShare-A-B['k]), return 'sis, 'sis  )
)
|| 
(family (('SendInputShare-B-A ^^ 'A .. 'adv)[bound N]) 'k (bound N) ::=
  nf('sis : bool <- read ('InputShare-B-A['k]), return 'sis, 'sis  ))
|| 
(family ('Share-A[bound K]) 'k (bound (N + M)) ::= 
  (when (apply 'isAliceInput 'k) -->
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
     nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
        return 'is, 'is  )
  ) 
  ;; 
  (when (apply 'isNotGate 'k) -->
     nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), return 'sa, 'sa  )
  ) 
  ;; 
  (when (apply 'isXorGate 'k) -->
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )
  ) 
  ;; 
  (when (apply 'isAndGate 'k) -->
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
         'ba 'xa 'ya  )
  )
)    
|| 
(family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound (N + M)) ::=
  nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa  )
)
|| 
(family ('Wire[bound K]) 'k (bound (N + M)) ::=
  nf(('xa : bool <- read ('Share-A['k])) 
      'xb : bool <- read ('Share-B['k]), 
      return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
)
|| 
(family ('Share-B[bound K]) 'k (bound 'B) ::= 
  nf(('xa : bool <- read ('Share-A['k])) 
       'x : bool <- read ('Wire['k]), 
      return (ap 'xor pair('xa, 'x)), 'xa 'x  )
)
|| 
('Share-B['B] ::= 
   nf(('xa : bool <- read ('Share-A['B])) 
       'x : bool <- read ('Wire['B]), 
      return (ap 'xor pair('xa, 'x)), 'xa 'x  )
) 
.

***
 
 op aliceOK : -> Protocol .
 eq aliceOK = 
  family ('AliceOK[bound K]) 'k 'k (bound K) ::=
   ( *** start aliceok
   (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( 
           ('ak : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('al : unit <- read ('ShareOK-A[fun 'wire1 'k])),
           return (),
           'ak 'al  
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-A-B['k]), 
                      return 'ot,
                      'ot  )
     )
   )
   ||
   (family ('ShareOK-A[bound K]) 'k (bound K) ::=
     (when (apply 'isAliceInput 'k) --> 
          nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 'k]),
             return 'is,
             'is  )
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
          nf(
           'is : unit <- read ('InputShareOK-A-B[fun 'wire0 'k]),
           return 'is,
           'is  
          )
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]),
             return 'sa,
             'sa  
            )
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])),
           return (),
           'xa 'ya  
          )
        )
        ;;
        (when (apply 'isAndGate 'k) -->
          nf( 
          ('ba : unit <- read ('OTBitOK-A-B['k]))
          ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
          ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])),
          return (),
          'ba 'xa 'ya  
          )
        )
   )
   ) *** end aliceok
 . 
 
 *** what we get when rewriting restrFinal
 
 op restrFinal1 : -> Protocol .
 eq restrFinal1 =
  (family ('Out-A[bound K]) 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
    nf(('sa : bool <- read ('Share-A['k])) 
        'sb : bool <- read ('Share-B['k]), 
        return (ap 'xor pair('sa, 'sb)), 
        'sa 'sb  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('Out-A['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('Out-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA  )
) 
|| 
(family ('Out-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf(('sa : bool <- read ('Share-A['k])) 
         'sb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('sa, 'sb)), 
         'sa 'sb  )
  ) 
  ;; 
  (otherwise --> nf('x3 : bool <- read ('Out-B['k]), return 'x3, 'x3  )
  )
) 
|| 
(family (('SendFinalShare-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isOutputWire 'k) --> 
      nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : bool <- read (('SendFinalShare-A ^^ 'A .. 'adv)['k]), return 'x3, 'x3  )
   )
) 
|| 
(family (('SendFinalShare-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('SendFinalShare-B ^^ 'A .. 'adv)['k]), return 'x3, 'x3  ) 
    )
)
 .
 
 *** restrFinal2
 op restrFinal2 : -> Protocol .
 eq restrFinal2 =
  (family ('Out-A[bound K]) 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
    nf(('w : bool <- read ('Wire['k])) , 
        return 'w, 
        'w  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('Out-A['k]), 
       return 'x3, 'x3  )
  )
) 
|| 
(family (('Out-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA  )
) 
|| 
(family ('Out-B[bound K]) 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf(('w : bool <- read ('Wire['k])) , 
        return 'w, 
        'w  )
  ) 
  ;; 
  (otherwise --> nf('x3 : bool <- read ('Out-B['k]), return 'x3, 'x3  )
  )
) 
|| 
(family (('SendFinalShare-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isOutputWire 'k) --> 
      nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : bool <- read (('SendFinalShare-A ^^ 'A .. 'adv)['k]), return 'x3, 'x3  )
   )
) 
|| 
(family (('SendFinalShare-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb  )
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read (('SendFinalShare-B ^^ 'A .. 'adv)['k]), return 'x3, 'x3  ) 
    )
)
 .
 
 op restr1 : -> Protocol .
 eq restr1 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new3 || restrFinal1) 
 .
 
 op restr2 : -> Protocol .
 eq restr2 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new4 || restrFinal1) 
 .
 
 op restr3 : -> Protocol .
 eq restr3 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new4Int || restrFinal1) 
 .
 
  
 op restr4 : -> Protocol .
 eq restr4 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new5 || restrFinal1) 
 .
 
 op restr4IndStart : -> Protocol .
 eq restr4IndStart = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new5IndStart || restrFinal1) 
 .
 
 op restr4IndEnd : -> Protocol .
 eq restr4IndEnd = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new5IndEnd || restrFinal1) 
 .
 
 op restr5 : -> Protocol .
 eq restr5 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new6 || restrFinal1) 
 .
 
 op restr6 : -> Protocol .
 eq restr6 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new7 || restrFinal1) 
 .
 
 op restr7 : -> Protocol .
 eq restr7 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new8 || restrFinal1) 
 .

 op restr8 : -> Protocol .
 eq restr8 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new9 || restrFinal1) 
 .
 
 op restr9 : -> Protocol .
 eq restr9 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new10 || restrFinal1) 
 .
 
 op restr10Int : -> Protocol .
 eq restr10Int = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new10Int || restrFinal1)
.
 
 op restr10 : -> Protocol .
 eq restr10 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new11 || restrFinal1) 
 .
 
 op restr11 : -> Protocol .
 eq restr11 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new12 || restrFinal1) 
 .
 
 op restr12 : -> Protocol .
 eq restr12 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new13 || restrFinal1) 
 .
 
 op restr13 : -> Protocol .
 eq restr13 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new14 || restrFinal1) 
 .
 
 op restr14 : -> Protocol .
 eq restr14 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  newfamily ('Wire[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new14 || restrFinal1 ||
    (family ('Wire[bound K]) 'k (bound K) ::=
       nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa 'xb  
         )
    )
  ) 
 .
 
 op restr15 : -> Protocol .
 eq restr15 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  newfamily ('Wire[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new14 || restrFinal2 ||
    (family ('Wire[bound K]) 'k (bound K) ::=
       nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa 'xb  
         )
    )
  ) 
 .
 
 op restr15Group : -> Protocol .
 eq restr15Group = 
    restrInitial2 || restrFinal2 || 
    *** expansion of new14, no group names
    ( 
     *** indAlice
     (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
     || 
     *** indAdv2
     (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
     ||
     *** indBob2 becomes a part of the new group!
     (
      family ('Group[bound K]) 'k (bound K) ::= 
      ( *** start group
       (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
  (family ('Wire[bound K]) 'k (bound K) ::=
       nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa 'xb  
         )
    )
     
     ) *** end group
    )
    )
 .
 
 *** for the induction proof
 
 op restr15GroupIndStart : -> Protocol .
 eq restr15GroupIndStart = 
    restrInitial2 || restrFinal2 || 
    *** expansion of new14, no group names
    ( 
     *** indAlice
     (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
     || 
     *** indAdv2
     (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
 *** induction hypothesis
 ||
 (
   family ('Group[bound K]) 'k (bound 'B) ::=
    ( *** start group
      (family ('Wire[bound K]) 'k (bound 'B) ::=
        *** assuming we proved Wire to be the 5 cases
        (when (apply 'isAliceInput 'k) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 'k]), return 'inA0, 'inA0  )
  )
  ;;
  (when (apply 'isBobInput 'k) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 'k]), return 'inB0, 'inB0  )
  )
  ;;
  (when (apply 'isNotGate 'k) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 'k]),
     return (ap 'neg 'x),
     'x  
     )
  )
  ;;
  (when (apply 'isXorGate 'k) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'xor pair('x, 'y)),
    'x 'y   
    )
  )
  ;;
  (when (apply 'isAndGate 'k) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'and pair('x, 'y)),
    'x 'y   
    )
  )
     
     ) *** end Wire 'B
     ||
     (family ('Share-B[bound K]) 'k (bound 'B) ::=
        *** and we proved Share-B to be the reaction
        nf(('xa : bool <- read ('Share-A['k])) 
            'x : bool <- read ('Wire['k]), 
            return (ap 'xor pair('xa, 'x)), 'xa 'x  )
     ) *** end Share-B
     ||
     (family ('OTBit-B-A[bound K]) 'k  (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
     )
    ) *** end group
 
 )
 *** induction step
 ||
 ('OTBit-B-A ['B]::= 
   (when (apply 'isAndGate 'B) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
 ||
  ( 'Share-B['B] ::= 
     *** we know this, and we want to get it to the one reaction
    (when (apply 'isAliceInput 'B) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'B]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'B])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'B) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'B]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'B])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'B) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'B]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'B])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'B) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'B]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'B]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'B])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'B) --> 
      nf(('bb : bool <- read ('OTBit-B-A['B])) 
         ('ba : bool <- read ('OTBit-A-B['B]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'B]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'B]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'B])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
  ('Wire['B] ::=
      *** and here we know that it is the one reaction 5 times
       (when (apply 'isAliceInput 'B) --> 
      nf( ('xa : bool <- read ('Share-A['B]))
           ('xb : bool <- read ('Share-B['B])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa 'xb  
         )
    ) ;;     
       (when (apply 'isBobInput 'B) --> 
      nf( ('xa : bool <- read ('Share-A['B]))
           ('xb : bool <- read ('Share-B['B])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa 'xb  
         )
    ) ;;
       (when (apply 'isNotGate 'B) --> 
      nf( ('xa : bool <- read ('Share-A['B]))
           ('xb : bool <- read ('Share-B['B])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa 'xb  
         )
    ) ;;
       (when (apply 'isXorGate 'B) --> 
      nf( ('xa : bool <- read ('Share-A['B]))
           ('xb : bool <- read ('Share-B['B])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa 'xb  
         )
    ) ;;
       (when (apply 'isAndGate 'B) --> 
      nf( ('xa : bool <- read ('Share-A['B]))
           ('xb : bool <- read ('Share-B['B])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa 'xb  
         )
       ) 
    ) 
   
   
   
   ) *** ends big bracket
 .

*** for the sym proof on share-b
 op restr15GroupIndSym : -> Protocol .
 eq restr15GroupIndSym = 
    restrInitial2 || restrFinal2 || 
    *** expansion of new14, no group names
    ( 
     *** indAlice
     (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
     || 
     *** indAdv2
     (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
 *** induction hypothesis
 ||
 (
  *** family ('Group[bound K]) 'k (bound 'B) ::=
    ( *** start group
      (family ('Wire[bound K]) 'k (bound 'B) ::=
        *** assuming we proved Wire to be the 5 cases
        (when (apply 'isAliceInput 'k) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 'k]), return 'inA0, 'inA0  )
  )
  ;;
  (when (apply 'isBobInput 'k) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 'k]), return 'inB0, 'inB0  )
  )
  ;;
  (when (apply 'isNotGate 'k) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 'k]),
     return (ap 'neg 'x),
     'x  
     )
  )
  ;;
  (when (apply 'isXorGate 'k) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'xor pair('x, 'y)),
    'x 'y   
    )
  )
  ;;
  (when (apply 'isAndGate 'k) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'and pair('x, 'y)),
    'x 'y   
    )
  )
     
     ) *** end Wire 'B
     ||
     (family ('Share-B[bound K]) 'k (bound 'B) ::=
        *** and we proved Share-B to be the reaction
        nf(('xa : bool <- read ('Share-A['k])) 
            'x : bool <- read ('Wire['k]), 
            return (ap 'xor pair('xa, 'x)), 'xa 'x  )
     ) *** end Share-B
     ||
     (family ('OTBit-B-A[bound K]) 'k  (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
     )
    ) *** end group
 
 )
 *** induction step
 ||
 ('OTBit-B-A ['B]::= 
   (when (apply 'isAndGate 'B) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
 ||
  ( 'Share-B['B] ::= 
     *** for the sym proof we write the reaction 5 times
    (when (apply 'isAliceInput 'B) --> 
        nf(('xa : bool <- read ('Share-A['B])) 
            'x : bool <- read ('Wire['B]), 
            return (ap 'xor pair('xa, 'x)), 'xa 'x  )
    ) 
    ;; 
    (when (apply 'isBobInput 'B) --> 
       nf(('xa : bool <- read ('Share-A['B])) 
            'x : bool <- read ('Wire['B]), 
            return (ap 'xor pair('xa, 'x)), 'xa 'x  )
    ) 
    ;; 
    (when (apply 'isNotGate 'B) --> 
       nf(('xa : bool <- read ('Share-A['B])) 
            'x : bool <- read ('Wire['B]), 
            return (ap 'xor pair('xa, 'x)), 'xa 'x  )
    ) 
    ;; 
    (when (apply 'isXorGate 'B) --> 
       nf(('xa : bool <- read ('Share-A['B])) 
            'x : bool <- read ('Wire['B]), 
            return (ap 'xor pair('xa, 'x)), 'xa 'x  )
    ) 
    ;; 
    (when (apply 'isAndGate 'B) --> 
      nf(('xa : bool <- read ('Share-A['B])) 
            'x : bool <- read ('Wire['B]), 
            return (ap 'xor pair('xa, 'x)), 'xa 'x  )
    )
  ) *** end Share-B
  ||
  ('Wire['B] ::= 
    (when (apply 'isAliceInput 'B) --> 
       nf(('xa : bool <- read ('InputShare-A-A[fun 'wire0 'B])) 
           'xb : bool <- read ('InputShare-B-A[fun 'wire0 'B]), 
           return (ap 'xor pair('xa, 'xb)), 
           'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isBobInput 'B) --> 
       nf(('xa : bool <- read ('InputShare-A-B[fun 'wire0 'B])) 
           'xb : bool <- read ('InputShare-B-B[fun 'wire0 'B]), 
           return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isNotGate 'B) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
           'xb : bool <- read ('Share-B[fun 'wire0 'B]), 
           return (ap 'xor pair('xa, ap 'neg 'xb)), 
           'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'B) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
          ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
          ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
           'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
           return (ap 'xor pair(ap 'xor pair('xa, 'ya), ap 'xor pair('xb, 'yb))),
           'xa 'yb 'ya 'xb  )
    ) 
    ;; 
    (when (apply 'isAndGate 'B) --> 
       nf(('ba : bool <- read ('OTBit-A-B['B])) 
          ('bb : bool <- read ('OTBit-B-A['B])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'B]))
          ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
          ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
           'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
           return (ap 'xor pair(ap 'xor pair(ap 'and pair('xa, 'ya), 'ba), 
                                ap 'xor pair('bb, ap 'and pair('xb, 'yb)))), 
           'bb 'ba 'xa 'yb 'ya 'xb  )    
    )
  ) 
   
   
   
   ) *** ends big bracket
 .



 
  op restr15GroupIndEnd : -> Protocol .
 eq restr15GroupIndEnd = 
    restrInitial2 || restrFinal2 || 
    *** expansion of new14, no group names
    ( 
     *** indAlice
     (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
     || 
     *** indAdv2
     (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
 *** induction hypothesis
 ||
 (
   family ('Group[bound K]) 'k (bound 'B) ::=
    ( *** start group
      (family ('Wire[bound K]) 'k (bound 'B) ::=
        *** assuming we proved Wire to be the 5 cases
        (when (apply 'isAliceInput 'k) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 'k]), return 'inA0, 'inA0  )
  )
  ;;
  (when (apply 'isBobInput 'k) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 'k]), return 'inB0, 'inB0  )
  )
  ;;
  (when (apply 'isNotGate 'k) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 'k]),
     return (ap 'neg 'x),
     'x  
     )
  )
  ;;
  (when (apply 'isXorGate 'k) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'xor pair('x, 'y)),
    'x 'y   
    )
  )
  ;;
  (when (apply 'isAndGate 'k) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'and pair('x, 'y)),
    'x 'y   
    )
  )
     
     ) *** end Wire 'B
     ||
     (family ('Share-B[bound K]) 'k (bound 'B) ::=
        *** and we proved Share-B to be the reaction
        nf(('xa : bool <- read ('Share-A['k])) 
            'x : bool <- read ('Wire['k]), 
            return (ap 'xor pair('xa, 'x)), 'xa 'x  )
     ) *** end Share-B
     ||
     (family ('OTBit-B-A[bound K]) 'k  (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
     )
    ) *** end group
 
 )
 *** induction step
 ||
 ('OTBit-B-A ['B]::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
 ||
  ( 'Share-B['B] ::= 
    nf(('xa : bool <- read ('Share-A['B])) 
            'x : bool <- read ('Wire['B]), 
            return (ap 'xor pair('xa, 'x)), 'xa 'x  )
  ) *** end Share-B
  ||
  ('Wire['B] ::=
     (when (apply 'isAliceInput 'B) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 'B]), return 'inA0, 'inA0  )
  )
  ;;
  (when (apply 'isBobInput 'B) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 'B]), return 'inB0, 'inB0  )
  )
  ;;
  (when (apply 'isNotGate 'B) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 'B]),
     return (ap 'neg 'x),
     'x  
     )
  )
  ;;
  (when (apply 'isAndGate 'B) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 'B]))
    ('y : bool <- read ('Wire[fun 'wire1 'B])),
    return (ap 'and pair('x, 'y)),
    'x 'y   
    )
  )
  ;;
  (when (apply 'isXorGate 'B) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 'B]))
    ('y : bool <- read ('Wire[fun 'wire1 'B])),
    return (ap 'xor pair('x, 'y)),
    'x 'y   
    )
  )     
  ) 
   
   
   
   ) *** ends big bracket
 .
 
 *******************
 
 op restr15Wire : -> Protocol .
 eq restr15Wire = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  newfamily ('Wire[bound K]) 'k (bound K) : bool in
  (restrInitial2 || new14 || restrFinal2 ||
    (family ('Wire[bound K]) 'k (bound K) ::=
          (when (apply 'isAliceInput 'k) --> 
      nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa 'xb  
         )
    ) ;;     
       (when (apply 'isBobInput 'k) --> 
      nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa 'xb  
         )
    ) ;;
       (when (apply 'isNotGate 'k) --> 
      nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa 'xb  
         )
    ) ;;
       (when (apply 'isXorGate 'k) --> 
      nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa 'xb  
         )
    ) ;;
       (when (apply 'isAndGate 'k) --> 
      nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa 'xb  
         )
    )
    )
  ) 
 .
 
 *** restr16
 
 op restr16 : -> Protocol .
 eq restr16 = 
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  newfamily ('Wire[bound K]) 'k (bound K) : bool in
  ( restrInitial2 || new15 || restrFinal2 || wiresIdeal )  
 .
 
 *** restr16Group
op restr16Group : -> Protocol .
eq restr16Group =
  newfamily ('InputShare-A-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-A-B[bound M]) 'k (bound M) : bool in
  newfamily ('InputShare-B-A[bound N]) 'k (bound N) : bool in
  newfamily ('InputShare-B-B[bound M]) 'k (bound M) : bool in
  newfamily ('OTBit-A-B[bound K]) 'k (bound K) : bool in
  newfamily ('OTBit-B-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-A[bound K]) 'k (bound K) : bool in
  newfamily ('Share-B[bound K]) 'k (bound K) : bool in
  newfamily ('Wire[bound K]) 'k (bound K) : bool in
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
    ||
    *** here is the group
   ( family ('Group[bound K]) 'k (bound K) ::= 
   ( *** start group
    (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  (
  family ('Share-B[bound K]) 'k (bound K) ::= 
    nf(('xa : bool <- read ('Share-A['k])) 
       'x : bool <- read ('Wire['k]), 
      return (ap 'xor pair('xa, 'x)), 'xa 'x  )
  ) *** end Share-B
  ||
    (family ('Wire[bound K]) 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 'k]), return 'inA0, 'inA0  )
  )
  ;;
  (when (apply 'isBobInput 'k) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 'k]), return 'inB0, 'inB0  )
  )
  ;;
  (when (apply 'isNotGate 'k) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 'k]),
     return (ap 'neg 'x),
     'x  
     )
  )
  ;;
  (when (apply 'isXorGate 'k) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'xor pair('x, 'y)),
    'x 'y   
    )
  )
  ;;
  (when (apply 'isAndGate 'k) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'and pair('x, 'y)),
    'x 'y   
    )
  )
)
) *** end group
)
.

*** restr16GIndStart
op restr16GIndStart : -> Protocol .
eq restr16GIndStart =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
    ||
    *** here is the group
   ( family ('Group[bound K]) 'k (bound 'B) ::= 
   ( *** start group
   (family ('Wire[bound K]) 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
   )
   ||
   (family ('Share-B[bound K]) 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
  (family ('OTBit-B-A[bound K]) 'k  (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B] ::= 
   (when (apply 'isAndGate 'B) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B] ::= 
    nf(('xa : bool <- read ('Share-A['B])) 
       'x : bool <- read ('Wire['B]), 
      return (ap 'xor pair('xa, 'x)), 'xa 'x  )
  ) *** end Share-B
  ||
    ('Wire['B]  ::= 
  (when (apply 'isAliceInput 'B) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 'B]), return 'inA0, 'inA0  )
  )
  ;;
  (when (apply 'isBobInput 'B) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 'B]), return 'inB0, 'inB0  )
  )
  ;;
  (when (apply 'isNotGate 'B) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 'B]),
     return (ap 'neg 'x),
     'x  
     )
  )
  ;;
  (when (apply 'isXorGate 'B) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 'B]))
    ('y : bool <- read ('Wire[fun 'wire1 'B])),
    return (ap 'xor pair('x, 'y)),
    'x 'y   
    )
  )
  ;;
  (when (apply 'isAndGate 'B) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 'B]))
    ('y : bool <- read ('Wire[fun 'wire1 'B])),
    return (ap 'and pair('x, 'y)),
    'x 'y   
    )
  )
  
)

.

*** restr16GIndEnd
op restr16GIndEnd : -> Protocol .
eq restr16GIndEnd =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
    ||
    *** here is the group
   ( family ('Group[bound K]) 'k (bound 'B) ::= 
   ( *** start group
   (family ('Wire[bound K]) 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
   )
   ||
   (family ('Share-B[bound K]) 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
  (family ('OTBit-B-A[bound K]) 'k  (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B] ::= 
   (when (apply 'isAndGate 'B) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B] ::= 
    (when (apply 'isAliceInput 'B) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'B]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'B])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'B) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'B]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'B])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'B) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'B]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'B])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'B) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'B]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'B]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'B])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'B) --> 
      nf(('bb : bool <- read ('OTBit-B-A['B])) 
         ('ba : bool <- read ('OTBit-A-B['B]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'B]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'B]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'B])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
    ('Wire['B]  ::= 
       nf(('xa : bool <- read ('Share-A['B])) 
         'xb : bool <- read ('Share-B['B]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
    )

.

*** restr16GIndSymShare
op restr16GIndSymShare : -> Protocol .
eq restr16GIndSymShare =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
    ||
    *** here is the group
   ( family ('Group[bound K]) 'k (bound 'B) ::= 
   ( *** start group
   (family ('Wire[bound K]) 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
   )
   ||
   (family ('Share-B[bound K]) 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
  (family ('OTBit-B-A[bound K]) 'k  (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B] ::= 
   (when (apply 'isAndGate 'B) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
 ( 'Share-B['B] ::= 
     *** for the sym proof we write the reaction 5 times
    (when (apply 'isAliceInput 'B) --> 
        nf(('xa : bool <- read ('Share-A['B])) 
            'x : bool <- read ('Wire['B]), 
            return (ap 'xor pair('xa, 'x)), 'xa 'x  )
    ) 
    ;; 
    (when (apply 'isBobInput 'B) --> 
       nf(('xa : bool <- read ('Share-A['B])) 
            'x : bool <- read ('Wire['B]), 
            return (ap 'xor pair('xa, 'x)), 'xa 'x  )
    ) 
    ;; 
    (when (apply 'isNotGate 'B) --> 
       nf(('xa : bool <- read ('Share-A['B])) 
            'x : bool <- read ('Wire['B]), 
            return (ap 'xor pair('xa, 'x)), 'xa 'x  )
    ) 
    ;; 
    (when (apply 'isXorGate 'B) --> 
       nf(('xa : bool <- read ('Share-A['B])) 
            'x : bool <- read ('Wire['B]), 
            return (ap 'xor pair('xa, 'x)), 'xa 'x  )
    ) 
    ;; 
    (when (apply 'isAndGate 'B) --> 
      nf(('xa : bool <- read ('Share-A['B])) 
            'x : bool <- read ('Wire['B]), 
            return (ap 'xor pair('xa, 'x)), 'xa 'x  )
    )
  ) *** end Share-B
  ||
    ('Wire['B] ::= 
 (when (apply 'isAliceInput 'B) --> 
   nf(('xa : bool <- read ('InputShare-A-A[fun 'wire0 'B])) 
       'xb : bool <- read ('InputShare-B-A[fun 'wire0 'B]), 
        return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
 ) 
 ;; 
 (when (apply 'isBobInput 'B) --> 
   nf(('xa : bool <- read ('InputShare-A-B[fun 'wire0 'B])) 
       'xb : bool <- read ('InputShare-B-B[fun 'wire0 'B]), 
        return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
 ) 
 ;; 
 (when (apply 'isNotGate 'B) -->
   nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
       'xb : bool <- read ('Share-B[fun 'wire0 'B]), 
       return (ap 'neg ap 'xor pair('xa, 'xb)), 'xa 'xb  )
 ) 
 ;; 
 (when (apply 'isXorGate 'B) --> 
   nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
      ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
      ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
       'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
       return (ap 'xor pair(ap 'xor pair('xa, 'ya), ap 'xor pair('xb, 'yb))),
       'xa 'yb 'ya 'xb  )
 ) 
 ;; 
 (when (apply 'isAndGate 'B) --> 
  nf(('ba : bool <- read ('OTBit-A-B['B])) 
     ('bb : bool <- read ('OTBit-B-A['B])) 
     ('xa : bool <- read ('Share-A[fun 'wire0 'B]))
     ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
     ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
      'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
      return (ap 'xor pair(ap 'xor pair(ap 'and pair('xa, 'ya), 'ba), 
                           ap 'xor pair('bb, ap 'and pair('xb, 'yb)))), 
      'bb 'ba 'xa 'yb 'ya 'xb  )
 )  
  
    )

.


*** restr16GSymAlice
op restr16GSymAlice : -> Protocol .
eq restr16GSymAlice =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
    ||
    *** here is the group
   ( family ('Group[bound K]) 'k (bound 'B) ::= 
   ( *** start group
   (family ('Wire[bound K]) 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
   )
   ||
   (family ('Share-B[bound K]) 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
  (family ('OTBit-B-A[bound K]) 'k  (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B] ::= 
   (when (apply 'isAndGate 'B) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B] ::= 
    nf(('xa : bool <- read ('Share-A['B])) 
       'x : bool <- read ('Wire['B]), 
      return (ap 'xor pair('xa, 'x)), 'xa 'x  )
  ) *** end Share-B
  ||
    ('Wire['B]  ::= 
  
    nf('inA0 : bool <- read ('In-A[fun 'wire0 'B]), return 'inA0, 'inA0  )
  
  )

.

*** restr16GSymBob
op restr16GSymBob : -> Protocol .
eq restr16GSymBob =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
    ||
    *** here is the group
   ( family ('Group[bound K]) 'k (bound 'B) ::= 
   ( *** start group
   (family ('Wire[bound K]) 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
   )
   ||
   (family ('Share-B[bound K]) 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
  (family ('OTBit-B-A[bound K]) 'k  (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B] ::= 
   (when (apply 'isAndGate 'B) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B] ::= 
    nf(('xa : bool <- read ('Share-A['B])) 
       'x : bool <- read ('Wire['B]), 
      return (ap 'xor pair('xa, 'x)), 'xa 'x  )
  ) *** end Share-B
  ||
    ('Wire['B]  ::= 
  
    nf('inB0 : bool <- read ('In-B[fun 'wire0 'B]), 
       return 'inB0, 'inB0  )
  
  )
.

*** restr16GSymNot
op restr16GSymNot : -> Protocol .
eq restr16GSymNot =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
    ||
    *** here is the group
   ( family ('Group[bound K]) 'k (bound 'B) ::= 
   ( *** start group
   (family ('Wire[bound K]) 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
   )
   ||
   (family ('Share-B[bound K]) 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
  (family ('OTBit-B-A[bound K]) 'k  (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B] ::= 
   (when (apply 'isAndGate 'B) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B] ::= 
    nf(('xa : bool <- read ('Share-A['B])) 
       'x : bool <- read ('Wire['B]), 
      return (ap 'xor pair('xa, 'x)), 'xa 'x  )
  ) *** end Share-B
  ||
    ('Wire['B]  ::= 
  
     nf( 
     'x : bool <- read ('Wire[fun 'wire0 'B]),
     return (ap 'neg 'x),
     'x  
     )
  
  )

.

*** restr16GSymXor
op restr16GSymXor : -> Protocol .
eq restr16GSymXor =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
    ||
    *** here is the group
   ( family ('Group[bound K]) 'k (bound 'B) ::= 
   ( *** start group
   (family ('Wire[bound K]) 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
   )
   ||
   (family ('Share-B[bound K]) 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
  (family ('OTBit-B-A[bound K]) 'k  (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B] ::= 
   (when (apply 'isAndGate 'B) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B] ::= 
    nf(('xa : bool <- read ('Share-A['B])) 
       'x : bool <- read ('Wire['B]), 
      return (ap 'xor pair('xa, 'x)), 'xa 'x  )
  ) *** end Share-B
  ||
    ('Wire['B]  ::= 
  
     nf(
    ('x : bool <- read ('Wire[fun 'wire0 'B]))
    ('y : bool <- read ('Wire[fun 'wire1 'B])),
    return (ap 'xor pair('x, 'y)),
    'x 'y   
    )
  
  )

.

*** restr16GSymAnd
op restr16GSymAnd : -> Protocol .
eq restr16GSymAnd =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
    ||
    *** here is the group
   ( family ('Group[bound K]) 'k (bound 'B) ::= 
   ( *** start group
   (family ('Wire[bound K]) 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
   )
   ||
   (family ('Share-B[bound K]) 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
  (family ('OTBit-B-A[bound K]) 'k  (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B] ::= 
   (when (apply 'isAndGate 'B) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B] ::= 
    nf(('xa : bool <- read ('Share-A['B])) 
       'x : bool <- read ('Wire['B]), 
      return (ap 'xor pair('xa, 'x)), 'xa 'x  )
  ) *** end Share-B
  ||
    ('Wire['B]  ::= 
  
   nf(
    ('x : bool <- read ('Wire[fun 'wire0 'B]))
    ('y : bool <- read ('Wire[fun 'wire1 'B])),
    return (ap 'and pair('x, 'y)),
    'x 'y   
    )
  
  )

.


*** restr16GIndEnd5
op restr16GIndEnd5 : -> Protocol .
eq restr16GIndEnd5 =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family ('OTBit-A-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa 'ya  )
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb  )
    )
  ) *** end otbit
   ||
   (family ('Share-A[bound K]) 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is  )
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is  )
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa  )
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa 'ya  )
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba 'xa 'ya  
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family (('OTBit-A-B ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb  )
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read (('OTBit-A-B ^^ 'A .. 'adv)['k]), 
        return 'otb, 'otb  )
   )
 ) *** end OTBit
 ||   
 (family (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-0  
 || 
 (family (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa  )
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)['k]), 
         return 'x3, 'x3  )
   )
 ) *** end choiceRcvd-1
 ||
 (family (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-0 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-0
 ||
 (family (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-1 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-1
 ||
 (family (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-2 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-2
 ||
 (family (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]) 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba 'xa 'ya  )
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read (('OTMsg-A-B-3 ^^ 'ot .. 'adv)['k]), 
        return 'x3, 'x3  )
   )
 ) *** end msg-3
 ||
 (family (('Share-A ^^ 'A .. 'adv)[bound K]) 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa  )
 ) *** end share-A ^^ 'A .. 'adv 
    ||
    *** here is the group
   ( family ('Group[bound K]) 'k (bound 'B) ::= 
   ( *** start group
   (family ('Wire[bound K]) 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
   )
   ||
   (family ('Share-B[bound K]) 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
  (family ('OTBit-B-A[bound K]) 'k  (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B] ::= 
   (when (apply 'isAndGate 'B) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B] ::= 
    (when (apply 'isAliceInput 'B) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'B]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'B])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'B) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'B]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'B])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'B) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'B]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'B])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'B) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'B]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'B]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'B])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'B) --> 
      nf(('bb : bool <- read ('OTBit-B-A['B])) 
         ('ba : bool <- read ('OTBit-A-B['B]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'B]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'B]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'B])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
    ('Wire['B]  ::= 
      ( when (apply 'isAliceInput 'B) --> 
       nf(('xa : bool <- read ('Share-A['B])) 
         'xb : bool <- read ('Share-B['B]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
      )   
      ;;
      ( when (apply 'isBobInput 'B) --> 
       nf(('xa : bool <- read ('Share-A['B])) 
         'xb : bool <- read ('Share-B['B]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
      )   
      ;;
      ( when (apply 'isNotGate 'B) --> 
       nf(('xa : bool <- read ('Share-A['B])) 
         'xb : bool <- read ('Share-B['B]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
      )   
      ;;
      ( when (apply 'isXorGate 'B) --> 
       nf(('xa : bool <- read ('Share-A['B])) 
         'xb : bool <- read ('Share-B['B]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
      )   
      ;;
      ( when (apply 'isAndGate 'B) --> 
       nf(('xa : bool <- read ('Share-A['B])) 
         'xb : bool <- read ('Share-B['B]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
      )   
      
    )

.

endm 

smod EXECUTE is
 pr GMW2 .
 pr STRATS .
 
 var x y x1 x2 x3 q C : Qid .
 var Sigma : Signature .
 var Delta : ChannelContext .
 var Gamma : TypeContext .
 var I O : Set{CNameBound} .
 var A : Set{BoolTerm} .
 var cn : ChannelName .
 var pConf : ProtocolConfig .
 var P : Protocol .
 var T : Type .
 var nt : NatTerm .
 var bt : BoolTerm .
 var bounds : List{Bounds} .
 
 var e1 e2 e3 e4 : Expression . 

 *** x = () if x : unit
 
 rl [return-unit] :
   rConfig(Sigma, Delta, Gamma (x : unit), return x, I, A, T)
   => 
   rConfig(Sigma, Delta, Gamma (x : unit), return (), I, A, T)
 .
 
 strat applyReturnUnit : CNameBound @ ProtocolConfig .
 sd applyReturnUnit(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnUnit(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-unit}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-unit}}
                      )
             )
 .
  sd applyReturnUnit(fam (cn[bounds])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnUnit(fam (cn[bounds]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[bounds])), 
                             P1:Protocol <- keepOne P (fam (cn[bounds]))]{
                             CONG-REACT-family[C:Qid <- cn]{cong-nf{return-unit}}
                             }
              or-else (CONG-REACT-family[C:Qid <- cn]{cong-nf{return-unit}}
                      )
             )
 .
 

 *******************************
 *** assumptions
 ******************************* 
 
 ***( this is the alternative path, needs consistent changes throughout the whole proof 
 *** congruence rules
 crl [cong-ap] : ap q e1 => ap q e2 
     if e1 => e2 .
     
 crl [cong-pair-r] : pair(e1, e2) => pair(e1, e3)    
     if e2 => e3 .
     
 crl [cong-pair-l] : pair(e1, e2) => pair(e3, e2)    
     if e1 => e3 .
     
 *** assoc and comm for 'xor and 'and
 
 rl [comm-xor] : 
    return(ap 'xor pair(e1, e2)) => return(ap 'xor pair(e2, e1)) .
    
 rl [comm-and] : 
    ap 'and pair(e1, e2) => ap 'and pair(e2, e1) .
    
 rl [assoc-xor-l] :
    ap 'xor pair(e1, ap 'xor pair(e2, e3)) 
    => 
    ap 'xor pair(ap 'xor pair(e1, e2), e3) .  
       
 rl [assoc-xor-r] :
    ap 'xor pair(ap 'xor pair(e1, e2), e3)
    => 
    ap 'xor pair(e1, ap 'xor pair(e2, e3))  .    
  
 rl [assoc-and-l] :
    ap 'and pair(e1, ap 'and pair(e2, e3)) 
    => 
    ap 'and pair(ap 'and pair(e1, e2), e3) .  
       
 rl [assoc-and-r] :
    ap 'and pair(ap 'and pair(e1, e2), e3)
    => 
    ap 'and pair(e1, ap 'and pair(e2, e3))  .    
 )
 
 *** lemma 
 
 rl [comm-xor] : 
    return(ap 'xor pair(e1, e2)) => return(ap 'xor pair(e2, e1)) .
 
 strat applyCommXor : CNameBound @ ProtocolConfig .
 sd applyCommXor(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCommXor(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{comm-xor}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{comm-xor}}
                      )
             )
 .
  sd applyCommXor(fam (cn[bounds])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCommXor(fam (cn[bounds]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[bounds])), 
                             P1:Protocol <- keepOne P (fam (cn[bounds]))]{
                             CONG-REACT-family[C:Qid <- cn]{cong-nf{comm-xor}}
                             }
              or-else (CONG-REACT-family[C:Qid <- cn]{cong-nf{comm-xor}}
                      )
             )
 .
 
 eq ap 'xor pair(e1, ap 'neg e2) = ap 'neg (ap 'xor pair(e1, e2)) .
 
 eq ap 'xor pair(ap 'xor pair(e1, e2), e2) = e1 .
 eq ap 'xor pair(e1, ap 'xor pair(e1, e2)) = e2 . 
 eq ap 'xor pair(e1, ap 'xor pair(e2, e1)) = e2 .
 
 rl [swap-23-xor] :
    return (ap 'xor pair(ap 'xor pair(e1, e2),
                         ap 'xor pair(e3, e4)
                        )
           )
    => 
    return (ap 'xor pair(ap 'xor pair(e1, e3),
                         ap 'xor pair(e2, e4)
                        )
           )       
 . 
 
 strat applySwap23Xor : ChannelName @ ProtocolConfig .
 sd applySwap23Xor(cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySwap23Xor(cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{swap-23-xor}}
                          ***   or-else
                          ***   CONG-REACT-family[C:Qid <- cn]{cong-nf{swap-23-xor}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{swap-23-xor}}
                         ***    or-else
                         ***    CONG-REACT-family[C:Qid <- cn]{cong-nf{swap-23-xor}}
                      )
             )
 .         

 var xa ya xb yb ba : Expression .

 *** lemma 
 rl [and-xor-term] :
 return (ap 'xor pair(ap 'xor pair(ap 'and pair(xa, ya), ba), 
                     ap 'xor pair(ap 'xor pair(ba, 
                                                ap 'xor pair(ap 'and pair(xa, yb), 
                                                             ap 'and pair(xb, ya))
                                              ), 
                                 ap 'and pair(xb, yb)
                                 )
                    )
       )
=> 
return (ap 'xor pair( ap 'xor pair( ap 'and pair(xa, ya),
                                    ap 'and pair(xa, yb)
                                  ), 
                                  
                      ap 'xor pair(ap 'and pair(xb, ya),
                                   ap 'and pair(xb, yb)
                                  )            
                    )
       ) 
 .  
 
 strat applyAndXorTerm : ChannelName @ ProtocolConfig .
 sd applyAndXorTerm(cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAndXorTerm(cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{and-xor-term}}
                             *** or-else
                             *** CONG-REACT-family[C:Qid <- cn]{cong-nf{and-xor-term}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{and-xor-term}}
                         ***    or-else
                         ***    CONG-REACT-family[C:Qid <- cn]{cong-nf{and-xor-term}}
                      )
             )
 .  
 
 rl [distrib-r] : 
 return (ap 'xor pair( ap 'xor pair( ap 'and pair(xa, ya),
                                    ap 'and pair(xa, yb)
                                  ), 
                                  
                      ap 'xor pair(ap 'and pair(xb, ya),
                                   ap 'and pair(xb, yb)
                                  )            
                    )
       ) 
  => 
  return (ap 'and pair(ap 'xor pair(xa, xb),
                       ap 'xor pair(ya, yb))
         )              
 .   
 
 strat applyDistribR : ChannelName @ ProtocolConfig .
 sd applyDistribR(cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDistribR(cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{distrib-r}}
                         ***    or-else
                         ***    CONG-REACT-family[C:Qid <- cn]{cong-nf{distrib-r}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{distrib-r}}
                           ***  or-else
                           ***  CONG-REACT-family[C:Qid <- cn]{cong-nf{distrib-r}}
                      )
             )
 .       

 *** x1 + x2 * x3 = x1 * x3 + x2 * x3
 
  eq ap 'and pair(ap 'xor pair(x1, x2), x3) =
     ap 'xor pair(ap 'and pair(x1, x3), ap 'and pair(x2, x3)) .
     
 *** x + x = False
 
 *** eq ap 'xor pair(x, x) = False .  
 
 var e : Expression .
 
 eq ap 'xor pair(e, e) = False .
 *** TODO: would it make sense to do this for all axioms?
 
 *** x + False = x
 
  eq ap 'xor pair(x, False) = x . 
  
 *** x + True = not x
 
 eq ap 'xor pair(x, True) = ap 'neg x . 
 
 *** x * False = False
 eq ap 'and pair(x, False) = False .    
 
  *** x * True = x
 eq ap 'and pair(x, True) = x .
 
 *** False + x = x
 
  eq ap 'xor pair(False, x) = x . 
 
 *** True + x = not x
 
 eq ap 'xor pair(e1, True) = ap 'neg e1 .
 
 *** rl [xor-not-l] :  ap 'xor pair(e1, True) => ap 'neg e1 . 
 *** rl [xor-not-r] :  ap 'neg e1 => ap 'xor pair(e1, True) .
  
 *** False * x = False
 eq ap 'and pair(False, x) = False .    
 
  *** True * x = x
 eq ap 'and pair(True, x) = x .
 
  *** xor distrib over and
  eq (ap 'xor pair(ap 'and pair(e1, ap 'xor pair(e3, e4)), 
                   ap 'and pair(e2, ap 'xor pair(e3, e4))
                  )
    )
    =
    ap 'and pair( ap 'xor pair(e1, e2),
                  ap 'xor pair(e3, e4)
                )
  .               
 
 rl [flip-invar-xor-r] : rConfig(Sigma, Delta, Gamma (x : bool),
            y : bool <- samp ('flip < () >) ; 
            return (ap 'xor pair(x, y)), I, A, bool
            )
            => 
            rConfig(Sigma, Delta , Gamma (x : bool),
            samp ('flip < () >), I, A, bool) .  
            
 rl [flip-invar-xor-l] : rConfig(Sigma, Delta, Gamma (y : bool),
            x : bool <- samp ('flip < () >) ; 
            return (ap 'xor pair(x, y)), I, A, bool
            )
            => 
            rConfig(Sigma, Delta , Gamma (y : bool),
            samp ('flip < () >), I, A, bool) .
                       
 *** induction proof 1
 strat shareOTInd @ ProtocolConfig .
 sd shareOTInd := 
       applyDropName(fam ('BobOK[bound K]))
     *** first we remove the group name, then we will add it back in a sym proof
     ; applySubstChannelCase3(
         fam ('OTBitOK-A-B[bound 'B]), 'OTBitOK-B-A['B], 
         nf('ba : bool <- read ('OTBit-A-B['B]), return (), 'ba  ), 
         nf(('ba : bool <- read ('OTBit-A-B['B])) 
                   ('xa : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
                   ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
                   ('ya : unit <- read ('ShareOK-A[fun 'wire1 'B])) 
                   ('yb : unit <- read ('ShareOK-B[fun 'wire1 'B])), 
                   return (), 
                   'ba 'xa 'ya 'xb 'yb  ), 
         apply 'isAndGate 'B
       ) 
     ; applySubstChannelCase3(
            fam ('ShareOK-A[bound K]),
            'OTBitOK-B-A['B], 
             nf('xa : bool <- read ('Share-A[fun 'wire0 'B]), 
                return (), 'xa  ),
          nf( ('ba : bool <- read ('OTBit-A-B['B]))
              ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
              ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
              ('ya : unit <- read ('ShareOK-A[fun 'wire1 'B])) 
              ('yb : unit <- read ('ShareOK-B[fun 'wire1 'B])), 
               return (), 
               'ba 'xa 'ya 'xb 'yb  
            ),
            apply 'isAndGate 'B
        ) 
     ; applySubstChannelCase3(
            fam ('ShareOK-B[bound 'B]), 
            'OTBitOK-B-A['B], 
             nf('xb : bool <- read ('Share-B[fun 'wire0 'B]), 
                return (), 'xb  ),
          nf( ('ba : bool <- read ('OTBit-A-B['B]))
              ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
              ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
              ('ya : unit <- read ('ShareOK-A[fun 'wire1 'B])) 
              ('yb : unit <- read ('ShareOK-B[fun 'wire1 'B])), 
               return (), 
               'ba 'xa 'ya 'xb 'yb  
            ),
            apply 'isAndGate 'B
        ) 
        ; applyBranch1Alpha(chn ('OTBitOK-B-A['B]), 
                           << 'xa, 'sa >> emptyQidPairList) 
        ; applySubstChannelCase3(
            fam ('ShareOK-A[bound K]),
            'OTBitOK-B-A['B], 
             nf('xa : bool <- read ('Share-A[fun 'wire1 'B]), 
                return (), 'xa  ),
          nf( ('ba : bool <- read ('OTBit-A-B['B]))
              ('sa : bool <- read ('Share-A[fun 'wire0 'B])) 
              ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
              ('xa : bool <- read ('Share-A[fun 'wire1 'B])) 
              ('yb : unit <- read ('ShareOK-B[fun 'wire1 'B])), 
               return (), 
               'ba 'sa 'xa 'xb 'yb  
            ),
            apply 'isAndGate 'B
        ) 
        ; applyBranch1Alpha(chn ('OTBitOK-B-A['B]), 
                           << 'xa, 'ya >> 
                           << 'sa, 'xa >>
                           << 'xb, 'sb >> emptyQidPairList) 
        ; applySubstChannelCase3(
            fam ('ShareOK-B[bound 'B]),
            'OTBitOK-B-A['B], 
             nf('xb : bool <- read ('Share-B[fun 'wire1 'B]), 
                return (), 'xb  ),
             nf(('ba : bool <- read ('OTBit-A-B['B])) 
                ('sb : bool <- read ('Share-B[fun 'wire0 'B])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
                ('xb : bool <- read ('Share-B[fun 'wire1 'B])) 
                 'ya : bool <- read ('Share-A[fun 'wire1 'B]), 
                 return (),
                'ba 'xa 'ya 'sb 'xb  ),
            apply 'isAndGate 'B
        )  
        ; applyBranch1Alpha(chn ('OTBitOK-B-A['B]),
                           << 'xb, 'yb >> 
                           << 'sb, 'xb >> emptyQidPairList)                    
        ; SYM[P1:Protocol <- new3OT]{
           applySubstFamiliesOneCases1(fam ('OTBit-B-A[bound 'B]), 'OTBitOK-B-A['B], unit, 'ot)
          } 
        ****
        **** from here it's the second part of the induction
        ****
        ; CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B]]
          { *** isAliceInput
            substNFFamilyOne(fam ('InputShareOK-B-A[bound N]), 'ShareOK-B['B],
           nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 'B]), return (), 
              'xb  )
          )
          ; SYM[P1:Protocol <- new3OTInd]{
            substNFFamilyOne(fam ('Share-B[bound N]), 'ShareOK-B['B],
       nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'B])) 
       'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'B]), 
       return 'is, 'x 'is  )
      )
      ;
      substNFFamilyOne(fam ('InputShareOK-B-A[bound N]), 'ShareOK-B['B],
       nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 'B]), return (), 
     'xb  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'is, 'xb >> emptyQidPairList)
          }
          , CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B]]{
       *** isBobInput
           substNFFamilyOne(fam ('InputShareOK-B-B[bound M]), 'ShareOK-B['B],
           nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 'B]), return (), 
              'xb  )
          )
          ; SYM[P1:Protocol <- new3OTInd]{
              substNFFamilyOne(fam ('Share-B[bound 'B]), 'ShareOK-B['B],
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'B])) 
       'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'B]), 
       return 'is, 'x 'is  )
      )
      ;
      substNFFamilyOne(fam ('InputShareOK-B-B[bound M]), 'ShareOK-B['B],
       nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 'B]), return (), 
     'xb  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'is, 'xb >> emptyQidPairList)
            }
          , 
          CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B]]{
       *** isNotGate
       substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
        nf('xb : bool <- read ('Share-B[fun 'wire0 'B]), return (), 'xb  )
       )
       ; SYM[P1:Protocol <- new3OTInd]{
         substNFFamilyOne(fam ('Share-B[bound K]), 'ShareOK-B['B],
       nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
           'xb : bool <- read ('Share-B[fun 'wire0 'B]), 
           return (ap 'neg 'xb), 'x 'xb  )
      )
      ;
      substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
       nf( 'xb : bool <- read ('Share-B[fun 'wire0 'B]), 
           return (), 'xb  )
      ) 
       }
       , CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B]]{
       *** isXorGate
         substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
          nf('xb : bool <- read ('Share-B[fun 'wire0 'B]), 
             return (), 'xb  )
         )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xb, 'is >> emptyQidPairList)
       ; substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
          nf('xb : bool <- read ('Share-B[fun 'wire1 'B]), 
             return (), 'xb  )
         )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]),
                         << 'xb, 'yb >> 
                         << 'is, 'xb >>
                         emptyQidPairList) 
       ; SYM[P1:Protocol <- new3OTInd]{
         substNFFamilyOne(fam ('Share-B[bound K]), 'ShareOK-B['B],
      
      nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
         ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'B])) 
          'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
          return (ap 'xor pair('xb, 'yb)), 
          'xb 'x 'yb 'y  )
      )
      ;
       substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
       nf( 'xb : bool <- read ('Share-B[fun 'wire0 'B]), 
           return (), 'xb  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xb, 'is >> emptyQidPairList)
      ;
       substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
       nf( 'xb : bool <- read ('Share-B[fun 'wire1 'B]), 
           return (), 'xb  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xb, 'yb >> 
                                            << 'is, 'xb >> emptyQidPairList)
      ; changeOrder(chn ('ShareOK-B['B]), 'xb 'yb  ) 
       }                    
       ,
                         
        CASE-DISTINCTION-channel-end-when{
         *** isAndGate 
         substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
          nf('xb : bool <- read ('Share-B[fun 'wire0 'B]), 
             return (), 'xb  )
         )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xb, 'is >> emptyQidPairList)
       ; substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
          nf('xb : bool <- read ('Share-B[fun 'wire1 'B]), 
             return (), 'xb  )
         )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]),
                         << 'xb, 'yb0 >> 
                         << 'is, 'xb0 >>
                         emptyQidPairList)  
                             
       ; substNFFamilyOne(fam ('OTBitOK-B-A[bound 'B]), 'ShareOK-B['B],
          nf('bb : bool <- read ('OTBit-B-A['B]), return (), 
             'bb  )
         )
       ; SYM[P1:Protocol <- new3OTInd]{
         substNFFamilyOne(fam ('Share-B[bound K]), 'ShareOK-B['B],
       nf(('b : unit <- read ('OTBitOK-B-A['B])) 
          ('bb : bool <- read ('OTBit-B-A['B])) 
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
          ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'B])) 
           'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
           return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
           'bb 'b 'xb 'x 'yb 'y  )
      )
      ;
      substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
       nf( 'xb : bool <- read ('Share-B[fun 'wire0 'B]), 
           return (), 'xb  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xb, 'is >> emptyQidPairList)
      ;
       substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
       nf( 'xb : bool <- read ('Share-B[fun 'wire1 'B]), 
           return (), 'xb  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xb, 'yb0 >> 
                                            << 'is, 'xb0 >> emptyQidPairList)
      ; substNFFamilyOne(fam ('OTBitOK-B-A[bound K]), 'ShareOK-B['B],
          nf('bb : bool <- read ('OTBit-B-A['B]), return (), 'bb)
         )
    ; changeOrder( chn ('ShareOK-B['B]),
        'bb 'xb0 'yb0  
       )
       }
        }         
       }               
       }
       }
       }
       ; applyAllSameCases(chn ('ShareOK-B['B]))
       ; SYM[P1:Protocol <- new3OTIndEnd] {
         applyDropName(fam ('BobOK[bound K]))
       }
 .             
            
 *** subst with cases strategies
 
 var fns : NameWithScripts .
 
 strat applySubstFamiliesOneCases1 : CNameBound ChannelName Type Qid @ ProtocolConfig .
 sd applySubstFamiliesOneCases1(fam (fns[bounds]), q[nt], T, x) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstFamiliesOneCases1(fam (fns[bounds]), q[nt], T, x)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (fns[bounds])) (chn (q[nt])), 
        P1:Protocol <- keepTwo P (fam (fns[bounds])) (chn (q[nt]))]
                             {
      subst-families-one-cases
         {applyCasesSubstChannelDivergeOwise(q[nt], fns[nt], T, x)}
        }
 .           
            
 *** induction strategies
 
 strat bigInduction @ ProtocolConfig .
 sd bigInduction := 
   SYM[P1:Protocol <- restr16GIndEnd5]{
        applyAllSameCases(chn ('Wire['B])) 
       }
     ; applyDropName(fam ('Group[bound K]))
    *** for alice input   
    ;  applySubstChannelCase3(
            fam ('Share-A[bound K]), 
            'Wire['B], 
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'B]),
                return 'is, 'is  ),
             nf(('is : bool <- read ('InputShare-A-A[fun 'wire0 'B])) 
                 'xb : bool <- read ('Share-B['B]), 
                 return (ap 'xor pair('is, 'xb)), 'is 'xb  ),
            apply 'isAliceInput 'B
        )
     ; applyAlphaBranchCond(chn ('Wire['B]), 'is, 'xa, 
                           when (apply 'isAliceInput 'B))
     *** bob input                           
    ;  applySubstChannelCase3(
            fam ('Share-A[bound K]),  
            'Wire['B], 
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'B]),
                return 'is, 'is  ),
             nf(('is : bool <- read ('InputShare-A-B[fun 'wire0 'B])) 
                 'xb : bool <- read ('Share-B['B]), 
                 return (ap 'xor pair('is, 'xb)), 'is 'xb  ),
            apply 'isBobInput 'B
        ) 
      ; applyAlphaBranchCond(chn ('Wire['B]), 'is, 'xa, 
                           when (apply 'isBobInput 'B)) 
    *** not gate  
    ;  applySubstChannelCase3(
            fam ('Share-A[bound K]), 
            'Wire['B], 
             nf('sa : bool <- read ('Share-A[fun 'wire0 'B]), 
                return 'sa, 'sa  )   ,
             nf(('sa : bool <- read ('Share-A[fun 'wire0 'B])) 
                 'xb : bool <- read ('Share-B['B]), 
                 return (ap 'xor pair('sa, 'xb)), 'sa 'xb  ),
            apply 'isNotGate 'B
        )                       
     ; applyAlphaBranchCond(chn ('Wire['B]), 'sa, 'xa, 
                           when (apply 'isNotGate 'B))
     *** xor gate  
    ;  applySubstChannelCase3(
            fam ('Share-A[bound K]),
            'Wire['B], 
             nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 'B])), 
                 return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )  ,
             nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
                 'xb : bool <- read ('Share-B['B]), 
                 return (ap 'xor pair((ap 'xor pair('xa, 'ya)), 'xb)), 
                 'ya 'xa 'xb  ),
            apply 'isXorGate 'B
        )                       
     *** and gate
    ;  applySubstChannelCase3(
            fam ('Share-A[bound K]),
            'Wire['B], 
             nf(('ba : bool <- read ('OTBit-A-B['B])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 'B])), 
                return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
                'ba 'xa 'ya  ) ,
             nf(('ba : bool <- read ('OTBit-A-B['B])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 'B]))
                 'xb : bool <- read ('Share-B['B]), 
                 return (ap 'xor pair((ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 'xb)), 
                 'ba 'ya 'xa 'xb  ),
            apply 'isAndGate 'B
        )                     
    *** now for Share-B   
        
    ; CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{
       applySelectCaseSubst(
         'Share-B['B], 'Wire['B], apply 'isAliceInput 'B
       )
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{
       applySelectCaseSubst(
         'Share-B['B], 'Wire['B], apply 'isBobInput 'B
       )
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{
       applySelectCaseSubst(
         'Share-B['B], 'Wire['B], apply 'isNotGate 'B
       )
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{
       applySelectCaseSubst(
         'Share-B['B], 'Wire['B], apply 'isXorGate 'B
       )
      , CASE-DISTINCTION-channel-end-when[cn:ChannelName <- 'Wire['B]]{
        applySelectCaseSubst(
         'Share-B['B], 'Wire['B], apply 'isAndGate 'B
       )
    }
        }}}
     } 
     *** renamings
    ; applyAlphaBranchCond(chn ('Wire['B]), 'is, 'xb, 
                           when (apply 'isAliceInput 'B))      
    ; applyAlphaBranchCond(chn ('Wire['B]), 'is, 'xb, 
                           when (apply 'isBobInput 'B)) 
                           
    *** now we handle the Share-B[B+1] part
    ; SYM[P1:Protocol <- restr16GIndSymShare]{
     applyDropName(fam ('Group[bound K]))
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'xa, 'ya, 
                           when (apply 'isAliceInput 'B)
                         )
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'xa, 'ya, 
                           when (apply 'isBobInput 'B)
                         )  
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'xa, 'ya, 
                           when (apply 'isNotGate 'B)
                         )                                            
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'xa, 'za, 
                           when (apply 'isXorGate 'B)
                         )  
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'xa, 'za, 
                           when (apply 'isAndGate 'B)
                         )
                        
   
    ; CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B]]{
       applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isAliceInput 'B
      ),
      CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B]]{
       applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isBobInput 'B
      ),
      CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B]]{
       applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isNotGate 'B
      ),
      CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B]]{
       applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isXorGate 'B
      ),
      CASE-DISTINCTION-channel-end-when[cn:ChannelName <- 'Share-B['B]]{
        applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isAndGate 'B
        )
      }
    }
    }
    }
    }  
    *** for alice input
   ;  applySubstChannelCase3(
            fam ('Share-A[bound K]), 
            'Share-B['B], 
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'B]),
                return 'is, 'is  ),
             nf(('is : bool <- read ('InputShare-A-A[fun 'wire0 'B])) 
                 'xb : bool <- read ('InputShare-B-A[fun 'wire0 'B]), 
                 return (ap 'xor pair('is, ap 'xor pair('is, 'xb))), 
                 'is 'xb  ),
            apply 'isAliceInput 'B
        ) 
   *** get to what we want
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'is, 'xa, 
                           when (apply 'isAliceInput 'B)
                         )  
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'xb, 'is, 
                           when (apply 'isAliceInput 'B)
                         )  
   *** for bob input  
   ;  applySubstChannelCase3(
            fam ('Share-A[bound K]), 
            'Share-B['B], 
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'B]),
                return 'is, 'is  ),
             nf(('is : bool <- read ('InputShare-A-B[fun 'wire0 'B])) 
                ('xb : bool <- read ('InputShare-B-B[fun 'wire0 'B])),
                 return (ap 'xor pair('is, ap 'xor pair('is, 'xb))), 
                 'is 'xb  ),
            apply 'isBobInput 'B
        ) 
   *** some renamings
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'is, 'xa, 
                           when (apply 'isBobInput 'B)
                         )  
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'xb, 'is, 
                           when (apply 'isBobInput 'B)  
                         )  
   *** for not gate
    ;  applySubstChannelCase3(
            fam ('Share-A[bound K]), 
            'Share-B['B], 
             nf('sa : bool <- read ('Share-A[fun 'wire0 'B]), 
                return 'sa, 'sa  ),
             nf(('sa : bool <- read ('Share-A[fun 'wire0 'B])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'B])), 
                return (ap 'xor pair('sa, ap 'xor pair('sa, ap 'neg 'xb))), 
                'sa 'xb  ),
            apply 'isNotGate 'B
        )      
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'sa, 'xa, 
                           when (apply 'isNotGate 'B)
                         )       
   *** for xor gate 
   
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'xa, 'aa, 
                           when (apply 'isXorGate 'B)
                         )
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'ya, 'ba, 
                           when (apply 'isXorGate 'B)
                         ) 
   ;  applySubstChannelCase3(
            fam ('Share-A[bound K]), 
            'Share-B['B], 
             nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
                 'ya : bool <- read ('Share-A[fun 'wire1 'B]), 
                 return (ap 'xor pair('xa, 'ya)), 'xa 'ya  ),
             nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
                ('yb : bool <- read ('Share-B[fun 'wire1 'B])), 
                return (ap 'xor pair('xb, 'yb)),
                'xa 'ya 'yb 'xb  ),
             apply 'isXorGate 'B
        )                       
   *** change the order to 'xb 'xa 'yb 'ya 
   ; applyChangeOrderBranch(
       'Share-B['B], 
       apply 'isXorGate 'B, 
       'xb 'xa 'yb 'ya  
     )   
   *** for and gate
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'ba, 'bc, 
                           when (apply 'isAndGate 'B)
                         )                         
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'xa, 'xc, 
                           when (apply 'isAndGate 'B)
                         )                         
   ; applyAlphaBranchCond(chn ('Share-B['B]), 'ya, 'yc, 
                           when (apply 'isAndGate 'B)
                         )                         
   ;  applySubstChannelCase3(
            fam ('Share-A[bound K]), 
            'Share-B['B], 
             nf(('ba : bool <- read ('OTBit-A-B['B])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
                 'ya : bool <- read ('Share-A[fun 'wire1 'B]), 
                 return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
                 'ba 'xa 'ya  ), 
             nf(('ba : bool <- read ('OTBit-A-B['B])) 
                ('bb : bool <- read ('OTBit-B-A['B])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
                 return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
                 'ba 'xa 'ya 'bb 'yb 'xb  ),
             apply 'isAndGate 'B
        )    
   *** change order to 'bb 'ba 'xb 'xa 'yb 'ya   
   ; applyChangeOrderBranch(
       'Share-B['B], 
       apply 'isAndGate 'B, 
       'bb 'ba 'xb 'xa 'yb 'ya  
     )
    
      }  
     ; applyAllSameCases(chn ('Share-B['B]))
     
     *** now we have to get back to Wire['B]
    ; CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{ 
        *** alice               
        substNFFamilyOne(fam ('InputShare-B-A[bound N]), 'Wire['B],
           nf(('x : bool <- read ('In-A[fun 'wire0 'B])) 
               'xa : bool <- read ('InputShare-A-A[fun 'wire0 'B]), 
               return (ap 'xor pair('x, 'xa)), 'x 'xa  )
          )
        ; applyDropNFCF(fam ('InputShare-A-A[bound N]), 'Wire['B]) 
        ; applyAlphaNFPr(chn ('Wire['B]), << 'x, 'inA0 >> emptyQidPairList ) 
        ; SYM[P1:Protocol <- restr16GSymAlice]{idle}
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{  
        *** bob            
        substNFFamilyOne(fam ('InputShare-B-B[bound M]), 'Wire['B],
           nf(('x : bool <- read ('In-B[fun 'wire0 'B])) 
               'xa : bool <- read ('InputShare-A-B[fun 'wire0 'B]), 
               return (ap 'xor pair('x, 'xa)), 'x 'xa  ) 
          )
        ; applyDropNFCF(fam ('InputShare-A-B[bound M]), 'Wire['B]) 
        ; applyAlphaNFPr(chn ('Wire['B]), << 'x, 'inB0 >> emptyQidPairList )  
        ; SYM[P1:Protocol <- restr16GSymBob]{idle}
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{  
         *** not
         applyDropName(fam ('Group[bound K]))
         ; SYM[P1:Protocol <- restr16GSymNot]{
               applyDropName(fam ('Group[bound K]))
             ; substNFFamilyOne(fam ('Wire[bound 'B]), 'Wire['B],
           nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
         'xb : bool <- read ('Share-B[fun 'wire0 'B]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
          )
           }, 
         CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{  
         *** xor
           applySwap23Xor('Wire['B])
          ; applyDropName(fam ('Group[bound K]))
          ; SYM[P1:Protocol <- restr16GSymXor]{
             applyDropName(fam ('Group[bound K]))
    ; substNFFamilyOne(fam ('Wire[bound 'B]), 'Wire['B],
           nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
         'xb : bool <- read ('Share-B[fun 'wire0 'B]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
          ) 
    ; applyAlphaNFPr(chn ('Wire['B]), << 'xa, 'ua >> << 'xb, 'ub >> emptyQidPairList )   
    ; substNFFamilyOne(fam ('Wire[bound 'B]), 'Wire['B],
           nf(('xa : bool <- read ('Share-A[fun 'wire1 'B])) 
         'xb : bool <- read ('Share-B[fun 'wire1 'B]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
          )
    ; applyAlphaNFPr(chn ('Wire['B]), 
                             << 'xa, 'ya >> << 'xb, 'yb >>
                             << 'ua, 'xa >> << 'ub, 'xb >> emptyQidPairList )
    ; changeOrder(chn ('Wire['B]), 'xa 'yb 'ya 'xb  )    
          }
         ,
         
          *** just a change of order, happens by nfs, and transforming the return, xor
         CASE-DISTINCTION-channel-end-when[cn:ChannelName <- 'Wire['B]]{
          *** and
          applySelectCaseSubst(
              'OTBit-B-A['B], 'Wire['B], apply 'isAndGate 'B
          )
            *** need to transform the return
          ; applyAndXorTerm('Wire['B])

          ; applyDropNFCFCases(fam ('OTBit-A-B[bound K]), 'Wire['B], apply 'isAndGate 'k) 
          ; applyDistribR('Wire['B])
          ; applyDropName(fam ('Group[bound K]))
          ; SYM[P1:Protocol <- restr16GSymAnd] {
            applyDropName(fam ('Group[bound K]))
    ; substNFFamilyOne(fam ('Wire[bound 'B]), 'Wire['B],
           nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
         'xb : bool <- read ('Share-B[fun 'wire0 'B]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
          ) 
    ; applyAlphaNFPr(chn ('Wire['B]), << 'xa, 'ua >> << 'xb, 'ub >> emptyQidPairList )   
    ; substNFFamilyOne(fam ('Wire[bound 'B]), 'Wire['B],
           nf(('xa : bool <- read ('Share-A[fun 'wire1 'B])) 
         'xb : bool <- read ('Share-B[fun 'wire1 'B]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
          )
    ; applyAlphaNFPr(chn ('Wire['B]), 
                             << 'xa, 'ya >> << 'xb, 'yb >>
                             << 'ua, 'xa >> << 'ub, 'xb >> emptyQidPairList )
                             
    ; changeOrder(chn ('Wire['B]), 'xa 'yb 'ya 'xb  )
          } 
         }
        }}
    }
    }
   
    ; SYM[P1:Protocol <- restr16GIndStart]{idle}
     
     *** ; applyGetChannel('Wire['B])

 .
 
 strat apBigInd : Protocol @ ProtocolConfig .
 sd apBigInd(P) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{apBigInd(P)}
     : SINGLE-INDUCTION
       *** INDUCTION-P-3
                   [idx:Qid <- 'B,
                     q:Qid <- 'k,
                    P2:Protocol <- P                      
                   ]
                   { SYM[P1:Protocol <- restr16GIndEnd]{
                       bigInduction
                     }
                   }
     .
 
 strat apIndBobOK : Protocol @ ProtocolConfig .
 sd apIndBobOK(P) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{apIndBobOK(P)}
     : SINGLE-INDUCTION
       *** INDUCTION-P-3
                   [idx:Qid <- 'B, 
                     q:Qid <- 'k,
                    P2:Protocol <- P                      
                   ]
                   {
                   shareOTInd
                   }
     .
     
 strat apIndAliceOK : Protocol @ ProtocolConfig .
 sd apIndAliceOK(P) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{apIndAliceOK(P)}
     : SINGLE-INDUCTION
       *** INDUCTION-P-3
                   [idx:Qid <- 'B, 
                     q:Qid <- 'k,
                    P2:Protocol <- P                      
                   ]
                   {
                   shareOTAliceInd
                   }
     .  
     
 strat apInd78 : Protocol @ ProtocolConfig .
 sd apInd78(P) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{apInd78(P)}
     : SINGLE-INDUCTION
       *** INDUCTION-P-3
                   [idx:Qid <- 'B, 
                     q:Qid <- 'k,
                    P2:Protocol <- P                      
                   ]
                   {
                   induction78
                   }
     .    
     
 strat induction78 @ ProtocolConfig .
 sd induction78 :=
         applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       ; applyDropName(fam ('AliceOK[bound K]))
       *** from here we start the proof
       ; applyDropName(fam ('BobOK[bound K]))
       ; CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B]]{
       *** isAliceInput
       substNFFamilyOne(fam ('InputShareOK-B-A[bound N]), 'ShareOK-B['B],
           nf('xa : unit <- read ('InputShareOK-A-A[fun 'wire0 'B]), 
              return 'xa, 
              'xa  )
          )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xa, 'is >> emptyQidPairList) 
       ; SYM[P1:Protocol <- new7Ind0]{
          substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B['B],
           nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 'B]), return 'is, 
              'is  )
          )
       }
       ,
       CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B]]{
       *** isBobInput
        substNFFamilyOne(fam ('InputShareOK-B-B[bound M]), 'ShareOK-B['B],
           nf('xa : unit <- read ('InputShareOK-A-B[fun 'wire0 'B]), return 'xa, 
              'xa  )
          )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xa, 'is >> emptyQidPairList)     
       ; SYM[P1:Protocol <- new7Ind0]{
          substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B['B],
           nf('is : unit <- read ('InputShareOK-A-B[fun 'wire0 'B]), return 'is, 
              'is  )
          )
       }
         , CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B]]{
       *** isNotGate
        substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'B]), return 'sa, 
              'sa  )
          )
       ; SYM[P1:Protocol <- new7Ind0]{
         substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B['B],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'B]),
           return 'sa, 'sa  )
          )
       } 
       , CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B]]{
       *** isXorGate
       substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'B]), return 'sa, 
              'sa  )
          )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'sa, 'is >> emptyQidPairList)    
       ; substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire1 'B]), return 'sa, 
              'sa  )
          )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'is, 'xa >> 
                                               << 'sa, 'ya >> emptyQidPairList)      
       ; SYM[P1:Protocol <- new7Ind0]{
        substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B['B],
           nf(('xa : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
         'ya : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
         return (), 'xa 'ya  )
          )
       }                
       , CASE-DISTINCTION-channel-end-when{
         *** isAndGate 
         substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
          nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'B]), 
             return 'sa, 'sa  )
         )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'sa, 'is >> emptyQidPairList)
       ; substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
          nf('sa : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
             return 'sa, 'sa  )
         )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), 
                         << 'sa, 'yb0 >> 
                         << 'is, 'xb0 >>
                         emptyQidPairList)  
       ; applySelectCaseSubst(
          'OTBitOK-B-A['B], 'ShareOK-B['B], apply 'isAndGate 'B
         )
                         
       
      ; substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
       nf( 'sa : unit <- read ('ShareOK-A[fun 'wire0 'B]), 
           return 'sa, 'sa  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'sa, 'is >> emptyQidPairList)
      ;
       substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
       nf( 'sa : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
           return 'sa, 'sa  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'sa, 'ya >> 
                                            << 'is, 'xa >> emptyQidPairList) 
                              
         ; SYM[P1:Protocol <- new7Ind0]{
           substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B['B],
            nf(('ba : unit <- read ('OTBitOK-A-B['B])) 
               ('xa : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
                'ya : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
                return (), 'ba 'xa 'ya  )
          ) 
          }
           }}
       }
       }
         }  
       ; applyAllSameCases(chn ('ShareOK-B['B]))    
       *** now the second part of the proof
       ; applySubstChannelCase3(
           fam ('OTBitOK-A-B[bound K]),
           'OTBitOK-B-A['B],
           nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
               'al : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
              return (), 'ak 'al  ),
           nf(
              ('ak : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
              ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
              ('al : unit <- read ('ShareOK-A[fun 'wire1 'B])) 
               'yb : unit <- read ('ShareOK-B[fun 'wire1 'B]), 
               return (), 
               'ak 'al 'xb 'yb  ),
            apply 'isAndGate 'B  
         )
       ; applySubstChannelCase3(
            fam ('ShareOK-B[bound 'B]), 
            'OTBitOK-B-A['B], 
             nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'B]), 
                return 'sa, 'sa  ),
             nf( ('sa : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
                 ('al : unit <- read ('ShareOK-A[fun 'wire1 'B])) 
                  'yb : unit <- read ('ShareOK-B[fun 'wire1 'B]),
                 return (), 
                 'al 'sa 'yb  ),
             apply 'isAndGate 'B
        )  
       ; applyBranch1Alpha(chn ('OTBitOK-B-A['B]), << 'sa, 'ak >> emptyQidPairList) 
       ; applySubstChannelCase3(
            fam ('ShareOK-B[bound 'B]), 
            'OTBitOK-B-A['B], 
             nf('sa : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
                return 'sa, 'sa  ),
             nf( ('ak : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
                 ('sa : unit <- read ('ShareOK-A[fun 'wire1 'B])),
                 return (), 
                 'ak 'sa  ),
             apply 'isAndGate 'B
        )
       ; applyBranch1Alpha(chn ('OTBitOK-B-A['B]), << 'sa, 'al >> emptyQidPairList) 
       ; SYM[P1:Protocol <- new7IndEnd]{
         applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       ; applyDropName(fam ('AliceOK[bound K]))
       ; applyDropName(fam ('BobOK[bound K]))
       ; applyCasesSubstFC(
           fam ('OTBitOK-A-B[bound K]), 'OTBitOK-B-A['B], 
           nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
               'al : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
               return (), 'ak 'al  ),
           unit, 'ot)
       }  
 .
     
 strat shareOTAliceInd @ ProtocolConfig .
 sd shareOTAliceInd := 
         applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       ; applyDropName(fam ('BobOK[bound K]))
       *** from here we start the proof
       *** drop AliceOK, we will add it back with sym
       ; applyDropName(fam ('AliceOK[bound K]))
             
       ; applySubstChannelCase3(
            fam ('ShareOK-A[bound K]),
            'OTBitOK-A-B['B], 
             nf('xa : bool <- read ('Share-A[fun 'wire0 'B]), 
                return (), 'xa  ),
             nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
                 'al : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
                 return (), 
                 'xa 'al  ),
            apply 'isAndGate 'B
        )
        ; applyBranch1Alpha(chn ('OTBitOK-A-B['B]), 
                           << 'xa, 'sa >> emptyQidPairList)
        ; applySubstChannelCase3(
            fam ('ShareOK-A[bound K]),
            'OTBitOK-A-B['B], 
             nf('xa : bool <- read ('Share-A[fun 'wire1 'B]), 
                return (), 'xa  ),
             nf(('sa : bool <- read ('Share-A[fun 'wire0 'B])) 
                 'xa : bool <- read ('Share-A[fun 'wire1 'B]), 
                 return (), 
                 'sa 'xa  ),
            apply 'isAndGate 'B
        )  
        ; applyBranch1Alpha(chn ('OTBitOK-A-B['B]), 
                           << 'xa, 'ya >> 
                           << 'sa, 'xa >> emptyQidPairList)   
       
        ; SYM[P1:Protocol <- new5IndInt]{
         applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       ; applyDropName(fam ('BobOK[bound K]))
       *** from here we start the proof
       ; applyDropName(fam ('AliceOK[bound K]))
       ; applyCasesSubsumeDropDivergeOwiseC(
          fam ('OTBit-A-B[bound K]), 
          'OTBitOK-A-B['B], 
          'xa 'ya  , 
          unit, 'ot
          )
        }
       ;  applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       ; applyDropName(fam ('BobOK[bound K]))
       ; applyDropName(fam ('AliceOK[bound K]))
       
       ;
         CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B]]{
       *** isAliceInput
       substNFFamilyOne(fam ('InputShareOK-A-A[bound N]), 'ShareOK-A['B],
           nf('xa : bool <- read ('InputShare-A-A[fun 'wire0 'B]), 
              return (), 'xa  )
          )    
        ; SYM[P1:Protocol <- new5Ind0]{
            substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A['B],
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'B]), 
             return 'is, 'is  )
            )
          ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'is, 'xa >> emptyQidPairList) 
          } 
          , 
          CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B]]{
       *** isBobInput
        substNFFamilyOne(fam ('InputShareOK-A-B[bound M]), 'ShareOK-A['B],
           nf('xa : bool <- read ('InputShare-A-B[fun 'wire0 'B]), return (), 
              'xa  )
          )
        ; SYM[P1:Protocol <- new5Ind0]{
            substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A['B],
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'B]), 
             return 'is, 'is  )
            )
            ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'is, 'xa >> emptyQidPairList)
          }  ,
          CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B]]{
       *** isNotGate
        substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire0 'B ]),
          return (), 'xa  )
       )
       
       ; SYM[P1:Protocol <- new5Ind0]{
        substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A['B],
       nf('sa : bool <- read ('Share-A[fun 'wire0 'B ]),
          return 'sa, 'sa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'sa, 'xa >> emptyQidPairList)
       }
       , 
        CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B]]{
       *** isXorGate
       substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire0 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire1 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
       ; changeOrder(chn ('ShareOK-A['B]), 'ya 'xa  )                   
       ; SYM[P1:Protocol <- new5Ind0]{
          substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A['B],
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'B]), 
        return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )
      )
       }, CASE-DISTINCTION-channel-end-when{
           
        
         *** isAndGate 
         substNFFamilyOne(fam ('OTBitOK-A-B[bound K]), 'ShareOK-A['B],
       nf('ba : bool <- read ('OTBit-A-B['B]), return (), 'ba  )
       )      
      ; substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire0 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire1 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
                       
        ; SYM[P1:Protocol <- new5Ind0]{
           substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A['B],
       nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'B]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba 'xa 'ya  )
     ) 
     ; changeOrder(chn ('ShareOK-A['B]), 'ba 'xa 'ya  ) 
        }
        
                      
       }
       
       }
        }
         }
       }  
             
       ; applyAllSameCases(chn ('ShareOK-A['B]))
       ; SYM[P1:Protocol <- new5IndEnd]{
         applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       ; applyDropName(fam ('BobOK[bound K]))
       ; applyDropName(fam ('AliceOK[bound K]))
       }
 .         
            
 *** strategies needed for splitting real in three parts
 
 op restr0 : -> Protocol .
 eq restr0 = restrInductive || restrFinal .
 
 strat rewriteRestrInitial @ ProtocolConfig .
 sd rewriteRestrInitial := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestrInitial}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[  *** add this for a speedup: Q:Protocol <- new2NF(restr0), 
                                      P1:Protocol <- new2NF(restrInitial)
                                   ]
                    {
     SYM[P1:Protocol <- restrInitial1]{
         substNFFamiliesOne(
           fam ('InputShare-A-B[bound M]), fam ('InputShare-B-B[bound M]),
           nf('sis : bool <- read ('SendInputShare-A-B['k]), return 'sis, 'sis  )
       )
     ; substNFFamiliesOne(
           fam ('InputShare-A-B[bound M]), 
           fam (('SendInputShare-A-B ^^ 'A .. 'adv)[bound M]),
           nf('sis : bool <- read ('SendInputShare-A-B['k]), return 'sis, 'sis  )
       )
     ; substNFFamiliesOne(
           fam ('InputShare-B-A[bound N]), 
           fam ('SendInputShare-B-A ^^ 'A .. 'adv[bound N]),
           nf('sis : bool <- read ('SendInputShare-B-A['k]), return 'sis, 'sis  )
       )
     ; applyAlphaNFPr(fam ('InputShare-B-B[bound M]), << 'sis,'xa >> emptyQidPairList)  
    }
      ; foldNFFamily(fam ('SendInputShare-A-B[bound M]), 
                     fam ('InputShare-A-B[bound M]))
      ; foldNFFamily(fam ('SendInputShare-B-A[bound N]), 
                     fam ('InputShare-B-A[bound N]))
                    }
 .
 
 strat rewriteRestrInductive @ ProtocolConfig .
  sd rewriteRestrInductive := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestrInductive}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[  *** Q:Protocol <- new2NF(restr0), 
                                      P1:Protocol <- new2NF(restrInductive)
                                   ]
                    { 
         sugar-newNF
          
       ; applyDropName(fam ('A[bound K]))
       ; applyDropName(fam ('B[bound K]))
       ; applyDropName(fam ('1OutOf4OT[bound K]))
             
       ; applyCasesSubstDivergeOwise(
          fam ('OTMsg-A-B-0[bound K]), 
          fam (('OTMsg-A-B-0 ^^ 'ot .. 'adv)[bound K]), 'k, bool, 'x3
        )
    
      ; applyCasesSubstDivergeOwise(
          fam ('OTMsg-A-B-1[bound K]), 
          fam (('OTMsg-A-B-1 ^^ 'ot .. 'adv)[bound K]), 'k, bool, 'x3
        )
        
      ; applyCasesSubstDivergeOwise(
          fam ('OTMsg-A-B-2[bound K]), 
          fam (('OTMsg-A-B-2 ^^ 'ot .. 'adv)[bound K]), 'k, bool, 'x3
        )
      ; applyCasesSubstDivergeOwise(
          fam ('OTMsg-A-B-3[bound K]), 
          fam (('OTMsg-A-B-3 ^^ 'ot .. 'adv)[bound K]), 'k, bool, 'x3
        )  
        
      ; applyCasesSubstDivergeOwise(
          fam ('OTChoice-B-A-0[bound K]), 
          fam (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv)[bound K]), 'k, unit, 'x3
        )
      ; applyCasesSubstDivergeOwise(
          fam ('OTChoice-B-A-1[bound K]), 
          fam (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv)[bound K]), 'k, unit, 'x3
        )  
          
      *** now we want to substitute in OTOut-B-A only for and gates
      *** so we need to add this case distinction
      ; applyAddSameCases(fam ('OTOut-B-A[bound K]), apply 'isAndGate 'k)
      *** now we can do the substitution on first branch
      ; applySameCasesSubstFirstBranch(
         fam ('OTMsg-A-B-0[bound K]), fam ('OTOut-B-A[bound K]), 'k)     
      ; applySameCasesSubstFirstBranch(
         fam ('OTMsg-A-B-1[bound K]), fam ('OTOut-B-A[bound K]), 'k)
      ; applySameCasesSubstFirstBranch(
         fam ('OTMsg-A-B-2[bound K]), fam ('OTOut-B-A[bound K]), 'k)
      ; applySameCasesSubstFirstBranch(
         fam ('OTMsg-A-B-3[bound K]), fam ('OTOut-B-A[bound K]), 'k)  
      ; applySameCasesSubstFirstBranch( 
          fam ('OTChoice-B-A-0[bound K]), fam ('OTOut-B-A[bound K]), 'k)
      ; applyBranch1Alpha(fam ('OTOut-B-A[bound K]), << 'sb, 'xb >> emptyQidPairList)
      ; applySameCasesSubstFirstBranch(
         fam ('OTChoice-B-A-1[bound K]), fam ('OTOut-B-A[bound K]), 'k)
             
      ; applyBranch1Alpha(fam ('OTOut-B-A[bound K]), << 'sb, 'yb >> emptyQidPairList)
      ; applyIfExt2(fam ('OTOut-B-A[bound K]),
                    return (ap 'xor pair('ba, 
                                 ap 'xor pair(ap 'and pair('xa, 'yb), 
                                              ap 'and pair('xb, 'ya)
                                             )
                                 )
                           ), 
                     'xb, 'yb)    
      ; applySameCasesSubstFirstBranch(
         fam ('OTOut-B-A[bound K]), fam ('OTBit-B-A[bound K]), 'k) 
                        
      ; SYM[P1:Protocol <- restrIndSplit]{
         sugar-newNF
       ; applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       ; applyDropName(fam ('ind1OutOf4OT[bound K]))
      }
      
      ; sugar-newNF  
      ; applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       ; applyDropName(fam ('ind1OutOf4OT[bound K]))

       ; absorbFamily(fam ('OTOut-B-A[bound K]))
       ; absorbFamily(fam ('OTMsg-A-B-0[bound K]))
       ; absorbFamily(fam ('OTMsg-A-B-1[bound K]))  
       ; absorbFamily(fam ('OTMsg-A-B-2[bound K]))
       ; absorbFamily(fam ('OTMsg-A-B-3[bound K]))
       ; absorbFamily(fam ('OTChoice-B-A-0[bound K]))
       ; absorbFamilyDeleteEmpty(fam ('OTChoice-B-A-1[bound K]))
             
     ***  here I need to do a sym proof from the protocol without the 4th component
      ; SYM[P1:Protocol <- restrIndSplitSym]{
         applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       
       }  
       ; SYM[P1:Protocol <- restrIndSplitSymNew]{
          sugar-newNF
        ; absorbFamily(fam ('InOK-A[bound N]))
        ; absorbFamily(fam ('InOK-B[bound M]))
        ; absorbFamily(fam ('InputShareOK-A-A[bound N]))
        ; absorbFamily(fam ('InputShareOK-A-B[bound M]))
        ; absorbFamily(fam ('InputShareOK-B-A[bound N]))
        ; absorbFamily(fam ('InputShareOK-B-B[bound M]))
        ; absorbFamily(fam ('OTBitOK-A-B[bound K]))
        ; absorbFamily(fam ('OTBitOK-B-A[bound K]))
        ; absorbFamily(fam ('ShareOK-A[bound K]))
        ; absorbFamilyDeleteEmpty(fam ('ShareOK-B[bound K]))
      } 
      ; sugar-newNF
      ; applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
      
      ; SYM[P1:Protocol <- restrIndSplitSymNew1]{
         sugar-newNF
       ; applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       ; applySubstFamilyCase(
                   fam ('ShareOK-B[bound K]), 
                   fam ('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv[bound K]),
                   'k,
                   nf('xb : bool <- read ('Share-B[fun 'wire0 'k]), 
                      return (), 'xb  )
                )
       ; applyBranch1Alpha(fam ('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv[bound K]), 
                           << 'xb, 'sb >> emptyQidPairList)   
       ; applySubstFamilyCase(
                   fam ('ShareOK-B[bound K]),
                   fam ('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv[bound K]),
                   'k,
                   nf('xb : bool <- read ('Share-B[fun 'wire1 'k]), 
                      return (), 'xb  )
                )
       ; applyBranch1Alpha(fam ('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv[bound K]), 
                           << 'xb, 'sb >> emptyQidPairList)                                
      }
      ; SYM[P1:Protocol <- new2]{
         sugar-newNF
        ; applyDropName(fam ('indBob[bound K]))
         ; applySubstFamilyCase3(
          fam ('InputShareOK-B-A[bound N]), 
          fam ('Share-B[bound K]), 'k,
          nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 'k]), 
             return (), 'xb  ),
          nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 'k]), 
             return 'xb, 'xb  ),
          apply 'isAliceInput 'k      
          )
           
        *** ; applyAlphaBranchCond('Share-B, 'xb, 'is, when (apply 'isAliceInput 'k))   
        ; applySubstFamilyCase3(
          fam ('InputShareOK-B-B[bound M]), fam ('Share-B[bound K]), 'k,
          nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 'k]), 
             return (), 'xb  ),
          nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 'k]), 
             return 'xb, 'xb  ),
          apply 'isBobInput 'k      
          )      
        ; applyAlphaBranchCond(fam ('Share-B[bound K]), 'xb, 'is, when (apply 'isNotGate 'k))  
        ; applySubstFamilyCase3(fam ('ShareOK-B[bound K]), fam ('Share-B[bound K]), 'k,
             nf('xb : bool <- read ('Share-B[fun 'wire0 'k]), 
                return (), 'xb  ),
          nf('xb : bool <- read ('Share-B[fun 'wire0 'k]), 
             return (ap 'neg 'xb), 'xb  ),
          apply 'isNotGate 'k      
          ) 
        ; applySubstFamilyCase3(fam ('ShareOK-B[bound K]), fam ('Share-B[bound K]), 'k,
             nf('xb : bool <- read ('Share-B[fun 'wire0 'k]), 
                return (), 'xb  ),
          nf( ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
              ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
               'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
               return (ap 'xor pair('xb, 'yb)), 
               'xb 'yb 'y  ),
          apply 'isXorGate 'k      
          )
        ; applyAlphaBranchCond(fam ('Share-B[bound K]), 'xb, 'a, when (apply 'isXorGate 'k)) 
        ; applySubstFamilyCase3(fam ('ShareOK-B[bound K]), fam ('Share-B[bound K]), 'k,
             nf('xb : bool <- read ('Share-B[fun 'wire1 'k]), 
                return (), 'xb  ),
          nf( ('a : bool <- read ('Share-B[fun 'wire0 'k])) 
               'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
               return (ap 'xor pair('a, 'yb)), 
               'a 'yb  ),
          apply 'isXorGate 'k      
          )
         ; applyAlphaBranchCond(fam ('Share-B[bound K]), 'a, 'xb, when (apply 'isXorGate 'k))
         
         ; applySubstFamilyCase3(fam ('OTBitOK-B-A[bound K]), fam ('Share-B[bound K]), 'k,
             nf('bb : bool <- read ('OTBit-B-A['k]), return (), 'bb  ),
             nf(('bb : bool <- read ('OTBit-B-A['k])) 
                ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
                ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
                 return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
                 'bb 'xb 'x 'yb 'y  ),
          apply 'isAndGate 'k      
          )
          ; applySubstFamilyCase3(fam ('ShareOK-B[bound K]), fam ('Share-B[bound K]), 'k,
             nf('xb : bool <- read ('Share-B[fun 'wire0 'k]), 
                return (), 'xb  ),
             nf(('bb : bool <- read ('OTBit-B-A['k])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
                ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
                 return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
                 'bb 'xb 'yb 'y  ),
          apply 'isAndGate 'k      
          ) 
          ; applyAlphaBranchCond(fam ('Share-B[bound K]), 'xb, 'a, when (apply 'isAndGate 'k)) 
          ; applySubstFamilyCase3(fam ('ShareOK-B[bound K]), fam ('Share-B[bound K]), 'k,
             nf('xb : bool <- read ('Share-B[fun 'wire1 'k]), 
                return (), 'xb  ),
             nf(('bb : bool <- read ('OTBit-B-A['k])) 
                ('a : bool <- read ('Share-B[fun 'wire0 'k])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
                 return (ap 'xor pair('bb, ap 'and pair('a, 'yb))), 
                 'bb 'a 'yb  ),
          apply 'isAndGate 'k      
          )
          ; applyAlphaBranchCond(fam ('Share-B[bound K]), 'a, 'xb, when (apply 'isAndGate 'k)) 
          ; SYM[P1:Protocol <- restrIndSplitSymNew1]{
              sugar-newNF
            ; applyDropName(fam ('indBob[bound K]))
            ; applyAlphaBranchCond(fam ('Share-B[bound K]), 
                'is, 'xb, when (apply 'isAliceInput 'k))
            ; applyAlphaBranchCond(fam ('Share-B[bound K]), 
                'is, 'xb, when (apply 'isBobInput 'k))  
          }
          }
          
          ; sugar-newNF
          ; applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
          
           
             
      ***( subcomment starts here
          ; SYM[P1:Protocol <- new3]{
            sugar-newNF
       ; applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       ; apIndBobOK(
         
   (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
     nf('bb : bool <- read ('OTBit-B-A['k]), 
        return (), 'bb  )
   )
   ||
   (family ('ShareOK-B[bound K]) 'k (bound K) ::=
     nf('xb : bool <- read ('Share-B['k]), 
         return (), 'xb  )
   )
       )
       ; applyDropName(fam ('BobOK[bound K]))
          }
      
      ) *** subcomment end
                    }    *** end of cong comp right          
     .           
  
  strat rewriteRestrFinal @ ProtocolConfig .
  sd rewriteRestrFinal := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestrFinal}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[  *** Q:Protocol <- new2NF(restr0), 
                                      P1:Protocol <- new2NF(restrFinal)
                                   ]
                    { 
        applyCasesSubstDivergeOwise(
          fam ('SendFinalShare-A[bound K]), fam ('Out-A[bound K]), 'k, bool, 'x3)
      ; applySameCasesSubstFirstBranch(fam ('SendFinalShare-B[bound K]), fam ('Out-A[bound K]), 'k)
      ; applyCasesSubstDivergeOwise(
          fam ('SendFinalShare-A[bound K]), fam ('Out-B[bound K]), 'k, bool, 'x3)
      ; applySameCasesSubstFirstBranch(
         fam ('SendFinalShare-B[bound K]), fam ('Out-B[bound K]), 'k) 
      ; applyCasesSubstDivergeOwise(
        fam ('SendFinalShare-A[bound K]), 
        fam (('SendFinalShare-A ^^ 'A .. 'adv)[bound K]), 'k, bool, 'x3)
      ; applyCasesSubstDivergeOwise(
        fam ('SendFinalShare-B[bound K]), 
        fam (('SendFinalShare-B ^^ 'A .. 'adv)[bound K]), 'k, bool, 'x3)
      ; absorbFamily(fam ('SendFinalShare-A[bound K]))
      ; absorbFamilyDeleteEmpty(fam ('SendFinalShare-B[bound K]))
      *** TODO: might have to do some alphas here!
                    }
    . 
    
    *** other strategies and helpers
    
    *** induction base 1
    
    strat indBase1 @ ProtocolConfig .
    sd indBase1 := 
         applyCaseDistChannel1('ShareOK-B[0])
       ; applyAllSameCases(chn ('ShareOK-B[0]))

    .
    
    strat indStep1 @ ProtocolConfig .
    sd indStep1 := 
        applyCaseDistChannel2('ShareOK-B['B])
    .   
    
    strat applyInd1 @ ProtocolConfig .
    sd applyInd1 := 
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyInd1}
     : INDUCTION-when-one[
        fns:NameWithScripts <- 'ShareOK-B,
        idx:Qid <- 'B,
        cases':Cases <-
           nf('xb : bool <- read ('Share-B['k]), return (), 'xb  )
                         ]
        {
        indBase1                 
        ,   
        indStep1          
        }
     .
    
    strat applyIndA1 @ ProtocolConfig .
    sd applyIndA1 := 
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyIndA1}
     : INDUCTION-when-one[
        fns:NameWithScripts <- 'ShareOK-A,
        idx:Qid <- 'B,
        cases':Cases <-
           nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
                         ]
        {
        indBaseA1                 
        ,   
        indStepA1          
        }
     .
    
    *** indB1
     
    strat applyIndB1 @ ProtocolConfig .
    sd applyIndB1 := 
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyIndB1}
     : INDUCTION-when-one[
        fns:NameWithScripts <- 'ShareOK-B,
        idx:Qid <- 'B,
        cases':Cases <-
           nf('sa : unit <- read ('ShareOK-A['k]), return 'sa, 'sa  )
                         ]
        {
        indBaseB1                 
        ,   
        indStepB1          
        }
     . 
     
    strat indBaseB1 @ ProtocolConfig .
    sd indBaseB1 := 
         applyCaseDistChannelBaseB('ShareOK-B[0])
       ; applyAllSameCases(chn ('ShareOK-B[0]))

    .
    
    strat indStepB1 @ ProtocolConfig .
    sd indStepB1 := 
        applyCaseDistChannelStepB('ShareOK-B['B])
    . 
    
    strat applyCaseDistChannelBaseB : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelBaseB(cn) :=
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelBaseB(cn)}
     : CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
        *** proof for alice goes here
        substNFFamilyOne(fam ('InputShareOK-B-A[bound N]), 'ShareOK-B[0],
           nf('xa : unit <- read ('InputShareOK-A-A[fun 'wire0 0]), return 'xa, 
              'xa  )
          )
       ; applyAlphaNFPr(chn ('ShareOK-B[0]), << 'xa, 'is >> emptyQidPairList)     
       ; SYM[P1:Protocol <- new7base]{
          substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B[0],
           nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 0]), return 'is, 
              'is  )
          )
       }
        ,
        CASE-DISTINCTION-channel-end-when{
          *** proof for bob goes here
        substNFFamilyOne(fam ('InputShareOK-B-B[bound M]), 'ShareOK-B[0],
           nf('xa : unit <- read ('InputShareOK-A-B[fun 'wire0 0]), return 'xa, 
              'xa  )
          )
       ; applyAlphaNFPr(chn ('ShareOK-B[0]), << 'xa, 'is >> emptyQidPairList)     
       ; SYM[P1:Protocol <- new7base]{
          substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B[0],
           nf('is : unit <- read ('InputShareOK-A-B[fun 'wire0 0]), return 'is, 
              'is  )
          )
       }  
        }
       }
     .  
     
    strat applyCaseDistChannelStepB : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelStepB(cn) :=
     match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelStepB(cn)}
     : ( *** open for :
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isAliceInput
       substNFFamilyOne(fam ('InputShareOK-B-A[bound N]), 'ShareOK-B['B],
           nf('xa : unit <- read ('InputShareOK-A-A[fun 'wire0 'B]), return 'xa, 
              'xa  )
          )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xa, 'is >> emptyQidPairList)     
       ; SYM[P1:Protocol <- new7step]{
          substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B['B],
           nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 'B]), return 'is, 
              'is  )
          )
       }
       , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isBobInput
        substNFFamilyOne(fam ('InputShareOK-B-B[bound M]), 'ShareOK-B['B],
           nf('xa : unit <- read ('InputShareOK-A-B[fun 'wire0 'B]), return 'xa, 
              'xa  )
          )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xa, 'is >> emptyQidPairList)     
       ; SYM[P1:Protocol <- new7step]{
          substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B['B],
           nf('is : unit <- read ('InputShareOK-A-B[fun 'wire0 'B]), return 'is, 
              'is  )
          )
       }
         , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isNotGate
        substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'B]), return 'sa, 
              'sa  )
          )
       ; SYM[P1:Protocol <- new7step]{
         substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B['B],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'B]),
           return 'sa, 'sa  )
          )
       } 
       , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isXorGate
       substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'B]), return 'sa, 
              'sa  )
          )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'sa, 'is >> emptyQidPairList)    
       ; substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire1 'B]), return 'sa, 
              'sa  )
          )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'is, 'xa >> 
                                               << 'sa, 'ya >> emptyQidPairList)      
       ; SYM[P1:Protocol <- new7step]{
        substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B['B],
           nf(('xa : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
         'ya : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
         return (), 'xa 'ya  )
          )
       }                
       , 
       CASE-DISTINCTION-channel-end-when{
         *** isAndGate 
         substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
          nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'B]), 
             return 'sa, 'sa  )
         )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'sa, 'is >> emptyQidPairList)
       ; substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
          nf('sa : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
             return 'sa, 'sa  )
         )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), 
                         << 'sa, 'yb0 >> 
                         << 'is, 'xb0 >>
                         emptyQidPairList)  
       ; substNFFamilyOne(fam ('OTBitOK-B-A[bound K]), 'ShareOK-B['B],
          nf(('ba : unit <- read ('OTBitOK-A-B['B])) 
             ('xa : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
             ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
             ('ya : unit <- read ('ShareOK-A[fun 'wire1 'B])) 
              'yb : unit <- read ('ShareOK-B[fun 'wire1 'B]), 
              return (),
              'ba 'xa 'ya 'xb 'yb  
            ) 
         )
      ; substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
       nf( 'sa : unit <- read ('ShareOK-A[fun 'wire0 'B]), 
           return 'sa, 'sa  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'sa, 'is >> emptyQidPairList)
      ;
       substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
       nf( 'sa : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
           return 'sa, 'sa  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'sa, 'ya >> 
                                            << 'is, 'xa >> emptyQidPairList)   
         ; SYM[P1:Protocol <- new7step]{
           substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B['B],
            nf(('ba : unit <- read ('OTBitOK-A-B['B])) 
               ('xa : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
                'ya : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
                return (), 'ba 'xa 'ya  )
          ) 
          }                 
       }}}}}
       ; applyAllSameCases(chn cn)
       ) *** end for :
     . 
    
    *** indC
    
    strat applyIndC @ ProtocolConfig .
    sd applyIndC := 
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyIndC}
     : INDUCTION-when-one[
        fns:NameWithScripts <- 'ShareOK-A,
        idx:Qid <- 'B,
        cases':Cases <-
           nf('xa : bool <- read ('Share-A['k]), return (), 'xa  )
                         ]
        {
        indBaseC                 
        ,   
        indStepC          
        }
     .
     
    strat indBaseC @ ProtocolConfig .
    sd indBaseC := 
         applyCaseDistChannelBaseC('ShareOK-A[0])
       ; applyAllSameCases(chn ('ShareOK-A[0]))

    .
    
    strat applyCaseDistChannelBaseC : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelBaseC(cn) :=
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelBaseC(cn)}
     : CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
        substNFFamilyOne(fam ('InputShareOK-A-A[bound N]), 'ShareOK-A[0],
           nf('xa : bool <- read ('InputShare-A-A[fun 'wire0 0]), return (), 
              'xa  )
          ) 
        ; SYM[P1:Protocol <- new10base]{
            substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A[0],
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 0]), 
             return 'is, 'is  )
            )
           ; applyAlphaNFPr(chn ('ShareOK-A[0]), << 'is, 'xa >> emptyQidPairList) 
          }  
        ,
        CASE-DISTINCTION-channel-end-when{
          substNFFamilyOne(fam ('InputShareOK-A-B[bound M]), 'ShareOK-A[0],
           nf('xa : bool <- read ('InputShare-A-B[fun 'wire0 0]), return (), 
              'xa  )
          )
        ; SYM[P1:Protocol <- new10base]{
            substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A[0],
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 0]), 
             return 'is, 'is  )
            )
            ; applyAlphaNFPr(chn ('ShareOK-A[0]), << 'is, 'xa >> emptyQidPairList)
          }  
        }
       }
     .  
    
    
    strat indStepC @ ProtocolConfig .
    sd indStepC := 
        applyCaseDistChannelStepC('ShareOK-A['B])
    .
    
    strat applyCaseDistChannelStepC : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelStepC(cn) :=
     match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelStepC(cn)}
     : ( *** open for :
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isAliceInput
       substNFFamilyOne(fam ('InputShareOK-A-A[bound N]), 'ShareOK-A['B],
           nf('xa : bool <- read ('InputShare-A-A[fun 'wire0 'B]), 
              return (), 'xa  )
          )
        ; SYM[P1:Protocol <- new10step]{
            substNFFamilyOne(fam ('Share-A[bound 'B]), 'ShareOK-A['B],
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'B]), 
             return 'is, 'is  )
            )
           ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'is, 'xa >> emptyQidPairList) 
          }  , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isBobInput
        substNFFamilyOne(fam ('InputShareOK-A-B[bound M]), 'ShareOK-A['B],
           nf('xa : bool <- read ('InputShare-A-B[fun 'wire0 'B]), return (), 
              'xa  )
          )
        ; SYM[P1:Protocol <- new10step]{
            substNFFamilyOne(fam ('Share-A[bound 'B]), 'ShareOK-A['B],
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'B]), 
             return 'is, 'is  )
            )
            ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'is, 'xa >> emptyQidPairList)
          }  , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isNotGate
        substNFFamilyOne(fam ('Share-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire0 'B ]),
       return (), 'xa  )
       )
       ; SYM[P1:Protocol <- new10step]{
        substNFFamilyOne(fam ('Share-A[bound 'B]), 'ShareOK-A['B],
       nf('sa : bool <- read ('Share-A[fun 'wire0 'B ]),
       return 'sa, 'sa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'sa, 'xa >> emptyQidPairList)
       }, 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isXorGate
       substNFFamilyOne(fam ('Share-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire0 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne(fam ('Share-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire1 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
       ; changeOrder(chn ('ShareOK-A['B]), 'ya 'xa  )                   
       ; SYM[P1:Protocol <- new10step]{
          substNFFamilyOne(fam ('Share-A[bound 'B]), 'ShareOK-A['B],
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'B]), 
        return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )
      )
       }                
       , 
       CASE-DISTINCTION-channel-end-when{
         *** isAndGate 
         substNFFamilyOne(fam ('OTBitOK-A-B[bound K]), 'ShareOK-A['B],
       nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
        'al : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
        return (), 'ak 'al  )
       )
      ; substNFFamilyOne(fam ('Share-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire0 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne(fam ('Share-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire1 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
        *** ; changeOrder(chn ('ShareOK-A['B]), 'xa 'ya  )                 
        ; SYM[P1:Protocol <- new10step]{
           substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A['B],
       nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'B]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba 'xa 'ya  )
     ) 
     ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'xa, 'xa1 >> << 'ya, 'ya1 >> emptyQidPairList)
     ; applySubsumeFamilyCasesChannelList
          (fam ('OTBit-A-B[bound K]), 'ShareOK-A['B], 'xa 'ya  )
     ; applyDropFamilyCasesChannel(fam ('OTBit-A-B[bound K]), 'ShareOK-A['B])
        }                
       }}}}}
       ; applyAllSameCases(chn ('ShareOK-A['B]))
       ) *** end for :
     . 
     
    *** indD
    
    strat applyIndD @ ProtocolConfig .
    sd applyIndD := 
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyIndD}
     : INDUCTION-when-one[
        fns:NameWithScripts <- 'Share-B,
        idx:Qid <- 'B,
        cases':Cases <-
           nf(('xa : bool <- read ('Share-A['k])) 
               'x : bool <- read ('Wire['k]), 
              return (ap 'xor pair('xa, 'x)), 
              'xa 'x  )
                         ]
        {
        indBaseD                 
        ,   
        indStepD          
        }
     .
     
    strat indBaseD @ ProtocolConfig .
    sd indBaseD := 
         applyCaseDistChannelBaseD('Share-B[0])
       ; applyAllSameCases(chn ('Share-B[0]))

    .
    
    strat applyCaseDistChannelBaseD : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelBaseD(cn) :=
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelBaseD(cn)}
     : CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
        *** for Alice
        idle
        ,
        CASE-DISTINCTION-channel-end-when{
          *** for Bob
          idle
        }
       }
     .  
    
    
    strat indStepD @ ProtocolConfig .
    sd indStepD := 
        applyCaseDistChannelStepD('Share-B['B])
    .
    
    strat applyCaseDistChannelStepD : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelStepD(cn) :=
     match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelStepD(cn)}
     : ( *** open for :
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isAliceInput
       idle  , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isBobInput
        idle , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isNotGate
        idle , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isXorGate
       idle              
       , 
       CASE-DISTINCTION-channel-end-when{
         *** isAndGate 
         idle               
       }}}}}
       ; applyAllSameCases(chn ('Share-B['B]))
       ) *** end for :
     .  
    
    *** ind A1 
    strat indBaseA1 @ ProtocolConfig .
    sd indBaseA1 := 
         applyCaseDistChannelA1('ShareOK-A[0])
       ; applyAllSameCases(chn ('ShareOK-A[0]))

    .
    
    strat indStepA1 @ ProtocolConfig .
    sd indStepA1 := 
        applyCaseDistChannelA2('ShareOK-A['B])
    .
    
    strat applyCaseDistChannelA1 : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelA1(cn) :=
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelA1(cn)}
     : CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
        substNFFamilyOne(fam ('InputShareOK-A-A[bound N]), 'ShareOK-A[0],
           nf('xa : bool <- read ('InputShare-A-A[fun 'wire0 0]), return (), 
              'xa  )
          ) 
        ; SYM[P1:Protocol <- new5base]{
            substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A[0],
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 0]), 
             return 'is, 'is  )
            )
           ; applyAlphaNFPr(chn ('ShareOK-A[0]), << 'is, 'xa >> emptyQidPairList) 
          }  
        ,
        CASE-DISTINCTION-channel-end-when{
          substNFFamilyOne(fam ('InputShareOK-A-B[bound M]), 'ShareOK-A[0],
           nf('xa : bool <- read ('InputShare-A-B[fun 'wire0 0]), return (), 
              'xa  )
          )
        ; SYM[P1:Protocol <- new5base]{
            substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A[0],
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 0]), 
             return 'is, 'is  )
            )
            ; applyAlphaNFPr(chn ('ShareOK-A[0]), << 'is, 'xa >> emptyQidPairList)
          }  
        }
       }
     .  
    
    strat applyCaseDistChannel1 : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannel1(cn) :=
     match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannel1(cn)}
     : CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
          substNFFamilyOne(fam ('InputShareOK-B-A[bound N]), 'ShareOK-B[0],
           nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 0]), return (), 
              'xb  )
          )
          ; SYM[P1:Protocol <- new3Base0]{ 
            substNFFamilyOne(fam ('Share-B[bound K]), 'ShareOK-B[0],
       nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 0])) 
       'x : unit <- read ('InputShareOK-B-A[fun 'wire0 0]), 
       return 'is, 'x 'is  )
      )
      ;
      substNFFamilyOne(fam ('InputShareOK-B-A[bound N]), 'ShareOK-B[0],
       nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 0]), return (), 
     'xb  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B[0]), << 'is, 'xb >> emptyQidPairList)
          }
          ,
          CASE-DISTINCTION-channel-end-when{
            substNFFamilyOne(fam ('InputShareOK-B-B[bound M]), 'ShareOK-B[0],
           nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 0]), return (), 
              'xb  )
          )
          ; SYM[P1:Protocol <- new3Base0]{ 
            substNFFamilyOne(fam ('Share-B[bound K]), 'ShareOK-B[0],
       nf(( 'is : bool <- read ('InputShare-B-B[fun 'wire0 0])) 
            'x : unit <- read ('InputShareOK-B-B[fun 'wire0 0]), 
            return 'is, 'x 'is  )
      )
     ;
      substNFFamilyOne(fam ('InputShareOK-B-B[bound M]), 'ShareOK-B[0],
       nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 0]), return (), 
          'xb  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B[0]), << 'is, 'xb >> emptyQidPairList)
          }
          }
       }
    .
    
    strat applyCaseDistChannelA2 : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelA2(cn) :=
     match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelA2(cn)}
     : ( *** open for :
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isAliceInput
       substNFFamilyOne(fam ('InputShareOK-A-A[bound N]), 'ShareOK-A['B],
           nf('xa : bool <- read ('InputShare-A-A[fun 'wire0 'B]), 
              return (), 'xa  )
          )
        ; SYM[P1:Protocol <- new5step]{
            substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A['B],
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'B]), 
             return 'is, 'is  )
            )
           ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'is, 'xa >> emptyQidPairList) 
          }  , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isBobInput
        substNFFamilyOne(fam ('InputShareOK-A-B[bound M]), 'ShareOK-A['B],
           nf('xa : bool <- read ('InputShare-A-B[fun 'wire0 'B]), return (), 
              'xa  )
          )
        ; SYM[P1:Protocol <- new5step]{
            substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A['B],
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'B]), 
             return 'is, 'is  )
            )
            ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'is, 'xa >> emptyQidPairList)
          }  , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isNotGate
        substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire0 'B ]),
       return (), 'xa  )
       )
       ; SYM[P1:Protocol <- new5step]{
        substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A['B],
       nf('sa : bool <- read ('Share-A[fun 'wire0 'B ]),
       return 'sa, 'sa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'sa, 'xa >> emptyQidPairList)
       }, 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isXorGate
       substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire0 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire1 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
       ; changeOrder(chn ('ShareOK-A['B]), 'ya 'xa  )                   
       ; SYM[P1:Protocol <- new5step]{
          substNFFamilyOne(fam ('Share-A[bound 'B]), 'ShareOK-A['B],
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'B]), 
        return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )
      )
       }                
       , 
       CASE-DISTINCTION-channel-end-when{
         *** isAndGate 
         substNFFamilyOne(fam ('OTBitOK-A-B[bound K]), 'ShareOK-A['B],
       nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
        'al : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
        return (), 'ak 'al  )
       )
      ; substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire0 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire1 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
        *** ; changeOrder(chn ('ShareOK-A['B]), 'xa 'ya  )                 
        ; SYM[P1:Protocol <- new5step]{
           substNFFamilyOne(fam ('Share-A[bound 'B]), 'ShareOK-A['B],
       nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'B]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba 'xa 'ya  )
     ) 
     ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'xa, 'xa1 >> << 'ya, 'ya1 >> emptyQidPairList)
     ; applySubsumeFamilyCasesChannelList
          (fam ('OTBit-A-B[bound K]), 'ShareOK-A['B], 'xa 'ya  )
     ; applyDropFamilyCasesChannel(fam ('OTBit-A-B[bound K]), 'ShareOK-A['B])
        }                
       }}}}}
       ; applyAllSameCases(chn ('ShareOK-A['B]))
       ) *** end for :
     .  
    
    strat applyCaseDistChannel2 : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannel2(cn) :=
     match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannel2(cn)}
     : ( *** open for :
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isAliceInput
       substNFFamilyOne(fam ('InputShareOK-B-A[bound N]), 'ShareOK-B['B],
           nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 'B]), return (), 
              'xb  )
          )
          ; SYM[P1:Protocol <- new3Ind0]{ 
            substNFFamilyOne(fam ('Share-B[bound K]), 'ShareOK-B['B],
       nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'B])) 
       'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'B]), 
       return 'is, 'x 'is  )
      )
      ;
      substNFFamilyOne(fam ('InputShareOK-B-A[bound N]), 'ShareOK-B['B],
       nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 'B]), return (), 
     'xb  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'is, 'xb >> emptyQidPairList)
      }
      , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isBobInput
       substNFFamilyOne(fam ('InputShareOK-B-B[bound M]), 'ShareOK-B['B],
           nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 'B]), return (), 
              'xb  )
          )
          ; SYM[P1:Protocol <- new3Ind0]{ 
            substNFFamilyOne(fam ('Share-B[bound K]), 'ShareOK-B['B],
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'B])) 
       'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'B]), 
       return 'is, 'x 'is  )
      )
      ;
      substNFFamilyOne(fam ('InputShareOK-B-B[bound M]), 'ShareOK-B['B],
       nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 'B]), return (), 
     'xb  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'is, 'xb >> emptyQidPairList)
      }
      , 
      CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isNotGate
       substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
        nf('xb : bool <- read ('Share-B[fun 'wire0 'B]), return (), 'xb  )
       )
       ; SYM[P1:Protocol <- new3Ind0]{ 
       substNFFamilyOne(fam ('Share-B[bound K]), 'ShareOK-B['B],
       nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
           'xb : bool <- read ('Share-B[fun 'wire0 'B]), 
           return (ap 'neg 'xb), 'x 'xb  )
      )
      ;
      substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
       nf( 'xb : bool <- read ('Share-B[fun 'wire0 'B]), 
           return (), 'xb  )
      )
      } 
       , CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isXorGate
         substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
          nf('xb : bool <- read ('Share-B[fun 'wire0 'B]), 
             return (), 'xb  )
         )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xb, 'is >> emptyQidPairList)
       ; substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
          nf('xb : bool <- read ('Share-B[fun 'wire1 'B]), 
             return (), 'xb  )
         )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), 
                         << 'xb, 'yb >> 
                         << 'is, 'xb >>
                         emptyQidPairList)  
       *** now comes the sym proof!
       ; SYM[P1:Protocol <- new3Ind0]{ 
        substNFFamilyOne(fam ('Share-B[bound K]), 'ShareOK-B['B],
      
      nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
         ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'B])) 
          'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
          return (ap 'xor pair('xb, 'yb)), 
          'xb 'x 'yb 'y  )
      )
      ;
       substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
       nf( 'xb : bool <- read ('Share-B[fun 'wire0 'B]), 
           return (), 'xb  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xb, 'is >> emptyQidPairList)
      ;
       substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
       nf( 'xb : bool <- read ('Share-B[fun 'wire1 'B]), 
           return (), 'xb  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xb, 'yb >> 
                                            << 'is, 'xb >> emptyQidPairList)
      ; changeOrder(chn ('ShareOK-B['B]), 'xb 'yb  ) 
       }
       , 
       CASE-DISTINCTION-channel-end-when{
         *** isAndGate 
         substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
          nf('xb : bool <- read ('Share-B[fun 'wire0 'B]), 
             return (), 'xb  )
         )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xb, 'is >> emptyQidPairList)
       ; substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
          nf('xb : bool <- read ('Share-B[fun 'wire1 'B]), 
             return (), 'xb  )
         )
       ; applyAlphaNFPr(chn ('ShareOK-B['B]), 
                         << 'xb, 'yb0 >> 
                         << 'is, 'xb0 >>
                         emptyQidPairList)  
       ; substNFFamilyOne(fam ('OTBitOK-B-A[bound N]), 'ShareOK-B['B],
          nf(('ba : unit <- read ('OTBitOK-A-B['B])) 
             ('xa : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
             ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
             ('ya : unit <- read ('ShareOK-A[fun 'wire1 'B])) 
              'yb : unit <- read ('ShareOK-B[fun 'wire1 'B]), 
              return (),
              'ba 'xa 'ya 'xb 'yb  
         ) 
         )
      ; substNFFamilyOne(fam ('OTBitOK-A-B[bound K]), 'ShareOK-B['B],  
         nf('ba : bool <- read ('OTBit-A-B['B]), return (), 'ba  )
      )
      ; substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B['B],
       nf('xa : bool <- read ('Share-A[fun 'wire0 'B]), 
          return (), 'xa  )
       ) 
    ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xa, 'is >> emptyQidPairList)         
    ; substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B['B],
       nf('xa : bool <- read ('Share-A[fun 'wire1 'B]), 
          return (), 'xa  )
       ) 
    ; applyAlphaNFPr(chn ('ShareOK-B['B]),
       << 'is, 'sa0 >>
       << 'xa, 'sa1 >>
       << 'xb, 'so0 >>
       << 'xb0, 'sb0 >>
       << 'yb, 'so1 >>
       << 'yb0, 'sb1 >>
        emptyQidPairList) 
        *** here comes the sym proof
    ; SYM[P1:Protocol <- new3Ind0]{
      substNFFamilyOne(fam ('Share-B[bound K]), 'ShareOK-B['B],
       nf(('b : unit <- read ('OTBitOK-B-A['B])) 
          ('bb : bool <- read ('OTBit-B-A['B])) 
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
          ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'B])) 
           'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
           return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
           'bb 'b 'xb 'x 'yb 'y  )
      )
      ;
      substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
       nf( 'xb : bool <- read ('Share-B[fun 'wire0 'B]), 
           return (), 'xb  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xb, 'is >> emptyQidPairList)
      ;
       substNFFamilyOne(fam ('ShareOK-B[bound 'B]), 'ShareOK-B['B],
       nf( 'xb : bool <- read ('Share-B[fun 'wire1 'B]), 
           return (), 'xb  )
      )
      ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xb, 'yb0 >> 
                                            << 'is, 'xb0 >> emptyQidPairList)
      ; substNFFamilyOne(fam ('OTBitOK-B-A[bound N]), 'ShareOK-B['B],
          nf(('ba : unit <- read ('OTBitOK-A-B['B])) 
             ('xa : unit <- read ('ShareOK-A[fun 'wire0 'B])) 
             ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B])) 
             ('ya : unit <- read ('ShareOK-A[fun 'wire1 'B])) 
              'yb : unit <- read ('ShareOK-B[fun 'wire1 'B]), 
              return (),
              'ba 'xa 'ya 'xb 'yb  
         ) 
         )
     ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'ba, 'ba1 >> 
                                           << 'xa, 'xa1 >> 
                                           << 'ya, 'ya1 >>
                                           << 'xb, 'xb1 >>
                                           << 'yb, 'yb1 >>
                                           emptyQidPairList)
     ; substNFFamilyOne(fam ('OTBitOK-A-B[bound K]), 'ShareOK-B['B],
        nf('ba : bool <- read ('OTBit-A-B['B]), return (), 'ba  )
       )                                     
     ; substNFFamilyOne(fam ('OTBit-B-A[bound K]), 'ShareOK-B['B], 
        nf(('ba : bool <- read ('OTBit-A-B['B])) 
           ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
           ('xb : bool <- read ('Share-B[fun 'wire0 'B])) 
           ('ya : bool <- read ('Share-A[fun 'wire1 'B])) 
            'yb : bool <- read ('Share-B[fun 'wire1 'B]), 
            return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                                   ap 'and pair('xb, 'ya)))),
           'ba 'xa 'ya 'xb 'yb  )
     )
     ; substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B['B],
       nf('xa : bool <- read ('Share-A[fun 'wire0 'B]), 
          return (), 'xa  )
       ) 
    ; applyAlphaNFPr(chn ('ShareOK-B['B]), << 'xa, 'is >> emptyQidPairList)         
    ; substNFFamilyOne(fam ('ShareOK-A[bound K]), 'ShareOK-B['B],
       nf('xa : bool <- read ('Share-A[fun 'wire1 'B]), 
          return (), 'xa  )
       )
    ; applyAlphaNFPr(chn ('ShareOK-B['B]),  
        << 'is, 'sa0 >>
        << 'xb, 'sb0 >>
        << 'xb1, 'so0 >>
        << 'xa, 'sa1 >>
        << 'yb, 'sb1 >>
        << 'yb1, 'so1 >>
        emptyQidPairList)
    ; changeOrder( chn ('ShareOK-B['B]),
       'ba 'sa0 'sa1 'so0 'so1 'sb0 'sb1  ) 
    }                          
       }
       }
      }
      }
     }
     ; applyAllSameCases(chn ('ShareOK-B['B]))
     ) *** close for :
     .
   
   *** rewrite new4, new induction
  strat rewriteRestr2Induction @ ProtocolConfig .
  sd rewriteRestr2Induction := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestr2Induction}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[
                                      P1:Protocol <- new2NF(new4)
                                   ]
                    {
     SYM[P1:Protocol <- new5]{              
       sugar-newNF
    
     ; apIndAliceOK(
   (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
     nf('ba : bool <- read ('OTBit-A-B['k]), 
        return (), 'ba  )
   )
   ||
   (family ('ShareOK-A[bound K]) 'k (bound K) ::=
     nf('xa : bool <- read ('Share-A['k]), 
        return (), 'xa  )
   )
      )
    ; applyDropName(fam ('AliceOK[bound K]))}
                    }
     .  
     
      *** rewrite new7, new induction
  strat rewriteRestr6Induction @ ProtocolConfig .
  sd rewriteRestr6Induction := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestr6Induction}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[
                                      P1:Protocol <- new2NF(new7)
                                   ]
                    {              
       ***sugar-newNF
    
      apInd78(  
   (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
      nf('ot : unit <- read ('OTBitOK-A-B['k]), 
                      return 'ot,
                      'ot  )
   )
   ||
   (family ('ShareOK-B[bound K]) 'k (bound K) ::=
     nf('sa : unit <- read ('ShareOK-A['k]), 
        return 'sa,
        'sa  )
   )
      )
    ; applyDropName(fam ('BobOK[bound K]))
                    }
     .    
     
   *** rewrite new10, new induction
  strat rewriteRestr9Induction @ ProtocolConfig .
  sd rewriteRestr9Induction := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestr9Induction}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[
                                      P1:Protocol <- new2NF(new10)
                                   ]
                    {
            
       apInduction910(
   (family ('OTBitOK-A-B[bound K]) 'k (bound K) ::= 
     nf('ba : bool <- read ('OTBit-A-B['k]), 
        return (), 'ba  )
   )
   ||
   (family ('ShareOK-A[bound K]) 'k (bound K) ::=
     nf('xa : bool <- read ('Share-A['k]), 
        return (), 'xa  )
   )
      )
    ; applyDropName(fam ('AliceOK[bound K]))
                    }
     .  
   
    strat apInduction910 : Protocol @ ProtocolConfig .
    sd apInduction910(P) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{apInduction910(P)}
     : SINGLE-INDUCTION
       *** INDUCTION-P-3
                    [idx:Qid <- 'B,
                     fns:NameWithScripts <- 'AliceOK, 
                     q:Qid <- 'k,
                     P2:Protocol <- P                      
                    ]
                   {
                   induction910
                   }
     .
     
   strat induction910 @ ProtocolConfig .
   sd induction910 :=
         applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       *** from here we start the proof
       *** drop AliceOK, we will add it back with sym
       ; applyDropName(fam ('AliceOK[bound K]))   
       ; applySubstChannelCase3(
            fam ('ShareOK-A[bound K]), 
            'OTBitOK-A-B['B], 
             nf('xa : bool <- read ('Share-A[fun 'wire0 'B]), 
                return (), 'xa  ),
             nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
                 'al : unit <- read ('ShareOK-A[fun 'wire1 'B]), 
                 return (), 
                 'xa 'al  ),
            apply 'isAndGate 'B
        )
        ; applyBranch1Alpha(chn ('OTBitOK-A-B['B]), 
                           << 'xa, 'sa >> emptyQidPairList)
        ; applySubstChannelCase3(
            fam ('ShareOK-A[bound K]),  
            'OTBitOK-A-B['B], 
             nf('xa : bool <- read ('Share-A[fun 'wire1 'B]), 
                return (), 'xa  ),
             nf(('sa : bool <- read ('Share-A[fun 'wire0 'B])) 
                 'xa : bool <- read ('Share-A[fun 'wire1 'B]), 
                 return (), 
                 'sa 'xa  ),
            apply 'isAndGate 'B
        )  
        ; applyBranch1Alpha(chn ('OTBitOK-A-B['B]), 
                           << 'xa, 'ya >> 
                           << 'sa, 'xa >> emptyQidPairList) 
            
        ; SYM[P1:Protocol <- new10IndInt]{
         applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       *** from here we start the proof
       ; applyDropName(fam ('AliceOK[bound K]))  
       ; applyCasesSubsumeDropDivergeOwiseC(
          fam ('OTBit-A-B[bound K]), 
          'OTBitOK-A-B['B], 
          'xa 'ya  , 
          unit, 'ot
          )
        }
          
       ; applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       ; applyDropName(fam ('AliceOK[bound K]))  
       
       ;
         CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B]]{
       *** isAliceInput
       substNFFamilyOne(fam ('InputShareOK-A-A[bound N]), 'ShareOK-A['B],
           nf('xa : bool <- read ('InputShare-A-A[fun 'wire0 'B]), 
              return (), 'xa  )
          )    
        ; SYM[P1:Protocol <- new10Ind0]{
            substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A['B],
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'B]), 
             return 'is, 'is  )
            )
          ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'is, 'xa >> emptyQidPairList) 
          } 
          , 
          CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B]]{
       *** isBobInput
        substNFFamilyOne(fam ('InputShareOK-A-B[bound M]), 'ShareOK-A['B],
           nf('xa : bool <- read ('InputShare-A-B[fun 'wire0 'B]), return (), 
              'xa  )
          )
        ; SYM[P1:Protocol <- new10Ind0]{
            substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A['B],
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'B]), 
             return 'is, 'is  )
            )
            ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'is, 'xa >> emptyQidPairList)
          }  ,
          CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B]]{
       *** isNotGate
        substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire0 'B ]),
          return (), 'xa  )
       )
       
       ; SYM[P1:Protocol <- new10Ind0]{
        substNFFamilyOne(fam ('Share-A[bound 'B]), 'ShareOK-A['B],
       nf('sa : bool <- read ('Share-A[fun 'wire0 'B ]),
          return 'sa, 'sa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'sa, 'xa >> emptyQidPairList)
       }
       , 
        CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B]]{
       *** isXorGate
       substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire0 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire1 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
       ; changeOrder(chn ('ShareOK-A['B]), 'ya 'xa  )                   
       ; SYM[P1:Protocol <- new10Ind0]{
          substNFFamilyOne(fam ('Share-A[bound K]), 'ShareOK-A['B],
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'B]), 
        return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )
      )
       }, CASE-DISTINCTION-channel-end-when{
           
        
         *** isAndGate 
         substNFFamilyOne(fam ('OTBitOK-A-B[bound K]), 'ShareOK-A['B],
       nf('ba : bool <- read ('OTBit-A-B['B]), return (), 'ba  )
       )      
      ; substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire0 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne(fam ('ShareOK-A[bound 'B]), 'ShareOK-A['B],
       nf('xa : bool <- read ('Share-A[fun 'wire1 'B ]),
       return (), 'xa  )
       )
       ; applyAlphaNFPr(chn ('ShareOK-A['B]), 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
                       
        ; SYM[P1:Protocol <- new10Ind0]{
           substNFFamilyOne(fam ('Share-A[bound 'B]), 'ShareOK-A['B],
       nf(('ba : bool <- read ('OTBit-A-B['B])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'B])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'B]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba 'xa 'ya  )
     ) 
     ; changeOrder(chn ('ShareOK-A['B]), 'ba 'xa 'ya  ) 
        }
        
                      
       }
       
       }
        }
         }
       }  
             
       ; applyAllSameCases(chn ('ShareOK-A['B]))
       
       ; SYM[P1:Protocol <- new10IndEnd]{
         applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       ; applyDropName(fam ('AliceOK[bound K]))  
       } 
   .             
    
   *** rewrite new4 
  strat rewriteRestr2Inductive @ ProtocolConfig .
  sd rewriteRestr2Inductive := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestr2Inductive}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[  *** Q:Protocol <- new2NF(restr0), 
                                      P1:Protocol <- new2NF(new4)
                                   ]
                    { sugar-newNF
       ; applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       ; applyDropName(fam ('BobOK[bound K]))  
       ; applyCasesSubsumeDropDivergeOwise(
          'OTBit-A-B, 
          'OTBitOK-A-B, 
          'xa 'ya  , 
          'k, unit, 'ot)
        *** here we get to new4Int  
       ; SYM[P1:Protocol <- new4Int]{
         sugar-newNF
       ; applyDropName(fam ('indAlice[bound K]))
       ; applyDropName(fam ('indBob[bound K]))
       ; applyDropName(fam ('indAdv[bound K]))
       ; applyDropName(fam ('BobOK[bound K]))  
       ; applyDropName(fam ('AliceOK[bound K]))  
       ; applySubstFamilyCase3(
            fam ('ShareOK-A[bound K]), 
            fam ('OTBitOK-A-B[bound K]), 
            'k,
             nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), return (), 'xa  ),
             nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
                 'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
                 return (), 
                 'xa 'al  ),
            apply 'isAndGate 'k
        ) 
        ; applyBranch1Alpha(fam ('OTBitOK-A-B[bound K]), 
                           << 'xa, 'sa >> emptyQidPairList)
        ; applySubstFamilyCase3(
            fam ('ShareOK-A[bound K]), 
            fam ('OTBitOK-A-B[bound K]),
            'k,
             nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), return (), 'xa  ),
             nf(('sa : bool <- read ('Share-A[fun 'wire0 'k])) 
                 'xa : bool <- read ('Share-A[fun 'wire1 'k]), 
                 return (), 
                 'sa 'xa  ),
            apply 'isAndGate 'k
        )  
        ; applyBranch1Alpha(fam ('OTBitOK-A-B[bound K]), 
                           << 'xa, 'ya >> 
                           << 'sa, 'xa >> emptyQidPairList)   
       }
                    }
     .               
   
   strat getInduction3 @ ProtocolConfig .
   sd getInduction3 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using 
    UNSAFE[P1:Protocol <- removeFamily (fam ('OTBitOK-B-A[bound K])) 
                          (removeFamily (fam ('ShareOK-B[bound K])) P
                          )
          ] *** add internal families with bound 'B, add internal channel['B]
            *** gets the induction protocol
            *** Delta should be changed to have these already
            *** or the UNSAFE rule should do that?
   .         
           
endsm

srew [1] 
 pConfig(secSig,
       (fam ('In-A [bound N]) :: bool)
           (fam ('In-B [bound M]) :: bool)          
           (fam (('In-A ^^ 'A .. 'adv) [bound N]) :: bool) 
           (fam (('InRcvd-B ^^ 'B .. 'adv) [bound M]) :: unit) 
           (fam (('InputShare-A-A ^^ 'A .. 'adv) [bound N]) :: bool)
           (fam (('InputShare-A-B ^^ 'A .. 'adv) [bound M]) :: bool) 
           (fam (('OTBit-A-B ^^ 'A .. 'adv) [bound K]) :: bool) 
           (fam (('OTChoice-B-A-0 ^^ 'ot .. 'adv) [bound K]) :: unit)
           (fam (('OTChoice-B-A-1 ^^ 'ot .. 'adv) [bound K]) :: unit) 
           (fam (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv) [bound K]) :: unit) 
           (fam (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv) [bound K]) :: unit)
           (fam (('OTMsg-A-B-0 ^^ 'ot .. 'adv) [bound K]) :: bool) 
           (fam (('OTMsg-A-B-1 ^^ 'ot .. 'adv) [bound K]) :: bool)
           (fam (('OTMsg-A-B-2 ^^ 'ot .. 'adv) [bound K]) :: bool) 
           (fam (('OTMsg-A-B-3 ^^ 'ot .. 'adv) [bound K]) :: bool)
           (fam ('Out-A [bound K]) :: bool)
           (fam (('Out-A ^^ 'A .. 'adv) [bound K]) :: bool) 
           (fam ('Out-B [bound K]) :: bool) 
           (fam (('SendFinalShare-A ^^ 'A .. 'adv) [bound K]) :: bool) 
           (fam (('SendFinalShare-B ^^ 'A .. 'adv) [bound K]) :: bool) 
           (fam (('SendInputShare-A-B ^^ 'A .. 'adv) [bound M]) :: bool) 
           (fam (('SendInputShare-B-A ^^ 'A .. 'adv) [bound N]) :: bool) 
           (fam (('Share-A ^^ 'A .. 'adv) [bound K]) :: bool)
           (fam ('OTOut-A-B [bound K]) :: bool)
           
               (fam ('InputShare-A-A[bound N]) :: bool)
               (fam ('InputShare-A-B[bound M]) :: bool)
              (fam ('InputShare-B-A[bound N]):: bool)
               (fam ('InputShare-B-B[bound M]) :: bool)
               (fam ('OTBit-A-B[bound K]) :: bool)
              (fam ('OTBit-B-A[bound K]) :: bool)
              (fam ('Share-A[bound K]) :: bool)
             (fam ('Share-B[bound K]) :: bool),
           new3,
           (fam ('In-A [bound N]), 
               fam ('In-B [bound M]),
               fam ('InputShare-A-A[bound N]) ,
               fam ('InputShare-A-B[bound M]) ,
               fam ('InputShare-B-A[bound N]),
               fam ('InputShare-B-B[bound M]),
               fam ('OTBit-A-B[bound K]),
               fam ('OTBit-B-A[bound K]),
               fam ('Share-A[bound K]),
               fam ('Share-A[bound K]) ), *** I  
           getOutputs(new3),
           empty
        )
using    sugar-newNF
      ; applyDropName(fam ('indAlice[bound K]))
      ; applyDropName(fam ('indBob[bound K]))
      ; applyDropName(fam ('indAdv[bound K]))
      ; getInduction3
 
.       

***( MAIN PROOF, KEEP rewrite real to idealPlusSym

srew [1] 
 pConfig(secSig,
           (fam ('In-A [bound N]) :: bool)
           (fam ('In-B [bound M]) :: bool)          
           (fam (('In-A ^^ 'A .. 'adv) [bound N]) :: bool) 
           (fam (('InRcvd-B ^^ 'B .. 'adv) [bound M]) :: unit) 
           (fam (('InputShare-A-A ^^ 'A .. 'adv) [bound N]) :: bool)
           (fam (('InputShare-A-B ^^ 'A .. 'adv) [bound M]) :: bool) 
           (fam (('OTBit-A-B ^^ 'A .. 'adv) [bound K]) :: bool) 
           (fam (('OTChoice-B-A-0 ^^ 'ot .. 'adv) [bound K]) :: unit)
           (fam (('OTChoice-B-A-1 ^^ 'ot .. 'adv) [bound K]) :: unit) 
           (fam (('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv) [bound K]) :: unit) 
           (fam (('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv) [bound K]) :: unit)
           (fam (('OTMsg-A-B-0 ^^ 'ot .. 'adv) [bound K]) :: bool) 
           (fam (('OTMsg-A-B-1 ^^ 'ot .. 'adv) [bound K]) :: bool)
           (fam (('OTMsg-A-B-2 ^^ 'ot .. 'adv) [bound K]) :: bool) 
           (fam (('OTMsg-A-B-3 ^^ 'ot .. 'adv) [bound K]) :: bool)
           (fam ('Out-A [bound K]) :: bool)
           (fam (('Out-A ^^ 'A .. 'adv) [bound K]) :: bool) 
           (fam ('Out-B [bound K]) :: bool) 
           (fam (('SendFinalShare-A ^^ 'A .. 'adv) [bound K]) :: bool) 
           (fam (('SendFinalShare-B ^^ 'A .. 'adv) [bound K]) :: bool) 
           (fam (('SendInputShare-A-B ^^ 'A .. 'adv) [bound M]) :: bool) 
           (fam (('SendInputShare-B-A ^^ 'A .. 'adv) [bound N]) :: bool) 
           (fam (('Share-A ^^ 'A .. 'adv) [bound K]) :: bool)
           (fam ('OTOut-A-B [bound K]) :: bool),
           real,
           insert(fam ('In-A [bound N]), fam ('In-B [bound M])), *** I 
           getOutputs(idealPlusSim),
           genA
        )
using     sugar-newNF
        ; moveNewToFront
        ; SYM[P1:Protocol <- restr]{
            sugar-newNF
        ; moveNewToFront
         ; reorder-newNF[ql2:List{CNameBound} <- 
 (fam ('SendInputShare-A-B[bound M]))
 (fam ('SendInputShare-B-A[bound N]))
 (fam ('OTMsg-A-B-0[bound K]))
 (fam ('OTMsg-A-B-1[bound K]))
 (fam ('OTMsg-A-B-2[bound K]))
 (fam ('OTMsg-A-B-3[bound K]))
 (fam ('OTOut-B-A[bound K]))
 (fam ('OTChoice-B-A-0[bound K]))
 (fam ('OTChoice-B-A-1[bound K]))
 (fam ('SendFinalShare-A[bound K]))
 (fam ('SendFinalShare-B[bound K]))
 (fam ('InputShare-A-A[bound N]))
 (fam ('InputShare-A-B[bound M]))
 (fam ('OTBit-A-B[bound K]))
 (fam ('Share-A[bound K]))
 (fam ('InputShare-B-A[bound N]))
 (fam ('InputShare-B-B[bound M]))
 (fam ('OTBit-B-A[bound K]))
 (fam ('Share-B[bound K]))
       ]
        }
          
        ;  sugar-newNF

        ; rewriteRestrInitial
                 
        ; rewriteRestrInductive  
           ***( was up to here
        ; rewriteRestrFinal
     
        ; desugar-newNF
            
        *** just to check that we are at restr1
        ; SYM[P1:Protocol <- restr1]{idle} 
 
        ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
  
        *** substitute InputShare-B-A in InputShareOK-B-A
       ; substNFFamiliesOne('InputShare-B-A, 'InputShareOK-B-A,
           nf(('x : bool <- read ('In-A['k])) 
               'xa : bool <- read ('InputShare-A-A['k]), 
               return (ap 'xor pair('x, 'xa)), 'x 'xa  )       
         )
       ; substNFFamiliesOne('InputShare-B-B, 'InputShareOK-B-B,
           nf(('x : bool <- read ('In-B['k])) 
               'xa : bool <- read ('InputShare-A-B['k]), 
               return (ap 'xor pair('x, 'xa)), 'x 'xa  )       
         ) 
                  
       *** going to restr2 now  
       ; SYM[P1:Protocol <- restr2]{
         sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; substNFFamiliesOne('InputShareOK-A-A, 'InputShareOK-B-A,
          nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa  )
         )
       ; substNFFamiliesOne('InOK-A, 'InputShareOK-B-A,
          nf('x : bool <- read ('In-A['k]), return (), 'x  )
         )
       ; substNFFamiliesOne('InputShareOK-A-B, 'InputShareOK-B-B,
          nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa  )
         )
       ; substNFFamiliesOne('InOK-B, 'InputShareOK-B-B,
          nf('x : bool <- read ('In-B['k]), return (), 'x  )
         )
       } 
       ; sugar-newNF
       ; rewriteRestr2Induction
       ; desugar-newNF
       *** recording that we got to restr4
       ; SYM[P1:Protocol <- restr4]{
         idle
       } 
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropSubsumeRevFamilies('InputShare-A-A, 'InputShareOK-A-A)
       ; applyDropSubsumeRevFamilies('InputShare-A-B, 'InputShareOK-A-B)       
        *** restr5 
       ; SYM [P1:Protocol <- restr5]{
         sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)

       ; substNFFamiliesOne(
           'InOK-A, 'InputShareOK-A-A,
            nf('x : bool <- read ('In-A['k]), return (), 'x  )       
         )
       ; substNFFamiliesOne(
           'InOK-B, 'InputShareOK-A-B,
            nf('x : bool <- read ('In-B['k]), return (), 'x  )       
         )  
        
       } 
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       
       ; substNFFamiliesOne(
           'InputShareOK-A-A, 'InputShareOK-B-A,
            nf('x : unit <- read ('InOK-A['k]), return 'x, 'x  )     
         )   
       ; substNFFamiliesOne(
           'InputShareOK-A-B, 'InputShareOK-B-B,
            nf('x : unit <- read ('InOK-B['k]), return 'x, 'x  )     
         )
        *** restr6
       ; SYM [P1:Protocol <- restr6]{
         sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; substNFFamiliesOne(
           'InputShareOK-A-A, 'InputShareOK-B-A,
            nf('x : unit <- read ('InOK-A['k]), return 'x, 'x  )     
         )  
       ; substNFFamiliesOne(
           'InputShareOK-A-B, 'InputShareOK-B-B,
            nf('x : unit <- read ('InOK-B['k]), return 'x, 'x  )     
         ) 
       ; applyReturnUnit(fam ('InputShareOK-B-A[bound N]))
       ; applyReturnUnit(fam ('InputShareOK-B-B[bound M]))
       } 
       ; sugar-newNF
       ; rewriteRestr6Induction 
      
       *** restr8
       ; SYM[P1:Protocol <- restr8]{
         sugar-newNF
       }
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       
       ; substNFFamiliesOne(
           'InOK-A, 'InputShareOK-A-A,
            nf('x : bool <- read ('In-A['k]), return (), 'x  )       
         )
       ; substNFFamiliesOne(
           'InOK-B, 'InputShareOK-A-B,
            nf('x : bool <- read ('In-B['k]), return (), 'x  )       
         )
         *** restr9
       ; SYM[P1:Protocol <- restr9]{
         sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       
       ; applyDropSubsumeRevFamilies('InputShare-A-A, 'InputShareOK-A-A)
       ; applyDropSubsumeRevFamilies('InputShare-A-B, 'InputShareOK-A-B)

       }  
       ; sugar-newNF
       ; rewriteRestr9Induction 
       
       *** restr10
        ; SYM[P1:Protocol <- restr10]{
          sugar-newNF
        }
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       *** for alice input
       ; applySubstFamilyCase3(
            'InputShareOK-B-A, 
            'Share-B, 
            'k,
             nf('xa : unit <- read ('InputShareOK-A-A[fun 'wire0 'k]), 
                return 'xa, 'xa  ),
             nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
                 'xa : unit <- read ('InputShareOK-A-A[fun 'wire0 'k]), 
                 return 'is, 'xa 'is  ),
            apply 'isAliceInput 'k
        ) 
       ; applySubstFamilyCase3(
            'InputShareOK-A-A, 
            'Share-B, 
            'k,
             nf('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
                return (), 'xa  ),
             nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
                 'xa : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
                 return 'is, 'xa 'is  ),
            apply 'isAliceInput 'k
        ) 
        *** for bob input
        ; applySubstFamilyCase3(
            'InputShareOK-B-B, 
            'Share-B, 
            'k,
             nf('xa : unit <- read ('InputShareOK-A-B[fun 'wire0 'k]), 
                return 'xa, 'xa  ),
             nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
                 'xa : unit <- read ('InputShareOK-A-B[fun 'wire0 'k]), 
                 return 'is, 'xa 'is  ),
            apply 'isBobInput 'k
        ) 
       ; applySubstFamilyCase3(
            'InputShareOK-A-B, 
            'Share-B, 
            'k,
             nf('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
                return (), 'xa  ),
             nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
                 'xa : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
                 return 'is, 'xa 'is  ),
            apply 'isBobInput 'k
        ) 
        *** for not gate
        ; applySubstFamilyCase3(
            'ShareOK-B, 
            'Share-B, 
            'k,
             nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]), 
                return 'sa, 'sa  ),
             nf(('sa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
                 'xb : bool <- read ('Share-B[fun 'wire0 'k]),
                 return (ap 'neg 'xb), 'sa 'xb  ),
            apply 'isNotGate 'k
        ) 
        ; applySubstFamilyCase3(
            'ShareOK-A, 
            'Share-B, 
            'k,
             nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
                return (), 'xa  ),
             nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
                 'xb : bool <- read ('Share-B[fun 'wire0 'k]),
                 return (ap 'neg 'xb), 'xa 'xb  ),
            apply 'isNotGate 'k
        ) 
        *** for xor gate 
        ; applySubstFamilyCase3(
            'ShareOK-B, 
            'Share-B, 
            'k,
             nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]), 
                return 'sa, 'sa  ),
             nf(('sa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
                ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
                return (ap 'xor pair('xb, 'yb)), 
                'xb 'sa 'yb 'y  ),
            apply 'isXorGate 'k
        ) 
        ; applyAlphaBranchCond('Share-B, 'sa, 'xa, when (apply 'isXorGate 'k)) 
        ; applySubstFamilyCase3(
            'ShareOK-B, 
            'Share-B, 
            'k,
             nf('sa : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
                return 'sa, 'sa  ),
             nf(('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
                ('sa : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
                return (ap 'xor pair('xb, 'yb)), 
                'xb 'xa 'yb 'sa  ),
            apply 'isXorGate 'k
        )   
        ; applyAlphaBranchCond('Share-B, 'sa, 'ya, when (apply 'isXorGate 'k)) 
        ; applySubstFamilyCase3(
            'ShareOK-A, 
            'Share-B, 
            'k,
             nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
                return (), 'xa  ),
             nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
                ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
                return (ap 'xor pair('xb, 'yb)), 
                'xb 'xa 'yb 'ya  ),
            apply 'isXorGate 'k
        )  
        ; applyAlphaBranchCond('Share-B, 'xa, 'xa0, when (apply 'isXorGate 'k)) 
        ; applySubstFamilyCase3(
            'ShareOK-A, 
            'Share-B, 
            'k,
             nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
                return (), 'xa  ),
             nf(('xa0 : bool <- read ('Share-A[fun 'wire0 'k])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
                ('xa : bool <- read ('Share-A[fun 'wire1 'k])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
                return (ap 'xor pair('xb, 'yb)), 
                'xb 'xa0 'yb 'xa  ),
            apply 'isXorGate 'k
        ) 
        ; applyAlphaBranchCond('Share-B, 'xa, 'ya, when (apply 'isXorGate 'k))
        ; applyAlphaBranchCond('Share-B, 'xa0, 'xa, when (apply 'isXorGate 'k)) 
        *** for and gate
        ; applySubstFamilyCase3(
            'ShareOK-B, 
            'Share-B, 
            'k,
             nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]), 
                return 'sa, 'sa  ),
             nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('sa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb 'b 'xb 'sa 'yb 'y  ), 
            apply 'isAndGate 'k
        ) 
        ; applyAlphaBranchCond('Share-B, 'sa, 'xa, when (apply 'isAndGate 'k)) 
        ; applySubstFamilyCase3(
            'ShareOK-B, 
            'Share-B, 
            'k,
             nf('sa : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
                return 'sa, 'sa  ),
             nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('sa : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb 'b 'xb 'xa 'yb 'sa  ), 
            apply 'isAndGate 'k
        ) 
        ; applyAlphaBranchCond('Share-B, 'sa, 'ya, when (apply 'isAndGate 'k)) 
        ; applySubstFamilyCase3(
            'ShareOK-A, 
            'Share-B, 
            'k,
             nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
                return (), 'xa  ),
             nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb 'b 'xb 'xa 'yb 'ya  ),
            apply 'isAndGate 'k
        )  
        ; applyAlphaBranchCond('Share-B, 'xa, 'xa0, when (apply 'isAndGate 'k)) 
        ; applySubstFamilyCase3(
            'ShareOK-A, 
            'Share-B, 
            'k,
             nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
                return (), 'xa  ),
             nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('xa0 : bool <- read ('Share-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('xa : bool <- read ('Share-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb 'b 'xb 'xa0 'yb 'xa  ),
            apply 'isAndGate 'k
        )  
        ; applySubstFamilyCase3(
            'OTBitOK-B-A, 
            'Share-B, 
            'k,
             nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot  ),
             nf(('ot : unit <- read ('OTBitOK-A-B['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('xa0 : bool <- read ('Share-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('xa : bool <- read ('Share-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb 'ot 'xb 'xa0 'yb 'xa  ),
            apply 'isAndGate 'k
        )
        ; applySubstFamilyCase3(
            'OTBitOK-A-B, 
            'Share-B, 
            'k,
             nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba  ),
             nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('xa0 : bool <- read ('Share-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('xa : bool <- read ('Share-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb 'ba 'xb 'xa0 'yb 'xa  ),
            apply 'isAndGate 'k
        )
        ; applyAlphaBranchCond('Share-B, 'xa, 'ya, when (apply 'isAndGate 'k))
        ; applyAlphaBranchCond('Share-B, 'xa0, 'xa, when (apply 'isAndGate 'k)) 
        
        *** restr11
        ; SYM[P1:Protocol <- restr11]{
          sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
        }
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       *** for -0
       ; applySubstFamilyCase3(
            'ShareOK-B, 
            'OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv, 
            'k,
            nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]), 
               return 'sa, 'sa  ), 
              nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]), 
                 return (), 'sa  ),
            apply 'isAndGate 'k
        )
       ; applySubstFamilyCase3(
            'ShareOK-A, 
            'OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv, 
            'k,
            nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
               return (), 'xa  ), 
              nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
                 return (), 'xa  ),
            apply 'isAndGate 'k
        )
        *** for -1
        ; applySubstFamilyCase3(
            'ShareOK-B, 
            'OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv, 
            'k,
            nf('sa : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
               return 'sa, 'sa  ), 
              nf('sa : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
                 return (), 'sa  ),
            apply 'isAndGate 'k
        )
       ; applySubstFamilyCase3(
            'ShareOK-A, 
            'OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv, 
            'k,
            nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
               return (), 'xa  ), 
              nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
                 return (), 'xa  ),
            apply 'isAndGate 'k
        ) 
        
        *** restr12
        ; SYM[P1:Protocol <- restr12]{
          sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
        } 
        
      *** now we get rid of timing channels
      ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
      ; absorbFamily('InOK-A)
      ; absorbFamily('InOK-B)
      ; absorbFamily('ShareOK-B)
      ; absorbFamily('ShareOK-A) 
      ; absorbFamily('OTBitOK-B-A)
      ; absorbFamily('OTBitOK-A-B)    
      ; absorbFamily('InputShareOK-B-A)
      ; absorbFamily('InputShareOK-B-B)
      ; absorbFamily('InputShareOK-A-A)
      ; absorbFamily('InputShareOK-A-B)
      *** restr13
      ; SYM[P1:Protocol <- restr13]{
          sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
        }
      ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)  
      ; SYM[P1:Protocol <- restr14]{
        sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; absorbFamily('Wire)
      }    
      ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
      ; SYM[P1:Protocol <- restr15]{
        sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applySubstFamilyCase3(
            'Wire, 
            'Out-A, 
            'k,
             nf( ('xa : bool <- read ('Share-A['k]))
                 ('xb : bool <- read ('Share-B['k])), 
                 return (ap 'xor pair('xa, 'xb)),
                 'xa 'xb  
               ),
             nf( ('xa : bool <- read ('Share-A['k]))
                 ('xb : bool <- read ('Share-B['k])), 
                 return (ap 'xor pair('xa, 'xb)),
                 'xa 'xb  
               ),
            apply 'isOutputWire 'k
        )  
        ; applySubstFamilyCase3(
            'Wire, 
            'Out-B, 
            'k,
             nf( ('xa : bool <- read ('Share-A['k]))
                 ('xb : bool <- read ('Share-B['k])), 
                 return (ap 'xor pair('xa, 'xb)),
                 'xa 'xb  
               ),
             nf( ('xa : bool <- read ('Share-A['k]))
                 ('xb : bool <- read ('Share-B['k])), 
                 return (ap 'xor pair('xa, 'xb)),
                 'xa 'xb  
               ),
            apply 'isOutputWire 'k
        ) 
        ; applyBranch1Alpha('Out-A, 
                           << 'xa, 'sa >> << 'xb, 'sb >> emptyQidPairList)
        ; applyBranch1Alpha('Out-B, 
                           << 'xa, 'sa >> << 'xb, 'sb >> emptyQidPairList) 
      }  
        ; sugar-newNF
        ; applyDropName('indAlice)
        ; applyDropName('indBob)
        ; applyDropName('indAdv)
        
        ; SYM[P1:Protocol <- restr16Group]{
             sugar-newNF  
    ; apBigInd(
        (family ('Wire[bound K]) 'k (bound K) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
   )
   ||
   (family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
      )
      
     ; applyDropName('Group)        
        }
   
        *** here we prove that restr16Group rewrites to restr16
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropName('Group)
       ; SYM[P1:Protocol <- restr16]{
         sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       ; applyDropName('Wires)  
       }
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       ; applyDropName('Wires)
       ; absorbFamily('OTBit-B-A)
       ; substNFFamiliesOne('InputShare-B-A, 'SendInputShare-B-A ^^ 'A .. 'adv,
          nf(('x : bool <- read ('In-A['k]))
              'xa : bool <- read ('InputShare-A-A['k]), 
              return (ap 'xor pair('x, 'xa)), 
              'x 'xa  )
         )
       ; applySubstFamilyCase3(
            'Share-B, 
            'SendFinalShare-B ^^ 'A .. 'adv, 
            'k,
             nf(('x : bool <- read ('Wire['k]))
                 'xa : bool <- read ('Share-A['k]), 
                 return (ap 'xor pair('xa, 'x)), 
                 'xa 'x  ),
              nf(('xa : bool <- read ('Share-A['k]))
                 ('x : bool <- read ('Wire['k])), 
                  return (ap 'xor pair('xa, 'x)), 
                  'xa 'x  ),
            apply 'isOutputWire 'k
      ) 
      ; absorbFamily('Share-B) 
      ; absorbFamily('InputShare-B-B) 
      ; absorbFamily('InputShare-B-A)
      *** here we finish the proof from section 8.4
      
      *** alphas to make things match
      ; applyAlphaNFPr('InputShare-A-A, << 'x, 'inA >> emptyQidPairList)
      ; applyAlphaNFPr('InputShare-A-A ^^ 'A .. 'adv, << 'is, 'inA >> emptyQidPairList)
      ; applyAlphaNFPr('InputShare-A-B ^^ 'A .. 'adv, << 'is, 'inB >> emptyQidPairList)
      ; applyAlphaBranchCond('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv, 'xa, 'c0, when (apply 'isAndGate 'k))
      ; applyAlphaBranchCond('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv, 'x3, 'otc, otherwise)
      ; applyAlphaBranchCond('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv, 'xa, 'c1, when (apply 'isAndGate 'k))
      ; applyAlphaBranchCond('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv, 'x3, 'otc, otherwise)
      ; applyAlphaBranchCond('OTMsg-A-B-0 ^^ 'ot .. 'adv, 'x3, 'otm, otherwise)
      ; applyAlphaBranchCond('OTMsg-A-B-1 ^^ 'ot .. 'adv, 'x3, 'otm, otherwise)
      ; applyAlphaBranchCond('OTMsg-A-B-2 ^^ 'ot .. 'adv, 'x3, 'otm, otherwise)
      ; applyAlphaBranchCond('OTMsg-A-B-3 ^^ 'ot .. 'adv, 'x3, 'otm, otherwise)
      ; applyAlphaBranchCond('Out-A, 'x3, 'oai, otherwise)
      ; applyAlphaBranchCond('Out-A, 'w, 'wi, when (apply 'isOutputWire 'k))
      ; applyAlphaBranchCond('Out-B, 'x3, 'obi, otherwise)
      ; applyAlphaBranchCond('Out-B, 'w, 'wi, when (apply 'isOutputWire 'k))
      ; applyAlphaNFPr('Out-A ^^ 'A .. 'adv, << 'outA, 'oai >> emptyQidPairList)
      ; applyAlphaBranchCond('SendFinalShare-A ^^ 'A .. 'adv, 'x3, 'sa, otherwise)
      ; applyAlphaNFPr('SendInputShare-A-B ^^ 'A .. 'adv, << 'sis, 'x >> emptyQidPairList)
      ; applyAlphaNFPr('SendInputShare-B-A ^^ 'A .. 'adv, << 'x, 'inA >> emptyQidPairList)
      ; applyCommXor(fam ('SendInputShare-B-A ^^ 'A .. 'adv[bound N]))
      ; changeOrder(chn ('SendInputShare-B-A ^^ 'A .. 'adv), 'xa 'inA  )
      ; applyAlphaBranchCond('SendFinalShare-B ^^ 'A .. 'adv, 'x3, 'sa, otherwise)
      ; applyAlphaBranchCond('SendFinalShare-B ^^ 'A .. 'adv, 'x, 'wi, when (apply 'isOutputWire 'k))
      ; SYM[P1:Protocol <- idealPlusSim]{
        sugar-newNF
       ; moveNewToFront 
       ; applySubstNFLeft('SendFinalShare-B ^^ 'A .. 'adv, 'Out-A ^^ 'id .. 'adv, 
          nf('oai : bool <- read ('Out-A['k]), return 'oai, 'oai  )
         )
       ; foldNFFamily('Out-A ^^ 'id .. 'adv, 'Out-A ^^ 'A .. 'adv)
       ; substNFFamiliesOne(
           'In-A ^^ 'id .. 'adv, 'In-A ^^ 'A .. 'adv, 
           nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA  )
         )
       ; substNFFamiliesOne(
           'In-A ^^ 'id .. 'adv, 'InputShare-A-A,
           nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA  )
         )
       ; foldNFFamily('In-A ^^ 'id .. 'adv, 'SendInputShare-B-A ^^ 'A .. 'adv)  
        ; substNFFamiliesOne(
          'InRcvd-B ^^ 'id .. 'adv, 'InRcvd-B ^^ 'B .. 'adv,
           nf('x : bool <- read ('In-B['k]), return (), 'x  )
         )
        ; foldNFFamily('InRcvd-B ^^ 'id .. 'adv, 'InputShare-A-B) 
        ; applyDropName('Sim)
        ; applyDropName('Wires)
        ; applySameCasesSubstFirstBranch('Out-A, 'SendFinalShare-B ^^ 'A .. 'adv, 'k)
      }    
   ) ***  comment ends here
   
  . 


) *** end of main proof

  
***(
  
  srew [1] 
 pConfig(secSig,
       ('In-A @ bound N :: bool)
           ('In-B @ bound M :: bool)          
           ('In-A ^^ 'A .. 'adv @ bound N :: bool) 
           ('InRcvd-B ^^ 'B .. 'adv @ bound M :: unit) 
           ('InputShare-A-A ^^ 'A .. 'adv @ bound N :: bool)
           ('InputShare-A-B ^^ 'A .. 'adv @ bound M :: bool) 
           ('OTBit-A-B ^^ 'A .. 'adv @ bound K :: bool) 
           ('OTChoice-B-A-0 ^^ 'ot .. 'adv @ bound K :: unit)
           ('OTChoice-B-A-1 ^^ 'ot .. 'adv @ bound K :: unit) 
            ('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv @ bound (N + M) :: unit) 
           ('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv @ bound (N + M) :: unit)
           ('OTMsg-A-B-0 ^^ 'ot .. 'adv @ bound K :: bool) 
           ('OTMsg-A-B-1 ^^ 'ot .. 'adv @ bound K :: bool)
           ('OTMsg-A-B-2 ^^ 'ot .. 'adv @ bound K :: bool) 
           ('OTMsg-A-B-3 ^^ 'ot .. 'adv @ bound K :: bool)
           ('Out-A @ bound K :: bool)
           ('Out-A ^^ 'A .. 'adv @ bound K :: bool) 
           ('Out-B @ bound K :: bool) 
           ('SendFinalShare-A ^^ 'A .. 'adv @ bound K :: bool) 
           ('SendFinalShare-B ^^ 'A .. 'adv @ bound K :: bool) 
           ('SendInputShare-A-B ^^ 'A .. 'adv @ bound M :: bool) 
           ('SendInputShare-B-A ^^ 'A .. 'adv @ bound N :: bool) 
           ('Share-A ^^ 'A .. 'adv @ bound K :: bool)
           ('OTOut-A-B @ bound (N + M) :: bool)
           
               ('InputShare-A-A @ bound N :: bool)
               ('InputShare-A-B @ bound M :: bool)
               ('InputShare-B-A @ bound N :: bool)
               ('InputShare-B-B @ bound M :: bool)
               ('OTBit-A-B @ bound K :: bool)
               ('OTBit-B-A @ bound K :: bool)
               ('Share-A @ bound K :: bool)
               ('Share-B @ bound K :: bool),
           new3,
           ('In-A @ bound N, 
               'In-B @ bound M,
               'InputShare-A-A @ bound N,
               'InputShare-A-B @ bound M,
               'InputShare-B-A @ bound N,
               'InputShare-B-B @ bound M,
               'OTBit-A-B @ bound K,
               'OTBit-B-A @ bound K,
               'Share-A @ bound K,'Share-B @ bound K), *** I  
           getOutputs(restrInductive),
           genA
        )
using    sugar-newNF
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       ; apIndBobOK(
         
   (family ('OTBitOK-B-A[bound K]) 'k (bound K) ::= 
     nf('bb : bool <- read ('OTBit-B-A['k]), 
        return (), 'bb  )
   )
   ||
   (family ('ShareOK-B[bound K]) 'k (bound K) ::=
     nf('xb : bool <- read ('Share-B['k]), 
         return (), 'xb  )
   )
       )
       ; applyDropName('BobOK)
  
.
)

set trace off .

***(
srew [1] 
 pConfig(secSig,
           ('In-A @ bound N :: bool)
           ('In-B @ bound M :: bool)          
           ('In-A ^^ 'A .. 'adv @ bound N :: bool) 
           ('InRcvd-B ^^ 'B .. 'adv @ bound M :: unit) 
           ('InputShare-A-A ^^ 'A .. 'adv @ bound N :: bool)
           ('InputShare-A-B ^^ 'A .. 'adv @ bound M :: bool) 
           ('OTBit-A-B ^^ 'A .. 'adv @ bound K :: bool) 
           ('OTChoice-B-A-0 ^^ 'ot .. 'adv @ bound K :: unit)
           ('OTChoice-B-A-1 ^^ 'ot .. 'adv @ bound K :: unit) 
            ('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv @ bound (N + M) :: unit) 
           ('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv @ bound (N + M) :: unit)
           ('OTMsg-A-B-0 ^^ 'ot .. 'adv @ bound K :: bool) 
           ('OTMsg-A-B-1 ^^ 'ot .. 'adv @ bound K :: bool)
           ('OTMsg-A-B-2 ^^ 'ot .. 'adv @ bound K :: bool) 
           ('OTMsg-A-B-3 ^^ 'ot .. 'adv @ bound K :: bool)
           ('Out-A @ bound K :: bool)
           ('Out-A ^^ 'A .. 'adv @ bound K :: bool) 
           ('Out-B @ bound K :: bool) 
           ('SendFinalShare-A ^^ 'A .. 'adv @ bound K :: bool) 
           ('SendFinalShare-B ^^ 'A .. 'adv @ bound K :: bool) 
           ('SendInputShare-A-B ^^ 'A .. 'adv @ bound M :: bool) 
           ('SendInputShare-B-A ^^ 'A .. 'adv @ bound N :: bool) 
           ('Share-A ^^ 'A .. 'adv @ bound K :: bool)
           ('OTOut-A-B @ bound (N + M) :: bool),
           restr16Group,
           insert('In-A @ bound N, 'In-B @ bound M), *** I 
           getOutputs(idealPlusSim),
           genA
        )
using sugar-newNF  
    ; apBigInd(
        (family ('Wire[bound K]) 'k (bound K) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
   )
   ||
   (family ('Share-B[bound K]) 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa 'is  )
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa 'xb  )
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb 'xa 'yb 'ya  )
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb 'ba 'xb 'xa 'yb 'ya  )
    )
  ) *** end Share-B
  ||
  (family ('OTBit-B-A[bound K]) 'k  (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba 'xa 'ya 'xb 'yb  )
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb  )
   )
  ) *** end OTBit-B-A
      )
      
     ; applyDropName('Group)      

.
)

***( this was the last test before reverting
set trace off .
srew [1] 
 pConfig(secSig,
           ('In-A @ bound N :: bool)
           ('In-B @ bound M :: bool)          
           ('In-A ^^ 'A .. 'adv @ bound N :: bool) 
           ('InRcvd-B ^^ 'B .. 'adv @ bound M :: unit) 
           ('InputShare-A-A ^^ 'A .. 'adv @ bound N :: bool)
           ('InputShare-A-B ^^ 'A .. 'adv @ bound M :: bool) 
           ('OTBit-A-B ^^ 'A .. 'adv @ bound K :: bool) 
           ('OTChoice-B-A-0 ^^ 'ot .. 'adv @ bound K :: unit)
           ('OTChoice-B-A-1 ^^ 'ot .. 'adv @ bound K :: unit) 
            ('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv @ bound (N + M) :: unit) 
           ('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv @ bound (N + M) :: unit)
           ('OTMsg-A-B-0 ^^ 'ot .. 'adv @ bound K :: bool) 
           ('OTMsg-A-B-1 ^^ 'ot .. 'adv @ bound K :: bool)
           ('OTMsg-A-B-2 ^^ 'ot .. 'adv @ bound K :: bool) 
           ('OTMsg-A-B-3 ^^ 'ot .. 'adv @ bound K :: bool)
           ('Out-A @ bound K :: bool)
           ('Out-A ^^ 'A .. 'adv @ bound K :: bool) 
           ('Out-B @ bound K :: bool) 
           ('SendFinalShare-A ^^ 'A .. 'adv @ bound K :: bool) 
           ('SendFinalShare-B ^^ 'A .. 'adv @ bound K :: bool) 
           ('SendInputShare-A-B ^^ 'A .. 'adv @ bound M :: bool) 
           ('SendInputShare-B-A ^^ 'A .. 'adv @ bound N :: bool) 
           ('Share-A ^^ 'A .. 'adv @ bound K :: bool)
           ('OTOut-A-B @ bound (N + M) :: bool)
           
           
           *** here we add the channels from new!
               
  ('InOK-A @ bound N :: unit)
  ('InOK-B @ bound M :: unit)
  ('InputShareOK-A-A @ bound N :: unit)
  ('InputShareOK-A-B @ bound M :: unit)
  ('InputShareOK-B-A @ bound N :: unit)
  ('InputShareOK-B-B @ bound M :: unit)
  ('OTBitOK-A-B @ bound K :: unit)
  ('OTBitOK-B-A @ bound K :: unit)
  ('ShareOK-A @ bound K :: unit)
  ('ShareOK-B @ bound K :: unit)
  ('Wire @ bound K :: bool)
  ('InputShare-A-A @ bound N :: bool)
  ('InputShare-A-B @ bound M :: bool)
  ('InputShare-B-A @ bound N :: bool)
  ('InputShare-B-B @ bound M :: bool)
  ('Share-A @ bound K :: bool)
  ('Share-B @ bound K :: bool)
  ('OTBit-A-B @ bound K :: bool)
  ('OTBit-B-A @ bound K :: bool)
    
           ,
           restr16GIndSymShare,
           insert('In-A @ bound N, 'In-B @ bound M), *** I 
           getOutputs(idealPlusSim),
           insert('B <T K, genA)
        )
using applyDropName('Group)
   ; applyAlphaBranchCond('Share-B['B], 'xa, 'ya, 
                           when (apply 'isAliceInput ('B))
                         )
   ; applyAlphaBranchCond('Share-B['B], 'xa, 'ya, 
                           when (apply 'isBobInput ('B))
                         )  
   ; applyAlphaBranchCond('Share-B['B], 'xa, 'ya, 
                           when (apply 'isNotGate ('B))
                         )                                            
   ; applyAlphaBranchCond('Share-B['B], 'xa, 'za, 
                           when (apply 'isXorGate ('B))
                         )  
   ; applyAlphaBranchCond('Share-B['B], 'xa, 'za, 
                           when (apply 'isAndGate ('B))
                         )
                    
   
    ; CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B]]{
       applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isAliceInput ('B)
      ),
      CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B]]{
       applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isBobInput ('B)
      ),
      CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B]]{
       applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isNotGate ('B)
      ),
      CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B]]{
       applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isXorGate ('B)
      ),
      CASE-DISTINCTION-channel-end-when[cn:ChannelName <- 'Share-B['B]]{
        applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isAndGate ('B)
        )
      }
    }
    }
    }
    }  
    
    *** for alice input
   ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B], 
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 ('B)]),
                return 'is, 'is  ),
             nf(('is : bool <- read ('InputShare-A-A[fun 'wire0 ('B)])) 
                 'xb : bool <- read ('InputShare-B-A[fun 'wire0 ('B)]), 
                 return (ap 'xor pair('is, ap 'xor pair('is, 'xb))), 
                 'is 'xb  ),
            apply 'isAliceInput ('B)
        ) 
        
   *** get to what we want
   ; applyAlphaBranchCond('Share-B['B], 'is, 'xa, 
                           when (apply 'isAliceInput ('B))
                         )  
   ; applyAlphaBranchCond('Share-B['B], 'xb, 'is, 
                           when (apply 'isAliceInput ('B))
                         )  
                         
   *** for bob input  
   ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B], 
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 ('B)]),
                return 'is, 'is  ),
             nf(('is : bool <- read ('InputShare-A-B[fun 'wire0 ('B)])) 
                ('xb : bool <- read ('InputShare-B-B[fun 'wire0 ('B)])),
                 return (ap 'xor pair('is, ap 'xor pair('is, 'xb))), 
                 'is 'xb  ),
            apply 'isBobInput ('B)
        ) 
   *** some renamings
   ; applyAlphaBranchCond('Share-B['B], 'is, 'xa, 
                           when (apply 'isBobInput ('B))
                         )  
   ; applyAlphaBranchCond('Share-B['B], 'xb, 'is, 
                           when (apply 'isBobInput ('B))  
                         )  
   *** for not gate 
    ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B], 
             nf('sa : bool <- read ('Share-A[fun 'wire0 ('B)]), 
                return 'sa, 'sa  ),
             nf(('sa : bool <- read ('Share-A[fun 'wire0 'B])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'B])), 
                return (ap 'xor pair('sa, ap 'xor pair('sa, ap 'neg 'xb))), 
                'sa 'xb  ),
            apply 'isNotGate ('B)
        )      
   ; applyAlphaBranchCond('Share-B['B], 'sa, 'xa, 
                           when (apply 'isNotGate ('B))
                         )       
                            
   *** for xor gate
   ; applyAlphaBranchCond('Share-B['B], 'xa, 'aa, 
                           when (apply 'isXorGate ('B))
                         )
   ; applyAlphaBranchCond('Share-B['B], 'ya, 'ba, 
                           when (apply 'isXorGate ('B))
                         ) 
   ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B], 
             nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
                 'ya : bool <- read ('Share-A[fun 'wire1 ('B)]), 
                 return (ap 'xor pair('xa, 'ya)), 'xa 'ya  ),
             nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 ('B)])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 ('B)])) 
                ('yb : bool <- read ('Share-B[fun 'wire1 ('B)])), 
                return (ap 'xor pair('xb, 'yb)),
                'xa 'ya 'yb 'xb  ),
             apply 'isXorGate ('B)
        )                      
   *** change the order to 'xb 'xa 'yb 'ya 
   ; applyChangeOrderBranch(
       'Share-B['B], 
       apply 'isXorGate ('B), 
       'xb 'xa 'yb 'ya  
     )   
   *** for and gate
   ; applyAlphaBranchCond('Share-B['B], 'ba, 'bc, 
                           when (apply 'isAndGate ('B))
                         )                         
   ; applyAlphaBranchCond('Share-B['B], 'xa, 'xc, 
                           when (apply 'isAndGate ('B))
                         )                         
   ; applyAlphaBranchCond('Share-B['B], 'ya, 'yc, 
                           when (apply 'isAndGate ('B))
                         )                         

   ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B], 
             nf(('ba : bool <- read ('OTBit-A-B['B])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
                 'ya : bool <- read ('Share-A[fun 'wire1 ('B)]), 
                 return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
                 'ba 'xa 'ya  ), 
             nf(('ba : bool <- read ('OTBit-A-B['B])) 
                ('bb : bool <- read ('OTBit-B-A['B])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 ('B)])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 ('B)])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 ('B)]), 
                 return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
                 'ba 'xa 'ya 'bb 'yb 'xb  ),
             apply 'isAndGate ('B)
        )    
   *** change order to 'bb 'ba 'xb 'xa 'yb 'ya   
   ; applyChangeOrderBranch(
       'Share-B['B], 
       apply 'isAndGate ('B), 
       'bb 'ba 'xb 'xa 'yb 'ya  
     )



.  
) *** end comment


***(

srew [1] 
 pConfig(secSig,
           ('In-A @ bound N :: bool)
           ('In-B @ bound M :: bool)          
           ('In-A ^^ 'A .. 'adv @ bound N :: bool) 
           ('InRcvd-B ^^ 'B .. 'adv @ bound M :: unit) 
           ('InputShare-A-A ^^ 'A .. 'adv @ bound N :: bool)
           ('InputShare-A-B ^^ 'A .. 'adv @ bound M :: bool) 
           ('OTBit-A-B ^^ 'A .. 'adv @ bound K :: bool) 
           ('OTChoice-B-A-0 ^^ 'ot .. 'adv @ bound K :: unit)
           ('OTChoice-B-A-1 ^^ 'ot .. 'adv @ bound K :: unit) 
            ('OTChoiceRcvd-B-A-0 ^^ 'ot .. 'adv @ bound (N + M) :: unit) 
           ('OTChoiceRcvd-B-A-1 ^^ 'ot .. 'adv @ bound (N + M) :: unit)
           ('OTMsg-A-B-0 ^^ 'ot .. 'adv @ bound K :: bool) 
           ('OTMsg-A-B-1 ^^ 'ot .. 'adv @ bound K :: bool)
           ('OTMsg-A-B-2 ^^ 'ot .. 'adv @ bound K :: bool) 
           ('OTMsg-A-B-3 ^^ 'ot .. 'adv @ bound K :: bool)
           ('Out-A @ bound K :: bool)
           ('Out-A ^^ 'A .. 'adv @ bound K :: bool) 
           ('Out-B @ bound K :: bool) 
           ('SendFinalShare-A ^^ 'A .. 'adv @ bound K :: bool) 
           ('SendFinalShare-B ^^ 'A .. 'adv @ bound K :: bool) 
           ('SendInputShare-A-B ^^ 'A .. 'adv @ bound M :: bool) 
           ('SendInputShare-B-A ^^ 'A .. 'adv @ bound N :: bool) 
           ('Share-A ^^ 'A .. 'adv @ bound K :: bool)
           ('OTOut-A-B @ bound (N + M) :: bool)
           
           
           *** here we add the channels from new!
               
  ('InOK-A @ bound N :: unit)
  ('InOK-B @ bound M :: unit)
  ('InputShareOK-A-A @ bound N :: unit)
  ('InputShareOK-A-B @ bound M :: unit)
  ('InputShareOK-B-A @ bound N :: unit)
  ('InputShareOK-B-B @ bound M :: unit)
  ('OTBitOK-A-B @ bound K :: unit)
  ('OTBitOK-B-A @ bound K :: unit)
  ('ShareOK-A @ bound K :: unit)
  ('ShareOK-B @ bound K :: unit)
  ('Wire @ bound K :: bool)
  ('InputShare-A-A @ bound N :: bool)
  ('InputShare-A-B @ bound M :: bool)
  ('InputShare-B-A @ bound N :: bool)
  ('InputShare-B-B @ bound M :: bool)
  ('Share-A @ bound K :: bool)
  ('Share-B @ bound K :: bool)
  ('OTBit-A-B @ bound K :: bool)
  ('OTBit-B-A @ bound K :: bool)
    
           ,
           restr16GIndEnd,
           insert('In-A @ bound N, 'In-B @ bound M), *** I 
           getOutputs(idealPlusSim),
           insert('B <T K, genA)
        )
using  
       SYM[P1:Protocol <- restr16GIndEnd5]{
        applyAllSameCases('Wire['B]) 
       }
     ; applyDropName('Group) 
     
    *** for alice input   
    ;  applySubstChannelCase3(
            'Share-A, 
            'Wire['B], 
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 ('B)]),
                return 'is, 'is  ),
             nf(('is : bool <- read ('InputShare-A-A[fun 'wire0 ('B)])) 
                 'xb : bool <- read ('Share-B['B]), 
                 return (ap 'xor pair('is, 'xb)), 'is 'xb  ),
            apply 'isAliceInput ('B)
        ) 
     ; applyAlphaBranchCond('Wire['B], 'is, 'xa, 
                           when (apply 'isAliceInput ('B)))
     *** bob input                           
    ;  applySubstChannelCase3(
            'Share-A, 
            'Wire['B], 
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 ('B)]),
                return 'is, 'is  ),
             nf(('is : bool <- read ('InputShare-A-B[fun 'wire0 ('B)])) 
                 'xb : bool <- read ('Share-B['B]), 
                 return (ap 'xor pair('is, 'xb)), 'is 'xb  ),
            apply 'isBobInput ('B)
        ) 
      ; applyAlphaBranchCond('Wire['B], 'is, 'xa, 
                           when (apply 'isBobInput ('B))) 
    *** not gate  
    ;  applySubstChannelCase3(
            'Share-A, 
            'Wire['B], 
             nf('sa : bool <- read ('Share-A[fun 'wire0 ('B)]), 
                return 'sa, 'sa  )   ,
             nf(('sa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
                 'xb : bool <- read ('Share-B['B]), 
                 return (ap 'xor pair('sa, 'xb)), 'sa 'xb  ),
            apply 'isNotGate ('B)
        )                       
     ; applyAlphaBranchCond('Wire['B], 'sa, 'xa, 
                           when (apply 'isNotGate ('B)))
     *** xor gate  
    ;  applySubstChannelCase3(
            'Share-A, 
            'Wire['B], 
             nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 ('B)])), 
                 return (ap 'xor pair('xa, 'ya)), 'xa 'ya  )  ,
             nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 ('B)])) 
                 'xb : bool <- read ('Share-B['B]), 
                 return (ap 'xor pair((ap 'xor pair('xa, 'ya)), 'xb)), 
                 'ya 'xa 'xb  ),
            apply 'isXorGate ('B)
        )                       
     *** and gate
    ;  applySubstChannelCase3(
            'Share-A, 
            'Wire['B], 
             nf(('ba : bool <- read ('OTBit-A-B['B])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 ('B)])), 
                return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
                'ba 'xa 'ya  ) ,
             nf(('ba : bool <- read ('OTBit-A-B['B])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 ('B)]))
                 'xb : bool <- read ('Share-B['B]), 
                 return (ap 'xor pair((ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 'xb)), 
                 'ba 'ya 'xa 'xb  ),
            apply 'isAndGate ('B)
        )                   
    *** now for Share-B      
    ; CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{
       applySelectCaseSubst(
         'Share-B['B], 'Wire['B], apply 'isAliceInput ('B)
       )
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{
       applySelectCaseSubst(
         'Share-B['B], 'Wire['B], apply 'isBobInput ('B)
       )
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{
       applySelectCaseSubst(
         'Share-B['B], 'Wire['B], apply 'isNotGate ('B)
       )
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{
       applySelectCaseSubst(
         'Share-B['B], 'Wire['B], apply 'isXorGate ('B)
       )
      , CASE-DISTINCTION-channel-end-when[cn:ChannelName <- 'Wire['B]]{
        applySelectCaseSubst(
         'Share-B['B], 'Wire['B], apply 'isAndGate ('B)
       )
    }
        }}}
     }   
     *** renamings
    ; applyAlphaBranchCond('Wire['B], 'is, 'xb, 
                           when (apply 'isAliceInput ('B)))      
    ; applyAlphaBranchCond('Wire['B], 'is, 'xb, 
                           when (apply 'isBobInput ('B))) 
      ***(                       
                             
    *** now we handle the Share-B[B] part
    ; SYM[P1:Protocol <- restr16GIndSymShare]{
     applyDropName('Group)
   ; applyAlphaBranchCond('Share-B['B], 'xa, 'ya, 
                           when (apply 'isAliceInput ('B))
                         )
   ; applyAlphaBranchCond('Share-B['B], 'xa, 'ya, 
                           when (apply 'isBobInput ('B))
                         )  
   ; applyAlphaBranchCond('Share-B['B], 'xa, 'ya, 
                           when (apply 'isNotGate ('B))
                         )                                            
   ; applyAlphaBranchCond('Share-B['B], 'xa, 'za, 
                           when (apply 'isXorGate ('B))
                         )  
   ; applyAlphaBranchCond('Share-B['B], 'xa, 'za, 
                           when (apply 'isAndGate ('B))
                         )
                    
   
    ; CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B]]{
       applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isAliceInput ('B)
      ),
      CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B]]{
       applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isBobInput ('B)
      ),
      CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B]]{
       applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isNotGate ('B)
      ),
      CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B]]{
       applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isXorGate ('B)
      ),
      CASE-DISTINCTION-channel-end-when[cn:ChannelName <- 'Share-B['B]]{
        applySelectCaseSubst(
         'Wire['B], 'Share-B['B], apply 'isAndGate ('B)
        )
      }
    }
    }
    }
    }  
    *** for alice input
   ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B], 
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 ('B)]),
                return 'is, 'is  ),
             nf(('is : bool <- read ('InputShare-A-A[fun 'wire0 ('B)])) 
                 'xb : bool <- read ('InputShare-B-A[fun 'wire0 ('B)]), 
                 return (ap 'xor pair('is, ap 'xor pair('is, 'xb))), 
                 'is 'xb  ),
            apply 'isAliceInput ('B)
        ) 
   *** get to what we want
   ; applyAlphaBranchCond('Share-B['B], 'is, 'xa, 
                           when (apply 'isAliceInput ('B))
                         )  
   ; applyAlphaBranchCond('Share-B['B], 'xb, 'is, 
                           when (apply 'isAliceInput ('B))
                         )  
   *** for bob input  
   ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B], 
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 ('B)]),
                return 'is, 'is  ),
             nf(('is : bool <- read ('InputShare-A-B[fun 'wire0 ('B)])) 
                ('xb : bool <- read ('InputShare-B-B[fun 'wire0 ('B)])),
                 return (ap 'xor pair('is, ap 'xor pair('is, 'xb))), 
                 'is 'xb  ),
            apply 'isBobInput ('B)
        ) 
   *** some renamings
   ; applyAlphaBranchCond('Share-B['B], 'is, 'xa, 
                           when (apply 'isBobInput ('B))
                         )  
   ; applyAlphaBranchCond('Share-B['B], 'xb, 'is, 
                           when (apply 'isBobInput ('B))  
                         )  
   *** for not gate
    ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B], 
             nf('sa : bool <- read ('Share-A[fun 'wire0 ('B)]), 
                return 'sa, 'sa  ),
             nf(('sa : bool <- read ('Share-A[fun 'wire0 'B])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'B])), 
                return (ap 'xor pair('sa, ap 'xor pair('sa, ap 'neg 'xb))), 
                'sa 'xb  ),
            apply 'isNotGate ('B)
        )      
   ; applyAlphaBranchCond('Share-B['B], 'sa, 'xa, 
                           when (apply 'isNotGate ('B))
                         )       
   *** for xor gate
   ; applyAlphaBranchCond('Share-B['B], 'xa, 'aa, 
                           when (apply 'isXorGate ('B))
                         )
   ; applyAlphaBranchCond('Share-B['B], 'ya, 'ba, 
                           when (apply 'isXorGate ('B))
                         ) 
   ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B], 
             nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
                 'ya : bool <- read ('Share-A[fun 'wire1 ('B)]), 
                 return (ap 'xor pair('xa, 'ya)), 'xa 'ya  ),
             nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 ('B)])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 ('B)])) 
                ('yb : bool <- read ('Share-B[fun 'wire1 ('B)])), 
                return (ap 'xor pair('xb, 'yb)),
                'xa 'ya 'yb 'xb  ),
             apply 'isXorGate ('B)
        )                       
   *** change the order to 'xb 'xa 'yb 'ya 
   ; applyChangeOrderBranch(
       'Share-B['B], 
       apply 'isXorGate ('B), 
       'xb 'xa 'yb 'ya  
     )   
   *** for and gate
   ; applyAlphaBranchCond('Share-B['B], 'ba, 'bc, 
                           when (apply 'isAndGate ('B))
                         )                         
   ; applyAlphaBranchCond('Share-B['B], 'xa, 'xc, 
                           when (apply 'isAndGate ('B))
                         )                         
   ; applyAlphaBranchCond('Share-B['B], 'ya, 'yc, 
                           when (apply 'isAndGate ('B))
                         )                         
   ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B], 
             nf(('ba : bool <- read ('OTBit-A-B['B])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
                 'ya : bool <- read ('Share-A[fun 'wire1 ('B)]), 
                 return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
                 'ba 'xa 'ya  ), 
             nf(('ba : bool <- read ('OTBit-A-B['B])) 
                ('bb : bool <- read ('OTBit-B-A['B])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 ('B)])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 ('B)])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 ('B)]), 
                 return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
                 'ba 'xa 'ya 'bb 'yb 'xb  ),
             apply 'isAndGate ('B)
        )    
   *** change order to 'bb 'ba 'xb 'xa 'yb 'ya   
   ; applyChangeOrderBranch(
       'Share-B['B], 
       apply 'isAndGate ('B), 
       'bb 'ba 'xb 'xa 'yb 'ya  
     )
    
      }  
     ; applyAllSameCases('Share-B['B])
     
     *** now we have to get back to Wire['B]
    ; CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{ 
        *** alice               
        substNFFamilyOne('InputShare-B-A, 'Wire['B],
           nf(('x : bool <- read ('In-A[fun 'wire0 ('B)])) 
               'xa : bool <- read ('InputShare-A-A[fun 'wire0 ('B)]), 
               return (ap 'xor pair('x, 'xa)), 'x 'xa  )
          )
        ; applyDropNFCF('InputShare-A-A, 'Wire['B]) 
        ; applyAlphaNFPr('Wire['B], << 'x, 'inA0 >> emptyQidPairList ) 
        ; SYM[P1:Protocol <- restr16GSymAlice]{idle}
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{  
        *** bob            
        substNFFamilyOne('InputShare-B-B, 'Wire['B],
           nf(('x : bool <- read ('In-B[fun 'wire0 ('B)])) 
               'xa : bool <- read ('InputShare-A-B[fun 'wire0 ('B)]), 
               return (ap 'xor pair('x, 'xa)), 'x 'xa  ) 
          )
        ; applyDropNFCF('InputShare-A-B, 'Wire['B]) 
        ; applyAlphaNFPr('Wire['B], << 'x, 'inB0 >> emptyQidPairList )  
        ; SYM[P1:Protocol <- restr16GSymBob]{idle}
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{  
         *** not
         applyDropName('Group)
         ; SYM[P1:Protocol <- restr16GSymNot]{
               applyDropName('Group)
             ; substNFFamilyOne('Wire, 'Wire['B],
           nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
         'xb : bool <- read ('Share-B[fun 'wire0 ('B)]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
          )
           }, 
         CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B]]{  
         *** xor
           applySwap23Xor('Wire['B])
          ; applyDropName('Group)
          ; SYM[P1:Protocol <- restr16GSymXor]{
             applyDropName('Group)
    ; substNFFamilyOne('Wire, 'Wire['B],
           nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
         'xb : bool <- read ('Share-B[fun 'wire0 ('B)]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
          ) 
    ; applyAlphaNFPr('Wire['B], << 'xa, 'ua >> << 'xb, 'ub >> emptyQidPairList )   
    ; substNFFamilyOne('Wire, 'Wire['B],
           nf(('xa : bool <- read ('Share-A[fun 'wire1 ('B)])) 
         'xb : bool <- read ('Share-B[fun 'wire1 ('B)]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
          )
    ; applyAlphaNFPr('Wire['B], 
                             << 'xa, 'ya >> << 'xb, 'yb >>
                             << 'ua, 'xa >> << 'ub, 'xb >> emptyQidPairList )
    ; changeOrder( chn ('Wire['B]), 'xa 'yb 'ya 'xb  )    
          }
         ,
         
          *** just a change of order, happens by nfs, and transforming the return, xor
         CASE-DISTINCTION-channel-end-when[cn:ChannelName <- 'Wire['B]]{
          *** and
          applySelectCaseSubst(
              'OTBit-B-A['B], 'Wire['B], apply 'isAndGate ('B)
          )
            *** need to transform the return
          ; applyAndXorTerm('Wire['B])

          ; applyDropNFCFCases('OTBit-A-B, 'Wire['B], apply 'isAndGate 'k) 
          ; applyDistribR('Wire['B])
          ; applyDropName('Group)
          ; SYM[P1:Protocol <- restr16GSymAnd] {
            applyDropName('Group)
    ; substNFFamilyOne('Wire, 'Wire['B],
           nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B)])) 
         'xb : bool <- read ('Share-B[fun 'wire0 ('B)]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
          ) 
    ; applyAlphaNFPr('Wire['B], << 'xa, 'ua >> << 'xb, 'ub >> emptyQidPairList )   
    ; substNFFamilyOne('Wire, 'Wire['B],
           nf(('xa : bool <- read ('Share-A[fun 'wire1 ('B)])) 
         'xb : bool <- read ('Share-B[fun 'wire1 ('B)]), 
         return (ap 'xor pair('xa, 'xb)), 'xa 'xb  )
          )
    ; applyAlphaNFPr('Wire['B], 
                             << 'xa, 'ya >> << 'xb, 'yb >>
                             << 'ua, 'xa >> << 'ub, 'xb >> emptyQidPairList )
                             
    ; changeOrder( chn ('Wire['B]), 'xa 'yb 'ya 'xb  )
          } 
         }
        }}
    }
    }
   
    ; SYM[P1:Protocol <- restr16GIndStart]{idle}
     
     *** ; applyGetChannel('Wire['B])
     )
.
)


