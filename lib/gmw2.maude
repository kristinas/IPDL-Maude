***( IPDL

  Copyright : (C) 2022-23, Kristina Sojakova
  License   : GNU General Public License v3.0 or later (GPL-3.0-or-later)
  Authors   : Mihai Codescu <mscodescu@gmail.com>
              Kristina Sojakova <sojakova.kristina@gmail.com>

Two-Party GMW Protocol
See Sec. 4 in doc/case-studies.pdf

)

load ../src/strategies

mod GMW2 is
 including APPROX-EQUALITY .
 protecting LIST{NatPairs} .

 op sumF : -> SigElem .
 eq sumF = 'xor : (bool * bool) ~> bool .
 
 op mulF : -> SigElem .
 eq mulF = 'and : (bool * bool) ~> bool .
 
 op negF : -> SigElem .
 eq negF = 'neg : bool ~> bool .
 
 op flipF : -> SigElem .
 eq flipF = 'flip : unit ~>> bool .
 
 op secSig : -> Signature .
 eq secSig = sumF mulF negF flipF .
 
 var i j l k n : Nat .
 
 sort Gate .
 
 op input-gate : Nat Nat -> Gate [ctor] . *** 0 for Alice 1 for Bob
 op not-gate : Nat -> Gate [ctor] .
 op xor-gate : Nat Nat -> Gate [ctor] .
 op and-gate : Nat Nat -> Gate [ctor] .
 
 sort Circuit . *** list of gates
 subsort Gate < Circuit .
 op emptyCircuit : -> Circuit [ctor] .
 op __ : Circuit Circuit -> Circuit [ctor assoc id: emptyCircuit] .

 op wellFormed : Circuit Nat -> Bool .
 
 var circuit : Circuit .
 
 op C : -> Circuit . *** the circuit acting as parameter 

 eq wellFormed(emptyCircuit, 0) = true .
 ceq wellFormed(circuit input-gate(i, j), s(n)) = true 
  if wellFormed(circuit, n) .
 ceq wellFormed(circuit not-gate(k), s(n)) = true
  if wellFormed(circuit, n) /\ k < n . 
 ceq wellFormed(circuit and-gate(k, l), s(n)) = true
  if wellFormed(circuit, n) /\ k < n /\ l < n .
 ceq wellFormed(circuit xor-gate(k, l), s(n)) = true
  if wellFormed(circuit, n) /\ k < n /\ l < n .  
  
 ops N M K : -> Nat .
 eq K = M + N .
 
 *** op isOutputWire : Nat -> Bool .
 op isAliceInput : Nat -> Bool .
 op isBobInput : Nat -> Bool .
 op isNotGate : Nat -> Bool .
 op isXorGate : Nat -> Bool .
 op isAndGate : Nat -> Bool .
 
 eq isAliceInput(i) = isAliceInputAux(C, i) .
 
 op isAliceInputAux : Circuit Nat -> Bool .
 eq isAliceInputAux(emptyCircuit, 0) = false .
 eq isAliceInputAux(emptyCircuit, s(i)) = false .
 eq isAliceInputAux(circuit gate, s(i)) = isAliceInputAux(circuit, i) .
 eq isAliceInputAux(circuit input-gate(k, 0), 0) = true .
 eq isAliceInputAux(circuit gate, 0) = false [owise] .
 
 eq isBobInput(i) = isBobInputAux(C, i) .
 
 op isBobInputAux : Circuit Nat -> Bool .
 eq isBobInputAux(emptyCircuit, 0) = false .
 eq isBobInputAux(emptyCircuit, s(i)) = false .
 eq isBobInputAux(circuit gate, s(i)) = isBobInputAux(circuit, i) .
 eq isBobInputAux(circuit input-gate(k, 1), 0) = true .
 eq isBobInputAux(circuit gate, 0) = false [owise] .
 
 eq isNotGate(i) = isNotGateAux(C, i) .
 
 op isNotGateAux : Circuit Nat -> Bool .
 eq isNotGateAux(emptyCircuit, 0) = false .
 eq isNotGateAux(emptyCircuit, s(i)) = false .
 eq isNotGateAux(circuit gate, s(i)) = isNotGateAux(circuit, i) .
 eq isNotGateAux(circuit not-gate(k), 0) = true .
 eq isNotGateAux(circuit gate, 0) = false [owise] .
 
 eq isXorGate(i) = isXorGateAux(C, i) .
 
 op isXorGateAux : Circuit Nat -> Bool .
 eq isXorGateAux(emptyCircuit, 0) = false .
 eq isXorGateAux(emptyCircuit, s(i)) = false .
 eq isXorGateAux(circuit gate, s(i)) = isXorGateAux(circuit, i) .
 eq isXorGateAux(circuit xor-gate(k, l), 0) = true .
 eq isXorGateAux(circuit gate, 0) = false [owise] .
 
 op isAndGateAux : Circuit Nat -> Bool .
 eq isAndGateAux(emptyCircuit, 0) = false .
 eq isAndGateAux(emptyCircuit, s(i)) = false .
 eq isAndGateAux(circuit gate, s(i)) = isAndGateAux(circuit, i) .
 eq isAndGateAux(circuit and-gate(k, l), 0) = true .
 eq isAndGateAux(circuit gate, 0) = false [owise] .
 
 *** helpers
 *** get the gate at the end of the circuit, after i pops
 *** i must be at most the length of circuit
 *** the circuit must be non-empty
 
 var gate : Gate .
 
 op gateAt : Circuit Nat -> Gate .
 eq gateAt(circuit gate, 0) = gate .
 eq gateAt(circuit gate, s(n)) = gateAt(circuit, n) .
 
 *** the wires of a gate, as a list
 op wiresOf : Gate -> List{NatPairs} .
 eq wiresOf(input-gate(i, j)) = (0 ;; i) .
 eq wiresOf(not-gate(i)) = (0 ;; i) .
 eq wiresOf(and-gate(k, l)) = (0 ;; k) (1 ;; l) .
 eq wiresOf(xor-gate(k, l)) = (0 ;; k) (1 ;; l) .
 
 *** list as an unsafe map
 var natPairs : List{NatPairs} .
 op _@@_ : List{NatPairs} Nat -> Nat .
 eq ( (i ;; k) natPairs) @@ i = k .
 ceq ( (l ;; k) natPairs) @@ i = natPairs @@ i if l =/= i .
 
 *** wire 0 of the circuit C at a given gate
 op wire0 : Nat -> Nat .
 eq wire0(i) = wiresOf(gateAt(C, i)) @@ 0 .
 
 *** wire 1 of the circuit C at a given gate
 op wire1 : Nat -> Nat .
 eq wire1(i) = wiresOf(gateAt(C, i)) @@ 1 .


 *** here we connect 'wire0 with wire0 
 var nt : NatTerm .
 var f : Map{Qid, NatTerm} .
 ceq evalTerm (fun 'wire0 nt) f = wire0(evalTerm nt f) 
  if (evalTerm nt f) : Nat .
 eq evalTerm (fun 'wire0 nt) f = fun 'wire0 nt [owise] . 
 ceq evalTerm (fun 'wire1 nt) f = wire1(evalTerm nt f) 
  if (evalTerm nt f) : Nat .
 eq evalTerm (fun 'wire1 nt) f = fun 'wire1 nt [owise] . 
  
 *** here we connect 'isAliceInput with isAliceInput
 var A : Set{BoolTerm} .
 eq evalBoolTerm(apply 'isAliceInput nt, A, f) = 
    isAliceInput(evalTerm nt f) . 
 eq evalBoolTerm(apply 'isBobInput nt, A, f) = 
    isBobInput(evalTerm nt f) . 
 eq evalBoolTerm(apply 'isNotGate nt, A, f) = 
    isNotGate(evalTerm nt f) . 
 eq evalBoolTerm(apply 'isXorGate nt, A, f) = 
    isXorGate(evalTerm nt f) . 
 eq evalBoolTerm(apply 'isAndGate nt, A, f) = 
    isAndGate(evalTerm nt f) .      

 *** here we record the assumptions on indices
 var q : Qid .
 ceq A |= fun 'wire0 q <=T N with f = true 
   if (apply 'isAliceInput (evalTerm q f)) in A [label aliceIndex].
 ceq A |= fun 'wire0 q <=T M with f = true 
    if (apply 'isBobInput (evalTerm q f)) in A .
 ceq A |= fun 'wire0 q <=T N + M with f = true 
    if (apply 'isNotGate (evalTerm q f)) in A [label notIndex].
 ceq A |= fun 'wire0 q <=T N + M with f = true 
    if (apply 'isXorGate (evalTerm q f)) in A .
 ceq A |= fun 'wire1 q <=T N + M with f = true 
    if (apply 'isXorGate (evalTerm q f)) in A .   
 ceq A |= fun 'wire0 q <=T N + M with f = true 
    if (apply 'isAndGate (evalTerm q f)) in A [label andIndex] .
 ceq A |= fun 'wire1 q <=T N + M with f = true 
    if (apply 'isAndGate (evalTerm q f)) in A .

 
*** ideal protocol

 op wiresIdeal : -> Protocol .
 eq wiresIdeal =
   family 'Wire 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 'k]), return 'inA0, 'inA0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isBobInput 'k) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 'k]), return 'inB0, 'inB0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isNotGate 'k) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 'k]),
     return (ap 'neg 'x),
     'x :: emptyCNameList
     )
  )
  ;;
  (when (apply 'isAndGate 'k) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'and pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
  ;;
  (when (apply 'isXorGate 'k) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'xor pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
 .  
 
 op ideal : -> Protocol .
 eq ideal = 
   newfamily 'Wire 'k (bound K) : bool in
   ( *** start new
   (family 'In-A_id_adv 'k (bound N) ::= 
     nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA :: emptyCNameList)
   ) 
   ||
   (family 'InRcvd-B_id_adv 'k (bound M) ::= 
     nf('x : bool <- read ('In-B['k]),
        return (),
        'x :: emptyCNameList)
   )
   || 
   wiresIdeal
   || 
   (family 'Out-A 'k (bound K) ::=
      (when (apply 'isOutputWire 'k) --> 
          nf( 'wi : bool <- read ('Wire['k]), return 'wi, 'wi :: emptyCNameList)
      )
      ;;
      (otherwise --> nf('oai : bool <- read ('Out-A['k]), return 'oai, 'oai :: emptyCNameList)
      )  
    ) 
    || 
   (family 'Out-B 'k (bound K) ::=
      (when (apply 'isOutputWire 'k) --> 
         nf( 'wi : bool <- read ('Wire['k]), return 'wi, 'wi :: emptyCNameList)
      )
      ;;
      (otherwise --> nf('obi : bool <- read ('Out-B['k]), return 'obi, 'obi :: emptyCNameList)
      )  
    )
    ||
    (family 'Out-A_id_adv 'k (bound K) ::= 
        nf('oai : bool <- read ('Out-A['k]), return 'oai, 'oai :: emptyCNameList)
    )     
   ) *** end new
 . 

 *** sim
 
 op sim : -> Protocol .
 eq sim = 
     newfamily 'InputShare-A-A 'k (bound N) : bool in
     newfamily 'InputShare-A-B 'k (bound M) : bool in
     newfamily 'OTBit-A-B 'k (bound K) : bool in
     newfamily 'Share-A 'k (bound K) : bool in
     newfamily 'Share-B 'k (bound K) : bool in     
     (simInitial || simInductive || simFinal)
.     

op simInitial : -> Protocol .
eq simInitial = 
 (
 family 'In-A_A_adv 'k (bound N) ::=
   nf('inA : bool <- read ('In-A_id_adv['k]) , return 'inA, 'inA :: emptyCNameList )
 )
 ||
 (
 family 'InRcvd-B_B_adv 'k (bound M) ::=
   nf('inB : unit <- read ('InRcvd-B_id_adv['k]) , return 'inB, 'inB :: emptyCNameList )
 )
 ||
 (
 family 'InputShare-A-A 'k (bound N) ::=
   nf('x : bool <- read ('In-A_id_adv['k]),
      samp ('flip < () >) ,
      'x :: emptyCNameList
     )
 )
 ||
 (
 family 'InputShare-A-B 'k (bound M) ::=
   nf('x : unit <- read ('InRcvd-B_id_adv['k]),
      samp ('flip < () >) ,
      'x :: emptyCNameList
     )
 )
 ||
 (
 family 'InputShare-A-A_A_adv 'k (bound N) ::=
   nf('inA : bool <- read ('InputShare-A-A['k]),
      return 'inA,
      'inA :: emptyCNameList
     )
 )
 ||
 (
 family 'InputShare-A-B_A_adv 'k (bound M) ::=
   nf('inB : bool <- read ('InputShare-A-B['k]),
      return 'inB,
      'inB :: emptyCNameList
     )
 )
 ||
 (
 family 'SendInputShare-B-A_A_adv 'k (bound N) ::=
   nf(('xa : bool <- read ('InputShare-A-A['k]))
      ('x : bool <- read ('In-A_id_adv['k])),
      return (ap 'xor pair('xa, 'x)),
      'xa :: 'x :: emptyCNameList
     )
 )
 ||
 (
 family 'SendInputShare-A-B_A_adv 'k (bound M) ::=
   nf('x : bool <- read ('InputShare-A-B['k]),
      return 'x,
      'x :: emptyCNameList
     )
 )
.


op simFinal : -> Protocol .
eq simFinal = 
  (family 'SendFinalShare-A_A_adv 'k (bound K) ::=
    (when (apply 'isOutputWire 'k) --> 
      nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa :: emptyCNameList)
    )
    ;;
    (otherwise --> 
      nf('sa : bool <- read ('SendFinalShare-A_A_adv['k]), return 'sa, 'sa :: emptyCNameList)
    )
  )
  ||
  (family 'SendFinalShare-B_A_adv 'k (bound K) ::=
    (when (apply 'isOutputWire 'k) --> 
      nf(('xa : bool <- read ('Share-A['k]))
         ('x : bool <- read ('Out-A_id_adv['k])), 
         return (ap 'xor pair('xa, 'x)), 
         'xa :: 'x :: emptyCNameList)
    )
    ;;
    (otherwise --> 
      nf('sa : bool <- read ('SendFinalShare-B_A_adv['k]), return 'sa, 'sa :: emptyCNameList)
    )
  )
  ||
   ( family 'Out-A_A_adv 'k (bound K) ::=
   nf('outA : bool <- read ('Out-A_id_adv['k]),
      return 'outA,
      'outA :: emptyCNameList
     )
 )

.

op simInductive : -> Protocol .
eq simInductive = 
  (family 'OTBit-A-B 'k (bound K) ::=
    (when (apply 'isAndGate 'k)  --> 
          nf(
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
           samp ('flip < () >),
           'xa :: 'ya :: emptyCNameList
           )
    )
    ;;
    (otherwise -->  
      nf( 'otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList )
    )
  )
  ||
  (family 'Share-A 'k (bound K) ::=
        (when (apply 'isAliceInput 'k) --> 
          nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]),
             return 'is,
             'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
          nf(
           'is : bool <- read ('InputShare-A-B[fun 'wire0 'k]),
           return 'is,
           'is :: emptyCNameList
          )
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
             return 'sa,
             'sa :: emptyCNameList
            )
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
           return (ap 'xor pair('xa, 'ya)),
           'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (when (apply 'isAndGate 'k) -->
          nf( 
          ('ba : bool <- read ('OTBit-A-B['k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair(ap 'and pair('xa, 'ya) , 'ba)),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
  )
  ||
  (family 'OTBit-A-B_A_adv 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList)
        )
        ;;
        (otherwise --> 
          nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), return 'otb, 'otb :: emptyCNameList)
        )
      )
  ||
      (family 'Share-A_A_adv 'k (bound K) ::= 
        nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa :: emptyCNameList)
      ) 
  ||
      (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
           return 'ba,
           'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise --> 
          nf('otm : bool <- read ('OTMsg-A-B-0_ot_adv['k]),
             return 'otm,
             'otm :: emptyCNameList
            )
        )    
      )
      ||
      (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
          ('ba : bool <- read ('OTBit-A-B['k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, 'xa)),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise --> 
          nf('otm : bool <- read ('OTMsg-A-B-1_ot_adv['k]),
             return 'otm,
             'otm :: emptyCNameList
            )
        )
      )   
      ||
      (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
           nf(
          ('ba : bool <- read ('OTBit-A-B['k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, 'ya)),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise --> nf('otm : bool <- read ('OTMsg-A-B-2_ot_adv['k]),
             return 'otm,
             'otm :: emptyCNameList
            )
        )
      )
      ||
      (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise --> nf('otm : bool <- read ('OTMsg-A-B-3_ot_adv['k]),
             return 'otm,
             'otm :: emptyCNameList
            )
        )
      )  
      ||
     (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::=
       (when (apply 'isAndGate 'k) --> 
       nf(
       'c0 : bool <- read ('Share-A[fun 'wire0 'k]),
       return (),
       'c0 :: emptyCNameList
       )
       )
       ;;
       (otherwise --> 
         nf('otc : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]),
            return 'otc,
            'otc :: emptyCNameList
           )
       )
     )
     ||
     (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
        nf(
       'c1 : bool <- read ('Share-A[fun 'wire1 'k]),
       return (),
       'c1 :: emptyCNameList
       )
       )
       ;;
       (otherwise --> nf('otc : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]),
            return 'otc,
            'otc :: emptyCNameList
           )
       )
       
     )  
         
.

*** idealPlusSim is just composition

op idealPlusSim : -> Protocol .
eq idealPlusSim = 
 newfamily 'In-A_id_adv 'k (bound N) : bool in
 newfamily 'InRcvd-B_id_adv 'k (bound M) : unit in
 newfamily 'Out-A_id_adv 'k (bound K) : bool in
 (ideal || sim) 
.
 
*** here we start spelling out real 
 
 *** everything from aliceInitial is typed bool
 op aliceInitial  : -> Protocol .
 eq aliceInitial = 
    (family 'In-A_A_adv 'k (bound N) ::= 
       nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA :: emptyCNameList)
    )
    ||
    (family 'InputShare-A-A 'k (bound N) ::= 
       nf(
       'x : bool <- read ('In-A['k]),
       samp ('flip < () >),
       'x :: emptyCNameList) 
    )
    ||
    (family 'InputShare-A-B 'k (bound M) ::= 
      nf('sis : bool <- read ('SendInputShare-A-B['k]), 
         return 'sis, 
         'sis :: emptyCNameList)
    )
    ||
    (family 'InputShare-A-A_A_adv 'k (bound N) ::= 
      nf(
       'is : bool <- read ('InputShare-A-A['k]),
       return 'is,
       'is :: emptyCNameList) 
    )
    ||
    (family 'InputShare-A-B_A_adv 'k (bound M) ::=
           nf(
       'is : bool <- read ('InputShare-A-B['k]),
       return 'is,
       'is :: emptyCNameList) 
    )
    ||
    (family 'SendInputShare-B-A 'k (bound N) ::= 
       nf(
       ('x : bool <- read ('In-A['k]))
       'xa : bool <- read ('InputShare-A-A['k]),
       return (ap 'xor pair('x, 'xa)),
       'x :: 'xa :: emptyCNameList)
    )
    ||
    (family 'SendInputShare-B-A_A_adv 'k (bound N) ::= 
       nf('sis : bool <- read ('SendInputShare-B-A['k]), 
         return 'sis, 
         'sis :: emptyCNameList)
    )
    ||
    (family 'SendInputShare-A-B_A_adv 'k (bound M) ::= 
         nf('sis : bool <- read ('SendInputShare-A-B['k]), 
         return 'sis, 
         'sis :: emptyCNameList)
    )
 .  
 
 *** InRcvd-B_B_adv is unit! the rest is bool
 op bobInitial : -> Protocol .
 eq bobInitial =
    (family 'InRcvd-B_B_adv 'k (bound M) ::= 
       nf('x : bool <- read ('In-B['k]) , return (), 'x :: emptyCNameList)
    )
    ||
    (family 'InputShare-B-A 'k (bound N) ::=
       nf('sis : bool <- read ('SendInputShare-B-A['k]), 
         return 'sis, 
         'sis :: emptyCNameList)
    )
    ||
    (family 'InputShare-B-B 'k (bound M) ::= 
      nf(
       ('x : bool <- read ('In-B['k]) )
       ('xa : bool <- read ('SendInputShare-A-B['k])),
       return (ap 'xor pair('x, 'xa)),
       'x :: 'xa :: emptyCNameList 
      )
    )
    ||
    (family 'SendInputShare-A-B 'k (bound M) ::= 
       nf('x : bool <- read ('In-B['k]),  samp ('flip < () >), 'x :: emptyCNameList)
    )
 .
 
 *** alice inductive
 
 op aliceInductive : -> Protocol .
 eq aliceInductive =
      (family 'OTBit-A-B 'k (bound K) ::= 
         (when (apply 'isAndGate 'k) -->
           nf( 
            ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
            ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
           samp ('flip < () >),
           'xa :: 'ya :: emptyCNameList
           )
         )
         ;;
         (otherwise --> 
           nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList)
         )     
      )
      ||
      (family 'OTBit-A-B_A_adv 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList)
        )
        ;;
        (otherwise --> 
          nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), return 'otb, 'otb :: emptyCNameList)
        )
      )
      ||
      (family 'Share-A 'k (bound K) ::=
        (when (apply 'isAliceInput 'k) --> 
          nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
         nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
             return 'sa, 'sa :: emptyCNameList)
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('xa, 'ya)),
          'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair(ap 'and pair('xa, 'ya) , 'ba)),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
      )
      ||
      (family 'Share-A_A_adv 'k (bound K) ::= 
        nf('sa : bool <- read ('Share-A['k]), 
             return 'sa, 'sa :: emptyCNameList)
      )
      ||
      (family 'OTMsg-A-B-0 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return 'ba,
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise --> 
          nf('otm : bool <- read ('OTMsg-A-B-0['k]), 
             return 'otm, 'otm :: emptyCNameList)
        )
      )
      ||
      (family 'OTMsg-A-B-1 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, 'xa)),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise -->
         nf('otm : bool <- read ('OTMsg-A-B-1['k]), 
             return 'otm, 'otm :: emptyCNameList) 
        )
      )   
      ||
      (family 'OTMsg-A-B-2 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, 'ya)),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise -->
         nf('otm : bool <- read ('OTMsg-A-B-2['k]), 
             return 'otm, 'otm :: emptyCNameList)
        )
      )
      ||
      (family 'OTMsg-A-B-3 'k (bound K) ::=
        (when (apply 'isAndGate 'k) -->
          nf( 
          ('ba : bool <- read ('OTBit-A-B['k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise --> 
          nf('otm : bool <- read ('OTMsg-A-B-3['k]), 
             return 'otm, 'otm :: emptyCNameList)
        )
      )
 .
 
 *** bob inductive
 
 op bobInductive : -> Protocol .
 eq bobInductive = 
  (family 'OTBit-B-A 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf('oto : bool <- read ('OTOut-B-A['k]), return 'oto, 'oto :: emptyCNameList)
    )
    ;;
    (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb :: emptyCNameList)
    )
  )
  ||
  (family 'OTChoice-B-A-0 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire0 'k]), return 'sb, 'sb :: emptyCNameList)
    )
    ;;
    (otherwise --> 
      nf('otc : bool <- read ('OTChoice-B-A-0['k]), return 'otc, 'otc :: emptyCNameList)
    )
  )
  ||
  (family 'OTChoice-B-A-1 'k (bound K) ::=
    (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire1 'k]), return 'sb, 'sb :: emptyCNameList)
    )
    ;;
    (otherwise -->
      nf('otc : bool <- read ('OTChoice-B-A-1['k]), return 'otc, 'otc :: emptyCNameList)
    )
  )
  ||
  (family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
          nf('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
          nf('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('xb : bool <- read ('Share-B[fun 'wire0 'k]),
             return (ap 'neg 'xb),
             'xb :: emptyCNameList)
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
          ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k])) ,
          return (ap 'xor pair('xb, 'yb)),
          'xb :: 'yb :: emptyCNameList 
          )
        )
        ;;
        (when (apply 'isAndGate 'k) --> 
          nf(
          ('bb : bool <- read ('OTBit-B-A['k]))
          ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('yb : bool <- read ('Share-B[fun 'wire1 'k])) ,
          return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))),
          'bb :: 'xb :: 'yb :: emptyCNameList
          )
        )
  )
 .
 
 *** alice final
 
 
 op aliceFinal : -> Protocol .
 eq aliceFinal =
    (family 'SendFinalShare-A 'k (bound K) ::=
       (when (apply 'isOutputWire 'k) --> 
         nf('sa : bool <- read ('Share-A['k]), 
         return 'sa,
         'sa :: emptyCNameList
         )
       ) 
       ;; 
       (otherwise --> 
         nf('sfs : bool <- read ('SendFinalShare-A['k]), 
         return 'sfs,
         'sfs :: emptyCNameList
         )
       ) 
    )
    ||
    (family 'SendFinalShare-A_A_adv 'k (bound K) ::=
      nf('sfs : bool <- read ('SendFinalShare-A['k]), 
         return 'sfs,
         'sfs :: emptyCNameList
         )
    )
    ||
    (family 'SendFinalShare-B_A_adv 'k (bound K) ::=
      nf('sfs : bool <- read ('SendFinalShare-B['k]), 
         return 'sfs,
         'sfs :: emptyCNameList
         )
    )
    ||
    (family 'Out-A 'k (bound K) ::=
      nf(
      ('xa : bool <- read ('SendFinalShare-A['k]))
      ('xb : bool <- read ('SendFinalShare-B['k])),
      return (ap 'xor pair('xa, 'xb)),
      'xa :: 'xb :: emptyCNameList
      )
    )
    ||
    (family 'Out-A_A_adv 'k (bound K) ::= 
      nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA :: emptyCNameList )
    )  
 .
 
 *** bob final
 
 op bobFinal : -> Protocol .
 eq bobFinal = 
   (family 'SendFinalShare-B 'k (bound K) ::=
       (when (apply 'isOutputWire 'k) -->
          nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb :: emptyCNameList)
       ) 
       ;; 
       (otherwise --> 
         nf('s : bool <- read ('SendFinalShare-B['k]), return 's, 's :: emptyCNameList)
       ) 
    )
    ||
    (family 'Out-B 'k (bound K) ::=
      nf(
       ('xa : bool <- read ('SendFinalShare-A['k]))
       ('xb : bool <- read ('SendFinalShare-B['k])),
       return (ap 'xor pair('xa, 'xb)),
       'xa :: 'xb :: emptyCNameList 
      )
    )
 .
 
 *** 'OTChoice-B-A-0_ot_adv and 'OTChoice-B-A-1_ot_adv are unit!
 op 1OutOf4 : -> Protocol .
 eq 1OutOf4 = 
 *** family '1OutOf4OT 'k (bound K) ::= 
    (family 'OTOut-B-A 'k (bound K) ::= 
      nf(
       ('m0 : bool <- read ( 'OTMsg-A-B-0['k]))
       ('m1 : bool <- read ( 'OTMsg-A-B-1['k]))
       ('m2 : bool <- read ( 'OTMsg-A-B-2['k]))
       ('m3 : bool <- read ( 'OTMsg-A-B-3['k]))
       ('c0 : bool <- read ( 'OTChoice-B-A-0['k]))
       ('c1 : bool <- read ( 'OTChoice-B-A-1['k])),
      if 'c0 then
        (if 'c1 then return 'm3 else return 'm2)
      else
        (if 'c1 then return 'm1 else return 'm0),
       'm0 :: 'm1 :: 'm2 :: 'm3 :: 'c0 :: 'c1 :: emptyCNameList    
      )
     )
     ||
     (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
       nf ('otm : bool <- read ('OTMsg-A-B-0['k]), return 'otm, 'otm :: emptyCNameList)
     )   
     ||
     (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
       nf ('otm : bool <- read ('OTMsg-A-B-1['k]), return 'otm, 'otm :: emptyCNameList)
     )
     ||
     (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
       nf ('otm : bool <- read ('OTMsg-A-B-2['k]), return 'otm, 'otm :: emptyCNameList)
     )
     ||
     (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
       nf ('otm : bool <- read ('OTMsg-A-B-3['k]), return 'otm, 'otm :: emptyCNameList)
     )
     ||
     (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::=
       nf(
       'c0 : bool <- read ('OTChoice-B-A-0['k]),
       return (),
       'c0 :: emptyCNameList
       )
     )
     ||
     (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::=
       nf(
       'c1 : bool <- read ('OTChoice-B-A-1['k]),
       return (),
       'c1 :: emptyCNameList)
     )
 .
 
 *** alice
 
 op alice : -> Protocol .
 eq alice = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  ( *** start new
  aliceInitial 
  ||
  aliceInductive
  ||
  aliceFinal
  ) *** end new
 .
 
 op bob : -> Protocol .
 eq bob =
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
 ( *** start new
  bobInitial 
  ||
  bobInductive
  ||
  bobFinal
  ) *** end new
 .
 
 op real : -> Protocol .
 eq real =
  newfamily 'SendInputShare-A-B 'k (bound M) : bool in
  newfamily 'SendInputShare-B-A 'k (bound N) : bool in
  newfamily 'OTMsg-A-B-0 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-1 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-2 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-3 'k (bound K) : bool in
  newfamily 'OTOut-B-A 'k (bound K) : bool in
  newfamily 'OTChoice-B-A-0 'k (bound K) : bool in
  newfamily 'OTChoice-B-A-1 'k (bound K) : bool in
  newfamily 'SendFinalShare-A 'k (bound K) : bool in
  newfamily 'SendFinalShare-B 'k (bound K) : bool in
  (alice || bob || 1OutOf4)
 .
 
 *******************************
 *** here we restructure real
 *******************************
 
 op restrInitial : -> Protocol .
 eq restrInitial = 
  newfamily 'SendInputShare-A-B 'k (bound M) : bool in
  newfamily 'SendInputShare-B-A 'k (bound N) : bool in
   (aliceInitial || bobInitial)
 . 
 
 op restrInductive : -> Protocol .
 eq restrInductive = 
  newfamily 'OTMsg-A-B-0 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-1 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-2 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-3 'k (bound K) : bool in
  newfamily 'OTOut-B-A 'k (bound K) : bool in
  newfamily 'OTChoice-B-A-0 'k (bound K) : bool in
  newfamily 'OTChoice-B-A-1 'k (bound K) : bool in
  (aliceInductive || bobInductive || 1OutOf4)
 .
 
 op restrFinal : -> Protocol .
 eq restrFinal = 
  newfamily 'SendFinalShare-A 'k (bound K) : bool in
  newfamily 'SendFinalShare-B 'k (bound K) : bool in
   (aliceFinal || bobFinal)
 . 
 
 op restr : -> Protocol .
 eq restr = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial || restrInductive || restrFinal) 
 .
 
 *************************************************
 *** auxiliaries
 *************************************************
 
 op restrInitial1 : -> Protocol .
 eq restrInitial1 =
    newNF({'SendInputShare-A-B 'k (bound M) : bool} 
          {'SendInputShare-B-A 'k (bound N) : bool}, 
    (family 'In-A_A_adv 'k (bound N) ::= 
       nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA :: emptyCNameList)
    ) 
    || 
    (family 'InRcvd-B_B_adv 'k (bound M) ::= 
       nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
    ) 
    || 
    (family 'InputShare-A-A 'k (bound N) ::= 
       nf('x : bool <- read ('In-A['k]), samp ('flip < () >), 'x :: emptyCNameList)
    ) 
    || 
    (family 'InputShare-A-A_A_adv 'k (bound N) ::= 
      nf('is : bool <- read ('InputShare-A-A['k]), return 'is, 'is :: emptyCNameList)
    ) 
    ||
    (family 'InputShare-A-B 'k (bound M) ::= 
      nf('sis : bool <- read ('SendInputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)
    ) 
    || 
    (family 'InputShare-A-B_A_adv 'k (bound M) ::= 
      nf('is : bool <- read ('InputShare-A-B['k]), return 'is, 'is :: emptyCNameList)
    ) 
    || 
    (family 'InputShare-B-A 'k (bound N) ::= 
      nf('sis : bool <- read ('SendInputShare-B-A['k]), return 'sis, 'sis :: emptyCNameList)
    ) 
    || 
    (family 'InputShare-B-B 'k (bound M) ::= 
      nf(('x : bool <- read ('In-B['k])) 
          'xa : bool <- read ('InputShare-A-B['k]), 
          return (ap 'xor pair('x, 'xa)), 
          'x :: 'xa :: emptyCNameList)
    ) 
    || 
    (family 'SendInputShare-A-B 'k (bound M) ::= 
      nf('x : bool <- read ('In-B['k]), samp ('flip < () >), 'x :: emptyCNameList)
    ) 
    || 
    (family 'SendInputShare-A-B_A_adv 'k (bound M) ::=  
      nf('sis : bool <- read ('InputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)
    ) 
    || 
    (family 'SendInputShare-B-A 'k (bound N) ::= 
      nf(('x : bool <- read ('In-A['k])) 
          'xa : bool <- read ('InputShare-A-A['k]), 
          return (ap 'xor pair('x, 'xa)), 
          'x :: 'xa :: emptyCNameList)
    ) 
    || 
    (family 'SendInputShare-B-A_A_adv 'k (bound N) ::= 
      nf('sis : bool <- read ('InputShare-B-A['k]), return 'sis, 'sis :: emptyCNameList)
    )  , 
    'SendInputShare-A-B :: 'SendInputShare-B-A :: emptyCNameList)   
 .    

********************************
*** splitting restrInductive
********************************
***(
op indAlice1 : -> Protocol .
eq indAlice1 =
 family 'indAlice 'k (bound K) ::=
  (when (apply 'isAliceInput 'k) -->
      (family 'Share-A 'k (bound K) ::=  
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
      ) 
      ||
      (family 'OTBit-A-B 'k (bound K) ::= 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList))
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       (family 'Share-A 'k (bound K) ::= 
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
       )
       ||
       (family 'OTBit-A-B 'k (bound K) ::= 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList))   
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       (family 'Share-A 'k (bound K) ::= 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList))
       ||
       (family 'OTBit-A-B 'k (bound K) ::= 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList))   
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       (family 'Share-A 'k (bound K) ::= 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList))
          ||
          (family 'OTBit-A-B 'k (bound K) ::= 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList))
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       (family 'Share-A 'k (bound K) ::= 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         ))
       ||
       (family 'OTBit-A-B 'k (bound K) ::=  
         nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)) 
    )
.
)

op indAlice : -> Protocol .
eq indAlice = 
family 'indAlice 'k (bound K) ::=
 (
  (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
 ) *** end indAlice
 
.

op indBob : -> Protocol .
eq indBob = 
 family 'indBob 'k (bound K) ::=
 (
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]), 
         return 'is, 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]), 
          return 'is, 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf('xb : bool <- read ('Share-B[fun 'wire0 'k]), 
          return (ap 'neg 'xb), 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
           'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'yb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
          'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'xb :: 'yb :: emptyCNameList)
    )
  ) *** end Share-B
 ) *** end indBob
.

op indAdv : -> Protocol .
eq indAdv = 
 family 'indAdv 'k (bound K) ::=
 (
 (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire0 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv
 ) *** end indAdv
. 

op ind1OutOf4OT : -> Protocol .
eq ind1OutOf4OT = 
 family 'ind1OutOf4OT 'k (bound K) ::=
 (
  (family 'OTChoice-B-A-0 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire0 'k]), 
         return 'sb, 'sb :: emptyCNameList)
    ) 
    ;; 
    (otherwise --> 
      nf('otc : bool <- read ('OTChoice-B-A-0['k]), 
         return 'otc, 'otc :: emptyCNameList)
    )
  ) *** end OTChoice-0
  ||
  (family 'OTChoice-B-A-1 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return 'sb, 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otc : bool <- read ('OTChoice-B-A-1['k]), return 'otc, 'otc :: emptyCNameList)
   )
  ) *** end OTChoice-1
  ||
  (family 'OTMsg-A-B-0 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (otherwise --> 
      nf('otm : bool <- read ('OTMsg-A-B-0['k]), return 'otm, 'otm :: emptyCNameList)
    )
  ) *** end msg-0
  ||
  (family 'OTMsg-A-B-1 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otm : bool <- read ('OTMsg-A-B-1['k]), return 'otm, 'otm :: emptyCNameList)
   )
  ) *** end msg-1
  ||
  (family 'OTMsg-A-B-2 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otm : bool <- read ('OTMsg-A-B-2['k]), return 'otm, 'otm :: emptyCNameList)
   )
  ) *** end msg-2
  || 
  (family 'OTMsg-A-B-3 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
         'ba :: 'xa :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (otherwise --> 
      nf('otm : bool <- read ('OTMsg-A-B-3['k]), return 'otm, 'otm :: emptyCNameList)
    )
  ) *** end msg-3
  ||
  (family 'OTOut-B-A 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
          'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                              ap 'xor pair(ap 'and pair('xa, 'yb), 
                                           ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
    ) 
    ;;
    (otherwise --> 
       nf(('c0 : bool <- read ('OTChoice-B-A-0['k])) 
          ('c1 : bool <- read ('OTChoice-B-A-1['k])) 
          ('m0 : bool <- read ('OTMsg-A-B-0['k])) 
          ('m1 : bool <- read ('OTMsg-A-B-1['k])) 
          ('m2 : bool <- read ('OTMsg-A-B-2['k])) 
           'm3 : bool <- read ('OTMsg-A-B-3['k]), 
           if 'c0 then
               if 'c1 then return 'm3 
                      else return 'm2 
                  else 
               if 'c1 then return 'm1 
                      else return 'm0, 
          'm0 :: 'm1 :: 'm2 :: 'm3 :: 'c0 :: 'c1 :: emptyCNameList)
    )
  ) *** end out
 ) *** end 1OutOf4OT
.

op restrIndSplit : -> Protocol .
eq restrIndSplit =
  newfamily 'OTMsg-A-B-0 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-1 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-2 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-3 'k (bound K) : bool in
  newfamily 'OTOut-B-A 'k (bound K) : bool in
  newfamily 'OTChoice-B-A-0 'k (bound K) : bool in
  newfamily 'OTChoice-B-A-1 'k (bound K) : bool in
    (indAlice || indBob || indAdv || ind1OutOf4OT)
.

op restrIndSplitSym : -> Protocol .
eq restrIndSplitSym =
  (indAlice || indBob || indAdv )
.

endm 

smod EXECUTE is
 pr GMW2 .
 pr STRATS .
 
 var x y x1 x2 x3 : Qid .
 var Sigma : Signature .
 var Delta : ChannelContext .
 var Gamma : TypeContext .
 var I O : Set{CNameBound} .
 var A : Set{BoolTerm} .
 var cn : ChannelName .
 var pConf : ProtocolConfig .
 var P : Protocol .

 *******************************
 *** assumptions
 *******************************

 *** x1 + x2 * x3 = x1 * x3 + x2 * x3
 
  eq ap 'and pair(ap 'xor pair(x1, x2), x3) =
     ap 'xor pair(ap 'and pair(x1, x3), ap 'and pair(x2, x3)) .
     
 *** x + x = False
 
 *** eq ap 'xor pair(x, x) = False .  
 
 var e : Expression .
 
 eq ap 'xor pair(e, e) = False .
 *** TODO: would it make sense to do this for all axioms?
 
 *** x + False = x
 
  eq ap 'xor pair(x, False) = x . 
  
 *** x + True = not x
 
 eq ap 'xor pair(x, True) = ap 'neg x . 
 
 *** x * False = False
 eq ap 'and pair(x, False) = False .    
 
  *** x * True = x
 eq ap 'and pair(x, True) = x .
 
 *** False + x = x
 
  eq ap 'xor pair(False, x) = x . 
 
 *** True + x = not x
 
 eq ap 'xor pair(True, x) = ap 'neg x . 
 
 *** False * x = False
 eq ap 'and pair(False, x) = False .    
 
  *** True * x = x
 eq ap 'and pair(True, x) = x .
 
 rl [flip-invar-xor-r] : rConfig(Sigma, Delta, Gamma (x : bool),
            y : bool <- samp ('flip < () >) ; 
            return (ap 'xor pair(x, y)), I, A, bool
            )
            => 
            rConfig(Sigma, Delta , Gamma (x : bool),
            samp ('flip < () >), I, A, bool) .  
            
 rl [flip-invar-xor-l] : rConfig(Sigma, Delta, Gamma (y : bool),
            x : bool <- samp ('flip < () >) ; 
            return (ap 'xor pair(x, y)), I, A, bool
            )
            => 
            rConfig(Sigma, Delta , Gamma (y : bool),
            samp ('flip < () >), I, A, bool) .  
            
 *** strategies needed for splitting real in three parts
 
 op restr0 : -> Protocol .
 eq restr0 = restrInductive || restrFinal .
 
 strat rewriteRestrInitial @ ProtocolConfig .
 sd rewriteRestrInitial := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestrInitial}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[  *** add this for a speedup: Q:Protocol <- new2NF(restr0), 
                                      P1:Protocol <- new2NF(restrInitial)
                                   ]
                    {
     SYM[P1:Protocol <- restrInitial1]{
         substNFFamiliesOne(
           'InputShare-A-B, 'InputShare-B-B,
           nf('sis : bool <- read ('SendInputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)
       )
     ; substNFFamiliesOne(
           'InputShare-A-B, 'SendInputShare-A-B_A_adv,
           nf('sis : bool <- read ('SendInputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)
       )
     ; substNFFamiliesOne(
           'InputShare-B-A, 'SendInputShare-B-A_A_adv,
           nf('sis : bool <- read ('SendInputShare-B-A['k]), return 'sis, 'sis :: emptyCNameList)
       )
     ; applyAlphaNFPr('InputShare-B-B, << 'sis,'xa >> emptyQidPairList)  
    }
      ; foldNFFamily('SendInputShare-A-B, 'InputShare-A-B)
      ; foldNFFamily('SendInputShare-B-A, 'InputShare-B-A)
                    }
 .
 
 strat rewriteRestrInductive @ ProtocolConfig .
  sd rewriteRestrInductive := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestrInductive}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[  *** Q:Protocol <- new2NF(restr0), 
                                      P1:Protocol <- new2NF(restrInductive)
                                   ]
                    { 
        applyCasesSubstDivergeOwise(
          'OTMsg-A-B-0, 'OTMsg-A-B-0_ot_adv, 'k, bool, 'x3
        )
      ; applyCasesSubstDivergeOwise(
          'OTMsg-A-B-1, 'OTMsg-A-B-1_ot_adv, 'k, bool, 'x3
        )
      ; applyCasesSubstDivergeOwise(
          'OTMsg-A-B-2, 'OTMsg-A-B-2_ot_adv, 'k, bool, 'x3
        )
      ; applyCasesSubstDivergeOwise(
          'OTMsg-A-B-3, 'OTMsg-A-B-3_ot_adv, 'k, bool, 'x3
        )  
      ; applyCasesSubstDivergeOwise(
          'OTChoice-B-A-0, 'OTChoiceRcvd-B-A-0_ot_adv, 'k, unit, 'x3
        )
      ; applyCasesSubstDivergeOwise(
          'OTChoice-B-A-1, 'OTChoiceRcvd-B-A-1_ot_adv, 'k, unit, 'x3
        )    
      *** now we want to substitute in OTOut-B-A only for and gates
      *** so we need to add this case distinction
      ; applyAddSameCases('OTOut-B-A, apply 'isAndGate 'k)
      *** now we can do the substitution on first branch
      ; applySameCasesSubstFirstBranch('OTMsg-A-B-0, 'OTOut-B-A, 'k)      
      ; applySameCasesSubstFirstBranch('OTMsg-A-B-1, 'OTOut-B-A, 'k)
      ; applySameCasesSubstFirstBranch('OTMsg-A-B-2, 'OTOut-B-A, 'k)
      ; applySameCasesSubstFirstBranch('OTMsg-A-B-3, 'OTOut-B-A, 'k)
      ; applySameCasesSubstFirstBranch('OTChoice-B-A-0, 'OTOut-B-A, 'k)
      ; applyBranch1Alpha('OTOut-B-A, << 'sb, 'xb >> emptyQidPairList)
      ; applySameCasesSubstFirstBranch('OTChoice-B-A-1, 'OTOut-B-A, 'k)
      ; applyBranch1Alpha('OTOut-B-A, << 'sb, 'yb >> emptyQidPairList)
      ; applyIfExt2('OTOut-B-A,
                    return (ap 'xor pair('ba, 
                                 ap 'xor pair(ap 'and pair('xa, 'yb), 
                                              ap 'and pair('xb, 'ya)
                                             )
                                 )
                           ), 
                     'xb, 'yb)
      ; applySameCasesSubstFirstBranch('OTOut-B-A, 'OTBit-B-A, 'k)   
      ; SYM[P1:Protocol <- restrIndSplit]{
         sugar-newNF
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       ; applyDropName('ind1OutOf4OT)
      }            
      ; sugar-newNF  
      ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       ; applyDropName('ind1OutOf4OT)
       ; absorbFamily('OTOut-B-A) 
       ; absorbFamily('OTMsg-A-B-0)
       ; absorbFamily('OTMsg-A-B-1)  
       ; absorbFamily('OTMsg-A-B-2)
       ; absorbFamily('OTMsg-A-B-3)
       ; absorbFamily('OTChoice-B-A-0)
       ; absorbFamily('OTChoice-B-A-1)
       **** here I need to do a sym proof from the protocol without the 4th component
      ; SYM[P1:Protocol <- restrIndSplitSym]{
         applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       }
                    }
     .           
  
  strat rewriteRestrFinal @ ProtocolConfig .
  sd rewriteRestrFinal := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestrFinal}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[  *** Q:Protocol <- new2NF(restr0), 
                                      P1:Protocol <- new2NF(restrFinal)
                                   ]
                    { 
                    applyCasesSubstDivergeOwise('SendFinalShare-A, 'Out-A, 'k, bool, 'x3)
      ; applySameCasesSubstFirstBranch('SendFinalShare-B, 'Out-A, 'k)
      ; applyCasesSubstDivergeOwise('SendFinalShare-A, 'Out-B, 'k, bool, 'x3)
      ; applySameCasesSubstFirstBranch('SendFinalShare-B, 'Out-B, 'k) 
      ; applyCasesSubstDivergeOwise('SendFinalShare-A, 'SendFinalShare-A_A_adv, 'k, bool, 'x3)
      ; applyCasesSubstDivergeOwise('SendFinalShare-B, 'SendFinalShare-B_A_adv, 'k, bool, 'x3)
      ; absorbFamily('SendFinalShare-A)
      ; absorbFamily('SendFinalShare-B)
      *** TODO: might have to do some alphas here!
                    }
    . 
      
endsm

***( proof commented out for now, keep it though!

*** this is idealPlusSim proof

srew [1] 
 pConfig(secSig,
           ('In-A @ N :: bool)
           ('In-B @ M :: bool)          
           ('In-A_A_adv @ N :: bool) 
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B_A_adv @ M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
            ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
           ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool)
           ('OTOut-A-B @ N + M :: bool),
           idealPlusSim,
           insert('In-A @ N, 'In-B @ M), *** I 
           getOutputs(idealPlusSim),
           empty
        )
using    sugar-newNF
       ; moveNewToFront 
       ; applySubstNFLeft('SendFinalShare-B_A_adv, 'Out-A_id_adv, 
          nf('oai : bool <- read ('Out-A['k]), return 'oai, 'oai :: emptyCNameList)
         )
       ; foldNFFamily('Out-A_id_adv, 'Out-A_A_adv)
       ; substNFFamiliesOne(
           'In-A_id_adv, 'In-A_A_adv, 
           nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA :: emptyCNameList)
         )
       ; substNFFamiliesOne(
           'In-A_id_adv, 'InputShare-A-A,
           nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA :: emptyCNameList)
         )
       ; foldNFFamily('In-A_id_adv, 'SendInputShare-B-A_A_adv)  
        ; substNFFamiliesOne(
          'InRcvd-B_id_adv, 'InRcvd-B_B_adv,
           nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
         )
        ; foldNFFamily('InRcvd-B_id_adv, 'InputShare-A-B) 
      
.

*** real to restr

srew [1] 
 pConfig(secSig,
           ('In-A @ N :: bool)
           ('In-B @ M :: bool)          
           ('In-A_A_adv @ N :: bool) 
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B_A_adv @ M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
            ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
           ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool)
           ('OTOut-A-B @ N + M :: bool),
           real,
           insert('In-A @ N, 'In-B @ M), *** I 
           getOutputs(idealPlusSim),
           empty
        )
using     sugar-newNF
        ; moveNewToFront
        ; SYM[P1:Protocol <- restr]{
            sugar-newNF
        ; moveNewToFront
         ; reorder-newNF[ql2:CNameList <- 
        'SendInputShare-A-B :: 'SendInputShare-B-A :: 
        'OTMsg-A-B-0 :: 'OTMsg-A-B-1 :: 'OTMsg-A-B-2 :: 'OTMsg-A-B-3 :: 
        'OTOut-B-A :: 'OTChoice-B-A-0 :: 'OTChoice-B-A-1 :: 
        'SendFinalShare-A :: 'SendFinalShare-B :: 
        'InputShare-A-A :: 'InputShare-A-B :: 
        'OTBit-A-B :: 
        'Share-A :: 'InputShare-B-A :: 'InputShare-B-B :: 'OTBit-B-A :: 
        'Share-B :: emptyCNameList
       ]
        }
        ; sugar-newNF
       
        
.
)

srew [1] 
 pConfig(secSig,
           ('In-A @ N :: bool)
           ('In-B @ M :: bool)          
           ('In-A_A_adv @ N :: bool) 
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B_A_adv @ M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
            ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
           ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool)
           ('OTOut-A-B @ N + M :: bool),
           restr,
           insert('In-A @ N, 'In-B @ M), *** I 
           getOutputs(idealPlusSim),
           empty
        )
using     sugar-newNF
        ; rewriteRestrInitial
        ; rewriteRestrInductive
        ; rewriteRestrFinal
.

***( here we test combined notation

srew [1] pConfig(secSig,  
                 ('OTBit-A-B @ K :: bool)
                 ('Share-A @ K :: bool)
                 ('InputShare-A-A @ N :: bool) 
                 ('InputShare-A-B @ M :: bool), 
                 indAlice1, 
                 ('InputShare-A-A @ N,'InputShare-A-B @ M), 
                 getOutputs(indAlice1), 
                 empty)
using idle .
      applyCombine('indAlice) - does not work, this is general enough
)

***( here are the bits that we want to combine in the restr splitting proof
set trace off .

srew [1] 
 pConfig(secSig,
           ('OTBit-A-B @ N + M :: bool)  
           ('OTBit-B-A @ N + M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('Share-A @ K :: bool)
           ('Share-B @ K :: bool)          
           ('In-A_A_adv @ N :: bool)
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A @ N :: bool)
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B @ M :: bool) 
           ('InputShare-A-B_A_adv @ M :: bool)
           ('InputShare-B-A @ N :: bool) 
           ('InputShare-B-B @ M :: bool)
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
            ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
           ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A @ K :: bool) 
           ('SendFinalShare-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool)
           ('OTOut-A-B @ N + M :: bool),
           restrInductive,
           empty, *** I 
           getOutputs(restrInductive),
           empty
        )
using   sugar-newNF
      ; applyCasesSubstDivergeOwise(
          'OTMsg-A-B-0, 'OTMsg-A-B-0_ot_adv, 'k, bool, 'x3
        )
      ; applyCasesSubstDivergeOwise(
          'OTMsg-A-B-1, 'OTMsg-A-B-1_ot_adv, 'k, bool, 'x3
        )
      ; applyCasesSubstDivergeOwise(
          'OTMsg-A-B-2, 'OTMsg-A-B-2_ot_adv, 'k, bool, 'x3
        )
      ; applyCasesSubstDivergeOwise(
          'OTMsg-A-B-3, 'OTMsg-A-B-3_ot_adv, 'k, bool, 'x3
        )  
      ; applyCasesSubstDivergeOwise(
          'OTChoice-B-A-0, 'OTChoiceRcvd-B-A-0_ot_adv, 'k, unit, 'x3
        )
      ; applyCasesSubstDivergeOwise(
          'OTChoice-B-A-1, 'OTChoiceRcvd-B-A-1_ot_adv, 'k, unit, 'x3
        )    
      *** now we want to substitute in OTOut-B-A only for and gates
      *** so we need to add this case distinction
      ; applyAddSameCases('OTOut-B-A, apply 'isAndGate 'k)
      *** now we can do the substitution on first branch
      ; applySameCasesSubstFirstBranch('OTMsg-A-B-0, 'OTOut-B-A, 'k)      
      ; applySameCasesSubstFirstBranch('OTMsg-A-B-1, 'OTOut-B-A, 'k)
      ; applySameCasesSubstFirstBranch('OTMsg-A-B-2, 'OTOut-B-A, 'k)
      ; applySameCasesSubstFirstBranch('OTMsg-A-B-3, 'OTOut-B-A, 'k)
      ; applySameCasesSubstFirstBranch('OTChoice-B-A-0, 'OTOut-B-A, 'k)
      ; applyBranch1Alpha('OTOut-B-A, << 'sb, 'xb >> emptyQidPairList)
      ; applySameCasesSubstFirstBranch('OTChoice-B-A-1, 'OTOut-B-A, 'k)
      ; applyBranch1Alpha('OTOut-B-A, << 'sb, 'yb >> emptyQidPairList)
      ; applyIfExt2('OTOut-B-A,
                    return (ap 'xor pair('ba, 
                                 ap 'xor pair(ap 'and pair('xa, 'yb), 
                                              ap 'and pair('xb, 'ya)
                                             )
                                 )
                           ), 
                     'xb, 'yb)
      ; applySameCasesSubstFirstBranch('OTOut-B-A, 'OTBit-B-A, 'k)   
      ; SYM[P1:Protocol <- restrIndSplit]{
         sugar-newNF
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       ; applyDropName('ind1OutOf4OT)
      }            
      ; sugar-newNF  
      ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       ; applyDropName('ind1OutOf4OT)
       ; absorbFamily('OTOut-B-A) 
       ; absorbFamily('OTMsg-A-B-0)
       ; absorbFamily('OTMsg-A-B-1)  
       ; absorbFamily('OTMsg-A-B-2)
       ; absorbFamily('OTMsg-A-B-3)
       ; absorbFamily('OTChoice-B-A-0)
       ; absorbFamily('OTChoice-B-A-1)
       **** here I need to do a sym proof from the protocol without the 4th component
      ; SYM[P1:Protocol <- restrIndSplitSym]{
         applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       } 
                
.

srew [1] 
 pConfig(secSig,
           ('OTBit-A-B @ N + M :: bool)  
           ('OTBit-B-A @ N + M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('Share-A @ K :: bool)
           ('Share-B @ K :: bool)          
           ('In-A_A_adv @ N :: bool)
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A @ N :: bool)
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B @ M :: bool) 
           ('InputShare-A-B_A_adv @ M :: bool)
           ('InputShare-B-A @ N :: bool) 
           ('InputShare-B-B @ M :: bool)
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
            ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
           ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A @ K :: bool) 
           ('SendFinalShare-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool)
           ('OTOut-A-B @ N + M :: bool),
           restrIndSplitSym,
           empty, *** I 
           getOutputs(restrInductive),
           empty
        )
using    applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
.


srew [1] 
 pConfig(secSig,
           ('OTBit-A-B @ N + M :: bool) 
           ('OTBit-B-A @ N + M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool)  
           ('Share-A @ K :: bool)
           ('Share-B @ K :: bool)          
           ('In-A_A_adv @ N :: bool)
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A @ N :: bool)
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B @ M :: bool) 
           ('InputShare-A-B_A_adv @ M :: bool)
           ('InputShare-B-A @ N :: bool) 
           ('InputShare-B-B @ M :: bool)
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
            ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
           ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A @ K :: bool) 
           ('SendFinalShare-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool)
           ('OTOut-A-B @ N + M :: bool),
           restrIndSplit,
           empty, *** I 
           getOutputs(restrInductive),
           empty
        )
using sugar-newNF
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       ; applyDropName('ind1OutOf4OT)
       ; absorbFamily('OTOut-B-A) 
       ; absorbFamily('OTMsg-A-B-0)
       ; absorbFamily('OTMsg-A-B-1)  
       ; absorbFamily('OTMsg-A-B-2)
       ; absorbFamily('OTMsg-A-B-3)
       ; absorbFamily('OTChoice-B-A-0)
       ; absorbFamily('OTChoice-B-A-1)
.       
) 

***( below is restrFinal, keep

srew [1] 
 pConfig(secSig,
           ('Share-A @ K :: bool)
           ('Share-B @ K :: bool)          
           ('In-A_A_adv @ N :: bool)
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A @ N :: bool)
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B @ M :: bool) 
           ('InputShare-A-B_A_adv @ M :: bool)
           ('InputShare-B-A @ N :: bool) 
           ('InputShare-B-B @ M :: bool)
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
            ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
           ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A @ K :: bool) 
           ('SendFinalShare-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool)
           ('OTOut-A-B @ N + M :: bool),
           restrFinal,
           insert('Share-A @ N, 'Share-B @ M), *** I 
           getOutputs(restrFinal),
           empty
        )
using   sugar-newNF
      ; applyCasesSubstDivergeOwise('SendFinalShare-A, 'Out-A, 'k, bool, 'x3)
      ; applySameCasesSubstFirstBranch('SendFinalShare-B, 'Out-A, 'k)
      ; applyCasesSubstDivergeOwise('SendFinalShare-A, 'Out-B, 'k, bool, 'x3)
      ; applySameCasesSubstFirstBranch('SendFinalShare-B, 'Out-B, 'k) 
      ; applyCasesSubstDivergeOwise('SendFinalShare-A, 'SendFinalShare-A_A_adv, 'k, bool, 'x3)
      ; applyCasesSubstDivergeOwise('SendFinalShare-B, 'SendFinalShare-B_A_adv, 'k, bool, 'x3)
      ; absorbFamily('SendFinalShare-A)
      ; absorbFamily('SendFinalShare-B)
      *** TODO: might have to do some renamings here!
      .
)      

***( below is restrInitial, keep
srew [1] 
 pConfig(secSig,
           ('In-A @ N :: bool)
           ('In-B @ M :: bool)          
           ('In-A_A_adv @ N :: bool)
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A @ N :: bool)
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B @ M :: bool) 
           ('InputShare-A-B_A_adv @ M :: bool)
           ('InputShare-B-A @ N :: bool) 
           ('InputShare-B-B @ M :: bool)
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
            ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
           ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool)
           ('OTOut-A-B @ N + M :: bool),
           restrInitial,
           insert('In-A @ N, 'In-B @ M), *** I 
           getOutputs(restrInitial),
           empty
        )
using   sugar-newNF
      ; SYM[P1:Protocol <- restrInitial1]{
         substNFFamiliesOne(
           'InputShare-A-B, 'InputShare-B-B,
           nf('sis : bool <- read ('SendInputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)
       )
     ; substNFFamiliesOne(
           'InputShare-A-B, 'SendInputShare-A-B_A_adv,
           nf('sis : bool <- read ('SendInputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)
       )
     ; substNFFamiliesOne(
           'InputShare-B-A, 'SendInputShare-B-A_A_adv,
           nf('sis : bool <- read ('SendInputShare-B-A['k]), return 'sis, 'sis :: emptyCNameList)
       )
     ; applyAlphaNFPr('InputShare-B-B, << 'sis,'xa >> emptyQidPairList)  
      }
      ; foldNFFamily('SendInputShare-A-B, 'InputShare-A-B)
      ; foldNFFamily('SendInputShare-B-A, 'InputShare-B-A)    
.
)


***( commented out for now, but this is the main computation!

*** WARNING: OTChoiceRcvd-B-A-0_ot_adv @ N + M    'OTChoiceRcvd-B-A-1_ot_adv @ N + M 
***          are outputs!

srew [1] 
 pConfig(secSig,
           ('In-A @ N :: bool)
           ('In-B @ M :: bool)          
           ('In-A_A_adv @ N :: bool) 
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B_A_adv @ M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool)
           ('OTOut-A-B @ N + M :: bool),
           real,
           insert('In-A @ N, 'In-B @ M), *** I 
           ('In-A_A_adv @ N,
    'InRcvd-B_B_adv @ M, 'InputShare-A-A_A_adv @ N, 'InputShare-A-B_A_adv @ M,
    'OTBit-A-B_A_adv @ N + M, 'OTChoice-B-A-0_ot_adv @ N + M,
    'OTChoice-B-A-1_ot_adv @ N + M, 'OTMsg-A-B-0_ot_adv @ N + M,
    'OTMsg-A-B-1_ot_adv @ N + M, 'OTMsg-A-B-2_ot_adv @ N + M,
    'OTMsg-A-B-3_ot_adv @ N + M, 'OTOut-A-B @ N + M, 'Out-A @ N + M,
    'Out-A_A_adv @ N + M, 'Out-B @ N + M, 'SendFinalShare-A_A_adv @ N + M,
    'SendFinalShare-B_A_adv @ N + M, 'SendInputShare-A-B_A_adv @ M,
    'SendInputShare-B-A_A_adv @ N, 'Share-A_A_adv @ N + M),
           empty
        )
using  sugar-newNF
     ; moveNewToFront
     ; SYM [P1:Protocol <- restr]{
       sugar-newNF
     ; moveNewToFront
     ; reorder-newNF[ql2:CNameList <- 
        'SendInputShare-A-B :: 'SendInputShare-B-A :: 'OTMsg-A-B-0 :: 
        'OTMsg-A-B-1 :: 'OTMsg-A-B-2 :: 'OTMsg-A-B-3 :: 'OTChoice-B-A-0 :: 
        'OTChoice-B-A-1 :: 'SendFinalShare-A :: 'SendFinalShare-B :: 
        'InputShare-A-A :: 'InputShare-A-B :: 'OTBit-A-B :: 
        'Share-A :: 'InputShare-B-A :: 'InputShare-B-B :: 'OTBit-B-A :: 
        'Share-B :: emptyCNameList
       ]
     }
     ; sugar-newNF
.
)



*************************************
*** from here down we have comments
*************************************

***(

red typeOf(secSig, 
           ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
           ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
           ('In-A @ N :: bool)
           ('In-B @ M :: bool)          
           ('In-A_A_adv @ N :: bool) 
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B_A_adv @ M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool) , 
           insert('In-A @ N, 'In-B @ M), *** I 
           empty, *** A
           restr)
.
red typeOf(secSig, 
           ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
           ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
           ('In-A @ N :: bool)
           ('In-B @ M :: bool)          
           ('In-A_A_adv @ N :: bool) 
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B_A_adv @ M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool) , 
           insert('In-A @ N, 'In-B @ M), *** I 
           empty, *** A
           idealPlusSim)
.


red typeOf(secSig, 
           ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
           ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
           ('In-A @ N :: bool)
           ('In-B @ M :: bool)          
           ('In-A_A_adv @ N :: bool) 
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B_A_adv @ M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool) , 
           insert('In-A @ N, 'In-B @ M), *** I 
           empty, *** A
           real)
.

red typeOf(secSig, 
           ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
           ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
           ('In-A @ N :: bool)
           ('In-B @ M :: bool)          
           ('In-A_A_adv @ N :: bool) 
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B_A_adv @ M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool) , 
           insert('In-A @ N, 'In-B @ M), *** I 
           empty, *** A
           idealPlusSim)
.

red typeOf(secSig, 
           ('In-A_id_adv @ N :: bool)  
           ('InRcvd-B_id_adv @ M :: unit)
           ('Out-A @ N + M :: bool) 
           ('Out-A_id_adv @ N + M :: bool) 
           ('Out-B @ N + M :: bool)
           ('In-A_A_adv @ N :: bool) 
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A @ N :: bool)
           ('InputShare-A-A_A_adv @ N :: bool) 
           ('InputShare-A-B @ M :: bool) 
           ('InputShare-A-B_A_adv @ M :: bool)
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool)


           ('In-A @ N :: bool)
           ('In-B @ M :: bool),
           insert('In-A_id_adv @ N , 'InRcvd-B_id_adv @ M), *** I 
           empty, *** A
           simInitial)
.


red typeOf(secSig, 
           ('In-A_id_adv @ N :: bool)  
           ('InRcvd-B_id_adv @ M :: unit)
           ('Out-A @ N + M :: bool) 
           ('Out-A_id_adv @ N + M :: bool) 
           ('Out-B @ N + M :: bool)

           ('In-A @ N :: bool)
           ('In-B @ M :: bool),
           insert('In-A @ N, 'In-B @ M), *** I 
           empty, *** A
           ideal)
.

red typeOf(secSig, 
           ('In-A_id_adv @ N :: bool)  
           ('InRcvd-B_id_adv @ M :: unit)
           ('Out-A @ N + M :: bool) 
           ('Out-A_id_adv @ N + M :: bool) 
           ('Out-B @ N + M :: bool)
           ('In-A_A_adv @ N :: bool) 
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A @ N :: bool)
           ('InputShare-A-A_A_adv @ N :: bool) 
           ('InputShare-A-B @ M :: bool) 
           ('InputShare-A-B_A_adv @ M :: bool)
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool)


           ('In-A @ N :: bool)
           ('In-B @ M :: bool),
           insert('In-A_id_adv @ N , 'InRcvd-B_id_adv @ M), *** I 
           empty, *** A
           simInitial)
.


*********************************
*********************************

red typeOf(secSig, 
           ('In-A @ N :: bool)
           ('In_A_id_adv @ K :: bool),
           insert('In-A @ N, 'In-B @ M), *** I 
           empty, *** A
           test)
.

red typeOf(
     secSig,
     ('In-A @ N :: bool)
     ('In-B @ M :: bool)
     ('In-A_A_adv @ N :: bool) 
     ('InputShare-A-A @ N :: bool)
     ('InputShare-A-A_A_adv @ N :: bool)
     ('InputShare-A-B @ M :: bool) 
     ('InputShare-A-B_A_adv @ M :: bool)
     ('SendInputShare-A-B_A_adv @ M :: bool) 
     ('SendInputShare-B-A @ N :: bool)
     ('SendInputShare-B-A_A_adv @ N :: bool)
     *** from here down inputs
     ('SendInputShare-A-B @ M :: bool),
    insert('SendInputShare-A-B @ M ,
     insert('In-A @ N, 'In-B @ M)
    ), *** I    
    empty, ***A
    aliceInitial
    ) 
.

red typeOf(
     secSig,
     ('In-A @ N :: bool)
     ('In-B @ M :: bool)
     ('OTBit-A-B @ K :: bool) 
     ('OTBit-A-B_A_adv @ K :: bool)
     ('OTMsg-A-B-0 @ K :: bool) 
     ('OTMsg-A-B-1 @ K :: bool) 
     ('OTMsg-A-B-2 @ K :: bool)
     ('OTMsg-A-B-3 @ K :: bool)
     ('Share-A @ K :: bool) 
     ('Share-A_A_adv @ K :: bool)
     ***inputs
     ('InputShare-A-A @ N :: bool)
     ('InputShare-A-B @ M :: bool),
     insert('InputShare-A-A @ N,
     insert('InputShare-A-B @ M,
     insert('In-A @ N, 'In-B @ M))),
    empty, ***A
    aliceInductive
    ) 
.

red typeOf(
      secSig,
     ('In-A @ N :: bool)
     ('In-B @ M :: bool)
     ('Out-A @ N + M :: bool) 
     ('Out-A_A_adv @ N + M :: bool) 
     ('SendFinalShare-A @ N + M :: bool)
     ('SendFinalShare-A_A_adv @ N + M :: bool) 
     ('SendFinalShare-B_A_adv @ N + M :: bool)
     *** inputs
     ('SendFinalShare-B @ K :: bool)
     ('Share-A @ K :: bool) 
     ,
    insert('SendFinalShare-B @ K , insert('Share-A @ K,
    insert('In-A @ N, 'In-B @ M))
    ),
    empty, ***A
    aliceFinal
    ) 
.

red typeOf(
     secSig,
     ('In-A @ N :: bool)
     ('In-B @ M :: bool)
     ('InRcvd-B_B_adv @ M :: unit) 
     ('InputShare-B-A @ N :: bool)
     ('InputShare-B-B @ M :: bool) 
     ('SendInputShare-A-B @ M :: bool)
     ('SendInputShare-B-A @ N :: bool),
    insert('SendInputShare-B-A @ N , insert('In-A @ N, 'In-B @ M)),
    empty, ***A
    bobInitial
    ) 
.

red typeOf(
     secSig,
  ('In-A @ N :: bool)
     ('In-B @ M :: bool)
  ('OTBit-B-A @ N + M :: bool)
  ('OTChoice-B-A-0 @ N + M :: bool)
  ('OTChoice-B-A-1 @ N + M :: bool)
  ('Share-B @ N + M :: bool)
  ***inputs
  ('OTOut-B-A @ N + M :: bool)
  ('InputShare-B-A @ N :: bool)
  ('InputShare-B-B @ M :: bool) ,
  insert('InputShare-B-A @ N, insert('InputShare-B-B @ M,
   insert('OTOut-B-A @ N + M , insert('In-A @ N, 'In-B @ M)))
  ),
    empty, ***A
    bobInductive
    ) 
. 


red typeOf(
     secSig,
     ('In-A @ N :: bool)
     ('In-B @ M :: bool)
     ('Out-B @ K :: bool) 
     ('SendFinalShare-B @ K :: bool)
     *** inputs
     ('SendFinalShare-A @ K :: bool)
     ('Share-B @ K :: bool)
     ('SendInputShare-B-A @ N :: bool)
     ,
     insert('SendFinalShare-A @ K,
     insert('Share-B @ K,   
    insert('SendInputShare-B-A @ N , insert('In-A @ N, 'In-B @ M)))),
    empty, ***A
    bobFinal
    ) 
.

red typeOf( secSig,
     ('In-A @ N :: bool)
     ('In-B @ M :: bool)
     ('OTChoice-B-A-0_ot_adv @ N + M :: unit) 
     ('OTChoice-B-A-1_ot_adv @ N + M :: unit)
     ('OTMsg-A-B-0_ot_adv @ N + M :: bool) 
     ('OTMsg-A-B-1_ot_adv @ N + M :: bool) 
     ('OTMsg-A-B-2_ot_adv @ N + M :: bool)
     ('OTMsg-A-B-3_ot_adv @ N + M :: bool) 
     ('OTOut-B-A @ N + M :: bool) 
     ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
     ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
     *** inputs
     ('OTChoice-B-A-0 @ N + M :: bool)
     ('OTChoice-B-A-1 @ N + M :: bool)
     ('OTMsg-A-B-0 @ K :: bool) 
     ('OTMsg-A-B-1 @ K :: bool) 
     ('OTMsg-A-B-2 @ K :: bool)
     ('OTMsg-A-B-3 @ K :: bool),
    insert('OTChoice-B-A-0 @ N + M, 
     insert('OTChoice-B-A-1 @ N + M,
      insert('OTMsg-A-B-0 @ K,
       insert('OTMsg-A-B-1 @ K, 
       insert('OTMsg-A-B-2 @ K, 
       insert('OTMsg-A-B-3 @ K, 
      insert('In-A @ N, 'In-B @ M
      ))))))
    )  ,
    empty, ***A
    1OutOf4
)
.

red typeOf(
     secSig,
     ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
     ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
     ('In-A @ N :: bool)
     ('In-B @ M :: bool)
     ('In-A_A_adv @ N :: bool) 
     ('InputShare-A-A_A_adv @ N :: bool)
     ('InputShare-A-B_A_adv @ M :: bool)
     ('SendInputShare-A-B_A_adv @ M :: bool) 
     ('SendInputShare-B-A_A_adv @ N :: bool)
     ('Out-A @ N + M :: bool) 
     ('Out-A_A_adv @ N + M :: bool) 
     ('SendFinalShare-A @ N + M :: bool)
     ('SendFinalShare-A_A_adv @ N + M :: bool) 
     ('SendFinalShare-B_A_adv @ N + M :: bool)
     ('InRcvd-B_B_adv @ M :: unit)  
     ('OTChoice-B-A-0 @ N + M :: bool)
     ('OTChoice-B-A-1 @ N + M :: bool)
     ('OTMsg-A-B-0 @ K :: bool) 
     ('OTMsg-A-B-1 @ K :: bool) 
     ('OTMsg-A-B-2 @ K :: bool)
     ('OTMsg-A-B-3 @ K :: bool) 
     ('Out-B @ K :: bool) 
     ('SendFinalShare-B @ K :: bool) 
     ('SendInputShare-A-B @ M :: bool)
     ('SendInputShare-B-A @ N :: bool)
     ('OTChoice-B-A-0_ot_adv @ N + M :: unit) 
     ('OTChoice-B-A-1_ot_adv @ N + M :: unit)
     ('OTMsg-A-B-0_ot_adv @ N + M :: bool) 
     ('OTMsg-A-B-1_ot_adv @ N + M :: bool) 
     ('OTMsg-A-B-2_ot_adv @ N + M :: bool)
     ('OTMsg-A-B-3_ot_adv @ N + M :: bool)
     ('OTBit-A-B_A_adv @ K :: bool)
     ('Share-A_A_adv @ K :: bool)
      ('OTOut-B-A @ N + M :: bool) ,
     *** inputs
     insert('In-A @ N, insert('In-B @ M, 
       union(getOutputs(bob), getOutputs(1OutOf4)))),
     empty,
     alice)
. 


red typeOf(
     secSig,
     ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
     ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
     ('In-A @ N :: bool)
     ('In-B @ M :: bool)
     ('InRcvd-B_B_adv @ M :: unit)  
     ('OTChoice-B-A-0 @ N + M :: bool)
     ('OTChoice-B-A-1 @ N + M :: bool)
     ('Out-B @ K :: bool) 
     ('SendFinalShare-B @ K :: bool) 
     ('SendInputShare-A-B @ M :: bool)
     ('SendInputShare-B-A @ N :: bool)
     *** all these below must be inputs for bob!
     ('SendInputShare-B-A @ N :: bool)
     ('In-A_A_adv @ N :: bool) 
     ('InputShare-A-A_A_adv @ N :: bool)
     ('InputShare-A-B_A_adv @ M :: bool)
     ('SendInputShare-A-B_A_adv @ M :: bool) 
     ('SendInputShare-B-A_A_adv @ N :: bool)
     ('Out-A @ N + M :: bool) 
     ('Out-A_A_adv @ N + M :: bool) 
     ('SendFinalShare-A @ N + M :: bool)
     ('SendFinalShare-A_A_adv @ N + M :: bool) 
     ('SendFinalShare-B_A_adv @ N + M :: bool)
     ('OTBit-A-B_A_adv @ K :: bool)
     ('OTMsg-A-B-0 @ K :: bool) 
     ('OTMsg-A-B-1 @ K :: bool) 
     ('OTMsg-A-B-2 @ K :: bool)
     ('OTMsg-A-B-3 @ K :: bool) 
     ('Share-A_A_adv @ K :: bool)
     ('OTChoice-B-A-0_ot_adv @ N + M :: unit) 
     ('OTChoice-B-A-1_ot_adv @ N + M :: unit)
     ('OTMsg-A-B-0_ot_adv @ N + M :: bool) 
     ('OTMsg-A-B-1_ot_adv @ N + M :: bool) 
     ('OTMsg-A-B-2_ot_adv @ N + M :: bool)
     ('OTMsg-A-B-3_ot_adv @ N + M :: bool) 
     ('OTOut-B-A @ N + M :: bool) ,
     *** inputs
     insert('In-A @ N, insert('In-B @ M, 
       union(getOutputs(alice), getOutputs(1OutOf4)))),
     empty,
     bob)
.    

red typeOf(secSig, 
           ('In-A @ N :: bool)
           ('In-B @ M :: bool)          
           ('In-A_A_adv @ N :: bool) 
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B_A_adv @ M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool)
           ('OTOut-B-A @ N + M :: bool) , 
           insert('In-A @ N, 'In-B @ M), *** I 
           empty, *** A
           real)
.
)

***(
srew [1] 
 pConfig(secSig,
           ('In-A @ N :: bool)
           ('In-B @ M :: bool)          
           ('In-A_A_adv @ N :: bool) 
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B_A_adv @ M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool)
           ('OTOut-A-B @ N + M :: bool),
           restr,
           insert('In-A @ N, 'In-B @ M), *** I 
           ('In-A_A_adv @ N,
    'InRcvd-B_B_adv @ M, 'InputShare-A-A_A_adv @ N, 'InputShare-A-B_A_adv @ M,
    'OTBit-A-B_A_adv @ N + M, 'OTChoice-B-A-0_ot_adv @ N + M,
    'OTChoice-B-A-1_ot_adv @ N + M, 'OTMsg-A-B-0_ot_adv @ N + M,
    'OTMsg-A-B-1_ot_adv @ N + M, 'OTMsg-A-B-2_ot_adv @ N + M,
    'OTMsg-A-B-3_ot_adv @ N + M, 'OTOut-A-B @ N + M, 'Out-A @ N + M,
    'Out-A_A_adv @ N + M, 'Out-B @ N + M, 'SendFinalShare-A_A_adv @ N + M,
    'SendFinalShare-B_A_adv @ N + M, 'SendInputShare-A-B_A_adv @ M,
    'SendInputShare-B-A_A_adv @ N, 'Share-A_A_adv @ N + M),
           empty
        )
using  sugar-newNF
     ; moveNewToFront
     ; reorder-newNF[ql2:CNameList <- 
        'SendInputShare-A-B :: 'SendInputShare-B-A :: 'OTMsg-A-B-0 :: 
        'OTMsg-A-B-1 :: 'OTMsg-A-B-2 :: 'OTMsg-A-B-3 :: 'OTChoice-B-A-0 :: 
        'OTChoice-B-A-1 :: 'SendFinalShare-A :: 'SendFinalShare-B :: 
        'InputShare-A-A :: 'InputShare-A-B :: 'OTBit-A-B :: 
        'Share-A :: 'InputShare-B-A :: 'InputShare-B-B :: 'OTBit-B-A :: 
        'Share-B :: emptyCNameList
       ]
.
 
 )  
 
***( restrInitial   

srew [1] 
 pConfig(secSig,
           ('In-A @ N :: bool)
           ('In-B @ M :: bool)          
           ('In-A_A_adv @ N :: bool) 
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B_A_adv @ M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool)
           ('OTOut-A-B @ N + M :: bool),
           restrInitial,
           insert('In-A @ N, 'In-B @ M), *** I 
           getOutputs(restrInitial),
           empty
        )
using  sugar-newNF

.
)
     
