***( IPDL

  Copyright : (C) 2022-23, Kristina Sojakova
  License   : GNU General Public License v3.0 or later (GPL-3.0-or-later)
  Authors   : Mihai Codescu <mscodescu@gmail.com>
              Kristina Sojakova <sojakova.kristina@gmail.com>

Two-Party GMW Protocol
See Sec. 8 in doc/case-studies.pdf

)

load ../src/strategies

mod GMW2 is
 including APPROX-EQUALITY .
 protecting LIST{NatPairs} .

 op sumF : -> SigElem .
 eq sumF = 'xor : (bool * bool) ~> bool .
 *** xor is +
 
 op mulF : -> SigElem .
 eq mulF = 'and : (bool * bool) ~> bool .
 *** and is *
 
 op negF : -> SigElem .
 eq negF = 'neg : bool ~> bool .
 
 op flipF : -> SigElem .
 eq flipF = 'flip : unit ~>> bool .
 
 op secSig : -> Signature .
 eq secSig = sumF mulF negF flipF .
 
 var i j l k n : Nat .
 
 sort Gate .
 
 op input-gate : Nat Nat -> Gate [ctor] . *** 0 for Alice 1 for Bob
 op not-gate : Nat -> Gate [ctor] .
 op xor-gate : Nat Nat -> Gate [ctor] .
 op and-gate : Nat Nat -> Gate [ctor] .
 
 sort Circuit . *** list of gates
 subsort Gate < Circuit .
 op emptyCircuit : -> Circuit [ctor] .
 op __ : Circuit Circuit -> Circuit [ctor assoc id: emptyCircuit] .

 op wellFormed : Circuit Nat -> Bool .
 
 var circuit : Circuit .
 
 op C : -> Circuit . *** the circuit acting as parameter 

 eq wellFormed(emptyCircuit, 0) = true .
 ceq wellFormed(circuit input-gate(i, j), s(n)) = true 
  if wellFormed(circuit, n) .
 ceq wellFormed(circuit not-gate(k), s(n)) = true
  if wellFormed(circuit, n) /\ k < n . 
 ceq wellFormed(circuit and-gate(k, l), s(n)) = true
  if wellFormed(circuit, n) /\ k < n /\ l < n .
 ceq wellFormed(circuit xor-gate(k, l), s(n)) = true
  if wellFormed(circuit, n) /\ k < n /\ l < n .  
  
 ops N M K : -> Nat .
 eq K = M + N .
 
 *** underspecified predicate
 op isOutputWire : Nat -> Bool .
 
 op isAliceInput : Nat -> Bool .
 op isBobInput : Nat -> Bool .
 op isNotGate : Nat -> Bool .
 op isXorGate : Nat -> Bool .
 op isAndGate : Nat -> Bool .
 
 eq isAliceInput(i) = isAliceInputAux(C, i) .
 
 op isAliceInputAux : Circuit Nat -> Bool .
 eq isAliceInputAux(emptyCircuit, 0) = false .
 eq isAliceInputAux(emptyCircuit, s(i)) = false .
 eq isAliceInputAux(gate circuit, s(i)) = isAliceInputAux(circuit, i) .
 eq isAliceInputAux(input-gate(k, 0) circuit, 0) = true .
 eq isAliceInputAux(gate circuit, 0) = false [owise] .
 
 eq isBobInput(i) = isBobInputAux(C, i) .
 
 op isBobInputAux : Circuit Nat -> Bool .
 eq isBobInputAux(emptyCircuit, 0) = false .
 eq isBobInputAux(emptyCircuit, s(i)) = false .
 eq isBobInputAux(gate circuit, s(i)) = isBobInputAux(circuit, i) .
 eq isBobInputAux(input-gate(k, 1) circuit, 0) = true .
 eq isBobInputAux(gate circuit, 0) = false [owise] .
 
 eq isNotGate(i) = isNotGateAux(C, i) .
 
 op isNotGateAux : Circuit Nat -> Bool .
 eq isNotGateAux(emptyCircuit, 0) = false .
 eq isNotGateAux(emptyCircuit, s(i)) = false .
 eq isNotGateAux(gate circuit, s(i)) = isNotGateAux(circuit, i) .
 eq isNotGateAux(not-gate(k) circuit, 0) = true .
 eq isNotGateAux(gate circuit, 0) = false [owise] .
 
 eq isXorGate(i) = isXorGateAux(C, i) .
 
 op isXorGateAux : Circuit Nat -> Bool .
 eq isXorGateAux(emptyCircuit, 0) = false .
 eq isXorGateAux(emptyCircuit, s(i)) = false .
 eq isXorGateAux(gate circuit, s(i)) = isXorGateAux(circuit, i) .
 eq isXorGateAux(xor-gate(k, l) circuit, 0) = true .
 eq isXorGateAux(gate circuit, 0) = false [owise] .
 
 op isAndGateAux : Circuit Nat -> Bool .
 eq isAndGateAux(emptyCircuit, 0) = false .
 eq isAndGateAux(emptyCircuit, s(i)) = false .
 eq isAndGateAux(gate circuit, s(i)) = isAndGateAux(circuit, i) .
 eq isAndGateAux(and-gate(k, l) circuit, 0) = true .
 eq isAndGateAux(gate circuit, 0) = false [owise] .
 
 *** helpers
 *** get the gate at the start of the circuit, after i pops
 *** i must be at most the length of circuit
 *** the circuit must be non-empty
 
 var gate : Gate .
 
 op gateAt : Circuit Nat -> Gate .
 eq gateAt(gate circuit, 0) = gate .
 eq gateAt(gate circuit, s(n)) = gateAt(circuit, n) .
 
 *** the wires of a gate, as a list
 op wiresOf : Gate -> List{NatPairs} .
 eq wiresOf(input-gate(i, j)) = (0 ;; i) .
 eq wiresOf(not-gate(i)) = (0 ;; i) .
 eq wiresOf(and-gate(k, l)) = (0 ;; k) (1 ;; l) .
 eq wiresOf(xor-gate(k, l)) = (0 ;; k) (1 ;; l) .
 
 *** list as an unsafe map
 var natPairs : List{NatPairs} .
 op _@@_ : List{NatPairs} Nat -> Nat .
 eq ( (i ;; k) natPairs) @@ i = k .
 ceq ( (l ;; k) natPairs) @@ i = natPairs @@ i if l =/= i .
 
 *** wire 0 of the circuit C at a given gate
 op wire0 : Nat -> Nat .
 eq wire0(i) = wiresOf(gateAt(C, i)) @@ 0 .
 
 *** wire 1 of the circuit C at a given gate
 op wire1 : Nat -> Nat .
 eq wire1(i) = wiresOf(gateAt(C, i)) @@ 1 .


 *** here we connect 'wire0 with wire0 
 var nt : NatTerm .
 var f : Map{Qid, NatTerm} .
 ceq evalTerm (fun 'wire0 nt) f = wire0(evalTerm nt f) 
  if (evalTerm nt f) : Nat .
 eq evalTerm (fun 'wire0 nt) f = fun 'wire0 nt [owise] . 
 ceq evalTerm (fun 'wire1 nt) f = wire1(evalTerm nt f) 
  if (evalTerm nt f) : Nat .
 eq evalTerm (fun 'wire1 nt) f = fun 'wire1 nt [owise] . 
  
 *** here we connect 'isAliceInput with isAliceInput etc.
 var A : Set{BoolTerm} .
 eq evalBoolTerm(apply 'isOutputWire nt, A, f) = 
    isOutputWire(evalTerm nt f) . 
 eq evalBoolTerm(apply 'isAliceInput nt, A, f) = 
    isAliceInput(evalTerm nt f) . 
 eq evalBoolTerm(apply 'isBobInput nt, A, f) = 
    isBobInput(evalTerm nt f) . 
 eq evalBoolTerm(apply 'isNotGate nt, A, f) = 
    isNotGate(evalTerm nt f) . 
 eq evalBoolTerm(apply 'isXorGate nt, A, f) = 
    isXorGate(evalTerm nt f) . 
 eq evalBoolTerm(apply 'isAndGate nt, A, f) = 
    isAndGate(evalTerm nt f) .      

 *** here we record the assumptions on indices
 var q : Qid .
 
 ceq A |= fun 'wire0 nt <=T N with f = true 
   if (apply 'isAliceInput (evalTerm nt f)) in A [label aliceIndex].
 ceq A |= fun 'wire0 nt <=T M with f = true 
    if (apply 'isBobInput (evalTerm nt f)) in A .
 ceq A |= fun 'wire0 nt <=T N + M with f = true 
    if (apply 'isNotGate (evalTerm nt f)) in A [label notIndex].
 ceq A |= fun 'wire0 nt <=T N + M with f = true 
    if (apply 'isXorGate (evalTerm nt f)) in A .
 ceq A |= fun 'wire1 nt <=T N + M with f = true 
    if (apply 'isXorGate (evalTerm nt f)) in A .   
 ceq A |= fun 'wire0 nt <=T N + M with f = true 
    if (apply 'isAndGate (evalTerm nt f)) in A [label andIndex] .
 ceq A |= fun 'wire1 nt <=T N + M with f = true 
    if (apply 'isAndGate (evalTerm nt f)) in A .
 eq A |= fun 'wire0 i <=T n with f = (A |= i <=T n with f) .
 
 *** generic assumptions shared by both proofs
 op genA : -> Set{BoolTerm} .
 eq genA = ( neg (apply 'isXorGate 0), 
             neg (apply 'isAndGate 0), 
             neg (apply 'isNotGate 0),
             0 <=T K )
 .            
 
 
*** ideal protocol

 op wiresIdeal : -> Protocol .
 eq wiresIdeal =
  family 'Wires 'k (bound K) ::=
  (  *** start group
   family 'Wire 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 'k]), return 'inA0, 'inA0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isBobInput 'k) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 'k]), return 'inB0, 'inB0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isNotGate 'k) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 'k]),
     return (ap 'neg 'x),
     'x :: emptyCNameList
     )
  )
  ;;
  (when (apply 'isXorGate 'k) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'xor pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
  ;;
  (when (apply 'isAndGate 'k) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'and pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
 ) *** end group 
 .  
 
 op ideal : -> Protocol .
 eq ideal = 
   newfamily 'Wire 'k (bound K) : bool in
   ( *** start new
   (family 'In-A_id_adv 'k (bound N) ::= 
     nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA :: emptyCNameList)
   ) 
   ||
   (family 'InRcvd-B_id_adv 'k (bound M) ::= 
     nf('x : bool <- read ('In-B['k]),
        return (),
        'x :: emptyCNameList)
   )
   || 
   wiresIdeal
   || 
   (family 'Out-A 'k (bound K) ::=
      (when (apply 'isOutputWire 'k) --> 
          nf( 'wi : bool <- read ('Wire['k]), return 'wi, 'wi :: emptyCNameList)
      )
      ;;
      (otherwise --> nf('oai : bool <- read ('Out-A['k]), return 'oai, 'oai :: emptyCNameList)
      )  
    ) 
    || 
   (family 'Out-B 'k (bound K) ::=
      (when (apply 'isOutputWire 'k) --> 
         nf( 'wi : bool <- read ('Wire['k]), return 'wi, 'wi :: emptyCNameList)
      )
      ;;
      (otherwise --> nf('obi : bool <- read ('Out-B['k]), return 'obi, 'obi :: emptyCNameList)
      )  
    )
    ||
    (family 'Out-A_id_adv 'k (bound K) ::= 
        nf('oai : bool <- read ('Out-A['k]), return 'oai, 'oai :: emptyCNameList)
    )     
   ) *** end new
 . 

 *** sim
 
 op sim : -> Protocol .
 eq sim = 
     newfamily 'InputShare-A-A 'k (bound N) : bool in
     newfamily 'InputShare-A-B 'k (bound M) : bool in
     newfamily 'OTBit-A-B 'k (bound K) : bool in
     newfamily 'Share-A 'k (bound K) : bool in
     (simInitial || simInductive || simFinal)
.     

op simInitial : -> Protocol .
eq simInitial = 
 (
 family 'In-A_A_adv 'k (bound N) ::=
   nf('inA : bool <- read ('In-A_id_adv['k]) , return 'inA, 'inA :: emptyCNameList )
 )
 ||
 (
 family 'InRcvd-B_B_adv 'k (bound M) ::=
   nf('inB : unit <- read ('InRcvd-B_id_adv['k]) , return 'inB, 'inB :: emptyCNameList )
 )
 ||
 (
 family 'InputShare-A-A 'k (bound N) ::=
   nf('x : bool <- read ('In-A_id_adv['k]),
      samp ('flip < () >) ,
      'x :: emptyCNameList
     )
 )
 ||
 (
 family 'InputShare-A-B 'k (bound M) ::=
   nf('x : unit <- read ('InRcvd-B_id_adv['k]),
      samp ('flip < () >) ,
      'x :: emptyCNameList
     )
 )
 ||
 (
 family 'InputShare-A-A_A_adv 'k (bound N) ::=
   nf('inA : bool <- read ('InputShare-A-A['k]),
      return 'inA,
      'inA :: emptyCNameList
     )
 )
 ||
 (
 family 'InputShare-A-B_A_adv 'k (bound M) ::=
   nf('inB : bool <- read ('InputShare-A-B['k]),
      return 'inB,
      'inB :: emptyCNameList
     )
 )
 ||
 (
 family 'SendInputShare-B-A_A_adv 'k (bound N) ::=
   nf(('xa : bool <- read ('InputShare-A-A['k]))
      ('x : bool <- read ('In-A_id_adv['k])),
      return (ap 'xor pair('xa, 'x)),
      'xa :: 'x :: emptyCNameList
     )
 )
 ||
 (
 family 'SendInputShare-A-B_A_adv 'k (bound M) ::=
   nf('x : bool <- read ('InputShare-A-B['k]),
      return 'x,
      'x :: emptyCNameList
     )
 )
.


op simFinal : -> Protocol .
eq simFinal = 
  (family 'SendFinalShare-A_A_adv 'k (bound K) ::=
    (when (apply 'isOutputWire 'k) --> 
      nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa :: emptyCNameList)
    )
    ;;
    (otherwise --> 
      nf('sa : bool <- read ('SendFinalShare-A_A_adv['k]), return 'sa, 'sa :: emptyCNameList)
    )
  )
  ||
  (family 'SendFinalShare-B_A_adv 'k (bound K) ::=
    (when (apply 'isOutputWire 'k) --> 
      nf(('xa : bool <- read ('Share-A['k]))
         ('x : bool <- read ('Out-A_id_adv['k])), 
         return (ap 'xor pair('xa, 'x)), 
         'xa :: 'x :: emptyCNameList)
    )
    ;;
    (otherwise --> 
      nf('sa : bool <- read ('SendFinalShare-B_A_adv['k]), return 'sa, 'sa :: emptyCNameList)
    )
  )
  ||
   ( family 'Out-A_A_adv 'k (bound K) ::=
   nf('outA : bool <- read ('Out-A_id_adv['k]),
      return 'outA,
      'outA :: emptyCNameList
     )
 )

.

op simInductive : -> Protocol .
eq simInductive = 
 family 'Sim 'k (bound K) ::= ( *** start group
  (family 'OTBit-A-B 'k (bound K) ::=
    (when (apply 'isAndGate 'k)  --> 
          nf(
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
           samp ('flip < () >),
           'xa :: 'ya :: emptyCNameList
           )
    )
    ;;
    (otherwise -->  
      nf( 'otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList )
    )
  )
  ||
  (family 'Share-A 'k (bound K) ::=
        (when (apply 'isAliceInput 'k) --> 
          nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]),
             return 'is,
             'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
          nf(
           'is : bool <- read ('InputShare-A-B[fun 'wire0 'k]),
           return 'is,
           'is :: emptyCNameList
          )
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
             return 'sa,
             'sa :: emptyCNameList
            )
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
           return (ap 'xor pair('xa, 'ya)),
           'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (when (apply 'isAndGate 'k) -->
          nf( 
          ('ba : bool <- read ('OTBit-A-B['k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair(ap 'and pair('xa, 'ya) , 'ba)),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
  )
  ||
  (family 'OTBit-A-B_A_adv 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList)
        )
        ;;
        (otherwise --> 
          nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), return 'otb, 'otb :: emptyCNameList)
        )
      )
  ||
      (family 'Share-A_A_adv 'k (bound K) ::= 
        nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa :: emptyCNameList)
      ) 
  ||
      (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
           return 'ba,
           'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise --> 
          nf('otm : bool <- read ('OTMsg-A-B-0_ot_adv['k]),
             return 'otm,
             'otm :: emptyCNameList
            )
        )    
      )
      ||
      (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
          ('ba : bool <- read ('OTBit-A-B['k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, 'xa)),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise --> 
          nf('otm : bool <- read ('OTMsg-A-B-1_ot_adv['k]),
             return 'otm,
             'otm :: emptyCNameList
            )
        )
      )   
      ||
      (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
           nf(
          ('ba : bool <- read ('OTBit-A-B['k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, 'ya)),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise --> nf('otm : bool <- read ('OTMsg-A-B-2_ot_adv['k]),
             return 'otm,
             'otm :: emptyCNameList
            )
        )
      )
      ||
      (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise --> nf('otm : bool <- read ('OTMsg-A-B-3_ot_adv['k]),
             return 'otm,
             'otm :: emptyCNameList
            )
        )
      )  
      ||
     (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::=
       (when (apply 'isAndGate 'k) --> 
       nf(
       'c0 : bool <- read ('Share-A[fun 'wire0 'k]),
       return (),
       'c0 :: emptyCNameList
       )
       )
       ;;
       (otherwise --> 
         nf('otc : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]),
            return 'otc,
            'otc :: emptyCNameList
           )
       )
     )
     ||
     (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
        nf(
       'c1 : bool <- read ('Share-A[fun 'wire1 'k]),
       return (),
       'c1 :: emptyCNameList
       )
       )
       ;;
       (otherwise --> nf('otc : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]),
            return 'otc,
            'otc :: emptyCNameList
           )
       )
       
     )  
    ) *** end group     
.

*** idealPlusSim is just composition

op idealPlusSim : -> Protocol .
eq idealPlusSim = 
 newfamily 'In-A_id_adv 'k (bound N) : bool in
 newfamily 'InRcvd-B_id_adv 'k (bound M) : unit in
 newfamily 'Out-A_id_adv 'k (bound K) : bool in
 (ideal || sim) 
.
 
*** here we start spelling out real 

 op aliceInitial  : -> Protocol .
 eq aliceInitial = 
    (family 'In-A_A_adv 'k (bound N) ::= 
       nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA :: emptyCNameList)
    )
    ||
    (family 'InputShare-A-A 'k (bound N) ::= 
       nf(
       'x : bool <- read ('In-A['k]),
       samp ('flip < () >),
       'x :: emptyCNameList) 
    )
    ||
    (family 'InputShare-A-B 'k (bound M) ::= 
      nf('sis : bool <- read ('SendInputShare-A-B['k]), 
         return 'sis, 
         'sis :: emptyCNameList)
    )
    ||
    (family 'InputShare-A-A_A_adv 'k (bound N) ::= 
      nf(
       'is : bool <- read ('InputShare-A-A['k]),
       return 'is,
       'is :: emptyCNameList) 
    )
    ||
    (family 'InputShare-A-B_A_adv 'k (bound M) ::=
           nf(
       'is : bool <- read ('InputShare-A-B['k]),
       return 'is,
       'is :: emptyCNameList) 
    )
    ||
    (family 'SendInputShare-B-A 'k (bound N) ::= 
       nf(
       ('x : bool <- read ('In-A['k]))
       'xa : bool <- read ('InputShare-A-A['k]),
       return (ap 'xor pair('x, 'xa)),
       'x :: 'xa :: emptyCNameList)
    )
    ||
    (family 'SendInputShare-B-A_A_adv 'k (bound N) ::= 
       nf('sis : bool <- read ('SendInputShare-B-A['k]), 
         return 'sis, 
         'sis :: emptyCNameList)
    )
    ||
    (family 'SendInputShare-A-B_A_adv 'k (bound M) ::= 
         nf('sis : bool <- read ('SendInputShare-A-B['k]), 
         return 'sis, 
         'sis :: emptyCNameList)
    )
 .  
 
 *** InRcvd-B_B_adv is unit! the rest is bool
 op bobInitial : -> Protocol .
 eq bobInitial =
    (family 'InRcvd-B_B_adv 'k (bound M) ::= 
       nf('x : bool <- read ('In-B['k]) , return (), 'x :: emptyCNameList)
    )
    ||
    (family 'InputShare-B-A 'k (bound N) ::=
       nf('sis : bool <- read ('SendInputShare-B-A['k]), 
         return 'sis, 
         'sis :: emptyCNameList)
    )
    ||
    (family 'InputShare-B-B 'k (bound M) ::= 
      nf(
       ('x : bool <- read ('In-B['k]) )
       ('xa : bool <- read ('SendInputShare-A-B['k])),
       return (ap 'xor pair('x, 'xa)),
       'x :: 'xa :: emptyCNameList 
      )
    )
    ||
    (family 'SendInputShare-A-B 'k (bound M) ::= 
       nf('x : bool <- read ('In-B['k]),  samp ('flip < () >), 'x :: emptyCNameList)
    )
 .
 
 *** alice inductive
 
 op aliceInductive : -> Protocol .
 eq aliceInductive =
  family 'A 'k (bound K) ::= ( *** start group
      (family 'OTBit-A-B 'k (bound K) ::= 
         (when (apply 'isAndGate 'k) -->
           nf( 
            ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
            ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
           samp ('flip < () >),
           'xa :: 'ya :: emptyCNameList
           )
         )
         ;;
         (otherwise --> 
           nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList)
         )     
      )
      ||
      (family 'OTBit-A-B_A_adv 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList)
        )
        ;;
        (otherwise --> 
          nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), return 'otb, 'otb :: emptyCNameList)
        )
      )
      ||
      (family 'Share-A 'k (bound K) ::=
        (when (apply 'isAliceInput 'k) --> 
          nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
         nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
             return 'sa, 'sa :: emptyCNameList)
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('xa, 'ya)),
          'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair(ap 'and pair('xa, 'ya) , 'ba)),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
      )
      ||
      (family 'Share-A_A_adv 'k (bound K) ::= 
        nf('sa : bool <- read ('Share-A['k]), 
             return 'sa, 'sa :: emptyCNameList)
      )
      ||
      (family 'OTMsg-A-B-0 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return 'ba,
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise --> 
          nf('otm : bool <- read ('OTMsg-A-B-0['k]), 
             return 'otm, 'otm :: emptyCNameList)
        )
      )
      ||
      (family 'OTMsg-A-B-1 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, 'xa)),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise -->
         nf('otm : bool <- read ('OTMsg-A-B-1['k]), 
             return 'otm, 'otm :: emptyCNameList) 
        )
      )   
      ||
      (family 'OTMsg-A-B-2 'k (bound K) ::=
        (when (apply 'isAndGate 'k) --> 
          nf(
           ('ba : bool <- read ('OTBit-A-B['k]))
           ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
           ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, 'ya)),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise -->
         nf('otm : bool <- read ('OTMsg-A-B-2['k]), 
             return 'otm, 'otm :: emptyCNameList)
        )
      )
      ||
      (family 'OTMsg-A-B-3 'k (bound K) ::=
        (when (apply 'isAndGate 'k) -->
          nf( 
          ('ba : bool <- read ('OTBit-A-B['k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])),
          return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (otherwise --> 
          nf('otm : bool <- read ('OTMsg-A-B-3['k]), 
             return 'otm, 'otm :: emptyCNameList)
        )
      )
  ) *** end group    
 .
 
 *** bob inductive
 
 op bobInductive : -> Protocol .
 eq bobInductive = 
 family 'B 'k (bound K) ::= ( *** start group
  (family 'OTBit-B-A 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf('oto : bool <- read ('OTOut-B-A['k]), return 'oto, 'oto :: emptyCNameList)
    )
    ;;
    (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb :: emptyCNameList)
    )
  )
  ||
  (family 'OTChoice-B-A-0 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire0 'k]), return 'sb, 'sb :: emptyCNameList)
    )
    ;;
    (otherwise --> 
      nf('otc : bool <- read ('OTChoice-B-A-0['k]), return 'otc, 'otc :: emptyCNameList)
    )
  )
  ||
  (family 'OTChoice-B-A-1 'k (bound K) ::=
    (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire1 'k]), return 'sb, 'sb :: emptyCNameList)
    )
    ;;
    (otherwise -->
      nf('otc : bool <- read ('OTChoice-B-A-1['k]), return 'otc, 'otc :: emptyCNameList)
    )
  )
  ||
  (family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
          nf('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
          nf('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('xb : bool <- read ('Share-B[fun 'wire0 'k]),
             return (ap 'neg 'xb),
             'xb :: emptyCNameList)
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
          ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k])) ,
          return (ap 'xor pair('xb, 'yb)),
          'xb :: 'yb :: emptyCNameList 
          )
        )
        ;;
        (when (apply 'isAndGate 'k) --> 
          nf(
          ('bb : bool <- read ('OTBit-B-A['k]))
          ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('yb : bool <- read ('Share-B[fun 'wire1 'k])) ,
          return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))),
          'bb :: 'xb :: 'yb :: emptyCNameList
          )
        )
  )
  ) *** end group
 .
 
 *** alice final
 
 
 op aliceFinal : -> Protocol .
 eq aliceFinal =
    (family 'SendFinalShare-A 'k (bound K) ::=
       (when (apply 'isOutputWire 'k) --> 
         nf('sa : bool <- read ('Share-A['k]), 
         return 'sa,
         'sa :: emptyCNameList
         )
       ) 
       ;; 
       (otherwise --> 
         nf('sfs : bool <- read ('SendFinalShare-A['k]), 
         return 'sfs,
         'sfs :: emptyCNameList
         )
       ) 
    )
    ||
    (family 'SendFinalShare-A_A_adv 'k (bound K) ::=
      nf('sfs : bool <- read ('SendFinalShare-A['k]), 
         return 'sfs,
         'sfs :: emptyCNameList
         )
    )
    ||
    (family 'SendFinalShare-B_A_adv 'k (bound K) ::=
      nf('sfs : bool <- read ('SendFinalShare-B['k]), 
         return 'sfs,
         'sfs :: emptyCNameList
         )
    )
    ||
    (family 'Out-A 'k (bound K) ::=
      nf(
      ('xa : bool <- read ('SendFinalShare-A['k]))
      ('xb : bool <- read ('SendFinalShare-B['k])),
      return (ap 'xor pair('xa, 'xb)),
      'xa :: 'xb :: emptyCNameList
      )
    )
    ||
    (family 'Out-A_A_adv 'k (bound K) ::= 
      nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA :: emptyCNameList )
    )  
 .
 
 *** bob final
 
 op bobFinal : -> Protocol .
 eq bobFinal = 
   (family 'SendFinalShare-B 'k (bound K) ::=
       (when (apply 'isOutputWire 'k) -->
          nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb :: emptyCNameList)
       ) 
       ;; 
       (otherwise --> 
         nf('s : bool <- read ('SendFinalShare-B['k]), return 's, 's :: emptyCNameList)
       ) 
    )
    ||
    (family 'Out-B 'k (bound K) ::=
      nf(
       ('xa : bool <- read ('SendFinalShare-A['k]))
       ('xb : bool <- read ('SendFinalShare-B['k])),
       return (ap 'xor pair('xa, 'xb)),
       'xa :: 'xb :: emptyCNameList 
      )
    )
 .
 
 op 1OutOf4 : -> Protocol .
 eq 1OutOf4 = 
  family '1OutOf4OT 'k (bound K) ::= ( *** start group
    (family 'OTOut-B-A 'k (bound K) ::= 
      nf(
       ('m0 : bool <- read ( 'OTMsg-A-B-0['k]))
       ('m1 : bool <- read ( 'OTMsg-A-B-1['k]))
       ('m2 : bool <- read ( 'OTMsg-A-B-2['k]))
       ('m3 : bool <- read ( 'OTMsg-A-B-3['k]))
       ('c0 : bool <- read ( 'OTChoice-B-A-0['k]))
       ('c1 : bool <- read ( 'OTChoice-B-A-1['k])),
      if 'c0 then
        (if 'c1 then return 'm3 else return 'm2)
      else
        (if 'c1 then return 'm1 else return 'm0),
       'm0 :: 'm1 :: 'm2 :: 'm3 :: 'c0 :: 'c1 :: emptyCNameList    
      )
     )
     ||
     (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
       nf ('otm : bool <- read ('OTMsg-A-B-0['k]), return 'otm, 'otm :: emptyCNameList)
     )   
     ||
     (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
       nf ('otm : bool <- read ('OTMsg-A-B-1['k]), return 'otm, 'otm :: emptyCNameList)
     )
     ||
     (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
       nf ('otm : bool <- read ('OTMsg-A-B-2['k]), return 'otm, 'otm :: emptyCNameList)
     )
     ||
     (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
       nf ('otm : bool <- read ('OTMsg-A-B-3['k]), return 'otm, 'otm :: emptyCNameList)
     )
     ||
     (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::=
       nf(
       'c0 : bool <- read ('OTChoice-B-A-0['k]),
       return (),
       'c0 :: emptyCNameList
       )
     )
     ||
     (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::=
       nf(
       'c1 : bool <- read ('OTChoice-B-A-1['k]),
       return (),
       'c1 :: emptyCNameList)
     )
   ) *** end group  
 .
 
 *** alice
 
 op alice : -> Protocol .
 eq alice = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  ( *** start new
  aliceInitial 
  ||
  aliceInductive
  ||
  aliceFinal
  ) *** end new
 .
 
 op bob : -> Protocol .
 eq bob =
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
 ( *** start new
  bobInitial 
  ||
  bobInductive
  ||
  bobFinal
  ) *** end new
 .
 
 op real : -> Protocol .
 eq real =
  newfamily 'SendInputShare-A-B 'k (bound M) : bool in
  newfamily 'SendInputShare-B-A 'k (bound N) : bool in
  newfamily 'OTMsg-A-B-0 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-1 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-2 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-3 'k (bound K) : bool in
  newfamily 'OTOut-B-A 'k (bound K) : bool in
  newfamily 'OTChoice-B-A-0 'k (bound K) : bool in
  newfamily 'OTChoice-B-A-1 'k (bound K) : bool in
  newfamily 'SendFinalShare-A 'k (bound K) : bool in
  newfamily 'SendFinalShare-B 'k (bound K) : bool in
  (alice || bob || 1OutOf4)
 .
 
 *******************************
 *** here we restructure real
 *******************************
 
 op restrInitial : -> Protocol .
 eq restrInitial = 
  newfamily 'SendInputShare-A-B 'k (bound M) : bool in
  newfamily 'SendInputShare-B-A 'k (bound N) : bool in
   (aliceInitial || bobInitial)
 . 
 
 op restrInductive : -> Protocol .
 eq restrInductive = 
  newfamily 'OTMsg-A-B-0 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-1 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-2 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-3 'k (bound K) : bool in
  newfamily 'OTOut-B-A 'k (bound K) : bool in
  newfamily 'OTChoice-B-A-0 'k (bound K) : bool in
  newfamily 'OTChoice-B-A-1 'k (bound K) : bool in
  (aliceInductive || bobInductive || 1OutOf4)
 .
 
 op restrFinal : -> Protocol .
 eq restrFinal = 
  newfamily 'SendFinalShare-A 'k (bound K) : bool in
  newfamily 'SendFinalShare-B 'k (bound K) : bool in
   (aliceFinal || bobFinal)
 . 
 
 op restr : -> Protocol .
 eq restr = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial || restrInductive || restrFinal) 
 .
 
 *************************************************
 *** auxiliaries
 *************************************************
 
 op restrInitial1 : -> Protocol .
 eq restrInitial1 =
    newNF({'SendInputShare-A-B 'k (bound M) : bool} 
          {'SendInputShare-B-A 'k (bound N) : bool}, 
    (family 'In-A_A_adv 'k (bound N) ::= 
       nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA :: emptyCNameList)
    ) 
    || 
    (family 'InRcvd-B_B_adv 'k (bound M) ::= 
       nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
    ) 
    || 
    (family 'InputShare-A-A 'k (bound N) ::= 
       nf('x : bool <- read ('In-A['k]), samp ('flip < () >), 'x :: emptyCNameList)
    ) 
    || 
    (family 'InputShare-A-A_A_adv 'k (bound N) ::= 
      nf('is : bool <- read ('InputShare-A-A['k]), return 'is, 'is :: emptyCNameList)
    ) 
    ||
    (family 'InputShare-A-B 'k (bound M) ::= 
      nf('sis : bool <- read ('SendInputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)
    ) 
    || 
    (family 'InputShare-A-B_A_adv 'k (bound M) ::= 
      nf('is : bool <- read ('InputShare-A-B['k]), return 'is, 'is :: emptyCNameList)
    ) 
    || 
    (family 'InputShare-B-A 'k (bound N) ::= 
      nf('sis : bool <- read ('SendInputShare-B-A['k]), return 'sis, 'sis :: emptyCNameList)
    ) 
    || 
    (family 'InputShare-B-B 'k (bound M) ::= 
      nf(('x : bool <- read ('In-B['k])) 
          'xa : bool <- read ('InputShare-A-B['k]), 
          return (ap 'xor pair('x, 'xa)), 
          'x :: 'xa :: emptyCNameList)
    ) 
    || 
    (family 'SendInputShare-A-B 'k (bound M) ::= 
      nf('x : bool <- read ('In-B['k]), samp ('flip < () >), 'x :: emptyCNameList)
    ) 
    || 
    (family 'SendInputShare-A-B_A_adv 'k (bound M) ::=  
      nf('sis : bool <- read ('InputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)
    ) 
    || 
    (family 'SendInputShare-B-A 'k (bound N) ::= 
      nf(('x : bool <- read ('In-A['k])) 
          'xa : bool <- read ('InputShare-A-A['k]), 
          return (ap 'xor pair('x, 'xa)), 
          'x :: 'xa :: emptyCNameList)
    ) 
    || 
    (family 'SendInputShare-B-A_A_adv 'k (bound N) ::= 
      nf('sis : bool <- read ('InputShare-B-A['k]), return 'sis, 'sis :: emptyCNameList)
    )  , 
    'SendInputShare-A-B :: 'SendInputShare-B-A :: emptyCNameList)   
 .    

 op restrInitial2 : -> Protocol .
 eq restrInitial2 =
    (family 'In-A_A_adv 'k (bound N) ::= 
       nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA :: emptyCNameList)
    ) 
    || 
    (family 'InRcvd-B_B_adv 'k (bound M) ::= 
       nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
    ) 
    || 
    (family 'InputShare-A-A 'k (bound N) ::= 
       nf('x : bool <- read ('In-A['k]), samp ('flip < () >), 'x :: emptyCNameList)
    ) 
    || 
    (family 'InputShare-A-A_A_adv 'k (bound N) ::= 
      nf('is : bool <- read ('InputShare-A-A['k]), return 'is, 'is :: emptyCNameList)
    ) 
    ||
    (family 'InputShare-A-B 'k (bound M) ::=
      nf('x : bool <- read ('In-B['k]), samp ('flip < () >), 'x :: emptyCNameList)
    ) 
    || 
    (family 'InputShare-A-B_A_adv 'k (bound M) ::= 
      nf('is : bool <- read ('InputShare-A-B['k]), return 'is, 'is :: emptyCNameList)
    ) 
    || 
    (family 'InputShare-B-A 'k (bound N) ::= 
      nf(('x : bool <- read ('In-A['k])) 
          'xa : bool <- read ('InputShare-A-A['k]), 
          return (ap 'xor pair('x, 'xa)), 
          'x :: 'xa :: emptyCNameList
        )
    ) 
    || 
    (family 'InputShare-B-B 'k (bound M) ::= 
      nf(('x : bool <- read ('In-B['k])) 
          'xa : bool <- read ('InputShare-A-B['k]), 
          return (ap 'xor pair('x, 'xa)), 
          'x :: 'xa :: emptyCNameList)
    ) 
    || 
    (family 'SendInputShare-A-B_A_adv 'k (bound M) ::=  
      nf('sis : bool <- read ('InputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)
    ) 
    || 
    (family 'SendInputShare-B-A_A_adv 'k (bound N) ::= 
      nf('sis : bool <- read ('InputShare-B-A['k]), return 'sis, 'sis :: emptyCNameList)
    )
 .    


********************************
*** splitting restrInductive
********************************

op indAlice : -> Protocol .
eq indAlice = 
family 'indAlice 'k (bound K) ::=
 (
  (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
 ) *** end indAlice
 
.

op indBob : -> Protocol .
eq indBob = 
 family 'indBob 'k (bound K) ::=
 (
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]), 
         return 'is, 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]), 
          return 'is, 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf('xb : bool <- read ('Share-B[fun 'wire0 'k]), 
          return (ap 'neg 'xb), 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
           'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'yb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
          'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'xb :: 'yb :: emptyCNameList)
    )
  ) *** end Share-B
 ) *** end indBob
.

op indAdv : -> Protocol .
eq indAdv = 
 family 'indAdv 'k (bound K) ::=
 (
 (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire0 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv
 ) *** end indAdv
. 

op ind1OutOf4OT : -> Protocol .
eq ind1OutOf4OT = 
 family 'ind1OutOf4OT 'k (bound K) ::=
 (
  (family 'OTChoice-B-A-0 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf('sb : bool <- read ('Share-B[fun 'wire0 'k]), 
         return 'sb, 'sb :: emptyCNameList)
    ) 
    ;; 
    (otherwise --> 
      nf('otc : bool <- read ('OTChoice-B-A-0['k]), 
         return 'otc, 'otc :: emptyCNameList)
    )
  ) *** end OTChoice-0
  ||
  (family 'OTChoice-B-A-1 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return 'sb, 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otc : bool <- read ('OTChoice-B-A-1['k]), return 'otc, 'otc :: emptyCNameList)
   )
  ) *** end OTChoice-1
  ||
  (family 'OTMsg-A-B-0 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (otherwise --> 
      nf('otm : bool <- read ('OTMsg-A-B-0['k]), return 'otm, 'otm :: emptyCNameList)
    )
  ) *** end msg-0
  ||
  (family 'OTMsg-A-B-1 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otm : bool <- read ('OTMsg-A-B-1['k]), return 'otm, 'otm :: emptyCNameList)
   )
  ) *** end msg-1
  ||
  (family 'OTMsg-A-B-2 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otm : bool <- read ('OTMsg-A-B-2['k]), return 'otm, 'otm :: emptyCNameList)
   )
  ) *** end msg-2
  || 
  (family 'OTMsg-A-B-3 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
         'ba :: 'xa :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (otherwise --> 
      nf('otm : bool <- read ('OTMsg-A-B-3['k]), return 'otm, 'otm :: emptyCNameList)
    )
  ) *** end msg-3
  ||
  (family 'OTOut-B-A 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
          'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                              ap 'xor pair(ap 'and pair('xa, 'yb), 
                                           ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
    ) 
    ;;
    (otherwise --> 
       nf(('c0 : bool <- read ('OTChoice-B-A-0['k])) 
          ('c1 : bool <- read ('OTChoice-B-A-1['k])) 
          ('m0 : bool <- read ('OTMsg-A-B-0['k])) 
          ('m1 : bool <- read ('OTMsg-A-B-1['k])) 
          ('m2 : bool <- read ('OTMsg-A-B-2['k])) 
           'm3 : bool <- read ('OTMsg-A-B-3['k]), 
           if 'c0 then
               if 'c1 then return 'm3 
                      else return 'm2 
                  else 
               if 'c1 then return 'm1 
                      else return 'm0, 
          'm0 :: 'm1 :: 'm2 :: 'm3 :: 'c0 :: 'c1 :: emptyCNameList)
    )
  ) *** end out
 ) *** end 1OutOf4OT
.

op restrIndSplit : -> Protocol .
eq restrIndSplit =
  newfamily 'OTMsg-A-B-0 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-1 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-2 'k (bound K) : bool in
  newfamily 'OTMsg-A-B-3 'k (bound K) : bool in
  newfamily 'OTOut-B-A 'k (bound K) : bool in
  newfamily 'OTChoice-B-A-0 'k (bound K) : bool in
  newfamily 'OTChoice-B-A-1 'k (bound K) : bool in
    (indAlice || indBob || indAdv || ind1OutOf4OT)
.

op restrIndSplitSym : -> Protocol .
eq restrIndSplitSym =
  (indAlice || indBob || indAdv )
.

op restrIndSplitSymNew : -> Protocol .
eq restrIndSplitSymNew = 
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  restrIndSplitSym
  ||
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-B-A 'k (bound K) ::= 
    nf('bb : bool <- read ('OTBit-B-A['k]), return (), 'bb :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'ShareOK-B 'k (bound K) ::= 
    nf('xb : bool <- read ('Share-B['k]), return (), 'xb :: emptyCNameList)
  )
  )
.  

op restrIndSplitSymNew1 : -> Protocol .
eq restrIndSplitSymNew1 = 
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  indAlice 
  ||
  indBob 
  ||
  indAdv1
  ||
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-B-A 'k (bound K) ::= 
    nf('bb : bool <- read ('OTBit-B-A['k]), return (), 'bb :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'ShareOK-B 'k (bound K) ::= 
    nf('xb : bool <- read ('Share-B['k]), return (), 'xb :: emptyCNameList)
  )

  )
.  

*** more sym protocols

*** indAdv1

op indAdv1 : -> Protocol .
eq indAdv1 = 
(
  family 'indAdv 'k (bound K) ::=
 (
 (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
  )
  )
  .

*** indAdv2 
op indAdv2 : -> Protocol .
eq indAdv2 = 
(
  family 'indAdv 'k (bound K) ::=
 (
 (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
  )
  )
  .

*** indBob1

op indBob1 : -> Protocol .
eq indBob1 = 
 family 'indBob 'k (bound K) ::=
 (
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    )
  ) *** end Share-B
 ) *** end indBob1
.

*** indBob2
 
op indBob2 : -> Protocol .
eq indBob2 = 
 family 'indBob 'k (bound K) ::=
 (
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
 ) *** end indBob2
.
 
*** indBob3
 
op indBob3 : -> Protocol .
eq indBob3 = 
 family 'indBob 'k (bound K) ::=
 (
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    nf(('xa : bool <- read ('Share-A['k])) 
       'x : bool <- read ('Wire['k]), 
      return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
  ) *** end Share-B
 ) *** end indBob3
.
 
 
*** new2

op new2 : -> Protocol .
eq new2 =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-B-A 'k (bound K) ::= 
    nf('bb : bool <- read ('OTBit-B-A['k]), return (), 'bb :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'ShareOK-B 'k (bound K) ::= 
    nf('xb : bool <- read ('Share-B['k]), return (), 'xb :: emptyCNameList)
  ) 
  ) *** end new
.

*** new3

 op bobOKInt : -> Protocol .
 eq bobOKInt =  
  family 'BobOK 'k (bound K) ::=
   ( *** start bobok
   (family 'OTBitOK-B-A 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot :: emptyCNameList)
     )
   )
   ||
   (family 'ShareOK-B 'k (bound K) ::=
     nf('xb : bool <- read ('Share-B['k]), return (), 'xb :: emptyCNameList)
   )
   
   ) *** end bobokint
 . 

 op bobOK : -> Protocol .
 eq bobOK =  
  family 'BobOK 'k (bound K) ::=
   ( *** start bobok
   (family 'OTBitOK-B-A 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot :: emptyCNameList)
     )
   )
   ||
   (family 'ShareOK-B 'k (bound K) ::=
     (when (apply 'isAliceInput 'k) --> 
          nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
          nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]),
             return 'xb,
             'xb :: emptyCNameList)
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
          return (),
          'xb :: 'yb :: emptyCNameList 
          )
        )
        ;;
        (when (apply 'isAndGate 'k) --> 
          nf(
          ('bb : unit <- read ('OTBitOK-B-A['k]))
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
          return (),
          'bb :: 'xb :: 'yb :: emptyCNameList
          )
        )
   )
   
   ) *** end bobok
 . 
 
 op bobOKBase : -> Protocol .
 eq bobOKBase =  
  family 'BobOK 'k (bound K) ::=
   ( *** start bobok
   (family 'OTBitOK-B-A 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot :: emptyCNameList)
     )
   )
   ||
   ('ShareOK-B[0] ::=
      (when (apply 'isAliceInput 0) --> 
          nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 0]), 
             return 'is, 'is :: emptyCNameList)
       )
        ;;
        (when (apply 'isBobInput 0) --> 
          nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 0]), 
             return 'is, 'is :: emptyCNameList)
        )      
   )
   
   ) *** end bobokbase
 . 
 
 op bobOKInd : -> Protocol .
 eq bobOKInd =  
  family 'BobOK 'k (bound K) ::=
   ( *** start bobok
   (family 'OTBitOK-B-A 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot :: emptyCNameList)
     )
   )
   ||
   ('ShareOK-B['B ++ 1] ::=
      (when (apply 'isAliceInput ('B ++ 1)) --> 
          nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput ('B ++ 1)) --> 
          nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isNotGate ('B ++ 1)) --> 
          nf('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)]),
             return 'xb,
             'xb :: emptyCNameList)
        )
        ;;
        (when (apply 'isXorGate ('B ++ 1)) --> 
          nf(
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])) ,
          return (),
          'xb :: 'yb :: emptyCNameList 
          )
        )
        ;;
        (when (apply 'isAndGate ('B ++ 1)) --> 
          nf(
          ('bb : unit <- read ('OTBitOK-B-A[('B ++ 1)]))
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)]))
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])) ,
          return (),
          'bb :: 'xb :: 'yb :: emptyCNameList
          )
        )   
   )
   ||
   (family 'ShareOK-B 'k (bound 'B) ::= 
      nf('xb : bool <- read ('Share-B['k]), 
     return (), 'xb :: emptyCNameList)
   )
   
   ) *** end bobokind
 .
 
 op new3Int : -> Protocol .
 eq new3Int =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  bobOKInt
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
  ) *** end new
.
 
 op new3 : -> Protocol .
 eq new3 =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
  ) *** end new
.

op bobOKOT : -> Protocol .
eq bobOKOT =  
   ('OTBitOK-B-A[ 'B ++ 1 ] ::= 
      nf('bb : bool <- read ('OTBit-B-A['B ++ 1]), 
        return (),
        'bb :: emptyCNameList)
   )
   ||
   ('ShareOK-B[ 'B ++ 1] ::= 
              (when (apply 'isAliceInput ('B ++ 1)) --> 
          nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput ('B ++ 1)) --> 
          nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isNotGate ('B ++ 1)) --> 
          nf('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)]),
             return 'xb,
             'xb :: emptyCNameList)
        )
        ;;
        (when (apply 'isXorGate ('B ++ 1)) --> 
          nf(
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])) ,
          return (),
          'xb :: 'yb :: emptyCNameList 
          )
        )
        ;;
        (when (apply 'isAndGate ('B ++ 1)) --> 
          nf(
          ('bb : unit <- read ('OTBitOK-B-A['B ++ 1]))
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)]))
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])) ,
          return (),
          'bb :: 'xb :: 'yb :: emptyCNameList
          )
        )
   )
   ||
  ***  start group
  *** family 'BobOK 'k (bound 'B) ::= 
   (
   (family 'OTBitOK-B-A 'k (bound 'B) ::= 
     nf('bb : bool <- read ('OTBit-B-A['k]), 
        return (),
        'bb :: emptyCNameList)
   )
   ||
   (family 'ShareOK-B 'k (bound 'B) ::=
     nf('xb : bool <- read ('Share-B['k]), 
     return (), 'xb :: emptyCNameList)
   )
   )
  *** ) *** end group
 .

op bobOKOT3IndStart : -> Protocol .
eq bobOKOT3IndStart  =  
   ('OTBitOK-B-A[ 'B ++ 1 ] ::= 
      (when (apply 'isAndGate ('B ++ 1)) --> 
      nf(('ba : unit <- read ('OTBitOK-A-B['B ++ 1])) 
         ('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
         ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)]))
         ('ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])) 
         ('yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])), 
         return (), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
    ) 
    ;; 
    (otherwise --> 
      nf('ot : unit <- read ('OTBitOK-B-A['B ++ 1]), 
         return 'ot, 'ot :: emptyCNameList)
    )
   )
   ||
   ('ShareOK-B[ 'B ++ 1] ::= 
              (when (apply 'isAliceInput ('B ++ 1)) --> 
          nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput ('B ++ 1)) --> 
          nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isNotGate ('B ++ 1)) --> 
          nf('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)]),
             return 'xb,
             'xb :: emptyCNameList)
        )
        ;;
        (when (apply 'isXorGate ('B ++ 1)) --> 
          nf(
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])) ,
          return (),
          'xb :: 'yb :: emptyCNameList 
          )
        )
        ;;
        (when (apply 'isAndGate ('B ++ 1)) --> 
          nf(
          ('bb : unit <- read ('OTBitOK-B-A['B ++ 1]))
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)]))
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])) ,
          return (),
          'bb :: 'xb :: 'yb :: emptyCNameList
          )
        )
   )
   ||
   ( *** start group
   family 'BobOK 'k (bound 'B) ::= 
   (
   (family 'OTBitOK-B-A 'k (bound 'B) ::= 
     nf('bb : bool <- read ('OTBit-B-A['k]), 
        return (),
        'bb :: emptyCNameList)
   )
   ||
   (family 'ShareOK-B 'k (bound 'B) ::=
     nf('xb : bool <- read ('Share-B['k]), 
     return (), 'xb :: emptyCNameList)
   )
   )
   ) *** end group

 .

*** induction proof starts with this term
op new3OTIndStart : -> Protocol .
eq new3OTIndStart = 
  bobOKOT3IndStart
  ||
  *** indAlice
  (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
   ) *** end share-A
 || 
  *** indBob1
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    )
  ) *** end Share-B
 ||
  *** indAdv1
  (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv ; end of indAdv1, the rest are the internals
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
.

op bobOKOT3IndEnd : -> Protocol .
eq bobOKOT3IndEnd  =  
   ('OTBitOK-B-A[ 'B ++ 1 ] ::= 
      nf('bb : bool <- read ('OTBit-B-A['B ++ 1]), 
        return (),
        'bb :: emptyCNameList)
   )
   ||
   ('ShareOK-B[ 'B ++ 1] ::= 
             nf('xb : bool <- read ('Share-B['B ++ 1]), 
     return (), 'xb :: emptyCNameList)
   )
   ||
   ( *** start group
   family 'BobOK 'k (bound 'B) ::= 
   (
   (family 'OTBitOK-B-A 'k (bound 'B) ::= 
     nf('bb : bool <- read ('OTBit-B-A['k]), 
        return (),
        'bb :: emptyCNameList)
   )
   ||
   (family 'ShareOK-B 'k (bound 'B) ::=
     nf('xb : bool <- read ('Share-B['k]), 
     return (), 'xb :: emptyCNameList)
   )
   )
   ) *** end group

 .


*** induction proof ends with this term
op new3OTIndEnd : -> Protocol .
eq new3OTIndEnd = 
  bobOKOT3IndEnd
  ||
  *** indAlice
  (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
   ) *** end share-A
 || 
  *** indBob1
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    )
  ) *** end Share-B
 ||
  *** indAdv1
  (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv ; end of indAdv1, the rest are the internals
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
.


*** intermediate induction protocol

op new3OT : -> Protocol .
eq new3OT = 
  bobOKOT
  ||
  *** indAlice
  (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
   ) *** end share-A
 || 
  *** indBob1
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    )
  ) *** end Share-B
 ||
  *** indAdv1
  (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv ; end of indAdv1, the rest are the internals
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
.

op bobOKOTInd : -> Protocol .
eq bobOKOTInd =  
   ('OTBitOK-B-A[ 'B ++ 1 ] ::= 
      nf('bb : bool <- read ('OTBit-B-A['B ++ 1]), 
        return (),
        'bb :: emptyCNameList)
   )
   ||
   ('ShareOK-B[ 'B ++ 1] ::= 
       nf('xb : bool <- read ('Share-B['B ++ 1]), 
          return (), 'xb :: emptyCNameList)       
   )
   ||
   (family 'OTBitOK-B-A 'k (bound 'B) ::= 
     nf('bb : bool <- read ('OTBit-B-A['k]), 
        return (),
        'bb :: emptyCNameList)
   )
   ||
   (family 'ShareOK-B 'k (bound 'B) ::=
     nf('xb : bool <- read ('Share-B['k]), 
     return (), 'xb :: emptyCNameList)
   )

 .


op new3OTInd : -> Protocol .
eq new3OTInd = 
  bobOKOTInd
  ||
  *** indAlice
  (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
   ) *** end share-A
 || 
  *** indBob1
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    )
  ) *** end Share-B
 ||
  *** indAdv1
  (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv ; end of indAdv1, the rest are the internals
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
.


op new3Base : -> Protocol .
eq new3Base =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  new 'ShareOK-B[0] : unit in
  (
  bobOKBase
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
  ) *** end new
.

op new3Ind : -> Protocol .
 eq new3Ind =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  bobOKInd
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
  ) *** end new
.

op new3Base0 : -> Protocol .
 eq new3Base0 =
  ('ShareOK-B[0] ::= 
  nf('xb : bool <- read ('Share-B[0]), 
     return (), 'xb :: emptyCNameList)
)
||
(family 'OTBitOK-B-A 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot :: emptyCNameList)
     )
   )
||
(family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
 ||
  (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
.  

op new3Ind0 : -> Protocol .
 eq new3Ind0 =
  ('ShareOK-B['B ++ 1] ::= 
  nf('xb : bool <- read ('Share-B['B ++ 1]), 
     return (), 'xb :: emptyCNameList)
)
||
(family 'ShareOK-B 'k (bound 'B) ::=
  nf('xb : bool <- read ('Share-B['k]), 
     return (), 'xb :: emptyCNameList)
)
||
(family 'OTBitOK-B-A 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot :: emptyCNameList)
     )
   )
||
(family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf('xb : bool <- read ('InputShare-B-A['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf('xb : bool <- read ('InputShare-B-B['k]), return (), 'xb :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
 ||
  (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
.  

 
*** new4 

 op new4 : -> Protocol .
 eq new4 =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ||
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
  ) *** end new
.

*** new4Int

 op new4Int : -> Protocol .
 eq new4Int =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  aliceOKInt 
  ||
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ) *** end new
.

op aliceOKInt : -> Protocol .
 eq aliceOKInt = 
  family 'AliceOK 'k (bound K) ::=
   ( *** start aliceok
   (family 'OTBitOK-A-B 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( 
           ('ak : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('al : unit <- read ('ShareOK-A[fun 'wire1 'k])),
           return (),
           'ak :: 'al :: emptyCNameList
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-A-B['k]), 
                      return 'ot,
                      'ot :: emptyCNameList)
     )
   )
   ||
   (family 'ShareOK-A 'k (bound K) ::=
     nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
   )
   ) *** end aliceok
 .
*** new5base

op new5base : -> Protocol .
eq new5base =

 ('ShareOK-A[0] ::= 
   nf('xa : bool <- read ('Share-A[0]), 
      return (), 'xa :: emptyCNameList
     )
 )
 ||
  (family 'InOK-A 'k (bound N) ::= 
   nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
 ) 
 || 
 (family 'InOK-B 'k (bound M) ::= 
   nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-A-A 'k (bound N) ::= 
   nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-A-B 'k (bound M) ::= 
   nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-B-A 'k (bound N) ::= 
   nf(('x : unit <- read ('InOK-A['k])) 
       'xa : unit <- read ('InputShareOK-A-A['k]), 
       return (), 
       'x :: 'xa :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-B-B 'k (bound M) ::= 
   nf(('x : unit <- read ('InOK-B['k])) 
       'xa : unit <- read ('InputShareOK-A-B['k]), 
       return (), 'x :: 'xa :: emptyCNameList)
 ) 
 || 
 (family 'OTBit-A-B 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-A-B['k]),
         return 'otb, 'otb :: emptyCNameList))
) 
|| 
(family 'OTBit-A-B_A_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf('otb : bool <- read ('OTBit-A-B['k]), 
       return 'otb, 'otb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
       return 'otb, 'otb :: emptyCNameList))
) 
|| 
(family 'OTBit-B-A 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                               ap 'and pair('xb, 'ya)))),
        'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('otb : bool <- read ('OTBit-B-A['k]), 
       return 'otb, 'otb :: emptyCNameList)
  )
) 
|| 
(family 'OTBitOK-A-B 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
        'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
        return (), 'ak :: 'al :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot :: emptyCNameList)
  )
) 
|| 
(family 'OTBitOK-B-A 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : unit <- read ('OTBitOK-A-B['k])) 
       ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
       ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('ot : unit <- read ('OTBitOK-B-A['k]), 
       return 'ot, 'ot :: emptyCNameList)
  )
) 
|| 
(family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
        return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
)    
|| 
(family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
       return (), 'sb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList))
) 
|| 
(family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList))
) 
|| 
(family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'Share-A 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
       return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
       return 'sa, 'sa :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList)
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  )
) 
|| 
(family 'Share-A_A_adv 'k (bound K) ::= 
  nf('sa : bool <- read ('Share-A['k]), 
     return 'sa, 'sa :: emptyCNameList)
) 
|| 
(family 'Share-B 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
        return 'is, 'x :: 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
    nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
        return 'is, 'x :: 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'xb : bool <- read ('Share-B[fun 'wire0 'k]),
        return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('xb, 'yb)), 
        'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
  ) 
)
|| 
(family 'ShareOK-B 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
       return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
       return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
       return 'xb, 'xb :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'xb :: 'yb :: emptyCNameList)
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('bb : unit <- read ('OTBitOK-B-A['k])) 
       ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'bb :: 'xb :: 'yb :: emptyCNameList) 
  )
)
.

*** new5step

op new5step : -> Protocol .
eq new5step =
 
 ('ShareOK-A['B ++ 1] ::= 
   nf('xa : bool <- read ('Share-A['B ++ 1]), 
      return (), 'xa :: emptyCNameList
     )
 )
 ||
 (family 'ShareOK-A 'k (bound 'B) ::=
   nf('xa : bool <- read ('Share-A['k]),
      return (), 'xa :: emptyCNameList
     )
 ) 
 ||
  (family 'InOK-A 'k (bound N) ::= 
   nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
 ) 
 || 
 (family 'InOK-B 'k (bound M) ::= 
   nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-A-A 'k (bound N) ::= 
   nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-A-B 'k (bound M) ::= 
   nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-B-A 'k (bound N) ::= 
   nf(('x : unit <- read ('InOK-A['k])) 
       'xa : unit <- read ('InputShareOK-A-A['k]), 
       return (), 
       'x :: 'xa :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-B-B 'k (bound M) ::= 
   nf(('x : unit <- read ('InOK-B['k])) 
       'xa : unit <- read ('InputShareOK-A-B['k]), 
       return (), 'x :: 'xa :: emptyCNameList)
 ) 
 || 
 (family 'OTBit-A-B 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-A-B['k]),
         return 'otb, 'otb :: emptyCNameList))
) 
|| 
(family 'OTBit-A-B_A_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf('otb : bool <- read ('OTBit-A-B['k]), 
       return 'otb, 'otb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
       return 'otb, 'otb :: emptyCNameList))
) 
|| 
(family 'OTBit-B-A 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                               ap 'and pair('xb, 'ya)))),
        'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('otb : bool <- read ('OTBit-B-A['k]), 
       return 'otb, 'otb :: emptyCNameList)
  )
) 
|| 
(family 'OTBitOK-A-B 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
        'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
        return (), 'ak :: 'al :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot :: emptyCNameList)
  )
) 
|| 
(family 'OTBitOK-B-A 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : unit <- read ('OTBitOK-A-B['k])) 
       ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
       ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('ot : unit <- read ('OTBitOK-B-A['k]), 
       return 'ot, 'ot :: emptyCNameList)
  )
) 
|| 
(family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
        return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
)    
|| 
(family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
       return (), 'sb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList))
) 
|| 
(family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList))
) 
|| 
(family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'Share-A 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
       return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
       return 'sa, 'sa :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList)
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  )
) 
|| 
(family 'Share-A_A_adv 'k (bound K) ::= 
  nf('sa : bool <- read ('Share-A['k]), 
     return 'sa, 'sa :: emptyCNameList)
) 
|| 
(family 'Share-B 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
        return 'is, 'x :: 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
    nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
        return 'is, 'x :: 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'xb : bool <- read ('Share-B[fun 'wire0 'k]),
        return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('xb, 'yb)), 
        'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
  ) 
)
|| 
(family 'ShareOK-B 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
       return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
       return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
       return 'xb, 'xb :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'xb :: 'yb :: emptyCNameList)
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('bb : unit <- read ('OTBitOK-B-A['k])) 
       ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'bb :: 'xb :: 'yb :: emptyCNameList) 
  )
)
.

*** new4Intstep

op new4Intstep : -> Protocol .
eq new4Intstep =
 
 ('ShareOK-A['B ++ 1] ::= 
     nf(('ba : unit <- read ('OTBitOK-A-B['B ++ 1 ])) 
       ('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
        'ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
        return (), 'ba :: 'xa :: 'ya :: emptyCNameList)
 )
 ||
 (family 'ShareOK-A 'k (bound 'B) ::=
   nf('xa : bool <- read ('Share-A['k]),
      return (), 'xa :: emptyCNameList
     )
 ) 
 ||
  (family 'InOK-A 'k (bound N) ::= 
   nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
 ) 
 || 
 (family 'InOK-B 'k (bound M) ::= 
   nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-A-A 'k (bound N) ::= 
   nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-A-B 'k (bound M) ::= 
   nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-B-A 'k (bound N) ::= 
   nf(('x : unit <- read ('InOK-A['k])) 
       'xa : unit <- read ('InputShareOK-A-A['k]), 
       return (), 
       'x :: 'xa :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-B-B 'k (bound M) ::= 
   nf(('x : unit <- read ('InOK-B['k])) 
       'xa : unit <- read ('InputShareOK-A-B['k]), 
       return (), 'x :: 'xa :: emptyCNameList)
 ) 
 || 
 (family 'OTBit-A-B 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-A-B['k]),
         return 'otb, 'otb :: emptyCNameList))
) 
|| 
(family 'OTBit-A-B_A_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf('otb : bool <- read ('OTBit-A-B['k]), 
       return 'otb, 'otb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
       return 'otb, 'otb :: emptyCNameList))
) 
|| 
(family 'OTBit-B-A 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                               ap 'and pair('xb, 'ya)))),
        'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('otb : bool <- read ('OTBit-B-A['k]), 
       return 'otb, 'otb :: emptyCNameList)
  )
) 
|| 
(family 'OTBitOK-A-B 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
        'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
        return (), 'ak :: 'al :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot :: emptyCNameList)
  )
) 
|| 
(family 'OTBitOK-B-A 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : unit <- read ('OTBitOK-A-B['k])) 
       ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
       ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('ot : unit <- read ('OTBitOK-B-A['k]), 
       return 'ot, 'ot :: emptyCNameList)
  )
) 
|| 
(family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
        return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
)    
|| 
(family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
       return (), 'sb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList))
) 
|| 
(family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList))
) 
|| 
(family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'Share-A 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
       return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
       return 'sa, 'sa :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList)
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  )
) 
|| 
(family 'Share-A_A_adv 'k (bound K) ::= 
  nf('sa : bool <- read ('Share-A['k]), 
     return 'sa, 'sa :: emptyCNameList)
) 
|| 
(family 'Share-B 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
        return 'is, 'x :: 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
    nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
        return 'is, 'x :: 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'xb : bool <- read ('Share-B[fun 'wire0 'k]),
        return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('xb, 'yb)), 
        'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
  ) 
)
|| 
(family 'ShareOK-B 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
       return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
       return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
       return 'xb, 'xb :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'xb :: 'yb :: emptyCNameList)
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('bb : unit <- read ('OTBitOK-B-A['k])) 
       ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'bb :: 'xb :: 'yb :: emptyCNameList) 
  )
)
.

*** new5

 op new5 : -> Protocol .
 eq new5 =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  aliceOK
  ||
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ) *** end new
.

*** for the induction proof
*** new5IndInt

op aliceOKIndInt : -> Protocol .
eq aliceOKIndInt = 
  ('OTBitOK-A-B['B ++ 1] ::=
    nf('ba : bool <- read ('OTBit-A-B['B ++ 1]), 
        return (), 'ba :: emptyCNameList)
  )
  ||
  ('ShareOK-A['B ++ 1] ::= 
        (when (apply 'isAliceInput ('B ++ 1)) --> 
          nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 ('B ++ 1)]),
             return 'is,
             'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput ('B ++ 1)) --> 
          nf(
           'is : unit <- read ('InputShareOK-A-B[fun 'wire0 ('B ++ 1)]),
           return 'is,
           'is :: emptyCNameList
          )
        )
        ;;
        (when (apply 'isNotGate ('B ++ 1)) --> 
          nf('sa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]),
             return 'sa,
             'sa :: emptyCNameList
            )
        )
        ;;
        (when (apply 'isXorGate ('B ++ 1)) --> 
          nf(
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])),
           return (),
           'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (when (apply 'isAndGate ('B ++ 1)) -->
          nf( 
          ('ba : unit <- read ('OTBitOK-A-B['B ++ 1]))
          ('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]))
          ('ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])),
          return (),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
  )
  ||
  ( *** group start
  family 'AliceOK 'k (bound 'B) ::=
   ( *** start aliceok
   (family 'OTBitOK-A-B 'k (bound 'B) ::= 
     nf('ba : bool <- read ('OTBit-A-B['k]), 
        return (), 'ba :: emptyCNameList)
   )
   ||
   (family 'ShareOK-A 'k (bound 'B) ::=
     nf('xa : bool <- read ('Share-A['k]), 
        return (), 'xa :: emptyCNameList)
   )
   ) *** end aliceok
  ) *** group end 
 .

 op new5IndInt : -> Protocol .
 eq new5IndInt =
  (
  aliceOKIndInt
  ||
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ) *** end new
.

*** new5IndStart

op aliceOKIndStart : -> Protocol .
eq aliceOKIndStart = 
  ('OTBitOK-A-B['B ++ 1] ::=
    (when (apply 'isAndGate ('B ++ 1)) -->
       nf( 
           ('ak : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]))
           ('al : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])),
           return (),
           'ak :: 'al :: emptyCNameList
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-A-B['B ++ 1]), 
                      return 'ot,
                      'ot :: emptyCNameList)
     )
  )
  ||
  ('ShareOK-A['B ++ 1] ::= 
        (when (apply 'isAliceInput ('B ++ 1)) --> 
          nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 ('B ++ 1)]),
             return 'is,
             'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput ('B ++ 1)) --> 
          nf(
           'is : unit <- read ('InputShareOK-A-B[fun 'wire0 ('B ++ 1)]),
           return 'is,
           'is :: emptyCNameList
          )
        )
        ;;
        (when (apply 'isNotGate ('B ++ 1)) --> 
          nf('sa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]),
             return 'sa,
             'sa :: emptyCNameList
            )
        )
        ;;
        (when (apply 'isXorGate ('B ++ 1)) --> 
          nf(
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])),
           return (),
           'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (when (apply 'isAndGate ('B ++ 1)) -->
          nf( 
          ('ba : unit <- read ('OTBitOK-A-B['B ++ 1]))
          ('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]))
          ('ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])),
          return (),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
  )
  ||
  ( *** group start
  family 'AliceOK 'k (bound 'B) ::=
   ( *** start aliceok
   (family 'OTBitOK-A-B 'k (bound 'B) ::= 
     nf('ba : bool <- read ('OTBit-A-B['k]), 
        return (), 'ba :: emptyCNameList)
   )
   ||
   (family 'ShareOK-A 'k (bound 'B) ::=
     nf('xa : bool <- read ('Share-A['k]), 
        return (), 'xa :: emptyCNameList)
   )
   ) *** end aliceok
  ) *** group end 
 .

 op new5IndStart : -> Protocol .
 eq new5IndStart =
  (
  aliceOKIndStart
  ||
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ) *** end new
.


*** new5IndEnd
op aliceOKIndEnd : -> Protocol .
eq aliceOKIndEnd = 
  ('OTBitOK-A-B['B ++ 1] ::=
     nf('ba : bool <- read ('OTBit-A-B['B ++ 1]), 
        return (), 'ba :: emptyCNameList)
  )
  ||
  ('ShareOK-A['B ++ 1] ::= 
     nf('xa : bool <- read ('Share-A['B ++ 1]), 
        return (), 'xa :: emptyCNameList)  
  )
  ||
  ( *** group start
  family 'AliceOK 'k (bound 'B) ::=
   ( *** start aliceok
   (family 'OTBitOK-A-B 'k (bound 'B) ::= 
     nf('ba : bool <- read ('OTBit-A-B['k]), 
        return (), 'ba :: emptyCNameList)
   )
   ||
   (family 'ShareOK-A 'k (bound 'B) ::=
     nf('xa : bool <- read ('Share-A['k]), 
        return (), 'xa :: emptyCNameList)
   )
   ) *** end aliceok
  ) *** group end 
 .

 op new5IndEnd : -> Protocol .
 eq new5IndEnd =
  (
  aliceOKIndEnd
  ||
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ) *** end new
.

*** new5Ind0
op aliceOKInd0 : -> Protocol .
eq aliceOKInd0 = 
  ('OTBitOK-A-B['B ++ 1] ::=
     nf('ba : bool <- read ('OTBit-A-B['B ++ 1]), 
        return (), 'ba :: emptyCNameList)
  )
  ||
  ('ShareOK-A['B ++ 1] ::= 
     nf('xa : bool <- read ('Share-A['B ++ 1]), 
        return (), 'xa :: emptyCNameList)  
  )
  ||
   (family 'OTBitOK-A-B 'k (bound 'B) ::= 
     nf('ba : bool <- read ('OTBit-A-B['k]), 
        return (), 'ba :: emptyCNameList)
   )
   ||
   (family 'ShareOK-A 'k (bound 'B) ::=
     nf('xa : bool <- read ('Share-A['k]), 
        return (), 'xa :: emptyCNameList)
   )
 .

 op new5Ind0 : -> Protocol .
 eq new5Ind0 =
 ***(
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
 ) 
  (
  aliceOKInd0
  ||
  *** bobOK
  (family 'OTBitOK-B-A 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot :: emptyCNameList)
     )
   )
   ||
   (family 'ShareOK-B 'k (bound K) ::=
     (when (apply 'isAliceInput 'k) --> 
          nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
          nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]),
             return 'xb,
             'xb :: emptyCNameList)
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
          return (),
          'xb :: 'yb :: emptyCNameList 
          )
        )
        ;;
        (when (apply 'isAndGate 'k) --> 
          nf(
          ('bb : unit <- read ('OTBitOK-B-A['k]))
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
          return (),
          'bb :: 'xb :: 'yb :: emptyCNameList
          )
        )
   )
  ||
  *** indAlice
  (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
 || 
 *** indBob1
 (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    )
  ) *** end Share-B
 ||
 *** indAdv1
 (
 (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
  )
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ) *** end new
.


 
*** new6

 op new6 : -> Protocol .
 eq new6 =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  aliceOK
  ||
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('x : unit <- read ('InOK-A['k]), return 'x, 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('x : unit <- read ('InOK-B['k]), return 'x, 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( ( 'x : unit <- read ('InOK-A['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf( ( 'x : unit <- read ('InOK-B['k]) ) 
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return (), 
        'x :: 'xa :: emptyCNameList)
  )
  ) *** end new
. 

*** new7

 op new7 : -> Protocol .
 eq new7 =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  aliceOK
  ||
  bobOK
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('x : unit <- read ('InOK-A['k]), return 'x, 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('x : unit <- read ('InOK-B['k]), return 'x, 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 

*** new7indstart

op bobOK7IndStart : -> Protocol .
eq bobOK7IndStart =  
   ('OTBitOK-B-A[ 'B ++ 1 ] ::= 
      (when (apply 'isAndGate ('B ++ 1)) --> 
      nf(('ba : unit <- read ('OTBitOK-A-B['B ++ 1])) 
         ('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
         ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
         ('ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])) 
          'yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)]), 
         return (), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
      ) 
      ;; 
      (otherwise --> 
        nf('ot : unit <- read ('OTBitOK-B-A[('B ++ 1)]), 
           return 'ot, 'ot :: emptyCNameList)
      )
   )
   ||
   ('ShareOK-B[ 'B ++ 1] ::= 
        (when (apply 'isAliceInput ('B ++ 1)) --> 
          nf('is : unit <- read ('InputShareOK-B-A[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput ('B ++ 1)) --> 
          nf('is : unit <- read ('InputShareOK-B-B[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isNotGate ('B ++ 1)) --> 
          nf('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)]),
             return 'xb,
             'xb :: emptyCNameList)
        )
        ;;
        (when (apply 'isXorGate ('B ++ 1)) --> 
          nf(
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])) ,
          return (),
          'xb :: 'yb :: emptyCNameList 
          )
        )
        ;;
        (when (apply 'isAndGate ('B ++ 1)) --> 
          nf(
          ('bb : unit <- read ('OTBitOK-B-A['B ++ 1]))
          ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)]))
          ('yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])) ,
          return (),
          'bb :: 'xb :: 'yb :: emptyCNameList
          )
        )
   )
   ||
  ***  start group
  (family 'BobOK 'k (bound 'B) ::= 
   (
   (family 'OTBitOK-B-A 'k (bound 'B) ::= 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), 
        return 'ot, 'ot :: emptyCNameList)
   )
   ||
   (family 'ShareOK-B 'k (bound 'B) ::=
     nf('sa : unit <- read ('ShareOK-A['k]), 
        return 'sa, 'sa :: emptyCNameList)
   )
   )
  ) *** end group
 .

op new7IndStart : -> Protocol .
eq new7IndStart =
  (
  aliceOK
  ||
  bobOK7IndStart
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('x : unit <- read ('InOK-A['k]), return 'x, 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('x : unit <- read ('InOK-B['k]), return 'x, 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 

*** new7indend

op bobOK7IndEnd : -> Protocol .
eq bobOK7IndEnd =  
   ('OTBitOK-B-A[ 'B ++ 1 ] ::= 
      nf('ot : unit <- read ('OTBitOK-A-B['B ++ 1]), 
        return 'ot, 'ot :: emptyCNameList)
   )
   ||
   ('ShareOK-B[ 'B ++ 1] ::= 
        nf('sa : unit <- read ('ShareOK-A['B ++ 1]), 
        return 'sa, 'sa :: emptyCNameList)
   )
   ||
  ***  start group
  (family 'BobOK 'k (bound 'B) ::= 
   (
   (family 'OTBitOK-B-A 'k (bound 'B) ::= 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), 
        return 'ot, 'ot :: emptyCNameList)
   )
   ||
   (family 'ShareOK-B 'k (bound 'B) ::=
     nf('sa : unit <- read ('ShareOK-A['k]), 
        return 'sa, 'sa :: emptyCNameList)
   )
   )
  ) *** end group
 .

op new7IndEnd : -> Protocol .
eq new7IndEnd =
  (
  aliceOK
  ||
  bobOK7IndEnd
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('x : unit <- read ('InOK-A['k]), return 'x, 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('x : unit <- read ('InOK-B['k]), return 'x, 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 


*** new7ind0

op bobOK7Ind0 : -> Protocol .
eq bobOK7Ind0 =  
   ('OTBitOK-B-A[ 'B ++ 1 ] ::= 
      (when (apply 'isAndGate ('B ++ 1)) --> 
  nf(('ba : unit <- read ('OTBitOK-A-B[('B ++ 1)])) 
     ('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
     ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
     ('ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])) 
      'yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)]), 
      return (), 
      'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
) 
;; 
 (otherwise --> 
   nf('ot : unit <- read ('OTBitOK-B-A[('B ++ 1)]),  
      return 'ot, 'ot :: emptyCNameList)
 )
   )
   ||
   ('ShareOK-B[ 'B ++ 1] ::= 
        nf('sa : unit <- read ('ShareOK-A['B ++ 1]), 
        return 'sa, 'sa :: emptyCNameList)
   )
   ||
   
   (family 'OTBitOK-B-A 'k (bound 'B) ::= 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), 
        return 'ot, 'ot :: emptyCNameList)
   )
   ||
   (family 'ShareOK-B 'k (bound 'B) ::=
     nf('sa : unit <- read ('ShareOK-A['k]), 
        return 'sa, 'sa :: emptyCNameList)
   )
   
 .

op new7Ind0 : -> Protocol .
eq new7Ind0 =
  (
  *** aliceOK
  (family 'OTBitOK-A-B 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( 
           ('ak : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('al : unit <- read ('ShareOK-A[fun 'wire1 'k])),
           return (),
           'ak :: 'al :: emptyCNameList
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-A-B['k]), 
                      return 'ot,
                      'ot :: emptyCNameList)
     )
   )
   ||
   (family 'ShareOK-A 'k (bound K) ::=
     (when (apply 'isAliceInput 'k) --> 
          nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 'k]),
             return 'is,
             'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
          nf(
           'is : unit <- read ('InputShareOK-A-B[fun 'wire0 'k]),
           return 'is,
           'is :: emptyCNameList
          )
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]),
             return 'sa,
             'sa :: emptyCNameList
            )
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])),
           return (),
           'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (when (apply 'isAndGate 'k) -->
          nf( 
          ('ba : unit <- read ('OTBitOK-A-B['k]))
          ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
          ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])),
          return (),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
   )
  ||
  bobOK7Ind0
  ||
  *** indAlice
  (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
 || 
  *** indBob1
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    )
  ) *** end Share-B
 ||
 *** indAdv1
 (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
 *** ok here
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('x : unit <- read ('InOK-A['k]), return 'x, 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('x : unit <- read ('InOK-B['k]), return 'x, 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 


*** new7base

op new7base : -> Protocol .
eq new7base =
    (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
 ) 
 || 
 (family 'InOK-B 'k (bound M) ::= 
   nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-A-A 'k (bound N) ::= 
   nf('x : unit <- read ('InOK-A['k]), return 'x, 'x :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-A-B 'k (bound M) ::= 
   nf('x : unit <- read ('InOK-B['k]), return 'x, 'x :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-B-A 'k (bound N) ::= 
   nf('xa : unit <- read ('InputShareOK-A-A['k]), return 'xa, 'xa :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-B-B 'k (bound M) ::= 
   nf('xa : unit <- read ('InputShareOK-A-B['k]), return 'xa, 'xa :: emptyCNameList)
 ) 
 || 
 (family 'OTBit-A-B 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 
         'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList)
   )
 ) 
 || 
 (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise -->
    nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), return 'otb, 'otb :: emptyCNameList)
   )
 ) 
 || 
 (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                                ap 'and pair('xb, 'ya)))), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
    ) 
    ;; 
    (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb :: emptyCNameList)
    ) 
 )
 || 
 (family 'OTBitOK-A-B 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'ak :: 'al :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot :: emptyCNameList)
   )
 ) 
 || 
 (family 'OTBitOK-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : unit <- read ('OTBitOK-A-B['k])) 
        ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
        ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
        ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('ot : unit <- read ('OTBitOK-B-A['k]), return 'ot, 'ot :: emptyCNameList)
   )
 ) 
 || 
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) -->
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : unit  <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) 
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'sb :: emptyCNameList)
   )
   ;; 
   (otherwise --> 
     nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) 
 || 
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList))
) 
|| 
(family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
||
(family 'Share-A 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
       return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
       return 'sa, 'sa :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList)
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  )
) 
|| 
(family 'Share-A_A_adv 'k (bound K) ::= 
  nf('sa : bool <- read ('Share-A['k]), 
     return 'sa, 'sa :: emptyCNameList)
) 
||  
(family 'Share-B 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
        return 'is, 'x :: 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
    nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
        return 'is, 'x :: 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'xb : bool <- read ('Share-B[fun 'wire0 'k]),
        return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('xb, 'yb)), 
        'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
  ) 
)
|| 
(family 'ShareOK-A 'k (bound K) ::= 
   (when (apply 'isAliceInput 'k) --> 
     nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
   ) 
   ;; 
   (when (apply 'isBobInput 'k) --> 
     nf('is : unit <- read ('InputShareOK-A-B[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
   ) 
   ;; 
   (when (apply 'isNotGate 'k) --> 
     nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]),
        return 'sa, 'sa :: emptyCNameList)
   ) 
   ;; 
   (when (apply 'isXorGate 'k) --> 
     nf(('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'ya : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : unit <- read ('OTBitOK-A-B['k])) 
        ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'ya : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'ba :: 'xa :: 'ya :: emptyCNameList)
   )
 )
 ||
 ('ShareOK-B[0] ::= nf('sa : unit <- read ('ShareOK-A[0]), return 'sa, 'sa :: emptyCNameList)
 )
.

*** new7step

op new7step : -> Protocol .
eq new7step =
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
 ) 
 || 
 (family 'InOK-B 'k (bound M) ::= 
   nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-A-A 'k (bound N) ::= 
   nf('x : unit <- read ('InOK-A['k]), return 'x, 'x :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-A-B 'k (bound M) ::= 
   nf('x : unit <- read ('InOK-B['k]), return 'x, 'x :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-B-A 'k (bound N) ::= 
   nf('xa : unit <- read ('InputShareOK-A-A['k]), return 'xa, 'xa :: emptyCNameList)
 ) 
 || 
 (family 'InputShareOK-B-B 'k (bound M) ::= 
   nf('xa : unit <- read ('InputShareOK-A-B['k]), return 'xa, 'xa :: emptyCNameList)
 ) 
 || 
 (family 'OTBit-A-B 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 
         'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList)
   )
 ) 
 || 
 (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise -->
    nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), return 'otb, 'otb :: emptyCNameList)
   )
 ) 
 || 
 (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                                ap 'and pair('xb, 'ya)))), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
    ) 
    ;; 
    (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb :: emptyCNameList)
    ) 
 )
 || 
 (family 'OTBitOK-A-B 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'ak :: 'al :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot :: emptyCNameList)
   )
 ) 
 || 
 (family 'OTBitOK-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : unit <- read ('OTBitOK-A-B['k])) 
        ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
        ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
        ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
        'yb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('ot : unit <- read ('OTBitOK-B-A['k]), return 'ot, 'ot :: emptyCNameList)
   )
 ) 
 || 
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) -->
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : unit  <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) 
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'sb :: emptyCNameList)
   )
   ;; 
   (otherwise --> 
     nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) 
 || 
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList))
) 
|| 
(family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
||
(family 'Share-A 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
       return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
       return 'sa, 'sa :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList)
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  )
) 
|| 
(family 'Share-A_A_adv 'k (bound K) ::= 
  nf('sa : bool <- read ('Share-A['k]), 
     return 'sa, 'sa :: emptyCNameList)
) 
||  
(family 'Share-B 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
        return 'is, 'x :: 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
    nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
        return 'is, 'x :: 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'xb : bool <- read ('Share-B[fun 'wire0 'k]),
        return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('xb, 'yb)), 
        'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
  ) 
)
|| 
(family 'ShareOK-A 'k (bound K) ::= 
   (when (apply 'isAliceInput 'k) --> 
     nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
   ) 
   ;; 
   (when (apply 'isBobInput 'k) --> 
     nf('is : unit <- read ('InputShareOK-A-B[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
   ) 
   ;; 
   (when (apply 'isNotGate 'k) --> 
     nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]),
        return 'sa, 'sa :: emptyCNameList)
   ) 
   ;; 
   (when (apply 'isXorGate 'k) --> 
     nf(('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'ya : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : unit <- read ('OTBitOK-A-B['k])) 
        ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'ya : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'ba :: 'xa :: 'ya :: emptyCNameList)
   )
 )
 ||
 (family 'ShareOK-B 'k (bound 'B) ::= 
   nf('sa : unit <- read ('ShareOK-A['k]), return 'sa, 'sa :: emptyCNameList)
 )
 ||
 ('ShareOK-B['B ++ 1] ::= 
    nf('sa : unit <- read ('ShareOK-A['B ++ 1]), return 'sa, 'sa :: emptyCNameList)
 )
.

*** new8

 op bobOKOTBit : -> Protocol .
 eq bobOKOTBit =  
  family 'BobOK 'k (bound K) ::=
   ( *** start bobok
   (family 'OTBitOK-B-A 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( ('ba : unit <- read ('OTBitOK-A-B['k]))
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k]))
           ('xb : unit <- read ('ShareOK-B[fun 'wire0 'k]))
           ('yb : unit <- read ('ShareOK-B[fun 'wire1 'k])) ,
           return (),
           'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-B-A['k]), 
                      return 'ot,
                      'ot :: emptyCNameList)
     )
   )
   ||
   (family 'ShareOK-B 'k (bound K) ::=
     nf('sa : unit <- read ('ShareOK-A['k]), 
        return 'sa,
        'sa :: emptyCNameList)
   )
   
   ) *** end bobok
 .

 op new8 : -> Protocol .
 eq new8 =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  aliceOK
  ||
  bobOKOTBit
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('x : unit <- read ('InOK-A['k]), return 'x, 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('x : unit <- read ('InOK-B['k]), return 'x, 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 

*** new9

 op bobOKNoGroup : -> Protocol .
 eq bobOKNoGroup =  
  
   (family 'OTBitOK-B-A 'k (bound K) ::= 
      nf('ot : unit <- read ('OTBitOK-A-B['k]), 
                      return 'ot,
                      'ot :: emptyCNameList)
   )
   ||
   (family 'ShareOK-B 'k (bound K) ::=
     nf('sa : unit <- read ('ShareOK-A['k]), 
        return 'sa,
        'sa :: emptyCNameList)
   )
 
 .

 op new9 : -> Protocol .
 eq new9 =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  aliceOK
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('x : unit <- read ('InOK-A['k]), return 'x, 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('x : unit <- read ('InOK-B['k]), return 'x, 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 

*** new10

 op new10 : -> Protocol .
 eq new10 =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  aliceOK
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 

*** new10Ind0

 op new10Ind0 : -> Protocol .
 eq new10Ind0 =
  (
  aliceOKInd0
  ||
  bobOKNoGroup
  ||
  *** indAlice
  (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
   ) *** end share-A
 || 
  *** indBob1
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k])), 
         return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
           ('x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k])), 
          return 'is, 'x :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
           ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('b : unit <- read ('OTBitOK-B-A['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
    )
  ) *** end Share-B
 ||
  *** indAdv1
  (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
         return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv ; end of indAdv1, the rest are the internals
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 



*** new10IndInt

 op new10IndInt : -> Protocol .
 eq new10IndInt =
  (
  aliceOKIndInt
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 

*** new10IndStart

 op new10IndStart : -> Protocol .
 eq new10IndStart =
  (
  aliceOKIndStart
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 

*** new10IndEnd

 op new10IndEnd : -> Protocol .
 eq new10IndEnd =
  (
  aliceOKIndEnd
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 



*** new10Int

 op aliceOKNoGroupInt : -> Protocol .
 eq aliceOKNoGroupInt = 
 (family 'OTBitOK-A-B 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
     nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'ak :: 'al :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot :: emptyCNameList)
   )
  ) 
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
 .

 op new10Int : -> Protocol .
 eq new10Int =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  aliceOKNoGroupInt
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 

*** new11

 op aliceOKNoGroup : -> Protocol .
 eq aliceOKNoGroup = 
  (family 'OTBitOK-A-B 'k (bound K) ::= 
    nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList)
  )
  ||
  (family 'ShareOK-A 'k (bound K) ::= 
    nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
  )
 .

 op new11 : -> Protocol .
 eq new11 =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  aliceOKNoGroup
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob1
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 

*** new10base

 op new10base : -> Protocol .
 eq new10base = 
 (family 'In-A_A_adv 'k (bound N) ::= 
  nf('inA : bool <- read ('In-A['k]), 
     return 'inA, 'inA :: emptyCNameList)
) 
|| 
(family 'InOK-A 'k (bound N) ::= 
  nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
) 
|| (family 'InOK-B 'k (bound M) ::= 
     nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)) 
|| (family 'InRcvd-B_B_adv 'k (bound M) ::= 
     nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)) 
|| (family 'InputShare-A-A 'k (bound N) ::= 
     nf('x : bool <- read ('In-A['k]), samp ('flip < () >), 'x :: emptyCNameList)
   ) 
|| (family 'InputShare-A-A_A_adv 'k (bound N) ::= 
     nf('is : bool <- read ('InputShare-A-A['k]), return 'is, 'is :: emptyCNameList)) 
|| (family 'InputShare-A-B 'k (bound M) ::= 
      nf('x : bool <- read ('In-B['k]), samp ('flip < () >), 'x :: emptyCNameList)
   ) 
|| (family 'InputShare-A-B_A_adv 'k (bound M) ::= 
     nf('is : bool <- read ('InputShare-A-B['k]), return 'is, 'is :: emptyCNameList)) 
|| (family 'InputShare-B-A 'k (bound N) ::= 
     nf(('x : bool <- read ('In-A['k])) 
         'xa : bool <- read ('InputShare-A-A['k]), 
         return (ap 'xor pair('x, 'xa)), 
         'x :: 'xa :: emptyCNameList)
   ) 
|| (family 'InputShare-B-B 'k (bound M) ::= 
     nf(('x : bool <- read ('In-B['k])) 
         'xa : bool <- read ('InputShare-A-B['k]), 
         return (ap 'xor pair('x, 'xa)), 
         'x :: 'xa :: emptyCNameList)
   ) 
|| (family 'InputShareOK-A-A 'k (bound N) ::= 
     nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)) 
|| (family 'InputShareOK-A-B 'k (bound M) ::= 
     nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)) 
|| (family 'InputShareOK-B-A 'k (bound N) ::= 
     nf('xa : unit <- read ('InputShareOK-A-A['k]), return 'xa, 'xa :: emptyCNameList)) 
|| (family 'InputShareOK-B-B 'k (bound M) ::= 
     nf('xa : unit <- read ('InputShareOK-A-B['k]), return 'xa, 'xa :: emptyCNameList)) 
|| (family 'OTBit-A-B 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 
         'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList)
   )
 ) 
|| (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise -->
    nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), return 'otb, 'otb :: emptyCNameList)
   )
 ) 
 || 
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                                ap 'and pair('xb, 'ya)))), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
    ) 
    ;; 
    (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb :: emptyCNameList)
    ) 
 )
 || 
 (family 'OTBitOK-A-B 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'ak :: 'al :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot :: emptyCNameList)
   )
 ) 
 || 
  (family 'OTBitOK-B-A 'k (bound K) ::= 
    nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot :: emptyCNameList)) 
||
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) -->
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : unit  <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) 
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'sb :: emptyCNameList)
   )
   ;; 
   (otherwise --> 
     nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) 
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList))
) 
|| 
(family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
)  
 || 
 (family 'Out-A 'k (bound K) ::= 
   (when (apply 'isOutputWire 'k) --> 
     nf(('sa : bool <- read ('Share-A['k])) 
         'sb : bool <- read ('Share-B['k]),
         return (ap 'xor pair('sa, 'sb)), 'sa :: 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('Out-A['k]), return 'x3, 'x3 :: emptyCNameList)
   )
 ) 
 || 
 (family 'Out-A_A_adv 'k (bound K) ::= 
   nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA :: emptyCNameList)) 
 || 
 (family 'Out-B 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf(('sa : bool <- read ('Share-A['k])) 
         'sb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('sa, 'sb)), 
         'sa :: 'sb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> nf('x3 : bool <- read ('Out-B['k]), return 'x3, 'x3 :: emptyCNameList)
  )
)  
||
(family 'SendFinalShare-A_A_adv 'k (bound K) ::= 
   (when (apply 'isOutputWire 'k) --> 
      nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : bool <- read ('SendFinalShare-A_A_adv['k]), return 'x3, 'x3 :: emptyCNameList)
   )
) 
|| 
(family 'SendFinalShare-B_A_adv 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('SendFinalShare-B_A_adv['k]), return 'x3, 'x3 :: emptyCNameList) 
    )
)
|| 
(family 'SendInputShare-A-B_A_adv 'k (bound M) ::= 
  nf('sis : bool <- read ('InputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)) 
|| 
(family 'SendInputShare-B-A_A_adv 'k (bound N) ::= 
  nf('sis : bool <- read ('InputShare-B-A['k]), return 'sis, 'sis :: emptyCNameList)) 
|| 
(family 'Share-A 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
       return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
       return 'sa, 'sa :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList)
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  )
) 
|| 
(family 'Share-A_A_adv 'k (bound K) ::= 
  nf('sa : bool <- read ('Share-A['k]), 
     return 'sa, 'sa :: emptyCNameList)
) 
|| 

(family 'Share-B 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
        return 'is, 'x :: 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
    nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
        return 'is, 'x :: 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'xb : bool <- read ('Share-B[fun 'wire0 'k]),
        return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('xb, 'yb)), 
        'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
  ) 
)
|| (family 'ShareOK-B 'k (bound K) ::= 
    nf('sa : unit <- read ('ShareOK-A['k]), return 'sa, 'sa :: emptyCNameList)
   )
    
|| ('ShareOK-A[0] ::= 
       nf('xa : bool <- read ('Share-A[0]), return (), 'xa :: emptyCNameList)
   )
 .
 
 op new10step : -> Protocol .
 eq new10step =
  (family 'In-A_A_adv 'k (bound N) ::= 
  nf('inA : bool <- read ('In-A['k]), 
     return 'inA, 'inA :: emptyCNameList)
) 
|| 
(family 'InOK-A 'k (bound N) ::= 
  nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
) 
|| (family 'InOK-B 'k (bound M) ::= 
     nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)) 
|| (family 'InRcvd-B_B_adv 'k (bound M) ::= 
     nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)) 
|| (family 'InputShare-A-A 'k (bound N) ::= 
     nf('x : bool <- read ('In-A['k]), samp ('flip < () >), 'x :: emptyCNameList)
   ) 
|| (family 'InputShare-A-A_A_adv 'k (bound N) ::= 
     nf('is : bool <- read ('InputShare-A-A['k]), return 'is, 'is :: emptyCNameList)) 
|| (family 'InputShare-A-B 'k (bound M) ::= 
      nf('x : bool <- read ('In-B['k]), samp ('flip < () >), 'x :: emptyCNameList)
   ) 
|| (family 'InputShare-A-B_A_adv 'k (bound M) ::= 
     nf('is : bool <- read ('InputShare-A-B['k]), return 'is, 'is :: emptyCNameList)) 
|| (family 'InputShare-B-A 'k (bound N) ::= 
     nf(('x : bool <- read ('In-A['k])) 
         'xa : bool <- read ('InputShare-A-A['k]), 
         return (ap 'xor pair('x, 'xa)), 
         'x :: 'xa :: emptyCNameList)
   ) 
|| (family 'InputShare-B-B 'k (bound M) ::= 
     nf(('x : bool <- read ('In-B['k])) 
         'xa : bool <- read ('InputShare-A-B['k]), 
         return (ap 'xor pair('x, 'xa)), 
         'x :: 'xa :: emptyCNameList)
   ) 
|| (family 'InputShareOK-A-A 'k (bound N) ::= 
     nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)) 
|| (family 'InputShareOK-A-B 'k (bound M) ::= 
     nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)) 
|| (family 'InputShareOK-B-A 'k (bound N) ::= 
     nf('xa : unit <- read ('InputShareOK-A-A['k]), return 'xa, 'xa :: emptyCNameList)) 
|| (family 'InputShareOK-B-B 'k (bound M) ::= 
     nf('xa : unit <- read ('InputShareOK-A-B['k]), return 'xa, 'xa :: emptyCNameList)) 
|| (family 'OTBit-A-B 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 
         'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList)
   )
 ) 
|| (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('otb : bool <- read ('OTBit-A-B['k]), return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise -->
    nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), return 'otb, 'otb :: emptyCNameList)
   )
 ) 
 || 
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                                ap 'and pair('xb, 'ya)))), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
    ) 
    ;; 
    (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb :: emptyCNameList)
    ) 
 )
 || 
 (family 'OTBitOK-A-B 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
         'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
         return (), 'ak :: 'al :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot :: emptyCNameList)
   )
 ) 
 || 
  (family 'OTBitOK-B-A 'k (bound K) ::= 
    nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot :: emptyCNameList)) 
||
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) -->
      nf('sb : unit <- read ('ShareOK-B[fun 'wire0 'k]), return (), 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : unit  <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) 
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf('sb : unit <- read ('ShareOK-B[fun 'wire1 'k]), 
        return (), 'sb :: emptyCNameList)
   )
   ;; 
   (otherwise --> 
     nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) 
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList))
) 
|| 
(family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'xa)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
)  
 || 
 (family 'Out-A 'k (bound K) ::= 
   (when (apply 'isOutputWire 'k) --> 
     nf(('sa : bool <- read ('Share-A['k])) 
         'sb : bool <- read ('Share-B['k]),
         return (ap 'xor pair('sa, 'sb)), 'sa :: 'sb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('Out-A['k]), return 'x3, 'x3 :: emptyCNameList)
   )
 ) 
 || 
 (family 'Out-A_A_adv 'k (bound K) ::= 
   nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA :: emptyCNameList)) 
 || 
 (family 'Out-B 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf(('sa : bool <- read ('Share-A['k])) 
         'sb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('sa, 'sb)), 
         'sa :: 'sb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> nf('x3 : bool <- read ('Out-B['k]), return 'x3, 'x3 :: emptyCNameList)
  )
)  
||
(family 'SendFinalShare-A_A_adv 'k (bound K) ::= 
   (when (apply 'isOutputWire 'k) --> 
      nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : bool <- read ('SendFinalShare-A_A_adv['k]), return 'x3, 'x3 :: emptyCNameList)
   )
) 
|| 
(family 'SendFinalShare-B_A_adv 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('SendFinalShare-B_A_adv['k]), return 'x3, 'x3 :: emptyCNameList) 
    )
)
|| 
(family 'SendInputShare-A-B_A_adv 'k (bound M) ::= 
  nf('sis : bool <- read ('InputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)) 
|| 
(family 'SendInputShare-B-A_A_adv 'k (bound N) ::= 
  nf('sis : bool <- read ('InputShare-B-A['k]), return 'sis, 'sis :: emptyCNameList)) 
|| 
(family 'Share-A 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) --> 
    nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
       return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf('sa : bool <- read ('Share-A[fun 'wire0 'k]),
       return 'sa, 'sa :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList)
  )
  ;; 
  (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
  )
) 
|| 
(family 'Share-A_A_adv 'k (bound K) ::= 
  nf('sa : bool <- read ('Share-A['k]), 
     return 'sa, 'sa :: emptyCNameList)
) 
|| 

(family 'Share-B 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-A[fun 'wire0 'k]), 
        return 'is, 'x :: 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
    nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
        'x : unit <- read ('InputShareOK-B-B[fun 'wire0 'k]), 
        return 'is, 'x :: 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
        'xb : bool <- read ('Share-B[fun 'wire0 'k]),
        return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) --> 
    nf(('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('xb, 'yb)), 
        'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isAndGate 'k) --> 
    nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
  ) 
)
|| (family 'ShareOK-B 'k (bound K) ::= 
    nf('sa : unit <- read ('ShareOK-A['k]), return 'sa, 'sa :: emptyCNameList)
   )

|| ('ShareOK-A['B ++ 1] ::= 
   nf('xa : bool <- read ('Share-A['B ++ 1]), 
      return (), 'xa :: emptyCNameList
     )
 )
 ||
 (family 'ShareOK-A 'k (bound 'B) ::=
   nf('xa : bool <- read ('Share-A['k]),
      return (), 'xa :: emptyCNameList
     )
 )
 .

*** new12

 op new12 : -> Protocol .
 eq new12 =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  aliceOKNoGroup
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob2
 ||
  indAdv1
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 

*** new13

 op new13 : -> Protocol .
 eq new13 =
  newfamily 'InOK-A 'k (bound N) : unit in
  newfamily 'InOK-B 'k (bound M) : unit in
  newfamily 'InputShareOK-A-A 'k (bound N) : unit in
  newfamily 'InputShareOK-A-B 'k (bound M) : unit in
  newfamily 'InputShareOK-B-A 'k (bound N) : unit in
  newfamily 'InputShareOK-B-B 'k (bound M) : unit in
  newfamily 'OTBitOK-A-B 'k (bound K) : unit in
  newfamily 'OTBitOK-B-A 'k (bound K) : unit in
  newfamily 'ShareOK-A 'k (bound K) : unit in
  newfamily 'ShareOK-B 'k (bound K) : unit in
  (
  aliceOKNoGroup
  ||
  bobOKNoGroup
  ||
  indAlice
 || 
  indBob2
 ||
  indAdv2
 || 
  (family 'InOK-A 'k (bound N) ::= 
    nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InOK-B 'k (bound M) ::= 
    nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-A 'k (bound N) ::= 
    nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-A-B 'k (bound M) ::= 
    nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-A 'k (bound N) ::= 
    nf( 
        ( 'xa : unit <- read ('InputShareOK-A-A['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ||
  (family 'InputShareOK-B-B 'k (bound M) ::= 
    nf(
        ( 'xa : unit <- read ('InputShareOK-A-B['k]) ), 
        return 'xa, 
        'xa :: emptyCNameList)
  )
  ) *** end new
. 

*** new14

 op new14 : -> Protocol .
 eq new14 =
  
  indAlice
 || 
  indBob2
 ||
  indAdv2
 
. 

*** new15 

op new15 : -> Protocol .
eq new15 = 
  indAlice
 || 
  indBob3
 ||
  indAdv2
.

*** new15base

op new15base : -> Protocol .
eq new15base =
  (family 'In-A_A_adv 'k (bound N) ::= 
  nf('inA : bool <- read ('In-A['k]), 
     return 'inA, 'inA :: emptyCNameList))
|| 
(family 'InRcvd-B_B_adv 'k (bound M) ::=  
  nf('x : bool <- read ('In-B['k]),
     return (), 'x :: emptyCNameList))
|| 

(family 'InputShare-A-A 'k (bound N) ::=
  nf('x : bool <- read ('In-A['k]), 
     samp ('flip < () >), 'x :: emptyCNameList))
|| 
(family 'InputShare-A-A_A_adv 'k (bound N) ::=
  nf('is : bool <- read ('InputShare-A-A['k]), 
     return 'is, 'is :: emptyCNameList))
|| 
(family 'InputShare-A-B 'k (bound M) ::=
  nf('x : bool <- read ('In-B['k]), 
     samp ('flip < () >), 'x :: emptyCNameList))
|| 
(family 'InputShare-A-B_A_adv 'k (bound M) ::=
  nf('is : bool <- read ('InputShare-A-B['k]), 
     return 'is, 'is :: emptyCNameList))
|| 
(family 'InputShare-B-A 'k (bound N) ::=
    nf(('x : bool <- read ('In-A['k])) 
        'xa : bool <- read ('InputShare-A-A['k]), 
        return (ap 'xor pair('x, 'xa)), 'x :: 'xa :: emptyCNameList)
)
|| 
(family 'InputShare-B-B 'k (bound M) ::=
  nf(('x : bool <- read ('In-B['k])) 
      'xa : bool <- read ('InputShare-A-B['k]), 
      return (ap 'xor pair('x, 'xa)), 'x :: 'xa :: emptyCNameList))
|| 
(family 'OTBit-A-B 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) -->
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise -->
  nf('otb : bool <- read ('OTBit-A-B['k]), 
     return 'otb, 'otb :: emptyCNameList)
  )
)
|| 
(family 'OTBit-A-B_A_adv 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) -->
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)) ;;
  (otherwise -->
    nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), return 'otb, 'otb :: emptyCNameList)
  )
)
|| 
(family 'OTBit-B-A 'k (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) -->
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
      ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
      ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
       'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
       return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                              ap 'and pair('xb, 'ya)))), 
       'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
 ) 
 ;; 
 (otherwise -->
  nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb :: emptyCNameList)
 )
)
|| 
(family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
 (when (apply 'isAndGate 'k) -->
   nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), return (), 'xa :: emptyCNameList)
 ) 
 ;; 
  (otherwise -->
     nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), return 'x3, 'x3 :: emptyCNameList)
  )
)
|| 
(family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) -->
    nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), return (), 'xa :: emptyCNameList)
  ) 
  ;; 
  (otherwise -->
    nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
)
|| 
(family 'OTMsg-A-B-0_ot_adv 'k (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) --> 
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
       return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
 ) 
 ;; 
 (otherwise --> 
   nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), return 'x3, 'x3 :: emptyCNameList)
 )
)
|| 
(family 'OTMsg-A-B-1_ot_adv 'k (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) --> 
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
       return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
 ) 
 ;; 
 (otherwise -->
  nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
     return 'x3, 'x3 :: emptyCNameList)
 )
)    
|| 
(family 'OTMsg-A-B-2_ot_adv 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise -->
    nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), return 'x3, 'x3 :: emptyCNameList)
  )
)
|| 
(family 'OTMsg-A-B-3_ot_adv 'k (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) -->
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
       return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
       'ba :: 'xa :: 'ya :: emptyCNameList)
 ) 
 ;; 
 (otherwise -->
   nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
      return 'x3, 'x3 :: emptyCNameList)
 )
)
|| 
(family 'Out-A 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
    nf('w : bool <- read ('Wire['k]), return 'w, 'w :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('Out-A['k]), return 'x3, 'x3 :: emptyCNameList)
  )
)
|| 
(family 'Out-A_A_adv 'k (bound (N + M)) ::=
  nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA :: emptyCNameList))
|| 
(family 'Out-B 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
   nf('w : bool <- read ('Wire['k]), return 'w, 'w :: emptyCNameList)
  ) 
  ;; 
  (otherwise -->
   nf('x3 : bool <- read ('Out-B['k]), return 'x3, 'x3 :: emptyCNameList)
  )
)
|| 
(family 'SendFinalShare-A_A_adv 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
    nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa :: emptyCNameList)
  ) 
  ;; 
  (otherwise -->
    nf('x3 : bool <- read ('SendFinalShare-A_A_adv['k]), return 'x3, 'x3 :: emptyCNameList)
  )
)
|| 
(family 'SendFinalShare-B_A_adv 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
    nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb :: emptyCNameList)
  ) 
  ;;
  (otherwise -->
     nf('x3 : bool <- read ('SendFinalShare-B_A_adv['k]), return 'x3, 'x3 :: emptyCNameList)
  )
)  
|| 
(family 'SendInputShare-A-B_A_adv 'k (bound M) ::=
  nf('sis : bool <- read ('InputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)
)
|| 
(family 'SendInputShare-B-A_A_adv 'k (bound N) ::=
  nf('sis : bool <- read ('InputShare-B-A['k]), return 'sis, 'sis :: emptyCNameList))
|| 
(family 'Share-A 'k (bound (N + M)) ::= 
  (when (apply 'isAliceInput 'k) -->
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
     nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) -->
     nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), return 'sa, 'sa :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) -->
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isAndGate 'k) -->
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
         'ba :: 'xa :: 'ya :: emptyCNameList)
  )
)    
|| 
(family 'Share-A_A_adv 'k (bound (N + M)) ::=
  nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa :: emptyCNameList)
)
|| 
(family 'Wire 'k (bound (N + M)) ::=
  nf(('xa : bool <- read ('Share-A['k])) 
      'xb : bool <- read ('Share-B['k]), 
      return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
)
|| 
('Share-B[0] ::= 
   nf(('xa : bool <- read ('Share-A[0])) 
       'x : bool <- read ('Wire[0]), 
      return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
) 
.

*** new15step

op new15step : -> Protocol .
eq new15step =
(family 'In-A_A_adv 'k (bound N) ::= 
  nf('inA : bool <- read ('In-A['k]), 
     return 'inA, 'inA :: emptyCNameList))
|| 
(family 'InRcvd-B_B_adv 'k (bound M) ::=  
  nf('x : bool <- read ('In-B['k]),
     return (), 'x :: emptyCNameList))
|| 

(family 'InputShare-A-A 'k (bound N) ::=
  nf('x : bool <- read ('In-A['k]), 
     samp ('flip < () >), 'x :: emptyCNameList))
|| 
(family 'InputShare-A-A_A_adv 'k (bound N) ::=
  nf('is : bool <- read ('InputShare-A-A['k]), 
     return 'is, 'is :: emptyCNameList))
|| 
(family 'InputShare-A-B 'k (bound M) ::=
  nf('x : bool <- read ('In-B['k]), 
     samp ('flip < () >), 'x :: emptyCNameList))
|| 
(family 'InputShare-A-B_A_adv 'k (bound M) ::=
  nf('is : bool <- read ('InputShare-A-B['k]), 
     return 'is, 'is :: emptyCNameList))
|| 
(family 'InputShare-B-A 'k (bound N) ::=
    nf(('x : bool <- read ('In-A['k])) 
        'xa : bool <- read ('InputShare-A-A['k]), 
        return (ap 'xor pair('x, 'xa)), 'x :: 'xa :: emptyCNameList)
)
|| 
(family 'InputShare-B-B 'k (bound M) ::=
  nf(('x : bool <- read ('In-B['k])) 
      'xa : bool <- read ('InputShare-A-B['k]), 
      return (ap 'xor pair('x, 'xa)), 'x :: 'xa :: emptyCNameList))
|| 
(family 'OTBit-A-B 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) -->
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         samp ('flip < () >), 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise -->
  nf('otb : bool <- read ('OTBit-A-B['k]), 
     return 'otb, 'otb :: emptyCNameList)
  )
)
|| 
(family 'OTBit-A-B_A_adv 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) -->
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)) ;;
  (otherwise -->
    nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), return 'otb, 'otb :: emptyCNameList)
  )
)
|| 
(family 'OTBit-B-A 'k (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) -->
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
      ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
      ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
       'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
       return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                              ap 'and pair('xb, 'ya)))), 
       'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
 ) 
 ;; 
 (otherwise -->
  nf('otb : bool <- read ('OTBit-B-A['k]), return 'otb, 'otb :: emptyCNameList)
 )
)
|| 
(family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
 (when (apply 'isAndGate 'k) -->
   nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), return (), 'xa :: emptyCNameList)
 ) 
 ;; 
  (otherwise -->
     nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), return 'x3, 'x3 :: emptyCNameList)
  )
)
|| 
(family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) -->
    nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), return (), 'xa :: emptyCNameList)
  ) 
  ;; 
  (otherwise -->
    nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
)
|| 
(family 'OTMsg-A-B-0_ot_adv 'k (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) --> 
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
       return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
 ) 
 ;; 
 (otherwise --> 
   nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), return 'x3, 'x3 :: emptyCNameList)
 )
)
|| 
(family 'OTMsg-A-B-1_ot_adv 'k (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) --> 
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
       return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
 ) 
 ;; 
 (otherwise -->
  nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
     return 'x3, 'x3 :: emptyCNameList)
 )
)    
|| 
(family 'OTMsg-A-B-2_ot_adv 'k (bound (N + M)) ::= 
  (when (apply 'isAndGate 'k) --> 
    nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (otherwise -->
    nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), return 'x3, 'x3 :: emptyCNameList)
  )
)
|| 
(family 'OTMsg-A-B-3_ot_adv 'k (bound (N + M)) ::= 
 (when (apply 'isAndGate 'k) -->
   nf(('ba : bool <- read ('OTBit-A-B['k])) 
      ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
       return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
       'ba :: 'xa :: 'ya :: emptyCNameList)
 ) 
 ;; 
 (otherwise -->
   nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
      return 'x3, 'x3 :: emptyCNameList)
 )
)
|| 
(family 'Out-A 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
    nf('w : bool <- read ('Wire['k]), return 'w, 'w :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('Out-A['k]), return 'x3, 'x3 :: emptyCNameList)
  )
)
|| 
(family 'Out-A_A_adv 'k (bound (N + M)) ::=
  nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA :: emptyCNameList))
|| 
(family 'Out-B 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
   nf('w : bool <- read ('Wire['k]), return 'w, 'w :: emptyCNameList)
  ) 
  ;; 
  (otherwise -->
   nf('x3 : bool <- read ('Out-B['k]), return 'x3, 'x3 :: emptyCNameList)
  )
)
|| 
(family 'SendFinalShare-A_A_adv 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
    nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa :: emptyCNameList)
  ) 
  ;; 
  (otherwise -->
    nf('x3 : bool <- read ('SendFinalShare-A_A_adv['k]), return 'x3, 'x3 :: emptyCNameList)
  )
)
|| 
(family 'SendFinalShare-B_A_adv 'k (bound (N + M)) ::= 
  (when (apply 'isOutputWire 'k) -->
    nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb :: emptyCNameList)
  ) 
  ;;
  (otherwise -->
     nf('x3 : bool <- read ('SendFinalShare-B_A_adv['k]), return 'x3, 'x3 :: emptyCNameList)
  )
)  
|| 
(family 'SendInputShare-A-B_A_adv 'k (bound M) ::=
  nf('sis : bool <- read ('InputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)
)
|| 
(family 'SendInputShare-B-A_A_adv 'k (bound N) ::=
  nf('sis : bool <- read ('InputShare-B-A['k]), return 'sis, 'sis :: emptyCNameList))
|| 
(family 'Share-A 'k (bound (N + M)) ::= 
  (when (apply 'isAliceInput 'k) -->
     nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isBobInput 'k) -->
     nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
        return 'is, 'is :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isNotGate 'k) -->
     nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), return 'sa, 'sa :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isXorGate 'k) -->
     nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList)
  ) 
  ;; 
  (when (apply 'isAndGate 'k) -->
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
         'ba :: 'xa :: 'ya :: emptyCNameList)
  )
)    
|| 
(family 'Share-A_A_adv 'k (bound (N + M)) ::=
  nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa :: emptyCNameList)
)
|| 
(family 'Wire 'k (bound (N + M)) ::=
  nf(('xa : bool <- read ('Share-A['k])) 
      'xb : bool <- read ('Share-B['k]), 
      return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
)
|| 
(family 'Share-B 'k (bound 'B) ::= 
  nf(('xa : bool <- read ('Share-A['k])) 
       'x : bool <- read ('Wire['k]), 
      return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
)
|| 
('Share-B['B ++ 1] ::= 
   nf(('xa : bool <- read ('Share-A['B ++ 1])) 
       'x : bool <- read ('Wire['B ++ 1]), 
      return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
) 
.

***
 
 op aliceOK : -> Protocol .
 eq aliceOK = 
  family 'AliceOK 'k (bound K) ::=
   ( *** start aliceok
   (family 'OTBitOK-A-B 'k (bound K) ::= 
     (when (apply 'isAndGate 'k) -->
       nf( 
           ('ak : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('al : unit <- read ('ShareOK-A[fun 'wire1 'k])),
           return (),
           'ak :: 'al :: emptyCNameList
         )
     ) 
     ;;
     (otherwise --> nf('ot : unit <- read ('OTBitOK-A-B['k]), 
                      return 'ot,
                      'ot :: emptyCNameList)
     )
   )
   ||
   (family 'ShareOK-A 'k (bound K) ::=
     (when (apply 'isAliceInput 'k) --> 
          nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 'k]),
             return 'is,
             'is :: emptyCNameList)
        )
        ;;
        (when (apply 'isBobInput 'k) --> 
          nf(
           'is : unit <- read ('InputShareOK-A-B[fun 'wire0 'k]),
           return 'is,
           'is :: emptyCNameList
          )
        )
        ;;
        (when (apply 'isNotGate 'k) --> 
          nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]),
             return 'sa,
             'sa :: emptyCNameList
            )
        )
        ;;
        (when (apply 'isXorGate 'k) --> 
          nf(
           ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
           ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])),
           return (),
           'xa :: 'ya :: emptyCNameList
          )
        )
        ;;
        (when (apply 'isAndGate 'k) -->
          nf( 
          ('ba : unit <- read ('OTBitOK-A-B['k]))
          ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k]))
          ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])),
          return (),
          'ba :: 'xa :: 'ya :: emptyCNameList
          )
        )
   )
   ) *** end aliceok
 . 
 
 *** what we get when rewriting restrFinal
 
 op restrFinal1 : -> Protocol .
 eq restrFinal1 =
  (family 'Out-A 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
    nf(('sa : bool <- read ('Share-A['k])) 
        'sb : bool <- read ('Share-B['k]), 
        return (ap 'xor pair('sa, 'sb)), 
        'sa :: 'sb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('Out-A['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'Out-A_A_adv 'k (bound K) ::= 
   nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA :: emptyCNameList)
) 
|| 
(family 'Out-B 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf(('sa : bool <- read ('Share-A['k])) 
         'sb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('sa, 'sb)), 
         'sa :: 'sb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> nf('x3 : bool <- read ('Out-B['k]), return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'SendFinalShare-A_A_adv 'k (bound K) ::= 
   (when (apply 'isOutputWire 'k) --> 
      nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : bool <- read ('SendFinalShare-A_A_adv['k]), return 'x3, 'x3 :: emptyCNameList)
   )
) 
|| 
(family 'SendFinalShare-B_A_adv 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('SendFinalShare-B_A_adv['k]), return 'x3, 'x3 :: emptyCNameList) 
    )
)
 .
 
 *** restrFinal2
 op restrFinal2 : -> Protocol .
 eq restrFinal2 =
  (family 'Out-A 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
    nf(('w : bool <- read ('Wire['k])) , 
        return 'w, 
        'w :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('Out-A['k]), 
       return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'Out-A_A_adv 'k (bound K) ::= 
   nf('outA : bool <- read ('Out-A['k]), return 'outA, 'outA :: emptyCNameList)
) 
|| 
(family 'Out-B 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf(('w : bool <- read ('Wire['k])) , 
        return 'w, 
        'w :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> nf('x3 : bool <- read ('Out-B['k]), return 'x3, 'x3 :: emptyCNameList)
  )
) 
|| 
(family 'SendFinalShare-A_A_adv 'k (bound K) ::= 
   (when (apply 'isOutputWire 'k) --> 
      nf('sa : bool <- read ('Share-A['k]), return 'sa, 'sa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : bool <- read ('SendFinalShare-A_A_adv['k]), return 'x3, 'x3 :: emptyCNameList)
   )
) 
|| 
(family 'SendFinalShare-B_A_adv 'k (bound K) ::= 
  (when (apply 'isOutputWire 'k) --> 
     nf('sb : bool <- read ('Share-B['k]), return 'sb, 'sb :: emptyCNameList)
  ) 
  ;; 
  (otherwise --> 
    nf('x3 : bool <- read ('SendFinalShare-B_A_adv['k]), return 'x3, 'x3 :: emptyCNameList) 
    )
)
 .
 
 op restr1 : -> Protocol .
 eq restr1 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new3 || restrFinal1) 
 .
 
 op restr2 : -> Protocol .
 eq restr2 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new4 || restrFinal1) 
 .
 
 op restr3 : -> Protocol .
 eq restr3 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new4Int || restrFinal1) 
 .
 
  
 op restr4 : -> Protocol .
 eq restr4 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new5 || restrFinal1) 
 .
 
 op restr4IndStart : -> Protocol .
 eq restr4IndStart = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new5IndStart || restrFinal1) 
 .
 
 op restr4IndEnd : -> Protocol .
 eq restr4IndEnd = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new5IndEnd || restrFinal1) 
 .
 
 op restr5 : -> Protocol .
 eq restr5 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new6 || restrFinal1) 
 .
 
 op restr6 : -> Protocol .
 eq restr6 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new7 || restrFinal1) 
 .
 
 op restr7 : -> Protocol .
 eq restr7 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new8 || restrFinal1) 
 .

 op restr8 : -> Protocol .
 eq restr8 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new9 || restrFinal1) 
 .
 
 op restr9 : -> Protocol .
 eq restr9 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new10 || restrFinal1) 
 .
 
 op restr10Int : -> Protocol .
 eq restr10Int = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new10Int || restrFinal1)
.
 
 op restr10 : -> Protocol .
 eq restr10 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new11 || restrFinal1) 
 .
 
 op restr11 : -> Protocol .
 eq restr11 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new12 || restrFinal1) 
 .
 
 op restr12 : -> Protocol .
 eq restr12 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new13 || restrFinal1) 
 .
 
 op restr13 : -> Protocol .
 eq restr13 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  (restrInitial2 || new14 || restrFinal1) 
 .
 
 op restr14 : -> Protocol .
 eq restr14 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  newfamily 'Wire 'k (bound K) : bool in
  (restrInitial2 || new14 || restrFinal1 ||
    (family 'Wire 'k (bound K) ::=
       nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa :: 'xb :: emptyCNameList
         )
    )
  ) 
 .
 
 op restr15 : -> Protocol .
 eq restr15 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  newfamily 'Wire 'k (bound K) : bool in
  (restrInitial2 || new14 || restrFinal2 ||
    (family 'Wire 'k (bound K) ::=
       nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa :: 'xb :: emptyCNameList
         )
    )
  ) 
 .
 
 op restr15Group : -> Protocol .
 eq restr15Group = 
    restrInitial2 || restrFinal2 || 
    *** expansion of new14, no group names
    ( 
     *** indAlice
     (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
     || 
     *** indAdv2
     (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
     ||
     *** indBob2 becomes a part of the new group!
     (
      family 'Group 'k (bound K) ::= 
      ( *** start group
       (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  (family 'Wire 'k (bound K) ::=
       nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa :: 'xb :: emptyCNameList
         )
    )
     
     ) *** end group
    )
    )
 .
 
 *** for the induction proof
 
 op restr15GroupIndStart : -> Protocol .
 eq restr15GroupIndStart = 
    restrInitial2 || restrFinal2 || 
    *** expansion of new14, no group names
    ( 
     *** indAlice
     (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
     || 
     *** indAdv2
     (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
 *** induction hypothesis
 ||
 (
   family 'Group 'k (bound 'B) ::=
    ( *** start group
      (family 'Wire 'k (bound 'B) ::=
        *** assuming we proved Wire to be the 5 cases
        (when (apply 'isAliceInput 'k) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 'k]), return 'inA0, 'inA0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isBobInput 'k) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 'k]), return 'inB0, 'inB0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isNotGate 'k) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 'k]),
     return (ap 'neg 'x),
     'x :: emptyCNameList
     )
  )
  ;;
  (when (apply 'isXorGate 'k) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'xor pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
  ;;
  (when (apply 'isAndGate 'k) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'and pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
     
     ) *** end Wire 'B
     ||
     (family 'Share-B 'k (bound 'B) ::=
        *** and we proved Share-B to be the reaction
        nf(('xa : bool <- read ('Share-A['k])) 
            'x : bool <- read ('Wire['k]), 
            return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
     ) *** end Share-B
     ||
     (family 'OTBit-B-A 'k (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
     )
    ) *** end group
 
 )
 *** induction step
 ||
 ('OTBit-B-A ['B ++ 1]::= 
   (when (apply 'isAndGate ('B ++ 1)) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
         'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B ++ 1]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
 ||
  ( 'Share-B['B ++ 1] ::= 
     *** we know this, and we want to get it to the one reaction
    (when (apply 'isAliceInput ('B ++ 1)) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 ('B ++ 1)]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput ('B ++ 1)) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 ('B ++ 1)]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate ('B ++ 1)) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]))
          ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate ('B ++ 1)) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]))
          ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]))
          ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate ('B ++ 1)) --> 
      nf(('bb : bool <- read ('OTBit-B-A['B ++ 1])) 
         ('ba : bool <- read ('OTBit-A-B['B ++ 1]))
         ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]))
         ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]))
         ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  ('Wire['B ++ 1] ::=
      *** and here we know that it is the one reaction 5 times
       (when (apply 'isAliceInput ('B ++ 1)) --> 
      nf( ('xa : bool <- read ('Share-A[('B ++ 1)]))
           ('xb : bool <- read ('Share-B[('B ++ 1)])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa :: 'xb :: emptyCNameList
         )
    ) ;;     
       (when (apply 'isBobInput ('B ++ 1)) --> 
      nf( ('xa : bool <- read ('Share-A[('B ++ 1)]))
           ('xb : bool <- read ('Share-B[('B ++ 1)])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa :: 'xb :: emptyCNameList
         )
    ) ;;
       (when (apply 'isNotGate ('B ++ 1)) --> 
      nf( ('xa : bool <- read ('Share-A[('B ++ 1)]))
           ('xb : bool <- read ('Share-B[('B ++ 1)])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa :: 'xb :: emptyCNameList
         )
    ) ;;
       (when (apply 'isXorGate ('B ++ 1)) --> 
      nf( ('xa : bool <- read ('Share-A[('B ++ 1)]))
           ('xb : bool <- read ('Share-B[('B ++ 1)])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa :: 'xb :: emptyCNameList
         )
    ) ;;
       (when (apply 'isAndGate ('B ++ 1)) --> 
      nf( ('xa : bool <- read ('Share-A[('B ++ 1)]))
           ('xb : bool <- read ('Share-B[('B ++ 1)])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa :: 'xb :: emptyCNameList
         )
       ) 
    ) 
   
   
   
   ) *** ends big bracket
 .

*** for the sym proof on share-b
 op restr15GroupIndSym : -> Protocol .
 eq restr15GroupIndSym = 
    restrInitial2 || restrFinal2 || 
    *** expansion of new14, no group names
    ( 
     *** indAlice
     (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
     || 
     *** indAdv2
     (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
 *** induction hypothesis
 ||
 (
  *** family 'Group 'k (bound 'B) ::=
    ( *** start group
      (family 'Wire 'k (bound 'B) ::=
        *** assuming we proved Wire to be the 5 cases
        (when (apply 'isAliceInput 'k) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 'k]), return 'inA0, 'inA0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isBobInput 'k) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 'k]), return 'inB0, 'inB0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isNotGate 'k) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 'k]),
     return (ap 'neg 'x),
     'x :: emptyCNameList
     )
  )
  ;;
  (when (apply 'isXorGate 'k) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'xor pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
  ;;
  (when (apply 'isAndGate 'k) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'and pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
     
     ) *** end Wire 'B
     ||
     (family 'Share-B 'k (bound 'B) ::=
        *** and we proved Share-B to be the reaction
        nf(('xa : bool <- read ('Share-A['k])) 
            'x : bool <- read ('Wire['k]), 
            return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
     ) *** end Share-B
     ||
     (family 'OTBit-B-A 'k (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
     )
    ) *** end group
 
 )
 *** induction step
 ||
 ('OTBit-B-A ['B ++ 1]::= 
   (when (apply 'isAndGate ('B ++ 1)) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
         'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B ++ 1]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
 ||
  ( 'Share-B['B ++ 1] ::= 
     *** for the sym proof we write the reaction 5 times
    (when (apply 'isAliceInput ('B ++ 1)) --> 
        nf(('xa : bool <- read ('Share-A['B ++ 1])) 
            'x : bool <- read ('Wire['B ++ 1]), 
            return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput ('B ++ 1)) --> 
       nf(('xa : bool <- read ('Share-A['B ++ 1])) 
            'x : bool <- read ('Wire['B ++ 1]), 
            return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate ('B ++ 1)) --> 
       nf(('xa : bool <- read ('Share-A['B ++ 1])) 
            'x : bool <- read ('Wire['B ++ 1]), 
            return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate ('B ++ 1)) --> 
       nf(('xa : bool <- read ('Share-A['B ++ 1])) 
            'x : bool <- read ('Wire['B ++ 1]), 
            return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate ('B ++ 1)) --> 
      nf(('xa : bool <- read ('Share-A['B ++ 1])) 
            'x : bool <- read ('Wire['B ++ 1]), 
            return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  ('Wire['B ++ 1] ::= 
    (when (apply 'isAliceInput ('B ++ 1)) --> 
       nf(('xa : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)])) 
           'xb : bool <- read ('InputShare-B-A[fun 'wire0 ('B ++ 1)]), 
           return (ap 'xor pair('xa, 'xb)), 
           'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput ('B ++ 1)) --> 
       nf(('xa : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)])) 
           'xb : bool <- read ('InputShare-B-B[fun 'wire0 ('B ++ 1)]), 
           return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate ('B ++ 1)) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
           'xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
           return (ap 'xor pair('xa, ap 'neg 'xb)), 
           'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate ('B ++ 1)) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
          ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
          ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
           'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
           return (ap 'xor pair(ap 'xor pair('xa, 'ya), ap 'xor pair('xb, 'yb))),
           'xa :: 'yb :: 'ya :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'B ++ 1) --> 
       nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
          ('bb : bool <- read ('OTBit-B-A['B ++ 1])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)]))
          ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
          ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
           'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
           return (ap 'xor pair(ap 'xor pair(ap 'and pair('xa, 'ya), 'ba), 
                                ap 'xor pair('bb, ap 'and pair('xb, 'yb)))), 
           'bb :: 'ba :: 'xa :: 'yb :: 'ya :: 'xb :: emptyCNameList)    
    )
  ) 
   
   
   
   ) *** ends big bracket
 .



 
  op restr15GroupIndEnd : -> Protocol .
 eq restr15GroupIndEnd = 
    restrInitial2 || restrFinal2 || 
    *** expansion of new14, no group names
    ( 
     *** indAlice
     (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
     || 
     *** indAdv2
     (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
 *** induction hypothesis
 ||
 (
   family 'Group 'k (bound 'B) ::=
    ( *** start group
      (family 'Wire 'k (bound 'B) ::=
        *** assuming we proved Wire to be the 5 cases
        (when (apply 'isAliceInput 'k) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 'k]), return 'inA0, 'inA0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isBobInput 'k) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 'k]), return 'inB0, 'inB0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isNotGate 'k) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 'k]),
     return (ap 'neg 'x),
     'x :: emptyCNameList
     )
  )
  ;;
  (when (apply 'isXorGate 'k) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'xor pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
  ;;
  (when (apply 'isAndGate 'k) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'and pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
     
     ) *** end Wire 'B
     ||
     (family 'Share-B 'k (bound 'B) ::=
        *** and we proved Share-B to be the reaction
        nf(('xa : bool <- read ('Share-A['k])) 
            'x : bool <- read ('Wire['k]), 
            return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
     ) *** end Share-B
     ||
     (family 'OTBit-B-A 'k (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
     )
    ) *** end group
 
 )
 *** induction step
 ||
 ('OTBit-B-A ['B ++ 1]::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
 ||
  ( 'Share-B['B ++ 1] ::= 
    nf(('xa : bool <- read ('Share-A['B ++ 1])) 
            'x : bool <- read ('Wire['B ++ 1]), 
            return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
  ) *** end Share-B
  ||
  ('Wire['B ++ 1] ::=
     (when (apply 'isAliceInput ('B ++ 1)) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 ('B ++ 1)]), return 'inA0, 'inA0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isBobInput ('B ++ 1)) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 ('B ++ 1)]), return 'inB0, 'inB0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isNotGate ('B ++ 1)) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 ('B ++ 1)]),
     return (ap 'neg 'x),
     'x :: emptyCNameList
     )
  )
  ;;
  (when (apply 'isAndGate ('B ++ 1)) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 ('B ++ 1)]))
    ('y : bool <- read ('Wire[fun 'wire1 ('B ++ 1)])),
    return (ap 'and pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
  ;;
  (when (apply 'isXorGate ('B ++ 1)) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 ('B ++ 1)]))
    ('y : bool <- read ('Wire[fun 'wire1 ('B ++ 1)])),
    return (ap 'xor pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )     
  ) 
   
   
   
   ) *** ends big bracket
 .
 
 *******************
 
 op restr15Wire : -> Protocol .
 eq restr15Wire = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  newfamily 'Wire 'k (bound K) : bool in
  (restrInitial2 || new14 || restrFinal2 ||
    (family 'Wire 'k (bound K) ::=
          (when (apply 'isAliceInput 'k) --> 
      nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa :: 'xb :: emptyCNameList
         )
    ) ;;     
       (when (apply 'isBobInput 'k) --> 
      nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa :: 'xb :: emptyCNameList
         )
    ) ;;
       (when (apply 'isNotGate 'k) --> 
      nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa :: 'xb :: emptyCNameList
         )
    ) ;;
       (when (apply 'isXorGate 'k) --> 
      nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa :: 'xb :: emptyCNameList
         )
    ) ;;
       (when (apply 'isAndGate 'k) --> 
      nf( ('xa : bool <- read ('Share-A['k]))
           ('xb : bool <- read ('Share-B['k])), 
           return (ap 'xor pair('xa, 'xb)),
           'xa :: 'xb :: emptyCNameList
         )
    )
    )
  ) 
 .
 
 *** restr16
 
 op restr16 : -> Protocol .
 eq restr16 = 
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  newfamily 'Wire 'k (bound K) : bool in
  ( restrInitial2 || new15 || restrFinal2 || wiresIdeal )  
 .
 
 *** restr16Group
op restr16Group : -> Protocol .
eq restr16Group =
  newfamily 'InputShare-A-A 'k (bound N) : bool in
  newfamily 'InputShare-A-B 'k (bound M) : bool in
  newfamily 'InputShare-B-A 'k (bound N) : bool in
  newfamily 'InputShare-B-B 'k (bound M) : bool in
  newfamily 'OTBit-A-B 'k (bound K) : bool in
  newfamily 'OTBit-B-A 'k (bound K) : bool in
  newfamily 'Share-A 'k (bound K) : bool in
  newfamily 'Share-B 'k (bound K) : bool in
  newfamily 'Wire 'k (bound K) : bool in
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
    ||
    *** here is the group
   ( family 'Group 'k (bound K) ::= 
   ( *** start group
    (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  (
  family 'Share-B 'k (bound K) ::= 
    nf(('xa : bool <- read ('Share-A['k])) 
       'x : bool <- read ('Wire['k]), 
      return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
  ) *** end Share-B
  ||
    (family 'Wire 'k (bound K) ::= 
  (when (apply 'isAliceInput 'k) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 'k]), return 'inA0, 'inA0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isBobInput 'k) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 'k]), return 'inB0, 'inB0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isNotGate 'k) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 'k]),
     return (ap 'neg 'x),
     'x :: emptyCNameList
     )
  )
  ;;
  (when (apply 'isXorGate 'k) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'xor pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
  ;;
  (when (apply 'isAndGate 'k) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 'k]))
    ('y : bool <- read ('Wire[fun 'wire1 'k])),
    return (ap 'and pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
)
) *** end group
)
.

*** restr16GIndStart
op restr16GIndStart : -> Protocol .
eq restr16GIndStart =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
    ||
    *** here is the group
   ( family 'Group 'k (bound 'B) ::= 
   ( *** start group
   (family 'Wire 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
   )
   ||
   (family 'Share-B 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  (family 'OTBit-B-A 'k (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B ++ 1] ::= 
   (when (apply 'isAndGate ('B ++ 1)) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
         'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B ++ 1]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B ++ 1] ::= 
    nf(('xa : bool <- read ('Share-A['B ++ 1])) 
       'x : bool <- read ('Wire['B ++ 1]), 
      return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
  ) *** end Share-B
  ||
    ('Wire['B ++ 1]  ::= 
  (when (apply 'isAliceInput ('B ++ 1)) --> 
    nf('inA0 : bool <- read ('In-A[fun 'wire0 ('B ++ 1)]), return 'inA0, 'inA0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isBobInput ('B ++ 1)) --> 
    nf('inB0 : bool <- read ('In-B[fun 'wire0 ('B ++ 1)]), return 'inB0, 'inB0 :: emptyCNameList)
  )
  ;;
  (when (apply 'isNotGate ('B ++ 1)) -->
    nf( 
     'x : bool <- read ('Wire[fun 'wire0 ('B ++ 1)]),
     return (ap 'neg 'x),
     'x :: emptyCNameList
     )
  )
  ;;
  (when (apply 'isXorGate ('B ++ 1)) -->
  nf(
    ('x : bool <- read ('Wire[fun 'wire0 ('B ++ 1)]))
    ('y : bool <- read ('Wire[fun 'wire1 ('B ++ 1)])),
    return (ap 'xor pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
  ;;
  (when (apply 'isAndGate ('B ++ 1)) -->
    nf(
    ('x : bool <- read ('Wire[fun 'wire0 ('B ++ 1)]))
    ('y : bool <- read ('Wire[fun 'wire1 ('B ++ 1)])),
    return (ap 'and pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  )
  
)

.

*** restr16GIndEnd
op restr16GIndEnd : -> Protocol .
eq restr16GIndEnd =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
    ||
    *** here is the group
   ( family 'Group 'k (bound 'B) ::= 
   ( *** start group
   (family 'Wire 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
   )
   ||
   (family 'Share-B 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  (family 'OTBit-B-A 'k (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B ++ 1] ::= 
   (when (apply 'isAndGate ('B ++ 1)) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
         'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B ++ 1]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B ++ 1] ::= 
    (when (apply 'isAliceInput ('B ++ 1)) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 ('B ++ 1)]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput ('B ++ 1)) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 ('B ++ 1)]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate ('B ++ 1)) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]))
          ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate ('B ++ 1)) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]))
          ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]))
          ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate ('B ++ 1)) --> 
      nf(('bb : bool <- read ('OTBit-B-A[('B ++ 1)])) 
         ('ba : bool <- read ('OTBit-A-B[('B ++ 1)]))
         ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]))
         ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]))
         ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
  ||
    ('Wire['B ++ 1]  ::= 
       nf(('xa : bool <- read ('Share-A['B ++ 1])) 
         'xb : bool <- read ('Share-B['B ++ 1]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
    )

.

*** restr16GIndSymShare
op restr16GIndSymShare : -> Protocol .
eq restr16GIndSymShare =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
    ||
    *** here is the group
   ( family 'Group 'k (bound 'B) ::= 
   ( *** start group
   (family 'Wire 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
   )
   ||
   (family 'Share-B 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  (family 'OTBit-B-A 'k (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B ++ 1] ::= 
   (when (apply 'isAndGate ('B ++ 1)) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
         'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B ++ 1]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
 ( 'Share-B['B ++ 1] ::= 
     *** for the sym proof we write the reaction 5 times
    (when (apply 'isAliceInput ('B ++ 1)) --> 
        nf(('xa : bool <- read ('Share-A['B ++ 1])) 
            'x : bool <- read ('Wire['B ++ 1]), 
            return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput ('B ++ 1)) --> 
       nf(('xa : bool <- read ('Share-A['B ++ 1])) 
            'x : bool <- read ('Wire['B ++ 1]), 
            return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate ('B ++ 1)) --> 
       nf(('xa : bool <- read ('Share-A['B ++ 1])) 
            'x : bool <- read ('Wire['B ++ 1]), 
            return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate ('B ++ 1)) --> 
       nf(('xa : bool <- read ('Share-A['B ++ 1])) 
            'x : bool <- read ('Wire['B ++ 1]), 
            return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate ('B ++ 1)) --> 
      nf(('xa : bool <- read ('Share-A['B ++ 1])) 
            'x : bool <- read ('Wire['B ++ 1]), 
            return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
    )
  ) *** end Share-B
  ||
    ('Wire['B ++ 1] ::= 
 (when (apply 'isAliceInput ('B ++ 1)) --> 
   nf(('xa : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)])) 
       'xb : bool <- read ('InputShare-B-A[fun 'wire0 ('B ++ 1)]), 
        return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
 ) 
 ;; 
 (when (apply 'isBobInput ('B ++ 1)) --> 
   nf(('xa : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)])) 
       'xb : bool <- read ('InputShare-B-B[fun 'wire0 ('B ++ 1)]), 
        return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
 ) 
 ;; 
 (when (apply 'isNotGate ('B ++ 1)) -->
   nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
       'xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
       return (ap 'neg ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
 ) 
 ;; 
 (when (apply 'isXorGate ('B ++ 1)) --> 
   nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
      ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
      ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
       'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
       return (ap 'xor pair(ap 'xor pair('xa, 'ya), ap 'xor pair('xb, 'yb))),
       'xa :: 'yb :: 'ya :: 'xb :: emptyCNameList)
 ) 
 ;; 
 (when (apply 'isAndGate ('B ++ 1)) --> 
  nf(('ba : bool <- read ('OTBit-A-B[('B ++ 1)])) 
     ('bb : bool <- read ('OTBit-B-A[('B ++ 1)])) 
     ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)]))
     ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
     ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
      'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
      return (ap 'xor pair(ap 'xor pair(ap 'and pair('xa, 'ya), 'ba), 
                           ap 'xor pair('bb, ap 'and pair('xb, 'yb)))), 
      'bb :: 'ba :: 'xa :: 'yb :: 'ya :: 'xb :: emptyCNameList)
 )  
  
    )

.


*** restr16GSymAlice
op restr16GSymAlice : -> Protocol .
eq restr16GSymAlice =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
    ||
    *** here is the group
   ( family 'Group 'k (bound 'B) ::= 
   ( *** start group
   (family 'Wire 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
   )
   ||
   (family 'Share-B 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  (family 'OTBit-B-A 'k (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B ++ 1] ::= 
   (when (apply 'isAndGate ('B ++ 1)) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
         'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B ++ 1]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B ++ 1] ::= 
    nf(('xa : bool <- read ('Share-A['B ++ 1])) 
       'x : bool <- read ('Wire['B ++ 1]), 
      return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
  ) *** end Share-B
  ||
    ('Wire['B ++ 1]  ::= 
  
    nf('inA0 : bool <- read ('In-A[fun 'wire0 ('B ++ 1)]), return 'inA0, 'inA0 :: emptyCNameList)
  
  )

.

*** restr16GSymBob
op restr16GSymBob : -> Protocol .
eq restr16GSymBob =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
    ||
    *** here is the group
   ( family 'Group 'k (bound 'B) ::= 
   ( *** start group
   (family 'Wire 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
   )
   ||
   (family 'Share-B 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  (family 'OTBit-B-A 'k (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B ++ 1] ::= 
   (when (apply 'isAndGate ('B ++ 1)) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
         'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B ++ 1]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B ++ 1] ::= 
    nf(('xa : bool <- read ('Share-A['B ++ 1])) 
       'x : bool <- read ('Wire['B ++ 1]), 
      return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
  ) *** end Share-B
  ||
    ('Wire['B ++ 1]  ::= 
  
    nf('inB0 : bool <- read ('In-B[fun 'wire0 ('B ++ 1)]), 
       return 'inB0, 'inB0 :: emptyCNameList)
  
  )
.

*** restr16GSymNot
op restr16GSymNot : -> Protocol .
eq restr16GSymNot =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
    ||
    *** here is the group
   ( family 'Group 'k (bound 'B) ::= 
   ( *** start group
   (family 'Wire 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
   )
   ||
   (family 'Share-B 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  (family 'OTBit-B-A 'k (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B ++ 1] ::= 
   (when (apply 'isAndGate ('B ++ 1)) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
         'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B ++ 1]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B ++ 1] ::= 
    nf(('xa : bool <- read ('Share-A['B ++ 1])) 
       'x : bool <- read ('Wire['B ++ 1]), 
      return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
  ) *** end Share-B
  ||
    ('Wire['B ++ 1]  ::= 
  
     nf( 
     'x : bool <- read ('Wire[fun 'wire0 ('B ++ 1)]),
     return (ap 'neg 'x),
     'x :: emptyCNameList
     )
  
  )

.

*** restr16GSymXor
op restr16GSymXor : -> Protocol .
eq restr16GSymXor =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
    ||
    *** here is the group
   ( family 'Group 'k (bound 'B) ::= 
   ( *** start group
   (family 'Wire 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
   )
   ||
   (family 'Share-B 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  (family 'OTBit-B-A 'k (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B ++ 1] ::= 
   (when (apply 'isAndGate ('B ++ 1)) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
         'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B ++ 1]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B ++ 1] ::= 
    nf(('xa : bool <- read ('Share-A['B ++ 1])) 
       'x : bool <- read ('Wire['B ++ 1]), 
      return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
  ) *** end Share-B
  ||
    ('Wire['B ++ 1]  ::= 
  
     nf(
    ('x : bool <- read ('Wire[fun 'wire0 ('B ++ 1)]))
    ('y : bool <- read ('Wire[fun 'wire1 ('B ++ 1)])),
    return (ap 'xor pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  
  )

.

*** restr16GSymAnd
op restr16GSymAnd : -> Protocol .
eq restr16GSymAnd =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
    ||
    *** here is the group
   ( family 'Group 'k (bound 'B) ::= 
   ( *** start group
   (family 'Wire 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
   )
   ||
   (family 'Share-B 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  (family 'OTBit-B-A 'k (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B ++ 1] ::= 
   (when (apply 'isAndGate ('B ++ 1)) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
         'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B ++ 1]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B ++ 1] ::= 
    nf(('xa : bool <- read ('Share-A['B ++ 1])) 
       'x : bool <- read ('Wire['B ++ 1]), 
      return (ap 'xor pair('xa, 'x)), 'xa :: 'x :: emptyCNameList)
  ) *** end Share-B
  ||
    ('Wire['B ++ 1]  ::= 
  
   nf(
    ('x : bool <- read ('Wire[fun 'wire0 ('B ++ 1)]))
    ('y : bool <- read ('Wire[fun 'wire1 ('B ++ 1)])),
    return (ap 'and pair('x, 'y)),
    'x :: 'y :: emptyCNameList 
    )
  
  )

.


*** restr16GIndEnd5
op restr16GIndEnd5 : -> Protocol .
eq restr16GIndEnd5 =
    restrInitial2 || restrFinal2 
    || *** expansion of new15, no news and expansion of wiresIdeal, but we group 
       *** Wire Share-B and OTBit-B-A 
    *** indAlice
    (family 'OTBit-A-B 'k (bound K) ::= 
    (when (apply 'isAndGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
           samp ('flip < () >), 
           'xa :: 'ya :: emptyCNameList)
    ) ;; 
    (otherwise --> 
       nf('otb : bool <- read ('OTBit-A-B['k]), 
          return 'otb, 
          'otb :: emptyCNameList)
    )
  ) *** end otbit
   ||
   (family 'Share-A 'k (bound K) ::= 
     (when (apply 'isAliceInput 'k) --> 
       nf('is : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
          return 'is,
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isBobInput 'k) -->  
       nf('is : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
          return 'is, 
          'is :: emptyCNameList)
     ) 
     ;; 
     (when (apply 'isNotGate 'k) --> 
       nf('sa : bool <- read ('Share-A[fun 'wire0 'k]), 
          return 'sa, 
          'sa :: emptyCNameList)
     ) 
     ;;
     (when (apply 'isXorGate 'k) --> 
       nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('xa, 'ya)), 
          'xa :: 'ya :: emptyCNameList)
     )
     ;; 
     (when (apply 'isAndGate 'k) --> 
       nf(('ba : bool <- read ('OTBit-A-B['k])) 
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
           'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
          'ba :: 'xa :: 'ya :: emptyCNameList
         )
    )
    ) *** end share-A
    || *** indAdv2
    (family 'OTBit-A-B_A_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('otb : bool <- read ('OTBit-A-B['k]), 
         return 'otb, 'otb :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('otb : bool <- read ('OTBit-A-B_A_adv['k]), 
        return 'otb, 'otb :: emptyCNameList)
   )
 ) *** end OTBit
 ||   
 (family 'OTChoiceRcvd-B-A-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-0_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-0  
 || 
 (family 'OTChoiceRcvd-B-A-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (), 'xa :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
      nf('x3 : unit <- read ('OTChoiceRcvd-B-A-1_ot_adv['k]), 
         return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end choiceRcvd-1
 ||
 (family 'OTMsg-A-B-0_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]),
         return 'ba, 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-0_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-0
 ||
 (family 'OTMsg-A-B-1_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
      nf(('ba : bool <- read ('OTBit-A-B['k])) 
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
          return (ap 'xor pair('ba, 'xa)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-1_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-1
 ||
 (family 'OTMsg-A-B-2_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 'ya)), 'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-2_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-2
 ||
 (family 'OTMsg-A-B-3_ot_adv 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         'ya : bool <- read ('Share-A[fun 'wire1 'k]), 
        return (ap 'xor pair('ba, ap 'xor pair('xa, 'ya))), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
   ) 
   ;; 
   (otherwise --> 
     nf('x3 : bool <- read ('OTMsg-A-B-3_ot_adv['k]), 
        return 'x3, 'x3 :: emptyCNameList)
   )
 ) *** end msg-3
 ||
 (family 'Share-A_A_adv 'k (bound K) ::= 
    nf('sa : bool <- read ('Share-A['k]), 
       return 'sa, 'sa :: emptyCNameList)
 ) *** end share-A_A_adv 
    ||
    *** here is the group
   ( family 'Group 'k (bound 'B) ::= 
   ( *** start group
   (family 'Wire 'k (bound 'B) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
   )
   ||
   (family 'Share-B 'k (bound 'B) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  (family 'OTBit-B-A 'k (bound 'B) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
   ) *** end group
   )
   ||
    ('OTBit-B-A['B ++ 1] ::= 
   (when (apply 'isAndGate ('B ++ 1)) --> 
     nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
         'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['B ++ 1]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
  ||
  ('Share-B['B ++ 1] ::= 
    (when (apply 'isAliceInput ('B ++ 1)) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 ('B ++ 1)]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput ('B ++ 1)) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 ('B ++ 1)]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate ('B ++ 1)) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]))
          ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate ('B ++ 1)) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]))
          ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]))
          ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate ('B ++ 1)) --> 
      nf(('bb : bool <- read ('OTBit-B-A[('B ++ 1)])) 
         ('ba : bool <- read ('OTBit-A-B[('B ++ 1)]))
         ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]))
         ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]))
         ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
  ||
    ('Wire['B ++ 1]  ::= 
      ( when (apply 'isAliceInput ('B ++ 1)) --> 
       nf(('xa : bool <- read ('Share-A['B ++ 1])) 
         'xb : bool <- read ('Share-B['B ++ 1]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
      )   
      ;;
      ( when (apply 'isBobInput ('B ++ 1)) --> 
       nf(('xa : bool <- read ('Share-A['B ++ 1])) 
         'xb : bool <- read ('Share-B['B ++ 1]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
      )   
      ;;
      ( when (apply 'isNotGate ('B ++ 1)) --> 
       nf(('xa : bool <- read ('Share-A['B ++ 1])) 
         'xb : bool <- read ('Share-B['B ++ 1]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
      )   
      ;;
      ( when (apply 'isXorGate ('B ++ 1)) --> 
       nf(('xa : bool <- read ('Share-A['B ++ 1])) 
         'xb : bool <- read ('Share-B['B ++ 1]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
      )   
      ;;
      ( when (apply 'isAndGate ('B ++ 1)) --> 
       nf(('xa : bool <- read ('Share-A['B ++ 1])) 
         'xb : bool <- read ('Share-B['B ++ 1]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
      )   
      
    )

.

endm 

smod EXECUTE is
 pr GMW2 .
 pr STRATS .
 
 var x y x1 x2 x3 q C : Qid .
 var Sigma : Signature .
 var Delta : ChannelContext .
 var Gamma : TypeContext .
 var I O : Set{CNameBound} .
 var A : Set{BoolTerm} .
 var cn : ChannelName .
 var pConf : ProtocolConfig .
 var P : Protocol .
 var T : Type .
 var nt : NatTerm .
 var bt : BoolTerm .
 
 var e1 e2 e3 e4 : Expression . 

 *** x = () if x : unit
 
 rl [return-unit] :
   rConfig(Sigma, Delta, Gamma (x : unit), return x, I, A, T)
   => 
   rConfig(Sigma, Delta, Gamma (x : unit), return (), I, A, T)
 .
 
 strat applyReturnUnit : ChannelName @ ProtocolConfig .
 sd applyReturnUnit(cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnUnit(cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P cn, 
                             P1:Protocol <- keepOne P cn]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-unit}}
                             or-else
                             CONG-REACT-family[C:Qid <- cn]{cong-nf{return-unit}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-unit}}
                             or-else
                             CONG-REACT-family[C:Qid <- cn]{cong-nf{return-unit}}
                      )
             )
 .
 

 *******************************
 *** assumptions
 ******************************* 
 
 ***( this is the alternative path, needs consistent changes throughout the whole proof 
 *** congruence rules
 crl [cong-ap] : ap q e1 => ap q e2 
     if e1 => e2 .
     
 crl [cong-pair-r] : pair(e1, e2) => pair(e1, e3)    
     if e2 => e3 .
     
 crl [cong-pair-l] : pair(e1, e2) => pair(e3, e2)    
     if e1 => e3 .
     
 *** assoc and comm for 'xor and 'and
 
 rl [comm-xor] : 
    return(ap 'xor pair(e1, e2)) => return(ap 'xor pair(e2, e1)) .
    
 rl [comm-and] : 
    ap 'and pair(e1, e2) => ap 'and pair(e2, e1) .
    
 rl [assoc-xor-l] :
    ap 'xor pair(e1, ap 'xor pair(e2, e3)) 
    => 
    ap 'xor pair(ap 'xor pair(e1, e2), e3) .  
       
 rl [assoc-xor-r] :
    ap 'xor pair(ap 'xor pair(e1, e2), e3)
    => 
    ap 'xor pair(e1, ap 'xor pair(e2, e3))  .    
  
 rl [assoc-and-l] :
    ap 'and pair(e1, ap 'and pair(e2, e3)) 
    => 
    ap 'and pair(ap 'and pair(e1, e2), e3) .  
       
 rl [assoc-and-r] :
    ap 'and pair(ap 'and pair(e1, e2), e3)
    => 
    ap 'and pair(e1, ap 'and pair(e2, e3))  .    
 )
 
 *** lemma 
 
 rl [comm-xor] : 
    return(ap 'xor pair(e1, e2)) => return(ap 'xor pair(e2, e1)) .
 
 strat applyCommXor : ChannelName @ ProtocolConfig .
 sd applyCommXor(cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCommXor(cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P cn, 
                             P1:Protocol <- keepOne P cn]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{comm-xor}}
                             or-else
                             CONG-REACT-family[C:Qid <- cn]{cong-nf{comm-xor}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{comm-xor}}
                             or-else
                             CONG-REACT-family[C:Qid <- cn]{cong-nf{comm-xor}}
                      )
             )
 .
 
 eq ap 'xor pair(e1, ap 'neg e2) = ap 'neg (ap 'xor pair(e1, e2)) .
 
 eq ap 'xor pair(ap 'xor pair(e1, e2), e2) = e1 .
 eq ap 'xor pair(e1, ap 'xor pair(e1, e2)) = e2 . 
 eq ap 'xor pair(e1, ap 'xor pair(e2, e1)) = e2 .
 
 rl [swap-23-xor] :
    return (ap 'xor pair(ap 'xor pair(e1, e2),
                         ap 'xor pair(e3, e4)
                        )
           )
    => 
    return (ap 'xor pair(ap 'xor pair(e1, e3),
                         ap 'xor pair(e2, e4)
                        )
           )       
 . 
 
 strat applySwap23Xor : ChannelName @ ProtocolConfig .
 sd applySwap23Xor(cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySwap23Xor(cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P cn, 
                             P1:Protocol <- keepOne P cn]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{swap-23-xor}}
                             or-else
                             CONG-REACT-family[C:Qid <- cn]{cong-nf{swap-23-xor}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{swap-23-xor}}
                             or-else
                             CONG-REACT-family[C:Qid <- cn]{cong-nf{swap-23-xor}}
                      )
             )
 .         

 var xa ya xb yb ba : Expression .

 *** lemma 
 rl [and-xor-term] :
 return (ap 'xor pair(ap 'xor pair(ap 'and pair(xa, ya), ba), 
                     ap 'xor pair(ap 'xor pair(ba, 
                                                ap 'xor pair(ap 'and pair(xa, yb), 
                                                             ap 'and pair(xb, ya))
                                              ), 
                                 ap 'and pair(xb, yb)
                                 )
                    )
       )
=> 
return (ap 'xor pair( ap 'xor pair( ap 'and pair(xa, ya),
                                    ap 'and pair(xa, yb)
                                  ), 
                                  
                      ap 'xor pair(ap 'and pair(xb, ya),
                                   ap 'and pair(xb, yb)
                                  )            
                    )
       ) 
 .  
 
 strat applyAndXorTerm : ChannelName @ ProtocolConfig .
 sd applyAndXorTerm(cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAndXorTerm(cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P cn, 
                             P1:Protocol <- keepOne P cn]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{and-xor-term}}
                             or-else
                             CONG-REACT-family[C:Qid <- cn]{cong-nf{and-xor-term}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{and-xor-term}}
                             or-else
                             CONG-REACT-family[C:Qid <- cn]{cong-nf{and-xor-term}}
                      )
             )
 .  
 
 rl [distrib-r] : 
 return (ap 'xor pair( ap 'xor pair( ap 'and pair(xa, ya),
                                    ap 'and pair(xa, yb)
                                  ), 
                                  
                      ap 'xor pair(ap 'and pair(xb, ya),
                                   ap 'and pair(xb, yb)
                                  )            
                    )
       ) 
  => 
  return (ap 'and pair(ap 'xor pair(xa, xb),
                       ap 'xor pair(ya, yb))
         )              
 .   
 
 strat applyDistribR : ChannelName @ ProtocolConfig .
 sd applyDistribR(cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDistribR(cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P cn, 
                             P1:Protocol <- keepOne P cn]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{distrib-r}}
                             or-else
                             CONG-REACT-family[C:Qid <- cn]{cong-nf{distrib-r}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{distrib-r}}
                             or-else
                             CONG-REACT-family[C:Qid <- cn]{cong-nf{distrib-r}}
                      )
             )
 .       

 *** x1 + x2 * x3 = x1 * x3 + x2 * x3
 
  eq ap 'and pair(ap 'xor pair(x1, x2), x3) =
     ap 'xor pair(ap 'and pair(x1, x3), ap 'and pair(x2, x3)) .
     
 *** x + x = False
 
 *** eq ap 'xor pair(x, x) = False .  
 
 var e : Expression .
 
 eq ap 'xor pair(e, e) = False .
 *** TODO: would it make sense to do this for all axioms?
 
 *** x + False = x
 
  eq ap 'xor pair(x, False) = x . 
  
 *** x + True = not x
 
 eq ap 'xor pair(x, True) = ap 'neg x . 
 
 *** x * False = False
 eq ap 'and pair(x, False) = False .    
 
  *** x * True = x
 eq ap 'and pair(x, True) = x .
 
 *** False + x = x
 
  eq ap 'xor pair(False, x) = x . 
 
 *** True + x = not x
 
 eq ap 'xor pair(e1, True) = ap 'neg e1 .
 
 *** rl [xor-not-l] :  ap 'xor pair(e1, True) => ap 'neg e1 . 
 *** rl [xor-not-r] :  ap 'neg e1 => ap 'xor pair(e1, True) .
  
 *** False * x = False
 eq ap 'and pair(False, x) = False .    
 
  *** True * x = x
 eq ap 'and pair(True, x) = x .
 
  *** xor distrib over and
  eq (ap 'xor pair(ap 'and pair(e1, ap 'xor pair(e3, e4)), 
                   ap 'and pair(e2, ap 'xor pair(e3, e4))
                  )
    )
    =
    ap 'and pair( ap 'xor pair(e1, e2),
                  ap 'xor pair(e3, e4)
                )
  .               
 
 rl [flip-invar-xor-r] : rConfig(Sigma, Delta, Gamma (x : bool),
            y : bool <- samp ('flip < () >) ; 
            return (ap 'xor pair(x, y)), I, A, bool
            )
            => 
            rConfig(Sigma, Delta , Gamma (x : bool),
            samp ('flip < () >), I, A, bool) .  
            
 rl [flip-invar-xor-l] : rConfig(Sigma, Delta, Gamma (y : bool),
            x : bool <- samp ('flip < () >) ; 
            return (ap 'xor pair(x, y)), I, A, bool
            )
            => 
            rConfig(Sigma, Delta , Gamma (y : bool),
            samp ('flip < () >), I, A, bool) .
                       
 *** induction proof 1
 strat shareOTInd @ ProtocolConfig .
 sd shareOTInd := 
       applyDropName('BobOK)
     *** first we remove the group name, then we will add it back in a sym proof
     ; applySubstChannelCase3(
         'OTBitOK-A-B, 'OTBitOK-B-A['B ++ 1], 
         nf('ba : bool <- read ('OTBit-A-B['B ++ 1]), return (), 'ba :: emptyCNameList), 
         nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
                   ('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
                   ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
                   ('ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])) 
                   ('yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])), 
                   return (), 
                   'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList), 
         apply 'isAndGate ('B ++ 1)
       ) 
     ; applySubstChannelCase3(
            'ShareOK-A, 
            'OTBitOK-B-A['B ++ 1], 
             nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)]), 
                return (), 'xa :: emptyCNameList),
          nf( ('ba : bool <- read ('OTBit-A-B['B ++ 1]))
              ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
              ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
              ('ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])) 
              ('yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])), 
               return (), 
               'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList
            ),
            apply 'isAndGate ('B ++ 1)
        ) 
     ; applySubstChannelCase3(
            'ShareOK-B, 
            'OTBitOK-B-A['B ++ 1], 
             nf('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
                return (), 'xb :: emptyCNameList),
          nf( ('ba : bool <- read ('OTBit-A-B['B ++ 1]))
              ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
              ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
              ('ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])) 
              ('yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])), 
               return (), 
               'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList
            ),
            apply 'isAndGate ('B ++ 1)
        ) 
        ; applyBranch1Alpha('OTBitOK-B-A['B ++ 1], 
                           << 'xa, 'sa >> emptyQidPairList) 
        ; applySubstChannelCase3(
            'ShareOK-A, 
            'OTBitOK-B-A['B ++ 1], 
             nf('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
                return (), 'xa :: emptyCNameList),
          nf( ('ba : bool <- read ('OTBit-A-B['B ++ 1]))
              ('sa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
              ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
              ('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
              ('yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])), 
               return (), 
               'ba :: 'sa :: 'xa :: 'xb :: 'yb :: emptyCNameList
            ),
            apply 'isAndGate ('B ++ 1)
        ) 
        ; applyBranch1Alpha('OTBitOK-B-A['B ++ 1], 
                           << 'xa, 'ya >> 
                           << 'sa, 'xa >>
                           << 'xb, 'sb >> emptyQidPairList) 
        ; applySubstChannelCase3(
            'ShareOK-B, 
            'OTBitOK-B-A['B ++ 1], 
             nf('xb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
                return (), 'xb :: emptyCNameList),
             nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
                ('sb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
                ('xb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)])) 
                 'ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
                 return (),
                'ba :: 'xa :: 'ya :: 'sb :: 'xb :: emptyCNameList),
            apply 'isAndGate ('B ++ 1)
        )  
        ; applyBranch1Alpha('OTBitOK-B-A['B ++ 1], 
                           << 'xb, 'yb >> 
                           << 'sb, 'xb >> emptyQidPairList)                    
        ; SYM[P1:Protocol <- new3OT]{
           applySubstFamiliesOneCases1('OTBit-B-A, 'OTBitOK-B-A['B ++ 1], unit, 'ot)
          } 
        ****
        **** from here it's the second part of the induction
        ****
        ; CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B ++ 1]]
          { *** isAliceInput
            substNFFamilyOne('InputShareOK-B-A, 'ShareOK-B['B ++ 1],
           nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 ('B ++ 1)]), return (), 
              'xb :: emptyCNameList)
          )
          ; SYM[P1:Protocol <- new3OTInd]{
            substNFFamilyOne('Share-B, 'ShareOK-B['B ++ 1],
       nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 ('B ++ 1)])) 
       'x : unit <- read ('InputShareOK-B-A[fun 'wire0 ('B ++ 1)]), 
       return 'is, 'x :: 'is :: emptyCNameList)
      )
      ;
      substNFFamilyOne('InputShareOK-B-A, 'ShareOK-B['B ++ 1],
       nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 ('B ++ 1)]), return (), 
     'xb :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'is, 'xb >> emptyQidPairList)
          }
          , CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B ++ 1]]{
       *** isBobInput
           substNFFamilyOne('InputShareOK-B-B, 'ShareOK-B['B ++ 1],
           nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 ('B ++ 1)]), return (), 
              'xb :: emptyCNameList)
          )
          ; SYM[P1:Protocol <- new3OTInd]{
              substNFFamilyOne('Share-B, 'ShareOK-B['B ++ 1],
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 ('B ++ 1)])) 
       'x : unit <- read ('InputShareOK-B-B[fun 'wire0 ('B ++ 1)]), 
       return 'is, 'x :: 'is :: emptyCNameList)
      )
      ;
      substNFFamilyOne('InputShareOK-B-B, 'ShareOK-B['B ++ 1],
       nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 ('B ++ 1)]), return (), 
     'xb :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'is, 'xb >> emptyQidPairList)
            }
          , 
          CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B ++ 1]]{
       *** isNotGate
       substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
        nf('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), return (), 'xb :: emptyCNameList)
       )
       ; SYM[P1:Protocol <- new3OTInd]{
         substNFFamilyOne('Share-B, 'ShareOK-B['B ++ 1],
       nf(('x : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
           'xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
           return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
      )
      ;
      substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
       nf( 'xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
           return (), 'xb :: emptyCNameList)
      ) 
       }
       , CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B ++ 1]]{
       *** isXorGate
         substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
          nf('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
             return (), 'xb :: emptyCNameList)
         )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xb, 'is >> emptyQidPairList)
       ; substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
          nf('xb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
             return (), 'xb :: emptyCNameList)
         )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], 
                         << 'xb, 'yb >> 
                         << 'is, 'xb >>
                         emptyQidPairList) 
       ; SYM[P1:Protocol <- new3OTInd]{
         substNFFamilyOne('Share-B, 'ShareOK-B['B ++ 1],
      
      nf(('x : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
         ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
         ('y : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])) 
          'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
          return (ap 'xor pair('xb, 'yb)), 
          'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
      )
      ;
       substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
       nf( 'xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
           return (), 'xb :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xb, 'is >> emptyQidPairList)
      ;
       substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
       nf( 'xb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
           return (), 'xb :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xb, 'yb >> 
                                            << 'is, 'xb >> emptyQidPairList)
      ; changeOrder('ShareOK-B['B ++ 1], 'xb :: 'yb :: emptyCNameList) 
       }                    
       ,
                         
        CASE-DISTINCTION-channel-end-when{
         *** isAndGate 
         substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
          nf('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
             return (), 'xb :: emptyCNameList)
         )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xb, 'is >> emptyQidPairList)
       ; substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
          nf('xb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
             return (), 'xb :: emptyCNameList)
         )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], 
                         << 'xb, 'yb0 >> 
                         << 'is, 'xb0 >>
                         emptyQidPairList)  
                             
       ; substNFFamilyOne('OTBitOK-B-A, 'ShareOK-B['B ++ 1],
          nf('bb : bool <- read ('OTBit-B-A['B ++ 1]), return (), 
             'bb :: emptyCNameList)
         )
       ; SYM[P1:Protocol <- new3OTInd]{
         substNFFamilyOne('Share-B, 'ShareOK-B['B ++ 1],
       nf(('b : unit <- read ('OTBitOK-B-A[('B ++ 1)])) 
          ('bb : bool <- read ('OTBit-B-A[('B ++ 1)])) 
          ('x : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
          ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
          ('y : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])) 
           'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
           return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
           'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
      )
      ;
      substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
       nf( 'xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
           return (), 'xb :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xb, 'is >> emptyQidPairList)
      ;
       substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
       nf( 'xb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
           return (), 'xb :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xb, 'yb0 >> 
                                            << 'is, 'xb0 >> emptyQidPairList)
      ; substNFFamilyOne('OTBitOK-B-A, 'ShareOK-B['B ++ 1],
          nf('bb : bool <- read ('OTBit-B-A['B ++ 1]), return (), 'bb ::
    emptyCNameList)
         )
    ; changeOrder( 'ShareOK-B['B ++ 1],
        'bb :: 'xb0 :: 'yb0 :: emptyCNameList
       )
       }
        }         
       }               
       }
       }
       }
       ; applyAllSameCases('ShareOK-B['B ++ 1])
       ; SYM[P1:Protocol <- new3OTIndEnd] {
         applyDropName('BobOK)
       }
 .             
            
 *** subst with cases strategies
 
 strat applySubstFamiliesOneCases1 : Qid ChannelName Type Qid @ ProtocolConfig .
 sd applySubstFamiliesOneCases1(C, q[nt], T, x) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstFamiliesOneCases1(C, q[nt], T, x)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C (q[nt]), 
                             P1:Protocol <- keepTwo P C (q[nt])]
                             {
      subst-families-one-cases
         {applyCasesSubstChannelDivergeOwise(q[nt], C[nt], T, x)}
        }
 .           
            
 *** induction strategies
 
 strat bigInduction @ ProtocolConfig .
 sd bigInduction := 
   SYM[P1:Protocol <- restr16GIndEnd5]{
        applyAllSameCases('Wire['B ++ 1]) 
       }
     ; applyDropName('Group)
    *** for alice input   
    ;  applySubstChannelCase3(
            'Share-A, 
            'Wire['B ++ 1], 
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)]),
                return 'is, 'is :: emptyCNameList),
             nf(('is : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)])) 
                 'xb : bool <- read ('Share-B['B ++ 1]), 
                 return (ap 'xor pair('is, 'xb)), 'is :: 'xb :: emptyCNameList),
            apply 'isAliceInput ('B ++ 1)
        )
     ; applyAlphaBranchCond('Wire['B ++ 1], 'is, 'xa, 
                           when (apply 'isAliceInput ('B ++ 1)))
     *** bob input                           
    ;  applySubstChannelCase3(
            'Share-A, 
            'Wire['B ++ 1], 
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)]),
                return 'is, 'is :: emptyCNameList),
             nf(('is : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)])) 
                 'xb : bool <- read ('Share-B['B ++ 1]), 
                 return (ap 'xor pair('is, 'xb)), 'is :: 'xb :: emptyCNameList),
            apply 'isBobInput ('B ++ 1)
        ) 
      ; applyAlphaBranchCond('Wire['B ++ 1], 'is, 'xa, 
                           when (apply 'isBobInput ('B ++ 1))) 
    *** not gate  
    ;  applySubstChannelCase3(
            'Share-A, 
            'Wire['B ++ 1], 
             nf('sa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)]), 
                return 'sa, 'sa :: emptyCNameList)   ,
             nf(('sa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
                 'xb : bool <- read ('Share-B['B ++ 1]), 
                 return (ap 'xor pair('sa, 'xb)), 'sa :: 'xb :: emptyCNameList),
            apply 'isNotGate ('B ++ 1)
        )                       
     ; applyAlphaBranchCond('Wire['B ++ 1], 'sa, 'xa, 
                           when (apply 'isNotGate ('B ++ 1)))
     *** xor gate  
    ;  applySubstChannelCase3(
            'Share-A, 
            'Wire['B ++ 1], 
             nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])), 
                 return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList)  ,
             nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
                 'xb : bool <- read ('Share-B['B ++ 1]), 
                 return (ap 'xor pair((ap 'xor pair('xa, 'ya)), 'xb)), 
                 'ya :: 'xa :: 'xb :: emptyCNameList),
            apply 'isXorGate ('B ++ 1)
        )                       
     *** and gate
    ;  applySubstChannelCase3(
            'Share-A, 
            'Wire['B ++ 1], 
             nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])), 
                return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
                'ba :: 'xa :: 'ya :: emptyCNameList) ,
             nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]))
                 'xb : bool <- read ('Share-B['B ++ 1]), 
                 return (ap 'xor pair((ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 'xb)), 
                 'ba :: 'ya :: 'xa :: 'xb :: emptyCNameList),
            apply 'isAndGate ('B ++ 1)
        )                     
    *** now for Share-B      
    ; CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B ++ 1]]{
       applySelectCaseSubst(
         'Share-B['B ++ 1], 'Wire['B ++ 1], apply 'isAliceInput ('B ++ 1)
       )
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B ++ 1]]{
       applySelectCaseSubst(
         'Share-B['B ++ 1], 'Wire['B ++ 1], apply 'isBobInput ('B ++ 1)
       )
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B ++ 1]]{
       applySelectCaseSubst(
         'Share-B['B ++ 1], 'Wire['B ++ 1], apply 'isNotGate ('B ++ 1)
       )
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B ++ 1]]{
       applySelectCaseSubst(
         'Share-B['B ++ 1], 'Wire['B ++ 1], apply 'isXorGate ('B ++ 1)
       )
      , CASE-DISTINCTION-channel-end-when[cn:ChannelName <- 'Wire['B ++ 1]]{
        applySelectCaseSubst(
         'Share-B['B ++ 1], 'Wire['B ++ 1], apply 'isAndGate ('B ++ 1)
       )
    }
        }}}
     } 
     *** renamings
    ; applyAlphaBranchCond('Wire['B ++ 1], 'is, 'xb, 
                           when (apply 'isAliceInput ('B ++ 1)))      
    ; applyAlphaBranchCond('Wire['B ++ 1], 'is, 'xb, 
                           when (apply 'isBobInput ('B ++ 1))) 
                           
    *** now we handle the Share-B[B+1] part
    ; SYM[P1:Protocol <- restr16GIndSymShare]{
     applyDropName('Group)
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'xa, 'ya, 
                           when (apply 'isAliceInput ('B ++ 1))
                         )
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'xa, 'ya, 
                           when (apply 'isBobInput ('B ++ 1))
                         )  
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'xa, 'ya, 
                           when (apply 'isNotGate ('B ++ 1))
                         )                                            
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'xa, 'za, 
                           when (apply 'isXorGate ('B ++ 1))
                         )  
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'xa, 'za, 
                           when (apply 'isAndGate ('B ++ 1))
                         )
                        
   
    ; CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B ++ 1]]{
       applySelectCaseSubst(
         'Wire['B ++ 1], 'Share-B['B ++ 1], apply 'isAliceInput ('B ++ 1)
      ),
      CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B ++ 1]]{
       applySelectCaseSubst(
         'Wire['B ++ 1], 'Share-B['B ++ 1], apply 'isBobInput ('B ++ 1)
      ),
      CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B ++ 1]]{
       applySelectCaseSubst(
         'Wire['B ++ 1], 'Share-B['B ++ 1], apply 'isNotGate ('B ++ 1)
      ),
      CASE-DISTINCTION-channel[cn:ChannelName <- 'Share-B['B ++ 1]]{
       applySelectCaseSubst(
         'Wire['B ++ 1], 'Share-B['B ++ 1], apply 'isXorGate ('B ++ 1)
      ),
      CASE-DISTINCTION-channel-end-when[cn:ChannelName <- 'Share-B['B ++ 1]]{
        applySelectCaseSubst(
         'Wire['B ++ 1], 'Share-B['B ++ 1], apply 'isAndGate ('B ++ 1)
        )
      }
    }
    }
    }
    }  
    *** for alice input
   ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B ++ 1], 
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)]),
                return 'is, 'is :: emptyCNameList),
             nf(('is : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)])) 
                 'xb : bool <- read ('InputShare-B-A[fun 'wire0 ('B ++ 1)]), 
                 return (ap 'xor pair('is, ap 'xor pair('is, 'xb))), 
                 'is :: 'xb :: emptyCNameList),
            apply 'isAliceInput ('B ++ 1)
        ) 
   *** get to what we want
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'is, 'xa, 
                           when (apply 'isAliceInput ('B ++ 1))
                         )  
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'xb, 'is, 
                           when (apply 'isAliceInput ('B ++ 1))
                         )  
   *** for bob input  
   ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B ++ 1], 
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)]),
                return 'is, 'is :: emptyCNameList),
             nf(('is : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)])) 
                ('xb : bool <- read ('InputShare-B-B[fun 'wire0 ('B ++ 1)])),
                 return (ap 'xor pair('is, ap 'xor pair('is, 'xb))), 
                 'is :: 'xb :: emptyCNameList),
            apply 'isBobInput ('B ++ 1)
        ) 
   *** some renamings
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'is, 'xa, 
                           when (apply 'isBobInput ('B ++ 1))
                         )  
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'xb, 'is, 
                           when (apply 'isBobInput ('B ++ 1))  
                         )  
   *** for not gate
    ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B ++ 1], 
             nf('sa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)]), 
                return 'sa, 'sa :: emptyCNameList),
             nf(('sa : bool <- read ('Share-A[fun 'wire0 'B ++ 1])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'B ++ 1])), 
                return (ap 'xor pair('sa, ap 'xor pair('sa, ap 'neg 'xb))), 
                'sa :: 'xb :: emptyCNameList),
            apply 'isNotGate ('B ++ 1)
        )      
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'sa, 'xa, 
                           when (apply 'isNotGate ('B ++ 1))
                         )       
   *** for xor gate
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'xa, 'aa, 
                           when (apply 'isXorGate ('B ++ 1))
                         )
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'ya, 'ba, 
                           when (apply 'isXorGate ('B ++ 1))
                         ) 
   ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B ++ 1], 
             nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
                 'ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
                 return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList),
             nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
                ('yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)])), 
                return (ap 'xor pair('xb, 'yb)),
                'xa :: 'ya :: 'yb :: 'xb :: emptyCNameList),
             apply 'isXorGate ('B ++ 1)
        )                       
   *** change the order to 'xb :: 'xa :: 'yb :: 'ya 
   ; applyChangeOrderBranch(
       'Share-B['B ++ 1], 
       apply 'isXorGate ('B ++ 1), 
       'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList
     )   
   *** for and gate
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'ba, 'bc, 
                           when (apply 'isAndGate ('B ++ 1))
                         )                         
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'xa, 'xc, 
                           when (apply 'isAndGate ('B ++ 1))
                         )                         
   ; applyAlphaBranchCond('Share-B['B ++ 1], 'ya, 'yc, 
                           when (apply 'isAndGate ('B ++ 1))
                         )                         
   ;  applySubstChannelCase3(
            'Share-A, 
            'Share-B['B ++ 1], 
             nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
                 'ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
                 return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
                 'ba :: 'xa :: 'ya :: emptyCNameList), 
             nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
                ('bb : bool <- read ('OTBit-B-A['B ++ 1])) 
                ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
                ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
                 return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
                 'ba :: 'xa :: 'ya :: 'bb :: 'yb :: 'xb :: emptyCNameList),
             apply 'isAndGate ('B ++ 1)
        )    
   *** change order to 'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList 
   ; applyChangeOrderBranch(
       'Share-B['B ++ 1], 
       apply 'isAndGate ('B ++ 1), 
       'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList
     )
    
      }  
     ; applyAllSameCases('Share-B['B ++ 1])
     
     *** now we have to get back to Wire['B ++ 1]
    ; CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B ++ 1]]{ 
        *** alice               
        substNFFamilyOne('InputShare-B-A, 'Wire['B ++ 1],
           nf(('x : bool <- read ('In-A[fun 'wire0 ('B ++ 1)])) 
               'xa : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)]), 
               return (ap 'xor pair('x, 'xa)), 'x :: 'xa :: emptyCNameList)
          )
        ; applyDropNFCF('InputShare-A-A, 'Wire['B ++ 1]) 
        ; applyAlphaNFPr('Wire['B ++ 1], << 'x, 'inA0 >> emptyQidPairList ) 
        ; SYM[P1:Protocol <- restr16GSymAlice]{idle}
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B ++ 1]]{  
        *** bob            
        substNFFamilyOne('InputShare-B-B, 'Wire['B ++ 1],
           nf(('x : bool <- read ('In-B[fun 'wire0 ('B ++ 1)])) 
               'xa : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)]), 
               return (ap 'xor pair('x, 'xa)), 'x :: 'xa :: emptyCNameList) 
          )
        ; applyDropNFCF('InputShare-A-B, 'Wire['B ++ 1]) 
        ; applyAlphaNFPr('Wire['B ++ 1], << 'x, 'inB0 >> emptyQidPairList )  
        ; SYM[P1:Protocol <- restr16GSymBob]{idle}
      , CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B ++ 1]]{  
         *** not
         applyDropName('Group)
         ; SYM[P1:Protocol <- restr16GSymNot]{
               applyDropName('Group)
             ; substNFFamilyOne('Wire, 'Wire['B ++ 1],
           nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
         'xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
          )
           }, 
         CASE-DISTINCTION-channel[cn:ChannelName <- 'Wire['B ++ 1]]{  
         *** xor
           applySwap23Xor('Wire['B ++ 1])
          ; applyDropName('Group)
          ; SYM[P1:Protocol <- restr16GSymXor]{
             applyDropName('Group)
    ; substNFFamilyOne('Wire, 'Wire['B ++ 1],
           nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
         'xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
          ) 
    ; applyAlphaNFPr('Wire['B ++ 1], << 'xa, 'ua >> << 'xb, 'ub >> emptyQidPairList )   
    ; substNFFamilyOne('Wire, 'Wire['B ++ 1],
           nf(('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
         'xb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
          )
    ; applyAlphaNFPr('Wire['B ++ 1], 
                             << 'xa, 'ya >> << 'xb, 'yb >>
                             << 'ua, 'xa >> << 'ub, 'xb >> emptyQidPairList )
    ; changeOrder('Wire['B ++ 1], 'xa :: 'yb :: 'ya :: 'xb :: emptyCNameList)    
          }
         ,
         
          *** just a change of order, happens by nfs, and transforming the return, xor
         CASE-DISTINCTION-channel-end-when[cn:ChannelName <- 'Wire['B ++ 1]]{
          *** and
          applySelectCaseSubst(
              'OTBit-B-A['B ++ 1], 'Wire['B ++ 1], apply 'isAndGate ('B ++ 1)
          )
            *** need to transform the return
          ; applyAndXorTerm('Wire['B ++ 1])

          ; applyDropNFCFCases('OTBit-A-B, 'Wire['B ++ 1], apply 'isAndGate 'k) 
          ; applyDistribR('Wire['B ++ 1])
          ; applyDropName('Group)
          ; SYM[P1:Protocol <- restr16GSymAnd] {
            applyDropName('Group)
    ; substNFFamilyOne('Wire, 'Wire['B ++ 1],
           nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
         'xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
          ) 
    ; applyAlphaNFPr('Wire['B ++ 1], << 'xa, 'ua >> << 'xb, 'ub >> emptyQidPairList )   
    ; substNFFamilyOne('Wire, 'Wire['B ++ 1],
           nf(('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
         'xb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
          )
    ; applyAlphaNFPr('Wire['B ++ 1], 
                             << 'xa, 'ya >> << 'xb, 'yb >>
                             << 'ua, 'xa >> << 'ub, 'xb >> emptyQidPairList )
                             
    ; changeOrder('Wire['B ++ 1], 'xa :: 'yb :: 'ya :: 'xb :: emptyCNameList)
          } 
         }
        }}
    }
    }
   
    ; SYM[P1:Protocol <- restr16GIndStart]{idle}
     
     *** ; applyGetChannel('Wire['B ++ 1])

 .
 
 strat apBigInd : Protocol @ ProtocolConfig .
 sd apBigInd(P) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{apBigInd(P)}
     : INDUCTION-P-3[idx:Qid <- 'B,
                    P2:Protocol <- P                      
                   ]
                   { SYM[P1:Protocol <- restr16GIndEnd]{
                       bigInduction
                     }
                   }
     .
 
 strat apIndBobOK : Protocol @ ProtocolConfig .
 sd apIndBobOK(P) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{apIndBobOK(P)}
     : INDUCTION-P-3[idx:Qid <- 'B, 
                    P2:Protocol <- P                      
                   ]
                   {
                   shareOTInd
                   }
     .
     
 strat apIndAliceOK : Protocol @ ProtocolConfig .
 sd apIndAliceOK(P) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{apIndAliceOK(P)}
     : INDUCTION-P-3[idx:Qid <- 'B, 
                    P2:Protocol <- P                      
                   ]
                   {
                   shareOTAliceInd
                   }
     .  
     
 strat apInd78 : Protocol @ ProtocolConfig .
 sd apInd78(P) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{apInd78(P)}
     : INDUCTION-P-3[idx:Qid <- 'B, 
                    P2:Protocol <- P                      
                   ]
                   {
                   induction78
                   }
     .    
     
 strat induction78 @ ProtocolConfig .
 sd induction78 :=
         applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       ; applyDropName('AliceOK)
       *** from here we start the proof
       ; applyDropName('BobOK)
       ; CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B ++ 1]]{
       *** isAliceInput
       substNFFamilyOne('InputShareOK-B-A, 'ShareOK-B['B ++ 1],
           nf('xa : unit <- read ('InputShareOK-A-A[fun 'wire0 ('B ++ 1)]), 
              return 'xa, 
              'xa :: emptyCNameList)
          )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xa, 'is >> emptyQidPairList) 
       ; SYM[P1:Protocol <- new7Ind0]{
          substNFFamilyOne('ShareOK-A, 'ShareOK-B['B ++ 1],
           nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 ('B ++ 1)]), return 'is, 
              'is :: emptyCNameList)
          )
       }
       ,
       CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B ++ 1]]{
       *** isBobInput
        substNFFamilyOne('InputShareOK-B-B, 'ShareOK-B['B ++ 1],
           nf('xa : unit <- read ('InputShareOK-A-B[fun 'wire0 'B ++ 1]), return 'xa, 
              'xa :: emptyCNameList)
          )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xa, 'is >> emptyQidPairList)     
       ; SYM[P1:Protocol <- new7Ind0]{
          substNFFamilyOne('ShareOK-A, 'ShareOK-B['B ++ 1],
           nf('is : unit <- read ('InputShareOK-A-B[fun 'wire0 ('B ++ 1)]), return 'is, 
              'is :: emptyCNameList)
          )
       }
         , CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B ++ 1]]{
       *** isNotGate
        substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]), return 'sa, 
              'sa :: emptyCNameList)
          )
       ; SYM[P1:Protocol <- new7Ind0]{
         substNFFamilyOne('ShareOK-A, 'ShareOK-B['B ++ 1],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]),
           return 'sa, 'sa :: emptyCNameList)
          )
       } 
       , CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-B['B ++ 1]]{
       *** isXorGate
       substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]), return 'sa, 
              'sa :: emptyCNameList)
          )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'sa, 'is >> emptyQidPairList)    
       ; substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), return 'sa, 
              'sa :: emptyCNameList)
          )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'is, 'xa >> 
                                               << 'sa, 'ya >> emptyQidPairList)      
       ; SYM[P1:Protocol <- new7Ind0]{
        substNFFamilyOne('ShareOK-A, 'ShareOK-B['B ++ 1],
           nf(('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
         'ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
         return (), 'xa :: 'ya :: emptyCNameList)
          )
       }                
       , CASE-DISTINCTION-channel-end-when{
         *** isAndGate 
         substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
          nf('sa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]), 
             return 'sa, 'sa :: emptyCNameList)
         )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'sa, 'is >> emptyQidPairList)
       ; substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
          nf('sa : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
             return 'sa, 'sa :: emptyCNameList)
         )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], 
                         << 'sa, 'yb0 >> 
                         << 'is, 'xb0 >>
                         emptyQidPairList)  
       ; applySelectCaseSubst(
          'OTBitOK-B-A['B ++ 1], 'ShareOK-B['B ++ 1], apply 'isAndGate ('B ++ 1)
         )
                         
       
      ; substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
       nf( 'sa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]), 
           return 'sa, 'sa :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'sa, 'is >> emptyQidPairList)
      ;
       substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
       nf( 'sa : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
           return 'sa, 'sa :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'sa, 'ya >> 
                                            << 'is, 'xa >> emptyQidPairList) 
                              
         ; SYM[P1:Protocol <- new7Ind0]{
           substNFFamilyOne('ShareOK-A, 'ShareOK-B['B ++ 1],
            nf(('ba : unit <- read ('OTBitOK-A-B['B ++ 1])) 
               ('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
                'ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
                return (), 'ba :: 'xa :: 'ya :: emptyCNameList)
          ) 
          }
           }}
       }
       }
         }  
       ; applyAllSameCases('ShareOK-B['B ++ 1])    
       *** now the second part of the proof
       ; applySubstChannelCase3(
           'OTBitOK-A-B,
           'OTBitOK-B-A['B ++ 1],
           nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
               'al : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
              return (), 'ak :: 'al :: emptyCNameList),
           nf(
              ('ak : unit <- read ('ShareOK-A[fun 'wire0 'B ++ 1])) 
              ('xb : unit <- read ('ShareOK-B[fun 'wire0 'B ++ 1])) 
              ('al : unit <- read ('ShareOK-A[fun 'wire1 'B ++ 1])) 
               'yb : unit <- read ('ShareOK-B[fun 'wire1 'B ++ 1]), 
               return (), 
               'ak :: 'al :: 'xb :: 'yb :: emptyCNameList),
            apply 'isAndGate ('B ++ 1)  
         )
       ; applySubstChannelCase3(
            'ShareOK-B, 
            'OTBitOK-B-A['B ++ 1], 
             nf('sa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]), 
                return 'sa, 'sa :: emptyCNameList),
             nf( ('sa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
                 ('al : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])) 
                  'yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)]),
                 return (), 
                 'al :: 'sa :: 'yb :: emptyCNameList),
             apply 'isAndGate ('B ++ 1)
        )  
       ; applyBranch1Alpha('OTBitOK-B-A['B ++ 1], << 'sa, 'ak >> emptyQidPairList) 
       ; applySubstChannelCase3(
            'ShareOK-B, 
            'OTBitOK-B-A['B ++ 1], 
             nf('sa : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
                return 'sa, 'sa :: emptyCNameList),
             nf( ('ak : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
                 ('sa : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])),
                 return (), 
                 'ak :: 'sa :: emptyCNameList),
             apply 'isAndGate ('B ++ 1)
        )
       ; applyBranch1Alpha('OTBitOK-B-A['B ++ 1], << 'sa, 'al >> emptyQidPairList) 
       ; SYM[P1:Protocol <- new7IndEnd]{
         applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       ; applyDropName('AliceOK)
       ; applyDropName('BobOK)
       ; applyCasesSubstFC(
           'OTBitOK-A-B, 'OTBitOK-B-A['B ++ 1], 
           nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
               'al : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
               return (), 'ak :: 'al :: emptyCNameList),
           unit, 'ot)
       }  
 .
     
 strat shareOTAliceInd @ ProtocolConfig .
 sd shareOTAliceInd := 
    applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       ; applyDropName('BobOK)
       *** from here we start the proof
       *** drop AliceOK, we will add it back with sym
       ; applyDropName('AliceOK)
             
       ; applySubstChannelCase3(
            'ShareOK-A, 
            'OTBitOK-A-B['B ++ 1], 
             nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)]), 
                return (), 'xa :: emptyCNameList),
             nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
                 'al : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
                 return (), 
                 'xa :: 'al :: emptyCNameList),
            apply 'isAndGate ('B ++ 1)
        )
        ; applyBranch1Alpha('OTBitOK-A-B['B ++ 1], 
                           << 'xa, 'sa >> emptyQidPairList)
        ; applySubstChannelCase3(
            'ShareOK-A, 
            'OTBitOK-A-B['B ++ 1], 
             nf('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
                return (), 'xa :: emptyCNameList),
             nf(('sa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
                 'xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
                 return (), 
                 'sa :: 'xa :: emptyCNameList),
            apply 'isAndGate ('B ++ 1)
        )  
        ; applyBranch1Alpha('OTBitOK-A-B['B ++ 1], 
                           << 'xa, 'ya >> 
                           << 'sa, 'xa >> emptyQidPairList)   
       
        ; SYM[P1:Protocol <- new5IndInt]{
         applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       ; applyDropName('BobOK)
       *** from here we start the proof
       ; applyDropName('AliceOK)
       ; applyCasesSubsumeDropDivergeOwiseC(
          'OTBit-A-B, 
          'OTBitOK-A-B['B ++ 1], 
          'xa :: 'ya :: emptyCNameList, 
          unit, 'ot
          )
        }
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       ; applyDropName('BobOK)  
       ; applyDropName('AliceOK)
       
       ;
         CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B ++ 1]]{
       *** isAliceInput
       substNFFamilyOne('InputShareOK-A-A, 'ShareOK-A['B ++ 1],
           nf('xa : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)]), 
              return (), 'xa :: emptyCNameList)
          )    
        ; SYM[P1:Protocol <- new5Ind0]{
            substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
            )
          ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'is, 'xa >> emptyQidPairList) 
          } 
          , 
          CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B ++ 1]]{
       *** isBobInput
        substNFFamilyOne('InputShareOK-A-B, 'ShareOK-A['B ++ 1],
           nf('xa : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)]), return (), 
              'xa :: emptyCNameList)
          )
        ; SYM[P1:Protocol <- new5Ind0]{
            substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
            )
            ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'is, 'xa >> emptyQidPairList)
          }  ,
          CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B ++ 1]]{
       *** isNotGate
        substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
          return (), 'xa :: emptyCNameList)
       )
       
       ; SYM[P1:Protocol <- new5Ind0]{
        substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
       nf('sa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
          return 'sa, 'sa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'sa, 'xa >> emptyQidPairList)
       }
       , 
        CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B ++ 1]]{
       *** isXorGate
       substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
       ; changeOrder('ShareOK-A['B ++ 1], 'ya :: 'xa :: emptyCNameList)                   
       ; SYM[P1:Protocol <- new5Ind0]{
          substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
       nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        'ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
        return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList)
      )
       }, CASE-DISTINCTION-channel-end-when{
           
        
         *** isAndGate 
         substNFFamilyOne('OTBitOK-A-B, 'ShareOK-A['B ++ 1],
       nf('ba : bool <- read ('OTBit-A-B['B ++ 1]), return (), 'ba :: emptyCNameList)
       )      
      ; substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
                       
        ; SYM[P1:Protocol <- new5Ind0]{
           substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
       nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
         'ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
     ) 
     ; changeOrder('ShareOK-A['B ++ 1], 'ba :: 'xa :: 'ya :: emptyCNameList) 
        }
        
                      
       }
       
       }
        }
         }
       }  
             
       ; applyAllSameCases('ShareOK-A['B ++ 1])
       ; SYM[P1:Protocol <- new5IndEnd]{
         applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       ; applyDropName('BobOK)  
       ; applyDropName('AliceOK) 
       }
 .         
            
 *** strategies needed for splitting real in three parts
 
 op restr0 : -> Protocol .
 eq restr0 = restrInductive || restrFinal .
 
 strat rewriteRestrInitial @ ProtocolConfig .
 sd rewriteRestrInitial := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestrInitial}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[  *** add this for a speedup: Q:Protocol <- new2NF(restr0), 
                                      P1:Protocol <- new2NF(restrInitial)
                                   ]
                    {
     SYM[P1:Protocol <- restrInitial1]{
         substNFFamiliesOne(
           'InputShare-A-B, 'InputShare-B-B,
           nf('sis : bool <- read ('SendInputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)
       )
     ; substNFFamiliesOne(
           'InputShare-A-B, 'SendInputShare-A-B_A_adv,
           nf('sis : bool <- read ('SendInputShare-A-B['k]), return 'sis, 'sis :: emptyCNameList)
       )
     ; substNFFamiliesOne(
           'InputShare-B-A, 'SendInputShare-B-A_A_adv,
           nf('sis : bool <- read ('SendInputShare-B-A['k]), return 'sis, 'sis :: emptyCNameList)
       )
     ; applyAlphaNFPr('InputShare-B-B, << 'sis,'xa >> emptyQidPairList)  
    }
      ; foldNFFamily('SendInputShare-A-B, 'InputShare-A-B)
      ; foldNFFamily('SendInputShare-B-A, 'InputShare-B-A)
                    }
 .
 
 strat rewriteRestrInductive @ ProtocolConfig .
  sd rewriteRestrInductive := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestrInductive}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[  *** Q:Protocol <- new2NF(restr0), 
                                      P1:Protocol <- new2NF(restrInductive)
                                   ]
                    { 
         sugar-newNF
       ; applyDropName('A)
       ; applyDropName('B)
       ; applyDropName('1OutOf4OT)
       ; applyCasesSubstDivergeOwise(
          'OTMsg-A-B-0, 'OTMsg-A-B-0_ot_adv, 'k, bool, 'x3
        )
      ; applyCasesSubstDivergeOwise(
          'OTMsg-A-B-1, 'OTMsg-A-B-1_ot_adv, 'k, bool, 'x3
        )
      ; applyCasesSubstDivergeOwise(
          'OTMsg-A-B-2, 'OTMsg-A-B-2_ot_adv, 'k, bool, 'x3
        )
      ; applyCasesSubstDivergeOwise(
          'OTMsg-A-B-3, 'OTMsg-A-B-3_ot_adv, 'k, bool, 'x3
        )  
      ; applyCasesSubstDivergeOwise(
          'OTChoice-B-A-0, 'OTChoiceRcvd-B-A-0_ot_adv, 'k, unit, 'x3
        )
      ; applyCasesSubstDivergeOwise(
          'OTChoice-B-A-1, 'OTChoiceRcvd-B-A-1_ot_adv, 'k, unit, 'x3
        )    
      *** now we want to substitute in OTOut-B-A only for and gates
      *** so we need to add this case distinction
      ; applyAddSameCases('OTOut-B-A, apply 'isAndGate 'k)
      *** now we can do the substitution on first branch
      ; applySameCasesSubstFirstBranch('OTMsg-A-B-0, 'OTOut-B-A, 'k)      
      ; applySameCasesSubstFirstBranch('OTMsg-A-B-1, 'OTOut-B-A, 'k)
      ; applySameCasesSubstFirstBranch('OTMsg-A-B-2, 'OTOut-B-A, 'k)
      ; applySameCasesSubstFirstBranch('OTMsg-A-B-3, 'OTOut-B-A, 'k)
      ; applySameCasesSubstFirstBranch('OTChoice-B-A-0, 'OTOut-B-A, 'k)
      ; applyBranch1Alpha('OTOut-B-A, << 'sb, 'xb >> emptyQidPairList)
      ; applySameCasesSubstFirstBranch('OTChoice-B-A-1, 'OTOut-B-A, 'k)
      ; applyBranch1Alpha('OTOut-B-A, << 'sb, 'yb >> emptyQidPairList)
      ; applyIfExt2('OTOut-B-A,
                    return (ap 'xor pair('ba, 
                                 ap 'xor pair(ap 'and pair('xa, 'yb), 
                                              ap 'and pair('xb, 'ya)
                                             )
                                 )
                           ), 
                     'xb, 'yb)
      ; applySameCasesSubstFirstBranch('OTOut-B-A, 'OTBit-B-A, 'k)  
      ; SYM[P1:Protocol <- restrIndSplit]{
         sugar-newNF
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       ; applyDropName('ind1OutOf4OT)
      }
      ; sugar-newNF  
      ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       ; applyDropName('ind1OutOf4OT)
       ; absorbFamily('OTOut-B-A) 
       ; absorbFamily('OTMsg-A-B-0)
       ; absorbFamily('OTMsg-A-B-1)  
       ; absorbFamily('OTMsg-A-B-2)
       ; absorbFamily('OTMsg-A-B-3)
       ; absorbFamily('OTChoice-B-A-0)
       ; absorbFamilyDeleteEmpty('OTChoice-B-A-1)
      
     ***  here I need to do a sym proof from the protocol without the 4th component
      ; SYM[P1:Protocol <- restrIndSplitSym]{
         applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       
       }  
       ; SYM[P1:Protocol <- restrIndSplitSymNew]{
          sugar-newNF
        ; absorbFamily('InOK-A)
        ; absorbFamily('InOK-B)
        ; absorbFamily('InputShareOK-A-A)
        ; absorbFamily('InputShareOK-A-B)
        ; absorbFamily('InputShareOK-B-A)
        ; absorbFamily('InputShareOK-B-B)
        ; absorbFamily('OTBitOK-A-B)
        ; absorbFamily('OTBitOK-B-A)
        ; absorbFamily('ShareOK-A)
        ; absorbFamilyDeleteEmpty('ShareOK-B)
      } 
      ; sugar-newNF
      ; applyDropName('indAlice)
      ; applyDropName('indBob)
      ; applyDropName('indAdv)
      ***
      ; SYM[P1:Protocol <- restrIndSplitSymNew1]{
         sugar-newNF
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       ; applySubstFamilyCase(
                   'ShareOK-B, 
                   'OTChoiceRcvd-B-A-0_ot_adv,
                   'k,
                   nf('xb : bool <- read ('Share-B[fun 'wire0 'k]), 
                      return (), 'xb :: emptyCNameList)
                )
       ; applyBranch1Alpha('OTChoiceRcvd-B-A-0_ot_adv, 
                           << 'xb, 'sb >> emptyQidPairList)   
       ; applySubstFamilyCase(
                   'ShareOK-B, 
                   'OTChoiceRcvd-B-A-1_ot_adv,
                   'k,
                   nf('xb : bool <- read ('Share-B[fun 'wire1 'k]), 
                      return (), 'xb :: emptyCNameList)
                )
       ; applyBranch1Alpha('OTChoiceRcvd-B-A-1_ot_adv, 
                           << 'xb, 'sb >> emptyQidPairList)                                
      }   
      ; SYM[P1:Protocol <- new2]{
         sugar-newNF
        ; applyDropName('indBob)
         ; applySubstFamilyCase3('InputShareOK-B-A, 'Share-B, 'k,
          nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 'k]), 
             return (), 'xb :: emptyCNameList),
          nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 'k]), 
             return 'xb, 'xb :: emptyCNameList),
          apply 'isAliceInput 'k      
          )
        *** ; applyAlphaBranchCond('Share-B, 'xb, 'is, when (apply 'isAliceInput 'k))   
        ; applySubstFamilyCase3('InputShareOK-B-B, 'Share-B, 'k,
          nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 'k]), 
             return (), 'xb :: emptyCNameList),
          nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 'k]), 
             return 'xb, 'xb :: emptyCNameList),
          apply 'isBobInput 'k      
          ) 
        ; applyAlphaBranchCond('Share-B, 'xb, 'is, when (apply 'isNotGate 'k))  
        ; applySubstFamilyCase3('ShareOK-B, 'Share-B, 'k,
             nf('xb : bool <- read ('Share-B[fun 'wire0 'k]), 
                return (), 'xb :: emptyCNameList),
          nf('xb : bool <- read ('Share-B[fun 'wire0 'k]), 
             return (ap 'neg 'xb), 'xb :: emptyCNameList),
          apply 'isNotGate 'k      
          )
        ; applySubstFamilyCase3('ShareOK-B, 'Share-B, 'k,
             nf('xb : bool <- read ('Share-B[fun 'wire0 'k]), 
                return (), 'xb :: emptyCNameList),
          nf( ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
              ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
               'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
               return (ap 'xor pair('xb, 'yb)), 
               'xb :: 'yb :: 'y :: emptyCNameList),
          apply 'isXorGate 'k      
          )
        ; applyAlphaBranchCond('Share-B, 'xb, 'a, when (apply 'isXorGate 'k)) 
        ; applySubstFamilyCase3('ShareOK-B, 'Share-B, 'k,
             nf('xb : bool <- read ('Share-B[fun 'wire1 'k]), 
                return (), 'xb :: emptyCNameList),
          nf( ('a : bool <- read ('Share-B[fun 'wire0 'k])) 
               'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
               return (ap 'xor pair('a, 'yb)), 
               'a :: 'yb :: emptyCNameList),
          apply 'isXorGate 'k      
          )
         ; applyAlphaBranchCond('Share-B, 'a, 'xb, when (apply 'isXorGate 'k))
         
         ; applySubstFamilyCase3('OTBitOK-B-A, 'Share-B, 'k,
             nf('bb : bool <- read ('OTBit-B-A['k]), return (), 'bb :: emptyCNameList),
             nf(('bb : bool <- read ('OTBit-B-A['k])) 
                ('x : unit <- read ('ShareOK-B[fun 'wire0 'k])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
                ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
                 return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
                 'bb :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList),
          apply 'isAndGate 'k      
          )
          ; applySubstFamilyCase3('ShareOK-B, 'Share-B, 'k,
             nf('xb : bool <- read ('Share-B[fun 'wire0 'k]), 
                return (), 'xb :: emptyCNameList),
             nf(('bb : bool <- read ('OTBit-B-A['k])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
                ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
                 return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
                 'bb :: 'xb :: 'yb :: 'y :: emptyCNameList),
          apply 'isAndGate 'k      
          ) 
          ; applyAlphaBranchCond('Share-B, 'xb, 'a, when (apply 'isAndGate 'k)) 
          ; applySubstFamilyCase3('ShareOK-B, 'Share-B, 'k,
             nf('xb : bool <- read ('Share-B[fun 'wire1 'k]), 
                return (), 'xb :: emptyCNameList),
             nf(('bb : bool <- read ('OTBit-B-A['k])) 
                ('a : bool <- read ('Share-B[fun 'wire0 'k])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
                 return (ap 'xor pair('bb, ap 'and pair('a, 'yb))), 
                 'bb :: 'a :: 'yb :: emptyCNameList),
          apply 'isAndGate 'k      
          )
          ; applyAlphaBranchCond('Share-B, 'a, 'xb, when (apply 'isAndGate 'k)) 
          ; SYM[P1:Protocol <- restrIndSplitSymNew1]{
              sugar-newNF
            ; applyDropName('indBob)
            ; applyAlphaBranchCond('Share-B, 'is, 'xb, when (apply 'isAliceInput 'k))
            ; applyAlphaBranchCond('Share-B, 'is, 'xb, when (apply 'isBobInput 'k))  
          }
          }
          ; sugar-newNF
          ; applyDropName('indAlice)
          ; applyDropName('indBob)
          ; applyDropName('indAdv)
          ; SYM[P1:Protocol <- new3]{
            sugar-newNF
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       ; apIndBobOK(
         
   (family 'OTBitOK-B-A 'k (bound K) ::= 
     nf('bb : bool <- read ('OTBit-B-A['k]), 
        return (), 'bb :: emptyCNameList)
   )
   ||
   (family 'ShareOK-B 'k (bound K) ::=
     nf('xb : bool <- read ('Share-B['k]), 
         return (), 'xb :: emptyCNameList)
   )
       )
       ; applyDropName('BobOK)
          }
         

                    }    *** end of cong comp right          
     .           
  
  strat rewriteRestrFinal @ ProtocolConfig .
  sd rewriteRestrFinal := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestrFinal}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[  *** Q:Protocol <- new2NF(restr0), 
                                      P1:Protocol <- new2NF(restrFinal)
                                   ]
                    { 
        applyCasesSubstDivergeOwise('SendFinalShare-A, 'Out-A, 'k, bool, 'x3)
      ; applySameCasesSubstFirstBranch('SendFinalShare-B, 'Out-A, 'k)
      ; applyCasesSubstDivergeOwise('SendFinalShare-A, 'Out-B, 'k, bool, 'x3)
      ; applySameCasesSubstFirstBranch('SendFinalShare-B, 'Out-B, 'k) 
      ; applyCasesSubstDivergeOwise('SendFinalShare-A, 'SendFinalShare-A_A_adv, 'k, bool, 'x3)
      ; applyCasesSubstDivergeOwise('SendFinalShare-B, 'SendFinalShare-B_A_adv, 'k, bool, 'x3)
      ; absorbFamily('SendFinalShare-A)
      ; absorbFamilyDeleteEmpty('SendFinalShare-B)
      *** TODO: might have to do some alphas here!
                    }
    . 
    
    *** other strategies and helpers
    
    *** induction base 1
    
    strat indBase1 @ ProtocolConfig .
    sd indBase1 := 
         applyCaseDistChannel1('ShareOK-B[0])
       ; applyAllSameCases('ShareOK-B[0])

    .
    
    strat indStep1 @ ProtocolConfig .
    sd indStep1 := 
        applyCaseDistChannel2('ShareOK-B['B ++ 1])
    .   
    
    strat applyInd1 @ ProtocolConfig .
    sd applyInd1 := 
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyInd1}
     : INDUCTION-when-one[
        C:Qid <- 'ShareOK-B,
        idx:Qid <- 'B,
        cases':Cases <-
           nf('xb : bool <- read ('Share-B['k]), return (), 'xb :: emptyCNameList)
                         ]
        {
        indBase1                 
        ,   
        indStep1          
        }
     .
    
    strat applyIndA1 @ ProtocolConfig .
    sd applyIndA1 := 
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyIndA1}
     : INDUCTION-when-one[
        C:Qid <- 'ShareOK-A,
        idx:Qid <- 'B,
        cases':Cases <-
           nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
                         ]
        {
        indBaseA1                 
        ,   
        indStepA1          
        }
     .
    
    *** indB1
     
    strat applyIndB1 @ ProtocolConfig .
    sd applyIndB1 := 
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyIndB1}
     : INDUCTION-when-one[
        C:Qid <- 'ShareOK-B,
        idx:Qid <- 'B,
        cases':Cases <-
           nf('sa : unit <- read ('ShareOK-A['k]), return 'sa, 'sa :: emptyCNameList)
                         ]
        {
        indBaseB1                 
        ,   
        indStepB1          
        }
     . 
     
    strat indBaseB1 @ ProtocolConfig .
    sd indBaseB1 := 
         applyCaseDistChannelBaseB('ShareOK-B[0])
       ; applyAllSameCases('ShareOK-B[0])

    .
    
    strat indStepB1 @ ProtocolConfig .
    sd indStepB1 := 
        applyCaseDistChannelStepB('ShareOK-B['B ++ 1])
    . 
    
    strat applyCaseDistChannelBaseB : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelBaseB(cn) :=
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelBaseB(cn)}
     : CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
        *** proof for alice goes here
        substNFFamilyOne('InputShareOK-B-A, 'ShareOK-B[0],
           nf('xa : unit <- read ('InputShareOK-A-A[fun 'wire0 0]), return 'xa, 
              'xa :: emptyCNameList)
          )
       ; applyAlphaNFPr('ShareOK-B[0], << 'xa, 'is >> emptyQidPairList)     
       ; SYM[P1:Protocol <- new7base]{
          substNFFamilyOne('ShareOK-A, 'ShareOK-B[0],
           nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 0]), return 'is, 
              'is :: emptyCNameList)
          )
       }
        ,
        CASE-DISTINCTION-channel-end-when{
          *** proof for bob goes here
        substNFFamilyOne('InputShareOK-B-B, 'ShareOK-B[0],
           nf('xa : unit <- read ('InputShareOK-A-B[fun 'wire0 0]), return 'xa, 
              'xa :: emptyCNameList)
          )
       ; applyAlphaNFPr('ShareOK-B[0], << 'xa, 'is >> emptyQidPairList)     
       ; SYM[P1:Protocol <- new7base]{
          substNFFamilyOne('ShareOK-A, 'ShareOK-B[0],
           nf('is : unit <- read ('InputShareOK-A-B[fun 'wire0 0]), return 'is, 
              'is :: emptyCNameList)
          )
       }  
        }
       }
     .  
     
    strat applyCaseDistChannelStepB : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelStepB(cn) :=
     match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelStepB(cn)}
     : ( *** open for :
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isAliceInput
       substNFFamilyOne('InputShareOK-B-A, 'ShareOK-B['B ++ 1],
           nf('xa : unit <- read ('InputShareOK-A-A[fun 'wire0 ('B ++ 1)]), return 'xa, 
              'xa :: emptyCNameList)
          )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xa, 'is >> emptyQidPairList)     
       ; SYM[P1:Protocol <- new7step]{
          substNFFamilyOne('ShareOK-A, 'ShareOK-B['B ++ 1],
           nf('is : unit <- read ('InputShareOK-A-A[fun 'wire0 ('B ++ 1)]), return 'is, 
              'is :: emptyCNameList)
          )
       }
       , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isBobInput
        substNFFamilyOne('InputShareOK-B-B, 'ShareOK-B['B ++ 1],
           nf('xa : unit <- read ('InputShareOK-A-B[fun 'wire0 'B ++ 1]), return 'xa, 
              'xa :: emptyCNameList)
          )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xa, 'is >> emptyQidPairList)     
       ; SYM[P1:Protocol <- new7step]{
          substNFFamilyOne('ShareOK-A, 'ShareOK-B['B ++ 1],
           nf('is : unit <- read ('InputShareOK-A-B[fun 'wire0 ('B ++ 1)]), return 'is, 
              'is :: emptyCNameList)
          )
       }
         , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isNotGate
        substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]), return 'sa, 
              'sa :: emptyCNameList)
          )
       ; SYM[P1:Protocol <- new7step]{
         substNFFamilyOne('ShareOK-A, 'ShareOK-B['B ++ 1],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]),
           return 'sa, 'sa :: emptyCNameList)
          )
       } 
       , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isXorGate
       substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]), return 'sa, 
              'sa :: emptyCNameList)
          )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'sa, 'is >> emptyQidPairList)    
       ; substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
           nf('sa : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), return 'sa, 
              'sa :: emptyCNameList)
          )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'is, 'xa >> 
                                               << 'sa, 'ya >> emptyQidPairList)      
       ; SYM[P1:Protocol <- new7step]{
        substNFFamilyOne('ShareOK-A, 'ShareOK-B['B ++ 1],
           nf(('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
         'ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
         return (), 'xa :: 'ya :: emptyCNameList)
          )
       }                
       , 
       CASE-DISTINCTION-channel-end-when{
         *** isAndGate 
         substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
          nf('sa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]), 
             return 'sa, 'sa :: emptyCNameList)
         )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'sa, 'is >> emptyQidPairList)
       ; substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
          nf('sa : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
             return 'sa, 'sa :: emptyCNameList)
         )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], 
                         << 'sa, 'yb0 >> 
                         << 'is, 'xb0 >>
                         emptyQidPairList)  
       ; substNFFamilyOne('OTBitOK-B-A, 'ShareOK-B['B ++ 1],
          nf(('ba : unit <- read ('OTBitOK-A-B[('B ++ 1)])) 
             ('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
             ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
             ('ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])) 
              'yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)]), 
              return (),
              'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList
            ) 
         )
      ; substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
       nf( 'sa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)]), 
           return 'sa, 'sa :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'sa, 'is >> emptyQidPairList)
      ;
       substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
       nf( 'sa : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
           return 'sa, 'sa :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'sa, 'ya >> 
                                            << 'is, 'xa >> emptyQidPairList)   
         ; SYM[P1:Protocol <- new7step]{
           substNFFamilyOne('ShareOK-A, 'ShareOK-B['B ++ 1],
            nf(('ba : unit <- read ('OTBitOK-A-B['B ++ 1])) 
               ('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
                'ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
                return (), 'ba :: 'xa :: 'ya :: emptyCNameList)
          ) 
          }                 
       }}}}}
       ; applyAllSameCases(cn)
       ) *** end for :
     . 
    
    *** indC
    
    strat applyIndC @ ProtocolConfig .
    sd applyIndC := 
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyIndC}
     : INDUCTION-when-one[
        C:Qid <- 'ShareOK-A,
        idx:Qid <- 'B,
        cases':Cases <-
           nf('xa : bool <- read ('Share-A['k]), return (), 'xa :: emptyCNameList)
                         ]
        {
        indBaseC                 
        ,   
        indStepC          
        }
     .
     
    strat indBaseC @ ProtocolConfig .
    sd indBaseC := 
         applyCaseDistChannelBaseC('ShareOK-A[0])
       ; applyAllSameCases('ShareOK-A[0])

    .
    
    strat applyCaseDistChannelBaseC : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelBaseC(cn) :=
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelBaseC(cn)}
     : CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
        substNFFamilyOne('InputShareOK-A-A, 'ShareOK-A[0],
           nf('xa : bool <- read ('InputShare-A-A[fun 'wire0 0]), return (), 
              'xa :: emptyCNameList)
          ) 
        ; SYM[P1:Protocol <- new10base]{
            substNFFamilyOne('Share-A, 'ShareOK-A[0],
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 0]), 
             return 'is, 'is :: emptyCNameList)
            )
           ; applyAlphaNFPr('ShareOK-A[0], << 'is, 'xa >> emptyQidPairList) 
          }  
        ,
        CASE-DISTINCTION-channel-end-when{
          substNFFamilyOne('InputShareOK-A-B, 'ShareOK-A[0],
           nf('xa : bool <- read ('InputShare-A-B[fun 'wire0 0]), return (), 
              'xa :: emptyCNameList)
          )
        ; SYM[P1:Protocol <- new10base]{
            substNFFamilyOne('Share-A, 'ShareOK-A[0],
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 0]), 
             return 'is, 'is :: emptyCNameList)
            )
            ; applyAlphaNFPr('ShareOK-A[0], << 'is, 'xa >> emptyQidPairList)
          }  
        }
       }
     .  
    
    
    strat indStepC @ ProtocolConfig .
    sd indStepC := 
        applyCaseDistChannelStepC('ShareOK-A['B ++ 1])
    .
    
    strat applyCaseDistChannelStepC : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelStepC(cn) :=
     match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelStepC(cn)}
     : ( *** open for :
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isAliceInput
       substNFFamilyOne('InputShareOK-A-A, 'ShareOK-A['B ++ 1],
           nf('xa : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)]), 
              return (), 'xa :: emptyCNameList)
          )
        ; SYM[P1:Protocol <- new10step]{
            substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
            )
           ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'is, 'xa >> emptyQidPairList) 
          }  , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isBobInput
        substNFFamilyOne('InputShareOK-A-B, 'ShareOK-A['B ++ 1],
           nf('xa : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)]), return (), 
              'xa :: emptyCNameList)
          )
        ; SYM[P1:Protocol <- new10step]{
            substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
            )
            ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'is, 'xa >> emptyQidPairList)
          }  , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isNotGate
        substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; SYM[P1:Protocol <- new10step]{
        substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
       nf('sa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
       return 'sa, 'sa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'sa, 'xa >> emptyQidPairList)
       }, 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isXorGate
       substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
       ; changeOrder('ShareOK-A['B ++ 1], 'ya :: 'xa :: emptyCNameList)                   
       ; SYM[P1:Protocol <- new10step]{
          substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
       nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        'ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
        return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList)
      )
       }                
       , 
       CASE-DISTINCTION-channel-end-when{
         *** isAndGate 
         substNFFamilyOne('OTBitOK-A-B, 'ShareOK-A['B ++ 1],
       nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
        'al : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
        return (), 'ak :: 'al :: emptyCNameList)
       )
      ; substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
        *** ; changeOrder('ShareOK-A['B ++ 1], 'xa :: 'ya :: emptyCNameList)                 
        ; SYM[P1:Protocol <- new10step]{
           substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
       nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
         'ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
     ) 
     ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'xa, 'xa1 >> << 'ya, 'ya1 >> emptyQidPairList)
     ; applySubsumeFamilyCasesChannelList
          ('OTBit-A-B, 'ShareOK-A['B ++ 1], 'xa :: 'ya :: emptyCNameList)
     ; applyDropFamilyCasesChannel('OTBit-A-B, 'ShareOK-A['B ++ 1])
        }                
       }}}}}
       ; applyAllSameCases('ShareOK-A['B ++ 1])
       ) *** end for :
     . 
     
    *** indD
    
    strat applyIndD @ ProtocolConfig .
    sd applyIndD := 
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyIndD}
     : INDUCTION-when-one[
        C:Qid <- 'Share-B,
        idx:Qid <- 'B,
        cases':Cases <-
           nf(('xa : bool <- read ('Share-A['k])) 
               'x : bool <- read ('Wire['k]), 
              return (ap 'xor pair('xa, 'x)), 
              'xa :: 'x :: emptyCNameList)
                         ]
        {
        indBaseD                 
        ,   
        indStepD          
        }
     .
     
    strat indBaseD @ ProtocolConfig .
    sd indBaseD := 
         applyCaseDistChannelBaseD('Share-B[0])
       ; applyAllSameCases('Share-B[0])

    .
    
    strat applyCaseDistChannelBaseD : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelBaseD(cn) :=
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelBaseD(cn)}
     : CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
        *** for Alice
        idle
        ,
        CASE-DISTINCTION-channel-end-when{
          *** for Bob
          idle
        }
       }
     .  
    
    
    strat indStepD @ ProtocolConfig .
    sd indStepD := 
        applyCaseDistChannelStepD('Share-B['B ++ 1])
    .
    
    strat applyCaseDistChannelStepD : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelStepD(cn) :=
     match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelStepD(cn)}
     : ( *** open for :
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isAliceInput
       idle  , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isBobInput
        idle , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isNotGate
        idle , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isXorGate
       idle              
       , 
       CASE-DISTINCTION-channel-end-when{
         *** isAndGate 
         idle               
       }}}}}
       ; applyAllSameCases('Share-B['B ++ 1])
       ) *** end for :
     .  
    
    *** ind A1 
    strat indBaseA1 @ ProtocolConfig .
    sd indBaseA1 := 
         applyCaseDistChannelA1('ShareOK-A[0])
       ; applyAllSameCases('ShareOK-A[0])

    .
    
    strat indStepA1 @ ProtocolConfig .
    sd indStepA1 := 
        applyCaseDistChannelA2('ShareOK-A['B ++ 1])
    .
    
    strat applyCaseDistChannelA1 : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelA1(cn) :=
       match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelA1(cn)}
     : CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
        substNFFamilyOne('InputShareOK-A-A, 'ShareOK-A[0],
           nf('xa : bool <- read ('InputShare-A-A[fun 'wire0 0]), return (), 
              'xa :: emptyCNameList)
          ) 
        ; SYM[P1:Protocol <- new5base]{
            substNFFamilyOne('Share-A, 'ShareOK-A[0],
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 0]), 
             return 'is, 'is :: emptyCNameList)
            )
           ; applyAlphaNFPr('ShareOK-A[0], << 'is, 'xa >> emptyQidPairList) 
          }  
        ,
        CASE-DISTINCTION-channel-end-when{
          substNFFamilyOne('InputShareOK-A-B, 'ShareOK-A[0],
           nf('xa : bool <- read ('InputShare-A-B[fun 'wire0 0]), return (), 
              'xa :: emptyCNameList)
          )
        ; SYM[P1:Protocol <- new5base]{
            substNFFamilyOne('Share-A, 'ShareOK-A[0],
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 0]), 
             return 'is, 'is :: emptyCNameList)
            )
            ; applyAlphaNFPr('ShareOK-A[0], << 'is, 'xa >> emptyQidPairList)
          }  
        }
       }
     .  
    
    strat applyCaseDistChannel1 : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannel1(cn) :=
     match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannel1(cn)}
     : CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
          substNFFamilyOne('InputShareOK-B-A, 'ShareOK-B[0],
           nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 0]), return (), 
              'xb :: emptyCNameList)
          )
          ; SYM[P1:Protocol <- new3Base0]{ 
            substNFFamilyOne('Share-B, 'ShareOK-B[0],
       nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 0])) 
       'x : unit <- read ('InputShareOK-B-A[fun 'wire0 0]), 
       return 'is, 'x :: 'is :: emptyCNameList)
      )
      ;
      substNFFamilyOne('InputShareOK-B-A, 'ShareOK-B[0],
       nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 0]), return (), 
     'xb :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B[0], << 'is, 'xb >> emptyQidPairList)
          }
          ,
          CASE-DISTINCTION-channel-end-when{
            substNFFamilyOne('InputShareOK-B-B, 'ShareOK-B[0],
           nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 0]), return (), 
              'xb :: emptyCNameList)
          )
          ; SYM[P1:Protocol <- new3Base0]{ 
            substNFFamilyOne('Share-B, 'ShareOK-B[0],
       nf(( 'is : bool <- read ('InputShare-B-B[fun 'wire0 0])) 
            'x : unit <- read ('InputShareOK-B-B[fun 'wire0 0]), 
            return 'is, 'x :: 'is :: emptyCNameList)
      )
     ;
      substNFFamilyOne('InputShareOK-B-B, 'ShareOK-B[0],
       nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 0]), return (), 
          'xb :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B[0], << 'is, 'xb >> emptyQidPairList)
          }
          }
       }
    .
    
    strat applyCaseDistChannelA2 : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannelA2(cn) :=
     match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannelA2(cn)}
     : ( *** open for :
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isAliceInput
       substNFFamilyOne('InputShareOK-A-A, 'ShareOK-A['B ++ 1],
           nf('xa : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)]), 
              return (), 'xa :: emptyCNameList)
          )
        ; SYM[P1:Protocol <- new5step]{
            substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
            )
           ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'is, 'xa >> emptyQidPairList) 
          }  , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isBobInput
        substNFFamilyOne('InputShareOK-A-B, 'ShareOK-A['B ++ 1],
           nf('xa : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)]), return (), 
              'xa :: emptyCNameList)
          )
        ; SYM[P1:Protocol <- new5step]{
            substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
            )
            ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'is, 'xa >> emptyQidPairList)
          }  , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isNotGate
        substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; SYM[P1:Protocol <- new5step]{
        substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
       nf('sa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
       return 'sa, 'sa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'sa, 'xa >> emptyQidPairList)
       }, 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isXorGate
       substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
       ; changeOrder('ShareOK-A['B ++ 1], 'ya :: 'xa :: emptyCNameList)                   
       ; SYM[P1:Protocol <- new5step]{
          substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
       nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        'ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
        return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList)
      )
       }                
       , 
       CASE-DISTINCTION-channel-end-when{
         *** isAndGate 
         substNFFamilyOne('OTBitOK-A-B, 'ShareOK-A['B ++ 1],
       nf(('ak : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
        'al : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
        return (), 'ak :: 'al :: emptyCNameList)
       )
      ; substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
        *** ; changeOrder('ShareOK-A['B ++ 1], 'xa :: 'ya :: emptyCNameList)                 
        ; SYM[P1:Protocol <- new5step]{
           substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
       nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
         'ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
     ) 
     ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'xa, 'xa1 >> << 'ya, 'ya1 >> emptyQidPairList)
     ; applySubsumeFamilyCasesChannelList
          ('OTBit-A-B, 'ShareOK-A['B ++ 1], 'xa :: 'ya :: emptyCNameList)
     ; applyDropFamilyCasesChannel('OTBit-A-B, 'ShareOK-A['B ++ 1])
        }                
       }}}}}
       ; applyAllSameCases('ShareOK-A['B ++ 1])
       ) *** end for :
     .  
    
    strat applyCaseDistChannel2 : ChannelName @ ProtocolConfig .
    sd applyCaseDistChannel2(cn) :=
     match pConf s.t. startsWithNew pConf 
     ? CONG-NEW-NF{applyCaseDistChannel2(cn)}
     : ( *** open for :
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isAliceInput
       substNFFamilyOne('InputShareOK-B-A, 'ShareOK-B['B ++ 1],
           nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 ('B ++ 1)]), return (), 
              'xb :: emptyCNameList)
          )
          ; SYM[P1:Protocol <- new3Ind0]{ 
            substNFFamilyOne('Share-B, 'ShareOK-B['B ++ 1],
       nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 ('B ++ 1)])) 
       'x : unit <- read ('InputShareOK-B-A[fun 'wire0 ('B ++ 1)]), 
       return 'is, 'x :: 'is :: emptyCNameList)
      )
      ;
      substNFFamilyOne('InputShareOK-B-A, 'ShareOK-B['B ++ 1],
       nf('xb : bool <- read ('InputShare-B-A[fun 'wire0 ('B ++ 1)]), return (), 
     'xb :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'is, 'xb >> emptyQidPairList)
      }
      , 
       CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isBobInput
       substNFFamilyOne('InputShareOK-B-B, 'ShareOK-B['B ++ 1],
           nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 ('B ++ 1)]), return (), 
              'xb :: emptyCNameList)
          )
          ; SYM[P1:Protocol <- new3Ind0]{ 
            substNFFamilyOne('Share-B, 'ShareOK-B['B ++ 1],
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 ('B ++ 1)])) 
       'x : unit <- read ('InputShareOK-B-B[fun 'wire0 ('B ++ 1)]), 
       return 'is, 'x :: 'is :: emptyCNameList)
      )
      ;
      substNFFamilyOne('InputShareOK-B-B, 'ShareOK-B['B ++ 1],
       nf('xb : bool <- read ('InputShare-B-B[fun 'wire0 ('B ++ 1)]), return (), 
     'xb :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'is, 'xb >> emptyQidPairList)
      }
      , 
      CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isNotGate
       substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
        nf('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), return (), 'xb :: emptyCNameList)
       )
       ; SYM[P1:Protocol <- new3Ind0]{ 
       substNFFamilyOne('Share-B, 'ShareOK-B['B ++ 1],
       nf(('x : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
           'xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
           return (ap 'neg 'xb), 'x :: 'xb :: emptyCNameList)
      )
      ;
      substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
       nf( 'xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
           return (), 'xb :: emptyCNameList)
      )
      } 
       , CASE-DISTINCTION-channel[cn:ChannelName <- cn]{
       *** isXorGate
         substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
          nf('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
             return (), 'xb :: emptyCNameList)
         )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xb, 'is >> emptyQidPairList)
       ; substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
          nf('xb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
             return (), 'xb :: emptyCNameList)
         )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], 
                         << 'xb, 'yb >> 
                         << 'is, 'xb >>
                         emptyQidPairList)  
       *** now comes the sym proof!
       ; SYM[P1:Protocol <- new3Ind0]{ 
        substNFFamilyOne('Share-B, 'ShareOK-B['B ++ 1],
      
      nf(('x : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
         ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
         ('y : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])) 
          'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
          return (ap 'xor pair('xb, 'yb)), 
          'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
      )
      ;
       substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
       nf( 'xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
           return (), 'xb :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xb, 'is >> emptyQidPairList)
      ;
       substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
       nf( 'xb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
           return (), 'xb :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xb, 'yb >> 
                                            << 'is, 'xb >> emptyQidPairList)
      ; changeOrder('ShareOK-B['B ++ 1], 'xb :: 'yb :: emptyCNameList) 
       }
       , 
       CASE-DISTINCTION-channel-end-when{
         *** isAndGate 
         substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
          nf('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
             return (), 'xb :: emptyCNameList)
         )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xb, 'is >> emptyQidPairList)
       ; substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
          nf('xb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
             return (), 'xb :: emptyCNameList)
         )
       ; applyAlphaNFPr('ShareOK-B['B ++ 1], 
                         << 'xb, 'yb0 >> 
                         << 'is, 'xb0 >>
                         emptyQidPairList)  
       ; substNFFamilyOne('OTBitOK-B-A, 'ShareOK-B['B ++ 1],
          nf(('ba : unit <- read ('OTBitOK-A-B[('B ++ 1)])) 
             ('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
             ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
             ('ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])) 
              'yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)]), 
              return (),
              'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList
         ) 
         )
      ; substNFFamilyOne('OTBitOK-A-B, 'ShareOK-B['B ++ 1],  
         nf('ba : bool <- read ('OTBit-A-B['B ++ 1]), return (), 'ba :: emptyCNameList)
      )
      ; substNFFamilyOne('ShareOK-A, 'ShareOK-B['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)]), 
          return (), 'xa :: emptyCNameList)
       ) 
    ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xa, 'is >> emptyQidPairList)         
    ; substNFFamilyOne('ShareOK-A, 'ShareOK-B['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
          return (), 'xa :: emptyCNameList)
       ) 
    ; applyAlphaNFPr('ShareOK-B['B ++ 1],  
       << 'is, 'sa0 >>
       << 'xa, 'sa1 >>
       << 'xb, 'so0 >>
       << 'xb0, 'sb0 >>
       << 'yb, 'so1 >>
       << 'yb0, 'sb1 >>
        emptyQidPairList) 
        *** here comes the sym proof
    ; SYM[P1:Protocol <- new3Ind0]{
      substNFFamilyOne('Share-B, 'ShareOK-B['B ++ 1],
       nf(('b : unit <- read ('OTBitOK-B-A[('B ++ 1)])) 
          ('bb : bool <- read ('OTBit-B-A[('B ++ 1)])) 
          ('x : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
          ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
          ('y : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)])) 
           'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
           return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
           'bb :: 'b :: 'xb :: 'x :: 'yb :: 'y :: emptyCNameList)
      )
      ;
      substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
       nf( 'xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)]), 
           return (), 'xb :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xb, 'is >> emptyQidPairList)
      ;
       substNFFamilyOne('ShareOK-B, 'ShareOK-B['B ++ 1],
       nf( 'xb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
           return (), 'xb :: emptyCNameList)
      )
      ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xb, 'yb0 >> 
                                            << 'is, 'xb0 >> emptyQidPairList)
      ; substNFFamilyOne('OTBitOK-B-A, 'ShareOK-B['B ++ 1],
          nf(('ba : unit <- read ('OTBitOK-A-B[('B ++ 1)])) 
             ('xa : unit <- read ('ShareOK-A[fun 'wire0 ('B ++ 1)])) 
             ('xb : unit <- read ('ShareOK-B[fun 'wire0 ('B ++ 1)])) 
             ('ya : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)])) 
              'yb : unit <- read ('ShareOK-B[fun 'wire1 ('B ++ 1)]), 
              return (),
              'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList
         ) 
         )
     ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'ba, 'ba1 >> 
                                           << 'xa, 'xa1 >> 
                                           << 'ya, 'ya1 >>
                                           << 'xb, 'xb1 >>
                                           << 'yb, 'yb1 >>
                                           emptyQidPairList)
     ; substNFFamilyOne('OTBitOK-A-B, 'ShareOK-B['B ++ 1],
        nf('ba : bool <- read ('OTBit-A-B['B ++ 1]), return (), 'ba :: emptyCNameList)
       )                                     
     ; substNFFamilyOne('OTBit-B-A, 'ShareOK-B['B ++ 1], 
        nf(('ba : bool <- read ('OTBit-A-B[('B ++ 1)])) 
           ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
           ('xb : bool <- read ('Share-B[fun 'wire0 ('B ++ 1)])) 
           ('ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)])) 
            'yb : bool <- read ('Share-B[fun 'wire1 ('B ++ 1)]), 
            return (ap 'xor pair('ba, ap 'xor pair(ap 'and pair('xa, 'yb), 
                                                   ap 'and pair('xb, 'ya)))),
           'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
     )
     ; substNFFamilyOne('ShareOK-A, 'ShareOK-B['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)]), 
          return (), 'xa :: emptyCNameList)
       ) 
    ; applyAlphaNFPr('ShareOK-B['B ++ 1], << 'xa, 'is >> emptyQidPairList)         
    ; substNFFamilyOne('ShareOK-A, 'ShareOK-B['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
          return (), 'xa :: emptyCNameList)
       )
    ; applyAlphaNFPr('ShareOK-B['B ++ 1],  
        << 'is, 'sa0 >>
        << 'xb, 'sb0 >>
        << 'xb1, 'so0 >>
        << 'xa, 'sa1 >>
        << 'yb, 'sb1 >>
        << 'yb1, 'so1 >>
        emptyQidPairList)
    ; changeOrder( 'ShareOK-B['B ++ 1],
       'ba :: 'sa0 :: 'sa1 :: 'so0 :: 'so1 :: 'sb0 :: 'sb1 :: emptyCNameList) 
    }                          
       }
       }
      }
      }
     }
     ; applyAllSameCases('ShareOK-B['B ++ 1])
     ) *** close for :
     .
   
   *** rewrite new4, new induction
  strat rewriteRestr2Induction @ ProtocolConfig .
  sd rewriteRestr2Induction := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestr2Induction}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[
                                      P1:Protocol <- new2NF(new4)
                                   ]
                    {
     SYM[P1:Protocol <- new5]{              
       sugar-newNF
    
     ; apIndAliceOK(
   (family 'OTBitOK-A-B 'k (bound K) ::= 
     nf('ba : bool <- read ('OTBit-A-B['k]), 
        return (), 'ba :: emptyCNameList)
   )
   ||
   (family 'ShareOK-A 'k (bound K) ::=
     nf('xa : bool <- read ('Share-A['k]), 
        return (), 'xa :: emptyCNameList)
   )
      )
    ; applyDropName('AliceOK)}
                    }
     .  
     
      *** rewrite new7, new induction
  strat rewriteRestr6Induction @ ProtocolConfig .
  sd rewriteRestr6Induction := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestr6Induction}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[
                                      P1:Protocol <- new2NF(new7)
                                   ]
                    {              
       ***sugar-newNF
    
      apInd78(  
   (family 'OTBitOK-B-A 'k (bound K) ::= 
      nf('ot : unit <- read ('OTBitOK-A-B['k]), 
                      return 'ot,
                      'ot :: emptyCNameList)
   )
   ||
   (family 'ShareOK-B 'k (bound K) ::=
     nf('sa : unit <- read ('ShareOK-A['k]), 
        return 'sa,
        'sa :: emptyCNameList)
   )
      )
    ; applyDropName('BobOK)
                    }
     .    
     
   *** rewrite new10, new induction
  strat rewriteRestr9Induction @ ProtocolConfig .
  sd rewriteRestr9Induction := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestr9Induction}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[
                                      P1:Protocol <- new2NF(new10)
                                   ]
                    {
            
       apInduction910(
   (family 'OTBitOK-A-B 'k (bound K) ::= 
     nf('ba : bool <- read ('OTBit-A-B['k]), 
        return (), 'ba :: emptyCNameList)
   )
   ||
   (family 'ShareOK-A 'k (bound K) ::=
     nf('xa : bool <- read ('Share-A['k]), 
        return (), 'xa :: emptyCNameList)
   )
      )
    ; applyDropName('AliceOK)
                    }
     .  
   
    strat apInduction910 : Protocol @ ProtocolConfig .
    sd apInduction910(P) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{apInduction910(P)}
     : INDUCTION-P-3[idx:Qid <- 'B,
                     C:Qid <- 'AliceOK, 
                    P2:Protocol <- P                      
                   ]
                   {
                   induction910
                   }
     .
     
   strat induction910 @ ProtocolConfig .
   sd induction910 :=
         applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       *** from here we start the proof
       *** drop AliceOK, we will add it back with sym
       ; applyDropName('AliceOK)    
       ; applySubstChannelCase3(
            'ShareOK-A, 
            'OTBitOK-A-B['B ++ 1], 
             nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)]), 
                return (), 'xa :: emptyCNameList),
             nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
                 'al : unit <- read ('ShareOK-A[fun 'wire1 ('B ++ 1)]), 
                 return (), 
                 'xa :: 'al :: emptyCNameList),
            apply 'isAndGate ('B ++ 1)
        )
        ; applyBranch1Alpha('OTBitOK-A-B['B ++ 1], 
                           << 'xa, 'sa >> emptyQidPairList)
        ; applySubstChannelCase3(
            'ShareOK-A, 
            'OTBitOK-A-B['B ++ 1], 
             nf('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
                return (), 'xa :: emptyCNameList),
             nf(('sa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
                 'xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
                 return (), 
                 'sa :: 'xa :: emptyCNameList),
            apply 'isAndGate ('B ++ 1)
        )  
        ; applyBranch1Alpha('OTBitOK-A-B['B ++ 1], 
                           << 'xa, 'ya >> 
                           << 'sa, 'xa >> emptyQidPairList) 
            
        ; SYM[P1:Protocol <- new10IndInt]{
         applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       *** from here we start the proof
       ; applyDropName('AliceOK)
       ; applyCasesSubsumeDropDivergeOwiseC(
          'OTBit-A-B, 
          'OTBitOK-A-B['B ++ 1], 
          'xa :: 'ya :: emptyCNameList, 
          unit, 'ot
          )
        }
          
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       ; applyDropName('AliceOK)
       
       ;
         CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B ++ 1]]{
       *** isAliceInput
       substNFFamilyOne('InputShareOK-A-A, 'ShareOK-A['B ++ 1],
           nf('xa : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)]), 
              return (), 'xa :: emptyCNameList)
          )    
        ; SYM[P1:Protocol <- new10Ind0]{
            substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
             nf('is : bool <- read ('InputShare-A-A[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
            )
          ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'is, 'xa >> emptyQidPairList) 
          } 
          , 
          CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B ++ 1]]{
       *** isBobInput
        substNFFamilyOne('InputShareOK-A-B, 'ShareOK-A['B ++ 1],
           nf('xa : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)]), return (), 
              'xa :: emptyCNameList)
          )
        ; SYM[P1:Protocol <- new10Ind0]{
            substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
             nf('is : bool <- read ('InputShare-A-B[fun 'wire0 ('B ++ 1)]), 
             return 'is, 'is :: emptyCNameList)
            )
            ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'is, 'xa >> emptyQidPairList)
          }  ,
          CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B ++ 1]]{
       *** isNotGate
        substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
          return (), 'xa :: emptyCNameList)
       )
       
       ; SYM[P1:Protocol <- new10Ind0]{
        substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
       nf('sa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
          return 'sa, 'sa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'sa, 'xa >> emptyQidPairList)
       }
       , 
        CASE-DISTINCTION-channel[cn:ChannelName <- 'ShareOK-A['B ++ 1]]{
       *** isXorGate
       substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
       ; changeOrder('ShareOK-A['B ++ 1], 'ya :: 'xa :: emptyCNameList)                   
       ; SYM[P1:Protocol <- new10Ind0]{
          substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
       nf(('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
        'ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
        return (ap 'xor pair('xa, 'ya)), 'xa :: 'ya :: emptyCNameList)
      )
       }, CASE-DISTINCTION-channel-end-when{
           
        
         *** isAndGate 
         substNFFamilyOne('OTBitOK-A-B, 'ShareOK-A['B ++ 1],
       nf('ba : bool <- read ('OTBit-A-B['B ++ 1]), return (), 'ba :: emptyCNameList)
       )      
      ; substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], << 'xa, 'is >> emptyQidPairList)
       ; substNFFamilyOne('ShareOK-A, 'ShareOK-A['B ++ 1],
       nf('xa : bool <- read ('Share-A[fun 'wire1 ('B ++ 1) ]),
       return (), 'xa :: emptyCNameList)
       )
       ; applyAlphaNFPr('ShareOK-A['B ++ 1], 
                         << 'xa, 'ya >> 
                         << 'is, 'xa >>
                         emptyQidPairList)
                       
        ; SYM[P1:Protocol <- new10Ind0]{
           substNFFamilyOne('Share-A, 'ShareOK-A['B ++ 1],
       nf(('ba : bool <- read ('OTBit-A-B['B ++ 1])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 ('B ++ 1)])) 
         'ya : bool <- read ('Share-A[fun 'wire1 ('B ++ 1)]), 
        return (ap 'xor pair(ap 'and pair('xa, 'ya), 'ba)), 
        'ba :: 'xa :: 'ya :: emptyCNameList)
     ) 
     ; changeOrder('ShareOK-A['B ++ 1], 'ba :: 'xa :: 'ya :: emptyCNameList) 
        }
        
                      
       }
       
       }
        }
         }
       }  
             
       ; applyAllSameCases('ShareOK-A['B ++ 1])
       
       ; SYM[P1:Protocol <- new10IndEnd]{
         applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       ; applyDropName('AliceOK) 
       } 
   .             
    
   *** rewrite new4 
  strat rewriteRestr2Inductive @ ProtocolConfig .
  sd rewriteRestr2Inductive := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteRestr2Inductive}
     : 
        matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[  *** Q:Protocol <- new2NF(restr0), 
                                      P1:Protocol <- new2NF(new4)
                                   ]
                    { sugar-newNF
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       ; applyDropName('BobOK)
       ; applyCasesSubsumeDropDivergeOwise(
          'OTBit-A-B, 
          'OTBitOK-A-B, 
          'xa :: 'ya :: emptyCNameList, 
          'k, unit, 'ot)
        *** here we get to new4Int  
       ; SYM[P1:Protocol <- new4Int]{
         sugar-newNF
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       ; applyDropName('BobOK)
       ; applyDropName('AliceOK)
       ; applySubstFamilyCase3(
            'ShareOK-A, 
            'OTBitOK-A-B, 
            'k,
             nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), return (), 'xa :: emptyCNameList),
             nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
                 'al : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
                 return (), 
                 'xa :: 'al :: emptyCNameList),
            apply 'isAndGate 'k
        ) 
        ; applyBranch1Alpha('OTBitOK-A-B, 
                           << 'xa, 'sa >> emptyQidPairList)
        ; applySubstFamilyCase3(
            'ShareOK-A, 
            'OTBitOK-A-B, 
            'k,
             nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), return (), 'xa :: emptyCNameList),
             nf(('sa : bool <- read ('Share-A[fun 'wire0 'k])) 
                 'xa : bool <- read ('Share-A[fun 'wire1 'k]), 
                 return (), 
                 'sa :: 'xa :: emptyCNameList),
            apply 'isAndGate 'k
        )  
        ; applyBranch1Alpha('OTBitOK-A-B, 
                           << 'xa, 'ya >> 
                           << 'sa, 'xa >> emptyQidPairList)   
       }
                    }
     .               
   
           
endsm

*** rewrite real to idealPlusSym

srew [1] 
 pConfig(secSig,
           ('In-A @ N :: bool)
           ('In-B @ M :: bool)          
           ('In-A_A_adv @ N :: bool) 
           ('InRcvd-B_B_adv @ M :: unit) 
           ('InputShare-A-A_A_adv @ N :: bool)
           ('InputShare-A-B_A_adv @ M :: bool) 
           ('OTBit-A-B_A_adv @ K :: bool) 
           ('OTChoice-B-A-0_ot_adv @ K :: unit)
           ('OTChoice-B-A-1_ot_adv @ K :: unit) 
            ('OTChoiceRcvd-B-A-0_ot_adv @ N + M :: unit) 
           ('OTChoiceRcvd-B-A-1_ot_adv @ N + M :: unit)
           ('OTMsg-A-B-0_ot_adv @ K :: bool) 
           ('OTMsg-A-B-1_ot_adv @ K :: bool)
           ('OTMsg-A-B-2_ot_adv @ K :: bool) 
           ('OTMsg-A-B-3_ot_adv @ K :: bool)
           ('Out-A @ K :: bool)
           ('Out-A_A_adv @ K :: bool) 
           ('Out-B @ K :: bool) 
           ('SendFinalShare-A_A_adv @ K :: bool) 
           ('SendFinalShare-B_A_adv @ K :: bool) 
           ('SendInputShare-A-B_A_adv @ M :: bool) 
           ('SendInputShare-B-A_A_adv @ N :: bool) 
           ('Share-A_A_adv @ K :: bool)
           ('OTOut-A-B @ N + M :: bool),
           real,
           insert('In-A @ N, 'In-B @ M), *** I 
           getOutputs(idealPlusSim),
           genA
        )
using     sugar-newNF
        ; moveNewToFront
        ; SYM[P1:Protocol <- restr]{
            sugar-newNF
        ; moveNewToFront
         ; reorder-newNF[ql2:CNameList <- 
        'SendInputShare-A-B :: 'SendInputShare-B-A :: 
        'OTMsg-A-B-0 :: 'OTMsg-A-B-1 :: 'OTMsg-A-B-2 :: 'OTMsg-A-B-3 :: 
        'OTOut-B-A :: 'OTChoice-B-A-0 :: 'OTChoice-B-A-1 :: 
        'SendFinalShare-A :: 'SendFinalShare-B :: 
        'InputShare-A-A :: 'InputShare-A-B :: 
        'OTBit-A-B :: 
        'Share-A :: 'InputShare-B-A :: 'InputShare-B-B :: 'OTBit-B-A :: 
        'Share-B :: emptyCNameList
       ]
        }
        ;  sugar-newNF
        ; rewriteRestrInitial
        ; rewriteRestrInductive
        ; rewriteRestrFinal
        ; desugar-newNF
        *** just to check that we are at restr1
        ; SYM[P1:Protocol <- restr1]{idle}   
        ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; substNFFamiliesOne('InputShare-B-A, 'InputShareOK-B-A,
           nf(('x : bool <- read ('In-A['k])) 
               'xa : bool <- read ('InputShare-A-A['k]), 
               return (ap 'xor pair('x, 'xa)), 'x :: 'xa :: emptyCNameList)       
         )
       ; substNFFamiliesOne('InputShare-B-B, 'InputShareOK-B-B,
           nf(('x : bool <- read ('In-B['k])) 
               'xa : bool <- read ('InputShare-A-B['k]), 
               return (ap 'xor pair('x, 'xa)), 'x :: 'xa :: emptyCNameList)       
         ) 
       *** going to restr2 now  
       ; SYM[P1:Protocol <- restr2]{
         sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; substNFFamiliesOne('InputShareOK-A-A, 'InputShareOK-B-A,
          nf('xa : bool <- read ('InputShare-A-A['k]), return (), 'xa :: emptyCNameList)
         )
       ; substNFFamiliesOne('InOK-A, 'InputShareOK-B-A,
          nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)
         )
       ; substNFFamiliesOne('InputShareOK-A-B, 'InputShareOK-B-B,
          nf('xa : bool <- read ('InputShare-A-B['k]), return (), 'xa :: emptyCNameList)
         )
       ; substNFFamiliesOne('InOK-B, 'InputShareOK-B-B,
          nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
         )
       } 
       ; sugar-newNF
       ; rewriteRestr2Induction
       ; desugar-newNF
       *** recording that we got to restr4
       ; SYM[P1:Protocol <- restr4]{
         idle
       }
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropSubsumeRevFamilies('InputShare-A-A, 'InputShareOK-A-A)
       ; applyDropSubsumeRevFamilies('InputShare-A-B, 'InputShareOK-A-B)       
        *** restr5 
       ; SYM [P1:Protocol <- restr5]{
         sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)

       ; substNFFamiliesOne(
           'InOK-A, 'InputShareOK-A-A,
            nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)       
         )
       ; substNFFamiliesOne(
           'InOK-B, 'InputShareOK-A-B,
            nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)       
         )  
        
       }
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       
       ; substNFFamiliesOne(
           'InputShareOK-A-A, 'InputShareOK-B-A,
            nf('x : unit <- read ('InOK-A['k]), return 'x, 'x :: emptyCNameList)     
         )   
       ; substNFFamiliesOne(
           'InputShareOK-A-B, 'InputShareOK-B-B,
            nf('x : unit <- read ('InOK-B['k]), return 'x, 'x :: emptyCNameList)     
         )
        *** restr6
       ; SYM [P1:Protocol <- restr6]{
         sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; substNFFamiliesOne(
           'InputShareOK-A-A, 'InputShareOK-B-A,
            nf('x : unit <- read ('InOK-A['k]), return 'x, 'x :: emptyCNameList)     
         )  
       ; substNFFamiliesOne(
           'InputShareOK-A-B, 'InputShareOK-B-B,
            nf('x : unit <- read ('InOK-B['k]), return 'x, 'x :: emptyCNameList)     
         ) 
       ; applyReturnUnit('InputShareOK-B-A)         
       ; applyReturnUnit('InputShareOK-B-B) 
       } 
       ; sugar-newNF
       ; rewriteRestr6Induction 
       *** restr8
       ; SYM[P1:Protocol <- restr8]{
         sugar-newNF
       }
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       
       ; substNFFamiliesOne(
           'InOK-A, 'InputShareOK-A-A,
            nf('x : bool <- read ('In-A['k]), return (), 'x :: emptyCNameList)       
         )
       ; substNFFamiliesOne(
           'InOK-B, 'InputShareOK-A-B,
            nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)       
         )  
         *** restr9
       ; SYM[P1:Protocol <- restr9]{
         sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       
       ; applyDropSubsumeRevFamilies('InputShare-A-A, 'InputShareOK-A-A)
       ; applyDropSubsumeRevFamilies('InputShare-A-B, 'InputShareOK-A-B)

       }  
       ; sugar-newNF
       ; rewriteRestr9Induction 
       *** restr10
        ; SYM[P1:Protocol <- restr10]{
          sugar-newNF
        }
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       *** for alice input
       ; applySubstFamilyCase3(
            'InputShareOK-B-A, 
            'Share-B, 
            'k,
             nf('xa : unit <- read ('InputShareOK-A-A[fun 'wire0 'k]), 
                return 'xa, 'xa :: emptyCNameList),
             nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
                 'xa : unit <- read ('InputShareOK-A-A[fun 'wire0 'k]), 
                 return 'is, 'xa :: 'is :: emptyCNameList),
            apply 'isAliceInput 'k
        ) 
       ; applySubstFamilyCase3(
            'InputShareOK-A-A, 
            'Share-B, 
            'k,
             nf('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
                return (), 'xa :: emptyCNameList),
             nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k])) 
                 'xa : bool <- read ('InputShare-A-A[fun 'wire0 'k]), 
                 return 'is, 'xa :: 'is :: emptyCNameList),
            apply 'isAliceInput 'k
        )
        *** for bob input
        ; applySubstFamilyCase3(
            'InputShareOK-B-B, 
            'Share-B, 
            'k,
             nf('xa : unit <- read ('InputShareOK-A-B[fun 'wire0 'k]), 
                return 'xa, 'xa :: emptyCNameList),
             nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
                 'xa : unit <- read ('InputShareOK-A-B[fun 'wire0 'k]), 
                 return 'is, 'xa :: 'is :: emptyCNameList),
            apply 'isBobInput 'k
        ) 
       ; applySubstFamilyCase3(
            'InputShareOK-A-B, 
            'Share-B, 
            'k,
             nf('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
                return (), 'xa :: emptyCNameList),
             nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k])) 
                 'xa : bool <- read ('InputShare-A-B[fun 'wire0 'k]), 
                 return 'is, 'xa :: 'is :: emptyCNameList),
            apply 'isBobInput 'k
        ) 
        *** for not gate
        ; applySubstFamilyCase3(
            'ShareOK-B, 
            'Share-B, 
            'k,
             nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]), 
                return 'sa, 'sa :: emptyCNameList),
             nf(('sa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
                 'xb : bool <- read ('Share-B[fun 'wire0 'k]),
                 return (ap 'neg 'xb), 'sa :: 'xb :: emptyCNameList),
            apply 'isNotGate 'k
        ) 
        ; applySubstFamilyCase3(
            'ShareOK-A, 
            'Share-B, 
            'k,
             nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
                return (), 'xa :: emptyCNameList),
             nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
                 'xb : bool <- read ('Share-B[fun 'wire0 'k]),
                 return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList),
            apply 'isNotGate 'k
        ) 
        *** for xor gate 
        ; applySubstFamilyCase3(
            'ShareOK-B, 
            'Share-B, 
            'k,
             nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]), 
                return 'sa, 'sa :: emptyCNameList),
             nf(('sa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
                ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
                return (ap 'xor pair('xb, 'yb)), 
                'xb :: 'sa :: 'yb :: 'y :: emptyCNameList),
            apply 'isXorGate 'k
        ) 
        ; applyAlphaBranchCond('Share-B, 'sa, 'xa, when (apply 'isXorGate 'k)) 
        ; applySubstFamilyCase3(
            'ShareOK-B, 
            'Share-B, 
            'k,
             nf('sa : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
                return 'sa, 'sa :: emptyCNameList),
             nf(('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
                ('sa : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
                return (ap 'xor pair('xb, 'yb)), 
                'xb :: 'xa :: 'yb :: 'sa :: emptyCNameList),
            apply 'isXorGate 'k
        )   
        ; applyAlphaBranchCond('Share-B, 'sa, 'ya, when (apply 'isXorGate 'k)) 
        ; applySubstFamilyCase3(
            'ShareOK-A, 
            'Share-B, 
            'k,
             nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
                return (), 'xa :: emptyCNameList),
             nf(('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
                ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
                return (ap 'xor pair('xb, 'yb)), 
                'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList),
            apply 'isXorGate 'k
        )  
        ; applyAlphaBranchCond('Share-B, 'xa, 'xa0, when (apply 'isXorGate 'k)) 
        ; applySubstFamilyCase3(
            'ShareOK-A, 
            'Share-B, 
            'k,
             nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
                return (), 'xa :: emptyCNameList),
             nf(('xa0 : bool <- read ('Share-A[fun 'wire0 'k])) 
                ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
                ('xa : bool <- read ('Share-A[fun 'wire1 'k])) 
                 'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
                return (ap 'xor pair('xb, 'yb)), 
                'xb :: 'xa0 :: 'yb :: 'xa :: emptyCNameList),
            apply 'isXorGate 'k
        ) 
        ; applyAlphaBranchCond('Share-B, 'xa, 'ya, when (apply 'isXorGate 'k))
        ; applyAlphaBranchCond('Share-B, 'xa0, 'xa, when (apply 'isXorGate 'k)) 
        *** for and gate
        ; applySubstFamilyCase3(
            'ShareOK-B, 
            'Share-B, 
            'k,
             nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]), 
                return 'sa, 'sa :: emptyCNameList),
             nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('sa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('y : unit <- read ('ShareOK-B[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb :: 'b :: 'xb :: 'sa :: 'yb :: 'y :: emptyCNameList), 
            apply 'isAndGate 'k
        ) 
        ; applyAlphaBranchCond('Share-B, 'sa, 'xa, when (apply 'isAndGate 'k)) 
        ; applySubstFamilyCase3(
            'ShareOK-B, 
            'Share-B, 
            'k,
             nf('sa : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
                return 'sa, 'sa :: emptyCNameList),
             nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('xa : unit <- read ('ShareOK-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('sa : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb :: 'b :: 'xb :: 'xa :: 'yb :: 'sa :: emptyCNameList), 
            apply 'isAndGate 'k
        ) 
        ; applyAlphaBranchCond('Share-B, 'sa, 'ya, when (apply 'isAndGate 'k)) 
        ; applySubstFamilyCase3(
            'ShareOK-A, 
            'Share-B, 
            'k,
             nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
                return (), 'xa :: emptyCNameList),
             nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('ya : unit <- read ('ShareOK-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb :: 'b :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList),
            apply 'isAndGate 'k
        )  
        ; applyAlphaBranchCond('Share-B, 'xa, 'xa0, when (apply 'isAndGate 'k)) 
        ; applySubstFamilyCase3(
            'ShareOK-A, 
            'Share-B, 
            'k,
             nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
                return (), 'xa :: emptyCNameList),
             nf(('b : unit <- read ('OTBitOK-B-A['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('xa0 : bool <- read ('Share-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('xa : bool <- read ('Share-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb :: 'b :: 'xb :: 'xa0 :: 'yb :: 'xa :: emptyCNameList),
            apply 'isAndGate 'k
        )  
        ; applySubstFamilyCase3(
            'OTBitOK-B-A, 
            'Share-B, 
            'k,
             nf('ot : unit <- read ('OTBitOK-A-B['k]), return 'ot, 'ot :: emptyCNameList),
             nf(('ot : unit <- read ('OTBitOK-A-B['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('xa0 : bool <- read ('Share-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('xa : bool <- read ('Share-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb :: 'ot :: 'xb :: 'xa0 :: 'yb :: 'xa :: emptyCNameList),
            apply 'isAndGate 'k
        )
        ; applySubstFamilyCase3(
            'OTBitOK-A-B, 
            'Share-B, 
            'k,
             nf('ba : bool <- read ('OTBit-A-B['k]), return (), 'ba :: emptyCNameList),
             nf(('ba : bool <- read ('OTBit-A-B['k])) 
       ('bb : bool <- read ('OTBit-B-A['k])) 
       ('xa0 : bool <- read ('Share-A[fun 'wire0 'k])) 
       ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
       ('xa : bool <- read ('Share-A[fun 'wire1 'k])) 
        'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
        return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
        'bb :: 'ba :: 'xb :: 'xa0 :: 'yb :: 'xa :: emptyCNameList),
            apply 'isAndGate 'k
        )
        ; applyAlphaBranchCond('Share-B, 'xa, 'ya, when (apply 'isAndGate 'k))
        ; applyAlphaBranchCond('Share-B, 'xa0, 'xa, when (apply 'isAndGate 'k)) 
        *** restr11
        ; SYM[P1:Protocol <- restr11]{
          sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
        }
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv) 
       *** for -0
       ; applySubstFamilyCase3(
            'ShareOK-B, 
            'OTChoiceRcvd-B-A-0_ot_adv, 
            'k,
            nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]), 
               return 'sa, 'sa :: emptyCNameList), 
              nf('sa : unit <- read ('ShareOK-A[fun 'wire0 'k]), 
                 return (), 'sa :: emptyCNameList),
            apply 'isAndGate 'k
        )
       ; applySubstFamilyCase3(
            'ShareOK-A, 
            'OTChoiceRcvd-B-A-0_ot_adv, 
            'k,
            nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
               return (), 'xa :: emptyCNameList), 
              nf('xa : bool <- read ('Share-A[fun 'wire0 'k]), 
                 return (), 'xa :: emptyCNameList),
            apply 'isAndGate 'k
        )
        *** for -1
        ; applySubstFamilyCase3(
            'ShareOK-B, 
            'OTChoiceRcvd-B-A-1_ot_adv, 
            'k,
            nf('sa : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
               return 'sa, 'sa :: emptyCNameList), 
              nf('sa : unit <- read ('ShareOK-A[fun 'wire1 'k]), 
                 return (), 'sa :: emptyCNameList),
            apply 'isAndGate 'k
        )
       ; applySubstFamilyCase3(
            'ShareOK-A, 
            'OTChoiceRcvd-B-A-1_ot_adv, 
            'k,
            nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
               return (), 'xa :: emptyCNameList), 
              nf('xa : bool <- read ('Share-A[fun 'wire1 'k]), 
                 return (), 'xa :: emptyCNameList),
            apply 'isAndGate 'k
        ) 
        *** restr12
        ; SYM[P1:Protocol <- restr12]{
          sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
        } 
        
      *** now we get rid of timing channels
      ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
      ; absorbFamily('InOK-A)
      ; absorbFamily('InOK-B)
      ; absorbFamily('ShareOK-B)
      ; absorbFamily('ShareOK-A) 
      ; absorbFamily('OTBitOK-B-A)
      ; absorbFamily('OTBitOK-A-B)    
      ; absorbFamily('InputShareOK-B-A)
      ; absorbFamily('InputShareOK-B-B)
      ; absorbFamily('InputShareOK-A-A)
      ; absorbFamily('InputShareOK-A-B)
      *** restr13
      ; SYM[P1:Protocol <- restr13]{
          sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
        } 
      ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)  
      ; SYM[P1:Protocol <- restr14]{
        sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; absorbFamily('Wire)
      }       
      ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
      ; SYM[P1:Protocol <- restr15]{
        sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applySubstFamilyCase3(
            'Wire, 
            'Out-A, 
            'k,
             nf( ('xa : bool <- read ('Share-A['k]))
                 ('xb : bool <- read ('Share-B['k])), 
                 return (ap 'xor pair('xa, 'xb)),
                 'xa :: 'xb :: emptyCNameList
               ),
             nf( ('xa : bool <- read ('Share-A['k]))
                 ('xb : bool <- read ('Share-B['k])), 
                 return (ap 'xor pair('xa, 'xb)),
                 'xa :: 'xb :: emptyCNameList
               ),
            apply 'isOutputWire 'k
        )  
        ; applySubstFamilyCase3(
            'Wire, 
            'Out-B, 
            'k,
             nf( ('xa : bool <- read ('Share-A['k]))
                 ('xb : bool <- read ('Share-B['k])), 
                 return (ap 'xor pair('xa, 'xb)),
                 'xa :: 'xb :: emptyCNameList
               ),
             nf( ('xa : bool <- read ('Share-A['k]))
                 ('xb : bool <- read ('Share-B['k])), 
                 return (ap 'xor pair('xa, 'xb)),
                 'xa :: 'xb :: emptyCNameList
               ),
            apply 'isOutputWire 'k
        ) 
        ; applyBranch1Alpha('Out-A, 
                           << 'xa, 'sa >> << 'xb, 'sb >> emptyQidPairList)
        ; applyBranch1Alpha('Out-B, 
                           << 'xa, 'sa >> << 'xb, 'sb >> emptyQidPairList) 
      } 
        ; sugar-newNF
        ; applyDropName('indAlice)
        ; applyDropName('indBob)
        ; applyDropName('indAdv)
        ; SYM[P1:Protocol <- restr16Group]{
             sugar-newNF  
    ; apBigInd(
        (family 'Wire 'k (bound K) ::=
     nf(('xa : bool <- read ('Share-A['k])) 
         'xb : bool <- read ('Share-B['k]), 
         return (ap 'xor pair('xa, 'xb)), 'xa :: 'xb :: emptyCNameList)
   )
   ||
   (family 'Share-B 'k (bound K) ::= 
    (when (apply 'isAliceInput 'k) --> 
      nf(('is : bool <- read ('InputShare-B-A[fun 'wire0 'k]))
         ('xa : bool <- read ('InputShare-A-A[fun 'wire0 'k])), 
         return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isBobInput 'k) --> 
       nf(('is : bool <- read ('InputShare-B-B[fun 'wire0 'k]))
          ('xa : bool <- read ('InputShare-A-B[fun 'wire0 'k])), 
          return 'is, 'xa :: 'is :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isNotGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])), 
          return (ap 'neg 'xb), 'xa :: 'xb :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isXorGate 'k) --> 
       nf(('xb : bool <- read ('Share-B[fun 'wire0 'k]))
          ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
          ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
          ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
          return (ap 'xor pair('xb, 'yb)), 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    ) 
    ;; 
    (when (apply 'isAndGate 'k) --> 
      nf(('bb : bool <- read ('OTBit-B-A['k])) 
         ('ba : bool <- read ('OTBit-A-B['k]))
         ('xb : bool <- read ('Share-B[fun 'wire0 'k]))
         ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
         ('yb : bool <- read ('Share-B[fun 'wire1 'k]))
         ('ya : bool <- read ('Share-A[fun 'wire1 'k])), 
         return (ap 'xor pair('bb, ap 'and pair('xb, 'yb))), 
         'bb :: 'ba :: 'xb :: 'xa :: 'yb :: 'ya :: emptyCNameList)
    )
  ) *** end Share-B
  ||
  (family 'OTBit-B-A 'k (bound K) ::= 
   (when (apply 'isAndGate 'k) --> 
     nf(('ba : bool <- read ('OTBit-A-B['k])) 
        ('xa : bool <- read ('Share-A[fun 'wire0 'k])) 
        ('ya : bool <- read ('Share-A[fun 'wire1 'k])) 
        ('xb : bool <- read ('Share-B[fun 'wire0 'k])) 
         'yb : bool <- read ('Share-B[fun 'wire1 'k]), 
         return (ap 'xor pair('ba, 
                               ap 'xor pair(ap 'and pair('xa, 'yb), 
                                            ap 'and pair('xb, 'ya)))
                ), 
         'ba :: 'xa :: 'ya :: 'xb :: 'yb :: emptyCNameList)
   ) 
   ;;
   (otherwise --> 
      nf('otb : bool <- read ('OTBit-B-A['k]), 
         return 'otb, 
         'otb :: emptyCNameList)
   )
  ) *** end OTBit-B-A
      )
      
     ; applyDropName('Group)        
        }
        *** here we prove that restr16Group rewrites to restr16
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropName('Group)
       ; SYM[P1:Protocol <- restr16]{
         sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       ; applyDropName('Wires)  
       }
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
       ; applyDropName('indAlice)
       ; applyDropName('indBob)
       ; applyDropName('indAdv)
       ; applyDropName('Wires)
       ; absorbFamily('OTBit-B-A)
       ; substNFFamiliesOne('InputShare-B-A, 'SendInputShare-B-A_A_adv,
          nf(('x : bool <- read ('In-A['k]))
              'xa : bool <- read ('InputShare-A-A['k]), 
              return (ap 'xor pair('x, 'xa)), 
              'x :: 'xa :: emptyCNameList)
         )
       ; applySubstFamilyCase3(
            'Share-B, 
            'SendFinalShare-B_A_adv, 
            'k,
             nf(('x : bool <- read ('Wire['k]))
                 'xa : bool <- read ('Share-A['k]), 
                 return (ap 'xor pair('xa, 'x)), 
                 'xa :: 'x :: emptyCNameList),
              nf(('xa : bool <- read ('Share-A['k]))
                 ('x : bool <- read ('Wire['k])), 
                  return (ap 'xor pair('xa, 'x)), 
                  'xa :: 'x :: emptyCNameList),
            apply 'isOutputWire 'k
      ) 
      ; absorbFamily('Share-B) 
      ; absorbFamily('InputShare-B-B) 
      ; absorbFamily('InputShare-B-A)
      *** here we finish the proof from section 8.4
      
      *** alphas to make things match
      ; applyAlphaNFPr('InputShare-A-A, << 'x, 'inA >> emptyQidPairList)
      ; applyAlphaNFPr('InputShare-A-A_A_adv, << 'is, 'inA >> emptyQidPairList)
      ; applyAlphaNFPr('InputShare-A-B_A_adv, << 'is, 'inB >> emptyQidPairList)
      ; applyAlphaBranchCond('OTChoiceRcvd-B-A-0_ot_adv, 'xa, 'c0, when (apply 'isAndGate 'k))
      ; applyAlphaBranchCond('OTChoiceRcvd-B-A-0_ot_adv, 'x3, 'otc, otherwise)
      ; applyAlphaBranchCond('OTChoiceRcvd-B-A-1_ot_adv, 'xa, 'c1, when (apply 'isAndGate 'k))
      ; applyAlphaBranchCond('OTChoiceRcvd-B-A-1_ot_adv, 'x3, 'otc, otherwise)
      ; applyAlphaBranchCond('OTMsg-A-B-0_ot_adv, 'x3, 'otm, otherwise)
      ; applyAlphaBranchCond('OTMsg-A-B-1_ot_adv, 'x3, 'otm, otherwise)
      ; applyAlphaBranchCond('OTMsg-A-B-2_ot_adv, 'x3, 'otm, otherwise)
      ; applyAlphaBranchCond('OTMsg-A-B-3_ot_adv, 'x3, 'otm, otherwise)
      ; applyAlphaBranchCond('Out-A, 'x3, 'oai, otherwise)
      ; applyAlphaBranchCond('Out-A, 'w, 'wi, when (apply 'isOutputWire 'k))
      ; applyAlphaBranchCond('Out-B, 'x3, 'obi, otherwise)
      ; applyAlphaBranchCond('Out-B, 'w, 'wi, when (apply 'isOutputWire 'k))
      ; applyAlphaNFPr('Out-A_A_adv, << 'outA, 'oai >> emptyQidPairList)
      ; applyAlphaBranchCond('SendFinalShare-A_A_adv, 'x3, 'sa, otherwise)
      ; applyAlphaNFPr('SendInputShare-A-B_A_adv, << 'sis, 'x >> emptyQidPairList)
      ; applyAlphaNFPr('SendInputShare-B-A_A_adv, << 'x, 'inA >> emptyQidPairList)
      ; applyCommXor('SendInputShare-B-A_A_adv)
      ; changeOrder('SendInputShare-B-A_A_adv, 'xa :: 'inA :: emptyCNameList)
      ; applyAlphaBranchCond('SendFinalShare-B_A_adv, 'x3, 'sa, otherwise)
      ; applyAlphaBranchCond('SendFinalShare-B_A_adv, 'x, 'wi, when (apply 'isOutputWire 'k))
      ; SYM[P1:Protocol <- idealPlusSim]{
        sugar-newNF
       ; moveNewToFront 
       ; applySubstNFLeft('SendFinalShare-B_A_adv, 'Out-A_id_adv, 
          nf('oai : bool <- read ('Out-A['k]), return 'oai, 'oai :: emptyCNameList)
         )
       ; foldNFFamily('Out-A_id_adv, 'Out-A_A_adv)
       ; substNFFamiliesOne(
           'In-A_id_adv, 'In-A_A_adv, 
           nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA :: emptyCNameList)
         )
       ; substNFFamiliesOne(
           'In-A_id_adv, 'InputShare-A-A,
           nf('inA : bool <- read ('In-A['k]), return 'inA, 'inA :: emptyCNameList)
         )
       ; foldNFFamily('In-A_id_adv, 'SendInputShare-B-A_A_adv)  
        ; substNFFamiliesOne(
          'InRcvd-B_id_adv, 'InRcvd-B_B_adv,
           nf('x : bool <- read ('In-B['k]), return (), 'x :: emptyCNameList)
         )
        ; foldNFFamily('InRcvd-B_id_adv, 'InputShare-A-B) 
        ; applyDropName('Sim)
        ; applyDropName('Wires)
        ; applySameCasesSubstFirstBranch('Out-A, 'SendFinalShare-B_A_adv, 'k)
      }      
.

