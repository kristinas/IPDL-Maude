***( IPDL

  Copyright : (C) 2022, Kristina Sojakova
  License   : GNU General Public License v3.0 or later (GPL-3.0-or-later)
  Authors   : Mihai Codescu <mscodescu@gmail.com>
              Kristina Sojakova <sojakova.kristina@gmail.com>

)

load ../src/strategies

mod SECURE is
 protecting PROTOCOL-EQUALITY .

 op msg  : -> Type .
 op key  : -> Type .
 op ctxt : -> Type .
 
 op zerosF : -> SigElem .
 eq zerosF = 'zeros : unit ~> msg .
 
 op decF : -> SigElem .
 eq decF = 'dec : (ctxt * key) ~> msg .
 
 op encF : -> SigElem .
 eq encF = 'enc : (msg * key) ~>> ctxt .

 op muKeySym : -> SigElem .
 eq muKeySym = 'mu_key : unit ~>> key .
 
 op secSig : -> Signature .
 eq secSig = muKeySym encF decF zerosF .
 
 op n : -> Nat .
 
 op idealPlusSim : -> Protocol .
 eq idealPlusSim = 
    new 'Key : key in
    newfamily 'LeakMsgRcvd_id_adv 'i (bound n) : unit in
    newfamily 'OkMsg_adv_id 'i (bound n) : ctxt in     
    (
    ('Key ::= nf(emptyBRList, samp ('mu_key < () >), emptyCNameList) )
    ||
    (family 'LeakCtxt_net_adv 'i (bound n) ::= 
                nf(
                 ('x : unit <- read ('LeakMsgRcvd_id_adv['i]))
                 ('k : key <- read 'Key ),
                 samp ('enc < pair(ap 'zeros (), 'k) >),
                 'x :: 'k :: emptyCNameList
                ) 
    )  
    ||
    (family 'OkMsg_adv_id 'i (bound n) ::= nf('okCtxt : ctxt <- read ('OkCtxt_adv_net['i]), 
                          return 'okCtxt , 
                          'okCtxt :: emptyCNameList )
    )   
    ||
    (family 'LeakMsgRcvd_id_adv 'i (bound n) ::= 
          nf(
            'in : msg <- read ('In['i]) ,
            return (),
            'in :: emptyCNameList
            )
    )
    ||
    (family 'Out 'i (bound n) ::= 
          nf(
            ('okMsg : ctxt <- read ('OkMsg_adv_id['i]))
            ('in : msg <- read ('In['i])),
            return 'in,
            'okMsg :: 'in :: emptyCNameList
            )
    ) 
    ) . *** end of new, leave here
    
 op real : -> Protocol .
 eq real = 
    new 'Key : key in
    newfamily 'Recv 'i (bound n) : ctxt in
    newfamily 'Send 'i (bound n) : ctxt in
    ( 
    ('Key ::= nf(emptyBRList, samp ('mu_key < () >), emptyCNameList))
    || 
    (family 'Send 'i (bound n) ::= 
          nf(
            ('in : msg <- read ('In ['i]) )
            ('k : key <- read 'Key) ,
            samp ('enc < pair('in, 'k) >),
            'in :: 'k :: emptyCNameList
            )
    )    
    ||
    (family 'LeakCtxt_net_adv 'i (bound n) ::= 
      nf('send : ctxt <- read ('Send['i]), return 'send, 'send :: emptyCNameList)
    )
    || 
    (family 'Recv 'i (bound n) ::= 
            nf(
            ('okCtxt : ctxt <- read ('OkCtxt_adv_net [ 'i ]) )
            ('send : ctxt <- read ('Send [ 'i ])), 
                return 'send,
                'okCtxt :: 'send :: emptyCNameList
            )
    ) 
    ||
    (family 'Out 'i (bound n) ::=
            nf(
            ('c : ctxt <- read ('Recv['i]) )
            ('k : key <- read 'Key ),
            return (ap 'dec pair('c, 'k)),
            'c :: 'k :: emptyCNameList
            )
            
    ) 
    ) . *** end of new, leave here
  
  
endm

smod EXECUTE is
 pr STRATS .
 pr SECURE .
 
 var Sigma : Signature .
 var Delta : ChannelContext .
 var Gamma : VarContext .
 vars i1 i2 X Y Z In cn1 cn2 cn3 cn4 keyN inN encN decN : ChannelName .  
 vars m x y z k c Enc Dec Key i : Qid .
 var I O : Set{CNameBound} .
 var li : List{NatTerm} .
 var A : Set{BoolTerm} .
 var n1 n2 n3 n4 : Nat .
 
  crl [enc-dec-correctness] :
  pConfig(Sigma, Delta, 
           (keyN ::= nf(emptyBRList, samp ('mu_key < () >), emptyCNameList)
           ) 
           || 
           (encN ::= nf((m : msg <- read inN)
                       (k : key <- read keyN),
                    samp ('enc < pair(m, k) >),
                    m :: k :: emptyCNameList
                    )
           )
           ||
           (decN ::= nf ((c : ctxt <- read encN)
                    (k : key <- read keyN) ,
                    return (ap 'dec pair(c, k)),
                    c :: k :: emptyCNameList
                    )
           )  
          , I, O, A)
  => 
  pConfig(Sigma, Delta, 
          (keyN ::= nf(emptyBRList, samp ('mu_key < () >), emptyCNameList)
           ) 
           || 
           (encN ::= nf((m : msg <- read inN)
                       (k : key <- read keyN),
                    samp ('enc < pair(m, k) >),
                    m :: k :: emptyCNameList
                    )
           )
           ||
           (decN ::= nf (i : msg <- read inN ,
                    return i,
                    i :: emptyCNameList
                    )
           )  
                     , I, O, A) 
  if inN @ nil in I  [nonexec]. 
  
 var in key enc dec : ChannelName . 
 var pConf : ProtocolConfig .
  
 strat applyEDC : ChannelName ChannelName ChannelName ChannelName @ ProtocolConfig .  
 sd applyEDC(in, key, enc, dec) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyEDC(in, key, enc, dec)} 
     : CONG-COMP-RIGHT{
         enc-dec-correctness[inN:ChannelName <- in, 
                             keyN:ChannelName <- key,
                             encN:ChannelName <- enc,
                             decN:ChannelName <- dec,
                             i:Qid <- 'in]
       } .
  
  rl [ind-cpa] :
    pConfig(Sigma, Delta, 
          (keyN ::= nf(emptyBRList, samp ('mu_key < () >), emptyCNameList)
           ) 
          || 
          (encN ::= nf(
                   (m : msg <- read inN)
                   (k : key <- read keyN),
                   samp ('enc < pair(m, k) >),
                   m :: k :: emptyCNameList
                   )
          )
          , I, O, A) 
          =>
             pConfig(Sigma, Delta, 
          (keyN ::= nf(emptyBRList, samp ('mu_key < () >), emptyCNameList)
           )
          || 
          (encN ::= nf(
                   (m : msg <- read inN)
                   (k : key <- read keyN),
                   samp ('enc < pair(ap 'zeros (), k) >),
                   m :: k :: emptyCNameList
                   )
          )         
          , I, O, A) 
  . 
  
 strat applyCPA : ChannelName ChannelName @ ProtocolConfig .  
 sd applyCPA(key, enc) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCPA(key, enc)} 
     : CONG-COMP-RIGHT{
         ind-cpa[ keyN:ChannelName <- key,
                  encN:ChannelName <- enc
                ]
       } .
  
endsm
