***( IPDL

  Copyright : (C) 2022-23, Kristina Sojakova, Mihai Codescu
  License   : GNU General Public License v3.0 or later (GPL-3.0-or-later)
  Authors   : Mihai Codescu <mscodescu@gmail.com>
              Kristina Sojakova <sojakova.kristina@gmail.com>

Multi-Party Coin Toss
Sec. 7 in doc/case-studies.pdf

)

load ../src/strategies

mod COIN-TOSS is
 protecting PROTOCOL-EQUALITY .

 op msg  : -> Type .
 op key  : -> Type .
 op ctxt : -> Type .
 
 op xorF : -> SigElem .
 eq xorF = 'xor : (bool * bool) ~> bool .
 
 op zerosF : -> SigElem .
 eq zerosF = 'zeros : unit ~> msg .
 
 op decF : -> SigElem .
 eq decF = 'dec : (ctxt * key) ~> msg .
 
 op encF : -> SigElem .
 eq encF = 'enc : (msg * key) ~>> ctxt .

 op muKeySym : -> SigElem .
 eq muKeySym = 'mu_key : unit ~>> key .
 
 op flipF : -> SigElem .
 eq flipF = 'flip : unit ~>> bool .
 
 op secSig : -> Signature .
 eq secSig = muKeySym encF decF zerosF xorF flipF .
 
 op N : -> Nat .
 
 *** generic assumptions shared by both proofs
 op genA : -> Set{BoolTerm} .
 eq genA = ( 0 <T N + 2,
             0 <T N + 1,
             0 <T N + 3, 
             N <T N + 2,
             N <T N + 1,
             N <T N + 3, 
             N + 1 <T N + 2,
             N + 1 <T N + 3,
             N + 2 <T N + 3,
             apply 'honest (N + 1),
             apply 'corrupt N )
 .   
 
 op real : -> Protocol .
 eq real =  
    newfamily ('Commit[bound (N + 2)]) 'i (bound (N + 2)) : bool in
    newfamily ('Committed[bound (N + 2)]) 'i (bound (N + 2)) : unit in
   *** newfamily (('LeakCommitted ^^ 'comm .. 'adv)[bound (N + 2)]) 'i (bound (N + 2)) : unit in
    newfamily (('LeakOpened ^^ 'comm .. 'adv)[bound (N + 2)]) 'i (bound (N + 2)) : bool in
    newfamily ('Open[bound (N + 2)]) 'i (bound (N + 2)) : unit in
    newfamily ('Opened[bound (N + 2)]) 'i (bound (N + 2)) : bool in   
  (*** new
  (
  family ('Party[bound (N + 2)]) 'i (bound (N + 2)) ::= 
    (
     (when (apply 'honest 'i)  --> 
     newfamily ('AllCommitted[bound (N + 2) bound (N + 3)]) 
               ('i 'j) ((bound (N + 2))(bound (N + 3))) : unit in 
     newfamily ('SumOpened[bound (N + 2) bound (N + 3)]) 
               ('i 'j) ((bound (N + 2))(bound (N + 3))) : bool in
     ( *** start new
     (family ('Commit[bound (N + 2)]) 'i (bound (N + 2))  ::= 
       nf(emptyBRList, samp ('flip < () >), nil)
     )
     ||
     (family ('AllCommitted[bound (N + 2) bound (N + 3)]) 
             ('i 'j) ((bound (N + 2)) (bound (N + 3))) ::=
        (when ('j =T= 0) --> nf(emptyBRList, return (), nil))
        ;;
        (when (neg ('j =T= 0))  -->  
                        nf( ('x : unit <- read ('AllCommitted ['i ('j -- 1)] ))
                            ('y : unit <- read ('Committed [ 'j -- 1]) ),
                            return (),  
                            'x 'y
                        )
        )
     )                 
     ||
     (family ('Open[bound (N + 2)]) 'i (bound (N + 2))  ::= 
                   nf('x : unit  <- read ('AllCommitted ['i (N + 2) ]), 
                      return (),
                      'x)
     )
     ||
     (family ('SumOpened[bound (N + 2) bound (N + 3)]) 
             ('i 'j) ((bound (N + 2))  (bound (N + 3)))   ::= 
       (when ('j =T= 0) --> nf(emptyBRList, return False, nil)  ) ;;
       (when (neg ('j =T= 0)) -->
                      nf(('x : bool <- read ('SumOpened [ 'i ('j -- 1) ]))
                         ('y : bool <- read ('Opened ['j -- 1])),
                         return (ap 'xor pair('x, 'y)),
                         'x 'y)
       )
     )
     ||
     (
     family ('Out[bound (N + 2)]) 'i (bound (N + 2))  ::= 
        nf('sumOpened : bool <- read ('SumOpened ['i (N + 2)]), 
           return 'sumOpened,
           'sumOpened)
     ) 
     ) *** end new   
     ) *** end honest
     ;;
     (when (apply 'corrupt 'i) --> 
      ( *** start new
     (family ('Commit[bound (N + 2)]) 'i (bound (N + 2))  ::= 
       nf('advCommit : bool <- read (('AdvCommit ^^ 'adv .. 'party)['i]),
          return 'advCommit, 
          'advCommit)
     )  
     ||
     (family ('Open[bound (N + 2)]) 'i (bound (N + 2))  ::= 
       nf('advOpen : unit <- read (('AdvOpen ^^ 'adv .. 'party)['i]),
          return 'advOpen, 
          'advOpen)
     )
     ||
     (family ('Out[bound (N + 2)]) 'i (bound (N + 2))  ::= 
       nf('out : bool <- read ('Out ['i]),
          return 'out, 
          'out)
     )
     ) *** end new    
     ) *** end corrupt
    ) *** end party
  ) *** end family
  ||  
  (
  family ('Commitment[bound (N + 2)]) 'i (bound (N + 2)) ::= 
    (family ('Committed[bound (N + 2)]) 'i (bound (N + 2)) ::= 
                        nf('x : bool <- read ('Commit ['i]),
                        return (),
                        'x)
   )
   || 
   (family (('LeakCommitted ^^ 'comm .. 'adv)[bound (N + 2)]) 'i (bound (N + 2))  ::= 
     nf( 'committed : unit <- read ('Committed ['i]),
         return 'committed,
         'committed
       )
   )
   ||
   (family ('Opened[bound (N + 2)]) 'i (bound (N + 2))  ::= 
        nf(('x : unit <- read ('Open ['i]))
           ('commit : bool <- read ('Commit ['i])),
           return 'commit,
           'x 'commit 
          )
    )
    ||
    (family (('LeakOpened ^^ 'comm .. 'adv)[bound (N + 2)]) 'i (bound (N + 2))  ::= 
      nf('opened : bool <- read ('Opened ['i]),
         return 'opened,
         'opened
        )
    )
  ) *** end commitment
  ) *** end new
  .  
  
 op idealPlusSim : -> Protocol .
 eq idealPlusSim =
    newfamily ('AllOpen[bound (N + 3)]) 'j (bound (N + 3)) : unit in
    newfamily ('Commit[bound (N + 1)]) 'i (bound (N + 1)) : bool in
    newfamily ('Committed[bound (N + 2)]) 'i (bound (N + 2)) : unit in
    new 'Flip : bool in
    new 'LastCommit : bool in
    newfamily (('LeakOpened ^^ 'comm .. 'adv)[bound (N + 2)]) 'i (bound (N + 2)) : bool in
    newfamily ('Open[bound (N + 2)]) 'i (bound (N + 2)) : unit in
    newfamily ('Opened[bound (N + 2)]) 'i (bound (N + 2)) : bool in
    newfamily ('SumCommit[bound (N + 3)]) 'j (bound (N + 3)) : bool in
   ( *** new starts here 
    ('Flip ::= nf(emptyBRList, samp ('flip < () >), nil))
    ||
    (family ('Out[bound (N + 2)]) 'i (bound (N + 2)) ::= 
        (when (apply 'honest 'i) --> nf(
                                      ('ao : unit <- read ('AllOpen[N + 2]))
                                      ('sc : bool <- read ('SumCommit[N + 1]))
                                      ('f : bool <- read 'Flip), 
                                      return 'f, 
                                      'ao 'sc 'f )
        ) ;;
        (when (apply 'corrupt 'i) --> nf('out : bool <- read ('Out ['i]), return 'out, 'out )
        )
    )
    || 
   (family (('LeakCommitted ^^ 'comm .. 'adv)[bound (N + 2)]) 'i (bound (N + 2))  ::= 
     nf( 'committed : unit <- read ('Committed ['i]),
         return 'committed,
         'committed
       )
   )
    ||
    (family ('Commit[bound (N + 1)]) 'i (bound (N + 1)) ::= 
       (when (apply 'honest 'i)  --> nf(emptyBRList, samp ('flip < () >), nil)) ;;
       (when (apply 'corrupt 'i) --> 
          nf('advCommit : bool <- read (('AdvCommit ^^ 'adv .. 'party)['i]), 
             return 'advCommit, 
             'advCommit )
       )
    )
    ||
    ('LastCommit ::= nf( ('x : bool <- read ('SumCommit [ N + 1 ]))
                         ('f : bool <- read 'Flip),
                         return (ap 'xor pair('x, 'f)),
                         'x  'f  
                     )
    )
    ||
    (family ('SumCommit[bound (N + 3)]) 'j (bound (N + 3)) ::= 
        (when ('j =T= 0) --> nf(emptyBRList, return False, nil)) ;; 
        (when ('j =T= (N + 2)) --> 
               nf( ('x : bool <- read ('SumCommit [ N + 1 ])) 
                   ('f : bool <- read 'LastCommit) ,
                   return (ap 'xor pair('x, 'f)) ,
                   'x 'f  )
        )          ;;
        (otherwise --> nf(('x : bool <- read ('SumCommit ['j -- 1])) 
                          ('c : bool <- read ('Commit ['j -- 1])),
                          return (ap 'xor pair('x, 'c)),
                          'x 'c  )
        )                  
    )
    ||
    (family ('Committed[bound (N + 2)]) 'i (bound (N + 2)) ::=
        (when ('i =T= (N + 1)) --> nf(emptyBRList, return (), nil)) ;;
        (otherwise --> nf('x : bool <- read ('Commit ['i]),
                       return (),
                       'x  )
        )
    )
    ||
    (family ('Open[bound (N + 2)]) 'i (bound (N + 2)) ::= 
      (when (apply 'honest 'i)  --> 
        nf('sc : bool <- read ('SumCommit [N + 1]), return (), 'sc )
      ) ;;
      (when (apply 'corrupt 'i)  --> 
        nf('advOpen : unit <- read (('AdvOpen ^^ 'adv .. 'party)['i]) , 
           return 'advOpen, 'advOpen )
      )
    )  
    ||
    (family ('AllOpen[bound (N + 3)]) 'j (bound (N + 3)) ::= 
      (when ('j =T= 0) --> nf(emptyBRList, return (), nil)) ;;
      (when (neg ('j =T= 0)) --> 
                     nf(('x : unit <- read ('AllOpen ['j -- 1]))
                        ('y : unit <- read ('Open ['j -- 1])),
                        return (),
                        'x 'y 
                   )
      )
    )
    ||
    (family ('Opened[bound (N + 2)]) 'i (bound (N + 2)) ::= 
      (when ('i =T= N + 1) --> 
                      nf (('x : unit <- read ('Open [N + 1]))
                          ('commit : bool <- read 'LastCommit),
                          return 'commit,
                          'x 'commit 
                      )
      ) 
      ;;
      ( when (neg ('i =T= N + 1))--> 
                      nf (('x : unit <- read ('Open ['i]))
                          ('commit : bool <- read ('Commit ['i])),
                          return 'commit,
                          'x 'commit 
                      )
      )                 
    )
    ||
    (family (('LeakOpened ^^ 'comm .. 'adv)[bound (N + 2)]) 'i (bound (N + 2)) ::= 
       nf('opened : bool <- read ('Opened ['i]), return 'opened, 'opened )
    )
   ) *** new ends here, leave here

   .
       
endm

smod EXECUTE is
 pr STRATS .
 pr COIN-TOSS .
 
 var x y x1 x2 : Qid .
 var Sigma Sigma' : Signature .
 var Delta Delta' : ChannelContext .
 var Gamma : TypeContext .
 var I O I' O' : Set{CNameBound} .
 var A A' : Set{BoolTerm} .
 var cn : ChannelName .
 var pConf pConf' : ProtocolConfig .
 var P p P1 Q P' : Protocol .
 
 *******************************
 *** assumptions
 *******************************
 
 eq ap 'xor pair(ap 'xor pair(x1, x2), x2) = x1 .
 eq ap 'xor pair(x1, ap 'xor pair(x1, x2)) = x2 .  
 
 rl [flip-invar-xor-r] : rConfig(Sigma, Delta, Gamma (x : bool),
            y : bool <- samp ('flip < () >) ; 
            return (ap 'xor pair(x, y)), I, A, bool
            )
            => 
            rConfig(Sigma, Delta , Gamma (x : bool),
            samp ('flip < () >), I, A, bool) .  
            
 rl [flip-invar-xor-l] : rConfig(Sigma, Delta, Gamma (y : bool),
            x : bool <- samp ('flip < () >) ; 
            return (ap 'xor pair(x, y)), I, A, bool
            )
            => 
            rConfig(Sigma, Delta , Gamma (y : bool),
            samp ('flip < () >), I, A, bool) .  
 
 *********************************
 *** strategies for assumptions
 *********************************
             
 strat applyAR : ChannelName @ Protocol .
 sd applyAR(cn) := 
      match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyAR(cn)}
    : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]
             {CONG-REACT[o:ChannelName <- cn]
                { cong-pre-nf{flip-invar-xor-r}
                ; try (pre2Nf)
                }
             } .   
             
  ********************
  *** generated strategies
  ********************
  
  strat inductionAC @ ProtocolConfig .
  sd inductionAC :=
  
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- 
          removeThree P 
            (fam ('AllCommitted[bound (N + 2) bound (N + 3)])) 
            (fam ('AllCommitted1[bound (N + 3)]))
            (fam ('Committed[bound (N + 2)])), 
        P1:Protocol <- keepThree P 
            (fam ('AllCommitted[bound (N + 2) bound (N + 3)])) 
            (fam ('AllCommitted1[bound (N + 3)]))
            (fam ('Committed[bound (N + 2)]))
        ]
  {
     SINGLE-INDUCTION-new-R[
  idx:Qid <- 'B,
  q:Qid <- 'j,
  cn:ChannelName <- 'AllCommitted,
  cases':Cases <- 
   nf('x : unit <- read ('AllCommitted1['j]), return 'x, 'x)
   ]{
       CASE-DISTINCTION-one-R[fns:NameWithScripts <- 'AllCommitted]
       {symACZero,
       CASE-DISTINCTION-one-R-end-when[fns:NameWithScripts <- 'AllCommitted]{
       
        substNFFamiliesGen(
         fam ('AllCommitted[bound (N + 2) bound 'B]),
         fam ('AllCommitted[bound (N + 2) fixedBound 'B]),
         nf('x : unit <- read ('AllCommitted1['B -- 1]), return 'x, 'x)
        )
        ; symACNZero
        
       }
       }
       ; applyAllSameCases( fam ('AllCommitted[bound (N + 2) fixedBound 'B]) )
       }
  }     
  .     
 
  
  strat symACZero @ ProtocolConfig .
  sd symACZero :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change  
         fam ('AllCommitted[bound (N + 2) fixedBound 'B])
       with 
         nf('x : unit <- read ('AllCommitted1['B]), return 'x, 'x)
       in P
       ] 
     { substNFFamiliesGen(
          fam ('AllCommitted1[bound (N + 3)]),
          fam ('AllCommitted[bound (N + 2) fixedBound 'B]),
          nf(emptyBRList, return (), nil)
       )
     }  
  . 
  
  strat symACNZero @ ProtocolConfig .
  sd symACNZero :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change  
         fam ('AllCommitted[bound (N + 2) fixedBound 'B])
       with 
         nf('x : unit <- read ('AllCommitted1['B]), return 'x, 'x)
       in P
       ] 
     {  substNFFamiliesGen(
          fam ('AllCommitted1[bound (N + 3)]),
          fam ('AllCommitted[bound (N + 2) fixedBound 'B]),
          nf(('x : unit <- read ('AllCommitted1['B -- 1])) 
              'y : unit <- read ('Committed['B -- 1]), 
              return (), 'x 'y)
       )
     ; changeOrder(fam ('AllCommitted[bound (N + 2) fixedBound 'B]), 'x 'y)  
     } 
  .
  
  op r1 : -> Protocol .
  eq r1 = 
          
    (family ('AllCommitted1[bound (N + 3)]) 'i (bound (N + 3)) ::= 
        (when (0 =T= 'i) --> nf(emptyBRList, return (), nil)) 
        ;;
        (when (neg (0 =T= 'i)) --> 
                        nf(('x : unit <- read ('AllCommitted1['i -- 1])) 
                           ('y : unit <- read ('Committed['i -- 1])), 
                           return (), 'x 'y )
        )                   
     ) 
     || 
     (family 'Committed[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('x : bool <- read ('Commit['i]), return (), 'x)) 
     || 
     (family ('LeakCommitted ^^ 'comm .. 'adv)[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('committed : unit <- read ('Committed['i]), 
           return 'committed, 
           'committed)) 
     || 
     (family ('LeakOpened ^^ 'comm .. 'adv)[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('opened : bool <- read ('Opened['i]), return 'opened, 'opened)) 
     || 
     (family 'Opened[bound (N + 2)] 'i bound (N + 2) ::= 
        nf( ('commit : bool <- read ('Commit['i])) 
            ('x : unit <- read ('Open['i])), 
            return 'commit, 
            'x 'commit)
     ) 
     
     ||
    newNF(
          {('AllCommitted[bound (N + 2) bound (N + 3)]) ('i 'j) : unit} 
          {('SumOpened[bound (N + 2) bound (N + 3)]) ('i 'j) : bool}
     ,		 
 (family ('AllCommitted[bound (N + 2) bound (N + 3)]) 
         ('i 'j) (bound (N + 2) bound (N + 3)) ::= 
       nf('x : unit <- read ('AllCommitted1['j]), return 'x, 'x)   
     ) *** end family 
     ||
     (family 'Commit[bound (N + 2)] 'i
bound (N + 2)
::=
nf(emptyBRList, samp ('flip < () >), nil)
)
||
(family 'Open[bound (N + 2)] 'i
bound (N + 2)
::=
nf('x : unit <- read ('AllCommitted['i (N + 2)]), return (), 'x)
)
||
(family 'Out[bound (N + 2)] 'i
bound (N + 2)
::=
nf('sumOpened : bool <- read ('SumOpened['i (N + 2)]), return 'sumOpened, 'sumOpened)
)
||
family 'SumOpened[bound (N + 2) bound (N + 3)] 'i 'j
bound (N + 2) bound (N + 3)
::=
(when (0 =T= 'j) -->
nf(emptyBRList, return False, nil))
;;
when neg (0 =T= 'j) -->
nf(('x : bool <- read ('SumOpened['i ('j -- 1)])) 'y : bool <- read ('Opened['j -- 1]), return (ap
    'xor pair('x, 'y)), 'x 'y)
                 
     , 
     fam ('AllCommitted[bound (N + 2) bound (N + 3)]) 
     fam ('SumOpened[bound (N + 2) bound (N + 3)])
     ) .                   
   
   strat symAC @ ProtocolConfig .
   sd symAC := 
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- r1
       ] 
       {COMP-NEW-newNF}
   .
   
     op r2 : -> Protocol .
  eq r2 = 
  
     (family ('AllCommitted1[bound (N + 3)]) 'i (bound (N + 3)) ::= 
        (when (0 =T= 'i) --> nf(emptyBRList, return (), nil)) 
        ;;
        (when (neg (0 =T= 'i)) --> 
                        nf(('x : unit <- read ('AllCommitted1['i -- 1])) 
                           ('y : unit <- read ('Committed['i -- 1])), 
                           return (), 'x 'y )
        )                   
     ) 
     || 
     (family 'Committed[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('x : bool <- read ('Commit['i]), return (), 'x)) 
     || 
     (family ('LeakCommitted ^^ 'comm .. 'adv)[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('committed : unit <- read ('Committed['i]), 
           return 'committed, 
           'committed)) 
     || 
     (family ('LeakOpened ^^ 'comm .. 'adv)[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('opened : bool <- read ('Opened['i]), return 'opened, 'opened)) 
     || 
     (family 'Opened[bound (N + 2)] 'i bound (N + 2) ::= 
        nf( ('commit : bool <- read ('Commit['i])) 
            ('x : unit <- read ('Open['i])), 
            return 'commit, 
            'x 'commit)
     ) 
  
     ||
    newNF(
          {('AllCommitted[bound (N + 2) bound (N + 3)]) ('i 'j) : unit} 
          {('SumOpened[bound (N + 2) bound (N + 3)]) ('i 'j) : bool}
     ,		 
 (family ('AllCommitted[bound (N + 2) bound (N + 3)]) 
         ('i 'j) (bound (N + 2) bound (N + 3)) ::= 
       nf('x : unit <- read ('AllCommitted1['j]), return 'x, 'x )   
     ) *** end family 
     || 
     (family 'Commit[bound (N + 2)] 'i
bound (N + 2)
::=
        nf( emptyBRList, samp ('flip < () >), nil)) 
     || 
   
     (family 'Open[bound (N + 2)] 'i
bound (N + 2)
::=
nf('x : unit <- read ('AllCommitted1[N + 2]), return (), 'x)
)
||
(family 'Out[bound (N + 2)] 'i
bound (N + 2)
::=
nf('sumOpened : bool <- read ('SumOpened['i (N + 2)]), return 'sumOpened, 'sumOpened)
)
     || 
     family 'SumOpened[bound (N + 2) bound (N + 3)] 'i 'j
bound (N + 2) bound (N + 3)
::=
(when (0 =T= 'j) -->
nf(emptyBRList, return False, nil))
;;
when neg (0 =T= 'j) -->
nf(('x : bool <- read ('SumOpened['i ('j -- 1)])) 'y : bool <- read ('Opened['j -- 1]), return (ap
    'xor pair('x, 'y)), 'x 'y)             
                  
     , 
     fam ('AllCommitted[bound (N + 2) bound (N + 3)]) 
     fam ('SumOpened[bound (N + 2) bound (N + 3)])
     )
       .  

   strat symCNN : Protocol @ ProtocolConfig .
   sd symCNN(p) := 
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- p
       ] 
       {COMP-NEW-newNF}
   .

  op r3 : -> Protocol .
  eq r3 = 
  
     (family ('AllCommitted1[bound (N + 3)]) 'i (bound (N + 3)) ::= 
        (when (0 =T= 'i) --> nf(emptyBRList, return (), nil)) 
        ;;
        (when (neg (0 =T= 'i)) --> 
                        nf(('x : unit <- read ('AllCommitted1['i -- 1])) 
                           ('y : unit <- read ('Committed['i -- 1])), 
                           return (), 'x 'y )
        )                   
     ) 
     || 
     (family 'Committed[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('x : bool <- read ('Commit['i]), return (), 'x)) 
     || 
     (family ('LeakCommitted ^^ 'comm .. 'adv)[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('committed : unit <- read ('Committed['i]), 
           return 'committed, 
           'committed)) 
     || 
     (family ('LeakOpened ^^ 'comm .. 'adv)[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('opened : bool <- read ('Opened['i]), return 'opened, 'opened)) 
     || 
     (family 'Opened[bound (N + 2)] 'i bound (N + 2) ::= 
        nf( ('commit : bool <- read ('Commit['i])) 
            ('x : unit <- read ('Open['i])), 
            return 'commit, 
            'x 'commit)
     ) 
  
     ||
    newNF(
          {('SumOpened[bound (N + 2) bound (N + 3)]) ('i 'j) : bool}
     ,		 
 
     (family 'Commit[bound (N + 2)] 'i
bound (N + 2)
::=
        nf( emptyBRList, samp ('flip < () >), nil)) 
     || 
   
     (family 'Open[bound (N + 2)] 'i
bound (N + 2)
::=
nf('x : unit <- read ('AllCommitted1[N + 2]), return (), 'x)
)
||
(family 'Out[bound (N + 2)] 'i
bound (N + 2)
::=
nf('sumOpened : bool <- read ('SumOpened['i (N + 2)]), return 'sumOpened, 'sumOpened)
)
     || 
     family 'SumOpened[bound (N + 2) bound (N + 3)] 'i 'j
bound (N + 2) bound (N + 3)
::=
(when (0 =T= 'j) -->
nf(emptyBRList, return False, nil))
;;
when neg (0 =T= 'j) -->
nf(('x : bool <- read ('SumOpened['i ('j -- 1)])) 'y : bool <- read ('Opened['j -- 1]), return (ap
    'xor pair('x, 'y)), 'x 'y)             
                  
     , 
     
     fam ('SumOpened[bound (N + 2) bound (N + 3)])
     )
       .  

  strat inductionSO @ ProtocolConfig .
  sd inductionSO :=
  
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- 
          removeTwo P 
            (fam ('SumOpened[bound (N + 2) bound (N + 3)])) 
            (fam ('SumOpened1[bound (N + 3)])),
        P1:Protocol <- keepTwo P 
           (fam ('SumOpened[bound (N + 2) bound (N + 3)])) 
            (fam ('SumOpened1[bound (N + 3)]))      
        ]
 { 
     SINGLE-INDUCTION-new-R[
  idx:Qid <- 'B,
  q:Qid <- 'j,
  cn:ChannelName <- 'SumOpened,
  cases':Cases <- 
   nf('x : bool <- read ('SumOpened1['j]), return 'x, 'x)
   ]{
   
       CASE-DISTINCTION-one-R[fns:NameWithScripts <- 'SumOpened]
       {
       
       symSOZero,
       CASE-DISTINCTION-one-R-end-when[fns:NameWithScripts <- 'SumOpened]{
       
       
        substNFFamiliesGen(
         fam ('SumOpened[bound (N + 2) bound 'B]),
         fam ('SumOpened[bound (N + 2) fixedBound 'B]),
         nf('x : bool <- read ('SumOpened1['B -- 1]), return 'x, 'x)
        )
       ; symSONZero
        
       }
       }
      ; applyAllSameCases( fam ('SumOpened[bound (N + 2) fixedBound 'B]) )
      } 
  }
  . 

  strat symSOZero @ ProtocolConfig .
  sd symSOZero :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change  
         fam ('SumOpened[bound (N + 2) fixedBound 'B])
       with 
         nf('x : bool <- read ('SumOpened1['B]), return 'x, 'x)
       in P
       ] 
     { substNFFamiliesGen(
          fam ('SumOpened1[bound (N + 3)]),
          fam ('SumOpened[bound (N + 2) fixedBound 'B]),
          nf(emptyBRList, return False, nil)
       )
     }  
  . 
  
   
  strat symSONZero @ ProtocolConfig .
  sd symSONZero :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change  
          fam ('SumOpened[bound (N + 2) fixedBound 'B])
       with 
         nf('x : bool <- read ('SumOpened1['B]), return 'x, 'x)
       in P
       ] 
     {  substNFFamiliesGen(
          fam ('SumOpened1[bound (N + 3)]),
          fam ('SumOpened[bound (N + 2) fixedBound 'B]),
          nf(('x : bool <- read ('SumOpened1['B -- 1])) 
               'y : bool <- read ('Opened['B -- 1]), 
               return (ap 'xor  pair('x, 'y)), 'x 'y)

       )
     ; changeOrder(fam ('SumOpened[bound (N + 2) fixedBound 'B]), 'x 'y)  
     } 
  .

  op r4 : -> Protocol .
  eq r4 = 
  
     (family ('AllCommitted1[bound (N + 3)]) 'i (bound (N + 3)) ::= 
        (when (0 =T= 'i) --> nf(emptyBRList, return (), nil)) 
        ;;
        (when (neg (0 =T= 'i)) --> 
                        nf(('x : unit <- read ('AllCommitted1['i -- 1])) 
                           ('y : unit <- read ('Committed['i -- 1])), 
                           return (), 'x 'y )
        )                   
     ) 
     || 
     (family 'Committed[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('x : bool <- read ('Commit['i]), return (), 'x)) 
     || 
     (family ('LeakCommitted ^^ 'comm .. 'adv)[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('committed : unit <- read ('Committed['i]), 
           return 'committed, 
           'committed)) 
     || 
     (family ('LeakOpened ^^ 'comm .. 'adv)[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('opened : bool <- read ('Opened['i]), return 'opened, 'opened)) 
     || 
     (family 'Opened[bound (N + 2)] 'i bound (N + 2) ::= 
        nf( ('commit : bool <- read ('Commit['i])) 
            ('x : unit <- read ('Open['i])), 
            return 'commit, 
            'x 'commit)
     ) 
     ||
     (family 'SumOpened1[bound (N + 3)] 'j
bound (N + 3)
::=
(when (0 =T= 'j) -->
nf(emptyBRList, return False, nil))
;;
when neg (0 =T= 'j) -->
nf(('x : bool <- read ('SumOpened1['j -- 1])) 'y : bool <- read ('Opened['j -- 1]), return (ap 'xor
    pair('x, 'y)), 'x 'y)
)

     ||
    newNF(
          {('SumOpened[bound (N + 2) bound (N + 3)]) ('i 'j) : bool}
     ,		 
 
     (family 'Commit[bound (N + 2)] 'i
bound (N + 2)
::=
        nf( emptyBRList, samp ('flip < () >), nil)) 
     || 
   
     (family 'Open[bound (N + 2)] 'i
bound (N + 2)
::=
nf('x : unit <- read ('AllCommitted1[N + 2]), return (), 'x)
)
||
(family 'Out[bound (N + 2)] 'i
bound (N + 2)
::=
nf('sumOpened : bool <- read ('SumOpened['i (N + 2)]), return 'sumOpened, 'sumOpened)
)
     || 
     family 'SumOpened[bound (N + 2) bound (N + 3)] 'i 'j
bound (N + 2) bound (N + 3)
::=
nf('x : bool <- read ('SumOpened1['j]), return 'x, 'x)      
                  
     , 
     
     fam ('SumOpened[bound (N + 2) bound (N + 3)])
     )
       .  
 
     op r5 : -> Protocol .
  eq r5 = 
  
     (family ('AllCommitted1[bound (N + 3)]) 'i (bound (N + 3)) ::= 
        (when (0 =T= 'i) --> nf(emptyBRList, return (), nil)) 
        ;;
        (when (neg (0 =T= 'i)) --> 
                        nf(('x : unit <- read ('AllCommitted1['i -- 1])) 
                           ('y : unit <- read ('Committed['i -- 1])), 
                           return (), 'x 'y )
        )                   
     ) 
     || 
     (family 'Committed[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('x : bool <- read ('Commit['i]), return (), 'x)) 
     || 
     (family ('LeakCommitted ^^ 'comm .. 'adv)[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('committed : unit <- read ('Committed['i]), 
           return 'committed, 
           'committed)) 
     || 
     (family ('LeakOpened ^^ 'comm .. 'adv)[bound (N + 2)] 'i bound (N + 2) ::= 
        nf('opened : bool <- read ('Opened['i]), return 'opened, 'opened)) 
     || 
     (family 'Opened[bound (N + 2)] 'i bound (N + 2) ::= 
        nf( ('commit : bool <- read ('Commit['i])) 
            ('x : unit <- read ('Open['i])), 
            return 'commit, 
            'x 'commit)
     ) 
     ||
     (family 'SumOpened1[bound (N + 3)] 'j
bound (N + 3)
::=
(when (0 =T= 'j) -->
nf(emptyBRList, return False, nil))
;;
when neg (0 =T= 'j) -->
nf(('x : bool <- read ('SumOpened1['j -- 1])) 'y : bool <- read ('Opened['j -- 1]), return (ap 'xor
    pair('x, 'y)), 'x 'y)
)

     ||
    newNF(
          {('SumOpened[bound (N + 2) bound (N + 3)]) ('i 'j) : bool}
     ,		 
 
     (family 'Commit[bound (N + 2)] 'i
bound (N + 2)
::=
        nf( emptyBRList, samp ('flip < () >), nil)) 
     || 
   
     (family 'Open[bound (N + 2)] 'i
bound (N + 2)
::=
nf('x : unit <- read ('AllCommitted1[N + 2]), return (), 'x)
)
||
(family 'Out[bound (N + 2)] 'i
bound (N + 2)
::=
nf('x : bool <- read ('SumOpened1[N + 2]), 
            return 'x, 
            'x)
)
     || 
     family 'SumOpened[bound (N + 2) bound (N + 3)] 'i 'j
bound (N + 2) bound (N + 3)
::=
nf('x : bool <- read ('SumOpened1['j]), return 'x, 'x)      
                  
     , 
     
     fam ('SumOpened[bound (N + 2) bound (N + 3)])
     )
       .  
       
       
    strat addSumCommit @ ProtocolConfig .
    sd addSumCommit :=
      matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'SumCommit
         typed bool
         params ('j)
                ( bound (N + 3) )
         assigned
          (when ('j =T= 0) --> nf(emptyBRList, return False, nil))
                   ;;
          ( when (neg ('j =T= 0)) --> 
                      nf(('xj : bool <- read ('SumCommit['j -- 1]))
                         ('cj : bool <- read ('Commit['j -- 1])),
                         return (ap 'xor pair('xj, 'cj)),
                      'xj 'cj
                     )
                   )  
         in P]
         {absorbFamilyDeleteEmpty(  fam ('SumCommit[bound (N + 3)]) )
         }
    .   
    
   strat inductionAC1 @ ProtocolConfig .
   sd inductionAC1 := 
   
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- 
          removeThree P 
            (fam ('Committed[bound (N + 1)]))
            (fam ('AllCommitted1[bound (N + 2)]))
            (fam ('SumCommit[bound (N + 3)])),
        P1:Protocol <- keepThree P 
           (fam ('Committed[bound (N + 1)]))
            (fam ('AllCommitted1[bound (N + 2)]))
            (fam ('SumCommit[bound (N + 3)]))   
        ]
   {
      SINGLE-INDUCTION-new-R[
  idx:Qid <- 'B,
  q:Qid <- 'i,
  cn:ChannelName <- 'AllCommitted1,
  cases':Cases <- 
   nf('sc : bool <- read ('SumCommit['i]), 
              return (), 
              'sc)
   ]{
       CASE-DISTINCTION-channel[cn:ChannelName <- 'AllCommitted1['B]]{
       symAC1Zero, 
       CASE-DISTINCTION-channel-end-when[cn:ChannelName <- 'AllCommitted1['B]]{
        substNFFamilyOne(
              fam ('AllCommitted1[bound 'B]),
              'AllCommitted1['B],
              nf('sc : bool <- read ('SumCommit['B -- 1]), return (), 'sc)
              )  
        ;
        substNFFamilyOne(
              fam ('Committed[bound (N + 1)]),
              'AllCommitted1['B],
              nf('x : bool <- read ('Commit['B -- 1]), return (), 'x)
              ) 
        ; applyAlphaNFPr(chn ('AllCommitted1['B]), 
                 << 'sc, 'xj >> << 'x, 'cj >> emptyQidPairList)   
        ; symAC1NZero                    
       }
       }
       ; applyAllSameCases( chn ('AllCommitted1['B]) )
       }
    }
   . 
      
    strat symAC1Zero @ ProtocolConfig .
  sd symAC1Zero :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change  
         chn ('AllCommitted1['B])
       with 
        nf('sc : bool <- read ('SumCommit['B]), 
              return (), 
              'sc)
       in P
       ] 
    { substNFFamilyOne(fam ('SumCommit[bound (N + 3)]),
         'AllCommitted1['B],
         nf(emptyBRList, return False, nil)
         )
    }
       
  . 
  
   
  strat symAC1NZero @ ProtocolConfig .
  sd symAC1NZero :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
      change  
         chn ('AllCommitted1['B])
       with 
        nf('sc : bool <- read ('SumCommit['B]), 
              return (), 
              'sc)
       in P       
       ] 
       {  substNFFamilyOne(fam ('SumCommit[bound (N + 3)]),
         'AllCommitted1['B],
         nf(('cj : bool <- read ('Commit['B -- 1])) 
             'xj : bool <- read ('SumCommit['B -- 1]), 
             return (ap 'xor pair('xj, 'cj)), 'xj 'cj)
         )
     ; changeOrder(chn ('AllCommitted1['B]), 'xj 'cj)  
     } 
  .
  
  strat addAllOpen @ ProtocolConfig .
    sd addAllOpen :=
      matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'AllOpen
         typed unit
         params ('j)
                ( bound (N + 3) )
         assigned
          (when ('j =T= 0) --> nf(emptyBRList, return (), nil))
                   ;;
          ( when (neg ('j =T= 0)) --> 
                      nf(('x : unit <- read ('AllOpen['j -- 1]))
                         ('y : unit <- read ('Open['j -- 1])),
                         return (),
                      'x 'y
                     )
                   )  
         in P]
         {absorbFamilyDeleteEmpty(  fam ('AllOpen[bound (N + 3)]) )
         }
    . 
    
  strat inductionSO1 @ ProtocolConfig . 
  sd inductionSO1 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- 
          removeFour P 
            (fam ('AllOpen[bound (N + 3)]))
            (fam ('SumOpened1[bound (N + 3)]))
            (fam ('SumCommit[bound (N + 3)]))
            (fam ('Opened[bound (N + 2)])),
        P1:Protocol <- keepFour P 
           (fam ('AllOpen[bound (N + 3)]))
            (fam ('SumOpened1[bound (N + 3)]))
            (fam ('SumCommit[bound (N + 3)]))
            (fam ('Opened[bound (N + 2)])) 
        ]
  {
      SINGLE-INDUCTION-new-R[
  idx:Qid <- 'B,
  q:Qid <- 'j,
  cn:ChannelName <- 'SumOpened1,
  cases':Cases <- 
   nf(('ao : unit <- read ('AllOpen['j])) 
                          ('sc : bool <- read ('SumCommit['j])),
                          return 'sc,
                          'ao  'sc )
   ]{
  CASE-DISTINCTION-channel[cn:ChannelName <- 'SumOpened1['B]]{
       symSO1Zero ,
       CASE-DISTINCTION-channel-end-when[cn:ChannelName <- 'SumOpened1['B]]{
       
        substNFFamilyOne(
              fam ('SumOpened1[bound 'B]),
              'SumOpened1['B],
              nf(('ao : unit <- read ('AllOpen['B -- 1])) 
                  'sc : bool <- read ('SumCommit['B -- 1]), 
                  return 'sc, 'ao 'sc)
              )  
        ; 
        substNFFamilyOne(
              fam ('Opened[bound (N + 2)]),
              'SumOpened1['B],
              nf(('commit : bool <- read ('Commit['B -- 1])) 
                  'x : unit <- read ('Open['B -- 1]), return 'commit, 'x 'commit)
              )        
       
        ; symSO1NZero                    
       }
       }
       ; applyAllSameCases( chn ('SumOpened1['B]))
       }
  }
  .  
    
  strat symSO1Zero @ ProtocolConfig .
  sd symSO1Zero :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change  
         chn ('SumOpened1['B])
       with 
        nf(('ao : unit <- read ('AllOpen['B])) 
                          ('sc : bool <- read ('SumCommit['B])),
                          return 'sc,
                          'ao  'sc )
       in P
       ] 
       {
        substNFFamilyOne(
              fam ('AllOpen[bound (N + 3)]),
              'SumOpened1['B],
              nf(emptyBRList, return (), nil)
              )   
        ;
        substNFFamilyOne(
              fam ('SumCommit[bound (N + 3)]),
              'SumOpened1['B],
              nf(emptyBRList, return False, nil)
              )         
       }                   
  . 
  
   
  strat symSO1NZero @ ProtocolConfig .
  sd symSO1NZero :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change  
         chn ('SumOpened1['B])
       with 
        nf(('ao : unit <- read ('AllOpen['B])) 
                          ('sc : bool <- read ('SumCommit['B])),
                          return 'sc,
                          'ao  'sc )
       in P
       ] 
       {
       substNFFamilyOne(
              fam ('AllOpen[bound (N + 3)]),
              'SumOpened1['B],
              nf(('x : unit <- read ('AllOpen['B -- 1])) 
                  'y : unit <- read ('Open['B -- 1]), return (), 'x 'y)
              ) 
        ;
        substNFFamilyOne(
              fam ('SumCommit[bound (N + 3)]),
              'SumOpened1['B],
              nf(('cj : bool <- read ('Commit['B -- 1])) 
                  'xj : bool <- read ('SumCommit['B -- 1]), 
                  return (ap 'xor pair('xj, 'cj)), 'xj 'cj)
              )             
         ; applyAlphaNFPr(
              chn ('SumOpened1['B]),
                 << 'x, 'ao >> << 'cj, 'commit >> << 'xj, 'sc >> << 'y, 'x >>
                 emptyQidPairList)   
         ; changeOrder(chn ('SumOpened1['B]), 'ao 'sc 'x 'commit)    
        }        
  .  
     
  strat symOut @ ProtocolConfig .
  sd symOut := 
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change
         (fam ('Out[bound (N + 2)]) )
        with 
         nf(('ao : unit <- read ('AllOpen[N + 2])) 
            'sc : bool <- read ('SumCommit[N + 2]), return 'sc, 'ao 'sc)
         in P 
       ] 
       { 
       substNFFamiliesGen(
        fam ('SumCommit[bound (N + 3)]),
        (fam ('Out[bound (N + 2)]) ),
        nf(('f : bool <- read 'LastCommit) 
            'x : bool <- read ('SumCommit[N + 1]), 
            return (ap 'xor pair('x, 'f)), 'x 'f)
       )
       ; substChannelFamilyOne(chn 'LastCommit, (fam ('Out[bound (N + 2)]) ))
       ; applyAlphaNFPr( fam ('Out[bound (N + 2)]), 
                         << 'x, 'sc >> emptyQidPairList)
                         }
  .
  
  strat symOpened @ ProtocolConfig . 
  sd symOpened :=
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change
         fam ('Opened[bound (N + 2)])
        with 
        nf(('commit : bool <- read ('Commit[N + 1])) 
            'o : unit <- read ('Open[N + 1]), 
            return 'commit,
            'o 'commit)
        in P
         
       ] 
       { substNFFamiliesGen(
           fam ('Open[bound (N + 2)]),
           fam ('Opened[bound (N + 2)]),
           nf('sc : bool <- read ('SumCommit[N + 1]), return (), 'sc)
         )
       }  
  .   
      
endsm

*** this is the main proof
srew [1] pConfig(secSig, 
    (fam (('AdvCommit ^^ 'adv .. 'party)[bound (N + 2)]) :: bool) 
    (fam (('AdvOpen ^^ 'adv .. 'party)[bound (N + 2)]) :: unit)
    (fam (('LeakCommitted ^^ 'comm .. 'adv)[bound (N + 2)]) :: unit)
    (fam ('Out[bound (N + 2)]) :: bool),
                 real,
    (fam (('AdvCommit ^^ 'adv .. 'party)[bound (N + 2)]),
     fam (('AdvOpen ^^ 'adv .. 'party)[bound (N + 2)]) 
    ), 
    (fam ('Out[bound (N + 2)]), 
     fam (('LeakCommitted ^^ 'comm .. 'adv)[bound (N + 2)])
    ),
    genA
                ) 
   using sugar-newNF
   ; addNewFamilyToGroup(
       newfamily ('AllCommitted1[bound (N + 3)]) 'i (bound(N + 3)) : unit in 
          family ('AllCommitted1[bound (N + 3)]) 'i (bound(N + 3)) ::= 
                (when ('i =T= 0) --> nf(emptyBRList, return (), nil)) ;;
                (when (neg ('i =T= 0))  --> 
                   nf(('x : unit <- read ('AllCommitted1['i -- 1]))
                      ('y : unit <- read ('Committed['i -- 1])),
                      return (),
                      'x  'y 
                     )
                )
             , fam ('Commitment[bound (N + 2)])
             , fam ('AllCommitted1[bound (N + 3)])
            ) 
                 
   ; CONG-NEW-NF{
       CASE-DISTINCTION-one[fns:NameWithScripts <- 'Party]
       { use-family-p[fns:NameWithScripts <- 'Commitment]
          { 
            *** 1. get everything under newNF
            COMP-NEW-newNF
            *** 2. do the induction proof
           ; CONG-NEW-NF{
           
           inductionAC
            
            }
            *** 3. sym proof 
            ; symCNN(r1)
          }, 
        *** no changes for corrupt
        idle}
     } 
    
      ; CONG-NEW-NF{
       
        CASE-DISTINCTION-one[fns:ChannelName <- 'Party]
         { use-family-p[fns:ChannelName <- 'Commitment]
             { 
               COMP-NEW-newNF
             ; applySubstReadFamilyTwoFamily(
                fam ('Open[bound (N + 2)]), 
                fam ('AllCommitted[bound (N + 2) bound (N + 3)])
             )
             ; symCNN(r2)
             
             }
         , idle
         }  
      
      }  
      
   *** absorb AllCommitted
   ; CONG-NEW-NF{
     CASE-DISTINCTION-one[fns:ChannelName <- 'Party]
         { use-family-p[fns:ChannelName <- 'Commitment]
             { 
               COMP-NEW-newNF
             ; absorbFamilyDeleteEmpty( fam ('AllCommitted[bound (N + 2) bound (N + 3)]) )
             ; symCNN(r3)
             }
         , idle
         }
   }    
   
   ; addNewFamilyToGroup(
             newfamily ('SumOpened1[bound (N + 3)]) 'j (bound (N + 3)) : bool in
              family ('SumOpened1[bound (N + 3)]) 'j (bound (N + 3)) ::= 
                (when ('j =T= 0) --> nf(emptyBRList, return False, nil)) ;;
                (when (neg ('j =T= 0)) --> 
                   nf(('x : bool <- read ('SumOpened1['j -- 1]))
                      ('y : bool <- read ('Opened['j -- 1])),
                      return (ap 'xor pair('x, 'y)),
                      'x 'y
                     )
                ), fam ('Commitment[bound (N + 2)]), fam ('SumOpened1[bound (N + 3)])
            ) 
       
            *** induction proof for SumOpened
    ; CONG-NEW-NF{
       CASE-DISTINCTION-one[fns:NameWithScripts <- 'Party]
       { use-family-p[fns:NameWithScripts <- 'Commitment]
          { 
            *** 1. get everything under newNF
            COMP-NEW-newNF
            *** 2. do the induction proof
           ; CONG-NEW-NF{
           
           inductionSO
           
            }
            *** 3. sym proof 
            ; symCNN(r4)
          }, 
        *** no changes for corrupt
        idle}
     } 
        
     ; CONG-NEW-NF{
       
        CASE-DISTINCTION-one[fns:ChannelName <- 'Party]
         { use-family-p[fns:ChannelName <- 'Commitment]
             { 
               COMP-NEW-newNF
             ; applySubstReadFamilyTwoFamily(
                fam ('Out[bound (N + 2)]), 
                fam ('SumOpened[bound (N + 2) bound (N + 3)])
             )
            ; symCNN(r5)
             
             }
         , idle
         }  
      
      }      
        
     *** absorb AllCommitted
   ; CONG-NEW-NF{
     CASE-DISTINCTION-one[fns:ChannelName <- 'Party]
         { use-family-p[fns:ChannelName <- 'Commitment]
             { 
               COMP-NEW-newNF
             ; absorbFamilyDeleteEmpty( fam ('SumOpened[bound (N + 2) bound (N + 3)]) )
             }
         , idle
         }
   }    
   ; applyDropName(fam ('Commitment[bound (N + 2)]) )
   ; applyNewCombine(fam ('Party[bound (N + 2)]))  
   ; addSumCommit 
    
    ; addAllOpen  
   *** induction for SumOpened1
   ; CONG-NEW-NF{
    
     inductionSO1

   }
   *** subst in Out
    ; CONG-NEW-NF{
   
     CASE-DISTINCTION-one-R[fns:NameWithScripts <- 'Out]
     {substNFFamiliesGen(
       fam ('SumOpened1[bound (N + 3)]),
       fam ('Out[bound (N + 2)]),
       nf(('ao : unit <- read ('AllOpen[N + 2])) 
           'sc : bool <- read ('SumCommit[N + 2]), return 'sc, 'ao 'sc)
      ), 
      idle}
   
   }
   ; absorbFamily(fam ('SumOpened1[bound (N + 3)])) 
   ; SPLIT-family-1-newnf[fns:NameWithScripts <- 'Commit]      
   ; SPLIT-family-1-newnf[fns:NameWithScripts <- 'Committed] 
   ; applyDropSubsumeRevChannels('Commit[N + 1], 'Committed[N + 1]) 
   ;  SPLIT-family-1-newnf[fns:NameWithScripts <- 'AllCommitted1] 
   ; substNF('Committed[N + 1], 'AllCommitted1[N + 2])
   ; CONG-NEW-NF{
   
     CASE-DISTINCTION-one-R[fns:NameWithScripts <- 'Open]
     {substChannelFamilyOne(chn ('AllCommitted1[N + 2]),
       fam ('Open[bound (N + 2)])
      ), 
      idle}
   
     }
   ; absorbChannel('AllCommitted1[N + 2])
       
   *** induction on AllCommitted1
   ; CONG-NEW-NF{
     
     inductionAC1
     
   }
   
   ; UNSPLIT-fst-family-1-nf[fns:NameWithScripts <- 'Committed] 
  
   ; CONG-NEW-NF{
   
     CASE-DISTINCTION-one-R[fns:NameWithScripts <- 'Open]
     {substNFFamiliesGen(
       fam ('AllCommitted1[bound (N + 2)]),
       fam ('Open[bound (N + 2)]),
       nf('sc : bool <- read ('SumCommit[N + 1]), return (), 'sc)
      ), 
      idle}
   
   }
   
   ; absorbFamily(fam ('AllCommitted1[bound (N + 2)]))   
   ; applyNegToOtherwise(fam ('Committed[bound (N + 2)]))
   ; applyNegToOtherwise( fam ('SumCommit[bound (N + 3)]) )
    ****************************
 *** now the sym proof
 ; matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
        SYM[
       Delta1:ChannelContext <- Delta',
       O1:Set{CNameBound} <- O',
       P1:Protocol <- idealPlusSim
       ]{
       sugar-newNF
   ; CONG-NEW-NF{
   CASE-DISTINCTION-one-R[fns:NameWithScripts <- 'Out]{
    symOut, 
    idle
   }
   }
   ; foldNF('Flip, 'LastCommit)
   ; applyAR('LastCommit)
   ; matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       *** I':Set{CNameBound} <- I,
       *** A':Set{BoolTerm} <- A,
       P1:Protocol <-
        addInternalChannel 
         'Commit[N + 1]
         typed 
         bool 
         assigned 
         nf(emptyBRList, samp ('flip < () >), nil)
         in
         (
         change (chn 'LastCommit) 
         with  nf(( 'x : bool <- read ('SumCommit[N + 1]) ) 
                    'commit : bool <- read ('Commit[N + 1]), 
                    return 'commit,
                    'x 'commit)
         in
         P
         )
       ] 
       { foldNF('Commit[N + 1], 'LastCommit) }
       ;
        CONG-NEW-NF{
         matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       CONG-COMP-RIGHT[
        Q:Protocol  <- 
          removeTwo P (chn 'LastCommit) 
                       ( fam ('Opened[ bound (N + 2)]) ), 
        P1:Protocol <- keepTwo P (chn 'LastCommit) (fam ('Opened[bound (N + 2)]))]{
         
         CASE-DISTINCTION-one-R[fns:NameWithScripts <- 'Opened]{
          applyAlphaNFPr(
            fam ('Opened[bound (N + 2)]), 
                         << 'x, 'o >> emptyQidPairList)
                         ; 
          substChannelFamilyOne(chn 'LastCommit, fam ('Opened[bound (N + 2)]) ), 
          
          idle
         }
         }
         ; matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       CONG-COMP-RIGHT[
        Q:Protocol  <- 
          removeTwo P (chn 'LastCommit) 
                       ( fam ('SumCommit[bound (N + 3)]) ), 
        P1:Protocol <- keepTwo P (chn 'LastCommit) (fam ('SumCommit[bound (N + 3)]) )]{
         CASE-DISTINCTION-one-R[fns:NameWithScripts <- 'SumCommit]{
          idle, 
          CASE-DISTINCTION-one-R[fns:NameWithScripts <- 'SumCommit]{
          substChannelFamilyOne(chn 'LastCommit, fam ('SumCommit[bound (N + 3)]) )
          ; applyAlphaNFPr(
           fam ('SumCommit[bound (N + 3)]), 
                         << 'commit, 'c >> emptyQidPairList), 
          idle
         } *** case-dist in 
         } *** case-dist out
         } *** comp
        } ***cong-new-nf
        ; absorbChannel('LastCommit)
        ;
        CONG-NEW-NF{
         matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       CONG-COMP-RIGHT[
        Q:Protocol  <- 
          removeTwo P (fam ('Open[bound (N + 2)])) 
                       ( fam ('Opened[ bound (N + 2)]) ), 
        P1:Protocol <- keepTwo P (fam ('Open[bound (N + 2)]))  
                                 (fam ('Opened[bound (N + 2)]) )]{
        CASE-DISTINCTION-one-R[fns:NameWithScripts <- 'Opened]{
         substNFFamiliesGen(
           fam ('Open[bound (N + 2)]),
           fam ('Opened[bound (N + 2)]),
           nf('sc : bool <- read ('SumCommit[N + 1]), return (), 'sc)
         )
         ; symOpened
         ; applyAlphaNFPr(
            fam ('Opened[bound (N + 2)]), 
                         << 'o, 'x >> emptyQidPairList), 
         idle}
        }
        }
        ; applyMergeDropCases( fam ('Opened[bound (N + 2)] ) )
        ; merge-cases[fns:NameWithScripts <- 'SumCommit, nt1:NatTerm <- N + 2]
        ; CONG-NEW-NF{
           CASE-DISTINCTION-one-R[fns:NameWithScripts <- 'SumCommit]{
          idle, 
          CASE-DISTINCTION-one-R-end[fns:NameWithScripts <- 'SumCommit]{
           applyAlphaNFPr(
           fam ('SumCommit[bound (N + 3)]), 
                         << 'c, 'cj >> << 'x, 'xj >> emptyQidPairList)
          }
          }
          }
          ; reorder-newNF[ql2:List{CNameBound} <- 
( 
            fam ('Committed[bound (N + 2)]) 
            fam ('Commit[bound (N + 1)]) 
            chn ('Commit[N + 1]) 
            fam ('AllOpen[bound (N + 3)]) 
            fam ('SumCommit[bound (N + 3)]) 
            fam (('LeakOpened ^^ 'comm .. 'adv)[bound (N + 2)]) 
            fam ('Open[bound (N + 2)]) fam ('Opened[bound (N + 2)])
 ) ] 
       }
   ************************** results
   ***; get-structure 
.

