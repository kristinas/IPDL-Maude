load ../src/strategies

mod TOY is

 protecting APPROX-EQUALITY .
 
 op p0 : -> Protocol .
 
 eq p0 = 
    ('c ::= 'x : bool <- return True ; return 'x)
     || 
    ('d ::= read 'I)
 .
     
endm

smod ASTRATS is
 protecting APPROX-EQUALITY .
 
 var aConf : ApproxConfig .
 var cn : ChannelName .
 var Sigma : Signature .
 var Delta : ChannelContext .
 var I O : Set{CNameBound} .
 var A : Set{BoolTerm} .
 var aW : Width .
 var aL : Length .
 var w l : Nat .
 var P : Protocol .
 
 var pConf : ProtocolConfig .
 
 strat applyStrictInComp : ChannelName @ ApproxConfig .
 sd applyStrictInComp(cn) := 
    matchrew aConf s.t. aConfig(Sigma, Delta, P, I, O, A, width w, length l) := aConf by aConf 
       using CONG-COMP-APPROX[Q:Protocol <- removeOne P cn]
             {STRICT{CONG-REACT{ret-bind}}}
 .
 
 
 crl [assumption1] : 
  aConfig(Sigma, Delta ('I @ nil :: bool), cn ::= read 'I, I, O, A, width w, length l)
  => 
  aConfig(Sigma, Delta ('I @ nil :: bool), cn ::= samp flip, I, O, A, 
          width (w + 1), length (l + | I \ ('I @ nil)| )   
         )
  if 'I @ nil in I /\ O == cn @ nil
 .

 strat applyAssumption : ChannelName @ ApproxConfig .
 sd applyAssumption(cn) := 
    matchrew aConf s.t. aConfig(Sigma, Delta, P, I, O, A, width w, length l) := aConf by aConf 
       using CONG-COMP-APPROX[Q:Protocol <- removeOne P cn,
                              P1:Protocol <- keepOne P cn
                              ]
             {assumption1}
 .
 
 
endsm

smod EXECUTE is
 pr ASTRATS .
 pr TOY .
  
endsm

srew [1]
 aConfig(emptySig, 
         ('c @ nil :: bool) ('d @ nil :: bool) ('I @ nil :: bool),
         p0, 
         'I @ nil, 
         insert('c @ nil, 'd @ nil), 
         empty,
         width 0, 
         length 0
 )
using *** applyAssumption('d)
     TRANS{
       applyAssumption('d), 
       applyStrictInComp('c)
    }
.

***(
srew [1]
 aConfig(emptySig, 
         ('c @ nil :: bool) ('d @ nil :: bool) ('I @ nil :: bool),
         'd ::= read 'I, 
         'I @ nil, 
         'd @ nil, 
         empty,
         width 0, 
         length 0
 )
using *** applyStrictInComp('c) 
      assumption1 
.
)

***(
srew [1]
 aConfig(emptySig, 
         ('c @ nil :: bool) ('d @ nil :: bool) ('I @ nil :: bool),
         new 'cn : bool in p0, 
         'I @ nil, 
         insert('c @ nil, 'd @ nil), 
         empty,
         width 0, 
         length 0
 )
using 
 CONG-NEW-APPROX[nw1:Nat <- 0, nl1:Nat <- 0, nw':Nat <- 0, nl':Nat <- 0]{idle}
 *** applyStrictInComp('c) 
. 
)

mod CTEST is
 pr NAT .

 sort Conf .
 
 op mkConf : Nat Nat -> Conf [ctor] .
 
 var n1 n2 n3 n4 n5 n6 : Nat .
 
 crl [incFst] :
  mkConf(n1, n2) => mkConf(n1 + 1, n2 + 1) 
 if n1 < 10 . 
 
 crl [trans] : 
  mkConf(n1, n2) => mkConf(n5, n2 + n4 + n6)
  if
  mkConf(n1, 0) => mkConf(n3, n4)
  /\
  mkConf(n3, 0) => mkConf(n5, n6) 
 .

endm

smod CTESTS is

 pr CTEST .
 
 var c : Conf .
 
 strat appTrans @ Conf .
 sd appTrans := 
    trans{incFst, incFst}
 .

endsm

