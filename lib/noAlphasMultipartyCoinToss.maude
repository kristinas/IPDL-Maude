***( IPDL

  Copyright : (C) 2022, Kristina Sojakova
  License   : GNU General Public License v3.0 or later (GPL-3.0-or-later)
  Authors   : Mihai Codescu <mscodescu@gmail.com>
              Kristina Sojakova <sojakova.kristina@gmail.com>

)

load ../src/noAlphasStrategies

mod COIN-TOSS is
 protecting PROTOCOL-EQUALITY .

 op msg  : -> Type .
 op key  : -> Type .
 op ctxt : -> Type .
 
 op xorF : -> SigElem .
 eq xorF = 'xor : (bool * bool) ~> bool .
 
 op zerosF : -> SigElem .
 eq zerosF = 'zeros : unit ~> msg .
 
 op decF : -> SigElem .
 eq decF = 'dec : (ctxt * key) ~> msg .
 
 op encF : -> SigElem .
 eq encF = 'enc : (msg * key) ~>> ctxt .

 op muKeySym : -> SigElem .
 eq muKeySym = 'mu_key : unit ~>> key .
 
 op secSig : -> Signature .
 eq secSig = muKeySym encF decF zerosF xorF .
 
 op n : -> Nat .
   
 op idealPlusSim : -> Protocol .
 eq idealPlusSim = 
    newfamily 'AllOpen 'i (bound (n + 2)) : unit in
    newfamily 'Commit 'i (bound n) : bool in
    newfamily 'Committed 'i (bound (n + 1)) : unit in
    new 'Flip : bool in
    new 'LastCommit : bool in
    newfamily 'LeakCommitted_comm_adv 'i (bound (n + 1)) : unit in
    new 'LeakFlip_id_adv : bool in
    newfamily 'LeakOpened_comm_adv 'i (bound (n + 1)) : bool in
    new 'Ok_adv_id : unit in
    newfamily 'Open 'i (bound (n + 1)) : unit in
    newfamily 'Opened 'i (bound (n + 1)) : bool in
    newfamily 'SumCommit 'i (bound (n + 2)) : bool in
   ( *** new starts here 
    ('Flip ::= nf(emptyBRList, samp flip, emptyCNameList))
    || 
    ('LeakFlip_id_adv ::= nf( 'f : bool <- read 'Flip, return 'f, 'f :: emptyCNameList)
    )   
    ||
    (family 'Out 'i (bound (n + 1)) ::= 
        (when (apply 'honest 'i) --> nf(
                                      ('okAdvId : unit <- read 'Ok_adv_id)
                                      ('f : bool <- read 'Flip), 
                                      return 'f, 
                                      'okAdvId :: 'f :: emptyCNameList)
        ) ;;
        (otherwise --> nf('out : bool <- read ('Out ['i]), return 'out, 'out :: emptyCNameList)
        )
    )
    ||
    ('Ok_adv_id ::= nf(('ao : unit <- read ('AllOpen [ n + 2]))
                       ('sc : bool <- read ('SumCommit [ n + 1])),
                        return (), 'ao :: 'sc :: emptyCNameList)
    )   
    ||
    (family 'Commit 'i (bound n) ::= 
       (when (apply 'honest 'i)  --> nf(emptyBRList, samp flip, emptyCNameList)) ;;
       (otherwise --> 
          nf('advCommit : bool <- read ('AdvCommit_adv_party ['i]), 
             return 'advCommit, 
             'advCommit :: emptyCNameList)
       )
    )
    ||
    ('LastCommit ::= nf( ('sc : bool <- read ('SumCommit [ n + 1 ]))
                         ('leakF : bool <- read 'LeakFlip_id_adv),
                         return (ap 'xor pair('sc, 'leakF)),
                         'sc :: 'leakF :: emptyCNameList 
                     )
    )
    ||
    (family 'SumCommit 'i (bound (n + 2)) ::= 
        (when ('i =T= 0) --> nf(emptyBRList, return False, emptyCNameList)) ;; 
        (when ('i =T= (n + 2)) --> 
               nf( ('sc : bool <- read ('SumCommit [ n + 1 ])) 
                   ('lastC : bool <- read 'LastCommit) ,
                   return (ap 'xor pair('sc, 'lastC)) ,
                   'sc :: 'lastC :: emptyCNameList )
        )          ;;
        (otherwise --> nf(('sc : bool <- read ('SumCommit ['i -- 1])) 
                          ('c : bool <- read ('Commit ['i -- 1])),
                          return (ap 'xor pair('sc, 'c)),
                          'sc :: 'c :: emptyCNameList )
        )                  
    )
    ||
    (family 'Committed 'i (bound (n + 1)) ::=
        (when ('i =T= (n + 1)) --> nf(emptyBRList, return (), emptyCNameList)) ;;
        (otherwise --> nf('c : bool <- read ('Commit ['i]),
                       return (),
                       'c :: emptyCNameList )
        )
    )
    ||
    (family 'LeakCommitted_comm_adv 'i (bound (n + 1)) ::= 
       nf('ctd : unit <- read ('Committed ['i]), 
          return 'ctd, 
          'ctd :: emptyCNameList)
    )
    ||
    (family 'Open 'i (bound (n + 1)) ::= 
      (when (apply 'honest 'i)  --> 
        nf('sc : bool <- read ('SumCommit [n + 2]), return (), 'sc :: emptyCNameList)
      ) ;;
      (otherwise --> 
        nf('advOpen : unit <- read ('AdvOpen_adv_party ['i]) , return 'advOpen, 'advOpen :: emptyCNameList)
      )
    )  
    ||
    (family 'AllOpen 'i (bound (n + 2)) ::= 
      (when ('i =T= 0) --> nf(emptyBRList, return (), emptyCNameList)) ;;
      (otherwise --> nf(('ao : unit <- read ('AllOpen ['i -- 1]))
                        ('o : unit <- read ('Open ['i -- 1])),
                        return (),
                        'ao :: 'o :: emptyCNameList
                   )
      )
    )
    ||
    (family 'Opened 'i (bound (n + 1)) ::= 
                      nf (('o : unit <- read ('Open ['i]))
                          ('c : bool <- read ('Commit ['i])),
                          return 'c,
                          'o :: 'c :: emptyCNameList
                      )
    )
    ||
    (family 'LeakOpened_comm_adv 'i (bound (n + 1)) ::= 
       nf('opened : bool <- read ('Opened ['i]), return 'opened, 'opened :: emptyCNameList)
    )
   ) *** new ends here, leave here

   .
   
  op real : -> Protocol .
 eq real =  
    newfamily 'Commit 'i (bound (n + 1)) : bool in
    newfamily 'Committed 'i (bound (n + 1)) : unit in
    newfamily 'LeakCommitted_comm_adv 'i (bound (n + 1)) : unit in
    newfamily 'LeakOpened_comm_adv 'i (bound (n + 1)) : bool in
    newfamily 'Open 'i (bound (n + 1)) : unit in
    newfamily 'Opened 'i (bound (n + 1)) : bool in   
  (*** new
  (
  family 'Party 'i (bound (n + 1)) ::= 
    (
     (when (apply 'honest 'i)  --> 
     newfamily 'AllCommitted ('i 'j) ((bound (n + 1))(uniformBound (n + 2))) : unit in 
     newfamily 'SumOpened ('i 'j) ((bound (n + 1))(uniformBound (n + 2))) : bool in
     ( *** start new
     (family 'Commit 'i (bound (n + 1))  ::= nf(emptyBRList, samp flip, emptyCNameList)
     )
     ||
     (family 'AllCommitted ('i 'j) ((bound (n + 1)) (uniformBound (n + 2))) ::=
        (when ('j =T= 0) --> nf(emptyBRList, return (), emptyCNameList))
        ;;
        (otherwise -->  nf( ('ac : unit <- read ('AllCommitted ['i ('j -- 1)] ))
                            ('ctd : unit <- read ('Committed [ 'j -- 1]) ),
                            return (),  
                            'ac :: 'ctd :: emptyCNameList
                      )
        )
     )                 
     ||
     (family 'Open 'i (bound (n + 1))  ::= 
                   nf('ac : unit  <- read ('AllCommitted ['i (n + 2) ]), 
                      return (),
                      'ac :: emptyCNameList)
     )
     ||
     (family 'SumOpened ('i 'j) ((bound (n + 1))  (uniformBound (n + 2)))   ::= 
       (when ('j =T= 0) --> nf(emptyBRList, return False, emptyCNameList)  ) ;;
       (otherwise --> nf(('so : bool <- read ('SumOpened [ 'i ('j -- 1) ]))
                         ('opened : bool <- read ('Opened ['j -- 1])),
                         return (ap 'xor pair('so, 'opened)),
                         'so :: 'opened :: emptyCNameList)
       )
     )
     ||
     (
     family 'Out 'i (bound (n + 1))  ::= 
        nf('so : bool <- read ('SumOpened ['i (n + 2)]), 
           return 'so,
           'so :: emptyCNameList)
     ) 
     ) *** end new   
     ) *** end honest
     ;;
     (otherwise --> 
      ( *** start new
     (family 'Commit 'i (bound (n + 1))  ::= 
       nf('advCommit : bool <- read ('AdvCommit_adv_party ['i]),
          return 'advCommit, 
          'advCommit :: emptyCNameList)
     )  
     ||
     (family 'Open 'i (bound (n + 1))  ::= 
       nf('advOpen : unit <- read ('AdvOpen_adv_party ['i]),
          return 'advOpen, 
          'advOpen :: emptyCNameList)
     )
     ||
     (family 'Out 'i (bound (n + 1))  ::= 
       nf('out : bool <- read ('Out ['i]),
          return 'out, 
          'out :: emptyCNameList)
     )
     ) *** end new    
     ) *** end corrupt
    ) *** end party
  ) *** end family
  ||  
  (
  family 'Commitment 'i (bound (n + 1)) ::= 
    (family 'Committed 'i (bound (n + 1)) ::= 
                        nf('c : bool <- read ('Commit ['i]),
                        return (),
                        'c :: emptyCNameList)
   )
   ||
   (family 'LeakCommitted_comm_adv 'i (bound (n + 1))  ::= 
     nf( 'ctd : unit <- read ('Committed ['i]),
         return 'ctd,
         'ctd :: emptyCNameList
       )
   )
   ||
   (family 'Opened 'i (bound (n + 1))  ::= 
        nf(('o : unit <- read ('Open ['i]))
           ('c : bool <- read ('Commit ['i])),
           return 'c,
           'o :: 'c :: emptyCNameList
          )
    )
    ||
    (family 'LeakOpened_comm_adv 'i (bound (n + 1))  ::= 
      nf('opened : bool <- read ('Opened ['i]),
         return 'opened,
         'opened :: emptyCNameList
        )
    )
  ) *** end commitment
  ) *** end new
  .

 endm 
  
smod EXECUTE is
 pr STRATS .
 pr COIN-TOSS .
 
 var x y x1 x2 : Qid .
 var Sigma : Signature .
 var Delta : ChannelContext .
 var Gamma : VarContext .
 var I O : Set{CNameBound} .
 var A : Set{BoolTerm} .
 var cn : ChannelName .
 var pConf : ProtocolConfig .
 var P : Protocol .
 
 *******************************
 *** assumptions
 *******************************
 
 eq ap 'xor pair(ap 'xor pair(x1, x2), x2) = x1 .
 eq ap 'xor pair(x1, ap 'xor pair(x1, x2)) = x2 .  
 
 rl [flip-invar-xor-r] : rConfig(Sigma, Delta, Gamma (x : bool),
            y : bool <- samp flip ; 
            return (ap 'xor pair(x, y)), I, A, bool
            )
            => 
            rConfig(Sigma, Delta , Gamma (x : bool),
            samp flip, I, A, bool) .  
            
 rl [flip-invar-xor-l] : rConfig(Sigma, Delta, Gamma (y : bool),
            x : bool <- samp flip ; 
            return (ap 'xor pair(x, y)), I, A, bool
            )
            => 
            rConfig(Sigma, Delta , Gamma (y : bool),
            samp flip, I, A, bool) .  
 
 *********************************
 *** strategies for assumptions
 *********************************
  
 *** applies the flip-invar-xor-r to R from
 *** cn ::= nf(BRL, R, QL)
 
 strat applyAR : ChannelName @ Protocol .
 sd applyAR(cn) := 
      match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyAR(cn)}
    : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P cn, 
                             P1:Protocol <- keepOne P cn]
             {CONG-REACT[o:ChannelName <- cn]
                { *** This was here but should go away before this strat applies! (try (pre2Nf)) ;
                  cong-nf{flip-invar-xor-r}
                }
             } .            
  
 
  **********************************
  *** auxiliary protocols for real
  **********************************

 ******************************************
 *** auxiliary protocols for idealPlusSim
 ******************************************     

    
 ***************************************
 *** induction proofs
 *************************************** 
 
 var q1 q2 q3 Q : Qid .
 var pr : Protocol .
  
 var pr7 pr8 : Protocol .
  
 var pr9 pr10 : Protocol .  
 
 *** induction proof 1
 
 strat applyCaseDistInd : Qid Qid Qid Protocol @ ProtocolConfig .
 sd applyCaseDistInd(q1, q2, q3, pr) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyCaseDistInd(q1, q2, q3, pr)}
    : CASE-DISTINCTION-one[aQid:Qid <- q1]
         { use-family-p[C:Qid <- q2]
             { comp-new-families
             ; (applyIndStep1(q3) )
             ; (SYM[P1:Protocol <- pr]{comp-new-families})
             }
         , idle
         } 
 . 
 
 strat applyIndStep1 : Qid @ ProtocolConfig .
 sd applyIndStep1(Q) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyIndStep1(Q)} 
     : INDUCTION-when-two[
         C:Qid <- Q, 
         cases':Cases <-
           nf('ac1 : unit <- read ('AllCommitted1['j]), return 'ac1, 'ac1 :: emptyCNameList)
        ]
        {*** ind base:
          applySubstRevFamily('AllCommitted1, 'AllCommitted ['i 0], unit, 'ac1),
         *** ind step:
          nTimesSubstNFReadFamilyTwo('AllCommitted, 'AllCommitted['i ('k ++ 1)]) 
        ; nTimesSubstFamiliesOne('AllCommitted1, 'AllCommitted['i ('k ++ 1)], 'k ++ 1, unit, 'ac1)
        }
 . 
 
 ***(
 
 *** induction proof 2
 
 strat applyCaseDistInd2 : Qid Qid Qid Protocol @ ProtocolConfig .
 sd applyCaseDistInd2(q1, q2, q3, pr) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyCaseDistInd2(q1, q2, q3, pr)}
    : CASE-DISTINCTION-one[aQid:Qid <- q1]
         { use-family-p[C:Qid <- q2]
             { comp-new-families
             ; (applyIndStep2(q3) )
             ; (SYM[P1:Protocol <- pr]
                 {comp-new-families
                 }
               )
             }
         , idle
         } .  
         
 strat applyIndStep2 : Qid @ ProtocolConfig .
 sd applyIndStep2(Q) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyIndStep2(Q)} 
     : INDUCTION-when-two[
         C:Qid <- Q, 
         cases':Cases <-
           nf('x : bool <- read ('SumOpened1['j]), return 'x, 'x :: emptyCNameList)
        ]
        {*** ind base:
          applySubstRevFamily('SumOpened1, 'SumOpened ['i 0], bool),
         *** ind step:
          *** redOwiseTwo('SumOpened)
         nTimesSubstNFReadFamilyTwo('SumOpened, 'SumOpened['i ('k ++ 1)]) 
        ; nTimesSubstFamiliesOne('SumOpened1, 'SumOpened['i ('k ++ 1)], 'k ++ 1, bool)
        *** ; addOwiseTwo('SumOpened)
        } 
 .
 
 *** induction proof 3

 
 strat applyIndStep3 : Qid Protocol Protocol @ ProtocolConfig .
 sd applyIndStep3(Q, pr7, pr8) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyIndStep3(Q, pr7, pr8)} 
     : 
      INDUCTION-when-one[
         C:Qid <- Q, 
         cases':Cases <-
           nf('sc : bool <- read ('SumCommit['i]), 
              return (), 
              'sc :: emptyCNameList)
        ]
        {*** ind base:
          SYM[P1:Protocol <- pr7]
           {substNFFamilyOne('SumCommit, 'AllCommitted1[0], 
                             nf(emptyBRList, return False, emptyCNameList)
                             )
           }  ,
         *** ind step:
          substNFFamilyOne('AllCommitted1, 'AllCommitted1['k ++ 1],   
                           nf('sc : bool <- read ('SumCommit['k]), 
                              return (), 
                              'sc :: emptyCNameList)
          )
     ; substNFFamilyOne('Committed, 'AllCommitted1['k ++ 1], 
         nf('x : bool <- read ('Commit['k]), return (), 'x :: emptyCNameList)
      )
     ; applyAlphaNFPr('AllCommitted1['k ++ 1], << 'sc,'xj >> << 'x,'cj >> emptyQidPairList)
     ; SYM[P1:Protocol <- pr8]
     {substNFFamilyOne('SumCommit, 'AllCommitted1['k ++ 1], 
      nf(('xj : bool <- read ('SumCommit['k]))
                           ('cj : bool <- read ('Commit['k])),
                           return (ap 'xor pair('xj, 'cj)),
                           'xj :: 'cj :: emptyCNameList
                        )
      ) }
        } 
 .  
 
 *** induction proof 4
      
         
 strat applyIndStep4 : Qid Protocol Protocol @ ProtocolConfig .
 sd applyIndStep4(Q, pr9, pr10) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyIndStep4(Q, pr9, pr10)} 
     : 
      INDUCTION-when-one[
         C:Qid <- Q, 
         cases':Cases <-
           nf(('ao : unit <- read ('AllOpen['i])) 
                          ('sc : bool <- read ('SumCommit['i])),
                          return 'sc,
                          'ao :: 'sc :: emptyCNameList )
        ]
        {*** ind base:
          SYM[P1:Protocol <- pr9] 
      {
       substNFFamilyOne('AllOpen, 'SumOpened1[0], 
                             nf(emptyBRList, return (), emptyCNameList)
                             )
     ; substNFFamilyOne('SumCommit, 'SumOpened1[0], 
                             nf(emptyBRList, return False, emptyCNameList)
                             )          
                   } 
          ,
         *** ind step:
          substNFFamilyOne('SumOpened1, 'SumOpened1['k ++ 1], 
                         nf(('ao : unit <- read ('AllOpen['k])) 
                          ('sc : bool <- read ('SumCommit['k])),
                          return 'sc,
                          'ao :: 'sc :: emptyCNameList )
                             ) 
 ; substNFFamilyOne('Opened, 'SumOpened1['k ++ 1], 
                            nf( ('commit : bool <- read ('Commit['k])) 
            ('x : unit <- read ('Open['k])), 
            return 'commit, 
            'x :: 'commit :: emptyCNameList)
                    )
  ; SYM[P1:Protocol <- pr10]
  {
  substNFFamilyOne('AllOpen, 'SumOpened1['k ++ 1], 
                         nf(('x : unit <- read ('AllOpen['k]))
                         ('y : unit <- read ('Open['k])),
                         return (),
                      'x :: 'y :: emptyCNameList)
                             )
   ; substNFFamilyOne('SumCommit, 'SumOpened1['k ++ 1], 
                         nf(('cj : bool <- read ('Commit['k])) 
                                'xj : bool <- read ('SumCommit['k]), 
                                return (ap 'xor pair('xj, 'cj)),
                                'xj :: 'cj :: emptyCNameList)
                             ) 
   ; applyAlphaNFPr('SumOpened1['k ++ 1],
         
        << 'x,'ao >> 
        << 'cj,'commit >> 
        << 'y,'x >>
        << 'xj,'sc >>
         emptyQidPairList)  
   ; changeOrder('SumOpened1['k ++ 1], 
     'ao :: 'sc :: 'x :: 'commit :: emptyCNameList)
  }                      
        } 
 .  

) *** end comment      

endsm

*** this is the main proof
srew [1] pConfig(secSig, 
                 ('AdvCommit_adv_party @ (n + 1) :: bool) 
    ('AdvOpen_adv_party @ (n + 1) :: unit) 
    ('Out @ (n + 1) :: bool),
                 real,
                 insert('AdvCommit_adv_party @ (n + 1), 'AdvOpen_adv_party @ (n + 1)), 
    'Out @ (n + 1),
                 insert(apply 'honest (n + 1), empty)
                ) 
   using   sugar-newNF 
         ; absorbReverseFamily
            ('Commitment, 
             newfamily 'AllCommitted1 'i (bound(n + 2)) : unit in 
              family 'AllCommitted1 'i (bound(n + 2)) ::= 
                (when ('i =T= 0) --> nf(emptyBRList, return (), emptyCNameList)) ;;
                (otherwise --> 
                   nf(('ac1 : unit <- read ('AllCommitted1['i -- 1]))
                      ('ctd : unit <- read ('Committed['i -- 1])),
                      return (),
                      'ac1 :: 'ctd :: emptyCNameList
                     )
                )
            )
             ***(
        ; applyCaseDistInd('Party, 'Commitment, 'AllCommitted, prot1)       
        ; applyCaseDistSubst('Party, 'Commitment, 'Open, 'AllCommitted, prot2) 
        ; applyCaseDistAbsorb('Party, 'Commitment, 'AllCommitted, prot3) 
        ; absorbReverseFamily
            ('Commitment, 
             newNF( 
                    {'SumOpened1 'i (bound (n + 2)) : bool},
              family 'SumOpened1 'i (bound (n + 2)) ::= 
                (when ('i =T= 0) --> nf(emptyBRList, return False, emptyCNameList)) ;;
                (otherwise --> 
                   nf(('x : bool <- read ('SumOpened1['i -- 1]))
                      ('y : bool <- read ('Opened['i -- 1])),
                      return (ap 'xor pair('x, 'y)),
                      'x :: 'y :: emptyCNameList
                     )
                ),
                'SumOpened1 :: emptyCNameList
                )
            ) 
        ; applyCaseDistInd2('Party, 'Commitment, 'SumOpened, prot4) 

        ; applyCaseDistSubst('Party, 'Commitment, 'Out, 'SumOpened, prot5)
        ; applyCaseDistAbsorb('Party, 'Commitment, 'SumOpened, prot6)  
        *** these aren't actual proof steps, they massage the protocol to get to 
        *** the combined form. We should have a strategy that merges them
        ; applyDeleteEmptyNF('Party)
        ; applyDropName('Commitment)
        ; applyCombine('Party)
        ; moveProtocolUnderNewNF
        ; lift-inner-new-nf 
        *** up to here
        *** now back to proof 
        ; absorbReverseNewNF(
           newNF( {'SumCommit 'i (bound (n + 2)) : bool},
                  family 'SumCommit 'i (bound(n + 2)) ::=
                   (when ('i =T= 0) --> nf(emptyBRList, return False, emptyCNameList))
                   ;;
                   (otherwise --> 
                      nf(('xj : bool <- read ('SumCommit['i -- 1]))
                         ('cj : bool <- read ('Commit['i -- 1])),
                         return (ap 'xor pair('xj, 'cj)),
                      'xj :: 'cj :: emptyCNameList
                     )
                      )
                  , 'SumCommit :: emptyCNameList
           ) 
          ) 

         ; applyIndStep3('AllCommitted1, prot70, prot80) 
         ; applySubstCaseDist('Open, 'AllCommitted1, 
            nf('sc : bool <- read ('SumCommit[n + 2]), return (), 'sc :: emptyCNameList)
           )
         ; absorbFamily('AllCommitted1)  
         ; absorbReverseNewNF(
           newNF( {'AllOpen 'i (bound (n + 2)) : unit},
                  family 'AllOpen 'i (bound(n + 2)) ::=
                   (when ('i =T= 0) --> nf(emptyBRList, return (), emptyCNameList))
                   ;;
                   (otherwise --> 
                      nf(('x : unit <- read ('AllOpen['i -- 1]))
                         ('y : unit <- read ('Open['i -- 1])),
                         return (),
                      'x :: 'y :: emptyCNameList
                     )
                      )
                  , 'AllOpen :: emptyCNameList
           ) 
          ) 
                         
       ; applyIndStep4('SumOpened1, prot90, prot100)
       ; applySubstCaseDist('Out, 'SumOpened1, 
             nf(('ao : unit <- read ('AllOpen[n + 2])) 
                 'sc : bool <- read ('SumCommit[n + 2]), 
                 return 'sc, 'ao :: 'sc :: emptyCNameList)
         )
       ; absorbFamily('SumOpened1)   
       ; *** quickfix
          reorder-newNF[ql2:CNameList <- 
          'AllOpen :: 'Commit :: 'Committed :: 'LeakCommitted_comm_adv ::
          'LeakOpened_comm_adv :: 'Open :: 'Opened :: 'SumCommit :: emptyCNameList
          ]
       ; applyBranch2Alpha('SumCommit, 
            << 'cj,'c >> 
            << 'xj,'x >>
            emptyQidPairList, 
            nf(('c : bool <- read ('Commit['i -- 1])) 
                'x : bool <- read ('SumCommit['i -- 1]), 
                return (ap 'xor pair('x, 'c)), 
                'x :: 'c :: emptyCNameList)
          )      
          ***( 
          ; SYM[P1:Protocol <- idealPlusSim]
            {
            sugar-newNF   
         ; smart-subst-nf('LeakFlip_id_adv, 'LastCommit )
         ; absorbChannel('LeakFlip_id_adv)
         ; applySubstChannelBranch('Out, 'Ok_adv_id)
         ; absorbChannel('Ok_adv_id)
         ; applyCaseDistBranch2('SumCommit, 'LastCommit)
         ; applyBranch2MoveReads('Out)
         ; applyBranch2SubstRev('Out, 'SumCommit, n + 2, 'sc, bool,
             nf( ('f : bool <- read 'Flip) 
                 ('x : bool <- read ('SumCommit [ n + 1 ])) ,
                   return 'f ,
                   'x :: 'f :: emptyCNameList )
                   )         
         ; SYM[P1:Protocol <- i1]{
             sugar-newNF
           ; applyCaseDistBranch2('SumCommit, 'LastCommit) 
         }  
         ; sugar-newNF
                 
         ; foldNF('Flip, 'LastCommit) 
         ; applyAR('LastCommit)
         ; SYM[P1:Protocol <- i2]{
            foldNF('Commit[n + 1], 'LastCommit) 
         } 
         ; wrap-channel-family
         ; applyCaseDistBranch2('SumCommit, 'LastCommit)
         ; absorbChannel('LastCommit)
         ; SYM[P1:Protocol <- i3]{
             unwrap-channel-family[C:Qid <- 'Commit]
      ; unwrap-channel-family[C:Qid <- 'Committed]
      ; applyUnusedNF('Commit[n + 1], 'Committed[n + 1])
      ; wrap-channel-family[C:Qid <- 'Commit]
      ; wrap-channel-family-new-R[C:Qid <- 'Committed]
         }
         ; merge-cases[C:Qid <- 'SumCommit]
         ; applyReorderNF('Out, 'ao :: 'sc :: emptyCNameList)
            }
            )
      ) *** end comment      
.


***( sym proof for ideal plus sim:
srew [1] pConfig(secSig, 
                 ('AdvCommit_adv_party @ (n + 1) :: bool) 
    ('AdvOpen_adv_party @ (n + 1) :: unit) 
    ('Out @ (n + 1) :: bool),
                 idealPlusSim,
                 insert('AdvCommit_adv_party @ (n + 1), 'AdvOpen_adv_party @ (n + 1)), 
    'Out @ (n + 1),
                 insert(apply 'honest (n + 1), empty)
                ) 
   using   sugar-newNF   
         ; smart-subst-nf('LeakFlip_id_adv, 'LastCommit )
         ; absorbChannel('LeakFlip_id_adv)
         ; applySubstChannelBranch('Out, 'Ok_adv_id)
         ; absorbChannel('Ok_adv_id)
         ; applyCaseDistBranch2('SumCommit, 'LastCommit)
         ; applyBranch2MoveReads('Out)                           
         ; applyBranch2SubstRev('Out, 'SumCommit, n + 2, 'sc, bool,
             nf( ('f : bool <- read 'Flip) 
                 ('x : bool <- read ('SumCommit [ n + 1 ])) ,
                   return 'f ,
                   'x :: 'f :: emptyCNameList )
                   )        
         ; SYM[P1:Protocol <- i1]{
             sugar-newNF
           ; applyCaseDistBranch2('SumCommit, 'LastCommit) 
         }  
         ; sugar-newNF
                 
         ; foldNF('Flip, 'LastCommit) 
         ; applyAR('LastCommit)
         ; SYM[P1:Protocol <- i2]{
            foldNF('Commit[n + 1], 'LastCommit) 
         } 
         ; wrap-channel-family
         ; applyCaseDistBranch2('SumCommit, 'LastCommit)
         ; absorbChannel('LastCommit)
         ; SYM[P1:Protocol <- i3]{
             unwrap-channel-family[C:Qid <- 'Commit]
      ; unwrap-channel-family[C:Qid <- 'Committed]
      ; applyUnusedNF('Commit[n + 1], 'Committed[n + 1])
      ; wrap-channel-family[C:Qid <- 'Commit]
      ; wrap-channel-family-new-R[C:Qid <- 'Committed]
         }
         ; merge-cases[C:Qid <- 'SumCommit]
         ; applyReorderNF('Out, 'ao :: 'sc :: emptyCNameList)
.
) *** end comment

*** induction proof
srew [1]
pConfig(secSig, 
    ('AdvCommit_adv_party @ (n ++ 1) :: bool) 
    ('AdvOpen_adv_party @ (n ++ 1) :: unit) 
    ('Out @ (n ++ 1) :: bool)
    ('Commit @ (n ++ 1) :: bool) 
    ('Committed @ (n ++ 1) :: unit)
    ('LeakCommitted_comm_adv @ (n ++ 1) :: unit)
    ('LeakOpened_comm_adv @ (n ++ 1) :: bool)
    ('Open  @ (n ++ 1) :: unit)
    ('Opened @ (n ++ 1) :: bool),
    newNF(
          {'AllCommitted ('i 'j) (bound (n + 1) uniformBound (n + 2)) : unit} 
          {'SumOpened ('i 'j) (bound (n + 1) uniformBound (n + 2)) : bool}
          {'AllCommitted1 'i (bound (n + 2)) : unit} 
     ,	
        
          (family 'AllCommitted1 'i (bound (n + 2)) ::= 
             (when (0 =T= 'i) --> nf(emptyBRList, return (), emptyCNameList)) 
             ;; 
             otherwise --> nf(('ac1 : unit <- read ('AllCommitted1['i -- 1])) 
                               'ctd : unit <- read ('Committed['i -- 1]), 
                               return (), 
                               'ac1 :: 'ctd :: emptyCNameList)
          ) 
          || 
          (family 'Committed 'i (bound (n + 1)) ::= 
              nf('c : bool <- read ('Commit['i]), return (), 'c :: emptyCNameList)
          ) 
          || 
          (family 'LeakCommitted_comm_adv 'i (bound (n + 1)) ::= 
             nf('ctd : unit <- read ('Committed['i]), return 'ctd, 'ctd :: emptyCNameList)
          ) 
          || 
          (family 'LeakOpened_comm_adv 'i (bound (n + 1)) ::= 
             nf('opened : bool <- read ('Opened['i]), return 'opened, 'opened :: emptyCNameList)
          ) 
          || 
          (family 'Opened 'i (bound (n + 1)) ::= 
             nf(('c : bool <- read ('Commit['i])) 
                 'o : unit <- read ('Open['i]), return 'c, 'o :: 'c :: emptyCNameList)
          )
          ||
          (family 'AllCommitted ('i 'j) ((bound (n + 1)) (uniformBound (n + 2))) ::= 
            (when (0 =T= 'j) --> nf(emptyBRList, return (), emptyCNameList)) 
            ;;
            otherwise --> 
               nf(('ac : unit <- read ('AllCommitted['i ('j -- 1)])) 
                   'ctd : unit <- read ('Committed['j -- 1]), 
                   return (), 
                   'ac :: 'ctd :: emptyCNameList)
          ) 
          || 
          (family 'Commit 'i (bound (n + 1)) ::= nf(emptyBRList, samp flip, emptyCNameList)
          ) 
          || 
          (family 'Open 'i (bound (n + 1)) ::= 
             nf( 'ac : unit <- read ('AllCommitted['i (n + 2)]), return (), 'ac :: emptyCNameList)
          ) 
          || 
          (family 'Out 'i (bound (n + 1)) ::= 
             nf('so : bool <- read ('SumOpened['i (n + 2)]), return 'so, 'so :: emptyCNameList)
          ) 
          || 
          family 'SumOpened ('i 'j) ((bound (n + 1)) (uniformBound (n + 2))) ::= 
            (when (0 =T= 'j) --> nf(emptyBRList, return False, emptyCNameList)) 
            ;; 
            otherwise --> nf(('opened : bool <- read ('Opened['j -- 1])) 
                              'so : bool <- read ('SumOpened['i ('j -- 1)]), 
                              return (ap 'xor pair('so, 'opened)), 
                              'so :: 'opened :: emptyCNameList),
    'AllCommitted :: 'SumOpened :: 'AllCommitted1 :: emptyCNameList
     ),
         insert('AdvCommit_adv_party @ (n ++ 1), 'AdvOpen_adv_party @ (n ++ 1)), 
         insert('Commit @ (n ++ 1),  
          insert('Committed @ (n ++ 1),
           insert('LeakCommitted_comm_adv @ (n ++ 1),
            insert('LeakOpened_comm_adv @ (n ++ 1),
             insert('Open  @ (n ++ 1),
              insert('Opened @ (n ++ 1),
                     'Out @ (n ++ 1)
                     )))))), 
    insert(apply 'honest (n + 1), empty)
)
 using 
    applyIndStep1('AllCommitted) 
   *** idle
 .

