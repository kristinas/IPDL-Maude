***( IPDL

  Copyright : (C) 2022-23, Kristina Sojakova, Mihai Codescu
  License   : GNU General Public License v3.0 or later (GPL-3.0-or-later)
  Authors   : Mihai Codescu <mscodescu@gmail.com>
              Kristina Sojakova <sojakova.kristina@gmail.com>

Multi-Party GMW Protocol
See Sec. 9 in doc/case-studies.pdf

)

load ../src/strategies

mod GMWN is
 including APPROX-EQUALITY .
 protecting LIST{NatPairs} .
 
 
 op sumF : -> SigElem .
 eq sumF = 'xor : (bool * bool) ~> bool .
 *** xor is +
 
 op mulF : -> SigElem .
 eq mulF = 'and : (bool * bool) ~> bool .
 *** and is *
 
 op negF : -> SigElem .
 eq negF = 'neg : bool ~> bool .
 
 op flipF : -> SigElem .
 eq flipF = 'flip : unit ~>> bool .
 
 op sig : -> Signature .
 eq sig = sumF mulF negF flipF .
 
 var i j l k n : Nat .
 
 *** global parameters
 
 op N : -> Nat . 
 
 op K : -> Nat .
 
 *** for each party p, I(p) is the number of inputs for p
 op I : Nat -> Nat . 
 
 op C : -> Circuit . *** the circuit acting as parameter
 
 *** gates and circuits
 
 sort Gate .
 
 op input-gate : Nat Nat -> Gate [ctor] . *** first nat is the party
 op not-gate : Nat -> Gate [ctor] .
 op xor-gate : Nat Nat -> Gate [ctor] .
 op and-gate : Nat Nat -> Gate [ctor] .
 
 sort Circuit . *** list of gates
 subsort Gate < Circuit .
 op emptyCircuit : -> Circuit [ctor] .
 op __ : Circuit Circuit -> Circuit [ctor assoc id: emptyCircuit] .

 op wellFormed : Circuit Nat -> Bool .
 
 var circuit : Circuit .
 eq wellFormed(emptyCircuit, 0) = true .
 ceq wellFormed(circuit input-gate(i, j), s(n)) = true 
  if wellFormed(circuit, n) /\ i <= N + 1 /\ j < I(i) .
 ceq wellFormed(circuit not-gate(k), s(n)) = true
  if wellFormed(circuit, n) /\ k < n . 
 ceq wellFormed(circuit and-gate(k, l), s(n)) = true
  if wellFormed(circuit, n) /\ k < n /\ l < n .
 ceq wellFormed(circuit xor-gate(k, l), s(n)) = true
  if wellFormed(circuit, n) /\ k < n /\ l < n .
  
 *** helpers
 *** get the gate at the start of the circuit, after i pops
 *** i must be at most the length of circuit
 *** the circuit must be non-empty
 
 var gate : Gate .
 
 op gateAt : Circuit Nat -> Gate .
 eq gateAt(gate circuit, 0) = gate .
 eq gateAt(gate circuit, s(n)) = gateAt(circuit, n) .
 
 *** the wires of a gate, as a list
 op wiresOf : Gate -> List{NatPairs} .
 eq wiresOf(input-gate(i, j)) = (0 ;; i) (1 ;; j) .
 eq wiresOf(not-gate(i)) = (0 ;; i) .
 eq wiresOf(and-gate(k, l)) = (0 ;; k) (1 ;; l) .
 eq wiresOf(xor-gate(k, l)) = (0 ;; k) (1 ;; l) .
 
 *** list as an unsafe map
 var natPairs : List{NatPairs} .
 op _@@_ : List{NatPairs} Nat -> Nat .
 eq ( (i ;; k) natPairs) @@ i = k .
 ceq ( (l ;; k) natPairs) @@ i = natPairs @@ i if l =/= i .
 
 *** wire 0 of the circuit C at a given gate
 op wire0 : Nat -> Nat .
 eq wire0(i) = wiresOf(gateAt(C, i)) @@ 0 .
 
 *** wire 1 of the circuit C at a given gate
 op wire1 : Nat -> Nat .
 eq wire1(i) = wiresOf(gateAt(C, i)) @@ 1 .
 
  *** here we connect 'wire0 with wire0 
 var nt nt1 nt2 : NatTerm .
 var f : Map{Qid, NatTerm} .
 ceq evalTerm (fun 'wire0 nt) f = wire0(evalTerm nt f) 
  if (evalTerm nt f) : Nat .
 eq evalTerm (fun 'wire0 nt) f = fun 'wire0 nt [owise] . 
 ceq evalTerm (fun 'wire1 nt) f = wire1(evalTerm nt f) 
  if (evalTerm nt f) : Nat .
 eq evalTerm (fun 'wire1 nt) f = fun 'wire1 nt [owise] .
 
 *** for I
 eq evalTerm (fun 'I nt) f = fun 'I (evalTerm nt f) . 

 *** here we record the assumptions on indices
 var q : Qid .
 var A : Set{BoolTerm} .
 
 ceq A |= fun 'wire0 nt <T (N + 2) with f = true 
   if (apply 'isInputGate (evalTerm nt f)) in A .
 
 ceq A |= fun 'wire0 nt <T K with f = true 
    if (apply 'isNotGate (evalTerm nt f)) in A .
 
 ceq A |= fun 'wire0 nt <T K with f = true 
    if (apply 'isXorGate (evalTerm nt f)) in A .
 ceq A |= fun 'wire1 nt <T K with f = true 
    if (apply 'isXorGate (evalTerm nt f)) in A .   
 
 ceq A |= fun 'wire0 nt <T K with f = true 
    if (apply 'isAndGate (evalTerm nt f)) in A .
 ceq A |= fun 'wire1 nt <T K with f = true 
    if (apply 'isAndGate (evalTerm nt f)) in A .
 
 
 ceq A |= fun 'wire0 nt <T nt with f = true  *** was N + 2
   if (apply 'isInputGate (evalTerm nt f)) in A .
 ceq A |= (fun 'wire1 nt <T fun 'I (fun 'wire0 nt)) with f = true 
    if (apply 'isInputGate (evalTerm nt f)) in A [label depBounds] .
 
 ceq A |= fun 'wire0 nt <T nt with f = true  *** was K here and below
    if (apply 'isNotGate (evalTerm nt f)) in A [label notIndex].
 
 ceq A |= fun 'wire0 nt <T nt with f = true 
    if (apply 'isXorGate (evalTerm nt f)) in A .
 ceq A |= fun 'wire1 nt <T nt with f = true 
    if (apply 'isXorGate (evalTerm nt f)) in A .   
 
 ceq A |= fun 'wire0 nt <T nt with f = true 
    if (apply 'isAndGate (evalTerm nt f)) in A [label andIndex] .
 ceq A |= fun 'wire1 nt <T nt with f = true 
    if (apply 'isAndGate (evalTerm nt f)) in A .
    
 ceq A |= fun 'wire0 nt1 <T nt2 with f = true 
  if A |= nt1 <T nt2 with f [label wireSmallThen0] .
 ceq A |= fun 'wire1 nt1 <T nt2 with f = true 
  if A |= nt1 <T nt2 with f [label wireSmallThen1] . 
 
  *** generic assumptions shared by both proofs
 op genA : -> Set{BoolTerm} .
 eq genA = ( neg (apply 'isXorGate 0), 
             neg (apply 'isAndGate 0), 
             neg (apply 'isNotGate 0),
             0 <T K,
             0 <T N + 2,
             N <T N + 1,
             N <T N + 2,
             N + 1 <T N + 2, 
             apply 'isHonest (N + 1) )
 . 
 
 eq (A, apply 'isHonest nt) |= neg (apply 'isSemiHonest nt) with f = true .
 eq (A, apply 'isSemiHonest nt) |= neg (apply 'isHonest nt) with f = true .
 
 *** record that a honest channel is not semi-honest
 *** sh to h (A, sh) |= h = false 
 *** h to sh (A, h) |= sh = false 
 
 *** delta
 
 op deltaIdealPlusSim : -> ChannelContext .
 eq deltaIdealPlusSim =
  (fam (('InRcvd ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) :: unit) 
             (fam (('InShare$-Sum ^^ 'party .. 'adv)[(bound (N + 1))((bound (N + 2))(dependentBound 'I))]) :: bool)
             (fam (('InShare$ ^^ 'party .. 'adv)[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]):: bool)
             (fam (('InShare$ ^^ 'party .. 'adv)[((fixedBound (N + 1)) (bound (N + 2)) (dependentBound 'I))]):: bool)
             (fam (('InShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) :: bool)
             (fam (('In ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) :: bool)  
             (fam (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 1))(bound K) )]) :: unit) 
             (fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (fixedBound (N + 1))(bound K) )]) :: unit) 
             (fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 1))(bound K) )]) :: unit)
             (fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (fixedBound (N + 1))(bound K) )]) :: unit) 
             (fam (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit)
             (fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam ('Out[((bound (N + 2))(bound K))]) :: bool)    
             (fam (('OutShareSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 1))(bound K) )]) :: bool)
             (fam (('OutShareSum ^^ 'party .. 'adv)[((bound (N + 2)) (fixedBound (N + 1))(bound K) )]) :: bool) 
             (fam (('OutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 1))(bound K) )]) :: bool)
             (fam (('OutShare ^^ 'party .. 'adv)[((bound (N + 2)) (fixedBound (N + 1))(bound K) )]) :: bool)
             (fam (('Out ^^ 'party .. 'adv)[((bound (N + 2))(bound K))]) :: bool)  
             (fam (('RcvdInShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) :: bool)  
             (fam (('RcvdOutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 1))(bound K) )]) :: bool) 
             (fam (('RcvdOutShare ^^ 'party .. 'adv)[((bound (N + 2)) (fixedBound (N + 1))(bound K) )]) :: bool) 
             (fam (('SendInShare ^^ 'party .. 'adv)[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) :: bool) 
             (fam (('SendInShare ^^ 'party .. 'adv)[((fixedBound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) :: bool) 
             (fam (('SendOutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool)  
             (fam (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))]) :: bool)
             (fam (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool)
             (fam (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool)  
             (fam ('In[(bound (N + 2)) (dependentBound 'I)]) :: bool)
 . 
 
 
 
 op delta : -> ChannelContext .
 eq delta = 
  (fam (('InRcvd ^^ 'party .. 'adv)[(bound (N + 2)) (dependentBound 'I)]) :: unit) 
  (fam (('InShare$-Sum ^^ 'party .. 'adv)[(bound (N + 1)) (bound (N + 2)) (dependentBound 'I)]) :: bool)
  (fam (('InShare$ ^^ 'party .. 'adv)
         [(bound (N + 2)) (bound (N + 2)) (dependentBound 'I)]
       ) :: bool)
  (fam (('InShare ^^ 'party .. 'adv)
        [(bound (N + 2)) (bound (N + 2)) (dependentBound 'I)]
       ) :: bool)
  (fam (('In ^^ 'party .. 'adv)
        [(bound (N + 2)) (dependentBound 'I)]
       ) :: bool)  
  (fam (('OTChc-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('OTChc-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: unit) 
  (fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: unit) 
  (fam (('OTMsg-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('OTMsg-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('OTMsg-2 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('OTMsg-3 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: unit)
  (fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: unit) 
  (fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: unit) 
  (fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: unit) 
  (fam (('OTOut ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam ('Out[(bound (N + 2)) (bound K)]) :: bool)    
  (fam (('OutShareSum ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('OutShare ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool)
  (fam (('Out ^^ 'party .. 'adv)[(bound (N + 2)) (bound K)]) :: bool)  
  (fam (('RcvdInShare ^^ 'party .. 'adv)
        [(bound (N + 2)) (bound (N + 2)) (dependentBound 'I)]
       ) :: bool)  
  (fam (('RcvdOutShare ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('SendInShare ^^ 'party .. 'adv)
        [(bound (N + 2)) (bound (N + 2)) (dependentBound 'I)]
       ) :: bool) 
  (fam (('SendOutShare ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool)  
  (fam (('Share ^^ 'party .. 'adv)[(bound (N + 2)) (bound K)]) :: bool)
  (fam (('Ctrb ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('RcvdBit ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('SendBit ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool)
  (fam (('CtrbSum ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool)  
  (fam ('In[(bound (N + 2)) (dependentBound 'I)]) :: bool)
   .
      
     *** ideal protocol
  
  op ideal : -> Protocol .
  eq ideal =
   newfamily ('Wire[bound K]) 'k (bound K) : bool in
   leakageIdeal || wiresIdeal || finalIdeal
  .
  
  op leakageIdeal : -> Protocol .
  eq leakageIdeal = 
     (family ('In ^^ 'id .. 'adv[((bound (N + 2))(dependentBound 'I))]) 
      ('n 'i) ((bound (N + 2))(dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('in : bool <- read ('In['n 'i]), return 'in, 'in)
       )
       ;;
       (when (apply 'isHonest 'n) --> 
         nf('in : bool <- read (('In ^^ 'id .. 'adv)['n 'i]), return 'in, 'in)
       )
     ) 
     ||
     (family ('InRcvd ^^ 'id .. 'adv[((bound (N + 2))(dependentBound 'I))]) 
       ('n 'i) ((bound (N + 2))(dependentBound 'I)) ::=
       (when (apply 'isHonest 'n) --> 
         nf('in : bool <- read ('In['n 'i]), return (), 'in)
       )
       ;;
       (when (apply 'isSemiHonest 'n) --> 
         nf('in : unit <- read (('InRcvd ^^ 'id .. 'adv)['n 'i]), 
            return 'in, 'in)
       )
     ) 
       
  .
  
  op wiresIdeal : -> Protocol .
  eq wiresIdeal = 
     family ('Wires[bound K]) 'k (bound K) ::= 
       (
        family ('Wire[bound K]) 'k (bound K) ::=
         (when (apply 'isInputGate 'k) --> 
           nf( 'i : bool <- read ('In[(fun 'wire0 'k) (fun 'wire1 'k)]), 
               return 'i, 'i)
         )
         ;;
         (when (apply 'isNotGate 'k) --> 
          nf('x : bool <- read ('Wire[fun 'wire0 'k]),
             return (ap 'neg 'x), 'x)
         )
         ;;
         (when (apply 'isXorGate 'k) --> 
          nf(('x : bool <- read ('Wire[fun 'wire0 'k]))
             ('y : bool <- read ('Wire[fun 'wire1 'k])),
             return (ap 'xor pair('x, 'y)), 'x 'y)
         )
         ;;
         (when (apply 'isAndGate 'k) --> 
          nf(('x : bool <- read ('Wire[fun 'wire0 'k]))
             ('y : bool <- read ('Wire[fun 'wire1 'k])),
             return (ap 'and pair('x, 'y)), 'x 'y)
         )
       )
  .
  
  op finalIdeal : -> Protocol .
  eq finalIdeal =
     (family (('Out ^^ 'id .. 'adv)[((bound (N + 2))(bound K))]) 
        ('n 'k) ((bound (N + 2))(bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('out : bool <- read ('Out['n 'k]), return 'out, 'out)
       )
       ;;
       (when (apply 'isHonest 'n) --> 
         nf('out : bool <- read (('Out ^^ 'id .. 'adv)['n 'k]), return 'out, 'out)
       )
     )
     ||
     (family ('Out[((bound (N + 2))(bound K))]) ('n 'k) ((bound (N + 2))(bound K)) ::=
       (when (apply 'isOutputWire 'k) --> 
         nf('out : bool <- read ('Wire['k]), return 'out, 'out)
       )
       ;;
       (when (neg (apply 'isOutputWire 'k)) --> 
         nf('o : bool <- read ('Out['n 'k]), return 'o, 'o)
       )
     
     )
  .
  
  *** sim protocol
  
   *** sim protocol
  
  op sim : -> Protocol .
  eq sim = 
     newfamily ('InShare[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) 
               ('m 'n 'i) 
               ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) : bool in
     newfamily ('Share[((bound (N + 1))(bound K))]) 
               ('n 'k) ((bound (N + 1))(bound K)) : bool in
     newfamily ('ShareSum[((bound (N + 1))(bound K))]) 
               ('m 'k) ((bound (N + 1))(bound K)) : bool in          
     initialSim || inductiveSim || finalSim || shareSim  
  . 
  
  op initialSim : -> Protocol .
  eq initialSim = 
     newfamily ('InShare$[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]) ('m 'n 'i) 
                ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) : bool in
     newfamily ('InShare$-Sum[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]) 
                ('m 'n 'i) 
                ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) : bool in
     (
     (family (('In ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) ('n 'i)
             ((bound (N + 2))(dependentBound 'I)) ::=
        ( (when (apply 'isSemiHonest 'n) -->
           nf('in : bool <- read (('In ^^ 'id .. 'adv) ['n 'i]), 
               return 'in, 'in)  
         ) 
         ;;
         (when (apply 'isHonest 'n) --> *** diverge
           nf('in : bool <- read (('In ^^ 'party .. 'adv) ['n 'i]), 
               return 'in, 'in)  
         )
       
       )      
     )
     ||
     (family (('InRcvd ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) ('n 'i)
             ((bound (N + 2))(dependentBound 'I)) ::=
             
       (when (apply 'isHonest 'n) -->
nf('x : unit <- read (('InRcvd ^^ 'id .. 'adv) ['n 'i]), return (), 'x))
;;
when (apply 'isSemiHonest 'n) -->
nf('in : unit <- read (('InRcvd ^^ 'party .. 'adv)['n 'i]), return 'in, 'in)
      
     )
     ||
     (family ('InShare$[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]) ('m 'n 'i) 
             ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) ::= 
       ( (when (apply 'isSemiHonest 'n) -->
           nf('x : bool <- read (('In ^^ 'id .. 'adv) ['n 'i]), 
              samp ('flip < () >), 'x)  
         ) 
         ;;
         (when (apply 'isHonest 'n) -->
           nf('x : unit <- read (('InRcvd ^^ 'id .. 'adv) ['n 'i]), 
              samp ('flip < () >), 'x)  
         )
       
       )         
     ) 
     ||
     (  
family ('InShare$ ^^ 'party ..
    'adv)[bound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 1) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in, 'in))
;;
when (apply 'isHonest 'n) -->
nf('in : bool <- read (('InShare$ ^^ 'party .. 'adv)['m 'n 'i]), return 'in, 'in)
)
||
(
family ('InShare$ ^^ 'party ..
    'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
fixedBound (N + 1) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf(('s : bool <- read ('InShare$-Sum[N 'n 'i])) 
    'x : bool <- read (('In ^^ 'id .. 'adv)['n 'i]), 
    return (ap 'xor pair('x, 's)), 'x 's))
;;
when (apply 'isHonest 'n) -->
nf('in : bool <- read (('InShare$ ^^ 'party .. 'adv)[(N + 1) 'n 'i]), return 'in, 'in)
 )    
     ||
     (family ('InShare$-Sum[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]) 
             ('m 'n 'i) 
             ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) ::=             
       ( (when ('m =T= 0) --> 
           nf('in : bool <- read ('InShare$ [0 'n 'i]), return 'in, 'in)
         ) 
         ;; 
         (otherwise --> 
          nf( ('s : bool <- read ('InShare$-Sum [('m -- 1) 'n 'i]) )
              ('x : bool <- read ('InShare$ ['m 'n 'i])) ,
             return (ap 'xor pair('s, 'x)), 's 'x) 
         )
       )      
     )
     ||
     (
       family ('InShare$-Sum ^^ 'party .. 'adv)[bound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 1) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('InShare$-Sum['m 'n 'i]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('InShare$-Sum ^^ 'party .. 'adv)['m 'n 'i]), return 's, 's)      
             
       
     ) 
     ||
     (
      family ('SendInShare ^^ 'party ..
    'adv)[bound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 1) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in, 'in))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('SendInShare ^^ 'party .. 'adv)['m 'n 'i]), return 's, 's)
      )
      ||
      (
      family ('SendInShare ^^ 'party ..
    'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
fixedBound (N + 1) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf(('s : bool <- read ('InShare$-Sum[N 'n 'i])) 'x : bool <- read (('In ^^ 'id .. 'adv)['n 'i]), return (ap 'xor
    pair('x, 's)), 'x 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('SendInShare ^^ 'party .. 'adv)[(N + 1) 'n 'i]), return 's, 's)

      )
     || 
     (family ('RcvdInShare ^^ 'party ..
    'adv)[bound (N + 2) bound (N + 2) dependentBound 'I] 'n 'm 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('in : bool <- read ('InShare$['n 'm 'i]), return 'in, 'in))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdInShare ^^ 'party .. 'adv)['n 'm 'i]), return 's, 's)
     )    
     ||
     (family ('InShare[((bound (N + 1))(bound (N + 2))(dependentBound 'I))])
             ('m 'n 'i) 
             ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) ::= 
        nf('in : bool <- read ('InShare$ ['m 'n 'i]), return 'in, 'in)     
     ) 
     ||
     (family ('InShare ^^ 'party ..
    'adv)[bound (N + 2) bound (N + 2) dependentBound 'I] 'n 'm 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('InShare['n 'm 'i]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('InShare ^^ 'party .. 'adv)['n 'm 'i]), return 's, 's)
     ) 
    ) *** end new 
  .   
  
  op inductiveSim : -> Protocol .
  eq inductiveSim = 
      newfamily ('SendBit[((bound (N + 1))(bound (N + 2))(bound K))]) ('n 'm 'k) 
                 ((bound (N + 1))(bound (N + 2))(bound K)) : bool in
      newfamily ('RcvdBit[((bound (N + 1))(bound (N + 1))(bound K))]) ('n 'm 'k)
                 ((bound (N + 1))(bound (N + 1))(bound K)) : bool in 
      newfamily ('RcvdBit[((bound (N + 1))(fixedBound (N + 1))(bound K))]) ('n 'm 'k)
                 ((bound (N + 1))(fixedBound (N + 1))(bound K)) : bool in            
      newfamily ('Ctrb[((bound (N + 1))(bound (N + 2))(bound K))]) ('n 'm 'k) 
                 ((bound (N + 1))(bound (N + 2))(bound K)) : bool in
      newfamily ('CtrbSum[((bound (N + 1))(bound (N + 2))(bound K))]) ('n 'm 'k) 
                 ((bound (N + 1))(bound (N + 2))(bound K)) : bool in
      family ('Circ[bound K]) 'k (bound K) ::=
      ( *** start circuit
      ( *** start when input gate
      when (apply 'isInputGate 'k) --> 
( *** start when
 (family 'Ctrb[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 1) bound (N + 1) bound K] 'n 'm 'k
bound (N + 1) bound (N + 1) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 1) fixedBound (N + 1) bound K
::=
nf('rb : bool <- read ('RcvdBit['n (N + 1) 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in, 'in)
)
||
(family ('Ctrb ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family ('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc, 'oc)
)
||
(family ('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
)
||
(family ('RcvdBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb, 'rb)
)
||
(family ('SendBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb, 'sb)
)
||
(family ('Share ^^ 'party .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's, 's)
)

   ) *** end when
   ) *** end when input gate
   ;;
   ( *** start when not gate
      when (apply 'isNotGate 'k) --> 
( *** start when
(family 'Ctrb[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 1) bound (N + 1) bound K] 'n 'm 'k
bound (N + 1) bound (N + 1) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 1) fixedBound (N + 1) bound K
::=
nf('rb : bool <- read ('RcvdBit['n (N + 1) 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's, 's)
)
||
(family ('Ctrb ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family ('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc, 'oc)
)
||
(family ('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
)
||
(family ('RcvdBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb, 'rb)
)
||
(family ('SendBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb, 'sb)
)
||
(family ('Share ^^ 'party .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's, 's)
)

) *** end when
   ) *** end when not gate
   ;;
   ( *** start when xor gate
      when (apply 'isXorGate 'k) --> 
( *** start when
(family 'Ctrb[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 1) bound (N + 1) bound K] 'n 'm 'k
bound (N + 1) bound (N + 1) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 1) fixedBound (N + 1) bound K
::=
nf('rb : bool <- read ('RcvdBit['n (N + 1) 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)), 'x 'y)
)
||
(family ('Ctrb ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family ('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc, 'oc)
)
||
(family ('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
)
||
(family ('RcvdBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb, 'rb)
)
||
(family ('SendBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb, 'sb)
)
||
(family ('Share ^^ 'party .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's, 's)
)

) *** end when
   ) *** end when xor gate 
   ;;
   ( *** start when and gate
when (apply 'isAndGate 'k) --> 
( *** start when
(family 'Ctrb[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)), 'x 'y))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r, 'r)
)
||
(family 'CtrbSum[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b, 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)), 's 'b)
)
||
(family 'RcvdBit[bound (N + 1) bound (N + 1) bound K] 'n 'm 'k
bound (N + 1) bound (N + 1) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)), 'b 'xm 'ym 'xn 'yn)
)
||
(family 'RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 1) fixedBound (N + 1) bound K
::=
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r, 'r)
)
||
(family 'SendBit[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >), 'x 'y))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs, 'bs)
)
||
(family ('Ctrb ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Ctrb['n 'm 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)
||
(family ('CtrbSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('CtrbSum['n 'm 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)
||
(family ('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), return 'x, 'x))
;;
when ((apply 'isHonest 'm) disj 'm <=T 'n) -->
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), return 'x, 'x))
;;
when ((apply 'isHonest 'm) disj 'm <=T 'n) -->
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
(when ((apply 'isHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), return (), 'x))
;;
when ((apply 'isSemiHonest 'm) disj 'm <=T 'n) -->
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
(when ('n <T N + 1) -->
nf('x : bool <- read ('ShareSum[N (fun 'wire0 'k)]), return (), 'x))
;;
when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
(when ((apply 'isHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), return (), 'x))
;;
when ((apply 'isSemiHonest 'm) disj 'm <=T 'n) -->
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
(when ('n <T N + 1) -->
nf('x : bool <- read ('ShareSum[N (fun 'wire1 'k)]), return (), 'x))
;;
when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc, 'oc)
)
||
(family ('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y :
    bool <- read ('Share['n (fun 'wire1 'k)]), return 'b, 'b 'x 'y))
;;
when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y :
    bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair('x, 'b)), 'b 'x 'y))
;;
when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y :
    bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair('y, 'b)), 'b 'x 'y))
;;
when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y :
    bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)), 'b
    'x 'y))
;;
when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y :
    bool <- read ('Share['n (fun 'wire1 'k)]), return (), 'b 'x 'y))
;;
when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y :
    bool <- read ('Share['n (fun 'wire1 'k)]), return (), 'b 'x 'y))
;;
when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y :
    bool <- read ('Share['n (fun 'wire1 'k)]), return (), 'b 'x 'y))
;;
when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y :
    bool <- read ('Share['n (fun 'wire1 'k)]), return (), 'b 'x 'y))
;;
when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'm) -->
nf('out : bool <- read ('RcvdBit['m 'n 'k]), return 'out, 'out))
;;
when (apply 'isHonest 'm) -->
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
)
||
(family ('RcvdBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('RcvdBit['n 'm 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)
||
(family ('SendBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)
||
(family ('Share ^^ 'party .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's, 's)
)
) *** end when
) *** end when and gate
      ) *** end circuit
  . 
  
  op finalSim : -> Protocol .
  eq finalSim = 
    ( *** start 'Fin
      (family ('SendOutShare ^^ 'party ..
    'adv)[bound (N + 2) bound (N + 2) bound K] 'm 'n 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's, 's))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('SendOutShare ^^ 'party .. 'adv)['m 'n 'k]), return 's, 's)

       )
       ||
       (family ('RcvdOutShare ^^ 'party ..
    'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['m 'k]), return 's, 's))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdOutShare ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)      
 ||
 (
 family ('RcvdOutShare ^^ 'party ..
    'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf(('w : bool <- read (('Out ^^ 'id .. 'adv)['n 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor pair('xs,
    'w)), 'xs 'w))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdOutShare ^^ 'party .. 'adv)['n (N + 1) 'k]), return 's, 's)
 ) 
       ||
      (family ('OutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['m 'k]), return 's, 's))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('OutShare ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)
||
(
family ('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf(('w : bool <- read (('Out ^^ 'id .. 'adv)['n 'k]))  'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor pair('xs,
    'w)), 'xs 'w))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('OutShare ^^ 'party .. 'adv)['n (N + 1) 'k]), return 's, 's)
) 
       ||
        (
 family ('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('ShareSum['m 'k]), return 's, 's))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('OutShareSum ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
 )    
 ||
 (
 family ('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf('w : bool <- read (('Out ^^ 'id .. 'adv)['n 'k]), return 'w, 'w))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('OutShareSum ^^ 'party .. 'adv)['n (N + 1) 'k]), return 's, 's)

 ) 
       ||
       (family (('Out ^^ 'party .. 'adv)[((bound (N + 2))(bound K))]) ('n 'k)
          ((bound (N + 2))(bound K)) ::=
          
          
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read (('Out ^^ 'id .. 'adv)['n 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Out ^^ 'party .. 'adv)['n 'k]), return 's, 's)

         
       )
    ) *** end 'Fin    
  .
  
  op shareSim : -> Protocol .
  eq shareSim = 
     family ('ShareSum[((bound (N + 1))(bound K))]) 
            ('m 'k) ((bound (N + 1))(bound K)) ::=
     (
      (when ('m =T= 0) --> 
        nf('s : bool <- read ('Share[0 'k]), return 's, 's)
      )
      ;;
      (when (neg ('m =T= 0)) --> 
        nf( ('xs : bool <- read ('ShareSum[('m -- 1) 'k])) 
            ('xm : bool <- read ('Share['m 'k])),
            return (ap 'xor pair('xs, 'xm)),
            'xs 'xm 
          )
      )
     )
  .

  
  ***( sim protocol
  old version
  
  op sim : -> Protocol .
  eq sim = 
     newfamily ('InShare[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) 
               ('m 'n 'i) 
               ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) : bool in
     newfamily ('Share[((bound (N + 2))(bound K))]) 
               ('n 'k) ((bound (N + 2))(bound K)) : bool in
     newfamily ('Share-Sum[((bound (N + 1))(bound K))]) 
               ('m 'k) ((bound (N + 1))(bound K)) : bool in          
     initialSim || inductiveSim || finalSim || shareSim  
  . 
  
  op initialSim : -> Protocol .
  eq initialSim = 
     newfamily ('InShare$[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]) ('m 'n 'i) 
                ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) : bool in
     newfamily ('InShare$-Sum[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]) 
                ('m 'n 'i) 
                ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) : bool in
     (
     (family (('In ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) ('n 'i)
             ((bound (N + 2))(dependentBound 'I)) ::=
       ( (when (apply 'isSemiHonest 'n) -->
           nf('in : bool <- read (('In ^^ 'id .. 'adv) ['n 'i]), 
               return 'in, 'in)  
         ) 
         ;;
         (when (apply 'isHonest 'n) --> *** diverge
           nf('in : bool <- read (('In ^^ 'party .. 'adv) ['n 'i]), 
               return 'in, 'in)  
         )
       
       )      
     )
     ||
     (family (('InRcvd ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) ('n 'i)
             ((bound (N + 2))(dependentBound 'I)) ::=
       ( (when (apply 'isHonest 'n) -->
           nf('in : bool <- read (('InRcvd ^^ 'id .. 'adv) ['n 'i]), 
               return 'in, 'in)  
         ) 
         ;;
         (when (apply 'isSemiHonest 'n) --> *** diverge
           nf('in : bool <- read (('InRcvd ^^ 'party .. 'adv) ['n 'i]), 
               return 'in, 'in)  
         )
       
       )   
     )
     ||
     (family ('InShare$[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]) ('m 'n 'i) 
             ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) ::= 
       ( (when (apply 'isSemiHonest 'n) -->
           nf('x : bool <- read (('In ^^ 'id .. 'adv) ['n 'i]), 
              samp ('flip < () >), 'x)  
         ) 
         ;;
         (when (apply 'isHonest 'n) -->
           nf('x : bool <- read (('InRcvd ^^ 'id .. 'adv) ['n 'i]), 
              samp ('flip < () >), 'x)  
         )
       
       )         
     ) 
     ||
     (family (('InShare$ ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(dependentBound 'I))])
             ('m 'n 'i) 
             ((bound (N + 2))(bound (N + 2))(dependentBound 'I)) ::= 
       ( (when ((apply 'isSemiHonest 'n) conj ('m =T= N + 1)) -->
           nf( ('xs : bool <- read ('InShare$-Sum [N 'n 'i]))
               ('x : bool <- read (('In ^^ 'id .. 'adv)['n 'i])), 
               return (ap 'xor pair('xs, 'x)), 'xs 'x)  
         ) 
         ;;
         (when ((apply 'isSemiHonest 'n) conj ('m <T N + 1)) -->
           nf('in : bool <- read ('InShare$ ['n 'i]), 
               return 'in, 'in)  
         ) 
         ;;
         (when (apply 'isHonest 'n) --> *** diverge
          nf('in : bool <- read (('InShare$ ^^ 'party .. 'adv)['n 'i]), 
               return 'in, 'in) 
         )
       
       )  
     ) *** 
     ||
     (family ('InShare$-Sum[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]) 
             ('m 'n 'i) 
             ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) ::= 
       ( (when ('m =T= 0) --> 
           nf('in : bool <- read ('InShare$ [0 'n 'i]), return 'in, 'in)
         ) 
         ;; 
         (otherwise --> 
          nf( ('xs : bool <- read ('InShare$-Sum [('m -- 1) 'n 'i]) )
              ('xm : bool <- read ('InShare$ ['m 'n 'i])) ,
             return (ap 'xor pair('xs, 'xm)), 'xs 'xm) 
         )
       )      
     )
     ||
     (family (('InShare$-Sum ^^ 'party .. 'adv)
              [((bound (N + 1))(bound (N + 2))(dependentBound 'I))])
             ('m 'n 'i) 
             ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) ::=
       ( (when (('m =T= N + 1) conj (apply 'isSemiHonest 'n)) --> 
           nf( ('xs : bool <- read ('InShare$-Sum [N 'n 'i]) )
               ('x  : bool <- read (('In ^^ 'id .. 'adv) ['n 'i])) ,
             return (ap 'xor pair('xs, 'x)), 'xs 'x) 
         ) 
          ;; 
         (when (('m =T= N + 1) conj (apply 'isHonest 'n)) --> *** diverge
           nf('in : bool <- read (('InShare$-Sum ^^ 'party .. 'adv)[(N + 1) 'n 'i]), 
               return 'in, 'in) 
         ) 
          ;; 
         (when (('m <=T N) conj (apply 'isSemiHonest 'n)) -->
          nf('in : bool <- read ('InShare$-Sum['m 'n 'i]), 
               return 'in, 'in) 
         ) 
          ;; 
         (when (('m <=T N) conj (apply 'isHonest 'n)) --> *** diverge
           nf('in : bool <- read (('InShare$-Sum ^^ 'party .. 'adv)['m 'n 'i]), 
               return 'in, 'in) 
         )
       
       )       
     ) 
     ||
     (family (('SendInShare ^^ 'party .. 'adv)
               [((bound (N + 2))(bound (N + 2))(dependentBound 'I))]) 
             ('m 'n 'i) 
             ((bound (N + 2))(bound (N + 2))(dependentBound 'I)) ::= 
       ( (when (('m =T= N + 1) conj (apply 'isSemiHonest 'n)) --> 
           nf( ('xs : bool <- read ('InShare$-Sum [N 'n 'i]) )
               ('x  : bool <- read (('In ^^ 'id .. 'adv) ['n 'i])) ,
             return (ap 'xor pair('xs, 'x)), 'xs 'x) 
         ) 
          ;; 
         (when (('m =T= N + 1) conj (apply 'isHonest 'n)) --> *** diverge
           nf('in : bool <- read (('SendInShare ^^ 'party .. 'adv)[(N + 1) 'n 'i]), 
               return 'in, 'in) 
         ) 
          ;; 
         (when (('m <=T N) conj (apply 'isSemiHonest 'n)) -->
          nf('in : bool <- read ('InShare$['m 'n 'i]), 
               return 'in, 'in) 
         ) 
          ;; 
         (when (('m <=T N) conj (apply 'isHonest 'n)) --> *** diverge
           nf('in : bool <- read (('SendInShare ^^ 'party .. 'adv)['m 'n 'i]), 
               return 'in, 'in) 
         )
       )             
     ) 
     || 
     (family (('RcvdInShare ^^ 'party .. 'adv)
               [((bound (N + 2))(bound (N + 2))(dependentBound 'I))]) 
             ('m 'n 'i) 
             ((bound (N + 2))(bound (N + 2))(dependentBound 'I)) ::= 
       (
          (when ('m =T= N + 1) --> *** diverge!
            nf('in : bool <- read (('RcvdInShare ^^ 'party .. 'adv) [(N + 1) 'n 'i]), 
               return 'in, 'in)  
          ) 
          ;; 
          (when (('m <=T N) conj (apply 'isSemiHonest 'm)) --> 
            nf('in : bool <- read ('InShare$ ['m 'n 'i]), return 'in, 'in)
          ) 
          ;; 
          (when (('m <=T N) conj (apply 'isHonest 'm)) --> 
            nf('in : bool <- read (('RcvdInShare ^^ 'party .. 'adv) ['m 'n 'i]), 
               return 'in, 'in)
          )
        )
     )    
     ||
     (family ('InShare[((bound (N + 1))(bound (N + 2))(dependentBound 'I))])
             ('m 'n 'i) 
             ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) ::= 
        nf('in : bool <- read ('InShare$ ['m 'n 'i]), return 'in, 'in)     
     ) 
     ||
     (family (('InShare ^^ 'party .. 'adv)
              [((bound (N + 2))(bound (N + 2))(dependentBound 'I))])
             ('m 'n 'i) 
             ((bound (N + 2))(bound (N + 2))(dependentBound 'I)) ::= 
       (
          (when ('m =T= N + 1) --> *** diverge!
            nf('in : bool <- read (('InShare ^^ 'party .. 'adv) [(N + 1) 'n 'i]), 
               return 'in, 'in)  
          ) 
          ;; 
          (when (('m <=T N) conj (apply 'isSemiHonest 'm)) --> 
            nf('in : bool <- read ('InShare ['m 'n 'i]), return 'in, 'in)
          ) 
          ;; 
          (when (('m <=T N) conj (apply 'isHonest 'm)) --> 
            nf('in : bool <- read (('InShare ^^ 'party .. 'adv) ['m 'n 'i]), 
               return 'in, 'in)
          )       
       )      
     ) 
    ) *** end new 
  .   
  
  op inductiveSim : -> Protocol .
  eq inductiveSim = 
      newfamily ('SendBit[((bound (N + 1))(bound (N + 2))(bound K))]) ('n 'm 'k) 
                 ((bound (N + 1))(bound (N + 2))(bound K)) : bool in
      newfamily ('RcvdBit[((bound (N + 1))(bound (N + 2))(bound K))]) ('n 'm 'k)
                 ((bound (N + 1))(bound (N + 2))(bound K)) : bool in 
      newfamily ('Ctrb[((bound (N + 1))(bound (N + 2))(bound K))]) ('n 'm 'k) 
                 ((bound (N + 1))(bound (N + 2))(bound K)) : bool in
      newfamily ('CtrbSum[((bound (N + 1))(bound (N + 2))(bound K))]) ('n 'm 'k) 
                 ((bound (N + 1))(bound (N + 2))(bound K)) : bool in
      family ('Circ[bound K]) 'k (bound K) ::=
      ( *** start circuit
      ( *** start when input gate
      when (apply 'isInputGate 'k) --> 
( *** start when
  (family ('SendBit[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::= 
     nf('sb : bool <- read ('SendBit ['n 'm 'k]), return 'sb, 'sb)      
  )
  ||
  (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::= 
     nf('sb : bool <- read (('SendBit  ^^ 'party .. 'adv)['n 'm 'k]), 
        return 'sb, 'sb)      
  )
  ||
  (family ('RcvdBit[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::=
     nf('rb : bool <- read ('RcvdBit ['n 'm 'k]), return 'rb, 'rb)       
  )
  ||
  (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('rb : bool <- read (('RcvdBit  ^^ 'party .. 'adv)['n 'm 'k]), 
        return 'rb, 'rb)       
  )
  ||
  (family ('Ctrb[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::=
     nf('c : bool <- read ('Ctrb ['n 'm 'k]), return 'c, 'c)     
  )
  ||
  (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('c : bool <- read (('Ctrb  ^^ 'party .. 'adv)['n 'm 'k]), 
        return 'c, 'c)         
  )
  ||
  (family ('CtrbSum[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::=
     nf('cs : bool <- read ('CtrbSum ['n 'm 'k]), return 'cs, 'cs)     
  )
  ||
  (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('cs : bool <- read (('CtrbSum  ^^ 'party .. 'adv)['n 'm 'k]), 
        return 'cs, 'cs)              
  )
  ||
  (family ('Share[((bound (N + 2)) (bound K) )]) ('n 'k) 
          ((bound (N + 2)) (bound K) ) ::=
     nf('is : bool <- read ('InShare ['n (fun 'wire0 'k) (fun 'wire1 'k)]), 
        return 'is, 'is)     
  )
  ||
  (family (('Share ^^ 'party .. 'adv)[((bound (N + 2)) (bound K) )]) ('n 'k) 
          ((bound (N + 2)) (bound K) ) ::=
     (when ('n =T= N + 1) --> 
      nf('s : bool <- read (('Share ^^ 'party .. 'adv)[(N + 1) 'k]), 
         return 's, 's)
     )
     ;;     
     (when (('n <=T N) conj (apply 'isSemiHonest 'n)) --> 
       nf('s : bool <- read ('Share ['n 'k]), return 's, 's)
     ) 
     ;;  
     (when (('n <=T N) conj (apply 'isHonest 'n)) -->
      nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's, 's)
     ) 
  )
  ||
  (family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('om : bool <- read (('OTMsg-0  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'om, 'om)        
  )
  ||
  (family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'om, 'om)     
  )
  ||
  (family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'om, 'om)     
  )
  ||
  (family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('om : bool <- read (('OTMsg-3  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'om, 'om)     
  )
  ||
  (family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('omr : bool <- read (('OTMsgRcvd-0  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'omr, 'omr)     
  )
  ||
  (family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('omr : bool <- read (('OTMsgRcvd-1  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'omr, 'omr)          
  )
  ||
  (family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('omr : bool <- read (('OTMsgRcvd-2  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'omr, 'omr)          
  )
  ||
  (family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('omr : bool <- read (('OTMsgRcvd-3  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'omr, 'omr)           
  )
  ||
  (family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('oc : bool <- read (('OTChc-0  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'oc, 'oc)          
  )
  ||
  (family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('oc : bool <- read (('OTChc-1  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'oc, 'oc)     
  )
  ||
  (family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
    nf('ocr : bool <- read (('OTChcRcvd-0  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'ocr, 'ocr)      
  )
  ||
  (family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
    nf('ocr : bool <- read (('OTChcRcvd-1  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'ocr, 'ocr)       
  )
  ||
  (family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('o : bool <- read (('OTOut  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'o, 'o)      
  )
   ) *** end when
   ) *** end when input gate
   ;;
   ( *** start when not gate
      when (apply 'isNotGate 'k) --> 
( *** start when
  (family ('SendBit[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::= 
     nf('sb : bool <- read ('SendBit ['n 'm 'k]), return 'sb, 'sb)      
  )
  ||
  (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::= 
     nf('sb : bool <- read (('SendBit  ^^ 'party .. 'adv)['n 'm 'k]), 
        return 'sb, 'sb)      
  )
  ||
  (family ('RcvdBit[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::=
     nf('rb : bool <- read ('RcvdBit ['n 'm 'k]), return 'rb, 'rb)       
  )
  ||
  (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('rb : bool <- read (('RcvdBit  ^^ 'party .. 'adv)['n 'm 'k]), 
        return 'rb, 'rb)       
  )
  ||
  (family ('Ctrb[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::=
     nf('c : bool <- read ('Ctrb ['n 'm 'k]), return 'c, 'c)     
  )
  ||
  (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('c : bool <- read (('Ctrb  ^^ 'party .. 'adv)['n 'm 'k]), 
        return 'c, 'c)         
  )
  ||
  (family ('CtrbSum[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::=
     nf('cs : bool <- read ('CtrbSum ['n 'm 'k]), return 'cs, 'cs)     
  )
  ||
  (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('cs : bool <- read (('CtrbSum  ^^ 'party .. 'adv)['n 'm 'k]), 
        return 'cs, 'cs)              
  )
  ||
  (family ('Share[((bound (N + 2)) (bound K) )]) ('n 'k) 
          ((bound (N + 2)) (bound K) ) ::=
     nf('is : bool <- read ('Share ['n (fun 'wire0 'k)]), 
        return 'is, 'is)     
  )
  ||
  (family (('Share ^^ 'party .. 'adv)[((bound (N + 2)) (bound K) )]) ('n 'k) 
          ((bound (N + 2)) (bound K) ) ::=
     (when ('n =T= N + 1) --> 
      nf('s : bool <- read (('Share ^^ 'party .. 'adv)[(N + 1) 'k]), 
         return 's, 's)
     )
     ;;     
     (when (('n <=T N) conj (apply 'isSemiHonest 'n)) --> 
       nf('s : bool <- read ('Share ['n 'k]), return 's, 's)
     ) 
     ;;  
     (when (('n <=T N) conj (apply 'isHonest 'n)) -->
      nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's, 's)
     ) 
  )
  ||
  (family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('om : bool <- read (('OTMsg-0  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'om, 'om)        
  )
  ||
  (family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'om, 'om)     
  )
  ||
  (family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'om, 'om)     
  )
  ||
  (family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('om : bool <- read (('OTMsg-3  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'om, 'om)     
  )
  ||
  (family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('omr : bool <- read (('OTMsgRcvd-0  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'omr, 'omr)     
  )
  ||
  (family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('omr : bool <- read (('OTMsgRcvd-1  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'omr, 'omr)          
  )
  ||
  (family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('omr : bool <- read (('OTMsgRcvd-2  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'omr, 'omr)          
  )
  ||
  (family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('omr : bool <- read (('OTMsgRcvd-3  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'omr, 'omr)           
  )
  ||
  (family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('oc : bool <- read (('OTChc-0  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'oc, 'oc)          
  )
  ||
  (family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('oc : bool <- read (('OTChc-1  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'oc, 'oc)     
  )
  ||
  (family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
    nf('ocr : bool <- read (('OTChcRcvd-0  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'ocr, 'ocr)      
  )
  ||
  (family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
    nf('ocr : bool <- read (('OTChcRcvd-1  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'ocr, 'ocr)       
  )
  ||
  (family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('o : bool <- read (('OTOut  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'o, 'o)      
  )
   ) *** end when
   ) *** end when not gate
   ;;
   ( *** start when xor gate
      when (apply 'isXorGate 'k) --> 
( *** start when
  (family ('SendBit[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::= 
     nf('sb : bool <- read ('SendBit ['n 'm 'k]), return 'sb, 'sb)      
  )
  ||
  (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::= 
     nf('sb : bool <- read (('SendBit  ^^ 'party .. 'adv)['n 'm 'k]), 
        return 'sb, 'sb)      
  )
  ||
  (family ('RcvdBit[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::=
     nf('rb : bool <- read ('RcvdBit ['n 'm 'k]), return 'rb, 'rb)       
  )
  ||
  (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('rb : bool <- read (('RcvdBit  ^^ 'party .. 'adv)['n 'm 'k]), 
        return 'rb, 'rb)       
  )
  ||
  (family ('Ctrb[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::=
     nf('c : bool <- read ('Ctrb ['n 'm 'k]), return 'c, 'c)     
  )
  ||
  (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('c : bool <- read (('Ctrb  ^^ 'party .. 'adv)['n 'm 'k]), 
        return 'c, 'c)         
  )
  ||
  (family ('CtrbSum[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::=
     nf('cs : bool <- read ('CtrbSum ['n 'm 'k]), return 'cs, 'cs)     
  )
  ||
  (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('cs : bool <- read (('CtrbSum  ^^ 'party .. 'adv)['n 'm 'k]), 
        return 'cs, 'cs)              
  )
  ||
  (family ('Share[((bound (N + 2)) (bound K) )]) ('n 'k) 
          ((bound (N + 2)) (bound K) ) ::=
     nf(('x : bool <- read ('Share ['n (fun 'wire0 'k)]))
        ('y : bool <- read ('Share ['n (fun 'wire1 'k)])) , 
        return (ap 'xor pair('x, 'y)), 'x 'y)     
  )
  ||
  (family (('Share ^^ 'party .. 'adv)[((bound (N + 2)) (bound K) )]) ('n 'k) 
          ((bound (N + 2)) (bound K) ) ::=
     (when ('n =T= N + 1) --> 
      nf('s : bool <- read (('SendBit  ^^ 'party .. 'adv)[(N + 1) 'k]), 
         return 's, 's)
     )
     ;;     
     (when (('n <=T N) conj (apply 'isSemiHonest 'n)) --> 
       nf('s : bool <- read ('Share ['n 'k]), return 's, 's)
     ) 
     ;;  
     (when (('n <=T N) conj (apply 'isHonest 'n)) -->
      nf('s : bool <- read (('SendBit  ^^ 'party .. 'adv)['n 'k]), return 's, 's)
     ) 
  )
  ||
  (family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('om : bool <- read (('OTMsg-0  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'om, 'om)        
  )
  ||
  (family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('om : bool <- read (('OTMsg-1  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'om, 'om)     
  )
  ||
  (family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('om : bool <- read (('OTMsg-2  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'om, 'om)     
  )
  ||
  (family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('om : bool <- read (('OTMsg-3  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'om, 'om)     
  )
  ||
  (family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('omr : bool <- read (('OTMsgRcvd-0  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'omr, 'omr)     
  )
  ||
  (family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('omr : bool <- read (('OTMsgRcvd-1  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'omr, 'omr)          
  )
  ||
  (family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('omr : bool <- read (('OTMsgRcvd-2  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'omr, 'omr)          
  )
  ||
  (family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('omr : bool <- read (('OTMsgRcvd-3  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'omr, 'omr)           
  )
  ||
  (family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('oc : bool <- read (('OTChc-0  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'oc, 'oc)          
  )
  ||
  (family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('oc : bool <- read (('OTChc-1  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'oc, 'oc)     
  )
  ||
  (family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
    nf('ocr : bool <- read (('OTChcRcvd-0  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'ocr, 'ocr)      
  )
  ||
  (family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
    nf('ocr : bool <- read (('OTChcRcvd-1  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'ocr, 'ocr)       
  )
  ||
  (family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
     nf('o : bool <- read (('OTOut  ^^ 'ot .. 'adv)['n 'm 'k]), 
        return 'o, 'o)      
  )
   ) *** end when
   ) *** end when xor gate 
   ;;
   ( *** start when and gate
when (apply 'isAndGate 'k) --> 
( *** start when
 (family ('SendBit[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::=
     (when ('n <T 'm) --> 
       nf( ('xn : bool <- read ('Share['n (fun 'wire0 'k)]))
           ('yn : bool <- read ('Share['n (fun 'wire1 'k)])), 
          samp ('flip < () >),
          'xn 'yn)
     ) 
     ;;
     (when ('m <=T 'n) --> 
       nf('sb : bool <- read ('SendBit['n 'm 'k]), 
        return 'sb, 'sb) 
     )     
  )
  ||
  (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when ('n =T= N + 1) --> *** diverge!
            nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv) [(N + 1) 'm 'k]), 
               return 'sb, 'sb)  
          ) 
          ;; 
          (when (('n <=T N) conj (apply 'isSemiHonest 'n)) --> 
            nf('sb : bool <- read ('SendBit ['n 'm 'k]), 
               return 'sb, 'sb)
          ) 
          ;; 
          (when (('n <=T N) conj (apply 'isHonest 'n)) -->  *** diverge!
            nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv) ['n 'm 'k]), 
               return 'sb, 'sb)  
          )            
          
  )
  ||
  (family ('RcvdBit[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::=
     (when ('m =T= N + 1) --> 
       nf( ('b : bool <- read ('SendBit['m 'n 'k]))
           ('xm : bool <- read ('Share['m (fun 'wire0 'k)]))
           ('ym : bool <- read ('Share['m (fun 'wire1 'k)]))
           ('xn : bool <- read ('Share['n (fun 'wire0 'k)]))
           ('yn : bool <- read ('Share['n (fun 'wire1 'k)])),
           return (ap 'xor 
                    pair('b,
                         ap 'xor pair(ap 'and pair('xm, 'yn), 
                                      ap 'and pair('xn, 'ym))
                        )
                  ),
           'b 'xm 'ym 'xn 'yn
         )
     ) 
     ;;
     (otherwise --> *** diverge
       nf('rb : bool <- read ('RcvdBit['n 'm 'k]), 
           return 'rb, 'rb) 
     )     
          
  )
  ||
  (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when ('n =T= N + 1) --> *** diverge!
            nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)[(N + 1) 'm 'k]), 
               return 'rb, 'rb)  
          ) 
          ;; 
          (when (('n <=T N) conj (apply 'isSemiHonest 'n)) --> 
            nf('rb : bool <- read ('RcvdBit ['n 'm 'k]), 
               return 'rb, 'rb)
          ) 
          ;; 
          (when (('n <=T N) conj (apply 'isHonest 'n)) -->  *** diverge!
            nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
               return 'rb, 'rb)  
          )           
  )
  ||
  (family ('Ctrb[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::=
          (when ('n <T 'm) --> 
            nf('sb : bool <- read ('SendBit ['n 'm 'k]), 
               return 'sb, 'sb)
          )
          ;;
          (when ('m <T 'n) --> 
            nf('rb : bool <- read ('RcvdBit ['n 'm 'k]), 
               return 'rb, 'rb)
          )
          ;;
          (when ('m =T= 'n) --> 
            nf(('xn : bool <- read ('Share['n (fun 'wire0 'k)]))
               ('yn : bool <- read ('Share['n (fun 'wire1 'k)])), 
               return (ap 'and pair('xn, 'yn)), 'xn 'yn)
          )
  )
  ||
  (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when ('n =T= N + 1) --> *** diverge!
            nf('cb : bool <- read (('Ctrb ^^ 'party .. 'adv)[(N + 1) 'm 'k]), 
               return 'cb, 'cb)  
          ) 
          ;; 
          (when (('n <=T N) conj (apply 'isSemiHonest 'n)) --> 
            nf('cb : bool <- read ('Ctrb ['n 'm 'k]), 
               return 'cb, 'cb)
          ) 
          ;; 
          (when (('n <=T N) conj (apply 'isHonest 'n)) -->  *** diverge!
            nf('cb : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), 
               return 'cb, 'cb)  
          )           
  )
  ||
  (family ('CtrbSum[((bound (N + 1)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 1)) (bound (N + 2))(bound K) ) ::=
          (when ('m =T= 0) --> 
             nf('cb : bool <- read ('Ctrb ['n 0 'k]), 
               return 'cb, 'cb)
          )
          ;;
          (when (neg ('m =T= 0)) --> 
             nf(('bs : bool <- read ('CtrbSum ['n ('m -- 1) 'k]))
                ('b : bool <- read ('Ctrb['n 'm 'k])), 
               return (ap 'xor pair('bs, 'b)), 'bs 'b)
          )
  )
  ||
  (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when ('n =T= N + 1) --> *** diverge!
            nf('cs : bool <- read (('CtrbSum ^^ 'party .. 'adv)[(N + 1) 'm 'k]), 
               return 'cs, 'cs)  
          ) 
          ;; 
          (when (('n <=T N) conj (apply 'isSemiHonest 'n)) --> 
            nf('cs : bool <- read ('CtrbSum ['n 'm 'k]), 
               return 'cs, 'cs)
          ) 
          ;; 
          (when (('n <=T N) conj (apply 'isHonest 'n)) -->  *** diverge!
            nf('cs : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), 
               return 'cs, 'cs)  
          )           
  )
  ||
  (family ('Share[((bound (N + 2)) (bound K) )]) ('n 'k) 
          ((bound (N + 2)) (bound K) ) ::=
      nf('cs : bool <- read ('CtrbSum ['n (N + 1) 'k]), 
         return 'cs, 'cs)     
  )
  ||
  (family (('Share ^^ 'party .. 'adv)[((bound (N + 2)) (bound K) )]) ('n 'k) 
          ((bound (N + 2)) (bound K) ) ::=
           (when ('n =T= N + 1) --> *** diverge!
            nf('cs : bool <- read (('Share ^^ 'party .. 'adv)[(N + 1) 'm 'k]), 
               return 'cs, 'cs)  
          ) 
          ;; 
          (when (('n <=T N) conj (apply 'isSemiHonest 'n)) --> 
            nf('cs : bool <- read ('Share ['n 'k]), 
               return 'cs, 'cs)
          ) 
          ;; 
          (when (('n <=T N) conj (apply 'isHonest 'n)) -->  *** diverge!
            nf('cs : bool <- read (('Share ^^ 'party .. 'adv)['n 'm 'k]), 
               return 'cs, 'cs)  
          ) 
  )
  ||
  (family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when ('n =T= N + 1) --> *** diverge!
            nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)[(N + 1) 'm 'k]), 
               return 'om, 'om)  
          )
          ;; 
          (when (('n <=T N) conj ((apply 'isSemiHonest 'n) conj ('n <T 'm)) ) -->
            nf(('b : bool <- read ('SendBit['n 'm 'k]))
               ('xn : bool <- read ('Share['n (fun 'wire0 'k)]))
               ('yn : bool <- read ('Share['n (fun 'wire1 'k)])), 
               return 'b, 'b 'xn 'yn)  
          )     
          ;; 
          (when (('n <=T N) conj ((apply 'isHonest 'n) disj ('m <=T 'n))) --> *** diverge!
            nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), 
               return 'om, 'om)  
          ) 
  )
  ||
  (family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when ('n =T= N + 1) --> *** diverge!
            nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)[(N + 1) 'm 'k]), 
               return 'om, 'om)  
          )
          ;; 
          (when (('n <=T N) conj ((apply 'isSemiHonest 'n) conj ('n <T 'm)) ) -->
            nf(('b : bool <- read ('SendBit['n 'm 'k]))
               ('xn : bool <- read ('Share['n (fun 'wire0 'k)]))
               ('yn : bool <- read ('Share['n (fun 'wire1 'k)])), 
               return (ap 'xor pair('b, 'xn)), 'b 'xn 'yn)  
          )     
          ;; 
          (when (('n <=T N) conj ((apply 'isHonest 'n) disj ('m <=T 'n))) --> *** diverge!
            nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
               return 'om, 'om)  
          )     
  )
  ||
  (family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when ('n =T= N + 1) --> *** diverge!
            nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)[(N + 1) 'm 'k]), 
               return 'om, 'om)  
          )
          ;; 
          (when (('n <=T N) conj ((apply 'isSemiHonest 'n) conj ('n <T 'm)) ) -->
            nf(('b : bool <- read ('SendBit['n 'm 'k]))
               ('xn : bool <- read ('Share['n (fun 'wire0 'k)]))
               ('yn : bool <- read ('Share['n (fun 'wire1 'k)])), 
               return (ap 'xor pair('b, 'yn)), 'b 'xn 'yn)  
          )     
          ;; 
          (when (('n <=T N) conj ((apply 'isHonest 'n) disj ('m <=T 'n))) --> *** diverge!
            nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), 
               return 'om, 'om)  
          )    
  )
  ||
  (family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when ('n =T= N + 1) --> *** diverge!
            nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)[(N + 1) 'm 'k]), 
               return 'om, 'om)  
          )
          ;; 
          (when (('n <=T N) conj ((apply 'isSemiHonest 'n) conj ('n <T 'm)) ) -->
            nf(('b : bool <- read ('SendBit['n 'm 'k]))
               ('xn : bool <- read ('Share['n (fun 'wire0 'k)]))
               ('yn : bool <- read ('Share['n (fun 'wire1 'k)])), 
               return (ap 'xor pair('b, ap 'xor pair('xn, 'yn))), 
               'b 'xn 'yn)  
          )     
          ;; 
          (when (('n <=T N) conj ((apply 'isHonest 'n) disj ('m <=T 'n))) --> *** diverge!
            nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), 
               return 'om, 'om)  
          )    
  )
  ||
  (family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
           (when ('n =T= N + 1) --> *** diverge!
            nf('om : bool <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[(N + 1) 'm 'k]), 
               return 'om, 'om)  
          )
          ;; 
          (when (('n <=T N) conj ((apply 'isHonest 'n) conj ('n <T 'm)) ) -->
            nf(('b : bool <- read ('SendBit['n 'm 'k]))
               ('xn : bool <- read ('Share['n (fun 'wire0 'k)]))
               ('yn : bool <- read ('Share['n (fun 'wire1 'k)])), 
               return (), 
               'b 'xn 'yn)  
          )     
          ;; 
          (when (('n <=T N) conj ((apply 'isSemiHonest 'n) disj ('m <=T 'n))) --> *** diverge!
            nf('om : bool <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), 
               return 'om, 'om)  
          )
  )
  ||
  (family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when ('n =T= N + 1) --> *** diverge!
            nf('om : bool <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[(N + 1) 'm 'k]), 
               return 'om, 'om)  
          )
          ;; 
          (when (('n <=T N) conj ((apply 'isHonest 'n) conj ('n <T 'm)) ) -->
            nf(('b : bool <- read ('SendBit['n 'm 'k]))
               ('xn : bool <- read ('Share['n (fun 'wire0 'k)]))
               ('yn : bool <- read ('Share['n (fun 'wire1 'k)])), 
               return (), 
               'b 'xn 'yn)  
          )     
          ;; 
          (when (('n <=T N) conj ((apply 'isSemiHonest 'n) disj ('m <=T 'n))) --> *** diverge!
            nf('om : bool <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
               return 'om, 'om)  
          )
  )
  ||
  (family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when ('n =T= N + 1) --> *** diverge!
            nf('om : bool <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[(N + 1) 'm 'k]), 
               return 'om, 'om)  
          )
          ;; 
          (when (('n <=T N) conj ((apply 'isHonest 'n) conj ('n <T 'm)) ) -->
            nf(('b : bool <- read ('SendBit['n 'm 'k]))
               ('xn : bool <- read ('Share['n (fun 'wire0 'k)]))
               ('yn : bool <- read ('Share['n (fun 'wire1 'k)])), 
               return (), 
               'b 'xn 'yn)  
          )     
          ;; 
          (when (('n <=T N) conj ((apply 'isSemiHonest 'n) disj ('m <=T 'n))) --> *** diverge!
            nf('om : bool <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), 
               return 'om, 'om)  
          )
  )
  ||
  (family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when ('n =T= N + 1) --> *** diverge!
            nf('om : bool <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[(N + 1) 'm 'k]), 
               return 'om, 'om)  
          )
          ;; 
          (when (('n <=T N) conj ((apply 'isHonest 'n) conj ('n <T 'm)) ) -->
            nf(('b : bool <- read ('SendBit['n 'm 'k]))
               ('xn : bool <- read ('Share['n (fun 'wire0 'k)]))
               ('yn : bool <- read ('Share['n (fun 'wire1 'k)])), 
               return (), 
               'b 'xn 'yn)  
          )     
          ;; 
          (when (('n <=T N) conj ((apply 'isSemiHonest 'n) disj ('m <=T 'n))) --> *** diverge!
            nf('om : bool <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), 
               return 'om, 'om)  
          )
  )
  ||
  (family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when ('m =T= N + 1) --> *** diverge!
            nf('om : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), 
               return 'om, 'om)  
          )
          ;; 
          (when (('m <=T N) conj ((apply 'isHonest 'm) conj ('n <T 'm)) ) -->
            nf(('xn : bool <- read ('Share['m (fun 'wire0 'k)])), 
               return 'xn, 
               'xn)  
          )     
          ;; 
          (when (('m <=T N) conj ((apply 'isSemiHonest 'm) disj ('m <=T 'n))) --> *** diverge!
            nf('om : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), 
               return 'om, 'om)  
          )
  )
  ||
  (family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when ('m =T= N + 1) --> *** diverge!
            nf('om : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), 
               return 'om, 'om)  
          )
          ;; 
          (when (('m <=T N) conj ((apply 'isHonest 'm) conj ('n <T 'm)) ) -->
            nf(('yn : bool <- read ('Share['m (fun 'wire1 'k)])), 
               return 'yn, 
               'yn)  
          )     
          ;; 
          (when (('m <=T N) conj ((apply 'isSemiHonest 'm) disj ('m <=T 'n))) --> *** diverge!
            nf('om : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
               return 'om, 'om)  
          )
  )
  ||
  (family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when (('m =T= N + 1) conj ('n =T= N + 1)) --> *** diverge
             nf('om : bool <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(N + 1) (N + 1) 'k]), 
               return 'om, 'om)            
          )
          ;;
          (when ('m =T= N + 1) --> 
            nf('xs : bool <- read ('ShareSum[N (fun 'wire0 'k)]) , 
               return (), 'xs)
          )
          ;;
          (when ((apply 'isHonest 'm) conj ('n <T 'm)) --> 
            nf('xs : bool <- read ('ShareSum['m (fun 'wire0 'k)]) , 
               return (), 'xs)
          )
          ;;
          (when ((apply 'isSemiHonest 'm) disj ('m <=T 'n)) --> *** diverge
            nf('om : bool <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), 
               return 'om, 'om)    
          )
  )
  ||
  (family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
            (when (('m =T= N + 1) conj ('n =T= N + 1)) --> *** diverge
             nf('om : bool <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(N + 1) (N + 1) 'k]), 
               return 'om, 'om)            
          )
          ;;
          (when ('m =T= N + 1) --> 
            nf('xs : bool <- read ('ShareSum[N (fun 'wire1 'k)]) , 
               return (), 'xs)
          )
          ;;
          (when ((apply 'isHonest 'm) conj ('n <T 'm)) --> 
            nf('xs : bool <- read ('ShareSum['m (fun 'wire1 'k)]) , 
               return (), 'xs)
          )
          ;;
          (when ((apply 'isSemiHonest 'm) disj ('m <=T 'n)) --> *** diverge
            nf('om : bool <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
               return 'om, 'om)    
          )
  )
  ||
  (family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) ('n 'm 'k) 
          ((bound (N + 2)) (bound (N + 2))(bound K) ) ::=
          (when ('m =T= N + 1) --> *** diverge!
            nf('cs : bool <- read (('OTOut ^^ 'party .. 'adv)[(N + 1) 'm 'k]), 
               return 'cs, 'cs)  
          ) 
          ;; 
          (when (('m <=T N) conj (apply 'isSemiHonest 'm)) --> 
            nf('cs : bool <- read ('RcvdBit ['m 'n 'k]), 
               return 'cs, 'cs)
          ) 
          ;; 
          (when (('m <=T N) conj (apply 'isHonest 'm)) -->  *** diverge!
            nf('cs : bool <- read (('OTOut ^^ 'party .. 'adv)['n 'm 'k]), 
               return 'cs, 'cs)  
          )     
  )

 ) *** end when
) *** end when and gate
      ) *** end circuit
  . 
  
   op finalSim : -> Protocol .
  eq finalSim = 
    ( *** start 'Fin
      (family (('SendOutShare ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))]) 
          ('m 'n 'k) 
          ((bound (N + 2))(bound (N + 2))(bound K)) ::=
       (
       ( when ('n =T= N + 1) --> 
          nf('sos : bool <- read (('SendOutShare ^^ 'party .. 'adv)['m (N + 1) 'k]),
             return 'sos, 'sos)
       ) ;;
       ( when ((apply 'isSemiHonest 'n) conj (apply 'isOutputWire 'k)) --> 
          nf('sos : bool <- read ('Share['n 'k]),
             return 'sos, 'sos)
       ) ;;
       (when ((apply 'isHonest 'n) disj (neg (apply 'isOutputWire 'k))) --> 
          nf('sos : bool <- read (('SendOutShare ^^ 'party .. 'adv)['m 'n 'k]),
             return 'sos, 'sos)
       ) 
       ) 
       )
       ||
       (family (('RcvdOutShare ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))]) 
           ('n 'm 'k)
           ((bound (N + 2))(bound (N + 2))(bound K)) ::=
         (
          (when (('m =T= N + 1) conj 
                 ((apply 'isSemiHonest 'n) conj (apply 'isOutputWire 'k))
                ) --> 
           nf(('xs : bool <- read ('ShareSum[N 'k]))
              ('x : bool <- read (('Out ^^ 'id .. 'adv)['n 'k])), 
               return (ap 'xor pair('xs, 'x)), 
               'xs 'x)      
          ) 
          ;;
          (when (('m =T= N + 1) conj 
                 ((apply 'isHonest 'n) disj (neg (apply 'isOutputWire 'k)))
                ) --> 
           nf('r : bool <- read (('RcvdOutShare ^^ 'party .. 'adv)['n (N + 1) 'k]),
              return 'r,
              'r)     
          ) 
          ;;
          (when (('m <=T N) conj 
                 ((apply 'isSemiHonest 'n) conj (apply 'isOutputWire 'k))
                ) --> 
            nf('r : bool <- read ('Share ['m 'k]),
              return 'r,
              'r)      
          ) 
          ;;
          (when (('m <=T N) conj 
                 ((apply 'isHonest 'n) disj (neg (apply 'isOutputWire 'k)))
                ) --> 
             nf('r : bool <- read (('RcvdOutShare ^^ 'party .. 'adv)['n 'm 'k]),
              return 'r,
              'r)          
          )  
         )       
       ) 
       ||
       (family (('OutShare ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))]) 
         ('n 'm 'k)
         ((bound (N + 2))(bound (N + 2))(bound K)) ::=
         (
          (when (('m =T= N + 1) conj 
                 ((apply 'isSemiHonest 'n) conj (apply 'isOutputWire 'k))
                ) --> 
            nf(('xs : bool <- read ('ShareSum[N 'k]))
              ('x : bool <- read (('Out ^^ 'id .. 'adv)['n 'k])), 
               return (ap 'xor pair('xs, 'x)), 
               'xs 'x)    
          )
          ;;
          (when (('m =T= N + 1) conj 
                 ((apply 'isHonest 'n) disj (neg (apply 'isOutputWire 'k)))
                ) --> 
           nf('r : bool <- read (('OutShare ^^ 'party .. 'adv)['n (N + 1) 'k]),
              return 'r,
              'r) )
          ;;
          (when (('m <=T N) conj 
                 ((apply 'isSemiHonest 'n) conj (apply 'isOutputWire 'k))
                ) --> 
            nf('r : bool <- read ('Share ['m 'k]),
              return 'r,
              'r) 
          )
          ;;
          (when (('m <=T N) conj 
                 ((apply 'isHonest 'n) disj (neg (apply 'isOutputWire 'k)))
                ) --> 
             nf('r : bool <- read (('OutShare ^^ 'party .. 'adv)['n 'm 'k]),
              return 'r,
              'r)  
          )
         )
       )
       ||
       (family (('OutShareSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))]) 
         ('n 'm 'k)
         ((bound (N + 2))(bound (N + 2))(bound K)) ::=
         (
          (when (('m =T= N + 1) conj 
                 ((apply 'isSemiHonest 'n) conj (apply 'isOutputWire 'k))
                ) --> 
            nf('r : bool <- read (('Out ^^ 'id .. 'adv)['n 'k]),
              return 'r,
              'r)  
          )
          ;;
          (when (('m =T= N + 1) conj 
                 ((apply 'isHonest 'n) disj (neg (apply 'isOutputWire 'k)))
                ) --> 
           nf('r : bool <- read (('OutShareSum ^^ 'party .. 'adv)['n 'k]),
              return 'r,
              'r) 
          )     
          ;;
          (when (('m <=T N) conj 
                 ((apply 'isSemiHonest 'n) conj (apply 'isOutputWire 'k))
                ) --> 
            nf('r : bool <- read ('ShareSum ['m 'k]),
              return 'r,
              'r) 
          )
          ;;
          (when (('m <=T N) conj 
                 ((apply 'isHonest 'n) disj (neg (apply 'isOutputWire 'k)))
                ) --> 
             nf('r : bool <- read (('OutShareSum ^^ 'party .. 'adv)['n 'm 'k]),
              return 'r,
              'r)  
          )
         )
       )
       ||
       (family (('Out ^^ 'party .. 'adv)[((bound (N + 2))(bound K))]) ('n 'k)
          ((bound (N + 2))(bound K)) ::=
          (
          (when (apply 'isSemiHonest 'n) --> 
            nf('o : bool <- read (('Out ^^ 'id .. 'adv)['n 'k]),
              return 'o,
              'o) 
          )
          ;;
          (when (apply 'isHonest 'n) --> 
            nf('o : bool <- read (('Out ^^ 'party .. 'adv)['n 'k]),
              return 'o,
              'o) 
          )
          )
       )
    ) *** end 'Fin    
  .
  
  op shareSim : -> Protocol .
  eq shareSim = 
     family ('Share-Sum[((bound (N + 1))(bound K))]) 
            ('m 'k) ((bound (N + 1))(bound K)) ::=
     (
      (when ('m =T= 0) --> 
        nf('s : bool <- read ('Share[0 'k]), return 's, 's)
      )
      ;;
      (otherwise --> 
        nf( ('xs : bool <- read ('Share-Sum[('m -- 1) 'k])) 
            ('xm : bool <- read ('Share['m 'k])),
            return (ap 'xor pair('xs, 'xm)),
            'xs 'xm 
          )
      )
     )
  .
  )
  
  
  
  *** idealplussim
  
  op idealPlusSim : -> Protocol .
  eq idealPlusSim =
   newfamily ('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I] 
     ('n 'i) (bound (N + 2) dependentBound 'I) : bool in
   newfamily ('InRcvd ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I] 'n 'i
bound (N + 2) dependentBound 'I : bool in
   newfamily ('Out ^^ 'id .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K : bool in  
   (ideal || sim)
  .
  
    *** real protocol
  
  op real : -> Protocol .
  eq real = 
   newfamily ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))])
             ('m 'n 'i) 
             ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in
   newfamily ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in  
   newfamily ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   newfamily ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   newfamily ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))])
             ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   newfamily ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in  
   newfamily ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))])
             ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in                             
   newfamily ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in          
   newfamily ('SendOutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in          
   parties || 1OutOf4
  .
  
  op parties : -> Protocol .
  eq parties = 
   newfamily ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
             ('n 'm 'i) 
             ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in   
   newfamily ('Share[((bound (N + 2)) (bound K) )]) ('n 'k) 
             ((bound (N + 2)) (bound K) ) : bool in
   partyInitial || partyInductive || partyFinal           
  . 
  
  op partyInitial : -> Protocol .
  eq partyInitial = 
  newfamily ('InShare$[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
            ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in
  newfamily ('InShare$-Sum[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) 
            ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) : bool in
  ( *** start new
    (family (('In ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) ('n 'i)
             ( (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('in : bool <- read ('In['n 'i]), return 'in, 'in)
       ) 
       ;; 
       (when (apply 'isHonest 'n) --> 
         nf('in : bool <- read (('In ^^ 'party .. 'adv)['n 'i]), return 'in, 'in)
       )       
     )
     ||
     (family ('InRcvd ^^ 'party .. 'adv[((bound (N + 2)) (dependentBound 'I))]) ('n 'i)
             ((bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isHonest 'n) --> 
         nf('x : bool <- read ('In['n 'i]), return (), 'x)
       ) 
       ;; 
       (when (apply 'isSemiHonest 'n)  --> 
         nf('in : unit <- read (('InRcvd ^^ 'party .. 'adv)['n 'i]), return 'in, 'in)
       )       
     )
     ||
     (family ('InShare$[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
            ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when ('m =T= N + 1) --> 
          nf(('x : bool <- read ('In['n 'i]))
             ('s : bool <- read ('InShare$-Sum[N 'n 'i])), 
             return (ap 'xor pair('x, 's)), 'x 's)
       )
       ;;
       (otherwise --> 
         nf('x : bool <- read ('In['n 'i]), samp ('flip < () >), 'x)
       )      
     )
     ||
      (family (('InShare$ ^^ 'party .. 'adv)
               [((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
            ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
          nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in, 'in)
       )
       ;;
       (when (apply 'isHonest 'n)  --> 
         nf('in : bool <- read (('InShare$ ^^ 'party .. 'adv)['m 'n 'i]), 
            return 'in, 'in)
       )      
     )
     ||
     (family ('InShare$-Sum[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) 
            ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) ::=
        (when ('m =T= 0) --> 
          nf('in : bool <- read ('InShare$[0 'n 'i]), 
             return 'in, 'in)
        )
        ;;
        (otherwise --> 
          nf(('x : bool <- read ('InShare$['m 'n 'i]))
             ('s : bool <- read ('InShare$-Sum[('m -- 1) 'n 'i])), 
             return (ap 'xor pair('s, 'x)), 's 'x)
        )    
     )
     ||
     (family (('InShare$-Sum ^^ 'party .. 'adv)
              [((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) 
            ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('InShare$-Sum['m 'n 'i]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('InShare$-Sum ^^ 'party .. 'adv)['m 'n 'i]), 
            return 's, 's)
       )       
     )
     ||
     (family ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
            ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
        nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in, 'in)    
     )  
     ||
     (family (('SendInShare ^^ 'party .. 'adv)
              [((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))])  
            ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendInShare['m 'n 'i]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('SendInShare ^^ 'party .. 'adv)['m 'n 'i]), 
            return 's, 's)
       )        
     )   
     ||
     (family (('RcvdInShare ^^ 'party .. 'adv)
              [((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
            ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendInShare['n 'm 'i]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('RcvdInShare ^^ 'party .. 'adv)['n 'm 'i]), 
            return 's, 's)
       )        
     ) 
     ||
     (family ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
            ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
        nf('s : bool <- read ('SendInShare['n 'm 'i]), return 's, 's)    
     )        
     ||
     (family (('InShare ^^ 'party .. 'adv)
              [((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
            ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('InShare['n 'm 'i]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('InShare ^^ 'party .. 'adv)['n 'm 'i]), 
            return 's, 's)
       )        
     )  
  ) *** end new
  .
  
  op partyInductive : -> Protocol .
  eq partyInductive =
   newfamily ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in   
  family ('Circuit[((bound (N + 2)) (bound K))])  
         ('n 'k) ((bound (N + 2)) (bound K)) ::= 
   (when (apply 'isInputGate 'k) -->          
      ( *** start new
       ( family ('SendBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
                ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
 )
 ||
 (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
       return 'sb, 'sb) 
 )               
 ||
 ( family ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
          ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
 )
 ||
 (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
         ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
      return 'rb, 'rb)          
 ) 
 ||
 ( family ('Ctrb[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
          ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)           
 )
 ||
 (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
          ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)           
 )  
 ||
 (family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
         ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)  
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
           ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)           
 )  
 ||
     ( family ('Share[ (bound (N + 2)) (bound K)]) 
        ('n 'k) ((bound (N + 2)) (bound K)) ::= 
       nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]),
          return 'in, 'in)
     )
     ||
     (family (('Share ^^ 'party .. 'adv)[ (bound (N + 2)) (bound K)]) ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's, 's)
       )        
     )
     ||
     ( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
              ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     ( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     ( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     ( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc, 'oc)
     )
     ||
     ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc, 'oc)
     )
     ) *** end new
   )
   ;;
   (when (apply 'isNotGate 'k) -->    
      ( *** start new
       ( family ('SendBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
 )
 ||
 (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
       return 'sb, 'sb) 
 )               
 ||
 ( family ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
 )
 ||
 (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
      return 'rb, 'rb)          
 ) 
 ||
 ( family ('Ctrb[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)           
 )
 ||
 (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)           
 )  
 ||
 (family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)  
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)           
 )  
 ||
     ( family ('Share[ (bound (N + 2)) (bound K)]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
        (when ('n =T= N + 1) --> 
          nf( ('x : bool <- read ('Share['n (fun 'wire0 'k)])),
              return (ap 'neg 'x), 'x
          )
        )
        ;;
        (when (neg('n =T= N + 1))--> 
          nf('s : bool <- read ('Share['n (fun 'wire0 'k)]),
          return 's, 's)
        )
          
     )
     ||
     (family (('Share ^^ 'party .. 'adv)[ (bound (N + 2)) (bound K)]) ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's, 's)
       )        
     )
     ||
     ( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     ( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     ( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     ( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc, 'oc)
     )
     ||
     ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc, 'oc)
     )
     ) *** end new
   )
   ;;
   (when (apply 'isXorGate 'k) --> 
      ( *** start new
       ( family ('SendBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
 )
 ||
 (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
       return 'sb, 'sb) 
 )               
 ||
 ( family ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
 )
 ||
 (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
      return 'rb, 'rb)          
 ) 
 ||
 ( family ('Ctrb[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)           
 )
 ||
 (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)           
 )  
 ||
 (family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)  
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)           
 )          
 ||
     ( family ('Share[ (bound (N + 2)) (bound K)]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
       nf(('x : bool <- read ('Share['n (fun 'wire0 'k)]))
          ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair('x, 'y)), 'x 'y)
     )
     ||
     (family (('Share ^^ 'party .. 'adv)[ (bound (N + 2)) (bound K)]) ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's, 's)
       )        
     )
     ||
     ( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     ( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     ( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     ( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc, 'oc)
     )
     ||
     ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc, 'oc)
     )   
   ) *** end new
   )
      ;;
   (when (apply 'isAndGate 'k) -->
     ( *** start new
     ( family ('SendBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( 
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          samp ('flip < () >), 
             'x 'y
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('sb : bool <- read ('SendBit['n 'm 'k]),
          return 'sb, 'sb)
       )   
     )
     ||
      (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's, 's)
       )        
     )
     ||
     ( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return 'b, 'b 'x 'y
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om, 'om)
       )   
     )
     ||
     ( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair('x, 'b)), 'b 'x 'y
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om, 'om)
       )   
     )
     ||
     ( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair('y, 'b)), 'b 'x 'y
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om, 'om)
       )   
     )
     ||
     ( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)), 
          'b 'x 'y
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om, 'om)
       )   
     )
     ||
     ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
      (when ('n <T 'm) --> 
         nf( ('x : bool <- read ('Share['n (fun 'wire0 'k)])),
          return 'x, 'x
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc, 'oc)
       )   
     )
     ||
     ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('x : bool <- read ('Share['n (fun 'wire1 'k)])),
          return 'x, 'x
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc, 'oc)
       )   
     )
     ||
     ( family ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
          nf( ('out : bool <- read ('OTOut['m 'n 'k])),
              return 'out, 'out
          )     
    )
    ||
     (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('RcvdBit['n 'm 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's, 's)
       )        
     )
      ||
      ( family ('Ctrb[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
      (when ('n <T 'm) --> 
         nf( ('s : bool <- read ('SendBit['n 'm 'k])),
          return 's, 's
          )
       )
       ;;
       (when ('n =T= 'm) --> 
         nf( ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'and pair('x, 'y)), 
          'x 'y
          )
       )
       ;;
       (when ('m <T 'n) --> 
         nf( ('r : bool <- read ('RcvdBit['n 'm 'k])),
          return 'r, 'r
          )
       )   
     )
     ||
 (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Ctrb['n 'm 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's, 's)
       )               
 )  
      ||
      (family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   (when ('m =T= 0) --> 
     nf( ('b : bool <- read ('Ctrb['n 0 'k])),
          return 'b, 'b
          ) 
   )
   ;;
   (when (neg ('m =T= 0)) --> 
     nf( ('s : bool <- read ('CtrbSum['n ('m -- 1) 'k]))
         ('b : bool <- read ('Ctrb['n 'm 'k])),
          return (ap 'xor pair('s, 'b)), 's 'b
          ) 
   )
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('CtrbSum['n 'm 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's, 's)
       )        
     )
      ||   
 ( family ('Share[ (bound (N + 2)) (bound K)]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
          nf( ('bs : bool <- read ('CtrbSum['n (N + 1) 'k])),
              return 'bs, 'bs
          )     
 )   
 ||
     (family (('Share ^^ 'party .. 'adv)[ (bound (N + 2)) (bound K)]) ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's, 's)
       )        
     ) 
     ) *** end new
   )
  . 
  
  op partyFinal : -> Protocol .
  eq partyFinal = 
   newfamily ('OutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k)
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('OutShareSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k)
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   ( *** start new
     (family ('SendOutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k)
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isOutputWire 'k) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's, 's)
       ) 
       ;; 
       (when (neg (apply 'isOutputWire 'k)) --> 
         nf('s : bool <- read ('SendOutShare['m 'n 'k]), return 's, 's)
       )       
     )
     ||
     (family (('SendOutShare ^^ 'party .. 'adv)
               [((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('m 'n 'k)
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendOutShare['m 'n 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('SendOutShare ^^ 'party .. 'adv)['m 'n 'k]), 
            return 's, 's)
       )       
     )
     ||
     (family (('RcvdOutShare ^^ 'party .. 'adv)
               [((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendOutShare['n 'm 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('RcvdOutShare ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's, 's)
       )       
     )
     || 
     (family ('OutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
      nf('s : bool <- read ('SendOutShare['n 'm 'k]), return 's, 's)       
     )
     ||
     (family (('OutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('OutShare['n 'm 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('OutShare ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's, 's)
       )       
     )
     ||
     (family ('OutShareSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when ('m =T= 0) --> 
         nf('s : bool <- read ('OutShare['n 0 'k]), 
            return 's, 's)
       )
       ;;
       (otherwise -->
         nf( ('s : bool <- read ('OutShareSum['n ('m -- 1) 'k]))
             ('x : bool <- read ('OutShare['n 'm 'k])),
             return (ap 'xor pair('s, 'x)),
             's 'x
         )
       )
     )        
     ||
     (family (('OutShareSum ^^ 'party .. 'adv)
              [((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('OutShareSum['n 'm 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('OutShareSum ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's, 's)
       )       
     )
     ||
     (family ('Out[((bound (N + 2)) (bound K))]) ('n 'k)
             ((bound (N + 2)) (bound K)) ::=
      nf('s : bool <- read ('OutShareSum['n (N + 1) 'k]),
         return 's, 's)       
     )
     ||
     (family (('Out ^^ 'party .. 'adv)[((bound (N + 2)) (bound K))]) ('n 'k)
             (bound (N + 2) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Out['n 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Out ^^ 'party .. 'adv)['n 'k]), 
            return 's, 's)
       )       
     )
   ) *** end new
  .
  
    op 1OutOf4 : -> Protocol .
  eq 1OutOf4 =
   ( family (('OTMsg-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   ( family (('OTMsg-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   ( family (('OTMsg-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   ( family (('OTMsg-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m0 : bool <- read ('OTMsg-0['n 'm 'k]), return (), 'm0)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m1 : bool <- read ('OTMsg-1['n 'm 'k]), return (), 'm1)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m2 : bool <- read ('OTMsg-2['n 'm 'k]), return (), 'm2)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m3 : bool <- read ('OTMsg-3['n 'm 'k]), return (), 'm3)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTChc-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-0['n 'm 'k]), return 'oc, 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChc-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-1['n 'm 'k]), return 'oc, 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c0 : bool <- read ('OTChc-0['n 'm 'k]), return (), 'c0)
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c1 : bool <- read ('OTChc-1['n 'm 'k]), return (), 'c1)
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTOut ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('out : bool <- read ('OTOut['n 'm 'k]), return 'out, 'out)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
     )   
   )
   ||
   (family ('OTOut[(bound (N + 2) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     nf( ('m0 : bool <- read ('OTMsg-0['n 'm 'k]))
         ('m1 : bool <- read ('OTMsg-1['n 'm 'k]))
         ('m2 : bool <- read ('OTMsg-2['n 'm 'k]))
         ('m3 : bool <- read ('OTMsg-3['n 'm 'k]))
         ('c0 : bool <- read ('OTChc-0['n 'm 'k]))
         ('c1 : bool <- read ('OTChc-1['n 'm 'k])),
         if 'c0 
         then (if 'c1 then return 'm3 else return 'm2)
         else (if 'c1 then return 'm1 else return 'm0),
         'm0 'm1 'm2 'm3 'c0 'c1
      )        
   )  
  .
  
    *** the restructured protocol
  
  op restr : -> Protocol .
  eq restr =
   newfamily ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i) 
             ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in   
   newfamily ('Share[((bound (N + 2)) (bound K) )]) ('n 'k) 
             ((bound (N + 2)) (bound K) ) : bool in
     restrInitial || restrInductive || restrFinal
  .

  op restrInitial : -> Protocol . 
  eq restrInitial = 
   newfamily ('InShare$[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in
   newfamily ('InShare$-Sum[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) : bool in         
   newfamily ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i) 
             ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in
   ( *** start new
     (family (('In ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) ('n 'i) ((bound (N + 2)) (dependentBound 'I)) ::=
        (when (apply 'isSemiHonest 'n) -->
           nf('in : bool <- read ('In['n 'i]), 
              return 'in, 'in)
        )
       ;;
       (when (apply 'isHonest 'n) -->
           nf('in : bool <- read (('In ^^ 'party .. 'adv)['n 'i]), 
              return 'in, 'in)
       )
    )
    ||
     (family (('InRcvd ^^ 'party .. 'adv)[( (bound (N + 2)) (dependentBound 'I))]) ('n 'i)
             ( (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isHonest 'n) --> 
         nf('x : bool <- read ('In['n 'i]), return (), 'x)
       ) 
       ;; 
       (when (apply 'isSemiHonest 'n)  --> 
         nf('in : unit <- read (('InRcvd ^^ 'party .. 'adv)['n 'i]), return 'in, 'in)
       )       
     )
    ||
     (family ('InShare$[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when ('m =T= N + 1) --> 
          nf(('x : bool <- read ('In['n 'i]))
             ('s : bool <- read ('InShare$-Sum[N 'n 'i])), 
             return (ap 'xor pair('x, 's)), 'x 's)
       )
       ;;
       (otherwise --> 
         nf('x : bool <- read ('In['n 'i]), samp ('flip < () >), 'x)
       )      
     )
     ||
     (family ('InShare$-Sum[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) ::=
        (when ('m =T= 0) --> 
          nf('in : bool <- read ('InShare$[0 'n 'i]), 
             return 'in, 'in)
        )
        ;;
        (otherwise --> 
          nf(('x : bool <- read ('InShare$['m 'n 'i]))
             ('s : bool <- read ('InShare$-Sum[('m -- 1) 'n 'i])), 
             return (ap 'xor pair('s, 'x)), 's 'x)
        )    
     )
     ||
      (family (('InShare$ ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
          nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in, 'in)
       )
       ;;
       (when (apply 'isHonest 'n)  --> 
         nf('in : bool <- read (('InShare$ ^^ 'party .. 'adv)['m 'n 'i]), 
            return 'in, 'in)
       )      
     )
     ||
     (family (('InShare$-Sum ^^ 'party .. 'adv)[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('InShare$-Sum['m 'n 'i]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('InShare$-Sum ^^ 'party .. 'adv)['m 'n 'i]), 
            return 's, 's)
       )       
     ) 
     ||
     (family ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
        nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in, 'in)    
     )  
     ||
     (family (('SendInShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendInShare['m 'n 'i]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('SendInShare ^^ 'party .. 'adv)['m 'n 'i]), 
            return 's, 's)
       )        
     )
     ||
     (family (('RcvdInShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendInShare['n 'm 'i]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('RcvdInShare ^^ 'party .. 'adv)['n 'm 'i]), 
            return 's, 's)
       )        
     )
     ||
     (family ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
        nf('s : bool <- read ('SendInShare['n 'm 'i]), return 's, 's)    
     )        
     ||
     (family (('InShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('InShare['n 'm 'i]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('InShare ^^ 'party .. 'adv)['n 'm 'i]), 
            return 's, 's)
       )        
     )
     ) *** end new    
  .
  
    op restrInductive : -> Protocol .
  
  eq restrInductive = 
   newfamily ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in  
   newfamily ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   newfamily ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   newfamily ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   newfamily ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in  
   newfamily ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in                             
   newfamily ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   ( *** start new
   
   family ('Circuit[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
   (when (apply 'isInputGate 'k) --> 
   *** for input gate
 ( family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
 )
 ||
 (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
       return 'sb, 'sb) 
 )               
 ||
 ( family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
 )
 ||
 (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
      return 'rb, 'rb)          
 ) 
 ||
 ( family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)           
 )
 ||
 (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)           
 )  
 ||
 ( family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)  
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)           
 )  
 ||
     ( family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
       nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]),
          return 'in, 'in)
     )
     ||
     (family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's, 's)
       )        
     )
     ||
     (  family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     (  family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     (  family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     (  family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     (  family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc, 'oc)
     )
     ||
     (  family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc, 'oc)
     )
     ||
     (family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
     )
||
   (family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m0 : bool <- read ('OTMsg-0['n 'm 'k]), return (), 'm0)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m1 : bool <- read ('OTMsg-1['n 'm 'k]), return (), 'm1)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m2 : bool <- read ('OTMsg-2['n 'm 'k]), return (), 'm2)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m3 : bool <- read ('OTMsg-3['n 'm 'k]), return (), 'm3)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-0['n 'm 'k]), return 'oc, 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-1['n 'm 'k]), return 'oc, 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c0 : bool <- read ('OTChc-0['n 'm 'k]), return (), 'c0)
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c1 : bool <- read ('OTChc-1['n 'm 'k]), return (), 'c1)
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('out : bool <- read ('OTOut['n 'm 'k]), return 'out, 'out)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
     )   
   )
   ||
   ( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     nf( ('m0 : bool <- read ('OTMsg-0['n 'm 'k]))
         ('m1 : bool <- read ('OTMsg-1['n 'm 'k]))
         ('m2 : bool <- read ('OTMsg-2['n 'm 'k]))
         ('m3 : bool <- read ('OTMsg-3['n 'm 'k]))
         ('c0 : bool <- read ('OTChc-0['n 'm 'k]))
         ('c1 : bool <- read ('OTChc-1['n 'm 'k])),
         if 'c0 
         then (if 'c1 then return 'm3 else return 'm2)
         else (if 'c1 then return 'm1 else return 'm0),
         'm0 'm1 'm2 'm3 'c0 'c1
      )        
   )  
   ) *** end when
   ;;
   (when (apply 'isNotGate 'k) -->
  *** for not gate   
 ( family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
 )
 ||
 (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
       return 'sb, 'sb) 
 )               
 ||
 ( family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
 )
 ||
 (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
      return 'rb, 'rb)          
 ) 
 ||
 ( family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)           
 )
 ||
 (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)           
 )  
 ||
 ( family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)  
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)           
 )  
 ||
     ( family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
        (when ('n =T= N + 1) --> 
          nf( ('x : bool <- read ('Share['n (fun 'wire0 'k)])),
              return (ap 'neg 'x), 'x
          )
        )
        ;;
        (when (neg ('n =T= N + 1)) --> 
          nf('s : bool <- read ('Share['n (fun 'wire0 'k)]),
          return 's, 's)
        )
          
     )
     ||
     (family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's, 's)
       )        
     )
     ||
     (  family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     (  family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     (  family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     (  family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     (  family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc, 'oc)
     )
     ||
     (  family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc, 'oc)
     )
     ||  
  (family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m0 : bool <- read ('OTMsg-0['n 'm 'k]), return (), 'm0)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m1 : bool <- read ('OTMsg-1['n 'm 'k]), return (), 'm1)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m2 : bool <- read ('OTMsg-2['n 'm 'k]), return (), 'm2)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m3 : bool <- read ('OTMsg-3['n 'm 'k]), return (), 'm3)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-0['n 'm 'k]), return 'oc, 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-1['n 'm 'k]), return 'oc, 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c0 : bool <- read ('OTChc-0['n 'm 'k]), return (), 'c0)
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c1 : bool <- read ('OTChc-1['n 'm 'k]), return (), 'c1)
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('out : bool <- read ('OTOut['n 'm 'k]), return 'out, 'out)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
     )   
   )
   ||
   ( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     nf( ('m0 : bool <- read ('OTMsg-0['n 'm 'k]))
         ('m1 : bool <- read ('OTMsg-1['n 'm 'k]))
         ('m2 : bool <- read ('OTMsg-2['n 'm 'k]))
         ('m3 : bool <- read ('OTMsg-3['n 'm 'k]))
         ('c0 : bool <- read ('OTChc-0['n 'm 'k]))
         ('c1 : bool <- read ('OTChc-1['n 'm 'k])),
         if 'c0 
         then (if 'c1 then return 'm3 else return 'm2)
         else (if 'c1 then return 'm1 else return 'm0),
         'm0 'm1 'm2 'm3 'c0 'c1
      )        
   )
   )*** end when
   ;;
   (when (apply 'isXorGate 'k) --> 
    *** for xor gate 
 ( family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
 )
 ||
 (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
       return 'sb, 'sb) 
 )               
 ||
 ( family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
 )
 ||
 (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
      return 'rb, 'rb)          
 ) 
 ||
 ( family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)           
 )
 ||
 (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)           
 )  
 ||
 ( family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)  
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)           
 )          
 ||
     ( family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
       nf(('x : bool <- read ('Share['n (fun 'wire0 'k)]))
          ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair('x, 'y)), 'x 'y)
     )
     ||
     (family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's, 's)
       )        
     )
     ||
     (  family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     (  family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     (  family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     (  family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om, 'om)
     )
     ||
     (  family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc, 'oc)
     )
     ||
     (  family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc, 'oc)
     )
      ||  
  (family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m0 : bool <- read ('OTMsg-0['n 'm 'k]), return (), 'm0)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m1 : bool <- read ('OTMsg-1['n 'm 'k]), return (), 'm1)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m2 : bool <- read ('OTMsg-2['n 'm 'k]), return (), 'm2)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m3 : bool <- read ('OTMsg-3['n 'm 'k]), return (), 'm3)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-0['n 'm 'k]), return 'oc, 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-1['n 'm 'k]), return 'oc, 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c0 : bool <- read ('OTChc-0['n 'm 'k]), return (), 'c0)
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c1 : bool <- read ('OTChc-1['n 'm 'k]), return (), 'c1)
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('out : bool <- read ('OTOut['n 'm 'k]), return 'out, 'out)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
     )   
   )
   ||
   ( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     nf( ('m0 : bool <- read ('OTMsg-0['n 'm 'k]))
         ('m1 : bool <- read ('OTMsg-1['n 'm 'k]))
         ('m2 : bool <- read ('OTMsg-2['n 'm 'k]))
         ('m3 : bool <- read ('OTMsg-3['n 'm 'k]))
         ('c0 : bool <- read ('OTChc-0['n 'm 'k]))
         ('c1 : bool <- read ('OTChc-1['n 'm 'k])),
         if 'c0 
         then (if 'c1 then return 'm3 else return 'm2)
         else (if 'c1 then return 'm1 else return 'm0),
         'm0 'm1 'm2 'm3 'c0 'c1
      )        
   )
   ) *** end when
   ;;
   (when (apply 'isAndGate 'k) -->
     *** for and gate
     ( family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( 
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          samp ('flip < () >), 
             'x 'y
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('sb : bool <- read ('SendBit['n 'm 'k]),
          return 'sb, 'sb)
       )   
     )
     ||
      (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's, 's)
       )        
     )
     ||
     (  family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return 'b, 'b 'x 'y
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om, 'om)
       )   
     )
     ||
     (  family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair('x, 'b)), 'b 'x 'y
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om, 'om)
       )   
     )
     ||
     (  family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair('y, 'b)), 'b 'x 'y
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om, 'om)
       )   
     )
     ||
     (  family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)), 
          'b 'x 'y
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om, 'om)
       )   
     )
     ||
     (  family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
      (when ('n <T 'm) --> 
         nf( ('x : bool <- read ('Share['n (fun 'wire0 'k)])),
          return 'x, 'x
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc, 'oc)
       )   
     )
     ||
     (  family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('x : bool <- read ('Share['n (fun 'wire1 'k)])),
          return 'x, 'x
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc, 'oc)
       )   
     )
     ||
     ( family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
          nf( ('out : bool <- read ('OTOut['m 'n 'k])),
              return 'out, 'out
          )     
    )
    ||
     (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('RcvdBit['n 'm 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's, 's)
       )        
     )
      ||
      ( family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
      (when ('n <T 'm) --> 
         nf( ('s : bool <- read ('SendBit['n 'm 'k])),
          return 's, 's
          )
       )
       ;;
       (when ('n =T= 'm) --> 
         nf( ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'and pair('x, 'y)), 
          'x 'y
          )
       )
       ;;
       (when ('m <T 'n) --> 
         nf( ('r : bool <- read ('RcvdBit['n 'm 'k])),
          return 'r, 'r
          )
       )   
     )
     ||
     (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) -->
             nf('s : bool <- read ('Ctrb['n 'm 'k]), return 's, 's)
       )
       ;;
       (when (apply 'isHonest 'n) -->
             nf('s : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
       ) 
     )
      ||
      ( family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   (when ('m =T= 0) --> 
     nf( ('b : bool <- read ('Ctrb['n 0 'k])),
          return 'b, 'b
          ) 
   )
   ;;
   (when (neg ('m =T= 0)) --> 
     nf( ('s : bool <- read ('CtrbSum['n ('m -- 1) 'k]))
         ('b : bool <- read ('Ctrb['n 'm 'k])),
          return (ap 'xor pair('s, 'b)), 's 'b
          ) 
   )
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('CtrbSum['n 'm 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's, 's)
       )        
     )
      ||   
 ( family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
          nf( ('bs : bool <- read ('CtrbSum['n (N + 1) 'k])),
              return 'bs, 'bs
          )     
 )   
 ||
     (family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's, 's)
       )        
     )
     ||
     (family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om, 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m0 : bool <- read ('OTMsg-0['n 'm 'k]), return (), 'm0)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m1 : bool <- read ('OTMsg-1['n 'm 'k]), return (), 'm1)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m2 : bool <- read ('OTMsg-2['n 'm 'k]), return (), 'm2)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m3 : bool <- read ('OTMsg-3['n 'm 'k]), return (), 'm3)
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
     )   
   )
   ||
   (family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-0['n 'm 'k]), return 'oc, 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-1['n 'm 'k]), return 'oc, 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c0 : bool <- read ('OTChc-0['n 'm 'k]), return (), 'c0)
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c1 : bool <- read ('OTChc-1['n 'm 'k]), return (), 'c1)
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc, 'oc)
     )   
   )
   ||
   (family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('out : bool <- read ('OTOut['n 'm 'k]), return 'out, 'out)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
     )   
   )
   ||
   ( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     nf( ('m0 : bool <- read ('OTMsg-0['n 'm 'k]))
         ('m1 : bool <- read ('OTMsg-1['n 'm 'k]))
         ('m2 : bool <- read ('OTMsg-2['n 'm 'k]))
         ('m3 : bool <- read ('OTMsg-3['n 'm 'k]))
         ('c0 : bool <- read ('OTChc-0['n 'm 'k]))
         ('c1 : bool <- read ('OTChc-1['n 'm 'k])),
         if 'c0 
         then (if 'c1 then return 'm3 else return 'm2)
         else (if 'c1 then return 'm1 else return 'm0),
         'm0 'm1 'm2 'm3 'c0 'c1
      )        
   ) 

   )
   ) *** end new

  . 
     
  op restrFinal : -> Protocol .  
  
  eq restrFinal = 
   newfamily ('SendOutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in          
   newfamily ('OutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) : bool in
   newfamily ('OutShareSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) : bool in
   ( *** start new
     (family ('SendOutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isOutputWire 'k) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's, 's)
       ) 
       ;; 
       (when (neg (apply 'isOutputWire 'k)) --> 
         nf('s : bool <- read ('SendOutShare['m 'n 'k]), return 's, 's)
       )       
     )
     ||
     (family (('SendOutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendOutShare['m 'n 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('SendOutShare ^^ 'party .. 'adv)['m 'n 'k]), 
            return 's, 's)
       )       
     )
     ||
     (family (('RcvdOutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendOutShare['n 'm 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('RcvdOutShare ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's, 's)
       )       
     )
     || 
     (family ('OutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
      nf('s : bool <- read ('SendOutShare['n 'm 'k]), return 's, 's)       
     )
     ||
     (family (('OutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('OutShare['n 'm 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('OutShare ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's, 's)
       )       
     )
     ||
     (family ('OutShareSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when ('m =T= 0) --> 
         nf('s : bool <- read ('OutShare['n 0 'k]), 
            return 's, 's)
       )
       ;;
       (otherwise -->
         nf( ('s : bool <- read ('OutShareSum['n ('m -- 1) 'k]))
             ('x : bool <- read ('OutShare['n 'm 'k])),
             return (ap 'xor pair('s, 'x)),
             's 'x
         )
       )
     )        
     ||
     (family (('OutShareSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('OutShareSum['n 'm 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('OutShareSum ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's, 's)
       )       
     )
     ||
     (family ('Out[((bound (N + 2)) (bound K))]) ('n 'k)
             ((bound (N + 2)) (bound K)) ::=
      nf('s : bool <- read ('OutShareSum['n (N + 1) 'k]),
         return 's, 's)       
     )
     ||
     (family (('Out ^^ 'party .. 'adv)[((bound (N + 2)) (bound K))]) ('n 'k)
             (bound (N + 2) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Out['n 'k]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Out ^^ 'party .. 'adv)['n 'k]), 
            return 's, 's)
       )       
     )
   ) *** end new

 . 
 
  *** before restructuring Circuit, store the results
 op simplRestrInitial : -> Protocol .
  
 eq simplRestrInitial = 
   newfamily ('InShare$[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in
   newfamily ('InShare$-Sum[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) : bool in         
   ( *** start new
     (family (('In ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) ('n 'i) ((bound (N + 2)) (dependentBound 'I)) ::=
        (when (apply 'isSemiHonest 'n) -->
           nf('in : bool <- read ('In['n 'i]), 
              return 'in, 'in)
        )
       ;;
       (when (apply 'isHonest 'n) -->
           nf('in : bool <- read (('In ^^ 'party .. 'adv)['n 'i]), 
              return 'in, 'in)
       )
    )
    ||
     (family (('InRcvd ^^ 'party .. 'adv)[( (bound (N + 2)) (dependentBound 'I))]) ('n 'i)
             ( (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isHonest 'n) --> 
         nf('x : bool <- read ('In['n 'i]), return (), 'x)
       ) 
       ;; 
       (when (apply 'isSemiHonest 'n)  --> 
         nf('in : unit <- read (('InRcvd ^^ 'party .. 'adv)['n 'i]), return 'in, 'in)
       )       
     )
    ||
     (family ('InShare$[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when ('m =T= N + 1) --> 
          nf(('x : bool <- read ('In['n 'i]))
             ('s : bool <- read ('InShare$-Sum[N 'n 'i])), 
             return (ap 'xor pair('x, 's)), 'x 's)
       )
       ;;
       (otherwise --> 
         nf('x : bool <- read ('In['n 'i]), samp ('flip < () >), 'x)
       )      
     )
     ||
     (family ('InShare$-Sum[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) ::=
        (when ('m =T= 0) --> 
          nf('in : bool <- read ('InShare$[0 'n 'i]), 
             return 'in, 'in)
        )
        ;;
        (otherwise --> 
          nf(('x : bool <- read ('InShare$['m 'n 'i]))
             ('s : bool <- read ('InShare$-Sum[('m -- 1) 'n 'i])), 
             return (ap 'xor pair('s, 'x)), 's 'x)
        )    
     )
     ||
      (family (('InShare$ ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
          nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in, 'in)
       )
       ;;
       (when (apply 'isHonest 'n)  --> 
         nf('in : bool <- read (('InShare$ ^^ 'party .. 'adv)['m 'n 'i]), 
            return 'in, 'in)
       )      
     )
     ||
     (family (('InShare$-Sum ^^ 'party .. 'adv)[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('InShare$-Sum['m 'n 'i]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('InShare$-Sum ^^ 'party .. 'adv)['m 'n 'i]), 
            return 's, 's)
       )       
     ) 
     ||
     (family (('SendInShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in, 'in)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('SendInShare ^^ 'party .. 'adv)['m 'n 'i]), 
            return 's, 's)
       )        
     )
     ||
     (family (('RcvdInShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('in : bool <- read ('InShare$['n 'm 'i]), return 'in, 'in)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('RcvdInShare ^^ 'party .. 'adv)['n 'm 'i]), 
            return 's, 's)
       )        
     )
     ||
     (family ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
        nf('in : bool <- read ('InShare$['n 'm 'i]), return 'in, 'in)   
     )        
     ||
     (family (('InShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('InShare['n 'm 'i]), return 's, 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('InShare ^^ 'party .. 'adv)['n 'm 'i]), 
            return 's, 's)
       )        
     )
     ) *** end new    
  . 
  
   *** restructuring Circuit
  
  *** 1. Shares
  op shares : -> Protocol .
eq shares = 
 family ('Shares[bound K]) 'k (bound K) ::=
 ( *** start family
 
  (when (apply 'isInputGate 'k) --> 
    (family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
      nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
    )
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
    ||
    (family ('Ctrb[((bound (N + 2))(bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
    ||
    (family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::=
      nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), 
         return 'in, 'in)
    )
  ) *** end when input gate
  ;;
   (when (apply 'isNotGate 'k) --> 
    (family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
      nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
    )
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
    ||
    (family ('Ctrb[((bound (N + 2))(bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
    ||
    (family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::=
      (when ('n =T= N + 1) -->
 nf('x : bool <- read ('Share['n (fun 'wire0 'k)]), 
 return (ap 'neg 'x), 'x))
;;
(when (neg ('n =T= N + 1)) -->
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's, 's)
)
    )
  ) *** end when not gate
  ;;
   (when (apply 'isXorGate 'k) --> 
    (family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
      nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
    )
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
    ||
    (family ('Ctrb[((bound (N + 2))(bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
    ||
    (family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::=
      nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
          'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
         return (ap 'xor pair('x, 'y)), 
         'x 'y)
    )
  ) *** end when xor gate
  ;;
   (when (apply 'isAndGate 'k) --> 
    (family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
      nf(('b : bool <- read ('SendBit['m 'n 'k])) 
         ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) 
         ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) 
         ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 
          'yn : bool <- read ('Share['n (fun 'wire1 'k)]), 
          return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn), 
                                            ap 'and pair('xn, 'ym)), 
                               'b)), 
          'b 'xm 'ym 'xn 'yn)
    )
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    samp ('flip < () >),
    'x 'y))
;;
(when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
)
    ||
    (family ('Ctrb[((bound (N + 2))(bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'and pair('x, 'y)), 'x 'y))
;;
(when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r, 'r)
)
)
||
( family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b, 'b))
;;
(when (neg (0 =T= 'm)) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k]))  
    's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), 
    return (ap 'xor pair('s, 'b)), 
    's 'b)
)
)
    ||
    (family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::=
      nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs, 'bs)
    )
  ) *** end when and gate
  
 
 ) *** end family
 
. 

  *** 2. Adv
  op adv : -> Protocol .
eq adv = 
 family ('Adv[bound K]) 'k (bound K) ::=
 ( *** start family
 
(when (apply 'isInputGate 'k) -->

(family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
)
||
(family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb, 'rb)
)
||
(family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb, 'sb)
)
||
(
family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k) ((bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's, 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's, 's)
)
)
) *** end when input gate        
;;
(when (apply 'isNotGate 'k) -->
(family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
)
||
(family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb, 'rb)
)
||
(family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb, 'sb)
)
||
(family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k)
((bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's, 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's, 's)
)
)
) *** end when not gate
;;
(when (apply 'isXorGate 'k) -->
(family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
)
||
(family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb, 'rb)
)
||
(family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb, 'sb)
)
||
(family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k)
((bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's, 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's, 's)
)
)
)
;;
(when (apply 'isAndGate 'k) -->
(family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Ctrb['n 'm 'k]), return 's, 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)
)
||
(family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('CtrbSum['n 'm 'k]), return 's, 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)
)
||
(family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isSemiHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), return 'x, 'x))
;;
(when ((apply 'isHonest 'm) disj 'm <=T 'n) -->
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
)
||
(family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isSemiHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), return 'x, 'x))
;;
(when ((apply 'isHonest 'm) disj 'm <=T 'n) -->
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
)
||
(family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), return (), 'x))
;;
(when ((apply 'isSemiHonest 'm) disj 'm <=T 'n) -->
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
)
||
(family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), return (), 'x))
;;
(when ((apply 'isSemiHonest 'm) disj 'm <=T 'n) -->
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
)
||
(family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return 'b, 'b 'x 'y))
;;
(when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
)
||
(family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair('x, 'b)), 'b 'x 'y))
;;
(when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
)
||
(family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair('y, 'b)), 'b 'x 'y)
)
;;
(when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
)
||
(family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)), 
    'b 'x 'y)
)
;;
(when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
)
||
(family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (), 'b 'x 'y))
;;
(when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
)
||
(family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (), 'b 'x 'y))
;;
(when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
)
||
(family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (), 'b 'x 'y))
;;
(when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
)
||
(family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (), 'b 'x 'y))
;;
(when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
)
||
(family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'm) -->
nf('out : bool <- read ('RcvdBit['m 'n 'k]), return 'out, 'out))
;;
(when (apply 'isHonest 'm) -->
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
)
)
||
(family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('RcvdBit['n 'm 'k]), return 's, 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)
)
||
(family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)
)
||
family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k)
((bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's, 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's, 's)
)
) *** end when and gate

 
 ) *** end family
 
.

  *** 3. 1OutOf4OT
  op 1OutOf4OT : -> Protocol .
  
  eq 1OutOf4OT =
    newfamily ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in  
    newfamily ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
    newfamily ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
    newfamily ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
    newfamily ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in  
    newfamily ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in                             
    newfamily ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   family ('1OutOf4OT[bound K]) 'k (bound K) ::=
    ( *** start family
      (when (apply 'isInputGate 'k) -->
      ( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om, 'om)
      )
      ||
      ( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om, 'om)
      )
      ||
      ( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om, 'om)
      ) 
      ||
      ( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om, 'om)
      )
      ||
      ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('oc : bool <- read ('OTChc-0['m 'n 'k]), return 'oc, 'oc)
      )
      ||
      ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('oc : bool <- read ('OTChc-1['m 'n 'k]), return 'oc, 'oc)
      )
      ||
      ( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('o : bool <- read ('OTOut['n 'm 'k]), return 'o, 'o)
      ) 
    ) *** end when input gate
    ;;
    (when (apply 'isNotGate 'k) -->
      ( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om, 'om)
      )
      ||
      ( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om, 'om)
      )
      ||
      ( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om, 'om)
      ) 
      ||
      ( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om, 'om)
      )
      ||
      ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('oc : bool <- read ('OTChc-0['m 'n 'k]), return 'oc, 'oc)
      )
      ||
      ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('oc : bool <- read ('OTChc-1['m 'n 'k]), return 'oc, 'oc)
      )
      ||
      ( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('o : bool <- read ('OTOut['n 'm 'k]), return 'o, 'o)
      ) 
    ) *** end when not gate
    ;;
    (when (apply 'isXorGate 'k) -->
      ( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om, 'om)
      )
      ||
      ( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om, 'om)
      )
      ||
      ( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om, 'om)
      ) 
      ||
      ( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om, 'om)
      )
      ||
      ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('oc : bool <- read ('OTChc-0['m 'n 'k]), return 'oc, 'oc)
      )
      ||
      ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('oc : bool <- read ('OTChc-1['m 'n 'k]), return 'oc, 'oc)
      )
      ||
      ( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('o : bool <- read ('OTOut['n 'm 'k]), return 'o, 'o)
      ) 
    ) *** end when xor gate
    ;;
    
    
    (when (apply 'isAndGate 'k) -->

( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ('n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return 'b, 'b 'x 'y)
)
;;
(when ('m <=T 'n) -->
nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om, 'om)
)
)
||
( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ('n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair('x, 'b)), 'b 'x 'y))
;;
(when ('m <=T 'n) -->
nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om, 'om)
)
)
||
( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ('n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair('y, 'b)), 'b 'x 'y))
;;
(when ('m <=T 'n) -->
nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om, 'om)
)
)
||
( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ('n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)), 
    'b 'x 'y)
)
;;
(when ('m <=T 'n) -->
nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om, 'om)
)
)
      ||
      ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        (when ('n <T 'm) --> 
          nf('x : bool <- read ('Share['n (fun 'wire0 'k)]), 
             return 'x, 'x))
        ;;
        (when ('m <=T 'n) -->
          nf('oc : bool <- read ('OTChc-0['m 'n 'k]), return 'oc, 'oc)
        )
      )
      ||
      ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        (when ('n <T 'm) --> 
          nf('x : bool <- read ('Share['n (fun 'wire1 'k)]), 
             return 'x, 'x))
        ;;
        (when ('m <=T 'n) -->
          nf('oc : bool <- read ('OTChc-1['m 'n 'k]), return 'oc, 'oc)
        )
      )

      ||
( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf(('c0 : bool <- read ('OTChc-0['n 'm 'k])) 
   ('c1 : bool <- read ('OTChc-1['n 'm 'k])) 
   ('m0 : bool <- read ('OTMsg-0['n 'm 'k])) 
   ('m1 : bool <- read ('OTMsg-1['n 'm 'k])) 
   ('m2 : bool <- read ('OTMsg-2['n 'm 'k])) 
    'm3 : bool <- read ('OTMsg-3['n 'm 'k]), 
   if 'c0 then if 'c1 then return 'm3 else return 'm2 
          else if 'c1 then return 'm1 else return 'm0,
    'm0 'm1 'm2 'm3 'c0 'c1)
)
    ) *** end when and gate  
    
    ) *** end family
. 


 op splitCirc : -> Protocol .
 eq splitCirc = 
    newfamily ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
    newfamily ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   (adv || shares || 1OutOf4OT)          
 .
 
  op pInt0 : -> Protocol .
 eq pInt0 = 
    newfamily ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i) 
             ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in   
    newfamily ('Share[((bound (N + 2)) (bound K) )]) ('n 'k) 
             ((bound (N + 2)) (bound K) ) : bool in
    restrFinal || splitCirc || simplRestrInitial
 .
 
  op splitCirc1 : -> Protocol .
 eq splitCirc1 = 
    newfamily ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
    newfamily ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   (adv || shares)          
 .   
  
 op pInt1 : -> Protocol .
 eq pInt1 = 
    newfamily ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i) 
             ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in   
    newfamily ('Share[((bound (N + 2)) (bound K) )]) ('n 'k) 
             ((bound (N + 2)) (bound K) ) : bool in
    restrFinal || splitCirc1 || simplRestrInitial
 .
 
endm

mod PROTOCOLS is
 pr GMWN .
 
 
 op delta0 : -> ChannelContext .
 eq delta0 = 
  getInductionDelta
  
  (addInternalChannels
  (
 (fam ('In[bound (N + 2) dependentBound 'I]) :: bool)
(fam ('Out[bound (N + 2) bound K]) :: bool)
(fam (('Ctrb ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('CtrbSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('In ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I]) :: bool)
(fam (('InRcvd ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I]) :: unit)
(fam (('InShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) dependentBound 'I]) :: bool)
(fam (('InShare$ ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) dependentBound 'I]) :: bool)
(fam (('InShare$-Sum ^^ 'party .. 'adv)[bound (N + 1) bound (N + 2) dependentBound 'I]) :: bool)
(fam (('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K]) :: unit)
(fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]) :: unit)
(fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K]) :: unit)
(fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]) :: unit)
(fam (('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: unit)
(fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: unit)
(fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: unit)
(fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: unit)
(fam (('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('Out ^^ 'party .. 'adv)[bound (N + 2) bound K]) :: bool)
(fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('RcvdBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('RcvdInShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) dependentBound 'I]) :: bool)
(fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('SendBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('SendInShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) dependentBound 'I]) :: bool)
(fam (('SendOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
fam (('Share ^^ 'party .. 'adv)[bound (N + 2) bound K]) :: bool) 

newNF({('Ctrb[bound (N + 2) bound (
    N + 2) bound K]) ('n 'm 'k) : bool} {('Ctrb-OK[bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k)
    : unit} {('CtrbSum[bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k) : bool} {('CtrbSum-OK[bound
    (N + 2) bound (N + 2) bound K]) ('n 'm 'k) : unit} {('In-OK[bound (N + 2) dependentBound 'I]) (
    'n 'i) : unit} {('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]) ('n 'm 'i) : bool} {(
    'InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]) ('m 'n 'i) : bool} {('InShare$-OK[
    bound (N + 2) bound (N + 2) dependentBound 'I]) ('m 'n 'i) : unit} {('InShare$-Sum[bound (N + 1)
    bound (N + 2) dependentBound 'I]) ('m 'n 'i) : bool} {('InShare$Sum-OK[bound (N + 1) bound (N +
    2) dependentBound 'I]) ('m 'n 'i) : unit} {('InShareOK[bound (N + 2) bound (N + 2)
    dependentBound 'I]) ('m 'n 'i) : unit} {('OutShare[bound (N + 2) bound (N + 2) bound K]) ('n 'm
    'k) : bool} {('OutShareSum[bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k) : bool} {('RcvdBit[
    bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k) : bool} {('RcvdBit-OK[bound (N + 2) bound (N +
    2) bound K]) ('n 'm 'k) : unit} {('SendBit[bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k) :
    bool} {('SendBit-OK[bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k) : unit} {('Share[bound (N +
    1) bound K]) ('n 'k) : bool} {('Share[fixedBound (N + 1) bound K]) ('n 'k) : bool} {('ShareOK[
    bound (N + 2) bound K]) ('n 'k) : unit} {('Wire-OK[bound K]) 'k : unit},
    emptyProtocol, nil)
) 
want0 'k 'B
.
 
 *************************************************************
 
 op want0 : -> Protocol .
 eq want0 =
(family 'Shares[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family ('Share[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in, 'in)
)
||
(family ('Share[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)])) 
    'x : unit <- read ('InShareOK[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]), 
    return 'in, 'x 'in)
)
) *** end when input gate
;;
(when (apply 'isNotGate 'k) -->
(family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family ('Share[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's, 's)
)
||
(family ('Share[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf(('s : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)])) 
    'x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)]), 
    return (ap 'neg 'x), 's 'x)
)
) *** end when not gate
;;
(when (apply 'isXorGate 'k) -->
(family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family ('Share[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)), 'x 'y)
)
||
(family ('Share[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf(('a : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)])) 
   ('b : unit <- read ('ShareOK[(N + 1) (fun 'wire1 'k)])) 
   ('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 
   'y : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), 
   return (ap 'xor pair('x, 'y)), 'a 'b 'x 'y)
)
) *** end when xor gate
;;
(when (apply 'isAndGate 'k) -->
(family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)), 'x 'y))
;;
(when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r, 'r)
)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b, 'b))
;;
(when (neg (0 =T= 'm)) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 
    's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), 
    return (ap 'xor pair('s, 'b)), 's 'b)
)
)
||
(family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) 
   ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) 
   ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) 
   ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 
    'yn : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn), 
                         ap 'and pair('xn, 'ym)), 'b)), 
    'b 'xm 'ym 'xn 'yn)
)
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >), 'x 'y))
;;
(when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
)
||
(family ('Share[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs, 'bs)
)
||
(family ('Share[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k])) 
    'x : unit <- read ('CtrbSum-OK[(N + 1) (N + 1) 'k]), 
    return 'bs, 'x 'bs)
)
) *** end when and gate
)
||
(family 'SharesOK[bound K] 'k
bound K
::=
cases0
)
.

 op know0 : -> Protocol .
 eq know0 =
(family 'Shares[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family ('Share[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in, 'in)
)
||
(family ('Share[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)])) 
    'x : unit <- read ('InShareOK[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]), 
    return 'in, 'x 'in)
)
) *** end when input gate
;;
(when (apply 'isNotGate 'k) -->
(family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family ('Share[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's, 's)
)
||
(family ('Share[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf(('s : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)])) 
    'x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)]), 
    return (ap 'neg 'x), 's 'x)
)
) *** end when not gate
;;
(when (apply 'isXorGate 'k) -->
(family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family ('Share[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)), 'x 'y)
)
||
(family ('Share[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf(('a : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)])) 
   ('b : unit <- read ('ShareOK[(N + 1) (fun 'wire1 'k)])) 
   ('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 
   'y : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), 
   return (ap 'xor pair('x, 'y)), 'a 'b 'x 'y)
)
) *** end when xor gate
;;
(when (apply 'isAndGate 'k) -->
(family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)), 'x 'y))
;;
(when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r, 'r)
)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b, 'b))
;;
(when (neg (0 =T= 'm)) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 
    's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), 
    return (ap 'xor pair('s, 'b)), 's 'b)
)
)
||
(family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) 
   ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) 
   ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) 
   ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 
    'yn : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn), 
                         ap 'and pair('xn, 'ym)), 'b)), 
    'b 'xm 'ym 'xn 'yn)
)
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >), 'x 'y))
;;
(when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
)
||
(family ('Share[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs, 'bs)
)
||
(family ('Share[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k])) 
    'x : unit <- read ('CtrbSum-OK[(N + 1) (N + 1) 'k]), 
    return 'bs, 'x 'bs)
)
) *** end when and gate
)
||
(family 'SharesOK[bound K] 'k
bound K
::=
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : bool <- read ('Ctrb['n 'm 'k]), return (), 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : bool <- read ('CtrbSum['n 'm 'k]), return (), 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return (), 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : bool <- read ('SendBit['n 'm 'k]), return (), 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('x : bool <- read ('Share['n 'k]), return (), 'x)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('x : bool <- read ('Share[(N + 1) 'k]), return (), 'x)
)
.

op cases0 : -> Cases .
eq cases0 = 
(when (apply 'isInputGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
(
family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('i : unit <- read ('InShareOK['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'i, 'i)
)
||
(
family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf('i : unit <- read ('InShareOK[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]), return 'i, 'i)
)
) *** end when input gate
;;
(when (apply 'isNotGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
(
family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('x : unit <- read ('ShareOK['n (fun 'wire0 'k)]), return 'x, 'x)
)
||
(
family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf('x : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)]), return 'x, 'x)
)
) *** end when not gate
;;
(when (apply 'isXorGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
(
family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 
    'y : unit <- read ('ShareOK['n (fun 'wire1 'k)]), 
    return (), 'x 'y)
)
||
(
family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf(('x : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)])) 
    'y : unit <- read ('ShareOK[(N + 1) (fun 'wire1 'k)]), 
    return (), 'x 'y)
)
) *** end when xor gate
;;
(when (apply 'isAndGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) -->
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's))
;;
(when ('m <T 'n) -->
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r))
;;
when ('m =T= 'n) -->
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 'y : unit <- read ('ShareOK['n (fun 'wire1
    'k)]), return (), 'x 'y)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (0 =T= 'm) -->
nf('c : unit <- read ('Ctrb-OK['n 0 'k]), return 'c, 'c))
;;
(when (neg (0 =T= 'm)) -->
nf(('x : unit <- read ('CtrbSum-OK['n ('m -- 1) 'k])) 
    'y : unit <- read ('Ctrb-OK['n 'm 'k]), 
     return (), 'x 'y)
)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf(('sb : unit <- read ('SendBit-OK['m 'n 'k])) 
   ('xm : unit <- read ('ShareOK['m (fun 'wire0 'k)]))
   ('xn : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 
   ('ym : unit <- read ('ShareOK['m (fun 'wire1 'k)])) 
    'yn : unit <- read ('ShareOK['n (fun 'wire1 'k)]), 
    return (), 'sb 'xm 'ym 'xn 'yn)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) -->
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 
    'y : unit <- read ('ShareOK['n (fun 'wire1 'k)]), 
    return (), 'x 'y))
;;
(when ('m <=T 'n) -->
nf('sb : unit <- read ('SendBit-OK['n 'm 'k]), return 'sb, 'sb)
)
)
||
(family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n (N + 1) 'k]), return 'c, 'c)
)
||
(family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf('c : unit <- read ('CtrbSum-OK[(N + 1) (N + 1) 'k]), return 'c, 'c)
)
) *** end when and gate
.
 
 op want10old : -> Protocol .
 eq want10old =
(family 'Shares[bound K] 'k
bound K
::=
(family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (apply 'isInputGate 'k) -->
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b))
;;
(when (apply 'isNotGate 'k) -->
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b))
;;
(when (apply 'isXorGate 'k) -->
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b))
;;
(when ((apply 'isAndGate 'k) conj 'n <T 'm) -->
nf('r : bool <- read ('RcvdBit['m 'n 'k]), return 'r, 'r))
;;
(when ((apply 'isAndGate 'k) conj 'm =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)), 'x 'y))
;;
when ((apply 'isAndGate 'k) conj 'm <T 'n) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (apply 'isInputGate 'k) -->
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b))
;;
(when (apply 'isNotGate 'k) -->
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b))
;;
(when (apply 'isXorGate 'k) -->
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b))
;;
(when ((apply 'isAndGate 'k) conj 0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b, 'b))
;;
when (neg (0 =T= 'm) conj apply 'isAndGate 'k) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)), 's 'b)
)
||
(family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (apply 'isInputGate 'k) -->
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb))
;;
(when (apply 'isNotGate 'k) -->
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb))
;;
(when (apply 'isXorGate 'k) -->
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb))
;;
when (apply 'isAndGate 'k) -->
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)), 'b 'xm 'ym 'xn 'yn)
)
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (apply 'isInputGate 'k) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb))
;;
(when (apply 'isNotGate 'k) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb))
;;
(when (apply 'isXorGate 'k) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb))
;;
(when ((apply 'isAndGate 'k) conj 'n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >), 'x 'y))
;;
when ((apply 'isAndGate 'k) conj 'm <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family ('Share[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
(when (apply 'isInputGate 'k) -->
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in, 'in))
;;
(when (apply 'isNotGate 'k) -->
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's, 's))
;;
(when (apply 'isXorGate 'k) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)), 'x 'y))
;;
when (apply 'isAndGate 'k) -->
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs, 'bs)
)
||
family ('Share[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
(when (apply 'isInputGate 'k) -->
nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)])) 'x : unit <- read (
    'InShareOK[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in, 'x 'in))
;;
(when (apply 'isNotGate 'k) -->
nf(('s : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)])) 'x : bool <- read ('Share[(N + 1) (fun
    'wire0 'k)]), return (ap 'neg 'x), 's 'x))
;;
(when (apply 'isXorGate 'k) -->
nf(('a : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)])) ('b : unit <- read ('ShareOK[(N + 1) (fun
    'wire1 'k)])) ('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 'y : bool <- read ('Share[(N
    + 1) (fun 'wire1 'k)]), return (ap 'xor pair('x, 'y)), 'a 'b 'x 'y))
;;
when (apply 'isAndGate 'k) -->
nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k])) 'x : unit <- read ('CtrbSum-OK[(N + 1) (N +
    1) 'k]), return 'bs, 'x 'bs)

)
||
family 'SharesOK[bound K] 'k
bound K
::=
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (apply 'isInputGate 'k) -->
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c))
;;
(when (apply 'isNotGate 'k) -->
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c))
;;
(when (apply 'isXorGate 'k) -->
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c))
;;
(when ((apply 'isAndGate 'k) conj 'n <T 'm) -->
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's))
;;
(when ((apply 'isAndGate 'k) conj 'm <T 'n) -->
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r))
;;
when ((apply 'isAndGate 'k) conj 'm =T= 'n) -->
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 'y : unit <- read ('ShareOK['n (fun 'wire1
    'k)]), return (), 'x 'y)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (apply 'isInputGate 'k) -->
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c))
;;
(when (apply 'isNotGate 'k) -->
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c))
;;
(when (apply 'isXorGate 'k) -->
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c))
;;
(when ((apply 'isAndGate 'k) conj 0 =T= 'm) -->
nf('c : unit <- read ('Ctrb-OK['n 0 'k]), return 'c, 'c))
;;
when (neg (0 =T= 'm) conj apply 'isAndGate 'k) -->
nf(('x : unit <- read ('CtrbSum-OK['n ('m -- 1) 'k])) 'y : unit <- read ('Ctrb-OK['n 'm 'k]), return
    (), 'x 'y)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (apply 'isInputGate 'k) -->
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r))
;;
(when (apply 'isNotGate 'k) -->
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r))
;;
(when (apply 'isXorGate 'k) -->
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r))
;;
when (apply 'isAndGate 'k) -->
nf(('sb : unit <- read ('SendBit-OK['n 'm 'k])) ('xm : unit <- read ('ShareOK['m (fun 'wire0 'k)]))
    ('xn : unit <- read ('ShareOK['n (fun 'wire0 'k)])) ('ym : unit <- read ('ShareOK['m (fun 'wire1
    'k)])) 'yn : unit <- read ('ShareOK['n (fun 'wire1 'k)]), return (), 'sb 'xm 'ym 'xn 'yn)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (apply 'isInputGate 'k) -->
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's))
;;
(when (apply 'isNotGate 'k) -->
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's))
;;
(when (apply 'isXorGate 'k) -->
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's))
;;
(when ((apply 'isAndGate 'k) conj 'n <T 'm) -->
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 'y : unit <- read ('ShareOK['n (fun 'wire1
    'k)]), return (), 'x 'y))
;;
when ((apply 'isAndGate 'k) conj 'm <=T 'n) -->
nf('sb : unit <- read ('SendBit-OK['n 'm 'k]), return 'sb, 'sb)
)
||
family ('ShareOK[(bound (N + 2)) (bound K)]) ('n 'k)
((bound (N + 2)) (bound K))
::=
(when (apply 'isInputGate 'k) -->
nf('i : unit <- read ('InShareOK['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'i, 'i))
;;
(when (apply 'isNotGate 'k) -->
nf('x : unit <- read ('ShareOK['n (fun 'wire0 'k)]), return 'x, 'x))
;;
(when (apply 'isXorGate 'k) -->
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 'y : unit <- read ('ShareOK['n (fun 'wire1
    'k)]), return (), 'x 'y))
;;
when (apply 'isAndGate 'k) -->
nf('c : unit <- read ('CtrbSum-OK['n (N + 1) 'k]), return 'c, 'c)

.


 *** TODO: copy the protocol!
 
 op delta1 : -> ChannelContext .
eq delta1 =

(fam ('In[bound (N + 2) dependentBound 'I]) :: bool)
(fam ('Out[bound (N + 2) bound K]) :: bool)
(fam (('Ctrb ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('CtrbSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) ::
    bool)
(fam (('In ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I]) :: bool)
(fam (('InRcvd ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I]) :: unit)
(fam (('InShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) dependentBound
    'I]) :: bool)
(fam (('InShare$ ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) dependentBound
    'I]) :: bool)
(fam (('InShare$-Sum ^^ 'party .. 'adv)[bound (N + 1) bound (N + 2)
    dependentBound 'I]) :: bool)
(fam (('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K]) ::
    unit)
(fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
    :: unit)
(fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K]) ::
    unit)
(fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
    :: unit)
(fam (('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) ::
    unit)
(fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) ::
    unit)
(fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) ::
    unit)
(fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) ::
    unit)
(fam (('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
(fam (('Out ^^ 'party .. 'adv)[bound (N + 2) bound K]) :: bool)
(fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) ::
    bool)
(fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) ::
    bool)
(fam (('RcvdBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) ::
    bool)
(fam (('RcvdInShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2)
    dependentBound 'I]) :: bool)
(fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K])
    :: bool)
(fam (('SendBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) ::
    bool)
(fam (('SendInShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2)
    dependentBound 'I]) :: bool)
(fam (('SendOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K])
    :: bool)
fam (('Share ^^ 'party .. 'adv)[bound (N + 2) bound K]) :: bool
.

*************
op indBase1 : -> Protocol .
eq indBase1 = getInductionBase (emptyProtocol || (family ('Comp['G 'H][bound N]) 'i
bound N
::=
(family 'G[bound N] 'i
bound N
::=
(
(family 'G1[bound N] 'i
bound N
::=
read ('In['i])
)
||
(family 'G2[bound N] 'i
bound N
::=
read ('In['i])
)

)
)
||
family 'H[bound N] 'i
bound N
::=
(
(family 'H1[bound N] 'i
bound N
::=
read ('In['i])
)
||
(family 'H2[bound N] 'i
bound N
::=
read ('In['i])
)
)

)) ('Comp['G 'H]) 'i 'B empty 
((family 'G[bound N] 'i
bound N
::=
((family 'G1[bound N] 'i
bound N
::=
read ('In['i])
)
||
(family 'G2[bound N] 'i
bound N
::=
read ('In['i])
)
)
)
||
family 'H[bound N] 'i
bound N
::=
(
(family 'H1[bound N] 'i
bound N
::=
read ('In['i])
)
||
(family 'H2[bound N] 'i
bound N
::=
read ('In['i])
)
)

)
 .

op indP1 : -> Protocol .
eq indP1 = 
((family 'G[bound N] 'i
bound N
::=
((family 'G1[bound N] 'i
bound N
::=
read ('In1['i])
)
||
(family 'G2[bound N] 'i
bound N
::=
read ('In1['i])
)
)
)
||
family 'H[bound N] 'i
bound N
::=
(
(family 'H1[bound N] 'i
bound N
::=
read ('In1['i])
)
||
(family 'H2[bound N] 'i
bound N
::=
read ('In1['i])
)
)

)
.

****************
 
 op indBase0 : -> Protocol .
 eq indBase0 = 
   getInductionBase p0 'SharesOK 'k 'B genA 
        (
(family  ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : bool <- read ('Ctrb['n 'm 'k]), return (), 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : bool <- read ('CtrbSum['n 'm 'k]), return (), 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return (), 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : bool <- read ('SendBit['n 'm 'k]), return (), 's)
)
||
(family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('x : bool <- read ('Share['n 'k]), return (), 'x)        
)        
||
(family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf('x : bool <- read ('Share[(N + 1) 'k]), return (), 'x)        
)
       
  )
 .
 
 op indP0 : -> Protocol .
 eq indP0 = 
  (family ('Ctrb-OK[bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k)
bound (N + 2) bound (N + 2) bound K
::=
nf('c : bool <- read ('Ctrb['n 'm 'k]), return (), 'c)
)
||
(family ('CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k)
bound (N + 2) bound (N + 2) bound K
::=
nf('c : bool <- read ('CtrbSum['n 'm 'k]), return (), 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return (), 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : bool <- read ('SendBit['n 'm 'k]), return (), 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('x : bool <- read ('Share['n 'k]), return (), 'x)
)
||
(family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('x : bool <- read ('Share[(N + 1) 'k]), return (), 'x)
)
 .
 
 op p0 : -> Protocol .
eq p0 =

newNF({('Ctrb[
    bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k) : bool} {('Ctrb-OK[bound (
    N + 2) bound (N + 2) bound K]) ('n 'm 'k) : unit} {('CtrbSum[bound (N + 2)
    bound (N + 2) bound K]) ('n 'm 'k) : bool} {('CtrbSum-OK[bound (N + 2)
    bound (N + 2) bound K]) ('n 'm 'k) : unit} {('In-OK[bound (N + 2)
    dependentBound 'I]) ('n 'i) : unit} {('InShare[bound (N + 2) bound (N + 2)
    dependentBound 'I]) ('n 'm 'i) : bool} {('InShare$[bound (N + 2) bound (N +
    2) dependentBound 'I]) ('m 'n 'i) : bool} {('InShare$-OK[bound (N + 2)
    bound (N + 2) dependentBound 'I]) ('m 'n 'i) : unit} {('InShare$-Sum[bound
    (N + 1) bound (N + 2) dependentBound 'I]) ('m 'n 'i) : bool} {(
    'InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I]) ('m 'n 'i)
    : unit} {('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]) ('m 'n
    'i) : unit} {('OutShare[bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k) :
    bool} {('OutShareSum[bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k) :
    bool} {('RcvdBit[bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k) : bool} {
    ('RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k) : unit} {(
    'SendBit[bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k) : bool} {(
    'SendBit-OK[bound (N + 2) bound (N + 2) bound K]) ('n 'm 'k) : unit} {(
    'Share[bound (N + 1) bound K]) ('n 'k) : bool} {('Share[fixedBound (N + 1)
    bound K]) ('n 'k) : bool} 
    {('ShareOK[bound (N + 1) bound K]) ('n 'k) : unit} 
    {('ShareOK[fixedBound (N + 1) bound K]) ('n 'k) : unit} 
    {('Wire-OK[bound K]) 'k : unit}, (family 'Adv[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family ('Ctrb ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm
    'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family ('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc,
    'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]
    'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return
    'oc, 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc,
    'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]
    'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return
    'oc, 'oc)
)
||
(family ('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
)
||
(family ('RcvdBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm
    'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb,
    'rb)
)
||
(family ('SendBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm
    'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb,
    'sb)
)
||
family ('Share ^^ 'party .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's, 's)
)
;;
(when (apply 'isNotGate 'k) -->
(family ('Ctrb ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm
    'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family ('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc,
    'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]
    'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return
    'oc, 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc,
    'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]
    'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return
    'oc, 'oc)
)
||
(family ('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
)
||
(family ('RcvdBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm
    'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb,
    'rb)
)
||
(family ('SendBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm
    'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb,
    'sb)
)
||
family ('Share ^^ 'party .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's, 's)
)
;;
(when (apply 'isXorGate 'k) -->
(family ('Ctrb ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family ('CtrbSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm
    'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b, 'b)
)
||
(family ('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc,
    'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]
    'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return
    'oc, 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc,
    'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]
    'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return
    'oc, 'oc)
)
||
(family ('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
)
||
(family ('RcvdBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm
    'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb,
    'rb)
)
||
(family ('SendBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm
    'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb,
    'sb)
)
||
family ('Share ^^ 'party .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's, 's)
)
;;
when (apply 'isAndGate 'k) -->
(family ('Ctrb ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Ctrb['n 'm 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)
||
(family ('CtrbSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm
    'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('CtrbSum['n 'm 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)
||
(family ('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), return 'x, 'x))
;;
when ((apply 'isHonest 'm) disj 'm <=T 'n) -->
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), return 'x, 'x))
;;
when ((apply 'isHonest 'm) disj 'm <=T 'n) -->
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc, 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 1) bound K
::=
(when ((apply 'isHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), return (), 'x))
;;
when ((apply 'isSemiHonest 'm) disj 'm <=T 'n) -->
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc,
    'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]
    'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
(when ('n <T N + 1) -->
nf('x : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)]), return (), 'x))
;;
when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return
    'oc, 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 1) bound K
::=
(when ((apply 'isHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), return (), 'x))
;;
when ((apply 'isSemiHonest 'm) disj 'm <=T 'n) -->
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc,
    'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]
    'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
(when ('n <T N + 1) -->
nf('x : unit <- read ('ShareOK[(N + 1) (fun 'wire1 'k)]), return (), 'x))
;;
when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return
    'oc, 'oc)
)
||
(family ('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun
    'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]), return 'b, 'b
    'x 'y))
;;
when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun
    'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap
    'xor pair('x, 'b)), 'b 'x 'y))
;;
when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun
    'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap
    'xor pair('y, 'b)), 'b 'x 'y))
;;
when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun
    'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap
    'xor pair(ap 'xor pair('x, 'y), 'b)), 'b 'x 'y))
;;
when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om, 'om)
)
||
(family ('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun
    'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]), return (), 'b
    'x 'y))
;;
when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun
    'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]), return (), 'b
    'x 'y))
;;
when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun
    'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]), return (), 'b
    'x 'y))
;;
when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun
    'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]), return (), 'b
    'x 'y))
;;
when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om,
    'om)
)
||
(family ('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'm) -->
nf('out : bool <- read ('RcvdBit['m 'n 'k]), return 'out, 'out))
;;
when (apply 'isHonest 'm) -->
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out, 'out)
)
||
(family ('RcvdBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm
    'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('RcvdBit['n 'm 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)
||
(family ('SendBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm
    'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)
||
family ('Share ^^ 'party .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's, 's)

)
||
(family 'In-OK[bound (N + 2) dependentBound 'I] 'n 'i
bound (N + 2) dependentBound 'I
::=
nf('in : bool <- read ('In['n 'i]), return (), 'in)
)
||
(family 'InShare[bound (N + 2) bound (N + 2) dependentBound 'I] 'n 'm 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
nf('in : bool <- read ('InShare$['n 'm 'i]), return 'in, 'in)
)
||
(family 'InShare$[bound (N + 2) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
(when ('m =T= N + 1) -->
nf(('s : bool <- read ('InShare$-Sum[N 'n 'i])) 'x : bool <- read ('In['n 'i]),
    return (ap 'xor pair('x, 's)), 'x 's))
;;
otherwise -->
nf('x : bool <- read ('In['n 'i]), samp ('flip < () >), 'x)
)
||
(family 'InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 1) bound (N + 2) dependentBound 'I
::=
(when (0 =T= 'm) -->
nf('in : bool <- read ('InShare$[0 'n 'i]), return 'in, 'in))
;;
otherwise -->
nf(('s : bool <- read ('InShare$-Sum[('m -- 1) 'n 'i])) 'x : bool <- read (
    'InShare$['m 'n 'i]), return (ap 'xor pair('s, 'x)), 's 'x)
)
||
(family 'InitOK[bound (N + 2) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
(family 'InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
nf('is : bool <- read ('InShare$['m 'n 'i]), return (), 'is)
)
||
(family 'InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 1) bound (N + 2) dependentBound 'I
::=
nf('is : bool <- read ('InShare$-Sum['m 'n 'i]), return (), 'is)
)
||
family 'InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
nf('is : bool <- read ('InShare['m 'n 'i]), return (), 'is)

)
||
(family 'Out[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K
::=
nf('s : bool <- read ('OutShareSum['n (N + 1) 'k]), return 's, 's)
)
||
(family 'OutShare[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isOutputWire 'k) -->
nf('s : bool <- read ('Share['m 'k]), return 's, 's))
;;
when neg (apply 'isOutputWire 'k) -->
nf('z : bool <- read ('OutShare['n 'm 'k]), return 'z, 'z)
)
||
(family 'OutShareSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('OutShare['n 0 'k]), return 's, 's))
;;
otherwise -->
nf(('s : bool <- read ('OutShareSum['n ('m -- 1) 'k])) 'x : bool <- read (
    'OutShare['n 'm 'k]), return (ap 'xor pair('s, 'x)), 's 'x)
)
||
(family 'Shares[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return
    'in, 'in)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)])) 'x
    : unit <- read ('InShareOK[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]),
    return 'in, 'x 'in)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's, 's)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('s : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)])) 'x : bool <- read (
    'Share[(N + 1) (fun 'wire0 'k)]), return (ap 'neg 'x), 's 'x)
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share[
    'n (fun 'wire1 'k)]), return (ap 'xor pair('x, 'y)), 'x 'y)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('a : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)])) ('b : unit <- read (
    'ShareOK[(N + 1) (fun 'wire1 'k)])) ('x : bool <- read ('Share[(N + 1) (fun
    'wire0 'k)])) 'y : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), return (
    ap 'xor pair('x, 'y)), 'a 'b 'x 'y)
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('r : bool <- read ('RcvdBit['m 'n 'k]), return 'r, 'r))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share[
    'n (fun 'wire1 'k)]), return (ap 'and pair('x, 'y)), 'x 'y))
;;
when ('m <T 'n) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b, 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m --
    1) 'k]), return (ap 'xor pair('s, 'b)), 's 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun
    'wire0 'k)])) ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool
    <- read ('Share['m (fun 'wire1 'k)])) 'yn : bool <- read ('Share['n (fun
    'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn), ap
    'and pair('xn, 'ym)), 'b)), 'b 'xm 'ym 'xn 'yn)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share[
    'n (fun 'wire1 'k)]), samp ('flip < () >), 'x 'y))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs, 'bs)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k])) 'x : unit <- read (
    'CtrbSum-OK[(N + 1) (N + 1) 'k]), return 'bs, 'x 'bs)

)
||
(family 'SharesOK[bound K] 'k
bound K
::=
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : bool <- read ('Ctrb['n 'm 'k]), return (), 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : bool <- read ('CtrbSum['n 'm 'k]), return (), 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return (), 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : bool <- read ('SendBit['n 'm 'k]), return (), 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('x : bool <- read ('Share['n 'k]), return (), 'x)
)
||
(family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('x : bool <- read ('Share[(N + 1) 'k]), return (), 'x)
)
)
||
(family 'Wires-OK[bound K] 'k
bound K
::=
family 'Wire-OK[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
nf('in : unit <- read ('In-OK[(fun 'wire0 'k) (fun 'wire1 'k)]), return 'in,
    'in))
;;
(when (apply 'isNotGate 'k) -->
nf('w : unit <- read ('Wire-OK[fun 'wire0 'k]), return (), 'w))
;;
(when (apply 'isXorGate 'k) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[
    fun 'wire1 'k]), return (), 'w0 'w1))
;;
when (apply 'isAndGate 'k) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[
    fun 'wire1 'k]), return (), 'w0 'w1)

)
||
(family ('In ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I] 'n 'i
bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('in : bool <- read ('In['n 'i]), return 'in, 'in))
;;
when (apply 'isHonest 'n) -->
nf('in : bool <- read (('In ^^ 'party .. 'adv)['n 'i]), return 'in, 'in)
)
||
(family ('InRcvd ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I] 'n 'i
bound (N + 2) dependentBound 'I
::=
(when (apply 'isHonest 'n) -->
nf('x : bool <- read ('In['n 'i]), return (), 'x))
;;
when (apply 'isSemiHonest 'n) -->
nf('in : unit <- read (('InRcvd ^^ 'party .. 'adv)['n 'i]), return 'in, 'in)
)
||
(family ('InShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) dependentBound
    'I] 'n 'm 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('InShare['n 'm 'i]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('InShare ^^ 'party .. 'adv)['n 'm 'i]), return 's, 's)
)
||
(family ('InShare$ ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2)
    dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in, 'in))
;;
when (apply 'isHonest 'n) -->
nf('in : bool <- read (('InShare$ ^^ 'party .. 'adv)['m 'n 'i]), return 'in,
    'in)
)
||
(family ('InShare$-Sum ^^ 'party .. 'adv)[bound (N + 1) bound (N + 2)
    dependentBound 'I] 'm 'n 'i
bound (N + 1) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('InShare$-Sum['m 'n 'i]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('InShare$-Sum ^^ 'party .. 'adv)['m 'n 'i]), return 's,
    's)
)
||
(family ('Out ^^ 'party .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Out['n 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Out ^^ 'party .. 'adv)['n 'k]), return 's, 's)
)
||
(family ('OutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n
    'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('OutShare['n 'm 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('OutShare ^^ 'party .. 'adv)['n 'm 'k]), return 's, 's)
)
||
(family ('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]
    'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('OutShareSum['n 'm 'k]), return 's, 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('OutShareSum ^^ 'party .. 'adv)['n 'm 'k]), return 's,
    's)
)
||
(family ('RcvdInShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2)
    dependentBound 'I] 'n 'm 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('in : bool <- read ('InShare$['n 'm 'i]), return 'in, 'in))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdInShare ^^ 'party .. 'adv)['n 'm 'i]), return 's,
    's)
)
||
(family ('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]
    'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['m 'k]), return 's, 's))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdOutShare ^^ 'party .. 'adv)['n 'm 'k]), return 's,
    's)
)
||
(family ('SendInShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2)
    dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in, 'in))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('SendInShare ^^ 'party .. 'adv)['m 'n 'i]), return 's,
    's)
)
||
family ('SendOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]
    'm 'n 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's, 's))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('SendOutShare ^^ 'party .. 'adv)['m 'n 'k]), return 's,
    's)
, fam ('Wire-OK[bound K]) fam ('In-OK[bound (N + 2) dependentBound 'I]) fam (
    'Share[bound (N + 1) bound K]) fam ('Share[fixedBound (N + 1) bound K]) fam
    ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]) fam (
    'InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I]) fam (
    'SendBit-OK[bound (N + 2) bound (N + 2) bound K]) fam ('RcvdBit-OK[bound (N
    + 2) bound (N + 2) bound K]) fam ('Ctrb-OK[bound (N + 2) bound (N + 2)
    bound K]) fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]) fam (
    'InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]) 
    fam ('ShareOK[bound (N + 1) bound K]) 
    fam ('ShareOK[fixedBound (N + 1) bound K]) 
    fam ('InShare[bound (N + 2) bound (N + 2)
    dependentBound 'I]) fam ('InShare$[bound (N + 2) bound (N + 2)
    dependentBound 'I]) fam ('InShare$-Sum[bound (N + 1) bound (N + 2)
    dependentBound 'I]) fam ('OutShare[bound (N + 2) bound (N + 2) bound K])
    fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]) fam ('SendBit[bound
    (N + 2) bound (N + 2) bound K]) fam ('RcvdBit[bound (N + 2) bound (N + 2)
    bound K]) fam ('Ctrb[bound (N + 2) bound (N + 2) bound K]) fam ('CtrbSum[
    bound (N + 2) bound (N + 2) bound K]))
    
.    
endm

smod EXECUTE is
 *** pr GMWN .
 pr PROTOCOLS .
 pr STRATS .
 
 var e1 e2 e3 e4 e5 e6 : Expression . 
 var Sigma Sigma' : Signature .
 var Delta Delta' : ChannelContext .
 var Gamma : TypeContext .
 var I O I' O' : Set{CNameBound} .
 var A : Set{BoolTerm} .
 var x y : Qid .
 var pConf pConf' : ProtocolConfig .
 var P P' : Protocol .
 var T : Type .
 var cn : ChannelName .
 var bounds : List{Bounds} .

*** xor & and are comm and assoc

 rl [comm-xor] : 
    ap 'xor pair(e1, e2) => ap 'xor pair(e2, e1) . 
    
 rl [return-comm-xor] : 
    return(ap 'xor pair(e1, e2)) => return (ap 'xor pair(e2, e1)) .
    
 strat applyReturnCommXor : CNameBound @ ProtocolConfig .
 sd applyReturnCommXor(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnCommXor(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-comm-xor}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-comm-xor}}
                      )
             )
 .     
 sd applyReturnCommXor(fam (cn[bounds])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnCommXor(fam (cn[bounds]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[bounds])), 
                             P1:Protocol <- keepOne P (fam (cn[bounds]))]{
               CONG-REACT-family{cong-nf{return-comm-xor}}
                             }
              or-else (CONG-REACT-family{cong-nf{return-comm-xor}}
                      )
             )
 .
 
 rl [comm-and] : 
    ap 'and pair(e1, e2) => ap 'and pair(e2, e1) . 
    
 rl [assoc-1-xor] :
    ap 'xor pair(e1, ap 'xor pair(e2, e3)) => 
    ap 'xor pair(ap 'xor pair(e1, e2), e3) .
    
 rl [assoc-2-xor] :
    ap 'xor pair(ap 'xor pair(e1, e2), e3) 
    => 
    ap 'xor pair(e1, ap 'xor pair(e2, e3)) 
    .   
    
 rl [assoc-1-and] :
    ap 'and pair(e1, ap 'and pair(e2, e3)) => 
    ap 'and pair(ap 'and pair(e1, e2), e3) .
    
 rl [assoc-2-and] :
    ap 'and pair(ap 'and pair(e1, e2), e3) 
    => 
    ap 'and pair(e1, ap 'and pair(e2, e3)) 
    .  
    
 ***( distrib TODO: if this breaks something, turn into a rule!
 eq ap 'and pair(ap 'xor pair(e1, e2), e3) =
    ap 'xor pair(ap 'and pair(e1, e3), ap 'and pair(e2, e3)) . 
 )   
    
 *** xor axioms
 eq ap 'xor pair(e1, e1) = False .
 eq ap 'xor pair(e1, False) = e1 .
 eq ap 'xor pair(False, e2) = e2 .
 
 *** neg axioms
 rl [neg-xor-1] : 
    ap 'neg e1 => ap 'xor pair(e1, True) .
    
 rl [neg-xor-2] : 
    ap 'xor pair(e1, True) => ap 'neg e1 .   
    
 *** and axioms   
 eq ap 'and pair(e1, True) = e1 .
 eq ap 'and pair(e1, False) = False .   
 eq ap 'and pair(True, e2) = e2 .
 eq ap 'and pair(False, e2) = False .
          
 *** flip
  rl [flip-invar-xor-r] : rConfig(Sigma, Delta, Gamma (x : bool),
            y : bool <- samp ('flip < () >) ; 
            return (ap 'xor pair(x, y)), I, A, bool
            )
            => 
            rConfig(Sigma, Delta , Gamma (x : bool),
            samp ('flip < () >), I, A, bool) . 
  
  *** neg over xor
  rl [neg-over-xor] :
    return (ap 'xor pair(e1, ap 'neg e2)) 
    =>
    return (ap 'neg (ap 'xor pair(e1, e2))) .
    
 strat applyReturnNegOverXor : CNameBound @ ProtocolConfig .
 sd applyReturnNegOverXor(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnNegOverXor(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{neg-over-xor}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{neg-over-xor}}
                      )
             )
 .  
            
  *** until we do expression equality we need this
   *** x = () if x : unit
 
 rl [return-unit] :
   rConfig(Sigma, Delta, Gamma (x : unit), return x, I, A, T)
   => 
   rConfig(Sigma, Delta, Gamma (x : unit), return (), I, A, T)
 .
 
 strat applyReturnUnit : CNameBound @ ProtocolConfig .
 sd applyReturnUnit(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnUnit(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-unit}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-unit}}
                      )
             )
 .
  sd applyReturnUnit(fam (cn[bounds])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnUnit(fam (cn[bounds]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[bounds])), 
                             P1:Protocol <- keepOne P (fam (cn[bounds]))]{
                             CONG-REACT-family{cong-nf{return-unit}}
                             }
              or-else (CONG-REACT-family{cong-nf{return-unit}}
                      )
             )
 .  
 
 rl [return-idem-rev] :
   return (ap 'xor pair(ap 'xor pair(e1, e2), e2) )
   => 
   return e1
 .
 
 strat applyReturnIdemRev : CNameBound @ ProtocolConfig .
 sd applyReturnIdemRev(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnIdemRev(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-idem-rev}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-idem-rev}}
                      )
             )
 .
  sd applyReturnIdemRev(fam (cn[bounds])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnIdemRev(fam (cn[bounds]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[bounds])), 
                             P1:Protocol <- keepOne P (fam (cn[bounds]))]{
                             CONG-REACT-family{cong-nf{return-idem-rev}}
                             }
              or-else (CONG-REACT-family{cong-nf{return-idem-rev}}
                      )
             )
 .  
 
 rl [return-idem] :
   return (ap 'xor pair(e1, ap 'xor pair(e1, e2)))
   => 
   return e2
 .
 
 strat applyReturnIdem : CNameBound @ ProtocolConfig .
 sd applyReturnIdem(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnIdem(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-idem}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-idem}}
                      )
             )
 .
  sd applyReturnIdem(fam (cn[bounds])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnIdem(fam (cn[bounds]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[bounds])), 
                             P1:Protocol <- keepOne P (fam (cn[bounds]))]{
                             CONG-REACT-family{cong-nf{return-idem}}
                             }
              or-else (CONG-REACT-family{cong-nf{return-idem}}
                      )
             )
 .  
 
  rl [return-idem-2] :
   return (ap 'xor pair(e1, ap 'xor pair(e2, e1)))
   => 
   return e2
 .
 
 strat applyReturnIdem2 : CNameBound @ ProtocolConfig .
 sd applyReturnIdem2(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnIdem(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-idem-2}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-idem-2}}
                      )
             )
 .
  sd applyReturnIdem2(fam (cn[bounds])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnIdem2(fam (cn[bounds]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[bounds])), 
                             P1:Protocol <- keepOne P (fam (cn[bounds]))]{
                             CONG-REACT-family{cong-nf{return-idem-2}}
                             }
              or-else (CONG-REACT-family{cong-nf{return-idem-2}}
                      )
             )
 .  
 
  rl [rearrange-xor] :
   return (ap 'xor pair(
              ap 'xor pair(e1, e2)
            , ap 'xor pair(e3, e4)
            )
          )
   => 
   return (ap 'xor pair(
              ap 'xor pair(e1, e3)
            , ap 'xor pair(e2, e4)
            )
          )
 .
 
 strat applyRearrangeXor : CNameBound @ ProtocolConfig .
 sd applyRearrangeXor(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyRearrangeXor(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{rearrange-xor}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{rearrange-xor}}
                      )
             )
 .
 
  rl [middle-xor] :
   return (ap 'xor pair(
              ap 'xor pair(e1, e2)
            , ap 'xor pair(e3, e4)
            )
          )
   => 
   return (ap 'xor pair( 
              ap 'xor pair(e1, ap 'xor pair(e2, e3))
            , e4
            )
          )
 .
 
 strat applyMiddleXor : CNameBound @ ProtocolConfig .
 sd applyMiddleXor(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyMiddleXor(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{middle-xor}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{middle-xor}}
                      )
             )
 .
  
 *** a derived rule, distributivity twice
 
 rl [derived-xor-and-rule] :
    return (
    ap 'xor 
       pair(
         ap 'xor pair(ap 'and pair(e1, e2), 
                      ap 'and pair(e3, e2)),
         ap 'xor pair(ap 'and pair(e4, e5), 
                      ap 'and pair(e4, e6))             
       ) 
    ) 
    =>
    return (
     ap 'xor 
        pair(
        ap 'and pair(ap 'xor pair(e1, e3), e2),
        ap 'and pair(e4, ap 'xor pair(e5, e6))
        )
    )    
 .   
  
 strat applyDerivedXorAndRule : CNameBound @ ProtocolConfig .
 sd applyDerivedXorAndRule(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDerivedXorAndRule(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{derived-xor-and-rule}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{derived-xor-and-rule}}
                      )
             )
 .        
 
  *** another derived rule based on assoc
 rl [derived-xor-rule] :
    return (
    ap 'xor 
       pair(
         ap 'xor pair(e1, 
                      ap 'xor pair(e2, e3)),
         e4           
       ) 
    ) 
    =>
    return (
     ap 'xor 
        pair(
        ap 'xor pair(e1, e2),
        ap 'xor pair(e3, e4)
        )
    )    
 .   
  
 strat applyDerivedXorRule : CNameBound @ ProtocolConfig .
 sd applyDerivedXorRule(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDerivedXorRule(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{derived-xor-rule}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{derived-xor-rule}}
                      )
             )
 . 
 
 rl [distrib-twice]:
 return (
   ap 'and pair(ap 'xor pair(e1, e2),
                ap 'xor pair(e3, e4)
               )
 )
 =>
 return (
  ap 'xor 
   pair(
     ap 'xor pair(ap 'and pair(e1, e3), ap 'and pair(e1, e4)),
     ap 'xor pair(ap 'and pair(e2, e3), ap 'and pair(e2, e4))
   )
 )
 .
 
 strat applyDistribTwice : CNameBound @ ProtocolConfig .
 sd applyDistribTwice(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDistribTwice(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{distrib-twice}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{distrib-twice}}
                      )
             )
 . 
  
  *** SYM strategies
 *** because only there we have access to current protocol
 
 *** sym strategies for extracting the protocol
 
 strat symWireOSS @ ProtocolConfig .
 sd symWireOSS :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
        with 
         (when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf('out : bool <- read ('Out['n 'k]), return 'out, 'out))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('OutShareSum ^^ 'party .. 'adv)['n (N + 1) 'k]), return 's, 's)
        in P
       ] 
       { CONG-NEW-NF{ select-branch-family-r[
    fns:NameWithScripts <- 'OutShareSum ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{ 
    substNFFamiliesGen(     
     fam ('Out [bound (N + 2) bound K]),
     fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]),
     nf('w : bool <- read ('Wire['k]), return 'w, 'w)
    )
 
   }
   }
 }
.  

 strat symWireOS @ ProtocolConfig .
 sd symWireOS :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
        with 
         (when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf(('out : bool <- read ('Out['n 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor pair('xs,
    'out)), 'xs 'out))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('OutShare ^^ 'party .. 'adv)['n (N + 1) 'k]), return 's, 's)

        in P
       ] 
       
       { CONG-NEW-NF{ select-branch-family-r[
    fns:NameWithScripts <- 'OutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{ 
    substNFFamiliesGen(     
     fam ('Out [bound (N + 2) bound K]),
     fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]),
     nf('w : bool <- read ('Wire['k]), return 'w, 'w)
    )
    
   }
   }
  }
 
.    

strat symWireROS @ ProtocolConfig .
 sd symWireROS :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
        with 
         (when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf(('out : bool <- read ('Out['n 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor pair('xs,
    'out)), 'xs 'out))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdOutShare ^^ 'party .. 'adv)['n (N + 1) 'k]), return 's, 's)

        in P
       ] 
       
       { CONG-NEW-NF{ select-branch-family-r[
    fns:NameWithScripts <- 'RcvdOutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{ 
    substNFFamiliesGen(     
     fam ('Out [bound (N + 2) bound K]),
     fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]),
     nf('w : bool <- read ('Wire['k]), return 'w, 'w)
    )
    
   }
   }
  }
 
.                    
  
 ***********************************************
 
 strat indSharedOK @ ProtocolConfig .
 sd indSharedOK :=
 CONG-NEW-NF{ 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
    CONG-COMP-RIGHT[
        Q:Protocol  <- 
         removeTwo P 
          (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I]))
          (fam ('Comp['Shares 'SharesOK][bound K])), 
        P1:Protocol <- 
          keepTwo P 
           (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
           (fam ('Comp['Shares 'SharesOK][bound K]))                      
        ]
        {
 matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
 SINGLE-INDUCTION-new[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- 'Comp['Shares 'SharesOK],
  blist:List{Bounds} <- bound K,
  P2:Protocol <- know0
 ]{ setIndConfSymProof
 }
 }      
 }
 .
 
 
 strat inIndSym1 @ ProtocolConfig .
 sd inIndSym1 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareOK[(N + 1) 'B])
        with
         nf('x : bool <- read ('Share[(N + 1) 'B]), return (), 'x)
        in P
       ]
       {
        substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B]) 
       ; substNFFamilyOne(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              'ShareOK[(N + 1) 'B],
              nf('is : bool <- read ('InShare[(N + 1) (fun 'wire0 'B) (fun 'wire1 'B)]), 
                 return (), 'is)
              )
       ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                         << 'in, 'is >> emptyQidPairList)        
       } 
       
 .
 
 strat inIndSym2 @ ProtocolConfig .
 sd inIndSym2 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
        with
         nf('x : bool <- read ('Share['n 'B]), return (), 'x)

        in P
       ]
       {
         substNFFamiliesGen(
             fam ('Share[bound (N + 1) fixedBound 'B]),
             fam ('ShareOK[bound (N + 1) fixedBound 'B]), 
             nf('in : bool <- read ('InShare['n (fun 'wire0 'B) (fun 'wire1 'B)]), 
                return 'in, 'in)
            )
       }          
 .
 
 strat inIndSym3 @ ProtocolConfig .
 sd inIndSym3 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       
       P1:Protocol <- change 
        chn ('ShareOK[(N + 1) 'B])
        with
         nf('x : bool <- read ('Share[(N + 1) 'B]), return (), 'x)
        in P
       ]
       {
        substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B])
       ;
           use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { 
             substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B],
              nf('x : bool <- read ('Share[(N + 1) (fun 'wire0 'B)]), return (), 'x)
              )   
           } 
        }   
 .  
 
 strat inIndSym4 @ ProtocolConfig .
 sd inIndSym4 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
        with
         nf('x : bool <- read ('Share['n 'B]), return (), 'x)

        in P
       ]
       {
       substNFFamiliesGen(
             fam ('Share[bound (N + 1) fixedBound 'B]),
             fam ('ShareOK[bound (N + 1) fixedBound 'B]), 
             nf('s : bool <- read ('Share['n (fun 'wire0 'B)]), return 's, 's)
            )
      ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 's, 'x >> emptyQidPairList)      
      }    
             
 .  
 
 strat inIndSym5 @ ProtocolConfig .
 sd inIndSym5 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareOK[(N + 1) 'B])
        with
         nf('x : bool <- read ('Share[(N + 1) 'B]), return (), 'x)
        in P
       ]
       {
        substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B])
       ;
           use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { 
             substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B],
              nf('x : bool <- read ('Share[(N + 1) (fun 'wire0 'B)]), return (), 'x)
              )   
              ;  applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                 << 'x, 'a >> emptyQidPairList) 
              ; substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B],
              nf('x : bool <- read ('Share[(N + 1) (fun 'wire1 'B)]), return (), 'x)
              )   
              ;  applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)  
              ; changeOrder(chn ('ShareOK[(N + 1) 'B]), 'x 'y)    
           } 
        }  
 .  
 
 strat inIndSym6 @ ProtocolConfig .
 sd inIndSym6 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
        with
         nf('x : bool <- read ('Share['n 'B]), return (), 'x)

        in P
       ]
       {
       substNFFamiliesGen(
             fam ('Share[bound (N + 1) fixedBound 'B]),
             fam ('ShareOK[bound (N + 1) fixedBound 'B]), 
             nf(('x : bool <- read ('Share['n (fun 'wire0 'B)])) 
                 'y : bool <- read ('Share['n (fun 'wire1 'B)]),
                 return (ap 'xor pair('x, 'y)), 'x 'y)
            )
       ; changeOrder(fam ('ShareOK[bound (N + 1) fixedBound 'B]), 'x 'y)        
       }
                     
 .   
 
 strat inIndSym7 @ ProtocolConfig .
 sd inIndSym7 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
        with
         nf('s : bool <- read ('SendBit['n 'm 'B]), return (), 's)
        in P
       ]
       {
       (matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
       SYM[
       Delta1:ChannelContext <- Delta',
       O1:Set{CNameBound} <- O',
       P1:Protocol <- change 
        fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
        with
         (when ('n <T 'm) --> 
           nf('s : bool <- read ('SendBit['n 'm 'B]), return (), 's)
         )
         ;;
         (when ('m <=T 'n) --> 
           nf('s : bool <- read ('SendBit['n 'm 'B]), return (), 's)
         )
        in P'
       ] 
        {
        applyAllSameCases(
           fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]) 
        )
        }
       )
       ;
       CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'SendBit-OK,
           blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]
       {
           *** for 'n <T 'm 
           select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]{
           select-case-family-r[
           fns1:NameWithScripts <- 'SendBit,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'n <T 'm]{
           applyDropSubsumeRevFamilies(
             fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
           )
           }
           }
           ,
           *** for 'm <=T 'n
            CASE-DISTINCTION-one-R-end-when[
           fns:NameWithScripts <- 'SendBit-OK,
           blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{     
select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]
{ 
select-case-family-r[
           fns1:NameWithScripts <- 'SendBit,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'm <=T 'n]{
   applySubstDivergeFamily(
     fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     'sb, unit)           
           } 
           }
           }
       } 
   }    
 .  
 
 strat inIndSym8 @ ProtocolConfig .
 sd inIndSym8 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
        with
         nf('r : bool <- read ('RcvdBit['n 'm 'B]), return (), 'r)

        in P
       ]
       {
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]
{ 
       substNFFamiliesGen(
             fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             nf(('b : bool <- read ('SendBit['m 'n 'B])) 
                ('xm : bool <- read ('Share['m (fun 'wire0 'B)])) 
                ('xn : bool <- read ('Share['n (fun 'wire0 'B)])) 
                ('ym : bool <- read ('Share['m (fun 'wire1 'B)])) 
                 'yn : bool <- read ('Share['n (fun 'wire1 'B)]), 
                 return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn), 
                                      ap 'and pair('xn, 'ym)), 'b)), 
                'b 'xm 'ym 'xn 'yn)
            )
            
}       
  }    
                     
 .  
 
 strat inIndSym9 @ ProtocolConfig .
 sd inIndSym9 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       
       P1:Protocol <- change 
        fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
        with
         nf('c : bool <- read ('Ctrb['n 'm 'B]), return (), 'c)

        in P
       ] 
       {
       (matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
       SYM[
       Delta1:ChannelContext <- Delta',
       O1:Set{CNameBound} <- O',
       P1:Protocol <- change 
        fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
        with
         (when ('n <T 'm) --> 
          nf('c : bool <- read ('Ctrb['n 'm 'B]), return (), 'c)
         )
         ;;
         (when ('m <T 'n) --> 
           nf('c : bool <- read ('Ctrb['n 'm 'B]), return (), 'c)
         )
         ;;
         (when ('m =T= 'n) --> 
           nf('c : bool <- read ('Ctrb['n 'm 'B]), return (), 'c)
         )
        in P'
       ] 
        {
        applyAllSameCases(
           fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]) 
        )
        }
       )
       ; CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'Ctrb-OK,
           blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]
       { *** for 'n <T 'm 
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]{
           select-case-family-r[
           fns1:NameWithScripts <- 'Ctrb,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'n <T 'm]{
           substNFFamiliesGen(
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             nf('s : bool <- read ('SendBit['n 'm 'B]), return 's, 's)
            )
           }
           
           }
           
       , 
        CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'Ctrb-OK,
           blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]
       { *** for 'm <T 'n 
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]{
           select-case-family-r[
           fns1:NameWithScripts <- 'Ctrb,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'm <T 'n]{
           substNFFamiliesGen(
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             nf('r : bool <- read ('RcvdBit['n 'm 'B]), return 'r, 'r)
            )
           }
           
           }
           
       , CASE-DISTINCTION-one-R-end-when[
           fns:NameWithScripts <- 'Ctrb-OK,
           blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]
        { select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]{
           select-case-family-r[
           fns1:NameWithScripts <- 'Ctrb,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'm =T= 'n]{
           substNFFamiliesGen(
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             nf(('x : bool <- read ('Share['n (fun 'wire0 'B)])) 
                 'y : bool <- read ('Share['n (fun 'wire1 'B)]), 
                 return (ap 'and pair('x, 'y)), 'x 'y)
            )
          }
         }
       }
       
       }
       }
 }    
 . 
 
 strat inIndSym10 @ ProtocolConfig .
 sd inIndSym10 :=
  SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'CtrbSum-OK,
  blist:List{Bounds} <- bound (N + 2) bound (N + 2) fixedBound 'B,
  cases':Cases <- 
   nf('c : bool <- read ('CtrbSum['n 'm 'B]), return (), 'c)
 ]
 {
 CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'CtrbSum-OK,
           blist:List{Bounds} <- (bound (N + 2) fixedBound 'M fixedBound 'B)
           ]{
           *** for m = 0
           substNFFamiliesGen(
             fam ('Ctrb-OK[(bound (N + 2))(bound (N + 2))(fixedBound 'B)]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
             nf('c : bool <- read ('Ctrb['n 0 'B]), return (), 'c)
            ) 
           ; inIndSym13    
            , 
           *** for m =/= 0
           CASE-DISTINCTION-one-R-end-when[
           fns:NameWithScripts <- 'CtrbSum-OK,
           blist:List{Bounds} <- (bound (N + 2) fixedBound 'M fixedBound 'B)
           ]{
           substNFFamiliesGen(
             fam ('Ctrb-OK[(bound (N + 2))(bound (N + 2))(fixedBound 'B)]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
             nf('c : bool <- read ('Ctrb['n 'M 'B]), return (), 'c)
            ) 
            ; applyAlphaNFPr(fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
                 << 'c, 'b >> emptyQidPairList)    
            ; 
            substNFFamiliesGen(
             fam ('CtrbSum-OK[bound (N + 2) bound 'M fixedBound 'B]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
               nf('c : bool <- read ('CtrbSum['n ('M -- 1) 'B]), return (), 'c)
            )
            ; applyAlphaNFPr(fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
                 << 'c, 's >> emptyQidPairList)
            ; inIndSym14     
            }
           } 
           ; applyAllSameCases(
           fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]) 
           )
 }
 ***(
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       UNSAFE[
       Delta':ChannelContext <- Delta,
       O':Set{CNameBound} <- O,
       I':Set{CNameBound} <- I,
       A':Set{BoolTerm} <- A,
       P1:Protocol <- change 
        fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
        with
         nf('c : bool <- read ('CtrbSum['n 'm 'B]), return (), 'c)

        in P
       ] 
  )     
 .   
 
 strat inIndSym11 @ ProtocolConfig .
 sd inIndSym11 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       
       P1:Protocol <- change 
        fam ('ShareOK[bound (N + 1) fixedBound 'B])
        with
         nf('x : bool <- read ('Share['n 'B]), return (), 'x)

        in P
       ]
 {
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]
{ 
         substNFFamiliesGen(
             fam ('Share[bound (N + 1) fixedBound 'B]),
             fam ('ShareOK[bound (N + 1) fixedBound 'B]), 
             nf('bs : bool <- read ('CtrbSum['n (N + 1) 'B]), return 'bs, 'bs)
            )
       ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 'bs, 'c >> emptyQidPairList)       
         
}       
}    
                        
 .  
 
 strat inIndSym12 @ ProtocolConfig .
 sd inIndSym12 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       
       P1:Protocol <- change 
        chn ('ShareOK[(N + 1) 'B])
        with
         nf('x : bool <- read ('Share[(N + 1) 'B]), return (), 'x)
        in P
       ]
       {
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]{
       substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B])
       }
       ; substNFFamilyOne(
              fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              'ShareOK[(N + 1) 'B],
              nf('c : bool <- read ('CtrbSum[(N + 1) (N + 1) 'B]), return (), 'c)
              ) 
       ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                 << 'bs, 'c >> emptyQidPairList)   
     }      
  .  
    
    
 strat inIndSym13 @ ProtocolConfig .
 sd inIndSym13 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
             with 
              nf('c : bool <- read ('CtrbSum['n 'M 'B]), return (), 'c)
             in P
            ]
       { select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]{
         substNFFamiliesGen(
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
             nf('b : bool <- read ('Ctrb['n 0 'B]), return 'b, 'b)
            )
          }  
       ; applyAlphaNFPr(fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
                 << 'b, 'c >> emptyQidPairList)          
       }
 . 
 
 strat inIndSym14 @ ProtocolConfig .
 sd inIndSym14 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
             with 
              nf('c : bool <- read ('CtrbSum['n 'M 'B]), return (), 'c)
             in P
            ]
       { select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]{
       substNFFamiliesGen(
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
             nf(('b : bool <- read ('Ctrb['n 'M 'B])) 
                 's : bool <- read ('CtrbSum['n ('M -- 1) 'B]), 
                 return (ap 'xor pair('s, 'b)), 's 'b)
            ) }
       }     
 .                        
 
 strat sym1 @ ProtocolConfig .
 sd sym1 := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{sym1} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change (fam ('RcvdBit[((bound (N + 2)) (bound (N + 2))(bound K) )]))
        with ( (when ('m <T 'n) -->

           nf(('b : bool <- read ('SendBit['m 'n 'k])) 
    ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) 
    ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) 
    ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 
     'yn : bool <- read ('Share['n (fun 'wire1 'k)]),  
           return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn),
                                             ap 'and pair('xn, 'ym)), 
                           'b)),
           'b 'xm 'ym 'xn 'yn)
 )          
  ;;  
 (
 when ('n <=T 'm) -->
   nf('z : bool <- read ('RcvdBit['n 'm 'k]), return 'z, 'z)
 )         
 )
        in P
       ]
       {auxSym1}
       )
 .
 
 strat auxSym1 @ ProtocolConfig .
 sd auxSym1 := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{auxSym1} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
        CONG-COMP-RIGHT[
         Q:Protocol  <- removeOne P (fam ('RcvdBit[((bound (N + 2)) (bound (N + 2))(bound K) )])), 
         P1:Protocol <- keepOne P (fam ('RcvdBit[((bound (N + 2)) (bound (N + 2))(bound K) )]))]{ 
        CONG-FAMILY-WHENLIST-R[bt:BoolTerm <- ('m <T 'n),
     R2:Reaction <- 
     nf(('b : bool <- read ('SendBit['m 'n 'k])) 
    ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) 
    ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) 
    ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 
     'yn : bool <- read ('Share['n (fun 'wire1 'k)]),  
           if 'xn then 
          if 'yn then return (ap 'xor pair(ap 'xor pair('xm, 'ym), 'b)) 
                 else return (ap 'xor pair('ym, 'b)) 
               else 
          if 'yn then return (ap 'xor pair('xm, 'b)) 
                 else return 'b,
           'b 'xm 'ym 'xn 'yn)]{ 
           
    cong-nf[R2:Reaction <- 
   
        if 'xn then 
          if 'yn then return (ap 'xor pair(ap 'xor pair('xm, 'ym), 'b)) 
                 else return (ap 'xor pair('ym, 'b)) 
               else 
          if 'yn then return (ap 'xor pair('xm, 'b)) 
                 else return 'b
     ]{
        if-intro-ext[q:Qid <- 'yn] ; 
        if-intro-ext[q:Qid <- 'xn]
       } *** cong-nf
       
       
       } *** cong-whenlist
       
       
       
        } *** cong-comp
       )
  .  
  
   strat sym2 @ ProtocolConfig .
 sd sym2 := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{sym2} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        *** was P
        change (fam ('RcvdBit[((bound (N + 2)) (bound (N + 2))(bound K) )]))
        with ( (when ('m <T 'n) -->

           nf(('b : bool <- read ('SendBit['m 'n 'k])) 
    ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) 
    ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) 
    ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 
     'yn : bool <- read ('Share['n (fun 'wire1 'k)]),  
           return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn),
                                             ap 'and pair('xn, 'ym)), 
                           'b)),
           'b 'xm 'ym 'xn 'yn)
 )          
  ;;  
 (
 when ('n <=T 'm) -->
    nf(('b : bool <- read ('SendBit['m 'n 'k])) 
    ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) 
    ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) 
    ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 
     'yn : bool <- read ('Share['n (fun 'wire1 'k)]),  
           return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn),
                                             ap 'and pair('xn, 'ym)), 
                           'b)),
           'b 'xm 'ym 'xn 'yn)
 )         
 )
        in P
       ]{
          auxSym2
        } ***sym
       )
 .
 
 strat auxSym2 @ ProtocolConfig .
 sd auxSym2 := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{auxSym2} 
     : select-branch-family-r[fns:NameWithScripts <- 'RcvdBit,
                              bt:BoolTerm <- ('n <=T 'm)]{
       matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
        CONG-COMP-RIGHT[
          Q:Protocol  <- removeTwo P 
                          (fam ('RcvdBit[((bound (N + 2)) (bound (N + 2))(bound K) )])) 
                          (fam ('SendBit[((bound (N + 2)) (bound (N + 2))(bound K) )])), 
          P1:Protocol <- keepTwo P 
                          (fam ('RcvdBit[((bound (N + 2)) (bound (N + 2))(bound K) )])) 
                          (fam ('SendBit[((bound (N + 2)) (bound (N + 2))(bound K) )]))
                       ]{
              ***    idle
               applySelectCaseDiverge( 
                (fam ('SendBit[((bound (N + 2)) (bound (N + 2))(bound K) )])), 
                (fam ('RcvdBit[((bound (N + 2)) (bound (N + 2))(bound K) )])), 
                ('n <=T 'm), 'z, bool)         
                       }
             )          
       }                
             
     .   

     
 strat slowSym @ ProtocolConfig .
 sd slowSym := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- pInt0]
       {   
               sugar-newNF
     
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
               
       ; applyNewCombine(fam ('Adv[bound K]))
       ; applyNewCombine(fam ('Shares[bound K]))
       ; applyNewCombine(fam ('1OutOf4OT[bound K]))
         
       ; reorder-newNF[ql2:List{CNameBound} <- 
         fam ('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]) 
fam ('Share[bound (N + 2) bound K])
 fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]) 
 fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]) 
 fam ('SendOutShare[bound (N + 2) bound (N + 2) bound K]) 
 fam ('OutShare[bound (N + 2) bound (N + 2) bound K]) 
 fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]) 
 fam ('OTMsg-0[bound (N + 2) bound (N + 2) bound K]) 
 fam ('OTMsg-1[bound (N + 2) bound (N + 2) bound K]) 
 fam ('OTMsg-2[bound (N + 2) bound (N + 2) bound K]) 
 fam ('OTMsg-3[bound (N + 2) bound (N + 2) bound K]) 
 fam ('OTChc-0[bound (N + 2) bound (N + 2) bound K]) 
 fam ('OTChc-1[bound (N + 2) bound (N + 2) bound K]) 
 fam ('OTOut[bound (N + 2) bound (N + 2) bound K]) 
 fam ('SendBit[bound (N + 2) bound (N + 2) bound K]) 
 fam ('RcvdBit[bound (N + 2) bound (N + 2) bound K]) 
 fam ('Ctrb[bound (N + 2) bound (N + 2) bound K]) 
 fam ('CtrbSum[bound (N + 2) bound (N + 2) bound K])
         
         ]
         }
         .     
     
 strat sym3 @ ProtocolConfig .
 sd sym3 := 
    *** match pConf s.t. startsWithNew pConf
    ***  ? CONG-NEW-NF{sym3} 
    ***  : 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'InShareOK
         typed unit
         params ('m 'n 'i)
                ((bound (N + 2))(bound (N + 2))(dependentBound 'I))  
         assigned
          nf('is : bool  <- read ('InShare['m 'n 'i]),
             return (), 'is)
         in (
         addInternalFamily
           'ShareOK
         typed unit
         params ('n 'k)
                ((bound (N + 2))(bound K))  
         assigned
          nf('x : bool  <- read ('Share['n 'k]),
             return (), 'x)
         in P
         )        
       ]{
          absorbFamily(fam ('ShareOK[((bound (N + 2))(bound K))]))
        ; absorbFamily(fam ('InShareOK[((bound (N + 2))(bound (N + 2))(dependentBound 'I))]))
        } ***sym
       )
 .   
 
 strat sym4 @ ProtocolConfig .
 sd sym4 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         change 
         (
         fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (fixedBound (N + 1)) (bound K)])
         )
         with
         (
         (when ('n <T N + 1) -->
nf('x : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)]), return (), 'x)
)
;;
(when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc, 'oc)
) 
         )
         in 
         (
         change 
         (
         fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (fixedBound (N + 1)) (bound K)])
         )
         with
         (
         (when ('n <T N + 1) -->
nf('x : unit <- read ('ShareOK[(N + 1) (fun 'wire1 'k)]), return (), 'x)
)
;;
(when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc, 'oc)
) 
         )
         in
         P )
       ]{
          applySubstFamilyGenCase(
  fam ('ShareOK[(bound (N + 2)) (bound K)]),
 fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (fixedBound (N + 1)) (bound K)]),
 nf('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)]), return (), 'x), 
 nf('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)]), return (), 'x), 
 ('n <T N + 1)
 ) 
 ; 
 applySubstFamilyGenCase(
  fam ('ShareOK[(bound (N + 2)) (bound K)]),
 fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (fixedBound (N + 1)) (bound K)]),
 nf('x : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), return (), 'x), 
 nf('x : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), return (), 'x), 
 ('n <T N + 1)
 )
        } ***sym
       )
 .  
 
 strat sym5 @ ProtocolConfig .
 sd sym5 := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'InShare$-OK
         typed unit
         params ('m 'n 'i)
                ((bound (N + 2))(bound (N + 2))(dependentBound 'I))  
         assigned
          nf('is : bool  <- read ('InShare$['m 'n 'i]),
             return (), 'is)
         in (
         addInternalFamily
           'InShare$Sum-OK
         typed unit
         params ('m 'n 'i)
                ((bound (N + 1))(bound (N + 2))(dependentBound 'I))  
         assigned
          nf('is : bool  <- read ('InShare$-Sum['m 'n 'i]),
             return (), 'is)
         in (  
         addInternalFamily
           'SendBit-OK
         typed unit
         params ('n 'm 'k)
                ((bound (N + 2))(bound (N + 2))(bound K))  
         assigned
          nf('s : bool  <- read ('SendBit['n 'm 'k]),
             return (), 's)
         in (  
         addInternalFamily
           'RcvdBit-OK
         typed unit
         params ('n 'm 'k)
                ((bound (N + 2))(bound (N + 2))(bound K)) 
         assigned
          nf('r : bool  <- read ('RcvdBit['n 'm 'k]),
             return (), 'r)
         in (  
         addInternalFamily
           'Ctrb-OK
         typed unit
         params ('n 'm 'k)
                ((bound (N + 2))(bound (N + 2))(bound K)) 
         assigned
          nf('c : bool  <- read ('Ctrb['n 'm 'k]),
             return (), 'c)
         in (   
         addInternalFamily
           'CtrbSum-OK
         typed unit
         params ('n 'm 'k)
                ((bound (N + 2))(bound (N + 2))(bound K)) 
         assigned
          nf('c : bool  <- read ('CtrbSum['n 'm 'k]),
             return (), 'c)
         in P
         )))))       
       ]{
          absorbFamily(
            fam ('InShare$Sum-OK[((bound (N + 1))(bound (N + 2))(dependentBound 'I))])
          )
        ; absorbFamily(
            fam ('InShare$-OK[((bound (N + 2))(bound (N + 2))(dependentBound 'I))])
          )
        ; absorbFamily(fam ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
        ; absorbFamily(fam ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
        ; absorbFamily(fam ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
        ; absorbFamily(fam ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
        } ***sym
       )
 .  
 
 strat sym6 @ ProtocolConfig .
 sd sym6 := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           (fam ('InShareOK[((bound (N + 2))(bound (N + 2))(dependentBound 'I))]))
           (fam ('InShare$-OK[((bound (N + 2))(bound (N + 2))(dependentBound 'I))]))
           (fam ('InShare$Sum-OK[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]))
         named 'InitOK 
         params ('m 'n 'i) ((bound (N + 2))(bound (N + 2))(dependentBound 'I))
         in P
       ]
       {
        applyDropName(fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)])
        )
       } ***sym
       )
 . 
 
 strat sym7 @ ProtocolConfig .
 sd sym7 := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           (fam ('ShareOK[(bound (N + 2)) (bound K)]))
           (fam ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
           (fam ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
           (fam ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
           (fam ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
         named 'SharesOK 
         params 'k (bound K)
         in P
       ]
       {
        applyDropName(fam ('SharesOK[bound K]) ) 
       } ***sym
       )
 .
 
 strat sym8 @ ProtocolConfig .
 sd sym8 := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ( 
        applyDropName(fam ('SharesOK[bound K]) )
      ; applyDropName(fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)]))  
 
      ; SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
        P1:Protocol <- 
         branch
           (when (apply 'isInputGate 'k)) 
         of 
         (fam ('Shares[bound K]) ) 
         change 
          (fam ('Share[(fixedBound (N + 1)) (bound K)]) )
         with 
          nf(('x : unit <- read ('InShareOK[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]))
             'in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]),  
             return 'in, 'x 'in)
         in 
         (branch
           (when (apply 'isNotGate 'k)) 
         of 
         (fam ('Shares[bound K]) ) 
         change 
          (fam ('Share[(fixedBound (N + 1)) (bound K)]) )
         with 
          nf( ('s : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)]))
              'x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)]), return (ap 'neg 'x), 's 'x)

         in 
         ( (branch
           (when (apply 'isXorGate 'k)) 
         of 
         (fam ('Shares[bound K]) ) 
         change 
          (fam ('Share[(fixedBound (N + 1)) (bound K)]) )
         with 
          nf( ('a : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)]))
              ('b : unit <- read ('ShareOK[(N + 1) (fun 'wire1 'k)]))
              ('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 
               'y : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), 
              return (ap 'xor pair('x, 'y)), 'a 'b 'x 'y)
         in 
          (branch
           (when (apply 'isAndGate 'k)) 
         of 
         (fam ('Shares[bound K]) ) 
         change 
          (fam ('Share[(fixedBound (N + 1)) (bound K)]) )
         with 
          nf(('x : unit <- read ('CtrbSum-OK[(N + 1) (N + 1) 'k]))
              'bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k]), return 'bs, 'x 'bs)
         in P
          ) ) ) )
       ]{
        applyDropName(fam ('SharesOK[bound K]) )
      ; applyDropName(fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)]))  
      ; select-branch-family-p[fns:NameWithScripts <- 'Shares,
                               bt:BoolTerm <- apply 'isInputGate 'k]
         {
          substNFFamiliesGen(
            fam ('InShareOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)]), 
            fam ('Share[(fixedBound (N + 1)) (bound K)]), 
            nf('is : bool  <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]),
             return (), 'is)
          )
         }
      ; select-branch-family-p[fns:NameWithScripts <- 'Shares,
                               bt:BoolTerm <- apply 'isNotGate 'k]
         {
          substNFFamiliesGen(
            fam ('ShareOK[(bound (N + 2)) (bound K)]), 
            fam ('Share[(fixedBound (N + 1)) (bound K)]), 
            nf('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)]), return (), 'x)
          )
         }
      ; select-branch-family-p[fns:NameWithScripts <- 'Shares,
                               bt:BoolTerm <- apply 'isXorGate 'k]
         {
          substNFFamiliesGen(
            fam ('ShareOK[(bound (N + 2)) (bound K)]), 
            fam ('Share[(fixedBound (N + 1)) (bound K)]), 
            nf('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)]), return (), 'x)
          )
         ; applyAlphaNFPr(
            fam ('Share[(fixedBound (N + 1)) (bound K)]), 
            << 'x, 'inA >> emptyQidPairList)
         ; substNFFamiliesGen(
            fam ('ShareOK[(bound (N + 2)) (bound K)]), 
            fam ('Share[(fixedBound (N + 1)) (bound K)]), 
            nf('x : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), return (), 'x)
          )  
         ; applyAlphaNFPr(
            fam ('Share[(fixedBound (N + 1)) (bound K)]), 
            << 'x, 'y >> << 'inA, 'x >> emptyQidPairList) 
         ; changeOrder(fam ('Share[(fixedBound (N + 1)) (bound K)]), 'x 'y)    
         }   
         ; select-branch-family-p[fns:NameWithScripts <- 'Shares,
                               bt:BoolTerm <- apply 'isAndGate 'k]
         {
          substNFFamiliesGen(
            fam ('CtrbSum-OK[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
            fam ('Share[(fixedBound (N + 1)) (bound K)]), 
            nf('c : bool  <- read ('CtrbSum[(N + 1) (N + 1) 'k]),
             return (), 'c)
          )
         }
       }
       
    )
 .
   
   
 strat sym9 @ ProtocolConfig .
 sd sym9 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'In-OK
         typed unit
         params ('n 'i)
                ((bound (N + 2))(dependentBound 'I))  
         assigned
          nf('in : bool  <- read ('In['n 'i]),
             return (), 'in)
         in P
       ]
       {
          absorbFamily( fam ('In-OK[(bound (N + 2))(dependentBound 'I)]) )
       } ***sym
       )
 . 
 
 *** just to force typechecks, delete
 strat addHidden @ ProtocolConfig .
 sd addHidden := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       *** I':Set{CNameBound} <- I,
       P1:Protocol <- 
         addInternalFamily
           'Hidden
         typed unit
         params 'k (bound K)
         assigned
          return ()
         in P
       *** A':Set{BoolTerm} <- A        
       ]
       {    sugar-newNF
         ;  absorbFamilyDeleteEmpty( fam ('Hidden[bound K]) )
       } ***sym
       )
 . 
 
 strat sym10 @ ProtocolConfig .
 sd sym10 := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           ( fam ('Wire-OK[bound K]) )
         named 'Wires-OK 
         params ('k) (bound K)
         in 
         (addInternalFamily
           'Wire-OK
         typed unit
         params ('k)
                (bound K)  
         assigned
         (
          (when (apply 'isInputGate 'k) --> 
            nf('in : unit <- read ('In-OK[(fun 'wire0 'k) (fun 'wire1 'k)]),
               return 'in, 'in
            )
          )
          ;;
          (when (apply 'isNotGate 'k) --> 
            nf('w : unit <- read ('Wire-OK[(fun 'wire0 'k)]),
               return (), 'w
            )
          )
          ;;
          (when (apply 'isXorGate 'k) --> 
            nf( ('w0 : unit <- read ('Wire-OK[(fun 'wire0 'k)]))
                 'w1 : unit <- read ('Wire-OK[(fun 'wire1 'k)]),
               return (), 'w0 'w1
            )
          )
          ;;
          (when (apply 'isAndGate 'k) --> 
            nf( ('w0 : unit <- read ('Wire-OK[(fun 'wire0 'k)]))
                 'w1 : unit <- read ('Wire-OK[(fun 'wire1 'k)]),
               return (), 'w0 'w1
            )
          )
          )
         in P
         
         )
       ]
       {
          applyDropName( fam ('Wires-OK[bound K]) )
        ; absorbFamily( fam ('Wire-OK[bound K]) )
        
       } ***sym
       
       
       )
 .
 
 strat sym11 @ ProtocolConfig .
 sd sym11 := 
    
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
     
        change ( fam ( 'SharesOK[bound K] ) )
        with (
        ( when (apply 'isInputGate 'k) --> 
        (family  ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : bool <- read ('Ctrb['n 'm 'k]), return (), 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : bool <- read ('CtrbSum['n 'm 'k]), return (), 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return (), 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : bool <- read ('SendBit['n 'm 'k]), return (), 's)
)
||
(family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('x : bool <- read ('Share['n 'k]), return (), 'x)
)
||
(family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf('x : bool <- read ('Share[(N + 1) 'k]), return (), 'x)
)
        ) *** end input gate
;;
        (when (apply 'isNotGate 'k) --> 
          (family  ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : bool <- read ('Ctrb['n 'm 'k]), return (), 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : bool <- read ('CtrbSum['n 'm 'k]), return (), 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return (), 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : bool <- read ('SendBit['n 'm 'k]), return (), 's)
)
||
(family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('x : bool <- read ('Share['n 'k]), return (), 'x)
)
||
(family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf('x : bool <- read ('Share[(N + 1) 'k]), return (), 'x)
)
        ) *** end not gate
;;
        (when (apply 'isXorGate 'k) --> 
          (family  ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : bool <- read ('Ctrb['n 'm 'k]), return (), 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : bool <- read ('CtrbSum['n 'm 'k]), return (), 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return (), 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : bool <- read ('SendBit['n 'm 'k]), return (), 's)
)
||
(family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('x : bool <- read ('Share['n 'k]), return (), 'x)
)
||
(family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf('x : bool <- read ('Share[(N + 1) 'k]), return (), 'x)
)

        ) *** end xor gate   
;;
 (when (apply 'isAndGate 'k) --> 
        (family  ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : bool <- read ('Ctrb['n 'm 'k]), return (), 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : bool <- read ('CtrbSum['n 'm 'k]), return (), 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return (), 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : bool <- read ('SendBit['n 'm 'k]), return (), 's)
)
||
(family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('x : bool <- read ('Share['n 'k]), return (), 'x)
)
||
(family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf('x : bool <- read ('Share[(N + 1) 'k]), return (), 'x)
)
        ) *** end and gate       
        ) *** end with
        in P
       ]{
         applyAllSameCases(fam ( 'SharesOK[bound K] ))
       }
    
 .  
 
 var fns1 fns2 : NameWithScripts .
 var q : Qid .
 var bt : BoolTerm .
 var A' : Set{BoolTerm} .
 
 strat changeComp @ ProtocolConfig .
 sd changeComp :=
 *** sym proof for 'SharesOK
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf 
            by pConf 
            using 
            SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            
            P1:Protocol <- 
             change (fam ('SharesOK[bound K]))
             with 
              cases0
             in P
            ]
            *** by the induction
      { indSharedOK 
      }
 .           
 
 
 strat setIndConfSymProof @ ProtocolConfig .
 sd setIndConfSymProof := ***(
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (UNSAFE[
       Delta':ChannelContext <- 
        getInductionDelta
          (addInternalChannels Delta P)
          want0 'k 'B,
       I':Set{CNameBound} <- (fam ('In[bound (N + 2) dependentBound 'I]), 
 fam ('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]),
 fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]),
 fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])
 ),   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBaseSym (keepTwo P 
                        (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
                        (fam ('Comp['Shares 'SharesOK][bound K]))
                      )  ('Comp['Shares 'SharesOK]) 
                      'k 'B A want0),
       P1:Protocol <- getInductionBaseSym 
                      (keepTwo P 
                        (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
                        (fam ('Comp['Shares 'SharesOK][bound K]))
                      )  
                      ('Comp['Shares 'SharesOK]) 
                      'k 'B A want0,
       A':Set{BoolTerm} <-  (A,'B <T K)                
       ] ) 
    )
         applyDropName(fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
       ; CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]{
          *** for input gate
          select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isInputGate 'B
           ]
           { 
           symSubstDiverge(
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)
          ; symSubstDiverge(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)   
          ; symSubstDiverge(
             fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'r, 'r) 
          ; symSubstDiverge(
             fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 's, 's)   
          *** first the channel       
          ; applyReturnUnit(chn ('ShareOK[(N + 1) 'B]))
          ; substNFFamilyOne(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              'ShareOK[(N + 1) 'B],
              nf('is : bool <- read ('InShare[(N + 1) (fun 'wire0 'B) (fun 'wire1 'B)]), 
                 return (), 'is)
              )   
           ; inIndSym1   
           *** now the family
           ; applyReturnUnit(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]))
       ; alpha-family-two-top[fns:NameWithScripts <- 'ShareOK,
          bd1:Bounds <- (bound (N + 1)),
          bd2:Bounds <- (fixedBound 'B),
          q3:Qid <- 'x,
          q4:Qid <- 'y
         ]
       ; substNFFamiliesGen(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('is : bool <- read ('InShare['x (fun 'wire0 'B) (fun 'wire1 'B)]), 
                 return (), 'is)
              ) 
       ; alpha-family-two-top[fns:NameWithScripts <- 'ShareOK,
          bd1:Bounds <- (bound (N + 1)),
          bd2:Bounds <- (fixedBound 'B),
          q3:Qid <- 'n,
          q4:Qid <- 'k
         ]  
       ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 'is, 'in >> emptyQidPairList)
           
           *** and the sym proof for the family 'Share[bound (N + 1) fixedBound 'B]
       ; inIndSym2
           
           },
           CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]{
          *** for not gate
          select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isNotGate 'B
           ]
           { 
           symSubstDiverge(
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)
          ; symSubstDiverge(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)   
          ; symSubstDiverge(
             fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'r, 'r) 
          ; symSubstDiverge(
             fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 's, 's)   
           *** first the channel
           ;
           use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { 
             substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B],
              nf('x : bool <- read ('Share[(N + 1) (fun 'wire0 'B)]), return (), 'x)
              )   
            
           }
           ; inIndSym3       
          
           *** now the family
           ; applyReturnUnit(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]))
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('x : bool <- read ('Share['n (fun 'wire0 'B)]), return (), 'x)
              ) 
           } 
           ; inIndSym4
           }
           ,
           CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]{
          *** for xor gate
          select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isXorGate 'B
           ]
           { 
           symSubstDiverge(
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)
          ; symSubstDiverge(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)   
          ; symSubstDiverge(
             fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'r, 'r) 
          ; symSubstDiverge(
             fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 's, 's)   
          *** first the channel
           ;
           use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { 
             substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B],
              nf('x : bool <- read ('Share[(N + 1) (fun 'wire0 'B)]), return (), 'x)
              )   
           ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                 << 'x, 'a >> emptyQidPairList)  
           ; substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B],
              nf('x : bool <- read ('Share[(N + 1) (fun 'wire1 'B)]), return (), 'x)
              )   
           ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)  
                 
                 
           }  
           ; inIndSym5     
          
           *** now the family
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('x : bool <- read ('Share['n (fun 'wire0 'B)]), return (), 'x)
              ) 
              ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 'x, 'a >> emptyQidPairList)
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('x : bool <- read ('Share['n (fun 'wire1 'B)]), return (), 'x)
              )  
              ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)   
           } 
           ; inIndSym6
           
           },
           CASE-DISTINCTION-one-end-when{
           *** for and gate
           
           CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'SendBit-OK,
           blist:List{Bounds} <-(bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['n (fun 'wire0 'B)]), return (), 'x)
              )
              ; applyAlphaNFPr(fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList)
                 ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['n (fun 'wire1 'B)]), return (), 'x)
              )
              ; applyAlphaNFPr(fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)  
           }, 
             idle}
           ; inIndSym7  
          
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { 
             substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['n (fun 'wire0 'B)]), return (), 'x)
              )
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList)
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['n (fun 'wire1 'B)]), return (), 'x)
              )  
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'yn >> << 'a, 'xn >> emptyQidPairList) 
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['m (fun 'wire0 'B)]), return (), 'x)
              )
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList)
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['m (fun 'wire1 'B)]), return (), 'x)
              )  
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'ym >> << 'a, 'xm >> emptyQidPairList) 
              ; alpha-family-three-top[fns:NameWithScripts <- 'SendBit-OK,
              bd3:Bounds <- fixedBound 'B,
     q4:Qid <- 'x,
     q5:Qid <- 'y,
     q6:Qid <- 'z
      ]   
              ; substNFFamiliesGen(
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('s : bool <- read ('SendBit['m 'n 'B]), return (), 's)
              )
              ; alpha-family-three-top[fns:NameWithScripts <- 'SendBit-OK,
              bd3:Bounds <- fixedBound 'B,
     q4:Qid <- 'n,
     q5:Qid <- 'm,
     q6:Qid <- 'k
      ]   
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 's, 'b >> emptyQidPairList)      
              
           }
           ; inIndSym8
           
           ; select-branch-family-r[
             fns:NameWithScripts <- 'Ctrb-OK,
             blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
             bt:BoolTerm <- 'n <T 'm 
           ]{substNFFamiliesGen(
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('s : bool <- read ('SendBit['n 'm 'B]), return (), 's)
              )}
              
           ; select-branch-family-r[
             fns:NameWithScripts <- 'Ctrb-OK,
             blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
             bt:BoolTerm <- 'm <T 'n 
           ]{substNFFamiliesGen(
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('r : bool <- read ('RcvdBit['n 'm 'B]), return (), 'r)
              )}   
              
           *** we need to unsplit 'ShareOK on bound 'B
           
           *** TRACE HERE
           
           ; applyUnsplitGroup(fam ('SharesOK[bound 'B]), 
               fam ('ShareOK[bound (N + 1) bound 'B]), 
               fam ('ShareOK[fixedBound (N + 1) bound 'B])
             ) 
           
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           {   
             select-branch-family-r[
             fns:NameWithScripts <- 'Ctrb-OK,
             blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
             bt:BoolTerm <- 'm =T= 'n 
           ]{substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['n (fun 'wire0 'B)]), return (), 'x)
              )
             ; applyAlphaNFPr(fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList) 
             ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['n (fun 'wire1 'B)]), return (), 'x)
              )
             ; applyAlphaNFPr(fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)      
              }   
           }
            
           ; applySplitInsideGroup(fam ('SharesOK[bound 'B]), 
               fam ('ShareOK[bound (N + 2) bound 'B])
             )   
                       
           *** now the sym proof
           
           ; inIndSym9
            
           *** for CtrbSum-OK we must do induction
           ; inIndSym10 
           
           *** for ShareOK, first the family
           ; substNFFamiliesGen(
              fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('ShareOK[bound (N + 1) fixedBound 'B]),
              nf('c : bool <- read ('CtrbSum['n (N + 1) 'B]), return (), 'c)
             )  
           
           ; inIndSym11  
           
           *** then the channel
           
           ; substNFFamilyOne(
              fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              'ShareOK[(N + 1) 'B],
              nf('c : bool <- read ('CtrbSum[(N + 1) (N + 1) 'B]), return (), 'c)
              )  
           ; inIndSym12
           
           
           
          }}}}
          *** now we got same thing on all branches, we can merge
          ; applyAllSameCases(
            fam ('SharesOK[fixedBound 'B])
           )
                  
 .      
 
 
 ***( TEST for end
 with an unsafe here we get the same result!
 strat setIndConfSymProofEnd @ ProtocolConfig .
 sd setIndConfSymProofEnd :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- 
        getInductionDelta
          (addInternalChannels Delta P)
          want0 'k 'B,
          
       O1:Set{CNameBound} <- 
        getOutputs(getInductionEndSym (keepTwo P 
                        (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
                        (fam ('Comp['Shares 'SharesOK][bound K]))
                      )  ('Comp['Shares 'SharesOK]) 
                      'k 'B A want0),
       P1:Protocol <- getInductionEndSym
                      (keepTwo P 
                        (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
                        (fam ('Comp['Shares 'SharesOK][bound K]))
                      )  
                      ('Comp['Shares 'SharesOK]) 
                      'k 'B A want0
       ]
       { 
       applyDropName(fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I]))
       } 
 . 
 )     
 
 strat setIndConf @ ProtocolConfig .
 sd setIndConf :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (UNSAFE[
       Delta':ChannelContext <- 
        getInductionDelta
          (addInternalChannels Delta P)
          want0 'k 'B,
       I':Set{CNameBound} <- (fam ('In[bound (N + 2) dependentBound 'I]), 
 fam ('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]),
 fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]),
 fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])
 ),   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase (keepTwo P 
                        (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
                        (fam ('Comp['Shares 'SharesOK][bound K]))
                      )  ('Comp['Shares 'SharesOK]) 
                      'k 'B A want0),
       P1:Protocol <- getInductionBase 
                      (keepTwo P 
                        (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
                        (fam ('Comp['Shares 'SharesOK][bound K]))
                      )  
                      ('Comp['Shares 'SharesOK]) 
                      'k 'B A want0,
       A':Set{BoolTerm} <-  (A,'B <T K)                
       ]
       
       ; applyDropName(fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
       ; CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]{
          *** for input gate
          select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isInputGate 'B
           ]
           { 
           applySubstDivergeFamily(
            fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            'c, unit) 
           ;
           applySubstDivergeFamily(
            fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            'c, unit)  
           ;
           applySubstDivergeFamily(
            fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            'r, unit)  
           ;
           applySubstDivergeFamily(
            fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            's, unit)  
           ;
           substNFFamiliesGen(
             fam ('Share[bound (N + 1) fixedBound 'B]),
             fam ('ShareOK[bound (N + 1) fixedBound 'B]), 
             nf('in : bool <- read ('InShare['n (fun 'wire0 'B) (fun 'wire1 'B)]), 
                return 'in, 'in)
            )
           ; substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B]) 
           ; substNFFamilyOne(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              'ShareOK[(N + 1) 'B],
              nf('is : bool <- read ('InShare[(N + 1) (fun 'wire0 'B) (fun 'wire1 'B)]), 
                 return (), 'is)
              )
           *** now we do the sym proof for the channel 'Share[(N + 1) 'B]
           ; inIndSym1  
           *** and the sym proof for the family 'Share[bound (N + 1) fixedBound 'B]
           ; inIndSym2
           },
          CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]{
          *** for not gate
          select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isNotGate 'B
           ]
           { 
           applySubstDivergeFamily(
            fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            'c, unit) 
           ;
           applySubstDivergeFamily(
            fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            'c, unit)  
           ;
           applySubstDivergeFamily(
            fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            'r, unit)  
           ;
           applySubstDivergeFamily(
            fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            's, unit)  
            ; substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B]) 
            ;
           substNFFamiliesGen(
             fam ('Share[bound (N + 1) fixedBound 'B]),
             fam ('ShareOK[bound (N + 1) fixedBound 'B]), 
             nf('s : bool <- read ('Share['n (fun 'wire0 'B)]), return 's, 's)
            )
            
           },
          CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]{
          *** for xor gate
          select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isXorGate 'B
           ]
           { 
           applySubstDivergeFamily(
            fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            'c, unit) 
           ;
           applySubstDivergeFamily(
            fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            'c, unit)  
           ;
           applySubstDivergeFamily(
            fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            'r, unit)  
           ;
           applySubstDivergeFamily(
            fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
            's, unit)  
           
           },
          CASE-DISTINCTION-one-end-when{
           idle
          }
         }
         }
         }
         
       )
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       ***(
       ; CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]{
          *** for input gate
         
         ***(
          applySubstDivergeFromBranchP(
            fam ('Shares[fixedBound 'B]), 
            fam ('Ctrb[(bound (N + 2))(bound (N + 2))(fixedBound 'B)]), 
            fam ('Ctrb-OK[(bound (N + 2))(bound (N + 2))(fixedBound 'B)]),
            apply 'isInputGate 'B,
            'c, unit
            )
          ) idle  
         
          ,
          idle          
          }
        )  
       
       
       
       
       
       
       
       
       
       ***(
       ;
       CASE-DISTINCTION-one-R[
         fns:NameWithScripts <- 'SendBit-OK,
         blist:List{Bounds} <- ((bound (N + 2)) (bound (N + 2)) (fixedBound 'B))
       ]
       { *** for input gate 
        
       applySelectCaseDiverge(
        fam ('SendBit[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        fam ('SendBit-OK[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        apply 'isInputGate 'B, 
        's, 
        unit)
       , 
       CASE-DISTINCTION-one-R[
         fns:NameWithScripts <- 'SendBit-OK,
         blist:List{Bounds} <- ((bound (N + 2)) (bound (N + 2)) (fixedBound 'B))
       ]
       { *** for not gate 
        
       applySelectCaseDiverge(
        fam ('SendBit[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        fam ('SendBit-OK[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        apply 'isNotGate 'B, 
        's, 
        unit)
        
       , 
       CASE-DISTINCTION-one-R[
         fns:NameWithScripts <- 'SendBit-OK,
         blist:List{Bounds} <- ((bound (N + 2)) (bound (N + 2)) (fixedBound 'B))
       ]
       { *** for xor gate 
        
       applySelectCaseDiverge(
        fam ('SendBit[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        fam ('SendBit-OK[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        apply 'isXorGate 'B, 
        's, 
        unit)
        
       , *** for and gate
       CASE-DISTINCTION-one-R-end-when[
         fns:NameWithScripts <- 'SendBit-OK,
         blist:List{Bounds} <- ((bound (N + 2)) (bound (N + 2)) (fixedBound 'B))
       ]{ ***(
       applySubstOnBranch(
        fam ('RcvdBit[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        fam ('RcvdBit-OK[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        apply 'isAndGate 'B, 
        nf(('b : bool <- read ('SendBit['m 'n 'B])) 
           ('xm : bool <- read ('Share['m (fun 'wire0 'B)])) 
           ('xn : bool <- read ('Share['n (fun 'wire0 'B)])) 
           ('ym : bool <- read ('Share['m (fun 'wire1 'B)])) 
            'yn : bool <- read ('Share['n (fun 'wire1 'B)]), 
            return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn), 
                                 ap 'and pair('xn, 'ym)), 'b)), 
          'b 'xm 'ym 'xn 'yn)
       )
       ) *** end comment
       idle
       }
       }}
       }
       ;
       CASE-DISTINCTION-one-R[
         fns:NameWithScripts <- 'RcvdBit-OK,
         blist:List{Bounds} <- ((bound (N + 2)) (bound (N + 2)) (fixedBound 'B))
       ]
       { *** for input gate 
        
       applySelectCaseDiverge(
        fam ('RcvdBit[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        fam ('RcvdBit-OK[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        apply 'isInputGate 'B, 
        'r, 
        unit)
       , 
       CASE-DISTINCTION-one-R[
         fns:NameWithScripts <- 'RcvdBit-OK,
         blist:List{Bounds} <- ((bound (N + 2)) (bound (N + 2)) (fixedBound 'B))
       ]
       { *** for not gate 
        
       applySelectCaseDiverge(
        fam ('RcvdBit[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        fam ('RcvdBit-OK[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        apply 'isNotGate 'B, 
        'r, 
        unit)
        
       , 
       CASE-DISTINCTION-one-R[
         fns:NameWithScripts <- 'RcvdBit-OK,
         blist:List{Bounds} <- ((bound (N + 2)) (bound (N + 2)) (fixedBound 'B))
       ]
       { *** for xor gate 
        
       applySelectCaseDiverge(
        fam ('RcvdBit[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        fam ('RcvdBit-OK[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        apply 'isXorGate 'B, 
        'r, 
        unit)
        
       , *** for and gate
       CASE-DISTINCTION-one-R-end-when[
         fns:NameWithScripts <- 'RcvdBit-OK,
         blist:List{Bounds} <- ((bound (N + 2)) (bound (N + 2)) (fixedBound 'B))
       ]{
       applySubstOnBranch(
        fam ('RcvdBit[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        fam ('RcvdBit-OK[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        apply 'isAndGate 'B, 
        nf(('b : bool <- read ('SendBit['m 'n 'B])) 
           ('xm : bool <- read ('Share['m (fun 'wire0 'B)])) 
           ('xn : bool <- read ('Share['n (fun 'wire0 'B)])) 
           ('ym : bool <- read ('Share['m (fun 'wire1 'B)])) 
            'yn : bool <- read ('Share['n (fun 'wire1 'B)]), 
            return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn), 
                                 ap 'and pair('xn, 'ym)), 'b)), 
          'b 'xm 'ym 'xn 'yn)
       )
       }
       }}
       }
       )
 .    
 
 strat setIndConfSym @ ProtocolConfig .
 sd setIndConfSym :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        getInductionDelta
          (addInternalChannels Delta P)
          want0 'k 'B,
       O':Set{CNameBound} <- getOutputs(getInductionEnd P ('Comp['Shares 'SharesOK]) 
                      'k 'B A want0),
       P1:Protocol <- getInductionEnd P ('Comp['Shares 'SharesOK]) 
                      'k 'B A want0 
       ]
       ***( needs to happen last
       ;
       CASE-DISTINCTION-one-R[
         fns:NameWithScripts <- 'RcvdBit-OK,
         blist:List{Bounds} <- ((bound (N + 2)) (bound (N + 2)) (fixedBound 'B))
       ]
       { *** for input gate 
        
       idle
       , 
       CASE-DISTINCTION-one-R[
         fns:NameWithScripts <- 'RcvdBit-OK,
         blist:List{Bounds} <- ((bound (N + 2)) (bound (N + 2)) (fixedBound 'B))
       ]
       { *** for not gate 
        
       idle
        
       , 
       CASE-DISTINCTION-one-R[
         fns:NameWithScripts <- 'RcvdBit-OK,
         blist:List{Bounds} <- ((bound (N + 2)) (bound (N + 2)) (fixedBound 'B))
       ]
       { *** for xor gate 
        
       idle
        
       , *** for and gate
       CASE-DISTINCTION-one-R-end-when[
         fns:NameWithScripts <- 'RcvdBit-OK,
         blist:List{Bounds} <- ((bound (N + 2)) (bound (N + 2)) (fixedBound 'B))
       ]{ idle ***(
       applySubstOnBranch(
        fam ('Share[(bound (N + 2)) (fixedBound 'B)]), 
        fam ('RcvdBit-OK[(bound (N + 2)) (bound (N + 2)) (fixedBound 'B)]), 
        apply 'isAndGate 'B, 
        nf(('b : bool <- read ('SendBit['m 'n 'B])) 
           ('xm : bool <- read ('Share['m (fun 'wire0 'B)])) 
           ('xn : bool <- read ('Share['n (fun 'wire0 'B)])) 
           ('ym : bool <- read ('Share['m (fun 'wire1 'B)])) 
            'yn : bool <- read ('Share['n (fun 'wire1 'B)]), 
            return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn), 
                                 ap 'and pair('xn, 'ym)), 'b)), 
          'b 'xm 'ym 'xn 'yn)
       )
      ) 
       }
       }}
       }
     )  
 .    
 
 strat setInduction @ ProtocolConfig .
 sd setInduction :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       P1:Protocol <- 
        getInductionBase P 'SharesOK 'k 'B genA 
        (
(family  ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : bool <- read ('Ctrb['n 'm 'k]), return (), 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : bool <- read ('CtrbSum['n 'm 'k]), return (), 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return (), 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : bool <- read ('SendBit['n 'm 'k]), return (), 's)
)
||
(family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('x : bool <- read ('Share['n 'k]), return (), 'x)        
)        
||
(family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf('x : bool <- read ('Share[(N + 1) 'k]), return (), 'x)        
)
       
  )      
       ]
 .
 
 var tlist : List{NatTerm} .
 var blist1 blist2 : List{Bounds} .
 var q1 q2 : Qid .
 
 strat symSubstDiverge : CNameBound CNameBound List{NatTerm} Qid Qid @ ProtocolConfig .
 sd symSubstDiverge(fam (fns1[blist1]), fam (fns2[blist2]), tlist, q1, q2) :=          
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       P1:Protocol <- 
        change fam (fns1[blist1])
        with nf(q1 : bool <- read (fns2[tlist]), return (), q1)
        in P,
        Delta1:ChannelContext <- Delta,
        O1:Set{CNameBound} <- O
       ]
       {
           applySubstDivergeFamily(
            fam (fns2[blist2]), 
            fam (fns1[blist1]), 
            q2, unit)   
       }
       
    . 
    
 
 
 var R : Reaction .
    
 strat scp2 : BoolTerm Reaction @ ProtocolConfig .
 sd scp2(bt, R) :=          
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{scp2(bt, R)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
        ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P (fam ('Shares[bound K])) 
                  (fam ('ShareOK[(bound (N + 1)) (bound K)])), 
                 P1:Protocol <- keepTwo P
                 (fam ('Shares[bound K])) 
                  (fam ('ShareOK[(bound (N + 1)) (bound K)]))
                ]
              {
                select-case-subst-family-p[
           fns1:NameWithScripts <- 'Shares,
           fns2:NameWithScripts <- 'ShareOK,
           bt:BoolTerm <- bt
          ]{
            substNFFamiliesGen(
            (fam ('Share[(bound (N + 1)) (bound K)])), 
            (fam ('ShareOK[(bound (N + 1)) (bound K)])), 
            R
            )
           }
              }
       )       
    .      
    
 strat scp3 @ ProtocolConfig .
 sd scp3 :=          
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{scp3}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
        ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P (fam ('Shares[bound K])) 
                  (fam ('ShareOK[(fixedBound (N + 1)) (bound K)])), 
                 P1:Protocol <- keepTwo P
                 (fam ('Shares[bound K])) 
                  (fam ('ShareOK[(fixedBound (N + 1)) (bound K)]))
                ]
              {
                select-case-subst-family-p[
           fns1:NameWithScripts <- 'Shares,
           fns2:NameWithScripts <- 'ShareOK,
           bt:BoolTerm <- apply 'isInputGate 'k
          ]{
            substNFFamiliesGen(
            (fam ('Share[(fixedBound (N + 1)) (bound K)])), 
            (fam ('ShareOK[(fixedBound (N + 1)) (bound K)])), 
            nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)])) 
                'x : unit <- read ('InShareOK[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]), 
                return 'in, 'x 'in)
            )
           }
              }
       )       
    . 
    
 strat scp4 @ ProtocolConfig .
 sd scp4 :=          
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{scp4}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
        (
           use-family-p[fns:NameWithScripts <- 'InitOK]{
            substNFFamiliesGen(
            (fam ('InShareOK[(bound (N + 2)) (bound (N + 2)) (dependentBound 'I)]) ), 
            (fam ('ShareOK[(fixedBound (N + 1)) (bound K)]) ), 
            nf('is : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]), 
               return (), 'is)
            )
           }     
       )       
    .              
    
          
 
 strat sym12 @ ProtocolConfig .
 sd sym12 := 
    
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       UNSAFE[
        Delta':ChannelContext <- Delta,
        O':Set{CNameBound} <- O,
        P1:Protocol <- 
     
        change ( fam ( 'SharesOK[bound K] ) )
        with (
        ( when (apply 'isInputGate 'k) --> 
        (family  ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
(family ('ShareOK[(bound (N + 2)) (bound K)]) ('n 'k)
((bound (N + 2)) (bound K))
::=
nf('i : unit <- read ('InShareOK['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'i, 'i)
)
        ) *** end input gate
;;
        (when (apply 'isNotGate 'k) --> 
          (family  ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
(family ('ShareOK[(bound (N + 2)) (bound K)]) ('n 'k)
((bound (N + 2)) (bound K))
::=
nf('x : unit <- read ('ShareOK['n (fun 'wire0 'k)]), return 'x, 'x)
)
        ) *** end not gate
;;
        (when (apply 'isXorGate 'k) --> 
          (family  ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
family ('ShareOK[(bound (N + 2)) (bound K)]) ('n 'k)
((bound (N + 2)) (bound K))
::=
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)]))
   ('y : unit <- read ('ShareOK['n (fun 'wire1 'k)])), 
   return (), 'x 'y)
        ) *** end xor gate   
;;
 (when (apply 'isAndGate 'k) --> 
        (family  ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) --> 
  nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
;;
(when ('m <T 'n) --> 
  nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r))
;;
(when ('n =T= 'm) --> 
  nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)]))
     ('y : unit <- read ('ShareOK['n (fun 'wire1 'k)])), 
     return (), 'x 'y)
)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('m =T= 0) --> 
  nf('c : unit <- read ('Ctrb-OK['n 0 'k]), return 'c, 'c)
)
;;
(when (neg ('m =T= 0)) --> 
 nf( ('x : unit <- read ('CtrbSum-OK['n ('m -- 1) 'k]))
     ('y : unit <- read ('Ctrb-OK['n 'm 'k])),
     return (), 'x 'y
 )
)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf( ('sb : unit <- read ('SendBit-OK['n 'm 'k]) )
    ('xm : unit <- read ('ShareOK['m (fun 'wire0 'k)]))
    ('ym : unit <- read ('ShareOK['m (fun 'wire1 'k)]))
    ('xn : unit <- read ('ShareOK['n (fun 'wire0 'k)]))
    ('yn : unit <- read ('ShareOK['n (fun 'wire1 'k)])),
    return (), 'sb 'xm 'ym 'xn 'yn
)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) --> 
  nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)]))
     ('y : unit <- read ('ShareOK['n (fun 'wire1 'k)])), 
     return (), 'x 'y)
)
;;
(when ('m <=T 'n) --> 
  nf(('sb : unit <- read ('SendBit-OK['n 'm 'k]) ), return 'sb, 'sb)
)
)
||
family ('ShareOK[(bound (N + 2)) (bound K)]) ('n 'k)
((bound (N + 2)) (bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n (N + 1) 'k]), return 'c, 'c)     
        ) *** end and gate       
        ) *** end with
        in P
       ]
    
 .           
   
 *** sym proofs after the induction on sharesok
 
 strat asym0 @ ProtocolConfig .
 sd asym0 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I])
        with
        nf('is : unit <- read ('InShare$-OK['m 'n 'i]), return (), 'is)

        in P
       ] 
       {
         substNFFamiliesGen(
             fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
             nf('is : bool <- read ('InShare$['m 'n 'i]), return (), 'is)
            )
       }         
 .  
 
 strat asym01 @ ProtocolConfig .
 sd asym01 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I])
        with
        (when ('m =T= N + 1) -->
            nf(('s : unit <- read ('InShare$Sum-OK[N 'n 'i])) 
                'x : unit <- read ('In-OK['n 'i]), 
                return (), 'x 's)
        )
        ;;
        (when (neg ('m =T= N + 1)) -->
            nf( 'x : unit <- read ('In-OK['n 'i]), return (), 'x)
        )

        in P
       ] 
    {
   
       applySubstFamilyGenCase(
  fam ('In-OK[bound (N + 2) dependentBound 'I]),
 fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]),
 nf('in : bool <- read ('In['n 'i]), return (), 'in), 
 nf('in : bool <- read ('In['n 'i]), return (), 'in), 
 (neg ('m =T= N + 1))
 ) 
       ; applyAlphaBranchCond(
           fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
           'in, 'x, 
           when (neg ('m =T= N + 1)))
 }
 . 
 
 strat asym1 @ ProtocolConfig .
 sd asym1 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
        with
        nf(('s : unit <- read ('InShare$Sum-OK[N 'n 'i])) 
            'x : unit <- read ('In-OK['n 'i]), return (), 'x 's)

        in P
       ] 
       {
       substNFFamiliesGen(
             fam ('In-OK[bound (N + 2) dependentBound 'I]),
             fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I]), 
             nf('in : bool <- read ('In['n 'i]), return (), 'in)
            )
       ;
       substNFFamiliesGen(
             fam ('InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I]),
             fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I]), 
             nf('is : bool <- read ('InShare$-Sum[N 'n 'i]), return (), 'is)
            ) 
       }  
           
 . 
  
 strat asym2 @ ProtocolConfig .
 sd asym2 := 
  matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
       SYM[
       Delta1:ChannelContext <- Delta',
       O1:Set{CNameBound} <- O',
       P1:Protocol <- change 
        fam ('InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I])
        with
        (when (0 =T= 'm) -->
           nf('in : unit <- read ('InShare$-OK[0 'n 'i]), return (), 'in)
        )
        ;;
        (otherwise -->
           nf(('s : unit <- read ('InShare$Sum-OK[('m -- 1) 'n 'i])) 
               'x : unit <- read ('InShare$-OK['m 'n 'i]),
              return (), 's 'x))

        in P']
  {
   CONG-NEW-NF{
   SINGLE-INDUCTION-new-R[
     idx:Qid <- 'M,
     q:Qid <- 'm,
     cn:ChannelName <- 'InShare$Sum-OK,
     blist:List{Bounds} <- bound (N + 1) bound (N + 2) dependentBound 'I,
     cases':Cases <- 
           nf('is : bool <- read ('InShare$-Sum['m 'n 'i]), return (), 'is)
        
    ]{
    applyOtherwiseToNeg(
      fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
    )
  ; CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'InShare$Sum-OK,
           blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
           ]{
           *** for M = 0
           matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
         Q:Protocol  <- 
           removeTwo P 
            (fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])), 
         P1:Protocol <- 
           keepTwo P 
            (fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
          ]{
            select-case-subst-family-r[
            bt:BoolTerm <- neg ('m =T= N + 1)
           ]{ 
           substNFFamiliesGen(
             fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf('x : bool <- read ('In['n 'i]), return (), 'x)
             ) 
             
             }
             
             
         }      
            ,
            *** for neg M =T= 0
                  
            CASE-DISTINCTION-one-R-end-when[
         fns:NameWithScripts <- 'InShare$Sum-OK,
           blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
       ]{
            substNFFamiliesGen(
             fam ('InShare$Sum-OK[bound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf('is : bool <- read ('InShare$-Sum[('M -- 1) 'n 'i]), return (), 'is)
             ) 
            ;
           matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
         Q:Protocol  <- 
           removeTwo P 
            (fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])), 
         P1:Protocol <- 
           keepTwo P 
            (fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
          ]{
            select-case-subst-family-r[
            bt:BoolTerm <- neg ('m =T= N + 1)
           ]{substNFFamiliesGen(
             fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf('x : bool <- read ('In['n 'i]), return (), 'x)
             )}
             }  
           ; applyAlphaNFPr(
              fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
                 << 'is, 's >> emptyQidPairList)  
          }   
           
            
            } 
 ; asym3
    } 
  }  

}       
 . 
 
 strat asym3 @ ProtocolConfig .
 sd asym3 := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
             with 
              nf('is : bool <- read ('InShare$-Sum['M 'n 'i]), return (), 'is)
             in P
            ]
     { matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
     SYM[Delta1:ChannelContext <- Delta', 
           O1:Set{CNameBound} <- O',
           P1:Protocol <- 
             change 
              (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
             with 
              ( when ('M =T= 0) --> 
              nf('is : bool <- read ('InShare$-Sum['M 'n 'i]), return (), 'is)
              )
              ;;
              ( when (neg ('M =T= 0)) --> 
              nf('is : bool <- read ('InShare$-Sum['M 'n 'i]), return (), 'is)
              )
             in P'
           ]{applyAllSameCases(fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))}  
           
     ; applyOtherwiseToNeg(fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]))         
          
     ; CASE-DISTINCTION-one-R[
   fns:NameWithScripts <- 'InShare$Sum-OK,
   blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
 ]{
 *** case M = 0
            asym4
           ; 
           applyDropSubsumeCase(
       fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
       fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]), 
       neg ('m =T= N + 1)) 
      
   ,
   *** otherwise
   CASE-DISTINCTION-one-R-end-when[
         fns:NameWithScripts <- 'InShare$Sum-OK,
           blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
       ]{
             asym5
           ; applyDropSubsumeCase(
       fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
       fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]), 
       neg ('m =T= N + 1))    
          
   }         
 }
 ; applyNegToOtherwise(fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])) 
} 
. 

strat asym4 @ ProtocolConfig .
sd asym4 := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
         Q:Protocol  <- 
           removeTwo P 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])), 
         P1:Protocol <- 
           keepTwo P 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
          ]{
            select-case-subst-family-r[
            bt:BoolTerm <- ('m =T= 0)
           ]{ 
           substNFFamiliesGen(
             fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf('in : bool <- read ('InShare$[0 'n 'i]), return 'in, 'in)
             )
             
             }
             
           }
.

strat asym5 @ ProtocolConfig .
sd asym5 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
         Q:Protocol  <- 
           removeTwo P 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])), 
         P1:Protocol <- 
           keepTwo P 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
          ]{
            select-case-subst-family-r[
            bt:BoolTerm <- neg ('m =T= 0)
           ]{ 
           substNFFamiliesGen(
             fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf(('s : bool <- read ('InShare$-Sum[('M -- 1) 'n 'i])) 
                 'x : bool <- read ('InShare$['M 'n 'i]),
                 return (ap 'xor pair('s, 'x)), 's 'x)

             )
             
             }
           }
. 

 strat indProofInitOK @ ProtocolConfig .
 sd indProofInitOK := 
   
  CONG-NEW-NF{
     SINGLE-INDUCTION-new[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'InitOK,
  blist:List{Bounds} <- bound (N + 2) bound (N + 2) dependentBound 'I,
  P2:Protocol <-
  
  (family 'InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
)
||
(family 'InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 1) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
)
||
family 'InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
  
  ]
  {applyDropName(fam ('InitOK[fixedBound 'M bound (N + 2) dependentBound 'I]))
   
   *** first  'InShare$-OK  
       ; CASE-DISTINCTION-one-R[
   fns:NameWithScripts <- 'InShare$-OK,
   blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
 ]{ *** M = N + 1
    substNFFamiliesGen(
             fam ('InShare$Sum-OK[bound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
             )
   , *** here we already have what we want
     idle
   } 
   ; applyAllSameCases(fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
   
   *** then 'InShareOK
   ; substNFFamiliesGen(
             fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShareOK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
             )
   
   *** then  'InShare$Sum-OK 
   
   ; applyOtherwiseToNeg(fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
   
   ; CASE-DISTINCTION-one-R[
   fns:NameWithScripts <- 'InShare$Sum-OK,
   blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
 ]{ *** M = 0
    substNFFamiliesGen(
             fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
             )
            
   , CASE-DISTINCTION-one-R-end-when[
   fns:NameWithScripts <- 'InShare$Sum-OK,
   blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
   ]{
          substNFFamiliesGen(
             fam ('InShare$Sum-OK[bound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
             )
         ; substNFFamiliesGen(
             fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
             )    
   }          
     }
  ; applyAllSameCases(fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
        
  ; regroupInitOK 
  
  
  }  
  }

  . 
  
 strat regroupInitOK @ ProtocolConfig .
 sd regroupInitOK := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           (fam ('InShareOK[(bound 'M)(bound (N + 2))(dependentBound 'I)  ] ))
           (fam ('InShare$-OK[(bound 'M)(bound (N + 2))(dependentBound 'I)  ] ))
           (fam ('InShare$Sum-OK[(bound 'M)(bound (N + 2))(dependentBound 'I)  ] ))
         named 'InitOK 
         params ('m 'n 'i) (bound 'M (bound (N + 2))(dependentBound 'I))
         in P
       ]
       {
        applyDropName(
          fam ('InitOK[bound 'M (bound (N + 2))(dependentBound 'I)])
        )
       } ***sym   
      
 .  
  
  *** TODO: old, delete!
  strat indSetup @ ProtocolConfig .
  sd indSetup :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
           (
                      
(family 'InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
)
||
(family 'InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 1) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
)
||
family 'InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
                      
                      ) 'm 'M,
                       
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P 'InitOK
                      'm 'M A 
                      (
                      
(family 'InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
)
||
(family 'InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 1) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
)
||
family 'InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
                      
                      )),
                
                      
              
       P1:Protocol <- 
       getInductionBase
                      P
                      'InitOK
                      'm 'M A 
                      (
                      
                      
                      
(family 'InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
)
||
(family 'InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 1) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
)
||
(family 'InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
)                      
                    
                      
                      )
             ,      
                      
       A':Set{BoolTerm} <-  (A,'M <T N + 2)                
       ] ) 
       
       ; applyDropName(fam ('InitOK[fixedBound 'M bound (N + 2) dependentBound 'I]))
   
   *** first  'InShare$-OK  
       ; CASE-DISTINCTION-one-R[
   fns:NameWithScripts <- 'InShare$-OK,
   blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
 ]{ *** M = N + 1
    substNFFamiliesGen(
             fam ('InShare$Sum-OK[bound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
             )
   , *** here we already have what we want
     idle
   } 
   ; applyAllSameCases(fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
   
   *** then 'InShareOK
   ; substNFFamiliesGen(
             fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShareOK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
             )
   
   *** then  'InShare$Sum-OK 
   
   ; applyOtherwiseToNeg(fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
   
   ; CASE-DISTINCTION-one-R[
   fns:NameWithScripts <- 'InShare$Sum-OK,
   blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
 ]{ *** M = 0
    substNFFamiliesGen(
             fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
             )
            
   , CASE-DISTINCTION-one-R-end-when[
   fns:NameWithScripts <- 'InShare$Sum-OK,
   blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
   ]{
          substNFFamiliesGen(
             fam ('InShare$Sum-OK[bound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
             )
         ; substNFFamiliesGen(
             fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
             nf('x : unit <- read ('In-OK['n 'i]), return (), 'x)
             )    
   }          
     }
  ; applyAllSameCases(fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
  ; regroupInitOK      
 ***  ; applyGetChannel(fam ('InitOK[fixedBound 'M bound (N + 2) dependentBound 'I]))
   .       
 
 op want1 : -> Protocol .
 eq want1 = 
 (family 'SharesOK[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
;;
(when (apply 'isAndGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return (), 'w0 'w1)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return (), 'w0 'w1)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('m <T 'n) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return (), 'w0 'w1))
;;
when ('n <=T 'm) -->
nf('rb : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return (), 'w0 'w1))
;;
when ('m <=T 'n) -->
nf('sb : unit <- read ('SendBit-OK['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
)
||
family 'Wires-OK[bound K] 'k
bound K
::=
family 'Wire-OK[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
nf('in : unit <- read ('In-OK[(fun 'wire0 'k) (fun 'wire1 'k)]), return 'in, 'in))
;;
(when (apply 'isNotGate 'k) -->
nf('w : unit <- read ('Wire-OK[fun 'wire0 'k]), return (), 'w))
;;
(when (apply 'isXorGate 'k) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return (), 'w0 'w1))
;;
(when (apply 'isAndGate 'k) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return (), 'w0 'w1)
)
.
 
 strat indWiresShares @ ProtocolConfig .
 sd indWiresShares := 
 CONG-NEW-NF{ 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
    CONG-COMP-RIGHT[
        Q:Protocol  <- 
         removeTwo P 
          (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I]))
          (fam ('Comp['Wires-OK 'SharesOK][bound K])), 
        P1:Protocol <- 
          keepTwo P 
           (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
           (fam ('Comp['Wires-OK 'SharesOK][bound K]))                      
        ]
        {
 matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
 SINGLE-INDUCTION-new[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- 'Comp['Wires-OK 'SharesOK],
  blist:List{Bounds} <- bound K,
  P2:Protocol <- want1
 ]{ setIndWiresShares
 }
 }      
 }
 .  
 
 strat setIndWiresShares @ ProtocolConfig .
 sd setIndWiresShares :=
 ***( this is the start configuration
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          want1 'k 'B,
       I':Set{CNameBound} <- (I, fam ('In-OK[bound (N + 2) dependentBound 'I])),   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase (keepTwo P 
                        (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
                        (fam ('Comp['Wires-OK 'SharesOK][bound K]))
                      )  ('Comp['Wires-OK 'SharesOK]) 
                      'k 'B A want1),
       P1:Protocol <- getInductionBase 
                      (keepTwo P 
                        (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
                        (fam ('Comp['Wires-OK 'SharesOK][bound K]))
                      )  
                      ('Comp['Wires-OK 'SharesOK]) 
                      'k 'B A want1,
       A':Set{BoolTerm} <-  (A,'B <T K)                
       ] ) 
       ; 
       *** and from here on is the induction proof
       )
         applyDropName(fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I]))
        
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound 'B]),
           fam ('ShareOK[bound (N + 1) bound 'B]))  
       ; applyAllSameCases(fam ('ShareOK[bound (N + 1) bound 'B]))
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound 'B]),
           fam ('ShareOK[fixedBound (N + 1) bound 'B]) )  
       ; applyAllSameCases(fam ('ShareOK[fixedBound (N + 1) bound 'B]))
       
       
       ; applyUnsplitTop(
          fam ('ShareOK[bound (N + 1) bound 'B]), 
          fam ('ShareOK[fixedBound (N + 1) bound 'B])
       )
       
     
       ; CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for input gate
         substNFFamiliesGen(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('x : unit <- read ('In-OK[(fun 'wire0 'B) (fun 'wire1 'B)]), 
                 return (), 'x)
              )
              
           
        ; symInput  
        
        *** now for the channel
        ; substNFFamilyOne(
            fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
                ('ShareOK[(N + 1) 'B]), 
                nf('x : unit <- read ('In-OK[(fun 'wire0 'B) (fun 'wire1 'B)]), 
                   return (), 'x))   
                   
         ; symInputC           
               , 
               CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for not gate
              substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
              )
         ; applyReturnUnit( fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]) )     
         ; wireSymNot
         
         ***  now the channel
         
         ; substNFFamilyOne(
            fam ('ShareOK[bound (N + 2) bound 'B]), 
                ('ShareOK[(N + 1) 'B]), 
                nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
           )
         ; applyReturnUnit( chn ('ShareOK[(N + 1) 'B]) ) 
         ; wireSymNotC
              ,
       CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for xor gate
       substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
              )
       ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
       ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('w : unit <- read ('Wire-OK[fun 'wire1 'B]), return 'w, 'w)
              ) 
       ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList)  
       ; wireSymXor    
       
        ***  now the channel
         
         ; substNFFamilyOne(
            fam ('ShareOK[bound (N + 2) bound 'B]), 
                ('ShareOK[(N + 1) 'B]), 
                nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
           )
         ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                     << 'w, 'w0 >> emptyQidPairList) 
       ; substNFFamilyOne(
            fam ('ShareOK[bound (N + 2) bound 'B]), 
                ('ShareOK[(N + 1) 'B]), 
                nf('w : unit <- read ('Wire-OK[fun 'wire1 'B]), return 'w, 'w)
           )
       ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]),
                     << 'w, 'w1 >> emptyQidPairList)   
         
        ; wireSymXorC
                            
       , CASE-DISTINCTION-one-end-when[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
          { *** for and gate
            *** SendBit-OK
             CASE-DISTINCTION-one-R[
          fns:NameWithScripts <- 'SendBit-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
          ]{ substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]),
              nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
              )
              ; applyAlphaNFPr(fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
       ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]),
              nf('w : unit <- read ('Wire-OK[fun 'wire1 'B]), return 'w, 'w)
              ) 
       ; applyAlphaNFPr(fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList)  , 
            *** here nothing to do
             idle}
           *** rename vars in SendBit-OK  
           ; alpha-family-three-top[
           fns:NameWithScripts <- 'SendBit-OK,
           bd3:Bounds <- fixedBound 'B,
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]  
          *** for RcvdBit we must first add two cases
          ; symRcvdBit
          *** then we can do case distinction
          ; CASE-DISTINCTION-one-R[
             fns:NameWithScripts <- 'RcvdBit-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{  *** here we do 5 substs
              select-case-family-r[
           fns1:NameWithScripts <- 'SendBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'm <T 'n]{
   substNFFamiliesGen(
     fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
    return (), 'w0 'w1))           
           }
           
           ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
      )  
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
      ) 
      ; applyAlphaNFPr(fam ('RcvdBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf('w : unit <- read ('Wire-OK[fun 'wire1 'B]), return 'w, 'w)
      )  
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf('w : unit <- read ('Wire-OK[fun 'wire1 'B]), return 'w, 'w)
      ) 
      ; applyAlphaNFPr(fam ('RcvdBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList) 
           
           
            , *** here we diverge
            CASE-DISTINCTION-one-R-end-when[
             fns:NameWithScripts <- 'RcvdBit-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{
            select-case-family-r[
           fns1:NameWithScripts <- 'SendBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'n <=T 'm]{
   applySubstDivergeFamily(
     fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     'rb, unit)           
           }
           }
            
          }
          
          *** revert the alpha  
          ; alpha-family-three-top[
           fns:NameWithScripts <- 'SendBit-OK,
           bd3:Bounds <- fixedBound 'B,
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k]
           
           *** case dist for Ctrb-OK   
           ; CASE-DISTINCTION-one-R[
             fns:NameWithScripts <- 'Ctrb-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ select-case-family-r[
           fns1:NameWithScripts <- 'SendBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'n <T 'm]{
   substNFFamiliesGen(
     fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
    return (), 'w0 'w1))           
           }, 
              CASE-DISTINCTION-one-R[
             fns:NameWithScripts <- 'Ctrb-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ select-case-family-r[
           fns1:NameWithScripts <- 'RcvdBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- ('m <T 'n)]{
   substNFFamiliesGen(
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
    return (), 'w0 'w1))} , 
              CASE-DISTINCTION-one-R-end-when[
             fns:NameWithScripts <- 'Ctrb-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
      ) 
      ; applyAlphaNFPr(fam ('Ctrb-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf('w : unit <- read ('Wire-OK[fun 'wire1 'B]), return 'w, 'w)
      ) 
      ; applyAlphaNFPr(fam ('Ctrb-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList)  
           
           
           }}}
      ; applyAllSameCases(fam ('Ctrb-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]))
      
      *** induction for CtrbSum-OK
      ; SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'CtrbSum-OK,
  blist:List{Bounds} <- bound (N + 2) bound (N + 2) fixedBound 'B,
  cases':Cases <- 
   nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 'w1 : unit <- read ('Wire-OK[
    fun 'wire1 'B]), return (), 'w0 'w1)

 ]{
  CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'CtrbSum-OK,
           blist:List{Bounds} <- (bound (N + 2) fixedBound 'M fixedBound 'B)
           ]
           {
           *** for m = 0
           substNFFamiliesGen(
             fam ('Ctrb-OK[(bound (N + 2))(bound (N + 2))(fixedBound 'B)]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
             nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 
                 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
                 return (), 'w0 'w1)
            ),
            CASE-DISTINCTION-one-R-end-when[
           fns:NameWithScripts <- 'CtrbSum-OK,
           blist:List{Bounds} <- (bound (N + 2) fixedBound 'M fixedBound 'B)
           ]{
            substNFFamiliesGen(
             fam ('Ctrb-OK[(bound (N + 2))(bound (N + 2))(fixedBound 'B)]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
             nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 
                 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
                 return (), 'w0 'w1)
            ) 
            ; 
            substNFFamiliesGen(
             fam ('CtrbSum-OK[bound (N + 2) bound 'M fixedBound 'B]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
               nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 
                 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
                 return (), 'w0 'w1)
            )
            }
            
            }
  ; applyAllSameCases(fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]))         
  }
          *** and finally subst for ShareOK 
           
          ; substNFFamiliesGen(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('ShareOK[bound (N + 1) fixedBound 'B]), 
               nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 
                 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
                 return (), 'w0 'w1)
            ) 
           ; wireSymAnd 
           
          *** and the channel 
          ; substNFFamilyOne(
            fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                ('ShareOK[(N + 1) 'B]), 
                nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 
                 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
                 return (), 'w0 'w1)
           ) 
           
            ; wireSymAndC  
                      
          }
       }
       }
       }
     *** put back InitOK  
     ; sym6  
     
     *** then split ShareOK and put it back in SharesOK
     ; applySplit(fam ('ShareOK[bound (N + 2) bound 'B]))
     ; applyAddToGroupCases(
         fam ('ShareOK[bound (N + 1) bound 'B]),
         fam ('SharesOK[bound 'B])
         )
     ; applyAddToGroupCases(
         fam ('ShareOK[fixedBound (N + 1) bound 'B]),
         fam ('SharesOK[bound 'B])
         )    
 .  
 
 strat symRcvdBit @ ProtocolConfig .
 sd symRcvdBit :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
             with 
              (when ('m <T 'n) --> 
                nf(('sb : unit <- read ('SendBit-OK['m 'n 'B])) 
                   ('xm : unit <- read ('ShareOK['m (fun 'wire0 'B)]))
                   ('xn : unit <- read ('ShareOK['n (fun 'wire0 'B)])) 
                   ('ym : unit <- read ('ShareOK['m (fun 'wire1 'B)])) 
                    'yn : unit <- read ('ShareOK['n (fun 'wire1 'B)]), 
                    return (), 'sb 'xm 'ym 'xn 'yn)

              ) ;;
              (when ('n <=T 'm) --> 
                nf(('sb : unit <- read ('SendBit-OK['m 'n 'B])) 
                   ('xm : unit <- read ('ShareOK['m (fun 'wire0 'B)]))
                   ('xn : unit <- read ('ShareOK['n (fun 'wire0 'B)])) 
                   ('ym : unit <- read ('ShareOK['m (fun 'wire1 'B)])) 
                    'yn : unit <- read ('ShareOK['n (fun 'wire1 'B)]), 
                    return (), 'sb 'xm 'ym 'xn 'yn)
              )
             in P
            ]
            {applyAllSameCases(fam ('RcvdBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]) )
            }
            .
 
 strat wireSymAnd @ ProtocolConfig .
 sd wireSymAnd :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
             in P
            ]
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isAndGate 'B)]{
                 
                 substChannelFamilyOne(
                   chn ('Wire-OK['B]), 
                   fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
                 )}}
            }  
 .
 
 strat wireSymAndC @ ProtocolConfig .
 sd wireSymAndC :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('ShareOK[(N + 1) 'B])
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
             in P
            ]
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isAndGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])
                 }}
            }  
 .
 
 strat wireSymXor @ ProtocolConfig .
 sd wireSymXor :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
             in P
            ]
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isXorGate 'B)]{
                 
                 substChannelFamilyOne(
                   chn ('Wire-OK['B]), 
                   fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
                 )}}
            }  
 .
 
 strat wireSymXorC @ ProtocolConfig .
 sd wireSymXorC :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('ShareOK[(N + 1) 'B])
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
             in P
            ]
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isXorGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])
                 }}
            }  
 .
 
 strat wireSymNot @ ProtocolConfig .
 sd wireSymNot :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
             in P
            ]
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isNotGate 'B)]{
                 
                 substChannelFamilyOne(
                   chn ('Wire-OK['B]), 
                   fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
                 )}}
            }     
 .
 
 strat wireSymNotC @ ProtocolConfig .
 sd wireSymNotC :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('ShareOK[(N + 1) 'B])
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
             in P
            ]
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isNotGate 'B)]{
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])
                 }}
            }     
 .
 
 strat symInputC @ ProtocolConfig .
 sd symInputC :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('ShareOK[(N + 1) 'B] )
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
             in P
            ]
            {
             use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isInputGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])
                 
                 
                 ; applyReturnUnit( chn ('ShareOK[(N + 1) 'B] ) )
                 ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B] ), 
                     << 'in, 'x >> emptyQidPairList)  
                       
                 }
             }
          }  
           
  .        
 
 strat symInput @ ProtocolConfig .
 sd symInput :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
             in P
            ]
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isInputGate 'B)]{
                 
                 substChannelFamilyOne(
                   chn ('Wire-OK['B]), 
                   fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
                 )
                 ; applyReturnUnit( fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]) )
                 ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                     << 'in, 'x >> emptyQidPairList)    
                 }
             }
           }     
              
            .  
            
 strat setIndWiresSharesEnd @ ProtocolConfig .
 sd setIndWiresSharesEnd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          want1 'k 'B,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase (keepTwo P 
                        (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
                        (fam ('Comp['Wires-OK 'SharesOK][bound K]))
                      )  ('Comp['Wires-OK 'SharesOK]) 
                      'k 'B A want1),
       P1:Protocol <- getInductionEnd
                      (keepTwo P 
                        (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
                        (fam ('Comp['Wires-OK 'SharesOK][bound K]))
                      )  
                      ('Comp['Wires-OK 'SharesOK]) 
                      'k 'B A want1,
       A':Set{BoolTerm} <-  (A,'B <T K)                
       ] ) 
 .                           
 
 *** for the last induction of timing 1
 
 op want2 : -> Protocol .
 eq want2 = 
(family 'HiddenGroup[bound K] 'k
bound K
::=
family 'Hidden[bound K] 'k
bound K
::=
return ()

)
||
 (
    family 'Shares[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in, 'in)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)])) 
    'w : unit <- read ('Wire-OK['k]), 
     return 'in, 'w 'in)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's, 's)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('w : unit <- read ('Wire-OK['k])) 
    'x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)]), 
    return (ap 'neg 'x), 'w 'x)
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(
    'x, 'y)), 'x 'y)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('w : unit <- read ('Wire-OK['k])) 
   ('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 
    'y : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), 
    return (ap 'xor  pair('x, 'y)), 'w 'x 'y)
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'and pair(
    'x, 'y)), 'x 'y))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r, 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b, 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap 'xor pair('s, 'b)), 's
    'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn : bool <- read (
    'Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn : bool <- read ('Share['n (fun
    'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn), ap 'and pair('xn, 'ym)), 'b)), 'b 'xm 'ym 'xn
    'yn)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]), samp ('flip < () >),
    'x 'y))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs, 'bs)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k])) 
    'w : unit <- read ('Wire-OK['k]), return 'bs,
    'w 'bs)
) 
 .   
 

 strat indSharesT1 @ ProtocolConfig .
 sd indSharesT1 := 
 CONG-NEW-NF{ 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 SINGLE-INDUCTION-new[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- ('Comp['HiddenGroup 'Shares]),
  blist:List{Bounds} <- bound K,
  P2:Protocol <- want2
 ]{ indSharesTiming1(Delta, P, O, A)
  }
     
 }
 .  
  
  
 strat indSharesTiming1
    : ChannelContext Protocol Set{CNameBound} Set{BoolTerm} 
  @ ProtocolConfig .
 sd indSharesTiming1(Delta, P, O, A) 
   :=
 ***(
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        
        UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          want2 'k 'B,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(
          getInductionBase P  ('Comp['HiddenGroup 'Shares]) 'k 'B A want2
        ),
       P1:Protocol <- getInductionBase P  ('Comp['HiddenGroup 'Shares]) 'k 'B A want2,
       A':Set{BoolTerm} <-  (A,'B <T K)                
       ]
       
         
        
      ;  *** up to here worked with unsafe 
  ) 
        applyDropName(fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)]))
      ; applyNewCombine(fam ('Ctrbs-OK[bound K]))
      
      ;  CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** input
          substNFFamilyOne(
             fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
             'Share[(N + 1) 'B], 
             nf('x : unit <- read ('In-OK[(fun 'wire0 'B) (fun 'wire1 'B)]), return (), 'x)
             )
         ; symSharesInput   
             , 
          CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** not
          substNFFamilyOne(
             fam ('ShareOK[fixedBound (N + 1) bound K]), 
             'Share[(N + 1) 'B], 
             nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
             )
          ; symSharesNot   
             ,
             
             CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** xor
             substNFFamilyOne(
             fam ('ShareOK[fixedBound (N + 1) bound K]), 
             'Share[(N + 1) 'B], 
             nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
             )
             ; applyAlphaNFPr(chn ('Share[(N + 1) 'B]), 
                     << 'w, 'w0 >> emptyQidPairList)
             ; substNFFamilyOne(
             fam ('ShareOK[fixedBound (N + 1) bound K]), 
             'Share[(N + 1) 'B], 
             nf('w : unit <- read ('Wire-OK[fun 'wire1 'B]), return 'w, 'w)
             )  
             ; applyAlphaNFPr(chn ('Share[(N + 1) 'B]), 
                     << 'w, 'w1 >> emptyQidPairList)       
             ; symSharesXor
             ,
             CASE-DISTINCTION-one-end-when[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** and
             substNFFamilyOne(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]), 
             'Share[(N + 1) 'B], 
             nf(  ('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 
                  ('w1 : unit <- read ('Wire-OK[fun 'wire1 'B])) , 
                  return (), 'w0 'w1)
             )
            
             ; symSharesAnd
             }}
         }}
         
        ; *** undo structural operations by performing them on the expected result
       SYM[
       Delta1:ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          want2 'k 'B,
       O1:Set{CNameBound} <- 
        getOutputs(
          getInductionBase P ('Comp['HiddenGroup 'Shares]) 'k 'B A want2
        ),
       P1:Protocol <- getInductionEnd P ('Comp['HiddenGroup 'Shares]) 'k 'B A want2
       ] 
        { applyDropName(fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)]))
     ; applyNewCombine(fam ('Ctrbs-OK[bound K]))
     }
     
        
 .
 
 strat indSharesTimingEnd @ ProtocolConfig .
 sd indSharesTimingEnd :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          want2 'k 'B,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(
          getInductionBase P  'Shares 'k 'B A want2
        ),
       P1:Protocol <- getInductionEnd P 'Shares 'k 'B A want2,
       A':Set{BoolTerm} <-  (A,'B <T K)                
       ] ) 
     ; applyDropName(fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)]))
     ; applyNewCombine(fam ('Ctrbs-OK[bound K]))
 .
 
 strat symSharesInput @ ProtocolConfig .
 sd symSharesInput := 
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('Share[(N + 1) 'B])
             with 
              nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'B) (fun 'wire1 'B)])) 
                  'w : unit <- read ('Wire-OK['B]), 
                  return 'in, 'w 'in)
             in P
            ] 
            { applyAlphaNFPr(chn ('Share[(N + 1) 'B]), 
                     << 'in, 'is >> emptyQidPairList) 
           
            ; use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- bound K]{
                 substNFFamilyOne(
                 fam ('Wire-OK[bound K]), 
                 'Share[(N + 1) 'B], 
                 nf('in : unit <- read ('In-OK[(fun 'wire0 'B) (fun 'wire1 'B)]), 
                  return 'in, 'in)
                 )
                }
            ;  applyAlphaNFPr(chn ('Share[(N + 1) 'B]), 
                     << 'in, 'x >> << 'is, 'in >>
                      emptyQidPairList)  
            }             
 .
 
  strat symSharesNot @ ProtocolConfig .
 sd symSharesNot := 
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('Share[(N + 1) 'B])
             with 
             nf(('w : unit <- read ('Wire-OK['B])) 
                 'x : bool <- read ('Share[(N + 1) (fun 'wire0 'B)]), 
                return (ap 'neg 'x), 'w 'x)
              
             in P
            ] 
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- bound K]{
                 substNFFamilyOne(
                 fam ('Wire-OK[bound K]), 
                 'Share[(N + 1) 'B], 
                 nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return (), 'w)
                 )
                }
           }   
 .
 
  strat symSharesXor @ ProtocolConfig .
 sd symSharesXor := 
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('Share[(N + 1) 'B])
             with 
              nf(('w : unit <- read ('Wire-OK['B])) 
                 ('x : bool <- read ('Share[(N + 1) (fun 'wire0 'B)])) 
                  'y : bool <- read ('Share[(N + 1) (fun 'wire1 'B)]), 
                 return (ap 'xor pair('x, 'y)), 'w 'x 'y)
             in P
            ] 
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- bound K]{
                 substNFFamilyOne(
                 fam ('Wire-OK[bound K]), 
                 'Share[(N + 1) 'B], 
                 nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 
                     'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]), 
                     return (), 'w0 'w1)
                 )
                }
           }   
 .
 
  strat symSharesAnd @ ProtocolConfig .
 sd symSharesAnd := 
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('Share[(N + 1) 'B])
             with 
              nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'B])) 
                  'w : unit <- read ('Wire-OK['B]), return 'bs,
                   'w 'bs)
             in P
            ] 
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- bound K]{
                 substNFFamilyOne(
                 fam ('Wire-OK[bound K]), 
                 'Share[(N + 1) 'B], 
                 nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 
                     'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]), 
                     return (), 'w0 'w1)
                 )
                }
           }   
 .
 
 
 *** hidden group
 strat addHiddenGroup @ ProtocolConfig .
 sd addHiddenGroup := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           (fam ('Hidden[bound K]))
           
         named 'HiddenGroup 
         params ('k) (bound K) 
         in P
       ]
       {
        applyDropName(fam ('HiddenGroup[bound K]) )
        
       } ***sym
       )
 . 
 
 ***
 
 strat addShareSum @ ProtocolConfig .
 sd addShareSum := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'ShareSum
         typed bool
         params ('m 'k)
                ( (bound (N + 2))(bound K) )  
         assigned
          (when ('m =T= 0) -->
            nf('s : bool <- read ('Share[0 'k]), return 's, 's )
          )
          ;;
          (when (neg ('m =T= 0)) -->
            nf(('xs : bool <- read ('ShareSum[('m -- 1) 'k]))
               ('xm : bool <- read ('Share['m 'k])), 
               return (ap 'xor pair('xs, 'xm)), 'xs 'xm )
          )
         in P
       ]
       {
          absorbFamily( fam ('ShareSum[(bound (N + 2))(bound K)]) )
       } ***sym
       )
 . 
 
 strat introShareSumOK @ ProtocolConfig .
 sd introShareSumOK := 
    
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'ShareSum-OK
         typed unit
         params ('m 'k )
                ((bound (N + 1))(bound K))  
         assigned
          nf('s : bool  <- read ('ShareSum['m 'k]),
             return (), 's)
         in P  
       ]{
          absorbFamily(
           fam ( 'ShareSum-OK[((bound (N + 1))(bound K))] )
          )
        } ***sym
       )
       .
       
  strat sym20 @ ProtocolConfig .
  sd sym20 :=
      matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
        Delta1:ChannelContext <- Delta,
        O1:Set{CNameBound} <- O,
        P1:Protocol <-
              
         branch 
          (when (apply 'isAndGate 'k ))
         of
          (fam ('Adv[bound K]))
         change
          (fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]) )
         with
          (when ('n <T N + 1) -->
nf('x : unit <- read ('ShareSum-OK[N (fun 'wire1 'k)]), return (), 'x))
;;
(when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc, 'oc)
)
          in
          (
          branch 
          (when (apply 'isAndGate 'k ))
         of
          (fam ('Adv[bound K]))
         change
          (fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]) )
         with
          (when ('n <T N + 1) -->
nf('x : unit <- read ('ShareSum-OK[N (fun 'wire0 'k)]), return (), 'x))
;;
(when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc, 'oc)
)
          in
          P
          )
         ]
       {
         select-branch-family-p[
            fns:NameWithScripts <- 'Adv,
            bt:BoolTerm <- apply 'isAndGate 'k
         ]{
         
         CONG-NEW-NF{
          
           select-branch-family-r[
           fns:NameWithScripts <- ('OTChcRcvd-1 ^^ 'ot .. 'adv),
           blist:List{Bounds} <- bound (N + 2) fixedBound (N + 1) bound K,
           bt:BoolTerm <- ('n <T N + 1)
          ]{
          
           
           substNFFamiliesGen(
                 fam ('ShareSum-OK[bound (N + 1) bound K]), 
                 fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]), 
                 nf('s : bool <- read ('ShareSum[N (fun 'wire1 'k)]), return (), 's)
                 )
           ; 
           applyAlphaNFPr(
            fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]), 
            << 's, 'x >> emptyQidPairList)       
                          
          
         }
         
         ;
         
         select-branch-family-r[
           fns:NameWithScripts <- ('OTChcRcvd-0 ^^ 'ot .. 'adv),
           blist:List{Bounds} <- bound (N + 2) fixedBound (N + 1) bound K,
           bt:BoolTerm <- ('n <T N + 1)
          ]{
          
           
           substNFFamiliesGen(
                 fam ('ShareSum-OK[bound (N + 1) bound K]), 
                 fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]), 
                 nf('s : bool <- read ('ShareSum[N (fun 'wire0 'k)]), return (), 's)
                 )
           ; 
           applyAlphaNFPr(
            fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]), 
            << 's, 'x >> emptyQidPairList)       
                          
          
         }
         
         }
         
         }
         
    }     
   .      
  
 strat timingShares @ ProtocolConfig .
 sd timingShares := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         change 
           (fam ('Shares[bound K]))
        
    with
    (when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in, 'in)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)])) 'xs : unit <- read (
    'ShareSum-OK[N 'k]), return 'in, 'xs 'in)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's, 's)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 'xs : unit <- read ('ShareSum-OK[N 'k]),
    return (ap 'neg 'x), 'xs 'x)
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)), 'x 'y)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) ('xs : unit <- read ('ShareSum-OK[N 'k])) 'y :
    bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), return (ap 'xor pair('x, 'y)), 'xs 'x 'y)
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)), 'x 'y))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r, 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b, 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)), 's 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)), 'b 'xm 'ym 'xn 'yn)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >), 'x 'y))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs, 'bs)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k])) 'xs : unit <- read ('ShareSum-OK[N 'k]), return
    'bs, 'xs 'bs)

    in P]
{
   
   select-branch-family-p[
    fns:NameWithScripts <- 'Shares,
    bt:BoolTerm <- apply 'isInputGate 'k
   ]
   {
     substNFFamiliesGen(
                 fam ('ShareSum-OK[bound (N + 1) bound K]), 
                 fam ('Share[fixedBound (N + 1) bound K]), 
                 nf('s : bool <- read ('ShareSum[N 'k]), return (), 's)
                 )
     ; 
           applyAlphaNFPr(
            fam ('Share[fixedBound (N + 1) bound K]), 
            << 's, 'xs >> emptyQidPairList)                
   }
   ;
   select-branch-family-p[
    fns:NameWithScripts <- 'Shares,
    bt:BoolTerm <- apply 'isNotGate 'k
   ]
   {
     substNFFamiliesGen(
                 fam ('ShareSum-OK[bound (N + 1) bound K]), 
                 fam ('Share[fixedBound (N + 1) bound K]), 
                 nf('s : bool <- read ('ShareSum[N 'k]), return (), 's)
                 )
     ; 
           applyAlphaNFPr(
            fam ('Share[fixedBound (N + 1) bound K]), 
            << 's, 'xs >> emptyQidPairList)                
   }
   ;
   select-branch-family-p[
    fns:NameWithScripts <- 'Shares,
    bt:BoolTerm <- apply 'isXorGate 'k
   ]
   {
     substNFFamiliesGen(
                 fam ('ShareSum-OK[bound (N + 1) bound K]), 
                 fam ('Share[fixedBound (N + 1) bound K]), 
                 nf('s : bool <- read ('ShareSum[N 'k]), return (), 's)
                 )
     ; 
           applyAlphaNFPr(
            fam ('Share[fixedBound (N + 1) bound K]), 
            << 's, 'xs >> emptyQidPairList)                
   }
   ;
   select-branch-family-p[
    fns:NameWithScripts <- 'Shares,
    bt:BoolTerm <- apply 'isAndGate 'k
   ]
   {
     substNFFamiliesGen(
                 fam ('ShareSum-OK[bound (N + 1) bound K]), 
                 fam ('Share[fixedBound (N + 1) bound K]), 
                 nf('s : bool <- read ('ShareSum[N 'k]), return (), 's)
                 )
     ; 
           applyAlphaNFPr(
            fam ('Share[fixedBound (N + 1) bound K]), 
            << 's, 'xs >> emptyQidPairList)                
   }
}   
 .
 
 strat indShareSum-OK @ ProtocolConfig .
 sd indShareSum-OK :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change
          fam ('ShareSum-OK[bound (N + 1) bound K])
         with
          (when ('m =T= 0) -->
    nf('s : unit <- read ('ShareOK[0 'k]), return (), 's))
;;
(when (neg ('m =T= 0)) -->
   nf(
        ('ss : unit <- read ('ShareSum-OK[('m -- 1) 'k]))
        ('s : unit <- read ('ShareOK['m 'k])),
        return (),
        'ss 's
   )   
)
          in
          P
       ] 
      {
       
       CONG-NEW-NF{
       
        SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'ShareSum-OK,
  blist:List{Bounds} <- bound (N + 1) bound K,
  cases':Cases <- 
   nf('s : bool <- read ('ShareSum['m 'k]), return (), 's)
  ]     
       { ***(
       matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (family 'ShareSum-OK[bound (N + 1) bound K] 
            ('m 'k) (bound (N + 1) bound K) ::=
           nf('s : bool <- read ('ShareSum['m 'k]), return (), 's)
          ) 'm 'M,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(
          getInductionBase P  'ShareSum-OK 'm 'M A 
          (family 'ShareSum-OK[bound (N + 1) bound K] 
            ('m 'k) (bound (N + 1) bound K) ::=
           nf('s : bool <- read ('ShareSum['m 'k]), return (), 's)
          )
        ),
       P1:Protocol <- 
         getInductionBase P  'ShareSum-OK 'm 'M A 
          (family 'ShareSum-OK[bound (N + 1) bound K] 
            ('m 'k) (bound (N + 1) bound K) ::=
           nf('s : bool <- read ('ShareSum['m 'k]), return (), 's)
          )
       ,
       A':Set{BoolTerm} <-  (A,'M <T N + 1)                
       ] 
       ; 
              *** ind proof starts here
     )         
       CASE-DISTINCTION-one-R[
        fns:NameWithScripts <- 'ShareSum-OK
       ]{
        *** for m = 0
        
        use-family-p[fns:NameWithScripts <- 'SharesOK]{
        
        substNFFamiliesGen(
                 fam ('ShareOK[bound (N + 2) bound K]), 
                 fam ('ShareSum-OK[fixedBound 'M bound K]), 
                 nf('x : bool <- read ('Share[0 'k]), return (), 'x)
                 )
        ; symShareSumOK0
        }
        ,
        *** for m /= 0
        CASE-DISTINCTION-one-R-end-when[
        fns:NameWithScripts <- 'ShareSum-OK
       ]{
        use-family-p[fns:NameWithScripts <- 'SharesOK]{
        
        
        substNFFamiliesGen(
                 fam ('ShareOK[bound (N + 2) bound K]), 
                 fam ('ShareSum-OK[fixedBound 'M bound K]), 
                 nf('x : bool <- read ('Share['M 'k]), return (), 'x)
                 )
       
       }
       
       ; 
        substNFFamiliesGen(
                 fam ('ShareSum-OK[bound 'M bound K]), 
                 fam ('ShareSum-OK[fixedBound 'M bound K]), 
                 nf('s : bool <- read ('ShareSum[('M -- 1) 'k]), return (), 's)
                 )  
       ; symShareSumOKM                 
        }
       }
       ; applyAllSameCases( fam ('ShareSum-OK[fixedBound 'M bound K]) )
}       
}
}  
 .   
 
 strat symShareSumOK0 @ ProtocolConfig .
 sd symShareSumOK0 := 
      matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change 
         fam ('ShareSum-OK[fixedBound 'M bound K])
        with
         nf('s : bool <- read ('ShareSum['M 'k]), return (), 's)
        in 
        P
       ] 
       { subst1
       ; applyAlphaNFPr(
            fam ('ShareSum-OK[fixedBound 'M bound K]), 
            << 's, 'x >> emptyQidPairList)                
       }     
       
             
 .

 strat subst1 @ ProtocolConfig .
 sd subst1 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P (fam ('ShareSum[bound (N + 2) bound K])) 
                  (fam ('ShareSum-OK[fixedBound 'M bound K])), 
                 P1:Protocol <- keepTwo P (fam ('ShareSum[bound (N + 2) bound K])) 
                  (fam ('ShareSum-OK[fixedBound 'M bound K]))
                ]
              {
                select-case-subst-family-r[
           fns1:NameWithScripts <- 'ShareSum,
           fns2:NameWithScripts <- 'ShareSum-OK,
           bt:BoolTerm <- 0 =T= 'm
          ]{ 
            substNFFamiliesGen(
                 fam ('ShareSum[bound (N + 2) bound K]), 
                 fam ('ShareSum-OK[fixedBound 'M bound K]), 
                 nf('s : bool <- read ('Share[0 'k]), return 's, 's)
                 )
            
           }
              }
       )       
 . 
 
 ***
 
 strat symShareSumOKM @ ProtocolConfig .
 sd symShareSumOKM := 
      matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change 
         fam ('ShareSum-OK[fixedBound 'M bound K])
        with
         nf('s : bool <- read ('ShareSum['M 'k]), return (), 's)
        in 
        P
       ] 
       { subst2
       ; applyAlphaNFPr(
            fam ('ShareSum-OK[fixedBound 'M bound K]), 
            << 'xm, 'x >> << 'xs, 's >>  emptyQidPairList)                
       }     
       
             
 .

 strat subst2 @ ProtocolConfig .
 sd subst2 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P (fam ('ShareSum[bound (N + 2) bound K])) 
                  (fam ('ShareSum-OK[fixedBound 'M bound K])), 
                 P1:Protocol <- keepTwo P (fam ('ShareSum[bound (N + 2) bound K])) 
                  (fam ('ShareSum-OK[fixedBound 'M bound K]))
                ]
              {
                select-case-subst-family-r[
           fns1:NameWithScripts <- 'ShareSum,
           fns2:NameWithScripts <- 'ShareSum-OK,
           bt:BoolTerm <- neg (0 =T= 'm)
          ]{ 
            substNFFamiliesGen(
                 fam ('ShareSum[bound (N + 2) bound K]), 
                 fam ('ShareSum-OK[fixedBound 'M bound K]), 
                 nf(('xm : bool <- read ('Share['M 'k])) 
                     'xs : bool <- read ('ShareSum[('M -- 1) 'k]), 
                     return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
                 )
            
           }
              }
       )       
 . 
 
 *** induction in timing 2
 
 op know0' : -> Protocol .
 eq know0' = 

(family 'Shares[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in, 'in)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)])) 'xs : unit <- read (
    'ShareSum-OK[N 'k]), return 'in, 'xs 'in)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's, 's)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 'xs : unit <- read ('ShareSum-OK[N 'k]),
    return (ap 'neg 'x), 'xs 'x)
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)), 'x 'y)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) ('xs : unit <- read ('ShareSum-OK[N 'k]))
    'y : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), return (ap 'xor pair('x, 'y)), 'xs 'x 'y)
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)), 'x 'y))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r, 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b, 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)), 's 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)), 'b 'xm 'ym 'xn 'yn)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >), 'x 'y))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs, 'bs)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k])) 'xs : unit <- read ('ShareSum-OK[N 'k]),
    return 'bs, 'xs 'bs)

)
||
family 'SharesOK[bound K] 'k
bound K
::=
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : bool <- read ('Ctrb['n 'm 'k]), return (), 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : bool <- read ('CtrbSum['n 'm 'k]), return (), 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return (), 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : bool <- read ('SendBit['n 'm 'k]), return (), 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('x : bool <- read ('Share['n 'k]), return (), 'x)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('x : bool <- read ('Share[(N + 1) 'k]), return (), 'x)

 .
 
 op cases0' : -> Cases .
 eq cases0' =
   (when (apply 'isInputGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
(
family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('i : unit <- read ('InShareOK['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'i, 'i)
)
||
(
family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf( ('i : unit <- read ('InShareOK[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]) )
    ('ss : unit <- read ('ShareSum-OK[N 'k])), return 'i, 'ss 'i)
)
) *** end when input gate
;;
(when (apply 'isNotGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
(
family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('x : unit <- read ('ShareOK['n (fun 'wire0 'k)]), return 'x, 'x)
)
||
(
family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf( ('x : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)]))
    ('ss : unit <- read ('ShareSum-OK[N 'k])) , return 'x, 'ss 'x)
)
) *** end when not gate
;;
(when (apply 'isXorGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
(
family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 
    'y : unit <- read ('ShareOK['n (fun 'wire1 'k)]), 
    return (), 'x 'y)
)
||
(
family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf( ('ss : unit <- read ('ShareSum-OK[N 'k])) 
   ('x : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)])) 
    'y : unit <- read ('ShareOK[(N + 1) (fun 'wire1 'k)]), 
    return (), 'ss 'x 'y)
)
) *** end when xor gate
;;
(when (apply 'isAndGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) -->
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's))
;;
(when ('m <T 'n) -->
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r))
;;
when ('m =T= 'n) -->
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 'y : unit <- read ('ShareOK['n (fun 'wire1
    'k)]), return (), 'x 'y)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (0 =T= 'm) -->
nf('c : unit <- read ('Ctrb-OK['n 0 'k]), return 'c, 'c))
;;
(when (neg (0 =T= 'm)) -->
nf(('x : unit <- read ('CtrbSum-OK['n ('m -- 1) 'k])) 
    'y : unit <- read ('Ctrb-OK['n 'm 'k]), 
     return (), 'x 'y)
)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf(('sb : unit <- read ('SendBit-OK['m 'n 'k])) 
   ('xm : unit <- read ('ShareOK['m (fun 'wire0 'k)]))
   ('xn : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 
   ('ym : unit <- read ('ShareOK['m (fun 'wire1 'k)])) 
    'yn : unit <- read ('ShareOK['n (fun 'wire1 'k)]), 
    return (), 'sb 'xm 'ym 'xn 'yn)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) -->
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 
    'y : unit <- read ('ShareOK['n (fun 'wire1 'k)]), 
    return (), 'x 'y))
;;
(when ('m <=T 'n) -->
nf('sb : unit <- read ('SendBit-OK['n 'm 'k]), return 'sb, 'sb)
)
)
||
(family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n (N + 1) 'k]), return 'c, 'c)
)
||
(family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf( ('c : unit <- read ('CtrbSum-OK[(N + 1) (N + 1) 'k]))
      ('ss : unit <- read ('ShareSum-OK[N 'k])), return 'c, 'ss 'c)
)
) *** end when and gate
. 
 
 strat changeComp' @ ProtocolConfig .
 sd changeComp' :=
 *** sym proof for 'SharesOK
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf 
            by pConf 
            using 
            SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change (fam ('SharesOK[bound K]))
             with 
              cases0'
             in P
            ]
         {  CONG-NEW-NF{ 
 
 matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
 SINGLE-INDUCTION-new[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- 'Comp['Shares 'SharesOK],
  blist:List{Bounds} <- bound K,
  P2:Protocol <- know0'
 ]{ setIndConfSymProof'(Delta', P', I', O', A')
 } 
     
 }
 }
 .           
 
 strat setIndConfSymProof' : 
       ChannelContext Protocol Set{CNameBound} Set{CNameBound} Set{BoolTerm} @ ProtocolConfig .
 sd setIndConfSymProof'(Delta, P, I, O, A) := 
  
   
   (
       UNSAFE[
       Delta':ChannelContext <- getInductionDelta
          (addInternalChannels Delta P)
          know0' 'k 'B,
       I':Set{CNameBound} <- I,
       O':Set{CNameBound} <-
         getOutputs(getInductionBase P ('Comp['Shares 'SharesOK]) 
                      'k 'B A know0'),
       P1:Protocol <- getInductionBase 
                      P 
                      ('Comp['Shares 'SharesOK]) 
                      'k 'B A know0',
       A':Set{BoolTerm} <-  (A,'B <T K)               
       ];

      
       *** ind proof starts here
        applyDropName(
         fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)])
        )
       ; CASE-DISTINCTION-one[
        fns:NameWithScripts <- 'SharesOK,
        blist:List{Bounds} <- fixedBound 'B
       ]{
       *** for input gate
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isInputGate 'B
           ]
           { 
           symSubstDiverge(
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)
          ; symSubstDiverge(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)   
          ; symSubstDiverge(
             fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'r, 'r) 
          ; symSubstDiverge(
             fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 's, 's)   
           *** for the family
       ; alpha-family-two-top[fns:NameWithScripts <- 'ShareOK,
          bd1:Bounds <- (bound (N + 1)),
          bd2:Bounds <- (fixedBound 'B),
          q3:Qid <- 'x,
          q4:Qid <- 'y
         ]
       ; substNFFamiliesGen(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('is : bool <- read ('InShare['x (fun 'wire0 'B) (fun 'wire1 'B)]), 
                 return (), 'is)
              ) 
       ; alpha-family-two-top[fns:NameWithScripts <- 'ShareOK,
          bd1:Bounds <- (bound (N + 1)),
          bd2:Bounds <- (fixedBound 'B),
          q3:Qid <- 'n,
          q4:Qid <- 'k
         ]  
       ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 'is, 'in >> emptyQidPairList)
        *** and the sym proof for the family 'Share[bound (N + 1) fixedBound 'B]
       ; inIndSym2    
       
           
           }
           *** for the channel
       ; substNFFamilyOne(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              'ShareOK[(N + 1) 'B],
              nf('is : bool <- read ('InShare[(N + 1) (fun 'wire0 'B) (fun 'wire1 'B)]), 
                 return (), 'is)
              )
       ; iSymInput
       
       , CASE-DISTINCTION-one[
        fns:NameWithScripts <- 'SharesOK,
        blist:List{Bounds} <- fixedBound 'B
       ]{
       *** for not gate
       
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isNotGate 'B
           ]
           { symSubstDiverge(
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)
          ; symSubstDiverge(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)   
          ; symSubstDiverge(
             fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'r, 'r) 
          ; symSubstDiverge(
             fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 's, 's)   
            *** now the family
           ; applyReturnUnit(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]))  
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('x : bool <- read ('Share['n (fun 'wire0 'B)]), return (), 'x)
              ) 
           } 
           ; inIndSym4
          } 
       ;
       use-family-p[
         fns1:NameWithScripts <- 'SharesOK,
         blist1:List{Bounds} <- bound 'B,
         bt:BoolTerm <- apply 'isNotGate 'B
       ]{
       substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B],
              nf('x : bool <- read ('Share[(N + 1) (fun 'wire0 'B)]), return (), 'x)
              )
       }
       ; iSymNot
       ,
        CASE-DISTINCTION-one[
        fns:NameWithScripts <- 'SharesOK,
        blist:List{Bounds} <- fixedBound 'B
       ]{
       *** for xor gate
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isXorGate 'B
           ]
           { 
           symSubstDiverge(
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)
          ; symSubstDiverge(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)   
          ; symSubstDiverge(
             fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'r, 'r) 
          ; symSubstDiverge(
             fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 's, 's)   
          
          
           *** now the family
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('x : bool <- read ('Share['n (fun 'wire0 'B)]), return (), 'x)
              ) 
              ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 'x, 'a >> emptyQidPairList)
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('x : bool <- read ('Share['n (fun 'wire1 'B)]), return (), 'x)
              )  
              ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)   
           } 
           ; inIndSym6
           
           }
       ;
       use-family-p[
         fns1:NameWithScripts <- 'SharesOK,
         blist1:List{Bounds} <- bound 'B,
         bt:BoolTerm <- apply 'isXorGate 'B
       ]{
       substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B],
              nf('x : bool <- read ('Share[(N + 1) (fun 'wire0 'B)]), return (), 'x)
              )
       ; applyAlphaNFPr(
            chn ('ShareOK[(N + 1) 'B]), 
            << 'x, 'x0 >>  emptyQidPairList) 
                   
       ; substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B],
              nf('x : bool <- read ('Share[(N + 1) (fun 'wire1 'B)]), return (), 'x)
              )     
       ; applyAlphaNFPr(
            chn ('ShareOK[(N + 1) 'B]), 
            << 'x, 'x1 >>  emptyQidPairList)        
       ; iSymXor     
       },
         CASE-DISTINCTION-one-end-when[
        fns:NameWithScripts <- 'SharesOK,
        blist:List{Bounds} <- fixedBound 'B
       ]{ *** for and gate
       
           CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'SendBit-OK,
           blist:List{Bounds} <-(bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['n (fun 'wire0 'B)]), return (), 'x)
              )
              ; applyAlphaNFPr(fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList)
                 ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['n (fun 'wire1 'B)]), return (), 'x)
              )
              ; applyAlphaNFPr(fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)  
           }, 
             idle}
           ; inIndSym7  
          
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { 
             substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['n (fun 'wire0 'B)]), return (), 'x)
              )
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList)
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['n (fun 'wire1 'B)]), return (), 'x)
              )  
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'yn >> << 'a, 'xn >> emptyQidPairList) 
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['m (fun 'wire0 'B)]), return (), 'x)
              )
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList)
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['m (fun 'wire1 'B)]), return (), 'x)
              )  
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'ym >> << 'a, 'xm >> emptyQidPairList) 
              ; alpha-family-three-top[fns:NameWithScripts <- 'SendBit-OK,
              bd3:Bounds <- fixedBound 'B,
     q4:Qid <- 'x,
     q5:Qid <- 'y,
     q6:Qid <- 'z
      ]   
              ; substNFFamiliesGen(
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('s : bool <- read ('SendBit['m 'n 'B]), return (), 's)
              )
              ; alpha-family-three-top[fns:NameWithScripts <- 'SendBit-OK,
              bd3:Bounds <- fixedBound 'B,
     q4:Qid <- 'n,
     q5:Qid <- 'm,
     q6:Qid <- 'k
      ]   
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 's, 'b >> emptyQidPairList)      
              
           }
           ; inIndSym8
           
           ; select-branch-family-r[
             fns:NameWithScripts <- 'Ctrb-OK,
             blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
             bt:BoolTerm <- 'n <T 'm 
           ]{substNFFamiliesGen(
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('s : bool <- read ('SendBit['n 'm 'B]), return (), 's)
              )}
              
           ; select-branch-family-r[
             fns:NameWithScripts <- 'Ctrb-OK,
             blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
             bt:BoolTerm <- 'm <T 'n 
           ]{substNFFamiliesGen(
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('r : bool <- read ('RcvdBit['n 'm 'B]), return (), 'r)
              )}   
              
           *** we need to unsplit 'ShareOK on bound 'B
           
           *** TRACE HERE
           
           ; applyUnsplitGroup(fam ('SharesOK[bound 'B]), 
               fam ('ShareOK[bound (N + 1) bound 'B]), 
               fam ('ShareOK[fixedBound (N + 1) bound 'B])
             ) 
           
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           {   
             select-branch-family-r[
             fns:NameWithScripts <- 'Ctrb-OK,
             blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
             bt:BoolTerm <- 'm =T= 'n 
           ]{substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['n (fun 'wire0 'B)]), return (), 'x)
              )
             ; applyAlphaNFPr(fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList) 
             ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              nf('x : bool <- read ('Share['n (fun 'wire1 'B)]), return (), 'x)
              )
             ; applyAlphaNFPr(fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)      
              }   
           }
            
           ; applySplitInsideGroup(fam ('SharesOK[bound 'B]), 
               fam ('ShareOK[bound (N + 2) bound 'B])
             )   
                       
           *** now the sym proof
           
           ; inIndSym9
            
           *** for CtrbSum-OK we must do induction
           ; inIndSym10 
           
           *** for ShareOK, first the family
           ; substNFFamiliesGen(
              fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('ShareOK[bound (N + 1) fixedBound 'B]),
              nf('c : bool <- read ('CtrbSum['n (N + 1) 'B]), return (), 'c)
             )  
           
           ; inIndSym11  
           *** now the channel
           ; substNFFamilyOne(
              fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              'ShareOK[(N + 1) 'B],
              nf('c : bool <- read ('CtrbSum[(N + 1) (N + 1) 'B]), return (), 'c)
             )
           ; iSymAnd
         }}
       }}
   ; applyAllSameCases(fam ('SharesOK[fixedBound 'B]))    
   ;
    SYM[
       Delta1:ChannelContext <- getInductionDelta
          (addInternalChannels Delta P)
          know0' 'k 'B,
       O1:Set{CNameBound} <-
         getOutputs(getInductionBase P ('Comp['Shares 'SharesOK]) 
                      'k 'B A know0'),
       P1:Protocol <- getInductionEnd 
                      P 
                      ('Comp['Shares 'SharesOK]) 
                      'k 'B A know0'
       ]   
     {
     applyDropName(
         fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)])
        )
     }
)
 .
 
 strat iSymInput @ ProtocolConfig .
 sd iSymInput :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         change 
          chn ('ShareOK[(N + 1) 'B])
         with
          nf('x : bool <- read ('Share[(N + 1) 'B]), return (), 'x)
         in P
       ] 
       {
       select-case-family-p[
         fns1:NameWithScripts <- 'Shares,
         blist1:List{Bounds} <- fixedBound 'B,
         bt:BoolTerm <- apply 'isInputGate 'B
       ]{substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B])}
       ; applyAlphaNFPr(
            chn ('ShareOK[(N + 1) 'B]), 
            << 'in, 'is >> << 'xs, 'ss >>  emptyQidPairList) 
            }
  .     

 strat iSymNot @ ProtocolConfig .
 sd iSymNot :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         change 
          chn ('ShareOK[(N + 1) 'B])
         with
          nf('x : bool <- read ('Share[(N + 1) 'B]), return (), 'x)
         in P
       ] 
       {
       select-case-family-p[
         fns1:NameWithScripts <- 'Shares,
         blist1:List{Bounds} <- fixedBound 'B,
         bt:BoolTerm <- apply 'isNotGate 'B
       ]{substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B])}
        ; applyAlphaNFPr(
            chn ('ShareOK[(N + 1) 'B]), 
            << 'xs, 'ss >>  emptyQidPairList) 
            }
            
  .     

 strat iSymXor @ ProtocolConfig .
 sd iSymXor :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         change 
          chn ('ShareOK[(N + 1) 'B])
         with
          nf('x : bool <- read ('Share[(N + 1) 'B]), return (), 'x)
         in P
       ] 
       {
       select-case-family-p[
         fns1:NameWithScripts <- 'Shares,
         blist1:List{Bounds} <- fixedBound 'B,
         bt:BoolTerm <- apply 'isXorGate 'B
       ]{substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B])}
        ; applyAlphaNFPr(
            chn ('ShareOK[(N + 1) 'B]), 
            << 'xs, 'ss  >> << 'x, 'x0 >> << 'y, 'x1 >>  emptyQidPairList) 
        ; changeOrder(chn ('ShareOK[(N + 1) 'B]), 'ss 'x0 'x1)       
        }    
  .     
  
 strat iSymAnd @ ProtocolConfig .
 sd iSymAnd :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         change 
          chn ('ShareOK[(N + 1) 'B])
         with
          nf('x : bool <- read ('Share[(N + 1) 'B]), return (), 'x)
         in P
       ] 
       {
       select-case-family-p[
         fns1:NameWithScripts <- 'Shares,
         blist1:List{Bounds} <- fixedBound 'B,
         bt:BoolTerm <- apply 'isAndGate 'B
       ]{substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B])}
       ; applyAlphaNFPr(
            chn ('ShareOK[(N + 1) 'B]), 
            << 'xs, 'ss  >> << 'bs, 'c >>  emptyQidPairList) 
       } 
  .
  
 *************************************************************** 
 
 *** induction on SharesOK to Ctrbs-OK with ShareSum-OK
 
 strat indWiresShares' @ ProtocolConfig .
 sd indWiresShares' := 
 CONG-NEW-NF{ 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
    CONG-COMP-RIGHT[
        Q:Protocol  <- 
         removeTwo P 
          (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I]))
          (fam ('Comp['Wires-OK 'SharesOK][bound K])), 
        P1:Protocol <- 
          keepTwo P 
           (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
           (fam ('Comp['Wires-OK 'SharesOK][bound K]))                      
        ]
        {
 matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
 SINGLE-INDUCTION-new[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- 'Comp['Wires-OK 'SharesOK],
  blist:List{Bounds} <- bound K,
  P2:Protocol <- want1'
 ]{ setIndWiresShares'
 }
 }      
 }
 . 
 
 strat symInputC' @ ProtocolConfig .
 sd symInputC' :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('ShareOK[(N + 1) 'B] )
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
             in P
            ]
          {
             use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isInputGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])
                 
                 
                 ; applyReturnUnit( chn ('ShareOK[(N + 1) 'B] ) )
                 
                       
                 }
             }
          }
           
  .        
 
 strat iSymSumSharesOK @ ProtocolConfig .
 sd iSymSumSharesOK :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         change 
          chn ('ShareSum-OK['M 'B])
         with
          nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
         in P
       ] 
       {
       applyReturnUnit(chn ('ShareSum-OK['M 'B]))
       } 
  .
 
 strat setIndWiresSharesEnd' @ ProtocolConfig .
 sd setIndWiresSharesEnd' :=
 *** this is the end configuration
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          want1' 'k 'B,
       I':Set{CNameBound} <- (I, fam ('In-OK[bound (N + 2) dependentBound 'I])),   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase (keepTwo P 
                        (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
                        (fam ('Comp['Wires-OK 'SharesOK][bound K]))
                      )  ('Comp['Wires-OK 'SharesOK]) 
                      'k 'B A want1'),
       P1:Protocol <- getInductionEnd 
                      (keepTwo P 
                        (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
                        (fam ('Comp['Wires-OK 'SharesOK][bound K]))
                      )  
                      ('Comp['Wires-OK 'SharesOK]) 
                      'k 'B A want1',
       A':Set{BoolTerm} <-  (A,'B <T K)                
       ] ) 
 .      
 
 strat setIndWiresShares' @ ProtocolConfig .
 sd setIndWiresShares' :=
 ***( this is the start configuration
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          want1' 'k 'B,
       I':Set{CNameBound} <- (I, fam ('In-OK[bound (N + 2) dependentBound 'I])),   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase (keepTwo P 
                        (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
                        (fam ('Comp['Wires-OK 'SharesOK][bound K]))
                      )  ('Comp['Wires-OK 'SharesOK]) 
                      'k 'B A want1'),
       P1:Protocol <- getInductionBase 
                      (keepTwo P 
                        (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
                        (fam ('Comp['Wires-OK 'SharesOK][bound K]))
                      )  
                      ('Comp['Wires-OK 'SharesOK]) 
                      'k 'B A want1',
       A':Set{BoolTerm} <-  (A,'B <T K)                
       ] ) 
        
       *** and from here on is the induction proof
      
       ; )
         applyDropName(fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I]))
        
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound 'B]),
           fam ('ShareOK[bound (N + 1) bound 'B]))  
       ; applyAllSameCases(fam ('ShareOK[bound (N + 1) bound 'B]))
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound 'B]),
           fam ('ShareOK[fixedBound (N + 1) bound 'B]) )  
       ; applyAllSameCases(fam ('ShareOK[fixedBound (N + 1) bound 'B]))
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound 'B]),
           fam ('ShareSum-OK[bound (N + 1) bound 'B]))  
       ; applyAllSameCases(fam ('ShareSum-OK[bound (N + 1) bound 'B]))
       
       ; applyRemoveMergeFromGroupCases(
           fam ('SharesOK[fixedBound 'B]),
           fam ('ShareSum-OK[bound (N + 1) fixedBound 'B]))  
       
       ; applyUnsplitTop(
          fam ('ShareOK[bound (N + 1) bound 'B]), 
          fam ('ShareOK[fixedBound (N + 1) bound 'B])
       )
       
      ; CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for input gate
         substNFFamiliesGen(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('x : unit <- read ('In-OK[(fun 'wire0 'B) (fun 'wire1 'B)]), 
                 return (), 'x)
              )
              
           
        ; symInput  
        
            
               , 
               CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for not gate
              substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
              )
         ; applyReturnUnit( fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]) )     
         ; wireSymNot
         
         
              ,
       CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for xor gate
       substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
              )
       ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
       ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]),
              nf('w : unit <- read ('Wire-OK[fun 'wire1 'B]), return 'w, 'w)
              ) 
       ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList)  
       ; wireSymXor    
       
        
       , CASE-DISTINCTION-one-end-when[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
          { *** for and gate
            *** SendBit-OK
             CASE-DISTINCTION-one-R[
          fns:NameWithScripts <- 'SendBit-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
          ]{ substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]),
              nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
              )
              ; applyAlphaNFPr(fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
       ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]),
              nf('w : unit <- read ('Wire-OK[fun 'wire1 'B]), return 'w, 'w)
              ) 
       ; applyAlphaNFPr(fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList)  , 
            *** here nothing to do
             idle}
           *** rename vars in SendBit-OK  
           ; alpha-family-three-top[
           fns:NameWithScripts <- 'SendBit-OK,
           bd3:Bounds <- fixedBound 'B,
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]  
          *** for RcvdBit we must first add two cases
          ; symRcvdBit
          *** then we can do case distinction
          ; CASE-DISTINCTION-one-R[
             fns:NameWithScripts <- 'RcvdBit-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{  *** here we do 5 substs
              select-case-family-r[
           fns1:NameWithScripts <- 'SendBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'm <T 'n]{
   substNFFamiliesGen(
     fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
    return (), 'w0 'w1))           
           }
           
           ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
      )  
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
      ) 
      ; applyAlphaNFPr(fam ('RcvdBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf('w : unit <- read ('Wire-OK[fun 'wire1 'B]), return 'w, 'w)
      )  
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf('w : unit <- read ('Wire-OK[fun 'wire1 'B]), return 'w, 'w)
      ) 
      ; applyAlphaNFPr(fam ('RcvdBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList) 
           
           
            , *** here we diverge
            CASE-DISTINCTION-one-R-end-when[
             fns:NameWithScripts <- 'RcvdBit-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{
            select-case-family-r[
           fns1:NameWithScripts <- 'SendBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'n <=T 'm]{
   applySubstDivergeFamily(
     fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     'rb, unit)           
           }
           }
            
          }
          
          *** revert the alpha  
          ; alpha-family-three-top[
           fns:NameWithScripts <- 'SendBit-OK,
           bd3:Bounds <- fixedBound 'B,
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k]
           
           *** case dist for Ctrb-OK   
           ; CASE-DISTINCTION-one-R[
             fns:NameWithScripts <- 'Ctrb-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ select-case-family-r[
           fns1:NameWithScripts <- 'SendBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'n <T 'm]{
   substNFFamiliesGen(
     fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
    return (), 'w0 'w1))           
           }, 
              CASE-DISTINCTION-one-R[
             fns:NameWithScripts <- 'Ctrb-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ select-case-family-r[
           fns1:NameWithScripts <- 'RcvdBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- ('m <T 'n)]{
   substNFFamiliesGen(
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
    return (), 'w0 'w1))} , 
              CASE-DISTINCTION-one-R-end-when[
             fns:NameWithScripts <- 'Ctrb-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
      ) 
      ; applyAlphaNFPr(fam ('Ctrb-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     nf('w : unit <- read ('Wire-OK[fun 'wire1 'B]), return 'w, 'w)
      ) 
      ; applyAlphaNFPr(fam ('Ctrb-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList)  
           
           
           }}}
      ; applyAllSameCases(fam ('Ctrb-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]))
      
      *** induction for CtrbSum-OK
      ; SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'CtrbSum-OK,
  blist:List{Bounds} <- bound (N + 2) bound (N + 2) fixedBound 'B,
  cases':Cases <- 
   nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 'w1 : unit <- read ('Wire-OK[
    fun 'wire1 'B]), return (), 'w0 'w1)

 ]{
  CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'CtrbSum-OK,
           blist:List{Bounds} <- (bound (N + 2) fixedBound 'M fixedBound 'B)
           ]
           {
           *** for m = 0
           substNFFamiliesGen(
             fam ('Ctrb-OK[(bound (N + 2))(bound (N + 2))(fixedBound 'B)]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
             nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 
                 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
                 return (), 'w0 'w1)
            ),
            CASE-DISTINCTION-one-R-end-when[
           fns:NameWithScripts <- 'CtrbSum-OK,
           blist:List{Bounds} <- (bound (N + 2) fixedBound 'M fixedBound 'B)
           ]{
            substNFFamiliesGen(
             fam ('Ctrb-OK[(bound (N + 2))(bound (N + 2))(fixedBound 'B)]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
             nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 
                 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
                 return (), 'w0 'w1)
            ) 
            ; 
            substNFFamiliesGen(
             fam ('CtrbSum-OK[bound (N + 2) bound 'M fixedBound 'B]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
               nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 
                 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
                 return (), 'w0 'w1)
            )
            }
            
            }
  ; applyAllSameCases(fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]))         
  }
          *** and finally subst for ShareOK 
           
          ; substNFFamiliesGen(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('ShareOK[bound (N + 1) fixedBound 'B]), 
               nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 
                 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
                 return (), 'w0 'w1)
            ) 
           ; wireSymAnd 
           
         
           
                            
          }
       }
       }
       }
       
       ; applyRemoveMergeFromGroupCases(
           fam ('SharesOK[fixedBound 'B]),
           fam ('ShareOK[bound (N + 1) fixedBound 'B]))  
           
       *** induction for ShareSumOK
       
       ;    SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'ShareSum-OK,
  blist:List{Bounds} <- bound (N + 1) fixedBound 'B,
  cases':Cases <- 
   nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
 ]{
       
       *** ind proof starts here
       
       CASE-DISTINCTION-channel[
           fns:NameWithScripts <- 'ShareSum-OK['M 'B]
           ]{
           *** for m = 0 
           substNFFamilyOne(
              fam ('ShareOK[bound (N + 1) fixedBound 'B]),
              'ShareSum-OK['M 'B],
              nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
              ),
           *** m /= 0
           CASE-DISTINCTION-channel-end-when[
           fns:NameWithScripts <- 'ShareSum-OK['M 'B]
           ]{
           substNFFamilyOne(
              fam ('ShareOK[bound (N + 1) fixedBound 'B]),
              'ShareSum-OK['M 'B],
              nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
              )
           ;
           substNFFamilyOne(
              fam ('ShareSum-OK[bound 'M fixedBound 'B]),
              'ShareSum-OK['M 'B],
              nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
              )   
           }
           } 
           ; applyAllSameCases(chn ('ShareSum-OK['M 'B]))
           ; iSymSumSharesOK 
           } 
           *** put things back
           ; applyAddToGroupCases(
           fam ('SharesOK[fixedBound 'B]),
           fam ('ShareOK[bound (N + 1) fixedBound 'B]))      
           ; applyAddToGroupCases(
           fam ('SharesOK[fixedBound 'B]),
           fam ('ShareSum-OK[bound (N + 1) fixedBound 'B])
           )   

           *** now case distinction for the channel 
           ; CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for input gate
       *** now for the channel
         substNFFamilyOne(
            fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
                ('ShareOK[(N + 1) 'B]), 
                nf('x : unit <- read ('In-OK[(fun 'wire0 'B) (fun 'wire1 'B)]), 
                   return (), 'x))  
         ; substNFFamilyOne(
            fam ('ShareSum-OK[bound (N + 1) fixedBound 'B]), 
                ('ShareOK[(N + 1) 'B]), 
               nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
               ) 
         ; use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isInputGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])    
                  }} 
         ; symInputC'
                   ,
                   CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for not gate  
       ***  now the channel
         
            substNFFamilyOne(
            fam ('ShareSum-OK[bound (N + 1) fixedBound 'B]), 
                ('ShareOK[(N + 1) 'B]), 
               nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
               ) 
          ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                     << 'w, 'w0 >> emptyQidPairList)      
         ; substNFFamilyOne(
            fam ('ShareOK[bound (N + 2) bound 'B]), 
                ('ShareOK[(N + 1) 'B]), 
                nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
           )  
           ; use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isNotGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])    
                  }} 
          ; applyReturnUnit( chn ('ShareOK[(N + 1) 'B]) )          
          ;  wireSymNotC
         ,
         CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for xor gate
       ***  now the channel
         
         substNFFamilyOne(
            fam ('ShareOK[bound (N + 2) bound 'B]), 
                ('ShareOK[(N + 1) 'B]), 
                nf('w : unit <- read ('Wire-OK[fun 'wire0 'B]), return 'w, 'w)
           )
         ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                     << 'w, 'w0 >> emptyQidPairList) 
       ; substNFFamilyOne(
            fam ('ShareOK[bound (N + 2) bound 'B]), 
                ('ShareOK[(N + 1) 'B]), 
                nf('w : unit <- read ('Wire-OK[fun 'wire1 'B]), return 'w, 'w)
           )
       ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]),
                     << 'w, 'w1 >> emptyQidPairList)  
       ; substNFFamilyOne(
            fam ('ShareSum-OK[bound (N + 1) fixedBound 'B]), 
                ('ShareOK[(N + 1) 'B]), 
               nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
               ) 
       ; use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isXorGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])    
                  }} 
       ; wireSymXorC                    
 ,
                   CASE-DISTINCTION-one-end-when[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
          { *** for and gate
           *** and the channel 
            substNFFamilyOne(
            fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                ('ShareOK[(N + 1) 'B]), 
                nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 
                 'w1 : unit <- read ('Wire-OK[fun 'wire1 'B]),
                 return (), 'w0 'w1)
           ) 
           ; substNFFamilyOne(
            fam ('ShareSum-OK[bound (N + 1) fixedBound 'B]), 
                ('ShareOK[(N + 1) 'B]), 
               nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
               ) 
           ; use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isAndGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])    
                  }} 
            ; wireSymAndC
            }}}} 
            *** now we put back initOk
            ; sym6 
            *** then split ShareOK and put it back in SharesOK
     ; applySplit(fam ('ShareOK[bound (N + 2) bound 'B]))
     ; applyAddToGroupCases(
         fam ('ShareOK[bound (N + 1) bound 'B]),
         fam ('SharesOK[bound 'B])
         )
     ; applyAddToGroupCases(
         fam ('ShareOK[fixedBound (N + 1) bound 'B]),
         fam ('SharesOK[bound 'B])
         ) 
          
     ; applyAddToGroupCases(
         fam ('ShareSum-OK[bound (N + 1) bound 'B]),
         fam ('SharesOK[bound 'B])
         )           
 .
 
   op want1' : -> Protocol .
 eq want1' = 
 (family 'SharesOK[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
||
(family 'ShareSum-OK[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
||
(family 'ShareSum-OK[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c, 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c, 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r, 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's, 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
||
(family 'ShareSum-OK[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
;;
(when (apply 'isAndGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return (), 'w0 'w1)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return (), 'w0 'w1)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('m <T 'n) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return (), 'w0 'w1))
;;
when ('n <=T 'm) -->
nf('rb : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return (), 'w0 'w1))
;;
when ('m <=T 'n) -->
nf('sb : unit <- read ('SendBit-OK['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
||
(family 'ShareSum-OK[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w, 'w)
)
)
||
family 'Wires-OK[bound K] 'k
bound K
::=
family 'Wire-OK[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
nf('in : unit <- read ('In-OK[(fun 'wire0 'k) (fun 'wire1 'k)]), return 'in, 'in))
;;
(when (apply 'isNotGate 'k) -->
nf('w : unit <- read ('Wire-OK[fun 'wire0 'k]), return (), 'w))
;;
(when (apply 'isXorGate 'k) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return (), 'w0 'w1))
;;
(when (apply 'isAndGate 'k) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return (), 'w0 'w1)
)
.


*****

***
 strat indSharesT2 @ ProtocolConfig .
 sd indSharesT2 := 
 CONG-NEW-NF{ 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 SINGLE-INDUCTION-new[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- ('Comp['HiddenGroup 'Shares]),
  blist:List{Bounds} <- bound K,
  P2:Protocol <- want2
 ]{ indSharesTiming2
  }
     
 }
 . 


strat indSharesTiming2End
    *** : ChannelContext Protocol Set{CNameBound} Set{BoolTerm} 
  @ ProtocolConfig .
 sd indSharesTiming2End
    ***      (Delta, P, O, A) 
   :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        
        UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          want2 'k 'B,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(
          getInductionBase P  ('Comp['HiddenGroup 'Shares]) 'k 'B A want2
        ),
       P1:Protocol <- getInductionEnd P  ('Comp['HiddenGroup 'Shares]) 'k 'B A want2,
       A':Set{BoolTerm} <-  (A,'B <T K)                
       ]
 .      

 strat indSharesTiming2
  @ ProtocolConfig .
 sd indSharesTiming2
   :=
***(
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        
        UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          want2 'k 'B,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(
          getInductionBase P  ('Comp['HiddenGroup 'Shares]) 'k 'B A want2
        ),
       P1:Protocol <- getInductionBase P  ('Comp['HiddenGroup 'Shares]) 'k 'B A want2,
       A':Set{BoolTerm} <-  (A,'B <T K)                
       ]
       
         
        
      ;  *** up to here worked with unsafe 
)
            
        CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** input
          substNFFamilyOne(
             fam ('ShareSum-OK[bound (N + 1) bound K]), 
             'Share[(N + 1) 'B], 
             nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
             )
             ,
             CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** not
          substNFFamilyOne(
             fam ('ShareSum-OK[bound (N + 1) bound K]), 
             'Share[(N + 1) 'B], 
             nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
             ),
             CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** xor
             substNFFamilyOne(
             fam ('ShareSum-OK[bound (N + 1) bound K]), 
             'Share[(N + 1) 'B], 
             nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
             ),
             CASE-DISTINCTION-one-end-when[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** and
           substNFFamilyOne(
             fam ('ShareSum-OK[bound (N + 1) bound K]), 
             'Share[(N + 1) 'B], 
             nf('w : unit <- read ('Wire-OK['B]), return 'w, 'w)
             )}}}}
     
        
 .


*******************************************************
*** 10.4.5 timing 2

strat timing2 : ChannelContext Protocol 
                Set{CNameBound} Set{CNameBound} Set{BoolTerm} 
                @ ProtocolConfig .
sd timing2(Delta, P, I, O, A) :=
 SYM[
        Delta1:ChannelContext <- Delta,
        O1:Set{CNameBound} <- O,
        P1:Protocol <-
         branch 
          (when (apply 'isInputGate 'k ))
         of
          (fam ('Shares[bound K]))
         change
          (fam ('Share[fixedBound (N + 1) bound K]) )
         with
          nf( ('xs : bool <- read('ShareSum[N 'k]))
              'in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]), 
              return 'in, 'xs 'in)
          in 
          (
          branch 
          (when (apply 'isNotGate 'k ))
         of
          (fam ('Shares[bound K]))
         change
          (fam ('Share[fixedBound (N + 1) bound K]) )
         with
          nf(('xs : bool <- read('ShareSum[N 'k]))
             'x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)]), 
             return (ap 'neg 'x), 'xs 'x)
          in 
          (
          branch 
          (when (apply 'isXorGate 'k ))
         of
          (fam ('Shares[bound K]))
         change
          (fam ('Share[fixedBound (N + 1) bound K]) )
         with
          nf(('xs : bool <- read('ShareSum[N 'k]))
             ('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 
              'y : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), 
              return (ap 'xor pair('x, 'y)), 'xs 'x 'y)
          in 
          (branch 
          (when (apply 'isAndGate 'k ))
         of
          (fam ('Shares[bound K]))
         change
          (fam ('Share[fixedBound (N + 1) bound K]) )
         with
          nf(('xs : bool <- read('ShareSum[N 'k]))
             'bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k]), 
             return 'bs, 'xs 'bs)
          in 
          (branch 
          (when (apply 'isAndGate 'k ))
         of
          (fam ('Adv[bound K]))
         change
          (fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]) )
         with
          (when ('n <T N + 1) -->
nf('x : bool <- read ('ShareSum[N (fun 'wire1 'k)]), return (), 'x))
;;
(when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc, 'oc)
)
          in
          (
          branch 
          (when (apply 'isAndGate 'k ))
         of
          (fam ('Adv[bound K]))
         change
          (fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]) )
         with
          (when ('n <T N + 1) -->
nf('x : bool <- read ('ShareSum[N (fun 'wire0 'k)]), return (), 'x))
;;
(when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc, 'oc)
)
          in
          P
          ))
          )
          )
          )
         ]  
     {   *** start of sym proof
         
      *** introduce InShare-OK, ShareOK  
        sym3 
      
      *** introduce ShareSum-OK  
      ; introShareSumOK
      
      *** use ShareSum-OK in Adv
      ; sym20
      
      *** turn dependency on sum shares to dependency on corresponding timing channel
      
      ; timingShares
        
      *** we introduce 'In-OK
      ; sym9
      
      *** and 'Wires-OK
      ; sym10
      
      *** add internal channels   
      ; sym5
      
      *** introduce InitOK
      ; sym6 
      
      *** introduce SharesOK
      ; sym7 
      
   
      *** rewrite ShareSum-OK      
      
      ; indShareSum-OK
       *** we split 'ShareOK
      ; applySplitInsideGroup(fam ('SharesOK[bound K]), 
           fam ('ShareOK[bound (N + 2) bound K]))
      
         
      *** then we group Shares with SharesOK
      ; applyGroupFamiliesNew(fam ('Shares[bound K]), fam ('SharesOK[bound K]))
      
      *** and we do the big induction for SharesOK
      ; changeComp'
      
      *** then we ungroup Shares with SharesOK
      ; applyUngroupFamiliesNew(fam ('Shares[bound K]), fam ('SharesOK[bound K]))
      
      *** this part repeated from timing 1
      
       ; applyDropName(
         fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)])
        )
      
       
      ; alpha-family-three[fns:NameWithScripts <- 'InShare,
     q4:Qid <- 'm,
     q5:Qid <- 'n,
     q6:Qid <- 'i
      ]   
      ; substNFFamiliesGen(
             fam ('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
             nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in, 'in)
            ) 
      ; applyAlphaNFPr(fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
                 << 'in, 'is >> emptyQidPairList)         
      ; alpha-family-three[fns:NameWithScripts <- 'InShare,
     q4:Qid <- 'n,
     q5:Qid <- 'm,
     q6:Qid <- 'i
      ]  
      ; asym0   
       
      *** first we split
      
      ; applySplitFst(fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]))
      
      *** for up to N + 1 in 'InShare$-OK
      ; applyOtherwiseToNeg(fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]))
      ; applyDropSubsumeFromBranchP(
         fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]), 
         fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]), 
         neg ('m =T= N + 1)
        )
        
        
     

      *** for N + 1 in 'InShare$-OK 
      ; substNFFamiliesGen(
             fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I]), 
             nf(('s : bool <- read ('InShare$-Sum[N 'n 'i])) 
                 'x : bool <- read ('In['n 'i]), 
                 return (ap 'xor pair('x, 's)), 'x 's)
        )
      ; applyAlphaNFPr(fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I]), 
                 << 's, 'is >> << 'x, 'in >> emptyQidPairList)   
      ; asym1 
      ; applyUnsplitFstNewNF(
      fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]),
      fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
     )  
  

       *** for 'InShare$Sum-OK we need an induction proof
       
       ; asym2
     
       *** and now we can deal with the missing bit on 'InShare$-OK
        *** ; applySplitFst(fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]))
       ; asym01  
       
      
      
      *** here we put back InitOK
      ; sym6 
      
      *** we can furthermore make all channels from InitOK read In-OK 
      
      ; indProofInitOK
      
      *** here ends the repeated proofs for InitOK
      
      *** we move ShareSum-OK in SharesOK
      ; applyAddToGroupCases(
         fam ('ShareSum-OK[bound (N + 1) bound K]), fam ('SharesOK[bound K])
        )
        
      *** here we introduce Ctrbs-OK by induction   
      
      *** we can group Wires-OK and SharesOK
      ; applyGroupFamiliesNew(fam ('Wires-OK[bound K]), fam ('SharesOK[bound K]))
      
      *** before set the induction up and test things
      ; indWiresShares'
      
      *** now we ungroup
      
      ; applyUngroupFamiliesNew(fam ('Wires-OK[bound K]), fam ('SharesOK[bound K]))
      
      *** we need to take out ShareOK
      
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound K]),
           fam ('ShareOK[bound (N + 1) bound K]))  
       ; applyAllSameCases(fam ('ShareOK[bound (N + 1) bound K]))
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound K]),
           fam ('ShareOK[fixedBound (N + 1) bound K]) )  
       ; applyAllSameCases(fam ('ShareOK[fixedBound (N + 1) bound K]))
       
       *** then ShareSum-OK
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound K]),
           fam ('ShareSum-OK[bound (N + 1) bound K]))  
       ; applyAllSameCases(fam ('ShareSum-OK[bound (N + 1) bound K]))       
       *** and rename SharesOK to Ctrbs-Ok
       
       ; applyRenameGroup(fam ('SharesOK[bound K]), 'Ctrbs-OK)  
      
      *** now we do some substs in Adv
       
       ; select-branch-family-p[
          fns:NameWithScripts <- 'Adv,
          bt:BoolTerm <- apply 'isAndGate 'k
         ]{ 
          CONG-NEW-NF{
          select-branch-family-r[
          fns:NameWithScripts <- 'OTChcRcvd-0 ^^ 'ot .. 'adv,
          blist:List{Bounds} <- bound (N + 2) fixedBound (N + 1) bound K,
          bt:BoolTerm <- 'n <T N + 1 
          ]
          { 
            substNFFamiliesGen(
             fam ('ShareSum-OK[(bound (N + 1)) (bound K)] ),
             fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]), 
             nf('w : unit <- read ('Wire-OK[fun 'wire0 'k]), return 'w, 'w)
            )
          }
          ; 
          select-branch-family-r[
          fns:NameWithScripts <- 'OTChcRcvd-1 ^^ 'ot .. 'adv,
          blist:List{Bounds} <- bound (N + 2) fixedBound (N + 1) bound K,
          bt:BoolTerm <- 'n <T N + 1 
          ]
          { 
            substNFFamiliesGen(
             fam ('ShareSum-OK[(bound (N + 1)) (bound K)] ),
             fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]), 
             nf('w : unit <- read ('Wire-OK[fun 'wire1 'k]), return 'w, 'w)
            )
          }
          }
         }   
         
      *** now induction for Shares
      
      *** group with a new dummy group
      
      ; addHidden
      ; addHiddenGroup
      
      ; applyGroupFamiliesNew(fam ('HiddenGroup[bound K]), fam ('Shares[bound K]))   
      
      *** ; indSharesTiming2
      ; indSharesT2
         
           
      ; applyUngroupFamiliesNew(fam ('HiddenGroup[bound K]), fam ('Shares[bound K]))
      ; applyDropName(fam ('HiddenGroup[bound K]) )
      ; absorbFamilyDeleteEmpty( fam ('Hidden[bound K]) )
      
      ; absorbFamily(fam ('ShareSum-OK[bound (N + 1) bound K]))
          
  
    
      *** reorder the normal form
       ; reorder-newNF[ql2:List{CNameBound} <-
       
      fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]) fam (
    'ShareOK[bound (N + 1) bound K]) fam ('ShareOK[fixedBound (N + 1) bound K])
    fam ('Wire-OK[bound K]) fam ('In-OK[bound (N + 2) dependentBound 'I]) fam (
    'InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I]) fam (
    'SendBit-OK[bound (N + 2) bound (N + 2) bound K]) fam ('RcvdBit-OK[bound (N
    + 2) bound (N + 2) bound K]) fam ('Ctrb-OK[bound (N + 2) bound (N + 2)
    bound K]) fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]) fam (
    'InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]) fam ('Share[
    bound (N + 1) bound K]) fam ('Share[fixedBound (N + 1) bound K]) fam (
    'ShareSum[bound (N + 2) bound K]) fam ('InShare[bound (N + 2) bound (N + 2)
    dependentBound 'I]) fam ('InShare$[bound (N + 2) bound (N + 2)
    dependentBound 'I]) fam ('InShare$-Sum[bound (N + 1) bound (N + 2)
    dependentBound 'I]) fam ('OutShare[bound (N + 2) bound (N + 2) bound K])
    fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]) fam ('SendBit[bound
    (N + 2) bound (N + 2) bound K]) fam ('RcvdBit[bound (N + 2) bound (N + 2)
    bound K]) fam ('Ctrb[bound (N + 2) bound (N + 2) bound K]) fam ('CtrbSum[
    bound (N + 2) bound (N + 2) bound K])
        
         ]
    *** end of timing2
 }
.

*****************************************************************

 strat addGroupOS @ ProtocolConfig .
 sd addGroupOS := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K])
           
         named 'GroupOS
         params ('n 'm 'k) (bound (N + 2) bound (N + 2) bound K)
         in P
       ]
       {
        applyDropName(fam ('GroupOS[bound (N + 2) bound (N + 2) bound K])
        )
       } ***sym
       )
 . 
 
 strat addBranchGroupOS @ ProtocolConfig .
 sd addBranchGroupOS := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change 
        fam ('GroupOS[bound (N + 2) bound (N + 2) bound K])
        with
         (when (apply 'isOutputWire 'k)  --> 
  family 'OutShareSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('OutShare['n 0 'k]), return 's, 's))
;;
otherwise -->
nf(('s : bool <- read ('OutShareSum['n ('m -- 1) 'k])) 'x : bool <- read ('OutShare['n 'm 'k]),
    return (ap 'xor pair('s, 'x)), 's 'x)
)
         ;;
(when (neg (apply 'isOutputWire 'k) ) --> 
family 'OutShareSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('OutShare['n 0 'k]), return 's, 's))
;;
otherwise -->
nf(('s : bool <- read ('OutShareSum['n ('m -- 1) 'k])) 'x : bool <- read ('OutShare['n 'm 'k]),
    return (ap 'xor pair('s, 'x)), 's 'x)
)
        in P
       ]
       {
        applyAllSameCases(fam ('GroupOS[bound (N + 2) bound (N + 2) bound K])
        )
       } ***sym
       )
 . 

  strat subst3 @ ProtocolConfig .
 sd subst3 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('OutShare[bound (N + 2) bound (N + 2) bound K]) ), 
                 P1:Protocol <- keepTwo P 
                  (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('OutShare[bound (N + 2) bound (N + 2) bound K]) )
                ]
              {
                select-case-subst-family-r[
           bt:BoolTerm <- apply 'isOutputWire 'k
          ]{ 
            substNFFamiliesGen(
                 fam ('OutShare[bound (N + 2) bound (N + 2) bound K]), 
                 fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
                 nf('s : bool <- read ('Share[0 'k]), return 's, 's)
                 )
            
           }
              }
       )       
 . 
 
 strat subst3sym @ ProtocolConfig .
 sd subst3sym :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])
        with
         nf('s : bool <- read ('ShareSum['M 'k]), return 's, 's)
        in P
       ]
{ matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P' (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('ShareSum[bound (N + 2) bound K]) ), 
                 P1:Protocol <- keepTwo P' 
                  (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('ShareSum[bound (N + 2) bound K]) )
                ]
              {
                select-case-subst-family-r[
           fns1:NameWithScripts <- 'ShareSum,
           bt:BoolTerm <- (0 =T= 'm)]{
   substNFFamiliesGen(
     fam ('ShareSum[bound (N + 2) bound K]), 
     fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
     nf('s : bool <- read ('Share[0 'k]), return 's, 's))       
           }
            
           
              }
       )       

 }
 .          
 
  strat subst4 @ ProtocolConfig .
 sd subst4 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('OutShare[bound (N + 2) bound (N + 2) bound K]) ), 
                 P1:Protocol <- keepTwo P 
                  (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('OutShare[bound (N + 2) bound (N + 2) bound K]) )
                ]
              {
                select-case-subst-family-r[
           bt:BoolTerm <- apply 'isOutputWire 'k
          ]{ 
            substNFFamiliesGen(
                 fam ('OutShare[bound (N + 2) bound (N + 2) bound K]), 
                 fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
                 nf('s : bool <- read ('Share['M 'k]), return 's, 's)
                 )
            
           }
              }
       )       
 . 


 strat subst4sym @ ProtocolConfig .
 sd subst4sym :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])
        with
         nf('s : bool <- read ('ShareSum['M 'k]), return 's, 's)
        in P
       ]
{ matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P' (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('ShareSum[bound (N + 2) bound K]) ), 
                 P1:Protocol <- keepTwo P' 
                  (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('ShareSum[bound (N + 2) bound K]) )
                ]
              {
                select-case-subst-family-r[
           fns1:NameWithScripts <- 'ShareSum,
           bt:BoolTerm <- neg (0 =T= 'm)]{
   substNFFamiliesGen(
     fam ('ShareSum[bound (N + 2) bound K]), 
     fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
     nf(('xm : bool <- read ('Share['M 'k])) 'xs : bool <- read ('ShareSum[('M -- 1)
    'k]), return (ap 'xor pair('xs, 'xm)), 'xs 'xm)

     )       
           }
            
           
              }
       )       

 }
 .   
 
 
 strat addBranchOut @ ProtocolConfig .
 sd addBranchOut := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change 
       fam ('Out[bound (N + 2) bound K])
        with
         (when (apply 'isOutputWire 'k)  --> 
  nf('s : bool <- read ('OutShareSum['n (N + 1) 'k]), return 's, 's)
)
         ;;
(when (neg (apply 'isOutputWire 'k) ) --> 
nf('s : bool <- read ('OutShareSum['n (N + 1) 'k]), return 's, 's)
)
        in P
       ]
       {
        applyAllSameCases( fam ('Out[bound (N + 2) bound K])  )
  
       } ***sym
       )
 . 
 
 strat subst5 @ ProtocolConfig .
 sd subst5 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P (fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K])) 
                  ( fam ('Out[bound (N + 2) bound K]) ), 
                 P1:Protocol <- keepTwo P 
                  (fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K])) 
                  ( fam ('Out[bound (N + 2) bound K]) )
                ]
              {
                select-case-subst-family-r[
           bt:BoolTerm <- apply 'isOutputWire 'k
          ]{ 
            substNFFamiliesGen(
                 fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]), 
                 fam ('Out[bound (N + 2) bound K]), 
                 nf('s : bool <- read ('ShareSum[(N + 1) 'k]), return 's, 's)
                 )
            
           }
              }
       )       
 .    
 
 strat subst6 @ ProtocolConfig .
 sd subst6 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P (fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K])) 
                  ( fam ('Out[bound (N + 2) bound K]) ), 
                 P1:Protocol <- keepTwo P 
                  (fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K])) 
                  ( fam ('Out[bound (N + 2) bound K]) )
                ]
              {
                select-case-subst-family-r[
           bt:BoolTerm <- neg(apply 'isOutputWire 'k)
          ]{ 
            subst-diverge-family[x3:ChannelName <- 'o, T2:Type <- bool] 
            
           }
              }
       )       
 .   
 
 *********************************
 *** for the induction in sum of shares
 
 op know3 : -> Protocol .
eq know3 = 
(when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in, 'in)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)])) 'xs : bool <- read (
    'ShareSum[N 'k]), return 'in, 'xs 'in)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)

||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('xm : bool <- read ('Share[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'xm)), 'xs 'xm)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's, 's)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 'xs : bool <- read ('ShareSum[N 'k]),
    return (ap 'neg 'x), 'xs 'x)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('xm : bool <- read ('Share[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'xm)), 'xs 'xm)
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)), 'x 'y)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) ('xs : bool <- read ('ShareSum[N 'k])) 'y :
    bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), return (ap 'xor pair('x, 'y)), 'xs 'x 'y)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('xm : bool <- read ('Share[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'xm)), 'xs 'xm)
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)), 'x 'y))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r, 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b, 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)), 's 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)), 'b 'xm 'ym 'xn 'yn)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >), 'x 'y))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs, 'bs)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return
    'bs, 'xs 'bs)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('xm : bool <- read ('Share[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'xm)), 'xs 'xm)
.    
 
op want3 : -> WhenList .
eq want3 = 
(when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in, 'in)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
    'xs : bool <- read ('ShareSum[N 'k]), 
    return (ap 'xor pair('xs, 'x)), 'xs 'x)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)

||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('i : bool <- read ('In[(fun 'wire0 'k) (fun 'wire1 'k)]), 
    return 'i, 'i)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's, 's)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
    'xs : bool <- read ('ShareSum[N 'k]), 
    return (ap 'xor pair('xs, 'x)), 'xs 'x)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)

||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)])),
    return (ap 'neg 'x),  'x)
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)), 'x 'y)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
    'xs : bool <- read ('ShareSum[N 'k]), 
    return (ap 'xor pair('xs, 'x)), 'xs 'x)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)])) 
    'y : bool <- read ('ShareSum[(N + 1) (fun 'wire1 'k)]), 
    return (ap 'xor pair('x, 'y)), 'x 'y)
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)), 'x 'y))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r, 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b, 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)), 's 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)), 'b 'xm 'ym 'xn 'yn)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >), 'x 'y))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs, 'bs)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
    'xs : bool <- read ('ShareSum[N 'k]), 
    return (ap 'xor pair('xs, 'x)), 'xs 'x)    
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)

||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)])) 
    'y : bool <- read ('ShareSum[(N + 1) (fun 'wire1 'k)]), 
    return (ap 'and pair('x, 'y)), 'x 'y)
.

*** add wire as internal channels

strat addWire @ ProtocolConfig .
sd addWire := 
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'Wire
         typed bool
         params ('k)
                (bound K) 
         assigned
          nf('s : bool  <- read ('ShareSum[(N + 1) 'k]),
             return 's, 's)
         in P
      ]{ absorbFamilyDeleteEmpty( 
        fam ('Wire[bound K])
       )
      }
.

*** 
strat addWiresGroup @ ProtocolConfig .
 sd addWiresGroup := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           (fam ('Wire[bound K]))
           
         named 'Wires
         params ('k) (bound K) 
         in P
       ]
       {
        applyDropName(fam ('Wires[bound K]) )
        
       } ***sym
       )
 . 


*** last induction of sum of shares

op knowSharesWire : -> Protocol .
eq knowSharesWire =
(family 'Shares[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in, 'in)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)), 'xs 'x)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('i : bool <- read ('In[(fun 'wire0 'k) (fun 'wire1 'k)]), return 'i, 'i)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's, 's)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)), 'xs 'x)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)]), return (ap 'neg 'x), 'x)
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)), 'x 'y)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)), 'xs 'x)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)])) 'y : bool <- read ('ShareSum[(N + 1) (
    fun 'wire1 'k)]), return (ap 'xor pair('x, 'y)), 'x 'y)
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)), 'x 'y))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r, 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b, 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)), 's 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)), 'b 'xm 'ym 'xn 'yn)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >), 'x 'y))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs, 'bs)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)), 'xs 'x)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)])) 'y : bool <- read ('ShareSum[(N + 1) (
    fun 'wire1 'k)]), return (ap 'and pair('x, 'y)), 'x 'y)

)
||
(
family 'Wire[bound K] 'k
bound K
::=
nf('s : bool <- read ('ShareSum[(N + 1) 'k]), return 's, 's)
)
.

op wantSharesWire : -> Protocol .
eq wantSharesWire =
(family 'Shares[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in, 'in)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)), 'xs 'x)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('w : bool <- read ('Wire['k]), return 'w, 'w)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's, 's)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)), 'xs 'x)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('w : bool <- read ('Wire['k]), return 'w, 'w)
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b, 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b, 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb, 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)), 'x 'y)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)), 'xs 'x)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('w : bool <- read ('Wire['k]), return 'w, 'w)

)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's, 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)), 'x 'y))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r, 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b, 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)), 's 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)), 'b 'xm 'ym 'xn 'yn)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >), 'x 'y))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb, 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs, 'bs)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)), 'xs 'x)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('w : bool <- read ('Wire['k]), return 'w, 'w)


)
||
(
family 'Wire[bound K] 'k
bound K
::=
 ( when (apply 'isInputGate 'k) -->  
       nf('i : bool <- read ('In[(fun 'wire0 'k) (fun 'wire1 'k)]), return 'i, 'i)
    )   
   ;;
   (when (apply 'isNotGate 'k) -->
       nf('x : bool <- read ('Wire [(fun 'wire0 'k)]), return (ap 'neg 'x), 'x)
   )  
   ;;
   (when (apply 'isXorGate 'k) --> 
       nf(('x : bool <- read ('Wire [(fun 'wire0 'k)])) 
           'y : bool <- read ('Wire [(fun 'wire1 'k)]), 
           return (ap 'xor pair('x, 'y)), 'x 'y)
   )
   ;;
   ( when (apply 'isAndGate 'k) --> 
    nf(('x : bool <- read ('Wire [(fun 'wire0 'k)])) 
        'y : bool <- read ('Wire [(fun 'wire1 'k)]), 
        return (ap 'and pair('x, 'y)), 'x 'y)
   ) 
)
.

strat inductionWireShares @ ProtocolConfig .
sd inductionWireShares :=
*** sym + induction again
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf 
            by pConf 
            using 
            SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change ( fam (('Comp['Shares 'Wire])[bound K]) )
             with 
              wantSharesWire
             in P
            ]
            {
  ***( ;
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          knowSharesWire 'k 'B,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P ('Comp['Shares 'Wire]) 'k 'B A knowSharesWire),
       P1:Protocol <- 
        *** getInductionBase P ('Comp['Shares 'Wire]) 'k 'B A knowSharesWire,
        getInductionBase P ('Comp['Shares 'Wire]) 'k 'B A knowSharesWire,
       A':Set{BoolTerm} <-  (A, 'B <T K)
       ] ; 
    )
    CONG-NEW-NF{ 
       SINGLE-INDUCTION-new[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- 'Comp['Shares 'Wire],
  blist:List{Bounds} <- bound K,
  P2:Protocol <- knowSharesWire
 ]{ 
    ***  
       *** here the induction proof
       *** take out ShareSum[N+1 B] from Shares
         applyRemoveFromGroupCases(fam ('Shares[fixedBound 'B]), chn ('ShareSum[(N + 1) 'B]))
       *** and group it with Wire[B]
       ; applyMergeCasesChannelGroup('Wire['B], 'ShareSum[(N + 1) 'B] )
       *** now we can do case distinction on CGroup
       ; CASE-DISTINCTION-one[
         fns:NameWithScripts <- 'CGroup
        ]{
         *** for input gate
           substNF('Wire['B], 'ShareSum[(N + 1) 'B] )
         ; symInputWS, 
         CASE-DISTINCTION-one[
         fns:NameWithScripts <- 'CGroup
        ]{ *** for not gate
           substNF('Wire['B], 'ShareSum[(N + 1) 'B] )
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'ShareSum[(N + 1) 'B],
            nf('s : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'B)]), return 's, 's)
           )
         
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'Wire['B],
            nf('s : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'B)]), return 's, 's)
           )  
        ; symInputWS  
        ;  applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 's, 'x >> emptyQidPairList)   
         ,
         CASE-DISTINCTION-one[
         fns:NameWithScripts <- 'CGroup
        ]{ *** for xor gate
           substNF('Wire['B], 'ShareSum[(N + 1) 'B] )
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'ShareSum[(N + 1) 'B],
            nf('s : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'B)]), return 's, 's)
           )
         ;  applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 's, 'x >> emptyQidPairList)  
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'ShareSum[(N + 1) 'B],
            nf('s : bool <- read ('ShareSum[(N + 1) (fun 'wire1 'B)]), return 's, 's)
           )
         ;  applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 's, 'y >> emptyQidPairList)  
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'Wire['B],
            nf('s : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'B)]), return 's, 's)
           )
         ;  applyAlphaNFPr(
            chn ('Wire['B]), 
                         << 's, 'x >> emptyQidPairList)      
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'Wire['B],
            nf('s : bool <- read ('ShareSum[(N + 1) (fun 'wire1 'B)]), return 's, 's)
           )
         ;  applyAlphaNFPr(
            chn ('Wire['B]), 
                         << 's, 'y >> emptyQidPairList)
         ;  symInputWS                               
         , 
         CASE-DISTINCTION-one-end-when[
         fns:NameWithScripts <- 'CGroup
        ]{ *** for and gate
         substNF('Wire['B], 'ShareSum[(N + 1) 'B] )
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'ShareSum[(N + 1) 'B],
            nf('s : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'B)]), return 's, 's)
           )
         ;  applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 's, 'x >> emptyQidPairList)  
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'ShareSum[(N + 1) 'B],
            nf('s : bool <- read ('ShareSum[(N + 1) (fun 'wire1 'B)]), return 's, 's)
           )
         ;  applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 's, 'y >> emptyQidPairList) 
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'Wire['B],
            nf('s : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'B)]), return 's, 's)
           )
         ;  applyAlphaNFPr(
            chn ('Wire['B]), 
                         << 's, 'x >> emptyQidPairList)      
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'Wire['B],
            nf('s : bool <- read ('ShareSum[(N + 1) (fun 'wire1 'B)]), return 's, 's)
           )
         ;  applyAlphaNFPr(
            chn ('Wire['B]), 
                         << 's, 'y >> emptyQidPairList)
         ;  symInputWS                           
         }}}}
         *** and combine the branches to get rid of the group
         ; applyNewCombine( fam('CGroup[nil]) )
         *** then move ShareSum back to Shares
         ; applyAddChnToGroupSameCases(fam ('Shares[fixedBound 'B]), 'ShareSum[(N + 1) 'B])
         *** simplify wire
         ; applyAllSameCases( chn ('Wire['B])  )
        }} } *** ind, cong, sym     
.

strat symInputWS @ ProtocolConfig .
sd symInputWS :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
       chn ('Wire['B])
       with  nf('s : bool <- read ('ShareSum[(N + 1) 'B]), return 's, 's)
       in P
       ] 
       { substNF( 'ShareSum[(N + 1) 'B], 'Wire['B])}

.

*** the huge induction

 strat setupIndSumShares @ ProtocolConfig .
 sd setupIndSumShares := 
 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('Shares[bound K])
        with
         want3
        in P
       ] 

{     
    
    CONG-NEW-NF{
    SINGLE-INDUCTION-new-R[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- 'Shares,
  blist:List{Bounds} <- bound K,
  cases':Cases <- know3
 ]{ 
 ***(
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          know3 'k 'B,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P 'Shares 'k 'B A know3),
       P1:Protocol <- 
        getInductionBase
        P 'Shares 'k 'B A know3,
       A':Set{BoolTerm} <-  (A,'B <T K)                
       ] ;)
       
    *** change otherwise to neg in 'InShare$-Sum
       applyOtherwiseToNeg( 
          fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]) 
         )
       ; applyOtherwiseToNeg( 
          fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]) 
         )  
       
    ; CASE-DISTINCTION-one[
       fns:NameWithScripts <- 'Shares,
       blist:List{Bounds} <- fixedBound 'B
    ]{ *** for input gate
         setupSymInput
         
       ,
       CASE-DISTINCTION-one[
       fns:NameWithScripts <- 'Shares,
       blist:List{Bounds} <- fixedBound 'B
    ]{ *** for not gate
         setupSymNot,
         CASE-DISTINCTION-one[
       fns:NameWithScripts <- 'Shares,
       blist:List{Bounds} <- fixedBound 'B
    ]{ *** for xor gate
       setupSymXor,
       
       CASE-DISTINCTION-one-end-when[
       fns:NameWithScripts <- 'Shares,
       blist:List{Bounds} <- fixedBound 'B
    ]{ *** for and gate
       setupSymAnd   
       }}
     }  
    }
    *** change neg to otherwise in 'InShare$-Sum
       ; 
       applyNegToOtherwise( 
          fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]) 
         )
       ; applyNegToOtherwise( 
          fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]) 
         )  
 } *** induction end  
 } *** cong new end
} *** sym end
.   

*** strats for and

strat setupIndColRowPartTwoNZ @ ProtocolConfig .
sd setupIndColRowPartTwoNZ := 
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
       fam ('Comp['RowSum 'ColSum][fixedBound 'X bound (N + 2)])
       with wantColRowSumPartTwoNZ
       in P
       ]
 {       ***(  
       matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          knowColRowSumPartTwoNZ 'j 'Y,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P ('Comp['RowSum 'ColSum]) 'j 'Y A knowColRowSumPartTwoNZ),
       P1:Protocol <- 
        getInductionBase P ('Comp['RowSum 'ColSum]) 'j 'Y A knowColRowSumPartTwoNZ,
       A':Set{BoolTerm} <-  (A,'Y <T (N + 2))
       ] ;
       )
       
       SINGLE-INDUCTION-new[
  idx:Qid <- 'Y,
  q:Qid <- 'j,
  cn:ChannelName <- 'Comp['RowSum 'ColSum],
  P2:Protocol <- knowColRowSumPartTwoNZ
 ]{      symColSumSameCasesPartTwo
       ; applyMergeCasesChannelGroup('RowSum['X 'Y], 'ColSum['X 'Y])
       ; CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'CGroup
       ]{
        substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'i), 
        nf(('bi : bool <- read ('Ctrb['X 0 'B])) 
            'r : bool <- read ('Row[('X -- 1) 0]), 
            return (ap 'xor pair('r, 'bi)), 'r 'bi)
        ) 
        ; symBranchYZeroAnd  
        ; substNF('RowSum['X 'Y], 'ColSum['X 'Y])
        ; symForRowSumPart2Zero
        ; symForColSumPart2Zero
        ,
       CASE-DISTINCTION-one-end-when[
          fns:NameWithScripts <- 'CGroup
       ]{
         applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                         << 'r, 'new >> emptyQidPairList)
       ; substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'i), 
        nf(('bi : bool <- read ('Ctrb['X 'Y 'B])) 
            'r : bool <- read ('Row[('X -- 1) 'Y]), 
            return (ap 'xor pair('r, 'bi)), 'r 'bi)
        ) 
        ; substNFFamilyOne(
          fam ('RowSum[fixedBound 'X bound 'Y]),
          'RowSum['X 'Y],
          nf('c : bool <- read ('ColSum['X ('Y -- 1)]), return 'c, 'c)
        ) 
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                         << 'bi, 'b >> << 'r, 'br >> emptyQidPairList)
                         
        ; substNFFamilyOne(
         fam ('ColSum[fixedBound 'X bound 'Y]),
        'RowSum['X 'Y],
         nf(('bi : bool <- read ('Col['X ('Y -- 1)])) 
             'bs : bool <- read ('ColSum[('X -- 1) ('Y -- 1)]), 
              return (ap 'xor pair('bs, 'bi)), 'bs 'bi)
        ) 
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                         << 'bi, 'bc >> emptyQidPairList)
                        
        ; substNFFamilyOne(
         fam ('ColSum[bound 'X bound (N + 2)]),
        'RowSum['X 'Y],
         nf('r : bool <- read ('RowSum[('X -- 1) ('Y -- 1)]), return 'r, 'r)
        )
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                         << 'r, 'bs >> emptyQidPairList)
        ; applyRearrangeXor(chn ('RowSum['X 'Y]))                 
        ; symRSPartTwoNZ
        ; substNF('RowSum['X 'Y], 'ColSum['X 'Y])   
        ; symForRowSumPart2Zero             
       }
       }
       ; applyAllSameCases(fam ('CGroup[nil]))
       ; applyDropName(fam ('CGroup[nil]))
       ; changeOrder(chn ('ColSum['X 'Y]), 'bs 'bi)
   } *** induction end    
 } *** sym end 
 .
 
 strat symRSPartTwoNZ @ ProtocolConfig .
 sd symRSPartTwoNZ :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change chn ('RowSum['X 'Y])
        with
        nf(('bi : bool <- read ('Col['X 'Y])) 
            'bs : bool <- read ('ColSum[('X -- 1) 'Y]), 
            return (ap 'xor pair('bs, 'bi)), 'bi 'bs)

        in P
       ] 
       { substNFFamilyOne(
         fam ('ColSum[bound 'X bound (N + 2)]),
        'RowSum['X 'Y],
         nf('r : bool <- read ('RowSum[('X -- 1) 'Y ]), return 'r, 'r)
        )
       ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'j), 
     nf(('bj : bool <- read ('Ctrb['X 'Y 'B])) 
         'bs : bool <- read ('Col['X ('Y -- 1)]), 
         return (ap 'xor pair('bs, 'bj)), 'bs 'bj)
      ) 
      ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                        << 'bj, 'b >> << 'bs, 'bc >> emptyQidPairList)
      ; substFamCaseChn(
        fam ('RowSum[bound 'X bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'j), 
       nf(('bj : bool <- read ('Row[('X -- 1) 'Y])) 
           'r : bool <- read ('RowSum[('X -- 1) ('Y -- 1)]), 
           return (ap 'xor pair('r, 'bj)), 'r 'bj)
      )   
       ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                        << 'bj, 'br >> << 'r, 'bs >> emptyQidPairList)        
       ; changeOrder(chn ('RowSum['X 'Y]),  'bs 'bc 'br 'b)
       }
 .
 
 
 strat symForRowSumPart2Zero @ ProtocolConfig .
 sd symForRowSumPart2Zero :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change chn ('RowSum['X 'Y]) 
       with 
        nf( 'c : bool <- read ('ColSum['X 'Y]),
             return 'c, 'c)
       in P
       ] 
       {substNF('ColSum['X 'Y], 'RowSum['X 'Y])}
.     

strat symForColSumPart2Zero @ ProtocolConfig .
 sd symForColSumPart2Zero :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change chn ('ColSum['X 'Y]) 
       with 
        nf(('bi : bool <- read ('Col['X 'Y])) 'bs : bool <- read ('ColSum[('X -- 1) 'Y]),
    return (ap 'xor pair('bs, 'bi)), 'bi 'bs)

       in P
       ] 
       { applyAlphaAssumChn('ColSum['X 'Y], 'Y)}
.        

 
 strat symBranchYZeroAnd @ ProtocolConfig .
 sd symBranchYZeroAnd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change chn ('RowSum['X 'Y]) 
       with 
        nf( ('bi : bool <- read ('Col['X 0]))
              'bs : bool <- read ('ColSum[('X -- 1) 0 ]),
          return (ap 'xor pair('bs, 'bi)), 'bi 'bs)
       in P
       ] 
       {
       substNFFamilyOne(
        fam ('ColSum[bound 'X bound (N + 2)]),
        'RowSum['X 'Y],
        nf('r : bool <- read ('RowSum[('X -- 1) 0]), return 'r, 'r)
       )
       ; substFamCaseChn(
        fam ('RowSum[bound 'X bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'j), 
        nf('r : bool <- read ('Row[('X -- 1) 0]), return 'r, 'r)
        ) 
       ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'j), 
       nf('c : bool <- read ('Ctrb['X 0 'B]), return 'c, 'c)
       )
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                         << 'c, 'bi >> emptyQidPairList)
        }              
.       



op wantColRowSumPartTwoNZ : -> Protocol .
eq wantColRowSumPartTwoNZ = 
(family 'ColSum[fixedBound 'X bound (N + 2)] 'i 'j
fixedBound 'X bound (N + 2)
::=
nf('r : bool <- read ('RowSum['X 'j]), return 'r, 'r)
)
||
(family 'RowSum[fixedBound 'X bound (N + 2)] 'i 'j
fixedBound 'X bound (N + 2)
::=
(when (0 =T= 'j) -->
nf('r : bool <- read ('Row['X 0]), return 'r, 'r))
;;
when neg (0 =T= 'j) -->
nf(('bj : bool <- read ('Row['X 'j])) 'r : bool <- read ('RowSum['X ('j -- 1)]),
    return (ap 'xor pair('r, 'bj)), 'r 'bj)
)
.

op knowColRowSumPartTwoNZ : -> Protocol .
eq knowColRowSumPartTwoNZ = 

(family 'ColSum[fixedBound 'X bound (N + 2)] 'i 'j
fixedBound 'X bound (N + 2)
::=
nf(('bi : bool <- read ('Col['X 'j])) 'bs : bool <- read ('ColSum[('X -- 1) 'j]), return (ap 'xor
    pair('bs, 'bi)), 'bs 'bi)
)
||
(
family 'RowSum[fixedBound 'X bound (N + 2)] 'i 'j
fixedBound 'X bound (N + 2)
::=
nf('c : bool <- read ('ColSum['X 'j]), return 'c, 'c)
)
.

strat revertShareSumInductiveAnd @ ProtocolConfig .
sd revertShareSumInductiveAnd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <-
        change fam ('ShareSum[bound (N + 1) fixedBound 'B])
        with
        (when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'B]), return 's, 's))
;;
(when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'B])) 'xs : bool <- read ('ShareSum[('m -- 1) 'B]), return (ap
    'xor pair('xs, 'xm)), 'xs 'xm)
)
        in P
       ] {CONG-NEW-NF{setupIndSSAnd}}
.       

strat symSqrBranchNZ @ ProtocolConfig .
sd symSqrBranchNZ :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using    
     SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <-
       change chn ('Sqr['Z])
       with
       nf(('x : bool <- read ('ShareSum['Z (fun 'wire0 'B)])) 
           'y : bool <- read ('ShareSum['Z (fun 'wire1 'B)]),
          return (ap 'and pair('x, 'y)), 'x 'y)
       in P]
       { applyRemoveMergeFromGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          )
       ;   
        substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'Sqr['Z], neg (0 =T= 'm),   
         nf(('xm : bool <- read ('Share['Z (fun 'wire0 'B)])) 
             'xs : bool <- read ('ShareSum[('Z -- 1) (fun 'wire0 'B)]), 
             return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
       )
       ; applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 'xs, 'as >> << 'xm, 'am >>  emptyQidPairList) 
       ; substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'Sqr['Z], neg (0 =T= 'm),   
         nf(('xm : bool <- read ('Share['Z (fun 'wire1 'B)])) 
             'xs : bool <- read ('ShareSum[('Z -- 1) (fun 'wire1 'B)]), 
             return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
       )  
       ; applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 'xs, 'ys >> << 'xm, 'yn >>
                         << 'as, 'xs >> << 'am, 'xn >>  emptyQidPairList) 
       ; applyDistribTwice(chn ('Sqr['Z]))                  
       ; changeOrder(chn ('Sqr['Z]), 'xs 'ys 'xn 'yn)                                  
       ; applyAddToGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          )
       }
.          

strat symSqrToClosedAnd @ ProtocolConfig .
sd symSqrToClosedAnd :=
 ***( to be removed and pointer
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        UNSAFE[
       Delta':ChannelContext <- Delta,
       O':Set{CNameBound} <- O,
       I':Set{CNameBound} <- I,
       A':Set{BoolTerm} <- A,
       P1:Protocol <-
        change fam ('Sqr[bound (N + 2)])
        with
        nf(
            ('x : bool <- read('ShareSum['i (fun 'wire0 'B)]) )
            ('y : bool <- read('ShareSum['i (fun 'wire1 'B)]) ),
            return (ap 'and pair('x, 'y)),
            'x 'y
        )
        in P
       ] 
 )  
 ***(
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (family ('Sqr[bound (N + 2)]) 'i bound (N + 2) ::=
nf(
 ('xs : bool <- read ('ShareSum['i (fun 'wire0 'B)]))
 ('ys : bool <- read ('ShareSum['i (fun 'wire1 'B)])),
 return ( ap 'and pair('xs, 'ys) ),
 'xs 'ys   
)
)
 'i 'Z,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P 'Sqr 'i 'Z A 
        (family 'Sqr[bound (N + 2)] 'i bound (N + 2) ::=
nf(
 ('xs : bool <- read ('ShareSum['i (fun 'wire0 'B)]))
 ('ys : bool <- read ('ShareSum['i (fun 'wire1 'B)])),
 return (ap 'and pair('xs, 'ys)),
 'xs 'ys   
)
)),
       P1:Protocol <- getInductionBase P 'Sqr 'i 'Z A 
       (family 'Sqr[bound (N + 2)] 'i bound (N + 2) ::=
nf(
 ('xs : bool <- read ('ShareSum['i (fun 'wire0 'B)]))
 ('ys : bool <- read ('ShareSum['i (fun 'wire1 'B)])),
 return (ap 'and pair('xs, 'ys)),
 'xs 'ys   
))
,
       A':Set{BoolTerm} <-  (A,'Z <T (N + 2))                
       ]    
       ;)
       
       CONG-NEW-NF{
       
       SINGLE-INDUCTION-new-R[
  idx:Qid <- 'Z,
  q:Qid <- 'i,
  cn:ChannelName <- 'Sqr,
  blist:List{Bounds} <- bound (N + 2),
  cases':Cases <- 
   nf(
 ('xs : bool <- read ('ShareSum['i (fun 'wire0 'B)]))
 ('ys : bool <- read ('ShareSum['i (fun 'wire1 'B)])),
 return (ap 'and pair('xs, 'ys)),
 'xs 'ys   
)
   ]{
       *** induction proof starts here
       CASE-DISTINCTION-channel[
        cn:ChannelName <- 'Sqr['Z]
       ]{
        substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'Sqr['Z], (0 =T= 'j), 
        nf('c : bool <- read ('Ctrb[0 0 'B]), return 'c, 'c)
        )
        ; substFamCaseChn(
        fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]), 
        'Sqr['Z], ('m =T= 'n), 
        nf(('x : bool <- read ('Share[0 (fun 'wire0 'B)])) 
            'y : bool <- read ('Share[0 (fun 'wire1 'B)]),
            return (ap 'and pair('x, 'y)), 'x 'y)
        )
        ; sym1SqrToAnd
        , 
        CASE-DISTINCTION-channel-end-when[
        cn:ChannelName <- 'Sqr['Z]
       ]{ applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 'bs, 's >> emptyQidPairList) 
        ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'Sqr['Z], neg (0 =T= 'j), 
        nf(('bj : bool <- read ('Ctrb['Z 'Z 'B])) 
            'bs : bool <- read ('Col['Z ('Z -- 1)]), 
            return (ap 'xor pair('bs, 'bj)), 'bs 'bj)
        ) 
        ; applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 'bs, 'bc >> << 's, 'bs >> << 'bj, 'b >> emptyQidPairList)
        ; applyMiddleXor( chn ('Sqr['Z]) )  
        
        *** add internals
        ; addInternalsDiagRefRowCol
        
        ; symRowColInSqr
        
        ; symRowColToInd
        
        ; rewriteDiagRef
        
        ; indRowColToClosed
        
        ; absorbFamilyDeleteEmpty( fam ('DiagRef[bound 'Z]) ) 
        
        *** now we do three substitutions in Sqr['Z]
        
        ; substNFFamilyOne(
          fam ('Sqr[bound 'Z]),
          'Sqr['Z],
          nf(('xs : bool <- read ('ShareSum[('Z -- 1) (fun 'wire0 'B)])) 
              'ys : bool <- read ('ShareSum[('Z -- 1) (fun 'wire1 'B)]), 
              return (ap 'and pair('xs, 'ys)), 'xs 'ys)
        )
        ; substNFFamilyOne(
          fam ('RowCol[bound 'Z]),
          'Sqr['Z],
          nf(('xn : bool <- read ('Share['Z (fun 'wire0 'B)])) 
             ('xs : bool <- read ('ShareSum[('Z -- 1) (fun 'wire0 'B)])) 
             ('yn : bool <- read ('Share['Z (fun 'wire1 'B)])) 
             'ys : bool <- read ('ShareSum[('Z -- 1) (fun 'wire1 'B)]), 
             return (ap 'xor pair(ap 'and pair('xs, 'yn), ap 'and pair('xn, 'ys))), 
             'xs 'ys 'xn 'yn)
        )
        ; substFamCaseChn(
        fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]), 
        'Sqr['Z], ('m =T= 'n),   
         nf(('x : bool <- read ('Share['Z (fun 'wire0 'B)])) 
             'y : bool <- read ('Share['Z (fun 'wire1 'B)]),
             return (ap 'and pair('x, 'y)), 'x 'y)
        )
        ; applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 'x, 'xn >> << 'y, 'yn >> emptyQidPairList)
        ; absorbFamilyDeleteEmpty( fam ('RowCol[bound 'Z]))
        *** slight rearrange
        ; applyDerivedXorRule(chn ('Sqr['Z])) 
        
        *** now the sym proof
        
        ; symSqrBranchNZ
        
        ; applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 'x, 'xs >> << 'y, 'ys >> emptyQidPairList)
        
        }
       }
       *** now we need Z on both branches, do a sym
       ; symZBranchNZSqr
       } *** end induction
       } *** end cong
.    

strat symZBranchNZSqr @ ProtocolConfig .
sd symZBranchNZSqr :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change 
       chn ('Sqr['Z])
       with nf(('xs : bool <- read ('ShareSum['Z (fun 'wire0 'B)])) 
                'ys : bool <- read ('ShareSum['Z (fun 'wire1 'B)]), 
                return (ap 'and pair('xs, 'ys)), 'xs 'ys)
       in P
       ] 
       {
       matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
       SYM[
       Delta1:ChannelContext <- Delta',
       O1:Set{CNameBound} <- O',
       P1:Protocol <- change 
        chn ('Sqr['Z])
        with
         (when ('Z =T= 0) --> 
          nf(('xs : bool <- read ('ShareSum['Z (fun 'wire0 'B)])) 
                'ys : bool <- read ('ShareSum['Z (fun 'wire1 'B)]), 
                return (ap 'and pair('xs, 'ys)), 'xs 'ys)
         )
         ;;
         (when neg('Z =T= 0) --> 
          nf(('xs : bool <- read ('ShareSum['Z (fun 'wire0 'B)])) 
                'ys : bool <- read ('ShareSum['Z (fun 'wire1 'B)]), 
                return (ap 'and pair('xs, 'ys)), 'xs 'ys)
         )
         
        in P'
        ]
        {applyAllSameCases(chn ('Sqr['Z]))}
        ; CASE-DISTINCTION-channel[
        cn:ChannelName <- 'Sqr['Z]
       ]{applyAlphaAssumChn('Sqr['Z], 'Z), idle}
       }
.

  

strat symRowColToInd @ ProtocolConfig .
sd symRowColToInd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change  
          fam ('RowCol[bound 'Z])
        with  
        
        (when ('i =T= 0) --> 
         nf('d : bool <- read ('DiagRef[0]), return 'd, 'd)
        )
        ;;
        (when neg ('i =T= 0) -->
         nf(
           ('bs : bool <- read ('RowCol['i -- 1]))
           ('bi : bool <- read ('DiagRef['i])),
           return (ap 'xor pair('bs, 'bi)),
           'bs 'bi 
         )
        )
        
        in P
       ]
       { 
        ***(
       matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (family 'RowCol[bound (N + 1)] 'i
bound (N + 1)
::=
nf(('bc : bool <- read ('Col['Z 'i])) 'br : bool <- read ('Row['i 'Z]), return (ap 'xor pair('br,
    'bc)), 'br 'bc)
) 'i 'M,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P 'RowCol 'i 'M A 
        (family 'RowCol[bound (N + 1)] 'i
bound (N + 1)
::=
nf(('bc : bool <- read ('Col['Z 'i])) 'br : bool <- read ('Row['i 'Z]), return (ap 'xor pair('br,
    'bc)), 'br 'bc)
)),
       P1:Protocol <- getInductionBase P 'RowCol 'i 'M A 
       (family 'RowCol[bound (N + 1)] 'i
bound (N + 1)
::=
nf(('bc : bool <- read ('Col['Z 'i])) 'br : bool <- read ('Row['i 'Z]), return (ap 'xor pair('br,
    'bc)), 'br 'bc)
),
       A':Set{BoolTerm} <-  (A,'M <T (N + 1))                
       ] ;)
       CONG-NEW-NF{
       SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'i,
  cn:ChannelName <- 'RowCol,
  blist:List{Bounds} <- bound 'Z,
  cases':Cases <- 
   nf(('bc : bool <- read ('Col['Z 'i])) 'br : bool <- read ('Row['i 'Z]), 
       return (ap 'xor pair('br, 'bc)), 'br 'bc)
   ]{
       *** ind proof
       CASE-DISTINCTION-channel[
        cn:ChannelName <- 'RowCol['M]
       ]
       {
       substNFFamilyOne(
        fam ('DiagRef[bound 'Z]),
        'RowCol['M],
        nf( ('b : bool  <-  read ('Ctrb[0 'Z 'B]))
            ('sb : bool  <- read ('Ctrb['Z 0 'B])),
             return (ap 'xor pair('b, 'sb)), 'b 'sb)
       )
       ; symRowColZero 
       ,
       CASE-DISTINCTION-channel-end-when[
       cn:ChannelName <- 'RowCol['M]
       ]{
          substNFFamilyOne(
           fam ('RowCol[bound 'M]),
           'RowCol['M],
           nf(('bc : bool <- read ('Col['Z ('M -- 1)])) 
               'br : bool <- read ('Row[('M -- 1) 'Z]), 
               return (ap 'xor pair('br, 'bc)), 'br 'bc)
          )
          ;
          substNFFamilyOne(
        fam ('DiagRef[bound 'Z]),
        'RowCol['M],
        nf( ('b : bool  <-  read ('Ctrb['M 'Z 'B]))
            ('sb : bool  <- read ('Ctrb['Z 'M 'B])),
             return (ap 'xor pair('b, 'sb)), 'b 'sb)
       )
       ; applyRearrangeXor(chn ('RowCol['M]))
       ; symRowColNZero
       }
       }
       ; applyAllSameCases(chn ('RowCol['M]))
     }  
     }
     }
.  

 strat symRowColNZero @ ProtocolConfig .
 sd symRowColNZero :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change chn ('RowCol['M])
        with
        nf( ('br : bool  <-  read ('Row['M 'Z ]))
            ('bc : bool  <- read ('Col['Z 'M ])),
             return (ap 'xor pair('br, 'bc)), 'br 'bc)
        in P
       ] 
       { substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowCol['M], neg (0 =T= 'i), 
        nf(('bi : bool <- read ('Ctrb['M 'Z 'B])) 
            'r : bool <- read ('Row[('M -- 1) 'Z]), 
            return (ap 'xor  pair('r, 'bi)), 'r 'bi)
      )
      ; applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'r, 'br >> << 'bi, 'b >> emptyQidPairList) 
      ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowCol['M], neg (0 =T= 'j), 
     nf(('bj : bool <- read ('Ctrb['Z 'M 'B])) 
         'bs : bool <- read ('Col['Z ('M -- 1)]), 
         return (ap 'xor pair('bs, 'bj)), 'bs 'bj)
      )  
      ; applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'bs, 'bc >> << 'bj, 'sb >> emptyQidPairList)     
      ; changeOrder(chn ('RowCol['M]), 'br 'bc 'b 'sb) 
      }                             
  .     

 strat symRowColZero @ ProtocolConfig .
 sd symRowColZero :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change chn ('RowCol['M])
        with
        nf( ('br : bool  <-  read ('Row['M 'Z ]))
            ('bc : bool  <- read ('Col['Z 'M ])),
             return (ap 'xor pair('br, 'bc)), 'br 'bc)
        in P
       ] 
       { substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowCol['M], (0 =T= 'i), 
        nf('c : bool <- read ('Ctrb[0 'Z 'B]), return 'c, 'c)
       )
       ; applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'c, 'b >> emptyQidPairList) 
       ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowCol['M], (0 =T= 'j), 
        nf('c : bool <- read ('Ctrb['Z 0 'B]), return 'c, 'c)
       )  
       ; applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'c, 'sb >> emptyQidPairList)  
       }                  
 .

strat rewriteDiagRef @ ProtocolConfig .
sd rewriteDiagRef := 
CONG-NEW-NF{
   substFamCaseFam(
        fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]), 
        fam ('DiagRef[bound 'Z]) , ('n <T 'm), 
        nf('s : bool <- read ('SendBit['i 'Z 'B]), return 's, 's)
       ) 
   
   ; substFamCaseFam(
        fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]), 
        fam ('DiagRef[bound 'Z]) , ('m <T 'n), 
        nf('r : bool <- read ('RcvdBit['Z 'i 'B]), return 'r, 'r)
       ) 
       
   ; substNFFamiliesGen(
      fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),
      fam ('DiagRef[bound 'Z]) ,
   
     nf(('b : bool <- read ('SendBit['i 'Z 'B])) 
       ('xm : bool <- read ('Share['i (fun 'wire0 'B)])) 
       ('xn : bool <- read ('Share['Z (fun 'wire0 'B)])) 
       ('ym : bool <- read ('Share['i (fun 'wire1 'B)])) 
        'yn : bool <- read ('Share['Z (fun 'wire1 'B)]), 
        return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn), 
                                          ap 'and pair('xn, 'ym)), 'b)
               ), 
        'b 'xm 'ym 'xn 'yn)
   )     
   ; applyReturnCommXor(
      fam ('DiagRef[bound 'Z])
   )                         
   ; applyReturnIdemRev(fam ('DiagRef[bound 'Z]))
   
   ; applyDropSubsumeCase(
       fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]), 
      fam ('DiagRef[bound 'Z]), ('n <T 'm)
     )
      
   
}      
.

strat indRowColToClosed @ ProtocolConfig .
sd indRowColToClosed :=
***(
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (
family 'RowCol[bound 'Z] 'i
bound 'Z
::=
nf(
   ('xs : bool <- read ('ShareSum['i (fun 'wire0 'B)]))
  ('ys : bool <- read ('ShareSum['i (fun 'wire1 'B)]))
  ('xn : bool <- read ('Share['Z (fun 'wire0 'B)]))
  ('yn : bool <- read ('Share['Z (fun 'wire1 'B)])),
  return (ap 'xor pair(
               ap 'and pair('xs, 'yn),
               ap 'and pair('xn, 'ys)
            )),
  'xs 'ys 'xn 'yn
)
) 'i 'M,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P 'RowCol 'i 'M A 
        (
family 'RowCol[bound 'Z] 'i
bound 'Z
::=
nf(
   ('xs : bool <- read ('ShareSum['i (fun 'wire0 'B)]))
  ('ys : bool <- read ('ShareSum['i (fun 'wire1 'B)]))
  ('xn : bool <- read ('Share['Z (fun 'wire0 'B)]))
  ('yn : bool <- read ('Share['Z (fun 'wire1 'B)])),
  return (ap 'xor pair(
               ap 'and pair('xs, 'yn),
               ap 'and pair('xn, 'ys)
            )),
  'xs 'ys 'xn 'yn
)
)
        ),
       P1:Protocol <- getInductionBase P 'RowCol 'i 'M A 
       (
family 'RowCol[bound 'Z] 'i
bound 'Z
::=
nf(
  ('xs : bool <- read ('ShareSum['i (fun 'wire0 'B)]))
  ('ys : bool <- read ('ShareSum['i (fun 'wire1 'B)]))
  ('xn : bool <- read ('Share['Z (fun 'wire0 'B)]))
  ('yn : bool <- read ('Share['Z (fun 'wire1 'B)])),
  return (ap 'xor pair(
               ap 'and pair('xs, 'yn),
               ap 'and pair('xn, 'ys)
            )),
  'xs 'ys 'xn 'yn
)
),
       A':Set{BoolTerm} <-  (A,'M <T 'Z)                
       ]
       ;
       )
      CONG-NEW-NF{ 
       SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'i,
  cn:ChannelName <- 'RowCol,
  blist:List{Bounds} <- bound 'Z,
  cases':Cases <- 
   nf(
  ('xs : bool <- read ('ShareSum['i (fun 'wire0 'B)]))
  ('ys : bool <- read ('ShareSum['i (fun 'wire1 'B)]))
  ('xn : bool <- read ('Share['Z (fun 'wire0 'B)]))
  ('yn : bool <- read ('Share['Z (fun 'wire1 'B)])),
  return (ap 'xor pair(
               ap 'and pair('xs, 'yn),
               ap 'and pair('xn, 'ys)
            )),
  'xs 'ys 'xn 'yn
)
   ]{
       *** ind proof here
       CASE-DISTINCTION-channel[
        cn:ChannelName <- 'RowCol['M]
        ]{
        substNFFamilyOne(
        fam ('DiagRef[bound 'Z]),
        'RowCol['M],
        nf(('xm : bool <- read ('Share[0 (fun 'wire0 'B)])) 
           ('xn : bool <- read ('Share['Z (fun 'wire0 'B)])) 
           ('ym : bool <- read ('Share[0 (fun 'wire1 'B)])) 
           'yn : bool <- read ('Share['Z (fun 'wire1 'B)]), 
           return (ap 'xor pair(ap 'and pair('xm, 'yn), ap 'and pair('xn, 'ym))), 
           'xm 'ym 'xn 'yn)
        )
        ; symBranch1RowColAnd
        ,
        CASE-DISTINCTION-channel-end-when[
        cn:ChannelName <- 'RowCol['M]
        ]{
         substNFFamilyOne(
        fam ('DiagRef[bound 'Z]),
        'RowCol['M],
        nf(('xm : bool <- read ('Share['M (fun 'wire0 'B)])) 
           ('xn : bool <- read ('Share['Z (fun 'wire0 'B)])) 
           ('ym : bool <- read ('Share['M (fun 'wire1 'B)])) 
           'yn : bool <- read ('Share['Z (fun 'wire1 'B)]), 
           return (ap 'xor pair(ap 'and pair('xm, 'yn), ap 'and pair('xn, 'ym))), 
           'xm 'ym 'xn 'yn)
        )
        ; applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'xm, 'xi >> << 'ym, 'yi >> 
                         emptyQidPairList)
        ; substNFFamilyOne(
        fam ('RowCol[bound 'M]),
        'RowCol['M],
        nf(
  ('xs : bool <- read ('ShareSum[('M -- 1) (fun 'wire0 'B)]))
  ('ys : bool <- read ('ShareSum[('M -- 1) (fun 'wire1 'B)]))
  ('xn : bool <- read ('Share['Z (fun 'wire0 'B)]))
  ('yn : bool <- read ('Share['Z (fun 'wire1 'B)])),
  return (ap 'xor pair(
               ap 'and pair('xs, 'yn),
               ap 'and pair('xn, 'ys)
            )),
  'xs 'ys 'xn 'yn
)
        )  
        ; applyRearrangeXor(chn ('RowCol['M]))                
        ; applyDerivedXorAndRule(chn ('RowCol['M]))  
        ; symBranch2RowColAnd               
        }
        }
        ; applyAllSameCases(chn ('RowCol['M])) 
  } *** ind
  } *** cong
.

strat symBranch2RowColAnd @ ProtocolConfig .
sd symBranch2RowColAnd :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <-
       change chn ('RowCol['M])
       with nf(
  ('xs : bool <- read ('ShareSum['M (fun 'wire0 'B)]))
  ('ys : bool <- read ('ShareSum['M (fun 'wire1 'B)]))
  ('xn : bool <- read ('Share['Z (fun 'wire0 'B)]))
  ('yn : bool <- read ('Share['Z (fun 'wire1 'B)])),
  return (ap 'xor pair(
               ap 'and pair('xs, 'yn),
               ap 'and pair('xn, 'ys)
            )),
  'xs 'ys 'xn 'yn
)
       in P
       ] 
       {
       applyRemoveMergeFromGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          )
       ;   
        substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'RowCol['M], neg (0 =T= 'm),   
         nf(('xm : bool <- read ('Share['M (fun 'wire0 'B)])) 
             'xs : bool <- read ('ShareSum[('M -- 1) (fun 'wire0 'B)]), 
             return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
    )
    ;  applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'xs, 'as >> << 'xm, 'am >> emptyQidPairList) 
    ;   
        substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'RowCol['M], neg (0 =T= 'm),   
         nf(('xm : bool <- read ('Share['M (fun 'wire1 'B)])) 
             'xs : bool <- read ('ShareSum[('M -- 1) (fun 'wire1 'B)]), 
             return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
    )
    ;  applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'xs, 'cs >> << 'xm, 'cm >> emptyQidPairList) 
    ;  applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'am, 'xi >> << 'as, 'xs >>
                         << 'cm, 'yi >> << 'cs, 'ys >> emptyQidPairList)  
    ; changeOrder(chn ('RowCol['M]), 'xs 'ys 'xi 'yi 'xn 'yn)
    ; applyAddToGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          ) 
     }      
.       

strat symBranch1RowColAnd @ ProtocolConfig .
sd symBranch1RowColAnd :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <-
       change chn ('RowCol['M])
       with nf(
  ('xs : bool <- read ('ShareSum['M (fun 'wire0 'B)]))
  ('ys : bool <- read ('ShareSum['M (fun 'wire1 'B)]))
  ('xn : bool <- read ('Share['Z (fun 'wire0 'B)]))
  ('yn : bool <- read ('Share['Z (fun 'wire1 'B)])),
  return (ap 'xor pair(
               ap 'and pair('xs, 'yn),
               ap 'and pair('xn, 'ys)
            )),
  'xs 'ys 'xn 'yn
)
       in P
       ] 
       { applyRemoveMergeFromGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          )
       ; substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'RowCol['M], (0 =T= 'm), 
        nf('s : bool <- read ('Share[0 (fun 'wire0 'B)]), return 's, 's)
        )  
       ; applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 's, 'xs >> emptyQidPairList) 
       ; substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'RowCol['M], (0 =T= 'm), 
        nf('s : bool <- read ('Share[0 (fun 'wire1 'B)]), return 's, 's)
        )  
       ; applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 's, 'ys >> << 'xs, 'xm >> << 'ys, 'ym >> emptyQidPairList)
       ; applyAddToGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          ) 
       }     
.

strat dropWithCase @ ProtocolConfig .
 sd dropWithCase :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{dropWithCase} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B])) 
          (fam ('DiagRef[bound 'Z])), 
        P1:Protocol <- keepTwo P 
          (fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B])) 
          (fam ('DiagRef[bound 'Z]))
        ]{
         select-case-subst-family[
           bt:BoolTerm <- ('n <T 'm)
         ]{
         applyDropNFFamilies(
      fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]), 
      fam ('DiagRef[bound 'Z])
     )
         }
       }
             )
 . 

strat symRowColInSqr @ ProtocolConfig .
sd symRowColInSqr :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change 
       chn ('Sqr['Z])
       with 
       nf(('b : bool <- read ('Ctrb['Z 'Z 'B])) 
          ('brc : bool <- read ('RowCol['Z -- 1])) 
          'bs : bool <- read ('Sqr['Z -- 1]), 
          return (ap 'xor pair(ap 'xor pair('bs, 'brc), 
                               'b)), 
          'bs 'brc 'b)
       in P
       ] 
       { substNFFamilyOne(
         fam ('RowCol[bound 'Z]),
         'Sqr['Z],
         nf( ('br : bool  <-  read ('Row[('Z -- 1) 'Z ]))
              ('bc : bool  <- read ('Col['Z ('Z -- 1) ])),
             return (ap 'xor pair('br, 'bc)), 'br 'bc)
       )
       }
.       

strat addInternalsDiagRefRowCol @ ProtocolConfig .
 sd addInternalsDiagRefRowCol := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'DiagRef
         typed bool
         params ('i)
                (bound 'Z)  
         assigned
          nf( ('b : bool  <-  read ('Ctrb['i 'Z 'B]))
              ('sb : bool  <- read ('Ctrb['Z 'i 'B])),
             return (ap 'xor pair('b, 'sb)), 'b 'sb)
         in (
         addInternalFamily
           'RowCol
         typed bool
         params ('i)
                (bound 'Z)   
         assigned
          nf( ('br : bool  <-  read ('Row['i 'Z ]))
              ('bc : bool  <- read ('Col['Z 'i ])),
             return (ap 'xor pair('br, 'bc)), 'br 'bc)
         in P)
        ]{
            absorbFamilyDeleteEmpty( fam ('RowCol[bound 'Z]) )
          ; absorbFamilyDeleteEmpty( fam ('DiagRef[bound 'Z]) )
        }  

. 

strat sym1SqrToAnd @ ProtocolConfig .
sd sym1SqrToAnd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change 
        chn ('Sqr['Z])
        with nf(
 ('xs : bool <- read ('ShareSum[0 (fun 'wire0 'B)]))
 ('ys : bool <- read ('ShareSum[0 (fun 'wire1 'B)])),
 return (ap 'and pair('xs, 'ys)),
 'xs 'ys   
)
        in P
       ] 
       {  applyRemoveMergeFromGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          )
       ; substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'Sqr['Z], (0 =T= 'm), 
        nf('s : bool <- read ('Share[0 (fun 'wire0 'B)]), return 's, 's)
        )
       ; applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 's, 'x >> emptyQidPairList) 
       ; substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'Sqr['Z], (0 =T= 'm), 
        nf('s : bool <- read ('Share[0 (fun 'wire1 'B)]), return 's, 's)
        )
        ; applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 's, 'y >> emptyQidPairList)  
       ;  applyAddToGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          )  
       }    
.     

strat symSqrToInductive @ ProtocolConfig .
sd symSqrToInductive :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <-
        change fam ('Sqr[bound (N + 2)])
        with
        (when ('i =T= 0) --> 
         nf('c : bool <- read ('Col[0 0]), return 'c, 'c)
        )
        ;;
        (when neg ('i =T= 0) -->
         nf( ('bs : bool <- read('Sqr['i -- 1]) ) 
             ('br : bool <- read('Row[('i -- 1) 'i]) )
             ('bc : bool <- read('Col['i 'i]) ),
             return (ap 'xor pair( ap 'xor pair('bs, 'br), 'bc)),
             'bs 'br 'bc  
           )
        )
        in P
       ] 
       {
       ***(
       matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (family 'Sqr[bound (N + 2)] 'i bound (N + 2) ::=
            nf('c : bool <- read ('ColSum['i 'i]), return 'c, 'c)
          ) 'i 'B,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P 'Sqr 'i 'B A 
         (family 'Sqr[bound (N + 2)] 'i bound (N + 2) ::=
            nf('c : bool <- read ('ColSum['i 'i]), return 'c, 'c)
          ) ),
       P1:Protocol <- getInductionBase P 'Sqr 'i 'B A 
          (family 'Sqr[bound (N + 2)] 'i bound (N + 2) ::=
            nf('c : bool <- read ('ColSum['i 'i]), return 'c, 'c)
          ) ,
       A':Set{BoolTerm} <-  (A,'B <T N + 2)                
       ] ;
       )
       CONG-NEW-NF{
       SINGLE-INDUCTION-new-R[
  idx:Qid <- 'B,
  q:Qid <- 'i,
  cn:ChannelName <- 'Sqr,
  blist:List{Bounds} <- bound (N + 2),
  cases':Cases <- 
   nf('c : bool <- read ('ColSum['i 'i]), return 'c, 'c)
              ]
       {
       *** ind proof
       CASE-DISTINCTION-channel[
        cn:ChannelName <- 'Sqr['B]
       ]{
       symSqrIndZero, 
       CASE-DISTINCTION-channel-end-when[
        cn:ChannelName <- 'Sqr['B]
       ]{
       symSqrIndNZero
       }}
       *** wrap it up with a sym proof
       ; symMergeBranchesSqr
       }
       }
       }
.   

*** I shouldn't need to do this, investigate why
strat symMergeBranchesSqr @ ProtocolConfig .
sd symMergeBranchesSqr :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change chn ('Sqr['B])
       with nf('c : bool <- read ('ColSum['B 'B]), return 'c, 'c)
       in P
       ] 
       {
       matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
       SYM[
       Delta1:ChannelContext <- Delta',
       O1:Set{CNameBound} <- O',
       P1:Protocol <- change chn ('Sqr['B])
       with 
       (when ('B =T= 0) -->
       nf('c : bool <- read ('ColSum['B 'B]), return 'c, 'c)
       )
       ;; 
       (when neg ('B =T= 0) -->
       nf('c : bool <- read ('ColSum['B 'B]), return 'c, 'c)
       )
       in P'
       ]{
       applyAllSameCases(chn ('Sqr['B]))
       }
       ;
       CASE-DISTINCTION-channel[
        cn:ChannelName <- 'Sqr['B]
       ]{
        applyAlphaAssumChn('Sqr['B], 'B),
       idle
       }
       }
.

strat symSqrIndNZero @ ProtocolConfig .
sd symSqrIndNZero :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
         SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change chn ('Sqr['B])
       with nf('c : bool <- read ('ColSum['B 'B]), return 'c, 'c)
       in P
       ]
       {
       substFamCaseChn(
        fam ('ColSum[bound (N + 2) bound (N + 2)]), 
        'Sqr['B], neg (0 =T= 'i), 
        nf(('bi : bool <- read ('Col['B 'B])) 
            'bs : bool <- read ('ColSum[('B -- 1) 'B]), 
            return (ap 'xor  pair('bs, 'bi)), 'bs 'bi)
        ) 
        ; unsafeColSumClosed
        ; substNFFamilyOne(fam ('ColSum[bound (N + 2) bound (N + 2)]),
          'Sqr['B],
          nf('r : bool <- read ('RowSum[('B -- 1) 'B]), return 'r, 'r)
         )
        ; substFamCaseChn(
        fam ('RowSum[bound (N + 2) bound (N + 2)]), 
        'Sqr['B], neg (0 =T= 'j), 
     nf(('bj : bool <- read ('Row[('B -- 1) 'B])) 
         'r : bool <- read ('RowSum[('B -- 1) ('B -- 1)]), 
         return (ap 'xor pair('r, 'bj)), 'r 'bj)
      ) 
        ; symColToRowNZ  
        ; applyAlphaNFPr(
            chn ('Sqr['B]), 
                         << 'bi, 'bc >> << 'bj, 'br >> << 'r, 'bs >> emptyQidPairList)
        ; changeOrder( chn ('Sqr['B]), 'bs 'br 'bc )                    
        ; unsafeColSumInductive
        }
.          

strat symColToRowNZ @ ProtocolConfig .
sd symColToRowNZ :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
         SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change chn ('Sqr['B])
       with  nf(('bi : bool <- read ('Col['B 'B])) 
             ('bj : bool <- read ('Row[('B -- 1) 'B])) 
              'r : bool <- read ('Sqr['B -- 1]), 
              return (ap 'xor pair(ap 'xor pair('r, 'bj), 'bi)), 'bj 'r 'bi)
       in P       
       ]
       {
       substNFFamilyOne(
       fam ('Sqr[bound 'B]),
       'Sqr['B],
       nf('c : bool <- read ('ColSum[('B -- 1)('B -- 1)]), return 'c, 'c)
       )
       ;
       substNFFamilyOne(
       fam ('ColSum[bound (N + 2) bound (N + 2)]), 
       'Sqr['B],
       nf('r : bool <- read ('RowSum[('B -- 1) ('B -- 1)]),
          return 'r, 'r)
       )
       }
       
.

strat symSqrIndZero @ ProtocolConfig .
sd symSqrIndZero :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change chn ('Sqr['B])
       with nf('c : bool <- read ('ColSum[0 0]), return 'c, 'c)
       in P
       ]
       { substFamCaseChn(
        fam ('ColSum[bound (N + 2) bound (N + 2)]), 
        'Sqr['B], (0 =T= 'i), 
        nf('c : bool <- read ('Col[0 0]), return 'c, 'c)
        ) 
       } 
       
.

strat unsafeColSumClosed @ ProtocolConfig .
sd unsafeColSumClosed :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        UNSAFE[
       Delta':ChannelContext <- Delta,
       O':Set{CNameBound} <- O,
       I':Set{CNameBound} <- I,
       A':Set{BoolTerm} <- A,
       P1:Protocol <- 
       change fam ('ColSum[bound (N + 2) bound (N + 2)])
       with 
        nf('r : bool <- read ('RowSum['i 'j]), return 'r, 'r)
       in P
       ]
.

strat unsafeColSumInductive @ ProtocolConfig .
sd unsafeColSumInductive :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        UNSAFE[
       Delta':ChannelContext <- Delta,
       O':Set{CNameBound} <- O,
       I':Set{CNameBound} <- I,
       A':Set{BoolTerm} <- A,
       P1:Protocol <- 
       change fam ('ColSum[bound (N + 2) bound (N + 2)])
       with 
       (when (0 =T= 'i) -->
nf('c : bool <- read ('Col[0 'j]), return 'c, 'c))
;;
(when neg (0 =T= 'i) -->
nf(('bi : bool <- read ('Col['i 'j])) 'bs : bool <- read ('ColSum[('i -- 1) 'j]),
    return (ap 'xor pair('bs, 'bi)), 'bs 'bi)
)    
       in P
       ]
.

strat symSqrInSSNPlus1 @ ProtocolConfig .
  sd symSqrInSSNPlus1 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf('c : bool  <- read ('Sqr[N + 1]),
             return 'c, 'c)
        in P
        ]
        { substNFFamilyOne(
          fam ('Sqr[bound (N + 2)]),
          'ShareSum[(N + 1) 'B],
          nf('c : bool  <- read ('ColSum[(N + 1)(N + 1)]),
             return 'c, 'c))
        }
  .

strat addSqr @ ProtocolConfig .
sd addSqr :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'Sqr
         typed bool
         params ('i)
                (bound (N + 2))
         assigned
          nf('c : bool  <- read ('ColSum['i 'i]),
             return 'c, 'c)
         in P]{
         absorbFamily( fam ('Sqr[(bound (N + 2))]) )
         }
 .        

strat unsafeIndStepAnd @ ProtocolConfig .
sd unsafeIndStepAnd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        UNSAFE[
       Delta':ChannelContext <- Delta,
       O':Set{CNameBound} <- O,
       I':Set{CNameBound} <- I,
       A':Set{BoolTerm} <- A,
       P1:Protocol <- change
         fam ('ColSum[fixedBound 'X bound (N + 2)])
        with
         nf('r : bool <- read ('RowSum['X 'j]), return 'r, 'r)
        in
        P
       ] 
.       

op wantColRowSumPartTwo : -> Protocol .
eq wantColRowSumPartTwo = 
(family 'ColSum[fixedBound 'X bound (N + 2)] 'i 'j
fixedBound 'X bound (N + 2)
::=
nf('r : bool <- read ('RowSum['X 'j]), return 'r, 'r)
)
||
(family 'RowSum[fixedBound 'X bound (N + 2)] 'i 'j
fixedBound 'X bound (N + 2)
::=
(when (0 =T= 'j) -->
nf('r : bool <- read ('Row['X 0]), return 'r, 'r))
;;
when neg (0 =T= 'j) -->
nf(('bj : bool <- read ('Row['X 'j])) 'r : bool <- read ('RowSum['X ('j -- 1)]),
    return (ap 'xor pair('r, 'bj)), 'r 'bj)
)
.

strat setupIndSymPartTwo @ ProtocolConfig .
sd setupIndSymPartTwo :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
       fam ('Comp['RowSum 'ColSum][fixedBound 'X bound (N + 2)])
       with wantColRowSumPartTwo
       in P
       ]
       { setupIndColRowPartTwo }
 .       

op knowColRowSumPartTwo : -> Protocol .
eq knowColRowSumPartTwo = 
 (family 'RowSum[fixedBound 'X bound (N + 2)]
    'i 'j
fixedBound 'X bound (N + 2)
::=
nf('c : bool <- read ('ColSum[0 'j]), return 'c, 'c)
)
||
(family 'ColSum[fixedBound 'X bound (N + 2)]
    'i 'j
fixedBound 'X bound (N + 2)
::=
nf('c : bool <- read ('Col[0 'j]), return 'c, 'c)
)
.

strat symColSumSameCasesPartTwo @ ProtocolConfig .
sd symColSumSameCasesPartTwo :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ColSum['X 'Y])
        with
         (when ('Y =T= 0) --> 
           nf('r : bool <- read ('RowSum['X 'Y]), return 'r, 'r))
         ;;
         (when neg ('Y =T= 0) --> 
           nf('r : bool <- read ('RowSum['X 'Y]), return 'r, 'r))
        in P
        ]{applyAllSameCases(chn ('ColSum['X 'Y]))}
.        

strat setupIndColRowPartTwo @ ProtocolConfig .
sd setupIndColRowPartTwo := ***(
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          knowColRowSumPartTwo 'j 'Y,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P ('Comp['RowSum 'ColSum]) 'j 'Y A knowColRowSumPartTwo),
       P1:Protocol <- getInductionBase P ('Comp['RowSum 'ColSum]) 'j 'Y A knowColRowSumPartTwo,
       A':Set{BoolTerm} <-  (A,'Y <T (N + 2))
       ] 
       ;)
       SINGLE-INDUCTION-new[
  idx:Qid <- 'Y,
  q:Qid <- 'j,
  cn:ChannelName <- 'Comp['RowSum 'ColSum],
  P2:Protocol <- knowColRowSumPartTwo
 ]{ 
       *** induction starts here
         symColSumSameCasesPartTwo
       ; applyMergeCasesChannelGroup('RowSum['X 'Y], 'ColSum['X 'Y])
       ; CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'CGroup
       ]{
       substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'i), 
        nf('c : bool <- read ('Ctrb[0 0 'B]), return 'c, 'c)
      )
       ; symRowToCol0Part2
       ; substNF('RowSum['X 'Y], 'ColSum['X 'Y])
       ; symRowToColSum0Part2
       ; applyAlphaAssumChn('RowSum['X 'Y], 'X)
      , CASE-DISTINCTION-one-end-when[
          fns:NameWithScripts <- 'CGroup
       ]{
         substNFFamilyOne(
         fam ('RowSum[fixedBound 'X bound 'Y]),
         'RowSum['X 'Y], 
         nf('c : bool <- read ('ColSum[0 ('Y -- 1)]), return 'c, 'c)
        ) 
        ; substNFFamilyOne(
         fam ('ColSum[fixedBound 'X bound 'Y]),
         'RowSum['X 'Y], 
         nf('c : bool <- read ('Col[0 ('Y -- 1)]), return 'c, 'c)
        ) 
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                         << 'c, 'bs >> emptyQidPairList)
        ; substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'i), 
        nf('c : bool <- read ('Ctrb[0 'Y 'B]), return 'c, 'c)
      ) 
      ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                         << 'c, 'bj >> emptyQidPairList) 
      ; symRowToColSumNzPart2                
      ; substNF('RowSum['X 'Y], 'ColSum['X 'Y])
      ; lastSymBaseCase
      ; applyAlphaAssumChn('RowSum['X 'Y], 'X)
      ; applyAlphaAssumChn('ColSum['X 'Y], 'X)
        }   
       }
      ; applyAllSameCases(fam ('CGroup[nil]))
      ; applyDropName(fam ('CGroup[nil]))
  }
 . 
 
strat lastSymBaseCase @ ProtocolConfig .
sd lastSymBaseCase :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
       chn ('RowSum['X 'Y]) with 
       nf('c : bool <- read ('ColSum['X 'Y]), return 'c, 'c)
       in P          
       ]{
       substNF('ColSum['X 'Y], 'RowSum['X 'Y])}
.  

strat symRowToColSumNzPart2 @ ProtocolConfig .
sd symRowToColSumNzPart2 := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
       chn ('RowSum['X 'Y]) with 
       nf('c : bool <- read ('Col['X 'Y]), return 'c, 'c)
       in P          
       ]
       { substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'j), 
     nf(('bj : bool <- read ('Ctrb['X 'Y 'B])) 
         'bs : bool <- read ('Col['X ('Y -- 1)]), 
         return (ap 'xor pair('bs, 'bj)), 'bs 'bj)
      )
      ; applyAlphaAssumChn('RowSum['X 'Y], 'X)
      } 
.

strat symRowToColSum0Part2 @ ProtocolConfig .
sd symRowToColSum0Part2 := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
        Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
       chn ('RowSum['X 'Y]) with 
       nf('c : bool <- read ('ColSum['X 'Y]), return 'c, 'c)
       in P          
       ]
       { substNF('ColSum['X 'Y], 'RowSum['X 'Y])
       }
.
 
strat symRowToCol0Part2 @ ProtocolConfig .
sd symRowToCol0Part2 := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
        Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
       chn ('RowSum['X 'Y]) with 
       nf('c : bool <- read ('Col[0 'Y]), return 'c, 'c)
       in P          
       ]
       {
       substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'j), 
        nf('c : bool <- read ('Ctrb[0 0 'B]), return 'c, 'c)
      )}
.

strat setupIndColRow @ ProtocolConfig .
sd setupIndColRow := ***(
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          wantColRowSum 'i 'X,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P ('Comp['RowSum 'ColSum]) 'i 'X A wantColRowSum),
       P1:Protocol <- getInductionBase P ('Comp['RowSum 'ColSum]) 'i 'X A wantColRowSum,
       A':Set{BoolTerm} <-  (A,'X <T (N + 2))
       ] ;  )
       
       SINGLE-INDUCTION-new[
  idx:Qid <- 'X,
  q:Qid <- 'i,
  cn:ChannelName <- 'Comp['RowSum 'ColSum],
  P2:Protocol <- wantColRowSum
 ]
{
        *** RowSum stays unchanged, so this distinction is fine here!
       CASE-DISTINCTION-one-R[
        fns:NameWithScripts <- 'ColSum,
        blist:List{Bounds} <- fixedBound 'X bound (N + 2)
       ]
       {
       *** 'X = 0
        addRowSumGroup
  *** part one, induction
; setupIndRowPartOneZeroCase
; applyDropName(fam ('HiddenGroup[bound 'X bound (N + 2)]) )
*** now we get to part two, another induction
; applyGroupFamiliesNew(
    fam ('RowSum[fixedBound 'X bound (N + 2)]), 
    fam ('ColSum[fixedBound 'X bound (N + 2)])
  )
  *** sym + ind
; setupIndSymPartTwo  
; applyUngroupFamiliesNew(
    fam ('RowSum[fixedBound 'X bound (N + 2)]), 
    fam ('ColSum[fixedBound 'X bound (N + 2)])
  )
       ,
       CASE-DISTINCTION-one-R-end-when[
        fns:NameWithScripts <- 'ColSum,
        blist:List{Bounds} <- fixedBound 'X bound (N + 2)
       ]
       { *** was unsafeindstepand
       
       *** again the hack to make induction work
  addRowSumGroup
  
 *** part one, induction
; setupIndRowPartOneNZCase

; applyDropName(fam ('HiddenGroup[bound 'X bound (N + 2)]) )
*** now we get to part two, another induction
; applyGroupFamiliesNew(
    fam ('RowSum[fixedBound 'X bound (N + 2)]), 
    fam ('ColSum[fixedBound 'X bound (N + 2)])
  )

; setupIndColRowPartTwoNZ  
; applyUngroupFamiliesNew(
    fam ('RowSum[fixedBound 'X bound (N + 2)]), 
    fam ('ColSum[fixedBound 'X bound (N + 2)])
  )
       
       }
       }
       ; applyAllSameCases(fam ('ColSum[fixedBound 'X bound (N + 2)]))
}
.

*** quickfix for a bug
 strat addRowSumGroup @ ProtocolConfig .
 sd addRowSumGroup := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           ( fam ('RowSum[bound 'X bound (N + 2)]) )
           
         named 'HiddenGroup 
         params ('i 'j) (bound 'X bound (N + 2)) 
         in P
       ]
       {
        applyDropName(fam ('HiddenGroup[bound 'X bound (N + 2)]) )
        
       } ***sym
       )
 .     
 
 strat symRSYNZero @ ProtocolConfig .
 sd symRSYNZero :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change
         chn( 'RowSum['X 'Y] )
         with 
         nf('c : bool <- read ('ColSum['X 'Y]), return 'c, 'c)
         in
         P
       ]
       { substNFFamilyOne(
       fam ('ColSum[fixedBound 'X bound (N + 2)]), 
        'RowSum['X 'Y], 
        nf(('bi : bool <- read ('Col['X 'Y])) 
            'bs : bool <- read ('ColSum[('X -- 1) 'Y]), 
            return (ap 'xor pair('bs, 'bi)), 'bs 'bi)
        )
        ; substNFFamilyOne(
         fam ('ColSum[bound 'X bound (N + 2)]), 
         'RowSum['X 'Y], 
         nf('r : bool <- read ('RowSum[('X -- 1) 'Y]), return 'r, 'r)
        ) 
        ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'j), 
        nf(('bj : bool <- read ('Ctrb['X 'Y 'B])) 
            'bs : bool <- read ('Col['X ('Y -- 1)]),    
            return (ap 'xor  pair('bs, 'bj)), 'bs 'bj)
        )
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'bj, 'bi >> emptyQidPairList)
         ; substFamCaseChn(
        fam ('RowSum[bound 'X bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'j), 
        nf(('bj : bool <- read ('Row[('X -- 1) 'Y])) 
            'r : bool <- read ('RowSum[('X -- 1) ('Y -- 1)]), 
            return (ap 'xor pair('r, 'bj)), 'r 'bj)
        ) 
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'bj, 'br >> << 'bs, 'bc >> emptyQidPairList) 
        ; changeOrder(chn ('RowSum['X 'Y]), 'r 'bc 'br 'bi) 
       }      
 .
 
 strat symRSYZero @ ProtocolConfig .
 sd symRSYZero :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change
         chn( 'RowSum['X 'Y] )
         with 
         nf('c : bool <- read ('ColSum['X 'Y]), return 'c, 'c)
         in
         P
       ]
       { substNFFamilyOne(
       fam ('ColSum[fixedBound 'X bound (N + 2)]), 
        'RowSum['X 'Y], 
        nf(('bi : bool <- read ('Col['X 'Y])) 
            'bs : bool <- read ('ColSum[('X -- 1) 'Y]), 
            return (ap 'xor pair('bs, 'bi)), 'bs 'bi)
        )
        ;
        *** ind hypo
        substNFFamilyOne(
         fam ('ColSum[bound 'X bound (N + 2)]), 
         'RowSum['X 'Y], 
         nf('r : bool <- read ('RowSum[('X -- 1) 'Y]), return 'r, 'r)
        ) 
        ; applyAlphaAssumChn('RowSum['X 'Y], 'Y)
        
        ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'j), 
        nf('c : bool <- read ('Ctrb['X 0 'B]), return 'c, 'c)
        )
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'c, 'bi >> emptyQidPairList)
        ; substFamCaseChn(
        fam ('RowSum[bound 'X bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'j), 
        nf('r : bool <- read ('Row[('X -- 1) 0]), return 'r, 'r)
        )
        ; changeOrder(chn ('RowSum['X 'Y]), 'bi 'r)
        }
       
.       

 
*** first induction for row on non-zero case
strat setupIndRowPartOneNZCase @ ProtocolConfig .
sd setupIndRowPartOneNZCase := 
***(
matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (family 'RowSum[fixedBound 'X bound (N + 2)]
    'i 'j
fixedBound 'X bound (N + 2)
::= nf('c : bool <- read ('ColSum['X 'j]), return 'c, 'c)
) 'j 'Y,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P 'RowSum 'j 'Y A (family 'RowSum[fixedBound 'X bound (N + 2)]
    'i 'j
fixedBound 'X bound (N + 2)
::= nf('c : bool <- read ('ColSum['X 'j]), return 'c, 'c)
)),
       P1:Protocol <- getInductionBase P 'RowSum 'j 'Y A (family 'RowSum[fixedBound 'X bound (N + 2)]
    'i 'j
fixedBound 'X bound (N + 2)
::= nf('c : bool <- read ('ColSum['X 'j]), return 'c, 'c)
),
       A':Set{BoolTerm} <-  (A,'Y <T (N + 2))                
       ]
    )
     SINGLE-INDUCTION-new-R[
  idx:Qid <- 'Y,
  q:Qid <- 'j,
  cn:ChannelName <- 'RowSum,
  blist:List{Bounds} <- fixedBound 'X bound (N + 2),
  cases':Cases <- 
   nf('c : bool <- read ('ColSum['X 'j]), return 'c, 'c)
   ]{   
       *** we need to use it, so ungroup it
         applyDropName(fam ('HiddenGroup[bound 'X bound (N + 2)]) )
       ; CASE-DISTINCTION-channel[
          cn:ChannelName <- 'RowSum['X 'Y]
       ]{
       *** Y = 0
       substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'i), 
        nf(('bi : bool <- read ('Ctrb['X 0 'B])) 
            'r : bool <- read ('Row[('X -- 1) 0]), 
            return (ap 'xor  pair('r, 'bi)), 'r 'bi)
      )
      *** now a sym proof
      ; symRSYZero
      ,
       CASE-DISTINCTION-channel-end-when[
          cn:ChannelName <- 'RowSum['X 'Y]
       ]{
       *** Y /= 0
        substNFFamilyOne(
          fam ('RowSum[fixedBound 'X bound 'Y]),
          'RowSum['X 'Y],
          nf('c : bool <- read ('ColSum['X ('Y -- 1)]), return 'c, 'c)
        ) 
        ;        
        substNFFamilyOne(
          fam ('ColSum[fixedBound 'X bound (N + 2)]),
          'RowSum['X 'Y],
          nf(('bi : bool <- read ('Col['X ('Y -- 1)])) 
              'bs : bool <- read ('ColSum[('X -- 1) ('Y -- 1)]), 
              return (ap 'xor pair('bs, 'bi)), 'bs 'bi)
        ) 
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'bi, 'bc >> emptyQidPairList)
        ; substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'i), 
        nf(('bi : bool <- read ('Ctrb['X 'Y 'B])) 
            'r : bool <- read ('Row[('X -- 1) 'Y]), 
            return (ap 'xor  pair('r, 'bi)), 'r 'bi)
      )  
      ; applyRearrangeXor(chn ('RowSum['X 'Y]))  
      ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'r, 'br >> emptyQidPairList)
      ; substNFFamilyOne(
         fam ('ColSum[bound 'X bound (N + 2)]), 
         'RowSum['X 'Y], 
         nf('r : bool <- read ('RowSum[('X -- 1) ('Y -- 1)]), return 'r, 'r)
        ) 
       *** and again the rest is a sym proof 
        ; symRSYNZero      
        }
       }
       ; applyAllSameCases(chn ('RowSum['X 'Y]))
       *** get back to original structure
       ; addRowSumGroup
     } *** induction end  
.            

*** first induction for row on 0 case
strat setupIndRowPartOneZeroCase @ ProtocolConfig .
sd setupIndRowPartOneZeroCase := 
***(
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (family 'RowSum[fixedBound 'X bound (N + 2)]
    'i 'j
fixedBound 'X bound (N + 2)
::= nf('c : bool <- read ('ColSum[0 'j]), return 'c, 'c)
) 'j 'Y,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P 'RowSum 'j 'Y A (family 'RowSum[fixedBound 'X bound (N + 2)]
    'i 'j
fixedBound 'X bound (N + 2)
::= nf('c : bool <- read ('ColSum[0 'j]), return 'c, 'c)
)),
       P1:Protocol <- getInductionBase P 'RowSum 'j 'Y A (family 'RowSum[fixedBound 'X bound (N + 2)]
    'i 'j
fixedBound 'X bound (N + 2)
::= nf('c : bool <- read ('ColSum[0 'j]), return 'c, 'c)
),
       A':Set{BoolTerm} <-  (A,'Y <T (N + 2))                
       ] ;)
       SINGLE-INDUCTION-new-R[
  idx:Qid <- 'Y,
  q:Qid <- 'j,
  cn:ChannelName <- 'RowSum,
  blist:List{Bounds} <- fixedBound 'X bound (N + 2),
  cases':Cases <- 
   nf('c : bool <- read ('ColSum[0 'j]), return 'c, 'c)
   ]{ 
      CASE-DISTINCTION-channel[
       cn:ChannelName <- 'RowSum['X 'Y]
      ] {
      substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'i), 
        nf('c : bool <- read ('Ctrb[0 0 'B]), return 'c, 'c)
      )
      ; symRowSumPart1Branch1,
      CASE-DISTINCTION-channel-end-when[
       cn:ChannelName <- 'RowSum['X 'Y]
      ] {
      substNFFamilyOne(
       fam ('RowSum[fixedBound 'X bound 'Y]),
       'RowSum['X 'Y],
       nf('c : bool <- read ('ColSum[0 ('Y -- 1)]), return 'c, 'c) 
      )
      ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'c, 'cs >> emptyQidPairList)
      ; substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'i), 
        nf('c : bool <- read ('Ctrb[0 'Y 'B]), return 'c, 'c)
      )
      ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'c, 'bj >> emptyQidPairList)
      ; substNFFamilyOne(
        fam ('ColSum[fixedBound 'X bound (N + 2)]),
        'RowSum['X 'Y],
        nf('c : bool <- read ('Col[0 ('Y -- 1)]), return 'c, 'c)
      )
      ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'c, 'bs >> emptyQidPairList)
      ; symRowSumPart1Branch2      
      }
      }
      ; applyAllSameCases( chn ('RowSum['X 'Y]) )
      }
.

strat symRowSumPart1Branch2 @ ProtocolConfig .
sd symRowSumPart1Branch2 :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('RowSum['X 'Y])
        with nf('c : bool <- read ('ColSum[0 'Y]), return 'c, 'c)
        in P
       ] 
       {
       substNFFamilyOne(
         fam ('ColSum[fixedBound 'X bound (N + 2)]),
         'RowSum['X 'Y],
         nf('c : bool <- read ('Col[0 'Y]), return 'c, 'c)
       )   
       ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'j), 
        nf(('bj : bool <- read ('Ctrb[0 'Y 'B])) 
            'bs : bool <- read ('Col[0 ('Y -- 1)]),
    return (ap 'xor pair('bs, 'bj)), 'bs 'bj)
      ) }
.

strat symRowSumPart1Branch1 @ ProtocolConfig .
sd symRowSumPart1Branch1 :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('RowSum['X 'Y])
        with nf('c : bool <- read ('ColSum[0 'Y]), return 'c, 'c)
        in P
       ] 
       { substNFFamilyOne(
         fam ('ColSum[fixedBound 'X bound (N + 2)]),
         'RowSum['X 'Y],
         nf('c : bool <- read ('Col[0 'Y]), return 'c, 'c)
       )   
       ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'j), 
        nf('c : bool <- read ('Ctrb[0 0 'B]), return 'c, 'c)
      )}

.       


op knowColRowSum : -> Protocol .
eq knowColRowSum =
(family 'ColSum[bound (N + 2) bound (N + 2)] 'i 'j
bound (N + 2) bound (N + 2)
::=
(when (0 =T= 'i) -->
nf('c : bool <- read ('Col[0 'j]), return 'c, 'c))
;;
(when neg (0 =T= 'i) -->
nf(('bi : bool <- read ('Col['i 'j])) 'bs : bool <- read ('ColSum[('i -- 1) 'j]),
    return (ap 'xor pair('bs, 'bi)), 'bs 'bi)
)    
)
||
(family 'RowSum[bound (N + 2) bound (N + 2)] 'i 'j
bound (N + 2) bound (N + 2)
::=
(when (0 =T= 'j) -->
nf('r : bool <- read ('Row['i 0]), return 'r, 'r))
;;
(when neg (0 =T= 'j) -->
nf(('bj : bool <- read ('Row['i 'j])) 'r : bool <- read ('RowSum['i ('j -- 1)]),
    return (ap 'xor pair('r, 'bj)), 'r 'bj)
)
)
.

op wantColRowSum : -> Protocol .
eq wantColRowSum =
(family 'ColSum[bound (N + 2) bound (N + 2)] 'i 'j
bound (N + 2) bound (N + 2)
::=
nf('r : bool <- read ('RowSum['i 'j]), return 'r, 'r)
)
||
(family 'RowSum[bound (N + 2) bound (N + 2)] 'i 'j
bound (N + 2) bound (N + 2)
::=
(when (0 =T= 'j) -->
nf('r : bool <- read ('Row['i 0]), return 'r, 'r))
;;
(when neg (0 =T= 'j) -->
nf(('bj : bool <- read ('Row['i 'j])) 'r : bool <- read ('RowSum['i ('j -- 1)]),
    return (ap 'xor pair('r, 'bj)), 'r 'bj)
)
)
.

 strat addRowAndRowSum @ ProtocolConfig .
 sd addRowAndRowSum :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'Row
         typed bool
         params ('i 'j)
                ( (bound (N + 2)) (bound (N + 2)) )  
         assigned
          (when ('i =T= 0) -->
            nf('c : bool <- read ('Ctrb[0 'j 'B]), return 'c, 'c)
          )
          ;;
          (when (neg ('i =T= 0)) -->
            nf(  
              ('r : bool <- read ('Row[('i -- 1) 'j]))
              ('bi : bool <- read ('Ctrb['i 'j 'B])),
              return (ap 'xor pair('r, 'bi)),
              'r 'bi
            )
          )
         in
         (addInternalFamily
           'RowSum
         typed bool
         params ('i 'j)
                ( (bound (N + 2)) (bound (N + 2)) )  
         assigned
          (when ('j =T= 0) -->
            nf('r : bool <- read ('Row['i 0]), return 'r, 'r)
          )
          ;;
          (when (neg ('j =T= 0)) -->
            nf(  
              ('r : bool <- read ('RowSum['i ('j -- 1)]))
              ('bj : bool <- read ('Row['i 'j])),
              return (ap 'xor pair('r, 'bj)),
              'r 'bj
            )
          )
         in P)
         ]
          { absorbFamily(fam ('Row[(bound (N + 2)) (bound (N + 2))]) )
          ; absorbFamily(fam ('RowSum[(bound (N + 2)) (bound (N + 2))]) )
          }
        
 .


 strat changeColToInductive @ ProtocolConfig .
 sd changeColToInductive :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf 
            by pConf 
            using 
            SYM[
            Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change ( fam ('Col[bound (N + 2) bound (N + 2)]) )
             with 
              (when ('j =T= 0) --> 
                nf('c : bool  <- read ('Ctrb['i 0 'B]),
                   return 'c, 'c)
              )
              ;;
              (when (neg ('j =T= 0)) --> 
                nf(('bs : bool <- read ('Col['i ('j -- 1)])) 
                    'bj : bool <- read ('Ctrb['i 'j 'B]),
                    return (ap 'xor pair('bs, 'bj)), 'bs 'bj)
              )
             in P
            ] {
            ***(
     ; matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (family 'Col[bound (N + 2) bound (N + 2)] 'i
    'j
bound (N + 2) bound (N + 2)
::=
nf('c : bool <- read ('CtrbSum['i 'j 'B]), return 'c, 'c)
) 'j 'J,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P 'Col 'j 'J A (family 'Col[bound (N + 2) bound (N + 2)] 'i
    'j
bound (N + 2) bound (N + 2)
::=
nf('c : bool <- read ('CtrbSum['i 'j 'B]), return 'c, 'c)
)),
       P1:Protocol <- getInductionBase P 'Col 'j 'J A (family 'Col[bound (N + 2) bound (N + 2)] 'i
    'j
bound (N + 2) bound (N + 2)
::=
nf('c : bool <- read ('CtrbSum['i 'j 'B]), return 'c, 'c)
),
       A':Set{BoolTerm} <-  (A,'J <T (N + 2))                
       ]       ;)
       CONG-NEW-NF{
       SINGLE-INDUCTION-new-R[
  idx:Qid <- 'J,
  q:Qid <- 'j,
  cn:ChannelName <- 'Col,
  blist:List{Bounds} <- bound (N + 2) (bound (N + 2)),
  cases':Cases <- 
   nf('c : bool <- read ('CtrbSum['i 'j 'B]), return 'c, 'c)
   ]
       {
       ***now the induction proof
       CASE-DISTINCTION-one-R[
        fns:NameWithScripts <- 'Col,
        blist:List{Bounds} <- bound (N + 2) fixedBound 'J
        ]{
         sym1ColAnd, 
         CASE-DISTINCTION-one-R-end-when[
        fns:NameWithScripts <- 'Col,
        blist:List{Bounds} <- bound (N + 2) fixedBound 'J
        ]{
         
         substNFFamiliesGen(
          fam ('Col[bound (N + 2) bound 'J]),
          fam ('Col[bound (N + 2) fixedBound 'J]),
          nf('c : bool <- read ('CtrbSum['i ('J -- 1) 'B]), return 'c, 'c)
         )
         ; sym2ColAnd
         }}
         ; applyAllSameCases( fam ('Col[bound (N + 2) fixedBound 'J]) )
         }}}
 .  

strat sym2ColAnd @ ProtocolConfig .
sd sym2ColAnd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
        Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
        fam ('Col[bound (N + 2) fixedBound 'J])
       with nf('c : bool <- read ('CtrbSum['i 'J 'B]), return 'c, 'c)
       in P 
       ] 
       { substFamCaseFam(
           fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]), 
           fam ('Col[bound (N + 2) fixedBound 'J]), 
           neg (0 =T= 'm), 
           nf(('b : bool <- read ('Ctrb['i 'J 'B])) 's : bool <- read ('CtrbSum['i ('J -- 1)
    'B]), return (ap 'xor pair('s, 'b)), 's 'b)
         )
       ; applyAlphaNFPr(
            fam ('Col[bound (N + 2) fixedBound 'J]), 
                         << 'b, 'bj >> << 's, 'c >> emptyQidPairList)      
        }                 
.       
 
strat sym1ColAnd @ ProtocolConfig .
sd sym1ColAnd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
        fam ('Col[bound (N + 2) fixedBound 'J])
       with nf('c : bool <- read ('CtrbSum['i 'J 'B]), return 'c, 'c)
       in P 
       ] 
       { substFamCaseFam(
           fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]), 
           fam ('Col[bound (N + 2) fixedBound 'J]), 
           0 =T= 'm, 
           nf('b : bool <- read ('Ctrb['i 0 'B]), return 'b, 'b)
         )
      ; applyAlphaNFPr(
            fam ('Col[bound (N + 2) fixedBound 'J]), 
                         << 'b, 'c >> emptyQidPairList)    
       } 
.                 

strat substFamCaseChnColSumSSAnd3 @ ProtocolConfig .
sd substFamCaseChnColSumSSAnd3 :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substFamCaseChnColSumSSAnd3} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('ColSum[bound (N + 2) bound (N + 2)]) ) 
          (chn ('ShareSum[(N + 1) 'B])), 
        P1:Protocol <- keepTwo P 
          (fam ('ColSum[bound (N + 2) bound (N + 2)])) 
          (chn ('ShareSum[(N + 1) 'B]) )
        ]{
 select-case-subst-family-r-gen[
          bt:BoolTerm <- neg (0 =T= 'i)
        ]{substNFFamilyOne(
           fam ('ColSum[bound (N + 2) bound (N + 2)]), 
           'ShareSum[(N + 1) 'B], 
           nf(('bi : bool <- read ('Col[(N + 1) (N + 1)])) 
               'bs : bool <- read ('ColSum[N (N + 1)]),
               return (ap 'xor pair('bs, 'bi)), 'bs 'bi)
          )} 
        }       
.

strat symSSColSumAnd @ ProtocolConfig .
sd symSSColSumAnd :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{symSSColSumAnd} 
     :
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
      ( SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf('c : bool  <- read ('ColSum[(N + 1) (N + 1)]),
             return 'c, 'c)
        in P
        ]
        { substFamCaseChnColSumSSAnd3
        ; substNFFamilyOne(
           fam ('Col[bound (N + 2) bound (N + 2)]),
           'ShareSum[(N + 1) 'B],
           nf('c : bool  <- read ('CtrbSum[(N + 1) (N + 1) 'B]),
             return 'c, 'c)
        )
        ; applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 'c, 't >> emptyQidPairList) 
        ; applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 'bs, 'c >> emptyQidPairList)   
        ; applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 't, 'bs >> emptyQidPairList) 
                         } 
      )  
.        

strat substFamCaseChnColSumSSAnd @ ProtocolConfig .
sd substFamCaseChnColSumSSAnd :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substFamCaseChnColSumSSAnd} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('ColSum[bound (N + 2) bound (N + 2)]) ) 
          (chn ('ShareSum['M 'B])), 
        P1:Protocol <- keepTwo P 
          (fam ('ColSum[bound (N + 2) bound (N + 2)])) 
          (chn ('ShareSum['M 'B]) )
        ]{
 select-case-subst-family-r-gen[
          bt:BoolTerm <- 0 =T= 'i
        ]{substNFFamilyOne(
           fam ('ColSum[bound (N + 2) bound (N + 2)]), 
           'ShareSum['M 'B], 
           nf('c : bool <- read ('Col[0 (N + 1)]), return 'c, 'c)
          )} 
        }       
.

strat substFamCaseChnColSumSSAnd2 @ ProtocolConfig .
sd substFamCaseChnColSumSSAnd2 :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substFamCaseChnColSumSSAnd2} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('ColSum[bound (N + 2) bound (N + 2)]) ) 
          (chn ('ShareSum['M 'B])), 
        P1:Protocol <- keepTwo P 
          (fam ('ColSum[bound (N + 2) bound (N + 2)])) 
          (chn ('ShareSum['M 'B]) )
        ]{
 select-case-subst-family-r-gen[
          bt:BoolTerm <- neg (0 =T= 'i)
        ]{substNFFamilyOne(
           fam ('ColSum[bound (N + 2) bound (N + 2)]), 
           'ShareSum['M 'B], 
           nf(('bi : bool <- read ('Col['M (N + 1)])) 
               'bs : bool <- read ('ColSum[('M -- 1) (N + 1)]),
               return (ap 'xor pair('bs, 'bi)), 'bs 'bi)
          )} 
        }       
.


strat setupIndSSAnd @ ProtocolConfig .
sd setupIndSSAnd := 
***(
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (family 'ShareSum[bound (N + 1) fixedBound 'B]
    'm 'k
bound (N + 1) fixedBound 'B
::= nf('c : bool <- read ('ColSum['m (N + 1)]), return 'c, 'c)
 ) 'm 'M,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P 'ShareSum 'm 'M A (family 'ShareSum[bound (N + 1) fixedBound 'B]
    'm 'k
bound (N + 1) fixedBound 'B
::= nf('c : bool <- read ('ColSum['m (N + 1)]), return 'c, 'c)
 )),
       P1:Protocol <- getInductionBase P 'ShareSum 'm 'M A (family 'ShareSum[bound (N + 1) fixedBound 'B]
    'm 'k
bound (N + 1) fixedBound 'B
::= nf('c : bool <- read ('ColSum['m (N + 1)]), return 'c, 'c)
 ),
       A':Set{BoolTerm} <-  (A,'B <T K)                
       ]
)
SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'ShareSum,
  blist:List{Bounds} <- bound (N + 1) fixedBound 'B,
  cases':Cases <- 
   nf('c : bool <- read ('ColSum['m (N + 1)]), return 'c, 'c)
   ]       
       
{ CASE-DISTINCTION-channel[
   cn:ChannelName <- 'ShareSum['M 'B]
  ]{
  substNFFamilyOne(
   fam ('Share[bound (N + 1) fixedBound 'B]),
   'ShareSum['M 'B],
   nf('bs : bool <- read ('CtrbSum[0 (N + 1) 'B]), return 'bs, 'bs)
  )
  ; symSSInd1And
  , 
  CASE-DISTINCTION-channel-end-when[
   cn:ChannelName <- 'ShareSum['M 'B]
  ]{
  substNFFamilyOne(
   fam ('Share[bound (N + 1) fixedBound 'B]),
   'ShareSum['M 'B],
   nf('bs : bool <- read ('CtrbSum['M (N + 1) 'B]), return 'bs, 'bs)
  )
  ;
  substNFFamilyOne(
   fam ('ShareSum[bound 'M fixedBound 'B]),
   'ShareSum['M 'B],
  nf('c : bool <- read ('ColSum[('M -- 1) (N + 1)]), return 'c, 'c)
  )
  ; symSSInd2And
  }
  }
 ; applyAllSameCases(chn ('ShareSum['M 'B]))  
}      
.

  strat symSSInd2And @ ProtocolConfig .
  sd symSSInd2And :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum['M 'B])
        with
         nf('c : bool <- read ('ColSum['M (N + 1)]), return 'c, 'c)
        in P
        ] 
        {
        substFamCaseChnColSumSSAnd2
        ; substNFFamilyOne(
          fam ('Col[bound (N + 2) bound (N + 2)]),
          'ShareSum['M 'B],
          nf('c : bool <- read ('CtrbSum['M (N + 1) 'B]), return 'c, 'c)
         )
        ; applyAlphaNFPr(
            chn ('ShareSum['M 'B]), 
                         << 'c, 't >> emptyQidPairList) 
        ; applyAlphaNFPr(
            chn ('ShareSum['M 'B]), 
                         << 'bs, 'c >> emptyQidPairList)   
        ; applyAlphaNFPr(
            chn ('ShareSum['M 'B]), 
                         << 't, 'bs >> emptyQidPairList)  
        }                                                
  .      

  strat symSSInd1And @ ProtocolConfig .
  sd symSSInd1And :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum['M 'B])
        with
         nf('c : bool <- read ('ColSum['M (N + 1)]), return 'c, 'c)
        in P
        ]
        { substFamCaseChnColSumSSAnd
        ; substNFFamilyOne(
          fam ('Col[bound (N + 2) bound (N + 2)]),
          'ShareSum['M 'B],
          nf('c : bool <- read ('CtrbSum[0 (N + 1) 'B]), return 'c, 'c)
         )
        ; applyAlphaNFPr(
            chn ('ShareSum['M 'B]), 
                         << 'c, 'bs >> emptyQidPairList) 
        }
        
 .

 strat addColAndColSum @ ProtocolConfig .
 sd addColAndColSum :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'Col
         typed bool
         params ('i 'j)
                ( (bound (N + 2)) (bound (N + 2)) )  
         assigned
          nf('c : bool  <- read ('CtrbSum['i 'j 'B]),
             return 'c, 'c)
         in
         (addInternalFamily
           'ColSum
         typed bool
         params ('i 'j)
                ( (bound (N + 2)) (bound (N + 2)) )  
         assigned
          (when ('i =T= 0) -->
            nf('c : bool <- read ('Col[0 'j]), return 'c, 'c)
          )
          ;;
          (when (neg ('i =T= 0)) -->
            nf(  
              ('bs : bool <- read ('ColSum[('i -- 1) 'j]))
              ('bi : bool <- read ('Col['i 'j])),
              return (ap 'xor pair('bs, 'bi)),
              'bs 'bi
            )
          )
         in P)
         ]
          { absorbFamily(fam ('Col[(bound (N + 2)) (bound (N + 2))]) )
          ; absorbFamilyDeleteEmpty(fam ('ColSum[(bound (N + 2)) (bound (N + 2))]) )
          }
        
 .

 strat revertShareAnd @ ProtocolConfig .
 sd revertShareAnd := 
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
        chn ('Share[(N + 1) 'B])
       with
 nf(('x : bool <- read ('ShareSum[(N + 1) 'B])) 'xs : bool
    <- read ('ShareSum[N 'B]), return (ap 'xor pair('xs, 'x)), 'xs 'x)
      in
      P]
      { substNF('ShareSum[(N + 1) 'B], 'Share[(N + 1) 'B])
      ; applyReturnIdem(chn ('Share[(N + 1) 'B]))
      }
 .

 strat setupSymAnd @ ProtocolConfig .
 sd setupSymAnd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change 
        chn ('Share[(N + 1) 'B])
        with
        nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'B])) 
            'xs : bool <- read ('ShareSum[N 'B]), return 'bs, 'xs 'bs)
        in (
        change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf(('xm : bool <- read ('Share[(N + 1) 'B])) 
             'xs : bool <- read ('ShareSum[N 'B]), 
             return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
        in 
        P)
       ]{
         substNF('Share[(N + 1) 'B], 'ShareSum[(N + 1) 'B])
; revertShareAnd 
; addColAndColSum
*** turn the family ShareSum(up to N + 1, fixed B) into closed form, reads from ColSum
; CONG-NEW-NF{setupIndSSAnd}

; substNFFamilyOne(
    fam ('ShareSum[bound (N + 1) fixedBound 'B]),
    'ShareSum[(N + 1) 'B],
    nf('c : bool <- read ('ColSum[N (N + 1)]), return 'c, 'c)
  )
*** put  the family ShareSum(up to N + 1, fixed B) back in its original form 
; revertShareSumInductiveAnd 
*** substs in ShareSum[N+1 B]
; symSSColSumAnd
*** change col to inductive form
; changeColToInductive

*** add Row and RowSum
; addRowAndRowSum

*** here we get ColSum to read from RowSum!
; applyGroupFamiliesNew(
    fam ('RowSum[bound (N + 2) bound (N + 2)]), 
    fam ('ColSum[bound (N + 2) bound (N + 2)])
  )
 
; CONG-NEW-NF{setupIndColRow}
  

; applyUngroupFamiliesNew(
    fam ('RowSum[bound (N + 2) bound (N + 2)]), 
    fam ('ColSum[bound (N + 2) bound (N + 2)])
  ) 
  
; addSqr
; symSqrInSSNPlus1 
*** we need to get ColSum back to the inductive form first
; unsafeColSumInductive
; symSqrToInductive 
*** ColSum RowSum are unused and we can absorb them
; absorbFamily( fam ('ColSum[bound (N + 2) bound (N + 2)]) )
; absorbFamily( fam ('RowSum[bound (N + 2) bound (N + 2)]) )

*** next proof step says that we can unsplit Share upto bound 'B
*** but we can choose to keep them separated!
*** last thing to show is that we can turn Sqr to a closed form involving and
; symSqrToClosedAnd

*** we can discard Row and Col
; absorbFamily( fam ('Col[bound (N + 2) bound (N + 2)]) )
; absorbFamilyDeleteEmpty( fam ('Row[bound (N + 2) bound (N + 2)]) )

*** then we can subst Sqr(N+1) in 'ShareSum[(N+1) 'B] to get what we wanted
; substNFFamilyOne(
    fam ('Sqr[bound (N + 2)]),
    'ShareSum[(N + 1) 'B],
    nf(
            ('xs : bool <- read('ShareSum[(N + 1) (fun 'wire0 'B)]) )
            ('ys : bool <- read('ShareSum[(N + 1) (fun 'wire1 'B)]) ),
            return (ap 'and pair('xs, 'ys)),
            'xs 'ys
        )
  )
  ; applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 'xs, 'x >> << 'ys, 'y >> emptyQidPairList)
*** discard Sqr

; absorbFamilyDeleteEmpty( fam ('Sqr[bound (N + 2)]) )  
       }
 .      

  
*** strategies for xor  

 strat psymXor @ ProtocolConfig .
  sd psymXor :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
      SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'B)])) 
             'y : bool <- read ('ShareSum[(N + 1) (fun 'wire1 'B)]), 
             return (ap 'xor pair('x, 'y)), 'x 'y)

        in P
        ]
         {
        substNFFamilyOne(
         fam ('ShareSum[fixedBound (N + 1) bound 'B]),
         'ShareSum[(N + 1) 'B],
         nf(('xm : bool <- read ('Share[(N + 1) (fun 'wire0 'B)])) 
             'xs : bool <- read ('ShareSum[N (fun 'wire0 'B)]),
             return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
        )
        ; applyAlphaNFPr(
             chn ('ShareSum[(N + 1) 'B]), 
                         << 'xs, 'x >> << 'xm, 'a >> emptyQidPairList)
        ;
        substNFFamilyOne(
         fam ('ShareSum[fixedBound (N + 1) bound 'B]),
         'ShareSum[(N + 1) 'B],
         nf(('xm : bool <- read ('Share[(N + 1) (fun 'wire1 'B)])) 
             'xs : bool <- read ('ShareSum[N (fun 'wire1 'B)]),
             return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
        )
        ; applyAlphaNFPr(
             chn ('ShareSum[(N + 1) 'B]), 
                         << 'xs, 'y >> << 'xm, 'b >> emptyQidPairList)   
        ; changeOrder(
            chn ('ShareSum[(N + 1) 'B]), 'x 'y 'a 'b
          )                               
        }             
        
  .

 strat setupSymXor @ ProtocolConfig .
 sd setupSymXor :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('Share[(N + 1) 'B])
        with
         nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'B)])) 
            ('xs : bool <- read ('ShareSum[N 'B])) 
            'y : bool <- read ('Share[(N + 1) (fun 'wire1 'B)]), 
            return (ap 'xor pair('x, 'y)), 'xs 'x 'y)
         
        in (
        change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf(('xm : bool <- read ('Share[(N + 1) 'B])) 
             'xs : bool <- read ('ShareSum[N 'B]), 
             return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
        in 
        P)
       ]
{
        substNF('Share[(N + 1) 'B], 'ShareSum[(N + 1) 'B])
; revertShareXor
; setupIndShareSumXor

; applyAlphaNFPr(
             chn ('ShareSum[(N + 1) 'B]), 
                         << 'x, 'a >> << 'y, 'b >> emptyQidPairList)
                         
; substNFFamilyOne(
   fam ('ShareSum[bound (N + 1) fixedBound 'B]),
   'ShareSum[(N + 1) 'B], 
   nf(('x : bool <- read ('ShareSum[N (fun 'wire0 'B)])) 
       'y : bool <- read ('ShareSum[N (fun 'wire1 'B)]), 
       return (ap 'xor pair('x, 'y)), 'x 'y)
  ) 

; applyRearrangeXor(chn ('ShareSum[(N + 1) 'B]))

; applyRemoveFromGroupCases(
       fam ('Shares[bound 'B]),
       fam ('ShareSum[fixedBound (N + 1) bound 'B])
     )
   ; applyAllSameCases(fam ('ShareSum[fixedBound (N + 1) bound 'B]))  

; psymXor  

; revertShareSumIndXor

; applyAddToGroupCases(
       fam ('Shares[bound 'B]),
       fam ('ShareSum[fixedBound (N + 1) bound 'B])
     ) 
} 
 . 
 
 strat revertShareXor @ ProtocolConfig . 
 sd revertShareXor := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('Share[(N + 1) 'B])
        with
        nf(('x : bool <- read ('ShareSum[(N + 1) 'B])) 
            'xs : bool <- read ('ShareSum[N 'B]), 
            return (ap 'xor pair('xs, 'x)), 'xs 'x)
        in P
       ]
     {  substNF('ShareSum[(N + 1) 'B], 'Share[(N + 1) 'B])
     ; applyReturnIdem(chn ('Share[(N + 1) 'B]))
     ; changeOrder(chn ('Share[(N + 1) 'B]), 'xs 'x 'y)
     }
       .

  strat revertShareSumIndXor @ ProtocolConfig .
  sd revertShareSumIndXor :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ( 'ShareSum[bound (N + 1) fixedBound 'B] )
        with
         (when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'B]), return 's, 's))
;;
(when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'B])) 'xs : bool <- read ('ShareSum[('m -- 1) 'B]), return (ap 'xor pair('xs, 'xm)),
    'xs 'xm)
)
        in P
        ]{setupIndShareSumXor}
 .  
 
strat setupIndShareSumXor @ ProtocolConfig .
sd setupIndShareSumXor := 
***(
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (
          family 'ShareSum[bound (N + 1) fixedBound 'B] 'm 'k
bound (N + 1) fixedBound 'B
          ::= nf( ('x : bool <- read ('ShareSum['m (fun 'wire0 'B)])) 
                  ('y : bool <- read ('ShareSum['m (fun 'wire1 'B)])) , 
                  return (ap 'xor pair('x, 'y)), 'x 'y)
          ) 'm 'M,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P 'ShareSum 'm 'M A 
        (
          family 'ShareSum[bound (N + 1) fixedBound 'B] 'm 'k
bound (N + 1) fixedBound 'B
          ::= 
          nf( ('x : bool <- read ('ShareSum['m (fun 'wire0 'k)])) 
                  ('y : bool <- read ('ShareSum['m (fun 'wire1 'k)])) , 
                  return (ap 'xor pair('x, 'y)), 'x 'y)
          )),
       P1:Protocol <- getInductionBase P 'ShareSum 'm 'M A (
          family 'ShareSum[bound (N + 1) fixedBound 'B] 'm 'k
bound (N + 1) fixedBound 'B
          ::= 
          nf( ('x : bool <- read ('ShareSum['m (fun 'wire0 'B)])) 
                  ('y : bool <- read ('ShareSum['m (fun 'wire1 'B)])) , 
                  return (ap 'xor pair('x, 'y)), 'x 'y)
          ),
       A':Set{BoolTerm} <-  (A,'B <T K)                
       ]
       ;)
   SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'ShareSum,
  blist:List{Bounds} <- bound (N + 1) fixedBound 'B,
  cases':Cases <- 
   nf( ('x : bool <- read ('ShareSum['m (fun 'wire0 'B)])) 
                  ('y : bool <- read ('ShareSum['m (fun 'wire1 'B)])) , 
                  return (ap 'xor pair('x, 'y)), 'x 'y)
   ]{     
       
       applyRemoveMergeFromGroupCases(fam ('Shares[bound 'B]), 
    fam ('ShareSum[bound (N + 1) bound 'B])
  )
       ;
       CASE-DISTINCTION-channel[
       cn:ChannelName <- 'ShareSum['M 'B]
       ]{
       substNFFamilyOne(
        fam ('Share[bound (N + 1) fixedBound 'B]),
        'ShareSum['M 'B],
        nf(('x : bool <- read ('Share[0 (fun 'wire0 'B)])) 
            'y : bool <- read ('Share[0 (fun 'wire1 'B)]), 
            return (ap 'xor pair('x, 'y)), 'x 'y)
       )
       ; symSS1Xor
       , 
       CASE-DISTINCTION-channel-end-when[
       cn:ChannelName <- 'ShareSum['M 'B]
       ]{
       
        substNFFamilyOne(
        fam ('ShareSum[bound 'M fixedBound 'B]), 
        'ShareSum['M 'B], 
        nf(('x : bool <- read ('ShareSum[('M -- 1) (fun 'wire0 'B)])) 
    'y : bool <- read ('ShareSum[('M -- 1) (fun 'wire1 'B)]), 
    return (ap 'xor pair('x, 'y)), 'x 'y)
)
; applyAlphaNFPr(
             chn ('ShareSum['M 'B]), 
                         << 'x, 'a >> << 'y, 'b >> emptyQidPairList)
; substNFFamilyOne(
        fam ('Share[bound (N + 1) fixedBound 'B]), 
        'ShareSum['M 'B], 
        nf(('x : bool <- read ('Share['M (fun 'wire0 'B)])) 'y : bool <- read ('Share['M (
    fun 'wire1 'B)]), return (ap 'xor pair('x, 'y)), 'x 'y)
)          
    ; applyRearrangeXor(chn ('ShareSum['M 'B]))          
    ; symSS2Xor
       }}
       ; applyAllSameCases( chn ('ShareSum['M 'B]))
       ; applyAddToGroupCases(fam ('Shares[bound 'B]), 
    fam ('ShareSum[bound (N + 1) bound 'B])
  )
  }
.

strat symSS2Xor @ ProtocolConfig .
  sd symSS2Xor :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum['M 'B])
        with
         nf( ('x : bool <- read ('ShareSum['M (fun 'wire0 'B)])) 
              ('y : bool <- read ('ShareSum['M (fun 'wire1 'B)])) , 
                  return (ap 'xor pair('x, 'y)), 'x 'y)
        in P
        ]
        { pSubstFamCaseChn1(
         nf(('xm : bool <- read ('Share['M (fun 'wire0 'B)])) 
             'xs : bool <- read ('ShareSum[('M -- 1) (fun 'wire0 'B)]), 
             return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
          )    
        ; applyAlphaNFPr(
             chn ('ShareSum['M 'B]), 
                         << 'xs, 'a >> << 'xm, 'x >> emptyQidPairList)     
        ; pSubstFamCaseChn1(
         nf(('xm : bool <- read ('Share['M (fun 'wire1 'B)])) 
             'xs : bool <- read ('ShareSum[('M -- 1) (fun 'wire1 'B)]), 
             return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
          )    
        ; applyAlphaNFPr(
             chn ('ShareSum['M 'B]), 
                         << 'xs, 'b >> << 'xm, 'y >> emptyQidPairList)    
        ; changeOrder(chn ('ShareSum['M 'B]), 'a 'b 'x 'y)                  
        }
.        
 
strat pSubstFamCaseChn1 : Reaction @ ProtocolConfig .
sd pSubstFamCaseChn1(R) :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{pSubstFamCaseChn1(R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('ShareSum[bound (N + 1) bound 'B]) ) 
          (chn ('ShareSum['M 'B]) ), 
        P1:Protocol <- keepTwo P 
          (fam ('ShareSum[bound (N + 1) bound 'B]) ) 
          (chn ('ShareSum['M 'B]) )
        ]{
 select-case-subst-family-r-gen[
          bt:BoolTerm <- neg (0 =T= 'm)
        ]{substNFFamilyOne(
           fam ('ShareSum[bound (N + 1) bound 'B]),
           'ShareSum['M 'B], 
           R
          )
          }}   
 .  
 
strat symSS1Xor @ ProtocolConfig .
  sd symSS1Xor :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum['M 'B])
        with
         nf( ('x : bool <- read ('ShareSum['M (fun 'wire0 'B)])) 
                  ('y : bool <- read ('ShareSum['M (fun 'wire1 'B)])) , 
                  return (ap 'xor pair('x, 'y)), 'x 'y)
        in P
        ]
        { pSubstFamCaseChn0(nf('s : bool <- read ('Share[0 (fun 'wire0 'B)]), return 's, 's))
        ; applyAlphaNFPr(
             chn ('ShareSum['M 'B]), 
                         << 's, 'x >> emptyQidPairList)
        ; pSubstFamCaseChn0(nf('s : bool <- read ('Share[0 (fun 'wire1 'B)]), return 's, 's))
        ; applyAlphaNFPr(
             chn ('ShareSum['M 'B]), 
                         << 's, 'y >> emptyQidPairList)
        }
  .    
  
strat pSubstFamCaseChn0 : Reaction @ ProtocolConfig .
sd pSubstFamCaseChn0(R) :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{pSubstFamCaseChn0(R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('ShareSum[bound (N + 1) bound 'B]) ) 
          (chn ('ShareSum['M 'B]) ), 
        P1:Protocol <- keepTwo P 
          (fam ('ShareSum[bound (N + 1) bound 'B]) ) 
          (chn ('ShareSum['M 'B]) )
        ]{
 select-case-subst-family-r-gen[
          bt:BoolTerm <- 0 =T= 'm
        ]{substNFFamilyOne(
           fam ('ShareSum[bound (N + 1) bound 'B]),
           'ShareSum['M 'B], 
           R
          )
          }}   
 . 
**** strategies for not

 strat psymNot @ ProtocolConfig .
  sd psymNot :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum[(N + 1) 'B])
        with
        nf('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'B)]), return (ap 'neg 'x), 'x)
        in P
        ]
        { substNFFamilyOne(
            fam ('ShareSum[fixedBound (N + 1) bound 'B]),
            'ShareSum[(N + 1) 'B],
            nf(('xm : bool <- read ('Share[(N + 1) (fun 'wire0 'B)])) 
                'xs : bool <- read ('ShareSum[N (fun 'wire0 'B)]), 
                return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
        )
        ; applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 'xm, 'x >> << 'xs, 's >> emptyQidPairList)
        }
  .

 strat rewriteSharesBoundNot @ ProtocolConfig .
 sd rewriteSharesBoundNot :=
 match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteSharesBoundNot} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam ('Shares[bound 'B])), 
                             P1:Protocol <- keepOne P (fam ('Shares[bound 'B]))]{
       CONG-FAMILY-WHENLIST-P[
        bt:BoolTerm <- apply 'isNotGate 'k]{
        rewriteSharesBoundNotAux
       }
                             }           
 .    
 
 strat rewriteSharesBoundNotAux @ ProtocolConfig .
 sd rewriteSharesBoundNotAux := 
 ***(
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
         (family 'ShareSum[bound (N + 1) fixedBound 'B]
    'm 'k
bound (N + 1) fixedBound 'B
::=
nf('s : bool <- read ('ShareSum['m (fun 'wire0 'B)]), return 's, 's) 
 ) 'm 'M,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P 'ShareSum 'm 'M A (family 'ShareSum[bound (N + 1) fixedBound 'B]
    'm 'k
bound (N + 1) fixedBound 'B
::=
nf('s : bool <- read ('ShareSum['m (fun 'wire0 'B)]), return 's, 's) 
 )),
       P1:Protocol <- getInductionBase P 'ShareSum 'm 'M A (family 'ShareSum[bound (N + 1) fixedBound 'B]
    'm 'k
bound (N + 1) fixedBound 'B
::=
nf('s : bool <- read ('ShareSum['m (fun 'wire0 'B)]), return 's, 's) 
 ),
       A':Set{BoolTerm} <-  (A,'M <T (N + 1))                
       ]
       ;)
       
      SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'ShareSum,
  blist:List{Bounds} <- bound (N + 1) fixedBound 'B,
  cases':Cases <- 
   nf('s : bool <- read ('ShareSum['m (fun 'wire0 'B)]), return 's, 's) 
   ] {
       *** ind proof starts here
        applyRemoveMergeFromGroupCases(
       fam ('Shares[bound 'B]),
       fam ('ShareSum[bound (N + 1) bound 'B])
      )
      ; CASE-DISTINCTION-channel[
       cn:ChannelName <- 'ShareSum['M 'B]
      ]
      {
      substNFFamilyOne(
        fam ('Share[bound (N + 1) fixedBound 'B]),
        'ShareSum['M 'B],
        nf('s : bool <- read ('Share[0 (fun 'wire0 'B)]), return 's, 's)
       )
     
       , 
       CASE-DISTINCTION-channel-end-when[
       cn:ChannelName <- 'ShareSum['M 'B]
      ]
      {substNFFamilyOne(
        fam ('Share[bound (N + 1) fixedBound 'B]),
        'ShareSum['M 'B],
        nf('s : bool <- read ('Share['M (fun 'wire0 'B)]), return 's, 's)
       )
       ; applyAlphaNFPr(
            chn ('ShareSum['M 'B]), 
                         << 's, 'new >> emptyQidPairList)
        
       ; substNFFamilyOne(
        fam ('ShareSum[bound 'M fixedBound 'B]),
        'ShareSum['M 'B],
       nf('s : bool <- read ('ShareSum[('M -- 1) (fun 'wire0 'B)]), return 's, 's)
       )
       }
      }
     ; symWithCasesSS
     ; applyAllSameCases( chn ('ShareSum['M 'B]) )
     ; applyAddToGroupCases(
       fam ('Shares[bound 'B]),
       fam ('ShareSum[bound (N + 1) bound 'B])
      )
   }  
 .  
 
 strat symWithCasesSS @ ProtocolConfig .
 sd symWithCasesSS :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change chn ('ShareSum['M 'B])
       with
        (when (0 =T= 'M) -->
nf('s : bool <- read ('ShareSum['M (fun 'wire0 'B)]), return 's, 's)
)
;;
(when neg (0 =T= 'M) -->
nf('s : bool <- read ('ShareSum['M (fun 'wire0 'B)]), return 's, 's)
)
       in P
       ] 
       {
       CASE-DISTINCTION-channel[
       cn:ChannelName <- 'ShareSum['M 'B]
      ]
      { pSubstFamCaseChnSSNot(  0 =T= 'm,
         nf('s : bool <- read ('Share[0 (fun 'wire0 'B)]), return 's, 's)
        )
        , 
       CASE-DISTINCTION-channel-end-when[
       cn:ChannelName <- 'ShareSum['M 'B]
      ]{
      pSubstFamCaseChnSSNot( neg( 0 =T= 'm),
         nf(('xm : bool <- read ('Share['M (fun 'wire0 'B)])) 
             'xs : bool <- read ('ShareSum[('M -- 1) (fun 'wire0 'B)]), 
             return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
        )
      ; applyAlphaNFPr(
            chn ('ShareSum['M 'B]), 
                         << 'xm, 'new >> << 'xs, 's >>  emptyQidPairList)   
      }
      }
      }
 .
 
strat pSubstFamCaseChnSSNot : BoolTerm Reaction  @ ProtocolConfig .
sd pSubstFamCaseChnSSNot(bt, R) :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{pSubstFamCaseChnSSNot(bt, R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('ShareSum[bound (N + 1) bound 'B]) ) 
          (chn ('ShareSum['M 'B])), 
        P1:Protocol <- keepTwo P 
          (fam ('ShareSum[bound (N + 1) bound 'B]) ) 
          (chn ('ShareSum['M 'B]))
        ]{
 select-case-subst-family-r-gen[
          bt:BoolTerm <- bt 
        ]{substNFFamilyOne(
           fam ('ShareSum[bound (N + 1) bound 'B]), 'ShareSum['M 'B], 
           R )
         }
         }) 
 .        
 
 strat revertSharesBoundNotAux @ ProtocolConfig .
 sd revertSharesBoundNotAux := 
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
         fam ('ShareSum[bound (N + 1) fixedBound 'B])
        with
         (when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'B]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'B])) 'xs : bool <- read ('ShareSum[('m -- 1)
    'B]), return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
        in
        P
       ] 
       { rewriteSharesBoundNotAux }
       
 .           

 strat revertShareNot @ ProtocolConfig . 
 sd revertShareNot := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('Share[(N + 1) 'B])
        with
        nf(('x : bool <- read ('ShareSum[(N + 1) 'B])) 
            'xs : bool <- read ('ShareSum[N 'B]), 
            return (ap 'xor pair('xs, 'x)), 'xs 'x)
        in P
       ]
       {  substNF('ShareSum[(N + 1) 'B], 'Share[(N + 1) 'B])
       ; applyReturnIdem(chn ('Share[(N + 1) 'B]))
       }
       .
  
 strat setupSymNot @ ProtocolConfig .
 sd setupSymNot :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('Share[(N + 1) 'B])
        with
         nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'B)])) 
             'xs : bool <- read ('ShareSum[N 'B]), return (ap 'neg 'x), 'xs 'x)
         
        in (
        change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf(('xm : bool <- read ('Share[(N + 1) 'B])) 
             'xs : bool <- read ('ShareSum[N 'B]), 
             return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
        in 
        P)
       ]
       *** this is from notSS, turn to sym
       {
     
     substNF('Share[(N + 1) 'B], 'ShareSum[(N + 1) 'B])
 
   ; revertShareNot
    
   ; rewriteSharesBoundNotAux
   
   ; substNFFamilyOne(
      fam ('ShareSum[bound (N + 1) fixedBound 'B]),
      'ShareSum[(N + 1) 'B],
      nf('s : bool <- read ('ShareSum[N (fun 'wire0 'B)]), return 's, 's)
    )
    
   ; revertSharesBoundNotAux 
    
   ; applyReturnNegOverXor(chn ('ShareSum[(N + 1) 'B]))  
   
  ; applyRemoveFromGroupCases(
       fam ('Shares[bound 'B]),
       fam ('ShareSum[fixedBound (N + 1) bound 'B])
       )
   
  ; applyAllSameCases(fam ('ShareSum[fixedBound (N + 1) bound 'B]))  
   
  ; psymNot
    
  ; applyAddToGroupCases( 
       fam ('ShareSum[fixedBound (N + 1) bound 'B]), 
       fam ('Shares[bound 'B]) )
  }
  
     
     
     
       ***( this was here, keep to see if you need it later
       
       
       ;
       substNF('Share[(N + 1) 'B], 'ShareSum[(N + 1) 'B])
   ; revertShareNot
   
   
   ; applyRemoveMergeFromGroupCases(
       fam ('Shares[bound 'B]),
       fam ('ShareSum[bound (N + 1) bound 'B])
     )
   ; rewriteSharesBoundNotAux
   
   ; substNFFamilyOne(
           fam ('ShareSum[bound (N + 1) bound 'B]), 
           'ShareSum[(N + 1) 'B],
           nf('s : bool <- read ('ShareSum[N (fun 'wire0 'B)]), return 's, 's)
     )
   ; revertSharesBoundNotAux 
   
   
   ; applyReturnNegOverXor(chn ('ShareSum[(N + 1) 'B]))
   
   ; applyAddToGroupCases( fam ('ShareSum[bound (N + 1) bound 'B]), fam ('Shares[bound 'B]) )
   
   ; applyRemoveFromGroupCases(
       fam ('Shares[bound 'B]),
       fam ('ShareSum[fixedBound (N + 1) bound 'B])
     )
   ; applyAllSameCases(fam ('ShareSum[fixedBound (N + 1) bound 'B]))  
   
   ; psymNot
    
   ; applyAddToGroupCases( 
       fam ('ShareSum[fixedBound (N + 1) bound 'B]), 
       fam ('Shares[bound 'B]) )
   )     
 .      

*** strategies for input
  
 strat pSymInd0 @ ProtocolConfig .
 sd pSymInd0 :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I])
        with
         (when (0 =T= 'm) -->
nf('in : unit <- read ('InShare$-OK[0 'p 'i]), return (), 'in))
;;
when neg (0 =T= 'm) -->
nf(('s : unit <- read ('InShare$Sum-OK[('m -- 1) 'p 'i])) 
    'x : unit <- read ('InShare$-OK['m 'p 'i]),
    return (), 's 'x)
        in P
        ]
      { 
        CONG-NEW-NF{
        alpha-family-three-top[
           fns:NameWithScripts <- 'InShare$-Sum, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'i,
           q4:Qid <- 'm,
           q5:Qid <- 'p,
           q6:Qid <- 'i] 
           
   ; alpha-family-three-top[
           fns:NameWithScripts <- 'InShare$, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'i,
           q4:Qid <- 'm,
           q5:Qid <- 'p,
           q6:Qid <- 'i]
           }
          
  ; CONG-NEW-NF{pSetupInd0
 
  ; alpha-family-three-top[
           fns:NameWithScripts <- 'InShare$-Sum, 
           q1:Qid <- 'm,
           q2:Qid <- 'p,
           q3:Qid <- 'i,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'i] 
   ; alpha-family-three-top[
           fns:NameWithScripts <- 'InShare$, 
           q1:Qid <- 'm,
           q2:Qid <- 'p,
           q3:Qid <- 'i,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'i]

        }    
        }                    
 . 
 
 strat pSetupInd1 @ ProtocolConfig .
 sd pSetupInd1 := 
 ***(
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (family ('InShare$Sum-OK[(bound (N + 1))(bound (N + 2))(dependentBound 'I)])
 ('m 'p 'i)
 ((bound (N + 1))(bound (N + 2))(dependentBound 'I) ) 
 ::= 
  nf('i : bool  <- read ('In-OK['p 'i]),
             return (), 'i)
 ) 'm 'M,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P 'InShare$Sum-OK 'm 'M A 
        (family ('InShare$Sum-OK[(bound (N + 1))(bound (N + 2))(dependentBound 'I)])
 ('m 'p 'i)
 ((bound (N + 1))(bound (N + 2))(dependentBound 'I) ) 
 ::= 
  nf('i : bool  <- read ('In-OK['p 'i]),
             return (), 'i)
 )),
       P1:Protocol <- getInductionBase P 'InShare$Sum-OK 'm 'M A
       (family ('InShare$Sum-OK[(bound (N + 1))(bound (N + 2))(dependentBound 'I)])
 ('m 'p 'i)
 ((bound (N + 1))(bound (N + 2))(dependentBound 'I) ) 
 ::= 
  nf('i : unit  <- read ('In-OK['p 'i]),
             return (), 'i)
 ),
       A':Set{BoolTerm} <-  (A,'M <T N + 1)                
       ] ;
      ) 
      SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'InShare$Sum-OK,
  blist:List{Bounds} <- (bound (N + 1)) bound (N + 2) dependentBound 'I,
  cases':Cases <- 
   nf('i : unit  <- read ('In-OK['p 'i]),
             return (), 'i)
   ]{
       *** induction proof here
       CASE-DISTINCTION-one-R[
     fns:NameWithScripts <- 'InShare$Sum-OK,
     blist:List{Bounds} <- fixedBound 'M bound (N + 2) dependentBound 'I  
     ] {substNFFamiliesGen(
      fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]) ,
      fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
      nf('i : unit <- read ('In-OK['p 'i]), return (), 'i)
     ), 
     CASE-DISTINCTION-one-R-end-when[
     fns:NameWithScripts <- 'InShare$Sum-OK,
     blist:List{Bounds} <- fixedBound 'M bound (N + 2) dependentBound 'I  
     ] {
     substNFFamiliesGen(
      fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]) ,
      fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
      nf('i : unit <- read ('In-OK['p 'i]), return (), 'i)
      ) 
      ;
      substNFFamiliesGen(
      fam ('InShare$Sum-OK[bound 'M bound (N + 2) dependentBound 'I]) ,
      fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
      nf('i : unit <- read ('In-OK['p 'i]), return (), 'i)
     )  

     }
     }
     ; applyAllSameCases( 
        fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]) 
       )
    }   
 .
 
  
 strat pSetupInd0 @ ProtocolConfig .
 sd pSetupInd0 :=
 ***( 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (family ('InShare$Sum-OK[(bound (N + 1))(bound (N + 2))(dependentBound 'I)])
 ('m 'p 'i)
 ((bound (N + 1))(bound (N + 2))(dependentBound 'I) ) 
 ::= 
  nf('i : bool  <- read ('InShare$-Sum['m 'p 'i]),
             return (), 'i)
 ) 'm 'M,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(getInductionBase P 'InShare$Sum-OK 'm 'M A 
        (family ('InShare$Sum-OK[(bound (N + 1))(bound (N + 2))(dependentBound 'I)])
 ('m 'p 'i)
 ((bound (N + 1))(bound (N + 2))(dependentBound 'I) ) 
 ::= 
  nf('i : bool  <- read ('InShare$-Sum['m 'p 'i]),
             return (), 'i)
 )),
       P1:Protocol <- getInductionBase P 'InShare$Sum-OK 'm 'M A
       (family ('InShare$Sum-OK[(bound (N + 1))(bound (N + 2))(dependentBound 'I)])
 ('m 'p 'i)
 ((bound (N + 1))(bound (N + 2))(dependentBound 'I) ) 
 ::= 
  nf('i : bool  <- read ('InShare$-Sum['m 'p 'i]),
             return (), 'i)
 ),
       A':Set{BoolTerm} <-  (A,'M <T N + 1)                
       ]
       
       ; )
       SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'InShare$Sum-OK,
  blist:List{Bounds} <- (bound (N + 1)) bound (N + 2) dependentBound 'I,
  cases':Cases <- 
   nf('i : bool  <- read ('InShare$-Sum['m 'p 'i]),
             return (), 'i)
   ]
       {
       CASE-DISTINCTION-one-R[
     fns:NameWithScripts <- 'InShare$Sum-OK,
     blist:List{Bounds} <- fixedBound 'M bound (N + 2) dependentBound 'I  
     ] {
     
     substNFFamiliesGen(
      fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]) ,
      fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
      nf('i : bool <- read ('InShare$[0 'p 'i]), return (), 'i)
     )
     
     ; sym1$SumOK
     , CASE-DISTINCTION-one-R-end-when[
     fns:NameWithScripts <- 'InShare$Sum-OK,
     blist:List{Bounds} <- fixedBound 'M bound (N + 2) dependentBound 'I  
     ] {
     substNFFamiliesGen(
      fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]) ,
      fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
      nf('i : bool <- read ('InShare$['M 'p 'i]), return (), 'i)
     )
     ; applyAlphaNFPr(
            fam ('InShare$Sum-OK[fixedBound 'M (bound (N + 2))(dependentBound 'I)]), 
                         << 'i, 'x >> emptyQidPairList) 
                         
     ; substNFFamiliesGen(
      fam ('InShare$Sum-OK[bound 'M bound (N + 2) dependentBound 'I]) ,
      fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
      nf('i : bool <- read ('InShare$-Sum[('M -- 1) 'p 'i]), return (), 'i)
     )  
     ; applyAlphaNFPr(
            fam ('InShare$Sum-OK[fixedBound 'M (bound (N + 2))(dependentBound 'I)]), 
                         << 'i, 's >> emptyQidPairList) 
     ; sym2$SumOK                                       
     }
     } 
     ; applyAllSameCases( fam ('InShare$Sum-OK[fixedBound 'M (bound (N + 2))(dependentBound 'I)]) )  
     }  
.

  strat sym2$SumOK @ ProtocolConfig .
  sd sym2$SumOK :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('InShare$Sum-OK[fixedBound 'M (bound (N + 2))(dependentBound 'I)])
        with
         nf('i : bool  <- read ('InShare$-Sum['M 'p 'i]),
             return (), 'i)
        in P
        ]
        { substSym2$SumOK
        }                 
        
  .
  
 strat substSym2$SumOK @ ProtocolConfig .
 sd substSym2$SumOK :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substSym1$SumOK} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])) 
          (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])), 
        P1:Protocol <- keepTwo P 
          (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])) 
          (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]))
        ]{
         select-case-subst-family-r[
           bt:BoolTerm <- neg ('m =T= 0)
         ]{substNFFamiliesGen(
             fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
             nf(('s : bool <- read ('InShare$-Sum[('M -- 1) 'p 'i])) 
                 'x : bool <- read ('InShare$['M 'p 'i]),
                   return (ap 'xor pair('s, 'x)), 's 'x)
           )}
       }
             )
 . 
  
  strat sym1$SumOK @ ProtocolConfig .
  sd sym1$SumOK :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('InShare$Sum-OK[fixedBound 'M (bound (N + 2))(dependentBound 'I)])
        with
         nf('i : bool  <- read ('InShare$-Sum['M 'p 'i]),
             return (), 'i)
        in P
        ]
        { substSym1$SumOK
        ; applyAlphaNFPr(
            fam ('InShare$Sum-OK[fixedBound 'M (bound (N + 2))(dependentBound 'I)]), 
                         << 'in, 'i >> emptyQidPairList)
        }                 
        
  .
  
  
 strat substSym1$SumOK @ ProtocolConfig .
 sd substSym1$SumOK :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substSym1$SumOK} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])) 
          (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])), 
        P1:Protocol <- keepTwo P 
          (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])) 
          (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]))
        ]{
         select-case-subst-family-r[
           bt:BoolTerm <- ('m =T= 0)
         ]{substNFFamiliesGen(
             fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
             nf('in : bool <- read ('InShare$[0 'p 'i]), return 'in, 'in)
           )}
       }
             )
 . 

 strat symInShare$ @ ProtocolConfig .
 sd symInShare$ :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I])
        with
         nf(('i : unit <- read ('In-OK['p 'i]) )
             , return (), 'i)
        in P
        ]
        { substNFFamiliesGen(
             fam ('In-OK[((bound (N + 2))(dependentBound 'I))]),
             fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]),
             nf('i : bool  <- read ('In['p 'i]),
             return (), 'i)
             ) 
        ; applyAlphaNFPr(fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]), 
                         << 'i, 'x >> emptyQidPairList)
        }                          
 .
  
 strat dropInShare$ @ ProtocolConfig .
 sd dropInShare$ :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{dropInShare$} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I])) 
          (fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I])), 
        P1:Protocol <- keepTwo P 
          (fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I])) 
          (fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]))
        ]{
        
         alpha-family-three-top[
           fns:NameWithScripts <- 'InShare$, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'i,
           q4:Qid <- 'm,
           q5:Qid <- 'p,
           q6:Qid <- 'i]  
        ;
         select-case-subst-family-r[
           bt:BoolTerm <- neg ('m =T= N + 1)
         ]{DROP-SUBSUME-families-gen}
        ;
         alpha-family-three-top[
           fns:NameWithScripts <- 'InShare$, 
           q1:Qid <- 'm,
           q2:Qid <- 'p,
           q3:Qid <- 'i,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'i]  
       }
             )
 .     
  
 strat sym$SumOK @ ProtocolConfig .
 sd sym$SumOK :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf(('s : unit <- read ('InShare$Sum-OK[N (fun 'wire0 'B) (fun 'wire1 'B)]))
             'x : bool <- read ('In[(fun 'wire0 'B) (fun 'wire1 'B)]), return 'x, 'x 's)
        in P
       ]
       {
       substNFFamilyOne(
              fam ('InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I]),
              'ShareSum[(N + 1) 'B],
              nf('i : bool  <- read ('InShare$-Sum[N (fun 'wire0 'B) (fun 'wire1 'B)]),
             return (), 'i)
              )
           
       ; applyAlphaNFPr(chn ('ShareSum[(N + 1) 'B]), 
                         << 'i, 's >> emptyQidPairList)        
       }
 .
  
 strat removeInternalsInputBranch @ ProtocolConfig .
 sd removeInternalsInputBranch := 
          sugar-newNF
        ; absorbFamily(fam ('In-OK[((bound (N + 2))(dependentBound 'I))]))
        ; absorbFamily(fam ('InShare$-OK[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]))
        ; absorbFamilyDeleteEmpty(
            fam ('InShare$Sum-OK[((bound (N + 1))(bound (N + 2))(dependentBound 'I))])
          )
 .

 strat addInternalsInputBranch @ ProtocolConfig .
 sd addInternalsInputBranch := 
    
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'In-OK
         typed unit
         params ('p 'i)
                ((bound (N + 2))(dependentBound 'I))  
         assigned
          nf('i : bool  <- read ('In['p 'i]),
             return (), 'i)
         in (
         addInternalFamily
           'InShare$-OK
         typed unit
         params ('m 'p 'i)
                ((bound (N + 1))(bound (N + 2))(dependentBound 'I) )  
         assigned
          nf('i : bool  <- read ('InShare$['m 'p 'i]),
             return (), 'i)
         in (
         addInternalFamily
           'InShare$Sum-OK
         typed unit
         params ('m 'p 'i)
                ((bound (N + 1))(bound (N + 2))(dependentBound 'I) )  
         assigned
          nf('i : bool  <- read ('InShare$-Sum['m 'p 'i]),
             return (), 'i)
         in P
         )
         )        
       ]{ sugar-newNF
        ; absorbFamily(fam ('In-OK[((bound (N + 2))(dependentBound 'I))]))
        ; absorbFamily(fam ('InShare$-OK[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]))
        ; absorbFamilyDeleteEmpty(
            fam ('InShare$Sum-OK[((bound (N + 1))(bound (N + 2))(dependentBound 'I))])
          )
        } ***sym
       )
 .   
 
 strat revertShareSum @ ProtocolConfig . 
 sd revertShareSum := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('ShareSum[bound (N + 1) fixedBound 'B])
        with
        (when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'B]), return 's, 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'B])) 'xs : bool <- read ('ShareSum[('m -- 1) 'B]), 
 return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
        in P
       ]{
          indShareSum
       }
 .
  
 strat indShareSum @ ProtocolConfig .
 sd indShareSum := 
 SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'ShareSum,
  blist:List{Bounds} <- bound (N + 1) fixedBound 'B,
  cases':Cases <- 
   nf('i : bool <- read ('InShare$-Sum['m (fun 'wire0 'B) (fun 'wire1 'B)]), 
              return 'i, 'i)
   ] ***(
       matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (family 'ShareSum[bound (N + 1) fixedBound 'B] 
            ('m 'k) (bound (N + 1) fixedBound 'B) ::=
           nf('i : bool <- read ('InShare$-Sum['m (fun 'wire0 'B) (fun 'wire1 'B)]), 
              return 'i, 'i)
          ) 'm 'M,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(
          getInductionBase P  'ShareSum 'm 'M A 
          (family 'ShareSum[bound (N + 1) fixedBound 'B] 
            ('m 'k) (bound (N + 1) fixedBound 'B) ::=
           nf('i : bool <- read ('InShare$-Sum['m (fun 'wire0 'B) (fun 'wire1 'B)]), 
              return 'i, 'i)
          )
        ),
       P1:Protocol <- 
         getInductionBase P  'ShareSum 'm 'M A 
          (family 'ShareSum[bound (N + 1) fixedBound 'B] 
            ('m 'k) (bound (N + 1) fixedBound 'B) ::=
           nf('i : bool <- read ('InShare$-Sum['m (fun 'wire0 'B) (fun 'wire1 'B)]), 
              return 'i, 'i)
          )
       ,
       A':Set{BoolTerm} <-  (A,'M <T N + 1)                
       ] 
       ;
       )
       {
        CASE-DISTINCTION-channel[
         cn:ChannelName <- 'ShareSum['M 'B]
        ]{substNFFamilyOne(
           fam ('Share[bound (N + 1) fixedBound 'B]),
           'ShareSum['M 'B],
           nf('in : bool <- read ('InShare[0 (fun 'wire0 'B) (fun 'wire1 'B)]), 
              return 'in, 'in) 
          )
          ;
          substNFFamilyOne(
           fam ('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]),
           'ShareSum['M 'B],
           nf('in : bool <- read ('InShare$[0 (fun 'wire0 'B) (fun 'wire1 'B)]), 
              return 'in, 'in) 
          )
          ; symSS
          , CASE-DISTINCTION-channel-end-when[
         cn:ChannelName <- 'ShareSum['M 'B]
        ]{substNFFamilyOne(
           fam ('Share[bound (N + 1) fixedBound 'B]),
           'ShareSum['M 'B],
           nf('in : bool <- read ('InShare['M (fun 'wire0 'B) (fun 'wire1 'B)]), 
              return 'in, 'in) 
              
          )
          ; substNFFamilyOne(
           fam ('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]),
           'ShareSum['M 'B],
           nf('in : bool <- read ('InShare$['M (fun 'wire0 'B) (fun 'wire1 'B)]), 
              return 'in, 'in) 
          )  
          ;
          substNFFamilyOne(
           fam ('ShareSum[bound 'M fixedBound 'B]),
           'ShareSum['M 'B],
           nf('i : bool <- read ('InShare$-Sum[('M -- 1) (fun 'wire0 'B) (fun 'wire1 'B)]),
              return 'i, 'i) 
          )
          ; applyAlphaNFPr(chn ('ShareSum['M 'B]), 
                             << 'i, 's >> << 'in, 'x >>
                            emptyQidPairList )
          ; symSS2                   
          }
        }
       ; applyAllSameCases(chn ('ShareSum['M 'B]))
       ; applyAlphaNFPr(chn ('ShareSum['M 'B]), 
                             << 'in, 'i >>
                            emptyQidPairList )
  }
 . 
 
 strat symSS @ ProtocolConfig .
 sd symSS := matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum['M 'B])
        with
         nf('in : bool <- read ('InShare$-Sum['M (fun 'wire0 'B) (fun 'wire1 'B)]), 
            return 'in, 'in)
        in P
       ]
       {
        matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using CONG-COMP-RIGHT[
         Q:Protocol  <- 
           removeTwo P' 
            (chn ('ShareSum['M 'B])) 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])), 
         P1:Protocol <- 
           keepTwo P' 
            (chn ('ShareSum['M 'B])) 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]))
          ]{
            select-case-subst-family-r-gen[
            bt:BoolTerm <- (0 =T= 'm)
           ]{ 
           substNFFamilyOne(
             (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])),
             'ShareSum['M 'B], 
             nf('in : bool <- read ('InShare$[0 (fun 'wire0 'B) (fun 'wire1 'B)]), 
                return 'in, 'in)
             ) 
               
             }
            
             
             
         }   
       
       }
 .
 
 strat symSS2 @ ProtocolConfig .
 sd symSS2 := matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum['M 'B])
        with
         nf('in : bool <- read ('InShare$-Sum['M (fun 'wire0 'B) (fun 'wire1 'B)]), 
            return 'in, 'in)
        in P
       ] 
       {
        matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using CONG-COMP-RIGHT[
         Q:Protocol  <- 
           removeTwo P' 
            (chn ('ShareSum['M 'B])) 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])), 
         P1:Protocol <- 
           keepTwo P' 
            (chn ('ShareSum['M 'B])) 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]))
          ]{
            select-case-subst-family-r-gen[
            bt:BoolTerm <- neg (0 =T= 'm)
           ]{ 
           substNFFamilyOne(
             (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])),
             'ShareSum['M 'B],
             nf(('s : bool <- read ('InShare$-Sum[('M -- 1) (fun 'wire0 'B) (fun 'wire1 'B)])) 
                 'x : bool <- read ('InShare$['M (fun 'wire0 'B) (fun 'wire1 'B)]),
                 return (ap 'xor pair('s, 'x)), 's 'x)
             ) 
               
             }
          
             
             
         } 
         }
      
 .
 
  
 strat setupSymInput @ ProtocolConfig .
 sd setupSymInput :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('Share[(N + 1) 'B])
        with
         nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'B) (fun 'wire1 'B)])) 
             'xs : bool <- read ('ShareSum[N 'B]), return 'in, 'xs 'in)
        in (
        change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf(('xm : bool <- read ('Share[(N + 1) 'B])) 
             'xs : bool <- read ('ShareSum[N 'B]), 
             return (ap 'xor pair('xs, 'xm)), 'xs 'xm)
        in 
        P)
       ]{
         substNF('Share[(N + 1) 'B], 'ShareSum[(N + 1) 'B])
         *** Share
       ; setupSymInput2
       
         *** ShareSum
        ; indShareSum 
        ; substNFFamilyOne(
           fam ('ShareSum[bound (N + 1) fixedBound 'B]), 
           'ShareSum[(N + 1) 'B],
           nf('i : bool <- read ('InShare$-Sum[N (fun 'wire0 'B) (fun 'wire1 'B)]), 
              return 'i, 'i)
        )
        ; revertShareSum
        
        ; substNFFamilyOne(
           fam ('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]), 
           'ShareSum[(N + 1) 'B],
            nf('in : bool <- read ('InShare$[(N + 1) (fun 'wire0 'B) (fun 'wire1 'B)]), 
               return 'in, 'in)
        )
        ; substNFFamilyOne(
           fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]), 
           'ShareSum[(N + 1) 'B],
            nf(('s : bool <- read ('InShare$-Sum[N (fun 'wire0 'B) (fun 'wire1 'B)])) 
            'x : bool <- read ('In[(fun 'wire0 'B) (fun 'wire1 'B)]),
            return (ap 'xor pair('x, 's)), 'x 's)
        )
        ; applyReturnIdem2(chn ('ShareSum[(N + 1) 'B]))
       ; addInternalsInputBranch
       *** from here until remove we work in a newNF
       
       ; sym$SumOK
       
       
       *** must happen before InShare$-OK changes
       ; pSymInd0
       
       *** now we do that change
       
       ; dropInShare$
       ; symInShare$
       
       ; CONG-NEW-NF{pSetupInd1}
       
       ; substNFFamilyOne(
      fam ('InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I]) ,
      'ShareSum[(N + 1) 'B],
      nf('i : unit <- read ('In-OK[(fun 'wire0 'B) (fun 'wire1 'B)]), return (), 'i)
      ) 
      
      ; substNFFamilyOne(
      fam ('In-OK[bound (N + 2) dependentBound 'I]) ,
      'ShareSum[(N + 1) 'B],
      nf('i : bool <- read ('In[(fun 'wire0 'B) (fun 'wire1 'B)]), return (), 'i)
      ) 
      ; applyAlphaNFPr(
           chn ('ShareSum[(N + 1) 'B]), 
                         << 'x, 'i >> emptyQidPairList)
      ; removeInternalsInputBranch 
      }
 .   
 
 strat setupSymInput2 @ ProtocolConfig .
 sd setupSymInput2 :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('Share[(N + 1) 'B])
        with
         nf(('x : bool <- read ('ShareSum[(N + 1) 'B])) 
             'xs : bool <- read ('ShareSum[N 'B]), 
            return (ap 'xor pair('xs, 'x)), 'xs 'x)
        in P
       ] 
       { substNF('ShareSum[(N + 1) 'B], 'Share[(N + 1) 'B])
       ; applyReturnIdem( chn ('Share[(N + 1) 'B]) )
       }
 .        

 ****************************************************************
 
 strat eliminateOTDivergent @ ProtocolConfig .
 sd eliminateOTDivergent := 
 
           applyDivergeChannel3FamilyBranch(
            fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
            apply 'isSemiHonest 'n, 'om, bool)

         ; applyAllSameCases(
            fam (('OTMsg-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
           )
         
         ; applyDivergeChannel3FamilyBranch(
           fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
           fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
           apply 'isHonest 'n, 'om, unit)
           
         ; applyAllSameCases(
            fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv) 
              [(bound (N + 2) (bound (N + 2)) (bound K))])   
           )

         ; applyDivergeChannel3FamilyBranch(
            fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
            apply 'isSemiHonest 'n, 'om, bool)
            
         ; applyAllSameCases(
            fam (('OTMsg-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
           )
         
         ; applyDivergeChannel3FamilyBranch(
           fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
           fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
           apply 'isHonest 'n, 'om, unit)
           
         ; applyAllSameCases(
            fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv) 
              [(bound (N + 2) (bound (N + 2)) (bound K))])   
           )
         
         ; applyDivergeChannel3FamilyBranch(
            fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
            apply 'isSemiHonest 'n, 'om, bool)
            
         ; applyAllSameCases(
            fam (('OTMsg-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
           )
         
         ; applyDivergeChannel3FamilyBranch(
           fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
           fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
           apply 'isHonest 'n, 'om, unit)
           
         ; applyAllSameCases(
            fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv) 
              [(bound (N + 2) (bound (N + 2)) (bound K))])   
           )
         
         ; applyDivergeChannel3FamilyBranch(
            fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
            apply 'isSemiHonest 'n, 'om, bool)
            
         ; applyAllSameCases(
            fam (('OTMsg-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
           )
         
         ; applyDivergeChannel3FamilyBranch(
           fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
           fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
           apply 'isHonest 'n, 'om, unit)
           
         ; applyAllSameCases(
            fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv) 
              [(bound (N + 2) (bound (N + 2)) (bound K))])   
           )
                                  
         ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-0, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k]  
           
          ; applyDivergeChannel3FamilyBranch(
             fam ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam (('OTChc-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]), 
             apply 'isSemiHonest 'm, 'oc, bool
            )
            
          ; applyAllSameCases(
             fam (('OTChc-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
            )
           
          ; applyDivergeChannel3FamilyBranch(
             fam ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]), 
              apply 'isHonest 'm, 'oc, unit)
              
          ; applyAllSameCases(
              fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
            )
          ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-0, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k] 
           
          ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-1, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k]  
        
          ; applyDivergeChannel3FamilyBranch(
             fam ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam (('OTChc-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]), 
             apply 'isSemiHonest 'm, 'oc, bool
            )
            
          ; applyAllSameCases(
             fam (('OTChc-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
            )
          
          ; applyDivergeChannel3FamilyBranch(
             fam ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]), 
              apply 'isHonest 'm, 'oc, unit)
              
          ; applyAllSameCases(
              fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
            )
          
          ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-1, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]  
              
          ; applySubstDivergeFamily(
             fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam ('OTOut[(bound (N + 2) (bound (N + 2)) (bound K))]), 'o, bool)
       
          ; applyDivergeChannel3FamilyBranch(
             fam ('OTOut[(bound (N + 2) (bound (N + 2)) (bound K))]), 
             fam (('OTOut ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]), 
             apply 'isSemiHonest 'm, 'out, bool)
          ; applyAllSameCases(
             fam (('OTOut ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
            )  
               
 .    
          
endsm 

************************************
*** proofs start here

*** real to restr
srew [1] pConfig(sig,
             (fam (('InRcvd ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) :: unit) 
             (fam (('InShare$-Sum ^^ 'party .. 'adv)[(bound (N + 1))((bound (N + 2))(dependentBound 'I))]) :: bool)
             (fam (('InShare$ ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]):: bool)
             (fam (('InShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) :: bool)
             (fam (('In ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) :: bool)  
             (fam (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit)
             (fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam ('Out[((bound (N + 2))(bound K))]) :: bool)    
             (fam (('OutShareSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool)
             (fam (('Out ^^ 'party .. 'adv)[((bound (N + 2))(bound K))]) :: bool)  
             (fam (('RcvdInShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) :: bool)  
             (fam (('RcvdOutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('SendInShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) :: bool) 
             (fam (('SendOutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool)  
             (fam (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))]) :: bool)
             (fam (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool)
             (fam (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool)  
             (fam ('In[(bound (N + 2)) (dependentBound 'I)]) :: bool)
             ,
             real,
             fam ('In[(bound (N + 2)) (dependentBound 'I)]), 
             getOutputs(real),
             genA) 
using  
       sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)

       ; applyAddToGroupCases(
          fam (('OTChc-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         ) 
       ; applyAddToGroupCases(
          fam (('OTChc-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         ) 
       ; applyAddToGroupCases(
          fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         )
       ; applyAddToGroupCases(
          fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         )
         
       ; applyAddToGroupCases(
          fam (('OTMsg-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         )
       ; applyAddToGroupCases(
          fam (('OTMsg-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         )
       ; applyAddToGroupCases(
          fam (('OTMsg-2 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
        )
       ; applyAddToGroupCases(
          fam (('OTMsg-3 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
       )
       ; applyAddToGroupCases(
          fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         )
       ; applyAddToGroupCases(
          fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         )
       ; applyAddToGroupCases(
          fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
        )
       ; applyAddToGroupCases(
          fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
       ) 
       
       ; applyAddToGroupCases(
          fam ('OTOut[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
       )  
       
       ; applyAddToGroupCases(
          fam (('OTOut ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
       ) 
       *** restructure the real protocol 10.4     
       ; matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using  
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
         P1:Protocol <- restr]{
          sugar-newNF
        ; moveNewToFront
        ; reorder-newNF[ql2:List{CNameBound} <-
           (fam ('SendInShare[(bound (N + 2)) (bound (N + 2)) (dependentBound 'I)]) )
 (fam ('OTMsg-0[(bound (N + 2)) (bound (N + 2)) (bound K)]) )
 (fam ('OTMsg-1[(bound (N + 2)) (bound (N + 2)) (bound K)]) )
 (fam ('OTMsg-2[(bound (N + 2)) (bound (N + 2)) (bound K)]) )
 (fam ('OTMsg-3[(bound (N + 2)) (bound (N + 2)) (bound K)]) )
 (fam ('OTChc-0[(bound (N + 2)) (bound (N + 2)) (bound K)]) )
 (fam ('OTChc-1[(bound (N + 2)) (bound (N + 2)) (bound K)]) )
 (fam ('OTOut[(bound (N + 2)) (bound (N + 2)) (bound K)]) )
 (fam ('SendOutShare[(bound (N + 2)) (bound (N + 2)) (bound K)]) )
 (fam ('InShare[(bound (N + 2)) (bound (N + 2)) (dependentBound 'I)]) )
 (fam ('Share[(bound (N + 2)) (bound K)]) )
 (fam ('InShare$[(bound (N + 2)) (bound (N + 2)) (dependentBound 'I)]) )
 (fam ('InShare$-Sum[(bound (N + 1)) (bound (N + 2)) (dependentBound 'I)]) )
 (fam ('OutShare[(bound (N + 2)) (bound (N + 2)) (bound K)]) )
 (fam ('OutShareSum[(bound (N + 2)) (bound (N + 2)) (bound K)]) )
 (fam ('SendBit[(bound (N + 2)) (bound (N + 2)) (bound K)]) )
 (fam ('RcvdBit[(bound (N + 2)) (bound (N + 2)) (bound K)]) )
 (fam ('Ctrb[(bound (N + 2)) (bound (N + 2)) (bound K)]) )
 (fam ('CtrbSum[(bound (N + 2)) (bound (N + 2)) (bound K)]) )
        ]
       }
       ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
             
       *** 10.4.1 Simplifying The Real Protocol: Initial Phase
       
       ; applySubstFamily3IdxCase(
          fam ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]), 
          fam (('SendInShare ^^ 'party .. 'adv)
            [((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]), 
          'm, 'n, 'i, 
         nf('in : bool <- read ('InShare$['m 'n 'i]), 
                              return 'in, 'in),
         nf('in : bool <- read ('InShare$['m 'n 'i]), 
                              return 'in, 'in),
         apply 'isSemiHonest 'n)
       
       ; alpha-family-three[
           fns:NameWithScripts <- 'SendInShare, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'i,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'i]
       
       ; applySubstFamily3IdxCase(
           fam ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]),
           fam (('RcvdInShare ^^ 'party .. 'adv)
            [((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]), 
           'n, 'm, 'i, 
         nf('in : bool <- read ('InShare$['n 'm 'i]), 
                              return 'in, 'in),
         nf('in : bool <- read ('InShare$['n 'm 'i]), 
                              return 'in, 'in),
         apply 'isSemiHonest 'n)    
        
       ; substNFFamiliesThree(
           fam ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]), 
           fam ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]), 
                            nf('in : bool <- read ('InShare$['n 'm 'i]), 
                               return 'in, 'in)
                           ) 

       ; absorbFamily(
          fam ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))])
         ) 
                                                  
         
       *** 10.4.2 Simplifying The Real Protocol: Inductive Phase
        
       ; select-branch-family-p[bt:BoolTerm <- apply 'isInputGate 'k, 
                                fns:NameWithScripts <- 'Circuit]{
           eliminateOTDivergent          
         } 
               
       ; select-branch-family-p[bt:BoolTerm <- apply 'isNotGate 'k]{
           eliminateOTDivergent          
         }  
       ; select-branch-family-p[bt:BoolTerm <- apply 'isXorGate 'k]{
           eliminateOTDivergent          
         } 
         
       ; select-branch-family-p[bt:BoolTerm <- apply 'isAndGate 'k]{

         substDivergeJoinCases(
            fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return 'b, 'b 'x 'y),
                nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return 'b, 'b 'x 'y)
          )
   ;
          substDivergeJoinCases(
            fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,  
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair('x, 'b)), 
                'b 'x 'y),
            nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair('x, 'b)), 
                'b 'x 'y)    
          ) 
            ;
          substDivergeJoinCases(
             fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,   
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair('y, 'b)), 
                'b 'x 'y),
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair('y, 'b)), 
                'b 'x 'y)   
          )  
         ;
          substDivergeJoinCases(
            fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,   
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)), 
                'b 'x 'y),
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)), 
                'b 'x 'y)   
          )
        ;
         substDivergeJoinCases(
            fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (), 'b 'x 'y),
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return 'b, 'b 'x 'y)   
          )
       ;
          substDivergeJoinCases(
            fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (), 
                'b 'x 'y),
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair('x, 'b)), 
                'b 'x 'y)   
          )  
           ;
          substDivergeJoinCases(
             fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (), 
                'b 'x 'y),
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair('y, 'b)), 
                'b 'x 'y)   
          )
          ;
          substDivergeJoinCases( 
             fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
             fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (), 
                'b 'x 'y),
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)), 
                'b 'x 'y)   
          ) 
          ;
          substDivergeJoinCases(
             fam ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
             fam (('OTChc-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,
             nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), 
                return 'x, 'x),
             nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), 
                return 'x, 'x)  
          )
          ;
          substDivergeJoinCases(
             fam ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
             fam (('OTChc-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,
             nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), 
                return 'x, 'x),
             nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), 
                return 'x, 'x)  
          )
          ;
          substDivergeJoinCases(
             fam ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
             fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,
             nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), 
                return (), 'x),
             nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), 
                return 'x, 'x)  
          )
          ;
          substDivergeJoinCases(
             fam ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
             nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), 
                return (), 'x),
             nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), 
                return 'x, 'x)  
          )
         
          ; alpha-family-three[
           fns:NameWithScripts <- 'RcvdBit, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k] 
            
          ; CONG-NEW-NF{
             select-branch-family-r[bt:BoolTerm <- apply 'isSemiHonest 'm, 
                                    fns:NameWithScripts <- 'OTOut ^^ 'ot .. 'adv]{
                  substNFReadRevFamilies(
                    fam ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                    fam (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                    fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))])
                  )   
             }
           }       
            
          ; alpha-family-three[
           fns:NameWithScripts <- 'RcvdBit, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k]  
            
          ; substNFFamiliesThree(
             fam ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             nf(('c0 : bool <- read ('OTChc-0['m 'n 'k])) 
                ('c1 : bool <- read ('OTChc-1['m 'n 'k])) 
                ('m0 : bool <- read ('OTMsg-0['m 'n 'k])) 
                ('m1 : bool <- read ('OTMsg-1['m 'n 'k])) 
                ('m2 : bool <- read ('OTMsg-2['m 'n 'k]))  
                 'm3 : bool <- read ('OTMsg-3['m 'n 'k]), 
                if 'c0 then if 'c1 then return 'm3 else return 'm2 
                      else  if 'c1 then return 'm1 else return 'm0, 
                'm0 'm1 'm2 'm3 'c0 'c1)
          )  
  
          ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-0, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k] 
          
          ; applySubstOrDiverge(
            fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
            'z, 
            nf(('b : bool <- read ('SendBit['m 'n 'k])) 
               ('x : bool <- read ('Share['m (fun 'wire0 'k)])) 
                'y : bool <- read ('Share['m (fun 'wire1 'k)]), 
                return 'b, 'b 'x 'y)
            )   
           
        ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-1, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k] 
           
        ; applyGenSameCasesSubstFirstBranch(
            fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
            nf(('b : bool <- read ('SendBit['m 'n 'k])) 
               ('x : bool <- read ('Share['m (fun 'wire0 'k)])) 
                'y : bool <- read ('Share['m (fun 'wire1 'k)]), 
               return (ap 'xor pair('x, 'b)), 'b 'x 'y)
             ) 
         ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-2, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]       
         ; applyGenSameCasesSubstFirstBranch(
            fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
            nf(('b : bool <- read ('SendBit['m 'n 'k])) 
               ('x : bool <- read ('Share['m (fun 'wire0 'k)])) 
                'y : bool <- read ('Share['m (fun 'wire1 'k)]), 
                return (ap 'xor pair('y, 'b)), 
                'b  'x 'y)
             )  
            ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-3, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]  
            ; applyGenSameCasesSubstFirstBranch(
            fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
            nf(('b : bool <- read ('SendBit['m 'n 'k])) 
               ('x : bool <- read ('Share['m (fun 'wire0 'k)])) 
                'y : bool <- read ('Share['m (fun 'wire1 'k)]), 
                return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)), 
                'b 'x 'y)
             ) 
             ; applyAlphaBranchCond(
                 fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                 'x, 'xm, when ('m <T 'n) )  
             ; applyAlphaBranchCond(
                 fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                 'y, 'ym, when ('m <T 'n) ) 
             ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-0, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; applyGenSameCasesSubstFirstBranch(
            fam ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
            nf('x : bool <- read ('Share['n (fun 'wire0 'k)]), 
            return 'x, 'x)
             )  
             ; applyAlphaBranchCond(
             fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             'x, 'xn, when ('m <T 'n) 
             )   
             ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-1, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; applyGenSameCasesSubstFirstBranch(
            fam ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
            nf('x : bool <- read ('Share['n (fun 'wire1 'k)]), 
            return 'x, 'x)
             )  
           ; applyAlphaBranchCond(
                fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                'x, 'yn, when ('m <T 'n) )   
                
           *** undo all alphas 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-0, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-1, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-2, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-3, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-0, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]    
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-1, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k] 
           ; sym1 *** first branch of RcvdBit  
           ; alpha-family-three[
           fns:NameWithScripts <- 'SendBit, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]   
           ; sym2 *** second branch of RcvdBit  
           ; alpha-family-three[
           fns:NameWithScripts <- 'SendBit, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; applyAllSameCases(fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))])) 
         
         }   
        
         *** now we need to restructure Circuit in Adv + Shares + 1OutOf4OT
         
         ; applyNewCombine(fam ('Circuit[(bound (N + 2)) (bound K)]))       
      *** here we get to 5 mil rewrites when turning to a sym proof
         ; slowSym *** this brings me to pInt0
     *** end comment     
     ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)

       ; applyNewCombine(fam ('Adv[bound K]))
                
       ; applyNewCombine(fam ('Shares[bound K]))
       ; applyNewCombine(fam ('1OutOf4OT[bound K]))
    
       ; absorbFamily(fam ('OTOut[((bound (N + 2)) (bound (N + 2))(bound K) )]))
           
       ; absorbFamily(fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2))(bound K) )]))
       ; absorbFamily(fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2))(bound K) )]))
             
       ; absorbFamily(fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2))(bound K) )]))
       ; absorbFamily(fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2))(bound K) )]))

       ; absorbFamily(fam ('OTChc-0[((bound (N + 2)) (bound (N + 2))(bound K) )]))
       ; absorbFamily(fam ('OTChc-1[((bound (N + 2)) (bound (N + 2))(bound K) )]))

       ; matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
         P1:Protocol <- pInt1]{
               sugar-newNF
       ; moveNewToFront
       ; applyNewCombine(fam ('Adv[bound K]))
       ; applyNewCombine(fam ('Shares[bound K]))
       }
       ; sugar-newNF
      ; moveNewToFront
  
        *** 10.4.3 Simplifying The Real Protocol: Final Phase 
          
        ; substDivergeJoinCases(
             fam ('SendOutShare[bound (N + 2) bound (N + 2) bound K]) , 
            fam (('SendOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) ,  
            nf('s : bool <- read ('Share['n 'k]), return 's, 's),
            nf('s : bool <- read ('Share['n 'k]), return 's, 's)
          )
        
        ; alpha-family-three[
           fns:NameWithScripts <- 'SendOutShare, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k]   
                           
        ; substDivergeJoinCases(
            fam ('SendOutShare[bound (N + 2) bound (N + 2) bound K]) , 
            fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) ,   
            nf('s : bool <- read ('Share['m 'k]), return 's, 's),
            nf('s : bool <- read ('Share['m 'k]), return 's, 's)
          ) 
        ***
        ; applySubstOrDiverge(
            fam ('SendOutShare[bound (N + 2) bound (N + 2) bound K]),
            fam ('OutShare[bound (N + 2) bound (N + 2) bound K]),            
            'z, 
            nf('s : bool <- read ('Share['m 'k]), return 's, 's)    
          )
        *** at this point 'SendOutShare are unused and can be eliminated
        ; absorbFamily(fam ('SendOutShare[bound (N + 2) bound (N + 2) bound K]))  
        
        *** first some preliminaries, common to 10.4.4 and 10.4.5
         
             ; addShareSum 
     
     ; applySplitAllBranches(fam ('Adv[bound K]), 
         fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K])
       )  
     ; applySplitAllBranches(fam ('Adv[bound K]), 
         fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K])
       )
        
         ***  we must split Share                 
       ; applySplitBranches(fam ('Shares[bound K]), 
         fam ('Share[bound (N + 2) bound K])
       ) 
       *** and remove the extra branching     
      ; select-branch-family-p[fns:NameWithScripts <- 'Shares,
                               bt:BoolTerm <- apply 'isNotGate 'k]
         {  applyRemoveBranch(fam ('Share[(bound (N + 1)) (bound K)]))
         }


        
        
        *** 10.4.4 timing of shares 1
        
     ;  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using    
  ( *** start matchrew
        *** add two new internal channels InShareOK and ShareOK
          sym3
        
       
             
      ***;  applyGetChannel(fam ('Adv[bound K]))     
      *** ;  applyGetChannel(fam ('ShareOK[(bound (N + 2))(bound K)]))
       ; select-branch-family-p[fns:NameWithScripts <- 'Adv,
                               bt:BoolTerm <- apply 'isAndGate 'k]
         {sym4}
       
      *** add internal channels   
      ; sym5
      
      *** introduce InitOK
      ; sym6 
      
      *** introduce SharesOK
      
      ; sym7  
       
      
      *** then we express Shares equivalently by introducing dependencies of timing
      ; sym8
      
      *** we introduce 'In-OK
      ; sym9
      
      *** and 'Wires-OK
      ; sym10
      
      
      *** we split 'ShareOK
      ; applySplitInsideGroup(fam ('SharesOK[bound K]), 
           fam ('ShareOK[bound (N + 2) bound K]))
         
           
      
      *** then we group Shares with SharesOK
      ; applyGroupFamiliesNew(fam ('Shares[bound K]), fam ('SharesOK[bound K]))
      
      
      *** we will do an induction proof by sym, so we first set to what we want
      ; changeComp 
      
      ; applyDropName(
         fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)])
        )
      
       
      ; alpha-family-three[fns:NameWithScripts <- 'InShare,
     q4:Qid <- 'm,
     q5:Qid <- 'n,
     q6:Qid <- 'i
      ]   
      ; substNFFamiliesGen(
             fam ('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
             nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in, 'in)
            ) 
      ; applyAlphaNFPr(fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
                 << 'in, 'is >> emptyQidPairList)         
      ; alpha-family-three[fns:NameWithScripts <- 'InShare,
     q4:Qid <- 'n,
     q5:Qid <- 'm,
     q6:Qid <- 'i
      ]  
      ; asym0   
       
      *** first we split
      
      ; applySplitFst(fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]))
      
      *** for up to N + 1 in 'InShare$-OK
      ; applyOtherwiseToNeg(fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]))
      ; applyDropSubsumeFromBranchP(
         fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]), 
         fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]), 
         neg ('m =T= N + 1)
        )
        
        
     

      *** for N + 1 in 'InShare$-OK 
      ; substNFFamiliesGen(
             fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I]), 
             nf(('s : bool <- read ('InShare$-Sum[N 'n 'i])) 
                 'x : bool <- read ('In['n 'i]), 
                 return (ap 'xor pair('x, 's)), 'x 's)
        )
      ; applyAlphaNFPr(fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I]), 
                 << 's, 'is >> << 'x, 'in >> emptyQidPairList)   
      ; asym1 
      ; applyUnsplitFstNewNF(
      fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]),
      fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
     )  
  

       *** for 'InShare$Sum-OK we need an induction proof
       
       ; asym2
     
       *** and now we can deal with the missing bit on 'InShare$-OK
        *** ; applySplitFst(fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]))
       ; asym01  
       
      
      
      *** here we put back InitOK
      ; sym6 
      
      *** we can furthermore make all channels from InitOK read In-OK 
      
      ; indProofInitOK
      
      *** then we un group Shares and SharesOK
      
      ; applyUngroupFamiliesNew(fam ('Shares[bound K]), fam ('SharesOK[bound K]))
      
      *** so we can group Wires-OK and SharesOK
      ; applyGroupFamiliesNew(fam ('Wires-OK[bound K]), fam ('SharesOK[bound K]))
      
      ; indWiresShares
      
      *** now we ungroup
      
      ; applyUngroupFamiliesNew(fam ('Wires-OK[bound K]), fam ('SharesOK[bound K]))
      
      *** we need to take out SharesOK
      
      ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound K]),
           fam ('ShareOK[bound (N + 1) bound K]))  
       ; applyAllSameCases(fam ('ShareOK[bound (N + 1) bound K]))
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound K]),
           fam ('ShareOK[fixedBound (N + 1) bound K]) )  
       ; applyAllSameCases(fam ('ShareOK[fixedBound (N + 1) bound K]))
              
       *** and rename SharesOK to Ctrbs-Ok
       
       ; applyRenameGroup(fam ('SharesOK[bound K]), 'Ctrbs-OK) 
             
       *** now we do some substs in Adv
       
       ; select-branch-family-p[
          fns:NameWithScripts <- 'Adv,
          bt:BoolTerm <- apply 'isAndGate 'k
         ]{ 
          CONG-NEW-NF{
          select-branch-family-r[
          fns:NameWithScripts <- 'OTChcRcvd-0 ^^ 'ot .. 'adv,
          blist:List{Bounds} <- bound (N + 2) fixedBound (N + 1) bound K,
          bt:BoolTerm <- 'n <T N + 1 
          ]
          { 
            substNFFamiliesGen(
             fam ('ShareOK[(fixedBound (N + 1)) (bound K)] ),
             fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]), 
             nf('w : unit <- read ('Wire-OK[fun 'wire0 'k]), return 'w, 'w)
            )
          }
          ; 
          select-branch-family-r[
          fns:NameWithScripts <- 'OTChcRcvd-1 ^^ 'ot .. 'adv,
          blist:List{Bounds} <- bound (N + 2) fixedBound (N + 1) bound K,
          bt:BoolTerm <- 'n <T N + 1 
          ]
          { 
            substNFFamiliesGen(
             fam ('ShareOK[(fixedBound (N + 1)) (bound K)] ),
             fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]), 
             nf('w : unit <- read ('Wire-OK[fun 'wire1 'k]), return 'w, 'w)
            )
          }
          }
         }    
      
      *** now induction for Shares
      
      *** group with a new dummy group
      
      ; addHidden
      ; addHiddenGroup
      
      ; applyGroupFamiliesNew(fam ('HiddenGroup[bound K]), fam ('Shares[bound K]))
      
      ; indSharesT1
      
      ; applyUngroupFamiliesNew(fam ('HiddenGroup[bound K]), fam ('Shares[bound K]))
      ; applyDropName(fam ('HiddenGroup[bound K]) )
      ; absorbFamilyDeleteEmpty( fam ('Hidden[bound K]) )

     
     *** 10.4.5 timing of shares 2
     
     ; timing2(Delta, P, I, O, A)
     
   ) *** end of matchrew     
     
     ; substDivergeJoinCases(
            fam ('OutShare[bound (N + 2) bound (N + 2) bound K]) , 
            fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) , 
             nf('s : bool <- read ('Share['m 'k]), return 's, 's),
             nf('s : bool <- read ('Share['m 'k]), return 's, 's)
          )
    ; addGroupOS      
    ; addBranchGroupOS 
    
    ; CONG-NEW-NF{
      CASE-DISTINCTION-one[fns:NameWithScripts <- 'GroupOS]{
        
        applyOtherwiseToNeg(
      fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K])
    )
    ***(
    ;
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (family 'OutShareSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
           nf('s : bool <- read ('ShareSum['m 'k]), return 's, 's)
          ) 'm 'M,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(
          getInductionBase P  'OutShareSum 'm 'M A 
          (family 'OutShareSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
           nf('s : bool <- read ('ShareSum['m 'k]), return 's, 's)
          ) 
        ),
       P1:Protocol <- 
         getInductionBase P  'OutShareSum 'm 'M A
          (family 'OutShareSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
           nf('s : bool <- read ('ShareSum['m 'k]), return 's, 's)
          ) 
       ,
       A':Set{BoolTerm} <-  (A,'M <T (N + 2))                
       ] ;
       )
      ; SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'OutShareSum,
  blist:List{Bounds} <- bound (N + 2) bound (N + 2) bound K,
  cases':Cases <- 
   nf('s : bool <- read ('ShareSum['m 'k]), return 's, 's)
   ]
       {
       *** ind starts here
       CASE-DISTINCTION-one-R[
        fns:NameWithScripts <- 'OutShareSum
       ]{
         subst3
       ; subst3sym
       ,
       CASE-DISTINCTION-one-R-end-when[
        fns:NameWithScripts <- 'OutShareSum
       ]{   *** rename to avoid clash
            applyAlphaNFPr(fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
                 << 's, 'is >> emptyQidPairList)     
          ; subst4
          ;  *** rename to avoid clash
            applyAlphaNFPr(fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
                 << 's, 'iis >> emptyQidPairList)  
          ; substNFFamiliesGen(
             fam ('OutShareSum[bound (N + 2) bound 'M bound K]),
             fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
             nf('s : bool <- read ('ShareSum[('M -- 1) 'k]), return 's, 's)
              )
          ;  *** rename to avoid clash
            applyAlphaNFPr(fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
                 << 'iis, 'xm >> << 's, 'xs >> emptyQidPairList) 
         ; subst4sym         
                     
       }
       }
       ; applyAllSameCases(fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]) )
       }

        
        
        ,
        CASE-DISTINCTION-one-end-when[fns:NameWithScripts <- 'GroupOS]{
         
         CASE-DISTINCTION-one-R[fns:NameWithScripts <- 'OutShareSum]
         {applySelectCaseDiverge(
  fam ('OutShare[bound (N + 2) bound (N + 2) bound K]), 
  fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]), 
   neg (apply 'isOutputWire 'k) , 'o, bool), 
        CASE-DISTINCTION-one-R-end[fns:NameWithScripts <- 'OutShareSum]{ 
          applySelectCaseDiverge(
  fam ('OutShare[bound (N + 2) bound (N + 2) bound K]), 
  fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]), 
   neg (apply 'isOutputWire 'k) , 'o, bool)
          }
        }
        ; applyAllSameCases(fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]))
         
        }
      }
      }
      
      ; applyNewCombine(fam ('GroupOS [bound (N + 2) bound (N + 2) bound K]) )
      
      *** then 'OutShareSum ^^ 'party .. 'adv
      ; substDivergeJoinCases(
            fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]) , 
            fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) , 
             nf('s : bool <- read ('ShareSum['m 'k]), return 's, 's),
             nf('s : bool <- read ('ShareSum['m 'k]), return 's, 's)
          )
      *** and Out    
      ; addBranchOut 
      
      ; CONG-NEW-NF{
        CASE-DISTINCTION-one-R[
        fns:NameWithScripts <- 'Out,
        blist:List{Bounds} <- bound (N + 2) bound K
       ]{ subst5, 
          CASE-DISTINCTION-one-R-end-when[
        fns:NameWithScripts <- 'Out,
        blist:List{Bounds} <- bound (N + 2) bound K
       ]{
          subst6 }
          }
          } 
      
      *** now we can absorb unused families
      ; absorbFamily( 
         fam ('OutShare [bound (N + 2) bound (N + 2) bound K]) 
         ) 
      ; absorbFamily( 
         fam ('OutShareSum [bound (N + 2) bound (N + 2) bound K]) 
         )
         
     *** we split sharesum
     
     ; applySplit(fam ('ShareSum[bound (N + 2) bound K])) 
     
     *** then we add ShareSum to Shares   
     ;  applyAddToGroupCases(
          fam ('ShareSum[fixedBound (N + 1) bound K]), 
          fam ('Shares[bound K])
        ) 
     ;  applyAddToGroupCases(
          fam ('ShareSum[bound (N + 1) bound K]), 
          fam ('Shares[bound K])
        )    
     
    *** then we do the big induction proof
     ; setupIndSumShares  
     
    *** and we add Wire 
    ; addWire      
    
    *** and group it with Shares for induction
    ; applyGroupFamiliesNew(
       fam ('Shares[ bound K]),
       fam ('Wire[ bound K])
      )   
      
      
    *** and do the induction proof   
    ; inductionWireShares  
      
    *** now we can ungroup
    ; applyUngroupFamiliesNew(
       fam ('Shares[ bound K]),
       fam ('Wire[ bound K])
      )   
     
    *** we can take out 'ShareSum[fixedBound N+1 bound K] 
    
    ; applyRemoveMergeFromGroupCases( 
        fam ('Shares[ bound K]), 
        fam ('ShareSum[fixedBound (N + 1) bound K] )
      ) 
      
    *** and we can add Wire to the Wires group   
    ; addWiresGroup
                 
                 
    *** end of sum of shares
    
    *** the rest goes here
    ; applySplitFst( fam (('InShare$ ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) dependentBound 'I])  ) 

; CONG-NEW-NF{
  select-branch-family-r[
    fns:NameWithScripts <- 'InShare$ ^^ 'party .. 'adv,
    blist:List{Bounds}  <- fixedBound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam ('InShare$ [bound (N + 2) bound (N + 2) dependentBound 'I]),
     fam (('InShare$ ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I]),
     nf(('s : bool <- read ('InShare$-Sum[N 'n 'i])) 
         'x : bool <- read ('In['n 'i]), 
         return (ap 'xor pair('x, 's)), 'x 's)
    )
   
   }
  } 

; applySplitFst( fam (('SendInShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2)
    dependentBound 'I])  ) 
    
; CONG-NEW-NF{
  select-branch-family-r[
    fns:NameWithScripts <- 'SendInShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- fixedBound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam ('InShare$ [bound (N + 2) bound (N + 2) dependentBound 'I]),
     fam (('SendInShare ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I]),
     nf(('s : bool <- read ('InShare$-Sum[N 'n 'i])) 
         'x : bool <- read ('In['n 'i]), 
         return (ap 'xor pair('x, 's)), 'x 's)
    )
   
   }
  }  
  
;  applySplitFst( fam ('InShare [bound (N + 2) bound (N + 2) dependentBound 'I])  )   


; substNFFamiliesGen(     
     fam ('InShare$ [bound (N + 2) bound (N + 2) dependentBound 'I]),
     fam ('InShare [fixedBound (N + 1) bound (N + 2) dependentBound 'I]),
     nf(('s : bool <- read ('InShare$-Sum[N 'm 'i])) 
         'x : bool <- read ('In['m 'i]), 
         return (ap 'xor pair('x, 's)), 'x 's)
    )
    
;  applySplitFst( fam ('InShare$ [bound (N + 2) bound (N + 2) dependentBound 'I])  )     
 
; absorbFamily( fam ('InShare$ [fixedBound (N + 1) bound (N + 2) dependentBound 'I]) )

; absorbFamily( fam ('InShare [fixedBound (N + 1) bound (N + 2) dependentBound 'I]) ) 

*** RcvdBit must be split
; applyRemoveFromGroupCases(fam ('Shares[bound K]), fam ('RcvdBit[bound (N + 2) bound (N + 2) bound K]) )

; applySplit( fam ('RcvdBit[bound (N + 2) bound (N + 2) bound K]) )


; applyAddFamToGroupSameCases(
   fam ('Shares[bound K]), 
   fam ('RcvdBit[bound (N + 2) bound (N + 1) bound K])
   )
   
; applyAddFamToGroupSameCases(
   fam ('Shares[bound K]), 
   fam ('RcvdBit[bound (N + 2) fixedBound (N + 1) bound K])
   )  
   
; CONG-NEW-NF{
   CASE-DISTINCTION-one[
     fns:NameWithScripts <- 'Shares
   ]{idle, 
    CASE-DISTINCTION-one[
     fns:NameWithScripts <- 'Shares
   ]{idle, 
    CASE-DISTINCTION-one[
     fns:NameWithScripts <- 'Shares
   ]{idle, 
    CASE-DISTINCTION-one-end-when[
     fns:NameWithScripts <- 'Shares
   ]{applySubstDivergeCase(
   fam ('SendBit[bound (N + 2) bound (N + 2) bound K]), 
   fam ('RcvdBit[bound (N + 2) fixedBound (N + 1) bound K]), 
   'm <=T 'n, 'r , bool)}}}}
}    
   
; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('SendBit[bound (N + 2) bound (N + 2) bound K])
  )  

; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('RcvdBit[bound (N + 2) bound (N + 1) bound K])
  ) 
  
; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('RcvdBit[bound (N + 2) fixedBound (N + 1) bound K])
  )     
  
; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('CtrbSum[bound (N + 2) bound (N + 2) bound K])
  )

; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('Ctrb[bound (N + 2) bound (N + 2) bound K])
  )


; applyExtractSubgroup( 
   fam ('Shares[ bound K]), 
   ( fam ('Ctrb[fixedBound (N + 1) bound (N + 2) bound K]) 
     fam ('CtrbSum[fixedBound (N + 1) bound (N + 2) bound K])
     fam ('SendBit[fixedBound (N + 1) bound (N + 2) bound K])
     fam ('RcvdBit[fixedBound (N + 1) bound (N + 1) bound K])
     fam ('RcvdBit[fixedBound (N + 1) fixedBound (N + 1) bound K])
   ), 
   'Ctrbs)
   
*** 'Ctrbs needs to go  aici 

; absorbGroup( fam ('Ctrbs[bound K]) )

; applySplit( fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) )
; applySplit( fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) )
; applyRemoveMergeFromGroupCases(
    fam ('Shares[bound K]), 
    fam ('Share[fixedBound (N + 1) bound K])) 

  
; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'RcvdOutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   

    substNFFamiliesGen(     
     fam ('Share[fixedBound (N + 1) bound K]),
     fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]),
     nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
         'xs : bool <- read ('ShareSum[N 'k]), 
         return (ap 'xor pair('xs, 'x)), 'xs 'x)
    )
   
   }
} 

; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'OutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   

    substNFFamiliesGen(     
     fam ('Share[fixedBound (N + 1) bound K]),
     fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]),
     nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
         'xs : bool <- read ('ShareSum[N 'k]), 
         return (ap 'xor pair('xs, 'x)), 'xs 'x)
    )
   
   }
} 
     
; absorbFamily( fam ('Share[fixedBound (N + 1) bound K]) )

; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'RcvdOutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   

    substNFFamiliesGen(     
     fam ('ShareSum[fixedBound (N + 1) bound K]),
     fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]),
     nf('w : bool <- read ('Wire['k]), return 'w, 'w)
    )
   
   }
} 

; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'OutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   

    substNFFamiliesGen(     
     fam ('ShareSum[fixedBound (N + 1) bound K]),
     fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]),
     nf('w : bool <- read ('Wire['k]), return 'w, 'w)
    )
   
   }
} 

; applySplit( fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) )

; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'OutShareSum ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   

    substNFFamiliesGen(     
     fam ('ShareSum[fixedBound (N + 1) bound K]),
     fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]),
     nf('w : bool <- read ('Wire['k]), return 'w, 'w)
    )
   
   }
} 

; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'Out,
    blist:List{Bounds}  <- bound (N + 2) bound K,
    bt:BoolTerm <- (apply 'isOutputWire 'k) 
   ]{
   

    substNFFamiliesGen(     
     fam ('ShareSum[fixedBound (N + 1) bound K]),
     fam ('Out[bound (N + 2) bound K]),
     nf('w : bool <- read ('Wire['k]), return 'w, 'w)
    )
   
   }
} 

; absorbFamily( fam ('ShareSum[fixedBound (N + 1) bound K]) )

*** prepare for sym
*** we can take ShareSum out of Shares

; applyRemoveMergeFromGroupCases(
    fam ('Shares[bound K]), 
    fam ('ShareSum[bound (N + 1) bound K])
 ) 
 
; applyMergeGroups(fam ('Adv[bound K]), fam ('Shares[bound K]), 'Circ) 

; alpha-family-three[fns:NameWithScripts <- 'InShare,
     q4:Qid <- 'm,
     q5:Qid <- 'n,
     q6:Qid <- 'i
      ]  


*** sym proofs from 10.4.8
; symWireOSS
; symWireOS
; symWireROS

*** simplification
; applyDropBranch(fam ('InShare$ [bound (N + 1) bound (N + 2) dependentBound 'I]), 
                  'm, N + 1)
; applyRemoveOtherwiseBranch(fam ('InShare$ [bound (N + 1) bound (N + 2) dependentBound 'I]))


*** finalize the proof

; matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- deltaIdealPlusSim,
       O1:Set{CNameBound} <- getOutputs(idealPlusSim),
       P1:Protocol <- idealPlusSim
       ] 
{ sugar-newNF
      ; ((COMP-NEW-newNF-inside-new ; lift-inner-new-nf) !)
             
     ; 
CONG-NEW-NF{

 select-branch-family-r[
    fns:NameWithScripts <- 'InShare$,
    blist:List{Bounds}  <- bound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam ('InShare$[bound (N + 1) bound (N + 2) dependentBound 'I]),
     nf('in : bool <- read ('In['n 'i]), return 'in, 'in)
    )
   }
   
   ; select-branch-family-r[
    fns:NameWithScripts <- 'In ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam (('In ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I] ),
     nf('in : bool <- read ('In['n 'i]), return 'in, 'in)
    )
   }
   
    ; select-branch-family-r[
    fns:NameWithScripts <- 'InShare$ ^^ 'party .. 'adv,
    blist:List{Bounds}  <- fixedBound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam (('InShare$ ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I]),
     nf('in : bool <- read ('In['n 'i]), return 'in, 'in)
    )
    ; applyAlphaNFPr(
       fam (('InShare$ ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I]),
                         << 'in, 'x >> emptyQidPairList)
   }
   
   ; select-branch-family-r[
    fns:NameWithScripts <- 'SendInShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- fixedBound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam (('SendInShare ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I]),
     nf('in : bool <- read ('In['n 'i]), return 'in, 'in)
    )
    ; applyAlphaNFPr(
      fam (('SendInShare ^^ 'party .. 'adv)
           [fixedBound (N + 1) bound (N + 2) dependentBound 'I]), 
                         << 'in, 'x >> emptyQidPairList)
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'InShare$,
    blist:List{Bounds}  <- bound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('InRcvd ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam ('InShare$[bound (N + 1) bound (N + 2) dependentBound 'I]),
     nf('in : bool <- read ('In['n 'i]), return (), 'in)
    )
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'InRcvd ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('InRcvd ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam (('InRcvd ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I]),
     nf('in : bool <- read ('In['n 'i]), return (), 'in)
    )
    ; applyAlphaNFPr(
       fam (('InRcvd ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I]),
                         << 'in, 'x >> emptyQidPairList)
    
   }
   
    ;  select-branch-family-r[
    fns:NameWithScripts <- 'Out ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) bound K,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]),
     fam( ('Out ^^ 'party .. 'adv)[bound (N + 2) bound K] ),
     nf('out : bool <- read ('Out['n 'k]), return 'out, 'out)
    )
     ; applyAlphaNFPr(
      fam( ('Out ^^ 'party .. 'adv)[bound (N + 2) bound K] ),
                         << 'out, 's >> emptyQidPairList)
   }
  
  ;  select-branch-family-r[
    fns:NameWithScripts <- 'OutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]),
     fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] ),
     nf('out : bool <- read ('Out['n 'k]), return 'out, 'out)
    )
    
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'OutShareSum ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]),
     fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] ),
     nf('out : bool <- read ('Out['n 'k]), return 'out, 'out)
    )
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'RcvdOutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]),
     fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] ),
     nf('out : bool <- read ('Out['n 'k]), return 'out, 'out)
    )
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'Out,
    bt:BoolTerm <- (apply 'isOutputWire 'k) 
   ]{
   applyAlphaNFPr(
            fam ('Out[bound (N + 2) bound K]), 
                         << 'out, 'w >> emptyQidPairList)     
   }
   
} 

; applyAllSameCases( fam ('InShare$[bound (N + 1) bound (N + 2) dependentBound 'I]) )
; applyAlphaNFPr(
            fam ('InShare$[bound (N + 1) bound (N + 2) dependentBound 'I]), 
                         << 'in, 'x >> emptyQidPairList)

; absorbFamily( fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]) )
; absorbFamily( fam (('InRcvd ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]) )
; absorbFamilyDeleteEmpty( fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]) )


; reorder-newNF[ql2:List{CNameBound} <- 
( 
fam ('Ctrb[bound (N + 1) bound (N + 2) bound K])
fam ('CtrbSum[bound (N + 1) bound (N + 2) bound K])
fam ('RcvdBit[bound (N + 1) fixedBound (N + 1)bound K])
fam ('RcvdBit[bound (N + 1) bound (N + 1) bound K])
fam ('SendBit[bound (N + 1) bound (N + 2) bound K])
fam ('InShare$[bound (N + 1) bound (N + 2) dependentBound 'I])
fam ('InShare[bound (N + 1) bound (N + 2) dependentBound 'I])
fam ('Wire[bound K])
fam ('ShareSum[bound (N + 1) bound K])
fam ('Share[bound (N + 1) bound K])
fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])
)    
  ]
}
    
 ***  DONE main proof ends here, below just checks  
 ; get-structure  

.


***( from restr
*** KEEP, takes very long!

set trace off .

srew [1] pConfig(sig,
             (fam (('InRcvd ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) :: unit) 
             (fam (('InShare$-Sum ^^ 'party .. 'adv)[(bound (N + 1))((bound (N + 2))(dependentBound 'I))]) :: bool)
             (fam (('InShare$ ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]):: bool)
             (fam (('InShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) :: bool)
             (fam (('In ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) :: bool)  
             (fam (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit)
             (fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam ('Out[((bound (N + 2))(bound K))]) :: bool)    
             (fam (('OutShareSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool)
             (fam (('Out ^^ 'party .. 'adv)[((bound (N + 2))(bound K))]) :: bool)  
             (fam (('RcvdInShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) :: bool)  
             (fam (('RcvdOutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('SendInShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) :: bool) 
             (fam (('SendOutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool)  
             (fam (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))]) :: bool)
             (fam (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool)
             (fam (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool)  
             (fam ('In[(bound (N + 2)) (dependentBound 'I)]) :: bool)
             ,
             restr,
             fam ('In[(bound (N + 2)) (dependentBound 'I)]), 
             getOutputs(real),
             genA) 
using    sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)
             
       *** 10.4.1 Simplifying The Real Protocol: Initial Phase
       
       ; applySubstFamily3IdxCase(
          fam ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]), 
          fam (('SendInShare ^^ 'party .. 'adv)
            [((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]), 
          'm, 'n, 'i, 
         nf('in : bool <- read ('InShare$['m 'n 'i]), 
                              return 'in, 'in),
         nf('in : bool <- read ('InShare$['m 'n 'i]), 
                              return 'in, 'in),
         apply 'isSemiHonest 'n)
       
       ; alpha-family-three[
           fns:NameWithScripts <- 'SendInShare, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'i,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'i]
       
       ; applySubstFamily3IdxCase(
           fam ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]),
           fam (('RcvdInShare ^^ 'party .. 'adv)
            [((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]), 
           'n, 'm, 'i, 
         nf('in : bool <- read ('InShare$['n 'm 'i]), 
                              return 'in, 'in),
         nf('in : bool <- read ('InShare$['n 'm 'i]), 
                              return 'in, 'in),
         apply 'isSemiHonest 'n)    
        
       ; substNFFamiliesThree(
           fam ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]), 
           fam ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]), 
                            nf('in : bool <- read ('InShare$['n 'm 'i]), 
                               return 'in, 'in)
                           ) 

       ; absorbFamily(
          fam ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))])
         ) 
                                                  
         
       *** 10.4.2 Simplifying The Real Protocol: Inductive Phase
        
       ; select-branch-family-p[bt:BoolTerm <- apply 'isInputGate 'k, 
                                fns:NameWithScripts <- 'Circuit]{
           eliminateOTDivergent          
         } 
               
       ; select-branch-family-p[bt:BoolTerm <- apply 'isNotGate 'k]{
           eliminateOTDivergent          
         }  
       ; select-branch-family-p[bt:BoolTerm <- apply 'isXorGate 'k]{
           eliminateOTDivergent          
         } 
         
       ; select-branch-family-p[bt:BoolTerm <- apply 'isAndGate 'k]{

         substDivergeJoinCases(
            fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return 'b, 'b 'x 'y),
                nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return 'b, 'b 'x 'y)
          )
   ;
          substDivergeJoinCases(
            fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,  
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair('x, 'b)), 
                'b 'x 'y),
            nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair('x, 'b)), 
                'b 'x 'y)    
          ) 
            ;
          substDivergeJoinCases(
             fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,   
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair('y, 'b)), 
                'b 'x 'y),
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair('y, 'b)), 
                'b 'x 'y)   
          )  
         ;
          substDivergeJoinCases(
            fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,   
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)), 
                'b 'x 'y),
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)), 
                'b 'x 'y)   
          )
        ;
         substDivergeJoinCases(
            fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (), 'b 'x 'y),
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return 'b, 'b 'x 'y)   
          )
       ;
          substDivergeJoinCases(
            fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (), 
                'b 'x 'y),
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair('x, 'b)), 
                'b 'x 'y)   
          )  
           ;
          substDivergeJoinCases(
             fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (), 
                'b 'x 'y),
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair('y, 'b)), 
                'b 'x 'y)   
          )
          ;
          substDivergeJoinCases( 
             fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
             fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (), 
                'b 'x 'y),
             nf(('b : bool <- read ('SendBit['n 'm 'k])) 
                ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
                ('y : bool <- read ('Share['n (fun 'wire1 'k)])), 
                return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)), 
                'b 'x 'y)   
          ) 
          ;
          substDivergeJoinCases(
             fam ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
             fam (('OTChc-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,
             nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), 
                return 'x, 'x),
             nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), 
                return 'x, 'x)  
          )
          ;
          substDivergeJoinCases(
             fam ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
             fam (('OTChc-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,
             nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), 
                return 'x, 'x),
             nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), 
                return 'x, 'x)  
          )
          ;
          substDivergeJoinCases(
             fam ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
             fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ,
             nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), 
                return (), 'x),
             nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), 
                return 'x, 'x)  
          )
          ;
          substDivergeJoinCases(
             fam ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
             nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), 
                return (), 'x),
             nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), 
                return 'x, 'x)  
          )
         
          ; alpha-family-three[
           fns:NameWithScripts <- 'RcvdBit, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k] 
            
          ; CONG-NEW-NF{
             select-branch-family-r[bt:BoolTerm <- apply 'isSemiHonest 'm, 
                                    fns:NameWithScripts <- 'OTOut ^^ 'ot .. 'adv]{
                  substNFReadRevFamilies(
                    fam ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                    fam (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                    fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))])
                  )   
             }
           }       
            
          ; alpha-family-three[
           fns:NameWithScripts <- 'RcvdBit, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k]  
            
          ; substNFFamiliesThree(
             fam ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             nf(('c0 : bool <- read ('OTChc-0['m 'n 'k])) 
                ('c1 : bool <- read ('OTChc-1['m 'n 'k])) 
                ('m0 : bool <- read ('OTMsg-0['m 'n 'k])) 
                ('m1 : bool <- read ('OTMsg-1['m 'n 'k])) 
                ('m2 : bool <- read ('OTMsg-2['m 'n 'k]))  
                 'm3 : bool <- read ('OTMsg-3['m 'n 'k]), 
                if 'c0 then if 'c1 then return 'm3 else return 'm2 
                      else  if 'c1 then return 'm1 else return 'm0, 
                'm0 'm1 'm2 'm3 'c0 'c1)
          )  
  
          ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-0, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k] 
          
          ; applySubstOrDiverge(
            fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
            'z, 
            nf(('b : bool <- read ('SendBit['m 'n 'k])) 
               ('x : bool <- read ('Share['m (fun 'wire0 'k)])) 
                'y : bool <- read ('Share['m (fun 'wire1 'k)]), 
                return 'b, 'b 'x 'y)
            )   
           
        ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-1, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k] 
           
        ; applyGenSameCasesSubstFirstBranch(
            fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
            nf(('b : bool <- read ('SendBit['m 'n 'k])) 
               ('x : bool <- read ('Share['m (fun 'wire0 'k)])) 
                'y : bool <- read ('Share['m (fun 'wire1 'k)]), 
               return (ap 'xor pair('x, 'b)), 'b 'x 'y)
             ) 
         ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-2, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]       
         ; applyGenSameCasesSubstFirstBranch(
            fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
            nf(('b : bool <- read ('SendBit['m 'n 'k])) 
               ('x : bool <- read ('Share['m (fun 'wire0 'k)])) 
                'y : bool <- read ('Share['m (fun 'wire1 'k)]), 
                return (ap 'xor pair('y, 'b)), 
                'b  'x 'y)
             )  
            ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-3, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]  
            ; applyGenSameCasesSubstFirstBranch(
            fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
            nf(('b : bool <- read ('SendBit['m 'n 'k])) 
               ('x : bool <- read ('Share['m (fun 'wire0 'k)])) 
                'y : bool <- read ('Share['m (fun 'wire1 'k)]), 
                return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)), 
                'b 'x 'y)
             ) 
             ; applyAlphaBranchCond(
                 fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                 'x, 'xm, when ('m <T 'n) )  
             ; applyAlphaBranchCond(
                 fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                 'y, 'ym, when ('m <T 'n) ) 
             ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-0, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; applyGenSameCasesSubstFirstBranch(
            fam ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
            nf('x : bool <- read ('Share['n (fun 'wire0 'k)]), 
            return 'x, 'x)
             )  
             ; applyAlphaBranchCond(
             fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             'x, 'xn, when ('m <T 'n) 
             )   
             ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-1, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; applyGenSameCasesSubstFirstBranch(
            fam ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
            nf('x : bool <- read ('Share['n (fun 'wire1 'k)]), 
            return 'x, 'x)
             )  
           ; applyAlphaBranchCond(
                fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                'x, 'yn, when ('m <T 'n) )   
                
           *** undo all alphas 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-0, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-1, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-2, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-3, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-0, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]    
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-1, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k] 
           ; sym1 *** first branch of RcvdBit  
           ; alpha-family-three[
           fns:NameWithScripts <- 'SendBit, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]   
           ; sym2 *** second branch of RcvdBit  
           ; alpha-family-three[
           fns:NameWithScripts <- 'SendBit, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; applyAllSameCases(fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))])) 
         
         }   
        
         *** now we need to restructure Circuit in Adv + Shares + 1OutOf4OT
         
         ; applyNewCombine(fam ('Circuit[(bound (N + 2)) (bound K)]))       
      *** here we get to 5 mil rewrites when turning to a sym proof
         ; slowSym *** this brings me to pInt0
     *** end comment     
     ; sugar-newNF
       ; (moveProtocolUnderNewNF !)
       ; (lift-inner-new-nf !)

       ; applyNewCombine(fam ('Adv[bound K]))
                
       ; applyNewCombine(fam ('Shares[bound K]))
       ; applyNewCombine(fam ('1OutOf4OT[bound K]))
    
       ; absorbFamily(fam ('OTOut[((bound (N + 2)) (bound (N + 2))(bound K) )]))
           
       ; absorbFamily(fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2))(bound K) )]))
       ; absorbFamily(fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2))(bound K) )]))
             
       ; absorbFamily(fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2))(bound K) )]))
       ; absorbFamily(fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2))(bound K) )]))

       ; absorbFamily(fam ('OTChc-0[((bound (N + 2)) (bound (N + 2))(bound K) )]))
       ; absorbFamily(fam ('OTChc-1[((bound (N + 2)) (bound (N + 2))(bound K) )]))

       ; matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
         P1:Protocol <- pInt1]{
               sugar-newNF
       ; moveNewToFront
       ; applyNewCombine(fam ('Adv[bound K]))
       ; applyNewCombine(fam ('Shares[bound K]))
       }
       ; sugar-newNF
      ; moveNewToFront
  
        *** 10.4.3 Simplifying The Real Protocol: Final Phase 
          
        ; substDivergeJoinCases(
             fam ('SendOutShare[bound (N + 2) bound (N + 2) bound K]) , 
            fam (('SendOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) ,  
            nf('s : bool <- read ('Share['n 'k]), return 's, 's),
            nf('s : bool <- read ('Share['n 'k]), return 's, 's)
          )
        
        ; alpha-family-three[
           fns:NameWithScripts <- 'SendOutShare, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k]   
                           
        ; substDivergeJoinCases(
            fam ('SendOutShare[bound (N + 2) bound (N + 2) bound K]) , 
            fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) ,   
            nf('s : bool <- read ('Share['m 'k]), return 's, 's),
            nf('s : bool <- read ('Share['m 'k]), return 's, 's)
          ) 
        ***
        ; applySubstOrDiverge(
            fam ('SendOutShare[bound (N + 2) bound (N + 2) bound K]),
            fam ('OutShare[bound (N + 2) bound (N + 2) bound K]),            
            'z, 
            nf('s : bool <- read ('Share['m 'k]), return 's, 's)    
          )
        *** at this point 'SendOutShare are unused and can be eliminated
        ; absorbFamily(fam ('SendOutShare[bound (N + 2) bound (N + 2) bound K]))  
        
        *** first some preliminaries, common to 10.4.4 and 10.4.5
         
             ; addShareSum 
     
     ; applySplitAllBranches(fam ('Adv[bound K]), 
         fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K])
       )  
     ; applySplitAllBranches(fam ('Adv[bound K]), 
         fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K])
       )
        
         ***  we must split Share                 
       ; applySplitBranches(fam ('Shares[bound K]), 
         fam ('Share[bound (N + 2) bound K])
       ) 
       *** and remove the extra branching     
      ; select-branch-family-p[fns:NameWithScripts <- 'Shares,
                               bt:BoolTerm <- apply 'isNotGate 'k]
         {  applyRemoveBranch(fam ('Share[(bound (N + 1)) (bound K)]))
         }


        
        
        *** 10.4.4 timing of shares 1
        
     ;  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using    
  ( *** start matchrew
        *** add two new internal channels InShareOK and ShareOK
          sym3
        
       
             
      ***;  applyGetChannel(fam ('Adv[bound K]))     
      *** ;  applyGetChannel(fam ('ShareOK[(bound (N + 2))(bound K)]))
       ; select-branch-family-p[fns:NameWithScripts <- 'Adv,
                               bt:BoolTerm <- apply 'isAndGate 'k]
         {sym4}
       
      *** add internal channels   
      ; sym5
      
      *** introduce InitOK
      ; sym6 
      
      *** introduce SharesOK
      
      ; sym7  
       
      
      *** then we express Shares equivalently by introducing dependencies of timing
      ; sym8
      
      *** we introduce 'In-OK
      ; sym9
      
      *** and 'Wires-OK
      ; sym10
      
      
      *** we split 'ShareOK
      ; applySplitInsideGroup(fam ('SharesOK[bound K]), 
           fam ('ShareOK[bound (N + 2) bound K]))
         
           
      
      *** then we group Shares with SharesOK
      ; applyGroupFamiliesNew(fam ('Shares[bound K]), fam ('SharesOK[bound K]))
      
      
      *** we will do an induction proof by sym, so we first set to what we want
      ; changeComp 
      
      ; applyDropName(
         fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)])
        )
      
       
      ; alpha-family-three[fns:NameWithScripts <- 'InShare,
     q4:Qid <- 'm,
     q5:Qid <- 'n,
     q6:Qid <- 'i
      ]   
      ; substNFFamiliesGen(
             fam ('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
             nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in, 'in)
            ) 
      ; applyAlphaNFPr(fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
                 << 'in, 'is >> emptyQidPairList)         
      ; alpha-family-three[fns:NameWithScripts <- 'InShare,
     q4:Qid <- 'n,
     q5:Qid <- 'm,
     q6:Qid <- 'i
      ]  
      ; asym0   
       
      *** first we split
      
      ; applySplitFst(fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]))
      
      *** for up to N + 1 in 'InShare$-OK
      ; applyOtherwiseToNeg(fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]))
      ; applyDropSubsumeFromBranchP(
         fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]), 
         fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]), 
         neg ('m =T= N + 1)
        )
        
        
     

      *** for N + 1 in 'InShare$-OK 
      ; substNFFamiliesGen(
             fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I]), 
             nf(('s : bool <- read ('InShare$-Sum[N 'n 'i])) 
                 'x : bool <- read ('In['n 'i]), 
                 return (ap 'xor pair('x, 's)), 'x 's)
        )
      ; applyAlphaNFPr(fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I]), 
                 << 's, 'is >> << 'x, 'in >> emptyQidPairList)   
      ; asym1 
      ; applyUnsplitFstNewNF(
      fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]),
      fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
     )  
  

       *** for 'InShare$Sum-OK we need an induction proof
       
       ; asym2
     
       *** and now we can deal with the missing bit on 'InShare$-OK
        *** ; applySplitFst(fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]))
       ; asym01  
       
      
      
      *** here we put back InitOK
      ; sym6 
      
      *** we can furthermore make all channels from InitOK read In-OK 
      
      ; indProofInitOK
      
      *** then we un group Shares and SharesOK
      
      ; applyUngroupFamiliesNew(fam ('Shares[bound K]), fam ('SharesOK[bound K]))
      
      *** so we can group Wires-OK and SharesOK
      ; applyGroupFamiliesNew(fam ('Wires-OK[bound K]), fam ('SharesOK[bound K]))
      
      ; indWiresShares
      
      *** now we ungroup
      
      ; applyUngroupFamiliesNew(fam ('Wires-OK[bound K]), fam ('SharesOK[bound K]))
      
      *** we need to take out SharesOK
      
      ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound K]),
           fam ('ShareOK[bound (N + 1) bound K]))  
       ; applyAllSameCases(fam ('ShareOK[bound (N + 1) bound K]))
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound K]),
           fam ('ShareOK[fixedBound (N + 1) bound K]) )  
       ; applyAllSameCases(fam ('ShareOK[fixedBound (N + 1) bound K]))
              
       *** and rename SharesOK to Ctrbs-Ok
       
       ; applyRenameGroup(fam ('SharesOK[bound K]), 'Ctrbs-OK) 
             
       *** now we do some substs in Adv
       
       ; select-branch-family-p[
          fns:NameWithScripts <- 'Adv,
          bt:BoolTerm <- apply 'isAndGate 'k
         ]{ 
          CONG-NEW-NF{
          select-branch-family-r[
          fns:NameWithScripts <- 'OTChcRcvd-0 ^^ 'ot .. 'adv,
          blist:List{Bounds} <- bound (N + 2) fixedBound (N + 1) bound K,
          bt:BoolTerm <- 'n <T N + 1 
          ]
          { 
            substNFFamiliesGen(
             fam ('ShareOK[(fixedBound (N + 1)) (bound K)] ),
             fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]), 
             nf('w : unit <- read ('Wire-OK[fun 'wire0 'k]), return 'w, 'w)
            )
          }
          ; 
          select-branch-family-r[
          fns:NameWithScripts <- 'OTChcRcvd-1 ^^ 'ot .. 'adv,
          blist:List{Bounds} <- bound (N + 2) fixedBound (N + 1) bound K,
          bt:BoolTerm <- 'n <T N + 1 
          ]
          { 
            substNFFamiliesGen(
             fam ('ShareOK[(fixedBound (N + 1)) (bound K)] ),
             fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]), 
             nf('w : unit <- read ('Wire-OK[fun 'wire1 'k]), return 'w, 'w)
            )
          }
          }
         }    
      
      *** now induction for Shares
      
      *** group with a new dummy group
      
      ; addHidden
      ; addHiddenGroup
      
      ; applyGroupFamiliesNew(fam ('HiddenGroup[bound K]), fam ('Shares[bound K]))
      
      ; indSharesT1
      
      ; applyUngroupFamiliesNew(fam ('HiddenGroup[bound K]), fam ('Shares[bound K]))
      ; applyDropName(fam ('HiddenGroup[bound K]) )
      ; absorbFamilyDeleteEmpty( fam ('Hidden[bound K]) )

     
     *** 10.4.5 timing of shares 2
     
     ; timing2(Delta, P, I, O, A)
     
   ) *** end of matchrew     
     
     ; substDivergeJoinCases(
            fam ('OutShare[bound (N + 2) bound (N + 2) bound K]) , 
            fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) , 
             nf('s : bool <- read ('Share['m 'k]), return 's, 's),
             nf('s : bool <- read ('Share['m 'k]), return 's, 's)
          )
    ; addGroupOS      
    ; addBranchGroupOS 
    
    ; CONG-NEW-NF{
      CASE-DISTINCTION-one[fns:NameWithScripts <- 'GroupOS]{
        
        applyOtherwiseToNeg(
      fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K])
    )
    ***(
    ;
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using UNSAFE[
       Delta':ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          (family 'OutShareSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
           nf('s : bool <- read ('ShareSum['m 'k]), return 's, 's)
          ) 'm 'M,
       I':Set{CNameBound} <- I,   
       O':Set{CNameBound} <- 
        getOutputs(
          getInductionBase P  'OutShareSum 'm 'M A 
          (family 'OutShareSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
           nf('s : bool <- read ('ShareSum['m 'k]), return 's, 's)
          ) 
        ),
       P1:Protocol <- 
         getInductionBase P  'OutShareSum 'm 'M A
          (family 'OutShareSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
           nf('s : bool <- read ('ShareSum['m 'k]), return 's, 's)
          ) 
       ,
       A':Set{BoolTerm} <-  (A,'M <T (N + 2))                
       ] ;
       )
      ; SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'OutShareSum,
  blist:List{Bounds} <- bound (N + 2) bound (N + 2) bound K,
  cases':Cases <- 
   nf('s : bool <- read ('ShareSum['m 'k]), return 's, 's)
   ]
       {
       *** ind starts here
       CASE-DISTINCTION-one-R[
        fns:NameWithScripts <- 'OutShareSum
       ]{
         subst3
       ; subst3sym
       ,
       CASE-DISTINCTION-one-R-end-when[
        fns:NameWithScripts <- 'OutShareSum
       ]{   *** rename to avoid clash
            applyAlphaNFPr(fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
                 << 's, 'is >> emptyQidPairList)     
          ; subst4
          ;  *** rename to avoid clash
            applyAlphaNFPr(fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
                 << 's, 'iis >> emptyQidPairList)  
          ; substNFFamiliesGen(
             fam ('OutShareSum[bound (N + 2) bound 'M bound K]),
             fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
             nf('s : bool <- read ('ShareSum[('M -- 1) 'k]), return 's, 's)
              )
          ;  *** rename to avoid clash
            applyAlphaNFPr(fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
                 << 'iis, 'xm >> << 's, 'xs >> emptyQidPairList) 
         ; subst4sym         
                     
       }
       }
       ; applyAllSameCases(fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]) )
       }

        
        
        ,
        CASE-DISTINCTION-one-end-when[fns:NameWithScripts <- 'GroupOS]{
         
         CASE-DISTINCTION-one-R[fns:NameWithScripts <- 'OutShareSum]
         {applySelectCaseDiverge(
  fam ('OutShare[bound (N + 2) bound (N + 2) bound K]), 
  fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]), 
   neg (apply 'isOutputWire 'k) , 'o, bool), 
        CASE-DISTINCTION-one-R-end[fns:NameWithScripts <- 'OutShareSum]{ 
          applySelectCaseDiverge(
  fam ('OutShare[bound (N + 2) bound (N + 2) bound K]), 
  fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]), 
   neg (apply 'isOutputWire 'k) , 'o, bool)
          }
        }
        ; applyAllSameCases(fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]))
         
        }
      }
      }
      
      ; applyNewCombine(fam ('GroupOS [bound (N + 2) bound (N + 2) bound K]) )
      
      *** then 'OutShareSum ^^ 'party .. 'adv
      ; substDivergeJoinCases(
            fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]) , 
            fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) , 
             nf('s : bool <- read ('ShareSum['m 'k]), return 's, 's),
             nf('s : bool <- read ('ShareSum['m 'k]), return 's, 's)
          )
      *** and Out    
      ; addBranchOut 
      
      ; CONG-NEW-NF{
        CASE-DISTINCTION-one-R[
        fns:NameWithScripts <- 'Out,
        blist:List{Bounds} <- bound (N + 2) bound K
       ]{ subst5, 
          CASE-DISTINCTION-one-R-end-when[
        fns:NameWithScripts <- 'Out,
        blist:List{Bounds} <- bound (N + 2) bound K
       ]{
          subst6 }
          }
          } 
      
      *** now we can absorb unused families
      ; absorbFamily( 
         fam ('OutShare [bound (N + 2) bound (N + 2) bound K]) 
         ) 
      ; absorbFamily( 
         fam ('OutShareSum [bound (N + 2) bound (N + 2) bound K]) 
         )
         
     *** we split sharesum
     
     ; applySplit(fam ('ShareSum[bound (N + 2) bound K])) 
     
     *** then we add ShareSum to Shares   
     ;  applyAddToGroupCases(
          fam ('ShareSum[fixedBound (N + 1) bound K]), 
          fam ('Shares[bound K])
        ) 
     ;  applyAddToGroupCases(
          fam ('ShareSum[bound (N + 1) bound K]), 
          fam ('Shares[bound K])
        )    
     
    *** then we do the big induction proof
     ; setupIndSumShares  
     
    *** and we add Wire 
    ; addWire      
    
    *** and group it with Shares for induction
    ; applyGroupFamiliesNew(
       fam ('Shares[ bound K]),
       fam ('Wire[ bound K])
      )   
      
      
    *** and do the induction proof   
    ; inductionWireShares  
      
    *** now we can ungroup
    ; applyUngroupFamiliesNew(
       fam ('Shares[ bound K]),
       fam ('Wire[ bound K])
      )   
     
    *** we can take out 'ShareSum[fixedBound N+1 bound K] 
    
    ; applyRemoveMergeFromGroupCases( 
        fam ('Shares[ bound K]), 
        fam ('ShareSum[fixedBound (N + 1) bound K] )
      ) 
      
    *** and we can add Wire to the Wires group   
    ; addWiresGroup
                 
                 
    *** end of sum of shares
    
    *** the rest goes here
    ; applySplitFst( fam (('InShare$ ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) dependentBound 'I])  ) 

; CONG-NEW-NF{
  select-branch-family-r[
    fns:NameWithScripts <- 'InShare$ ^^ 'party .. 'adv,
    blist:List{Bounds}  <- fixedBound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam ('InShare$ [bound (N + 2) bound (N + 2) dependentBound 'I]),
     fam (('InShare$ ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I]),
     nf(('s : bool <- read ('InShare$-Sum[N 'n 'i])) 
         'x : bool <- read ('In['n 'i]), 
         return (ap 'xor pair('x, 's)), 'x 's)
    )
   
   }
  } 

; applySplitFst( fam (('SendInShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2)
    dependentBound 'I])  ) 
    
; CONG-NEW-NF{
  select-branch-family-r[
    fns:NameWithScripts <- 'SendInShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- fixedBound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam ('InShare$ [bound (N + 2) bound (N + 2) dependentBound 'I]),
     fam (('SendInShare ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I]),
     nf(('s : bool <- read ('InShare$-Sum[N 'n 'i])) 
         'x : bool <- read ('In['n 'i]), 
         return (ap 'xor pair('x, 's)), 'x 's)
    )
   
   }
  }  
  
;  applySplitFst( fam ('InShare [bound (N + 2) bound (N + 2) dependentBound 'I])  )   


; substNFFamiliesGen(     
     fam ('InShare$ [bound (N + 2) bound (N + 2) dependentBound 'I]),
     fam ('InShare [fixedBound (N + 1) bound (N + 2) dependentBound 'I]),
     nf(('s : bool <- read ('InShare$-Sum[N 'm 'i])) 
         'x : bool <- read ('In['m 'i]), 
         return (ap 'xor pair('x, 's)), 'x 's)
    )
    
;  applySplitFst( fam ('InShare$ [bound (N + 2) bound (N + 2) dependentBound 'I])  )     
 
; absorbFamily( fam ('InShare$ [fixedBound (N + 1) bound (N + 2) dependentBound 'I]) )

; absorbFamily( fam ('InShare [fixedBound (N + 1) bound (N + 2) dependentBound 'I]) ) 

*** RcvdBit must be split
; applyRemoveFromGroupCases(fam ('Shares[bound K]), fam ('RcvdBit[bound (N + 2) bound (N + 2) bound K]) )

; applySplit( fam ('RcvdBit[bound (N + 2) bound (N + 2) bound K]) )


; applyAddFamToGroupSameCases(
   fam ('Shares[bound K]), 
   fam ('RcvdBit[bound (N + 2) bound (N + 1) bound K])
   )
   
; applyAddFamToGroupSameCases(
   fam ('Shares[bound K]), 
   fam ('RcvdBit[bound (N + 2) fixedBound (N + 1) bound K])
   )  
   
; CONG-NEW-NF{
   CASE-DISTINCTION-one[
     fns:NameWithScripts <- 'Shares
   ]{idle, 
    CASE-DISTINCTION-one[
     fns:NameWithScripts <- 'Shares
   ]{idle, 
    CASE-DISTINCTION-one[
     fns:NameWithScripts <- 'Shares
   ]{idle, 
    CASE-DISTINCTION-one-end-when[
     fns:NameWithScripts <- 'Shares
   ]{applySubstDivergeCase(
   fam ('SendBit[bound (N + 2) bound (N + 2) bound K]), 
   fam ('RcvdBit[bound (N + 2) fixedBound (N + 1) bound K]), 
   'm <=T 'n, 'r , bool)}}}}
}    
   
; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('SendBit[bound (N + 2) bound (N + 2) bound K])
  )  

; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('RcvdBit[bound (N + 2) bound (N + 1) bound K])
  ) 
  
; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('RcvdBit[bound (N + 2) fixedBound (N + 1) bound K])
  )     
  
; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('CtrbSum[bound (N + 2) bound (N + 2) bound K])
  )

; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('Ctrb[bound (N + 2) bound (N + 2) bound K])
  )


; applyExtractSubgroup( 
   fam ('Shares[ bound K]), 
   ( fam ('Ctrb[fixedBound (N + 1) bound (N + 2) bound K]) 
     fam ('CtrbSum[fixedBound (N + 1) bound (N + 2) bound K])
     fam ('SendBit[fixedBound (N + 1) bound (N + 2) bound K])
     fam ('RcvdBit[fixedBound (N + 1) bound (N + 1) bound K])
     fam ('RcvdBit[fixedBound (N + 1) fixedBound (N + 1) bound K])
   ), 
   'Ctrbs)
   
*** 'Ctrbs needs to go  aici 

; absorbGroup( fam ('Ctrbs[bound K]) )

; applySplit( fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) )
; applySplit( fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) )
; applyRemoveMergeFromGroupCases(
    fam ('Shares[bound K]), 
    fam ('Share[fixedBound (N + 1) bound K])) 

  
; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'RcvdOutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   

    substNFFamiliesGen(     
     fam ('Share[fixedBound (N + 1) bound K]),
     fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]),
     nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
         'xs : bool <- read ('ShareSum[N 'k]), 
         return (ap 'xor pair('xs, 'x)), 'xs 'x)
    )
   
   }
} 

; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'OutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   

    substNFFamiliesGen(     
     fam ('Share[fixedBound (N + 1) bound K]),
     fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]),
     nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
         'xs : bool <- read ('ShareSum[N 'k]), 
         return (ap 'xor pair('xs, 'x)), 'xs 'x)
    )
   
   }
} 
     
; absorbFamily( fam ('Share[fixedBound (N + 1) bound K]) )

; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'RcvdOutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   

    substNFFamiliesGen(     
     fam ('ShareSum[fixedBound (N + 1) bound K]),
     fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]),
     nf('w : bool <- read ('Wire['k]), return 'w, 'w)
    )
   
   }
} 

; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'OutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   

    substNFFamiliesGen(     
     fam ('ShareSum[fixedBound (N + 1) bound K]),
     fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]),
     nf('w : bool <- read ('Wire['k]), return 'w, 'w)
    )
   
   }
} 

; applySplit( fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) )

; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'OutShareSum ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   

    substNFFamiliesGen(     
     fam ('ShareSum[fixedBound (N + 1) bound K]),
     fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]),
     nf('w : bool <- read ('Wire['k]), return 'w, 'w)
    )
   
   }
} 

; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'Out,
    blist:List{Bounds}  <- bound (N + 2) bound K,
    bt:BoolTerm <- (apply 'isOutputWire 'k) 
   ]{
   

    substNFFamiliesGen(     
     fam ('ShareSum[fixedBound (N + 1) bound K]),
     fam ('Out[bound (N + 2) bound K]),
     nf('w : bool <- read ('Wire['k]), return 'w, 'w)
    )
   
   }
} 

; absorbFamily( fam ('ShareSum[fixedBound (N + 1) bound K]) )

*** prepare for sym
*** we can take ShareSum out of Shares

; applyRemoveMergeFromGroupCases(
    fam ('Shares[bound K]), 
    fam ('ShareSum[bound (N + 1) bound K])
 ) 
 
; applyMergeGroups(fam ('Adv[bound K]), fam ('Shares[bound K]), 'Circ) 

; alpha-family-three[fns:NameWithScripts <- 'InShare,
     q4:Qid <- 'm,
     q5:Qid <- 'n,
     q6:Qid <- 'i
      ]  


*** sym proofs from 10.4.8
; symWireOSS
; symWireOS
; symWireROS

*** simplification
; applyDropBranch(fam ('InShare$ [bound (N + 1) bound (N + 2) dependentBound 'I]), 
                  'm, N + 1)
; applyRemoveOtherwiseBranch(fam ('InShare$ [bound (N + 1) bound (N + 2) dependentBound 'I]))


*** finalize the proof

; matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- deltaIdealPlusSim,
       O1:Set{CNameBound} <- getOutputs(idealPlusSim),
       P1:Protocol <- idealPlusSim
       ] 
{ sugar-newNF
      ; ((COMP-NEW-newNF-inside-new ; lift-inner-new-nf) !)
             
     ; 
CONG-NEW-NF{

 select-branch-family-r[
    fns:NameWithScripts <- 'InShare$,
    blist:List{Bounds}  <- bound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam ('InShare$[bound (N + 1) bound (N + 2) dependentBound 'I]),
     nf('in : bool <- read ('In['n 'i]), return 'in, 'in)
    )
   }
   
   ; select-branch-family-r[
    fns:NameWithScripts <- 'In ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam (('In ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I] ),
     nf('in : bool <- read ('In['n 'i]), return 'in, 'in)
    )
   }
   
    ; select-branch-family-r[
    fns:NameWithScripts <- 'InShare$ ^^ 'party .. 'adv,
    blist:List{Bounds}  <- fixedBound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam (('InShare$ ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I]),
     nf('in : bool <- read ('In['n 'i]), return 'in, 'in)
    )
    ; applyAlphaNFPr(
       fam (('InShare$ ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I]),
                         << 'in, 'x >> emptyQidPairList)
   }
   
   ; select-branch-family-r[
    fns:NameWithScripts <- 'SendInShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- fixedBound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam (('SendInShare ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I]),
     nf('in : bool <- read ('In['n 'i]), return 'in, 'in)
    )
    ; applyAlphaNFPr(
      fam (('SendInShare ^^ 'party .. 'adv)
           [fixedBound (N + 1) bound (N + 2) dependentBound 'I]), 
                         << 'in, 'x >> emptyQidPairList)
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'InShare$,
    blist:List{Bounds}  <- bound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('InRcvd ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam ('InShare$[bound (N + 1) bound (N + 2) dependentBound 'I]),
     nf('in : bool <- read ('In['n 'i]), return (), 'in)
    )
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'InRcvd ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('InRcvd ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam (('InRcvd ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I]),
     nf('in : bool <- read ('In['n 'i]), return (), 'in)
    )
    ; applyAlphaNFPr(
       fam (('InRcvd ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I]),
                         << 'in, 'x >> emptyQidPairList)
    
   }
   
    ;  select-branch-family-r[
    fns:NameWithScripts <- 'Out ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) bound K,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]),
     fam( ('Out ^^ 'party .. 'adv)[bound (N + 2) bound K] ),
     nf('out : bool <- read ('Out['n 'k]), return 'out, 'out)
    )
     ; applyAlphaNFPr(
      fam( ('Out ^^ 'party .. 'adv)[bound (N + 2) bound K] ),
                         << 'out, 's >> emptyQidPairList)
   }
  
  ;  select-branch-family-r[
    fns:NameWithScripts <- 'OutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]),
     fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] ),
     nf('out : bool <- read ('Out['n 'k]), return 'out, 'out)
    )
    
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'OutShareSum ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]),
     fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] ),
     nf('out : bool <- read ('Out['n 'k]), return 'out, 'out)
    )
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'RcvdOutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]),
     fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] ),
     nf('out : bool <- read ('Out['n 'k]), return 'out, 'out)
    )
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'Out,
    bt:BoolTerm <- (apply 'isOutputWire 'k) 
   ]{
   applyAlphaNFPr(
            fam ('Out[bound (N + 2) bound K]), 
                         << 'out, 'w >> emptyQidPairList)     
   }
   
} 

; applyAllSameCases( fam ('InShare$[bound (N + 1) bound (N + 2) dependentBound 'I]) )
; applyAlphaNFPr(
            fam ('InShare$[bound (N + 1) bound (N + 2) dependentBound 'I]), 
                         << 'in, 'x >> emptyQidPairList)

; absorbFamily( fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]) )
; absorbFamily( fam (('InRcvd ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]) )
; absorbFamilyDeleteEmpty( fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]) )


; reorder-newNF[ql2:List{CNameBound} <- 
( 
fam ('Ctrb[bound (N + 1) bound (N + 2) bound K])
fam ('CtrbSum[bound (N + 1) bound (N + 2) bound K])
fam ('RcvdBit[bound (N + 1) fixedBound (N + 1)bound K])
fam ('RcvdBit[bound (N + 1) bound (N + 1) bound K])
fam ('SendBit[bound (N + 1) bound (N + 2) bound K])
fam ('InShare$[bound (N + 1) bound (N + 2) dependentBound 'I])
fam ('InShare[bound (N + 1) bound (N + 2) dependentBound 'I])
fam ('Wire[bound K])
fam ('ShareSum[bound (N + 1) bound K])
fam ('Share[bound (N + 1) bound K])
fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])
)    
  ]
}
    
 ***  DONE main proof ends here, below just checks  
 ; get-structure  
.
)

