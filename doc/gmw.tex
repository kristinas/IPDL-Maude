\renewcommand{\flip}{\mathsf{flip}}
\newcommand{\circuit}{\mathsf{circuit}}
\newcommand{\inputgate}{\textit{input-gate}}
\newcommand{\xorgate}{\textit{xor-gate}}
\newcommand{\andgate}{\textit{and-gate}}
\newcommand{\notgate}{\textit{not-gate}}
\newcommand{\A}{\mathsf{A}}
\newcommand{\B}{\mathsf{B}}
\renewcommand{\id}{\mathsf{id}}
\renewcommand{\adv}{\mathsf{adv}}
\renewcommand{\ot}{\mathsf{ot}}
\newcommand{\Wires}{\mathsf{Wires}}
\newcommand{\Init}{\mathsf{Init}}
\newcommand{\Circ}{\mathsf{Circ}}
\newcommand{\Fin}{\mathsf{Fin}}
\newcommand{\Shares}{\mathsf{Shares}}
\newcommand{\OT}{\mathsf{1OutOf4OT}}
\newcommand{\Adv}{\mathsf{Adv}}
\newcommand{\RcvdBits}{\mathsf{RcvdBits}}
\newcommand{\Sim}{\mathsf{Sim}}
\renewcommand{\In}{\mathsf{In}}
\newcommand{\Wire}{\mathsf{Wire}}
\renewcommand{\Out}{\mathsf{Out}}
\newcommand{\SendInShare}{\mathsf{SendInShare}}
\newcommand{\SendOutShare}{\mathsf{SendOutShare}}
\newcommand{\InShareGen}{\mathsf{InShare}\textsf{-}\$}
\newcommand{\InShare}{\mathsf{InShare}}
\newcommand{\SendBit}{\mathsf{SendBit}}
\newcommand{\RcvdBit}{\mathsf{RcvdBit}}
\newcommand{\Share}{\mathsf{Share}}
\newcommand{\OutShare}{\mathsf{OutShare}}
\newcommand{\SumShare}{\mathsf{Share}\textsf{-}\Sigma}
\renewcommand{\OTMsg}{\mathsf{OTMsg}}
\renewcommand{\OTChc}{\mathsf{OTChc}}
\renewcommand{\OTOut}{\mathsf{OTOut}}
\newcommand{\LeakInRcvd}{\mathsf{InRcvd}}
\newcommand{\LeakIn}{\mathsf{In}}
\renewcommand{\LeakOut}{\mathsf{Out}}
\newcommand{\LeakRcvdInShare}{\mathsf{RcvdInShare}}
\newcommand{\LeakSendInShare}{\mathsf{SendInShare}}
\newcommand{\LeakRcvdOutShare}{\mathsf{RcvdOutShare}}
\newcommand{\LeakSendOutShare}{\mathsf{SendOutShare}}
\newcommand{\LeakInShareGen}{\mathsf{InShare}\textsf{-}\$}
\newcommand{\LeakInShare}{\mathsf{InShare}}
\newcommand{\LeakSendBit}{\mathsf{SendBit}}
\newcommand{\LeakRcvdBit}{\mathsf{RcvdBit}}
\newcommand{\LeakShare}{\mathsf{Share}}
\newcommand{\LeakOutShare}{\mathsf{OutShare}}
\newcommand{\LeakOTMsg}{\mathsf{OTMsg}}
\newcommand{\LeakOTChcRcvd}{\mathsf{OTChcRcvd}}
\newcommand{\InitOk}{\mathsf{Init}\textsf{-}\checkmark}
\newcommand{\WiresOk}{\mathsf{Wires}\textsf{-}\checkmark}
\newcommand{\SharesOk}{\mathsf{Shares}\textsf{-}\checkmark}
\newcommand{\SendRcvdBitsOk}{\mathsf{SendRcvdBits}\textsf{-}\checkmark}
\newcommand{\InOk}{\mathsf{In}\textsf{-}\checkmark}
\newcommand{\WireOk}{\mathsf{Wire}\textsf{-}\checkmark}
\newcommand{\InShareGenOk}{\mathsf{InShare}\textsf{-}\$\textsf{-}\checkmark}
\newcommand{\InShareOk}{\mathsf{InShare}\textsf{-}\checkmark}
\newcommand{\SendBitOk}{\mathsf{SendBit}\textsf{-}\checkmark}
\newcommand{\RcvdBitOk}{\mathsf{RcvdBit}\textsf{-}\checkmark}
\newcommand{\ShareOk}{\mathsf{Share}\textsf{-}\checkmark}

In the two-party GMW protocol, Alice and Bob jointly compute the value of a given Boolean circuit built out of \emph{xor-}, \emph{and-}, and \emph{not} gates. The inputs to the circuit are divided between Alice and Bob, and neither party has access to the inputs of the other. For each gate, Alice and Bob maintain their respective \emph{shares} of the actual value $v$ computed by the gate, with Alice's share computed only from the information available to Alice, and analogously for Bob. The respective shares for Alice and Bob sum up to $v$. We prove the protocol secure against a semi-honest attacker in the case when Alice is corrupt and Bob is honest.

Formally, we assume a coin-flip distribution $\flip : \one \twoheadrightarrow \Bool$; a Boolean sum function $\oplus : \Bool \times \Bool \rightarrow \Bool$, where we write $x \oplus y$ in place of $\oplus \ (x,y)$; a Boolean multiplication function $* : \Bool \times \Bool \rightarrow \Bool$, where we write $x * y$ in place of $* \ (x,y)$; and a Boolean negation function $\neg : \Bool \rightarrow \Bool$, where we write $\neg x$ in place of $\neg \ x$.

We represent Boolean circuits using the syntax below, where we assume Alice has $N \geq 0$ inputs labeled $\{0,\ldots,N-1\}$, and Bob has $M \geq 0$ inputs labeled $\{0,\ldots,M-1\}$. Starting from the empty circuit $\epsilon$, we add one gate at a time: an \emph{input} gate allows us to plug into a specified input $i$ of Alice or Bob; a \emph{not} gate negates the value carried on wire $k$; an \emph{xor} gate computes the Boolean sum of the two values carried on wires $k$ and $l$; and an \emph{and} gate does the same for Boolean product.

\begin{syntax}
  \abstractCategory[Parties]{p \coloneqq \A,\B}
	\abstractCategory[Inputs]{i \in \nat}
  \abstractCategory[Wires]{k,l \in \nat}
	
  \category[Circuits]{C}
    \alternative{\epsilon}
		\alternative{C; \, \inputgate(p,i)}
    \alternative{C; \, \notgate(k)}
		\alternative{C; \, \xorgate(k,l)}
		\alternative{C; \, \andgate(k,l)}
\end{syntax}

\noindent A circuit $C$ with $n \in \nat$ wires is considered well-formed if each logical gate combines previously defined wires only:

\begin{mathpar}
\inferrule*{ }{\epsilon \ \circuit(0)}\and
\inferrule*{C \ \circuit(n) \\ i < N}{C; \, \inputgate(\A,i) \ \circuit(n+1)}\and
\inferrule*{C \ \circuit(n) \\ i < M}{C; \, \inputgate(\B,i) \ \circuit(n+1)}\and
\inferrule*{C \ \circuit(n) \\ 0 \leq k < n}{C; \, \notgate(k) \ \circuit(n+1)}\and
\inferrule*{C \ \circuit(n) \\ 0 \leq k < n \\ 0 \leq l < n}{C; \, \xorgate(k,l) \ \circuit(n+1)}\and
\inferrule*{C \ \circuit(n) \\ 0 \leq k < n \\ 0 \leq l < n}{C; \, \andgate(k,l) \ \circuit(n+1)}
\end{mathpar}

\noindent We now fix an ambient Boolean circuit $C$ with $K$ wires $\{0,\ldots,K-1\}$, a subset of which is designated as outputs.

\subsection{The Assumptions}
At the expression level, we assume that the Boolean sum and product operations are commutative and associative:
\begin{itemize}
\item $x : \Bool, y : \Bool \vdash x \oplus y = y \oplus x : \Bool$,
\item $x : \Bool, y : \Bool \vdash x * y = y * x : \Bool$,
\item $x : \Bool, y : \Bool, z : \Bool \vdash (x \oplus y) \oplus z = x \oplus (y \oplus z) : \Bool$, and
\item $x : \Bool, y : \Bool, z : \Bool \vdash (x * y) * z = x * (y * z) : \Bool$.
\end{itemize}
Furthermore, Boolean multiplication distributes over Boolean sum:
\begin{itemize}
\item $x : \Bool, y : \Bool, z : \Bool \vdash (x \oplus y) * z = (x * z) \oplus (y * z) : \Bool$.
\end{itemize}
Summing up a Boolean with itself yields $\false$ and summing up a Boolean with $\false$ yields the original Boolean:
\begin{itemize}
\item $x : \Bool \vdash x \oplus x = \false : \Bool$, and
\item $x : \Bool \vdash x \oplus \false = x : \Bool$.
\end{itemize}
Negating a Boolean equals summing it up with $\true$:
\begin{itemize}
\item $x : \Bool \vdash x \oplus \true = \neg x : \Bool$.
\end{itemize}
Finally, multiplying a Boolean with $\false$ or $\true$ yields $\false$ or the original Boolean, respectively:
\begin{itemize}
\item $x : \Bool \vdash x * \false = \false : \Bool$, and
\item $x : \Bool \vdash x * \true = x : \Bool$.
\end{itemize}
At the distribution level, we assume that the distribution $\flip$ on Booleans is invariant under the operation of Boolean sum with a fixed Boolean (as is indeed the case when $\flip$ is uniform):
\begin{itemize}
\item $x : \Bool \vdash \big(y \leftarrow \flip; \ \ret{x \oplus y}\big) = \flip : \Bool$
\end{itemize}

\subsection{The Ideal Protocol}
The leakage from the ideal functionality includes the timing information for Bob's inputs, plus the value of each of Alice's inputs, as she is semi-honest:
\begin{itemize}
\item {\color{blue} $\LeakIn(\A,i)^\id_\adv \coloneqq \In(\A,i)$ for $i < N$}
\item {\color{blue} $\LeakInRcvd(\B,i)^\id_\adv \coloneqq x\leftarrow \In(\B,i); \ \ret{\checkmark}$ for $i < M$}
\end{itemize}

\noindent In the inductive phase, the functionality computes the value carried by each wire $k < K$ of the ambient circuit by induction on the circuit:

\begin{itemize}
\item $\Wires(\epsilon,0)$ is the protocol $\zero$
\item $\Wires\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Wires(C,K)$ with the protocol
\begin{itemize}
\item $\Wire(K) \coloneqq \read{\In(\A,i)}$
\end{itemize}
\item $\Wires\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Wires(C,K)$ with the protocol
\begin{itemize}
\item $\Wire(K) \coloneqq \read{\In(\B,i)}$
\end{itemize}
\item $\Wires\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Wires(C,K)$ with the protocol
\begin{itemize}
\item $\Wire(K) \coloneqq x \leftarrow \Wire(k); \ \ret{\neg x}$
\end{itemize}
\item $\Wires\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Wires(C,K)$ with the protocol
\begin{itemize}
\item $\Wire(K) \coloneqq x \leftarrow \Wire(k); \ y \leftarrow \Wire(l); \ \ret{x \oplus y}$
\end{itemize}
\item $\Wires\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Wires(C,K)$ with the protocol
\begin{itemize}
\item $\Wire(K) \coloneqq x \leftarrow \Wire(k); \ y \leftarrow \Wire(l); \ \ret{x * y}$
\end{itemize}
\end{itemize}

\noindent After performing the above computation, the ideal functionality outputs the computed value for each wire marked as an output, and leaks the outputs to the adversary on behalf of Alice:

\begin{itemize}
\item $\begin{cases*} \Out(\A,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\A,k) \coloneqq \read{\Out(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\begin{cases*} \Out(\B,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\B,k) \coloneqq \read{\Out(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item {\color{blue} $\LeakOut(\A,k)^\id_\adv \coloneqq \read{\Out(\A,k)}$ for $k < K$}
\end{itemize}

\noindent Finally, the channels $\Wire(-)$ coming from the inductive protocol $\Wires(C,K)$ are designated as internal.

\subsection{The Real Protocol}
The real protocol consists of the two parties, plus an instance of the ideal 1-Out-Of-4 Oblivious Transfer (OT) functionality for each gate, with Alice the sender and Bob the receiver. The code for each party is separated into three parts: in the initial phase, each party computes and distributes everyone's shares for each of its inputs. In the inductive phase, each party computes their share of each wire by induction on the ambient circuit. At last, in the final phase, Alice and Bob send their shares of each output wire to each other and add them up to compute the result.

\subsubsection{Alice: Initial Phase}
As Alice is semi-honest, she leaks the value of each of her inputs:
\begin{itemize}
\item {\color{blue} $\LeakIn(\A,i)^\A_\adv \coloneqq \read{\In(\A,i)}$ for $i < N$}
\end{itemize}
She next randomly generates shares for each of her inputs:
\begin{itemize}
\item $\InShareGen(\A,\A,i) \coloneqq x \leftarrow \In(\A,i); \ \samp{\flip}$ for $i < N$
\item {\color{blue} $\LeakInShareGen(\A,\A,i)^\A_\adv \coloneqq \read{\InShareGen(\A,\A,i)}$ for $i < N$}
\end{itemize}
Bob's share is computed by summing up the input $i$ with Alice's share:
\begin{itemize}
\item $\InShareGen(\B,\A,i) \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \In(\A,i); \ \ret{x_A \oplus x}$ for $i < N$
\item {\color{blue} $\LeakInShareGen(\B,\A,i)^\A_\adv \coloneqq \read{\InShareGen(\B,\A,i)}$ for $i < N$}
\end{itemize}
Alice's share of Bob's inputs is sent over to her by Bob, and she shares the value with the adversary:
\begin{itemize}
\item {\color{blue} $\LeakRcvdInShare(\A,\B,i)^\A_\adv \coloneqq \read{\SendInShare(\A,\B,i)}$ for $i < M$}
\end{itemize}
Alice now records her input shares -- those computed as above, as well as those received from Bob:
\begin{itemize}
\item $\InShare(\A,\A,i) \coloneqq \read{\InShareGen(\A,\A,i)}$ for $i < N$
\item $\InShare(\A,\B,i) \coloneqq \read{\SendInShare(\A,\B,i)}$ for $i < M$
\item {\color{blue} $\LeakInShare(\A,\A,i)^\A_\adv \coloneqq \read{\InShare(\A,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakInShare(\A,\B,i)^\A_\adv \coloneqq \read{\InShare(\A,\B,i)}$ for $i < M$}
\end{itemize}
At last, Alice sends over the shares she computed for Bob:
\begin{itemize}
\item $\SendInShare(\B,\A,i) \coloneqq \read{\InShareGen(\B,\A,i)}$ for $i < N$
\item {\color{blue} $\LeakSendInShare(\B,\A,i)^\A_\adv \coloneqq \read{\SendInShare(\B,\A,i)}$ for $i < N$}
\end{itemize}
The channels
\begin{itemize}
\item $\InShareGen(\A,\A,i)$ for $i < N$,
\item $\InShareGen(\B,\A,i)$ for $i < M$
\end{itemize}
are declared as internal.

\subsubsection{Bob: Initial Phase}
Since Bob is honest, the only leakage from him is the timing of his inputs:
\begin{itemize}
\item {\color{blue} $\LeakInRcvd(\B,i)^\B_\adv \coloneqq x \leftarrow \In(\B,i); \ \ret{\checkmark}$ for $i < M$}
\end{itemize}
Bob next randomly generates Alice's shares for each of his inputs:
\begin{itemize}
\item $\InShareGen(\A,\B,i) \coloneqq x \leftarrow \In(\B,i); \ \samp{\flip}$ for $i < M$
\end{itemize}
Bob's share is computed by summing up the input $i$ with Alice's share:
\begin{itemize}
\item $\InShareGen(\B,\B,i) \coloneqq x_A \leftarrow \InShareGen(\A,\B,i); \ x \leftarrow \In(\B,i); \ \ret{x_A \oplus x}$ for $i < M$
\end{itemize}
Bob now records his input shares -- those computed as above, as well as those received from Alice:
\begin{itemize}
\item $\InShare(\B,\A,i) \coloneqq \read{\SendInShare(\B,\A,i)}$ for $i < N$
\item $\InShare(\B,\B,i) \coloneqq \read{\InShareGen(\B,\B,i)}$ for $i < M$
\end{itemize}
At last, Bob sends over the shares he computed for Alice:
\begin{itemize}
\item $\SendInShare(\A,\B,i) \coloneqq \read{\InShareGen(\A,\B,i)}$ for $i < M$
\end{itemize}
The channels
\begin{itemize}
\item $\InShareGen(\A,\B,i)$ for $i < N$,
\item $\InShareGen(\B,\B,i)$ for $i < M$
\end{itemize}
are declared as internal.

\subsubsection{Alice: Inductive Phase}
In the case of an \emph{input} gate, Alice uses her corresponding input share from the initial phase. In the case of a \emph{not} gate, she simply copies her share $x_A$ of the incoming wire. If the gate is an \emph{xor} gate, the resulting share is the sum $x_A \oplus y_A$ of the shares of the incoming two wires. The case of an \emph{and} gate is the most complex. The sum of Alice's and Bob's shares must equal $(x_A \oplus x_B) * (y_A \oplus y_B)$, where $x_A,y_A$ and $x_B,y_B$ are the respective shares of Alice and Bob on the incoming two wires. We have
\[(x_A \oplus x_B) * (y_A \oplus y_B) = (x_A * y_A) \oplus (x_A * y_B) \oplus (x_B * y_A) \oplus (x_B * y_B)\]
and the quantity $(x_A * y_B) \oplus (x_B * y_A)$ cannot be directly computed by either Alice or Bob, as neither of them has access to the shares of the other. Instead, Alice and Bob engage in an idealized 1-Out-Of-4 OT exchange: there are four possible combinations of values that $x_B,y_B$ can take, and Alice computes the value of $(x_A * y_B) \oplus (x_B * y_A)$ for each. This offers Bob four messages to choose from, and he selects the one corresponding to the actual values of $x_B,y_B$. A small caveat: in the exchange as described above, Bob would still be able to infer the value of Alice's shares in certain cases: \emph{e.g.}, if $x_B = 0$ and $y_B = 1$, Bob gets the share $x_A$ as the result of the exchange. To prevent this, Alice encodes her messages by xor-ing them with a random Boolean $b$ that only she knows. To offset for the presence of this Boolean, she includes it in her share $b \oplus (x_A * y_A)$.\medskip

To stay consistent throughout the cases, we set up our protocol so that each gate induces the same set of outputs, even though some of these channels may not be relevant to the specific gate in question. These irrelevant channels will simply diverge, which makes them effectively nonexistent. For wire $K$, the relevant non-adversarial outputs for Alice are among the following:
\begin{itemize}
\item $\SendBit(\A,\B,K)$ for storing the masking Boolean is relevant for an \emph{and} gate,
\item $\Share(\A,K)$ for storing the share is always relevant,
\item $\OTMsg_0(\A,\B,K)$, $\OTMsg_1(\A,\B,K)$, $\OTMsg_2(\A,\B,K)$, $\OTMsg_3(\A,\B,K)$ are relevant for an \emph{and} gate.
\end{itemize}

\noindent We define Alice's inductive part as follows:
 
\begin{itemize}
\item $\Circ_\A(\epsilon,0)$ is the protocol $\zero$

\item $\Circ_\A\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Circ_\A(C,K)$ with the following protocol. Alice's share is the input share as determined in the initial part of the protocol:
\begin{itemize}
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\A,i)}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}
\end{itemize}
As we said earlier, the 1-Out-Of-4 OT exchange with Bob is vacuous:
\begin{itemize}
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$
\end{itemize}
Since no OT exchange is taking place, no masking Boolean is needed:
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\end{itemize}

\item $\Circ_\A\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Circ_\A(C,K)$ with the following protocol. Alice's share is the input share as determined in the initial part of the protocol:
\begin{itemize}
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\B,i)}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}
\end{itemize}
The 1-Out-Of-4 OT exchange with Bob is again vacuous:
\begin{itemize}
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$
\end{itemize}
Since no OT exchange is taking place, no masking Boolean is needed:
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\end{itemize}

\item $\Circ_\A\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Circ_\A(C,K)$ with the following protocol. Alice's share is the share on wire $k$:
\begin{itemize}
\item $\Share(\A,K) \coloneqq \read{\Share(\A,k)}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}
\end{itemize}
The 1-Out-Of-4 OT exchange with Bob is once again vacuous:
\begin{itemize}
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$
\end{itemize}
Since no OT exchange is taking place, no masking Boolean is needed:
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\end{itemize}

\item $\Circ_\A\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Circ_\A(C,K)$ with the following protocol. Alice's share is the sum of shares on wires $k$ and $l$:
\begin{itemize}
\item $\Share(\A,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{x_A \oplus y_A}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}
\end{itemize}
The 1-Out-Of-4 OT exchange with Bob is once more vacuous:
\begin{itemize}
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$
\end{itemize}
Since no OT exchange is taking place, no masking Boolean is needed:
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\end{itemize}

\item $\Circ_\A\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Circ_\A(C,K)$ with the following protocol. First, Alice generates a random Boolean for the OT exchange with Bob:
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \samp{\flip}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\SendBit(\A,\B,K)}$}
\end{itemize}
She carries out the 1-Out-Of-4 OT exchange with Bob:
\begin{itemize}
\item $\OTMsg_0(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$
\item $\OTMsg_1(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A}$
\item $\OTMsg_2(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus y_A}$
\item $\OTMsg_3(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A \oplus y_A}$
\end{itemize}
Alice's share is computed by adding the masking Boolean to the product of shares on wires $k$ and $l$:
\begin{itemize}
\item $\Share(\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{(x_A * y_A) \oplus b_A}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}
\end{itemize}
\end{itemize}
Finally, the channels
\begin{itemize}
\item $\SendBit(\A,\B,k)$ for $k < K$
\end{itemize}
are declared as internal.

\subsubsection{Bob: Inductive Phase}
In the case of an \emph{input} gate, Bob uses his corresponding input share from the initial phase. In the case of a \emph{not} gate, the resulting share is a negation of the share $x_B$ of the incoming wire. If the gate is an \emph{xor} gate, the resulting share is the sum $x_B \oplus y_B$ of the shares of the incoming two wires. Finally, in the case of an \emph{and} gate, Bob engages in an idealized 1-Out-Of-4 exchange with Alice as described in the previous section. To compute his share, he adds the result of the OT exchange to the product $x_B * y_B$ of the shares of the incoming two wires.\medskip

\noindent For wire $K$, the relevant non-adversarial outputs for Bob are among the following:
\begin{itemize}
\item $\RcvdBit(\B,\A,K)$ for receiving the result of the OT exchange is relevant for an \emph{and} gate,
\item $\Share(\B,K)$ for storing the share is always relevant,
\item $\OTChc_0(\A,\B,K)$, $\OTChc_1(\A,\B,K)$ are relevant for an \emph{and} gate.
\end{itemize}

\noindent We define Bob's inductive part as follows:

\begin{itemize}
\item $\Circ_\B(\epsilon,0)$ is the protocol $\zero$

\item $\Circ_\B\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Circ_\B(C,K)$ with the following protocol. Bob’s share is the input share as determined in the initial part of the protocol:
\begin{itemize}
\item $\Share(\B,K) \coloneqq \read{\InShare(\B,\A,i)}$
\end{itemize}
As we said earlier, the 1-Out-Of-4 OT exchange with Alice is vacuous:
\begin{itemize}
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$
\end{itemize}
Since no OT exchange is taking place, there is nothing to receive from the OT functionality:
\begin{itemize}
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\end{itemize}

\item $\Circ_\B\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Circ_\B(C,K)$ with the following protocol. Bob’s share is the input share as determined in the initial part of the protocol:
\begin{itemize}
\item $\Share(\B,K) \coloneqq \read{\InShare(\B,\B,i)}$
\end{itemize}
The 1-Out-Of-4 OT exchange with Alice is again vacuous:
\begin{itemize}
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$
\end{itemize}
Since no OT exchange is taking place, there is nothing to receive from the OT functionality:
\begin{itemize}
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\end{itemize}

\item $\Circ_\B\big(C; \, \notgate(k),K+1\big)$ the composition of $\Circ_\B(C,K)$ with the following protocol. Bob’s share is the negation of the share on wire $k$:
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_B \leftarrow \Share(\B,k); \ \ret{\neg x_B}$
\end{itemize}
The 1-Out-Of-4 OT exchange with Alice is once again vacuous:
\begin{itemize}
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$
\end{itemize}
Since no OT exchange is taking place, there is nothing to receive from the OT functionality:
\begin{itemize}
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\end{itemize}

\item $\Circ_\B\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Circ_\B(C,K)$ with the following protocol. Bob’s share is the sum of shares on wires $k$ and $l$:
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_B \oplus y_B}$
\end{itemize}
The 1-Out-Of-4 OT exchange with Bob is once more vacuous:
\begin{itemize}
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$
\end{itemize}
Since no OT exchange is taking place, there is nothing to receive from the OT functionality:
\begin{itemize}
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\end{itemize}

\item $\Circ_\B\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Circ_\B(C,K)$ with the following protocol. First, Bob carries out the 1-Out-Of-4 OT exchange with Alice:
\begin{itemize}
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\Share(\B,k)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\Share(\B,l)}$
\end{itemize}
He records the Boolean he received from the 1-Out-Of-4 OT exchange:
\begin{itemize}
\item $\RcvdBit(\B,\A,K) \coloneqq \OTOut(\A,\B,K)$
\end{itemize}
Bob's share is computed by adding the above Boolean to the product of shares on wires $k$ and $l$:
\begin{itemize}
\item $\Share(\B,K) \coloneqq b_B \leftarrow \RcvdBit(\B,\A,K); \ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_B \oplus (x_B * y_B)}$
\end{itemize}
\end{itemize}
Finally, the channels
\begin{itemize}
\item $\RcvdBit(\B,\A,k)$ for $k < K$
\end{itemize}
are declared as internal.

\subsubsection{Alice: Final Phase}
For each output wire, Alice sends her output share to Bob:
\begin{itemize}
\item $\begin{cases*} \SendOutShare(\B,\A,k) \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \SendOutShare(\B,\A,k) \coloneqq \read{\SendOutShare(\B,\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item {\color{blue} $\LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\SendOutShare(\B,\A,k)}$ for $k < K$}
\end{itemize}
Each output share received from Bob is forwarded to the adversary:
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\SendOutShare(\A,\B,k)}$ for $k < K$}
\end{itemize}
Alice now records the output shares -- her own, as well as those received from Bob:
\begin{itemize}
\item $\begin{cases*} \OutShare(\A,\A,k) \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \OutShare(\A,\A,k) \coloneqq \read{\OutShare(\A,\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\OutShare(\A,\B,k) \coloneqq \read{\SendOutShare(\A,\B,k)}$ for $k < K$
\item {\color{blue} $\LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\OutShare(\A,\A,k)}$ for $k < K$}
\item {\color{blue} $\LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\OutShare(\A,\B,k)}$ for $k < K$}
\end{itemize}
Finally, Alice declares the output to be the sum of the output shares:
\begin{itemize}
\item $\Out(\A,k) \coloneqq x_A \leftarrow \OutShare(\A,\A,k); \ x_B \leftarrow \OutShare(\A,\B,k); \ \ret{x_A \oplus x_B}$ for $k < K$
\item {\color{blue} $\LeakOut(\A,k)^\A_\adv \coloneqq \read{\Out(\A,k)}$ for $k < K$}
\end{itemize}
The channels
\begin{itemize}
\item $\OutShare(\A,\A,k)$ for $k < K$,
\item $\OutShare(\A,\B,k)$ for $k < k$
\end{itemize}
are declared as internal.

\subsubsection{Bob: Final Phase}
For each output wire, Bob sends his output share to Alice:
\begin{itemize}
\item $\begin{cases*} \SendOutShare(\A,\B,k) \coloneqq \read{\Share(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \SendOutShare(\A,\B,k) \coloneqq \read{\SendOutShare(\A,\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\end{itemize}
Bob now records the output shares -- his own, as well as those received from Alice:
\begin{itemize}
\item $\OutShare(\B,\A,k) \coloneqq \read{\SendOutShare(\B,\A,k)}$ for $k < K$
\item $\begin{cases*} \OutShare(\B,\B,k) \coloneqq \read{\Share(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \OutShare(\B,\B,k) \coloneqq \read{\OutShare(\B,\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\end{itemize}
Finally, Bob declares the output to be the sum of the output shares:
\begin{itemize}
\item $\Out(\B,k) \coloneqq x_A \leftarrow \OutShare(\B,\A,k); \ x_B \leftarrow \OutShare(\B,\B,k); \ \ret{x_A \oplus x_B}$ for $k < K$
\end{itemize}
The channels
\begin{itemize}
\item $\OutShare(\B,\A,k)$ for $k < K$,
\item $\OutShare(\B,\B,k)$ for $k < K$
\end{itemize}
are declared as internal.

\subsubsection{1-Out-Of-4 Oblivious Transfer Functionality}
For each wire $k < K$ we have a separate idealized 1-Out-Of-4 Oblivious Transfer functionality $\OT(k)$, which we now describe. Since Alice is semi-honest, the functionality leaks the value of all messages received from Alice:
\begin{itemize}
\item {\color{blue} $\LeakOTMsg_0(\A,\B,k)^\ot_\adv \coloneqq \read{\OTMsg_0(\A,\B,k)}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,k)^\ot_\adv \coloneqq \read{\OTMsg_1(\A,\B,k)}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,k)^\ot_\adv \coloneqq \read{\OTMsg_2(\A,\B,k)}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,k)^\ot_\adv \coloneqq \read{\OTMsg_3(\A,\B,k)}$}
\end{itemize}
Since Bob is honest, the functionality only lets the adversary know that a message from Bob has been received:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,k)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(\A,\B,k); \ \ret{\checkmark}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,k)^\ot_\adv \coloneqq c_1 \leftarrow \OTChc_1(\A,\B,k); \ \ret{\checkmark}$}
\end{itemize}
The functionality then selects the appropriate message:
\begin{itemize}
\item $\OTOut(\A,\B,k) \coloneqq m_0 \leftarrow \OTMsg_0(\A,\B,k); \ m_1 \leftarrow \OTMsg_1(\A,\B,k); \ m_2 \leftarrow \OTMsg_2(\A,\B,k); \\ m_3 \leftarrow \OTMsg_3(\A,\B,k); \ c_0 \leftarrow \OTChc_0(\A,\B,k); \ c_1 \leftarrow \OTChc_1(\A,\B,k); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}

\subsubsection{The Real Protocol}
The complete code for Alice arises as the composition of her initial, inductive, and final phases, followed by the hiding of the communication internal to Alice - namely, the channels
\begin{itemize}
\item $\InShare(\A,\A,i)$ for $i < N$,
\item $\InShare(\A,\B,i)$ for $i < M$,
\item $\Share(\A,k)$ for $k < K$.
\end{itemize}
Analogously, the complete code for Bob arises as the composition of his initial, inductive, and final phases, followed by the hiding of the communication internal to Bob - namely, the channels
\begin{itemize}
\item $\InShare(\B,\A,i)$ for $i < N$,
\item $\InShare(\B,\B,i)$ for $i < M$,
\item $\Share(\B,k)$ for $k < K$.
\end{itemize}
The real protocol is a composition of the two parties, plus an instance of the circuit-wide OT functionality
\begin{itemize}
\item $\OT(\A,\B,k)$ for $k < K$,
\end{itemize}
all followed by the hiding of the internal communication among the two parties and the functionality -- namely the channels
\begin{itemize}
\item $\SendInShare(\A,\B,i)$ for $i < M$,
\item $\SendInShare(\B,\A,i)$ for $i < N$,
\item $\OTMsg_0(\A,\B,k)$ for $k < K$,
\item $\OTMsg_1(\A,\B,k)$ for $k < K$,
\item $\OTMsg_2(\A,\B,k)$ for $k < K$,
\item $\OTMsg_3(\A,\B,k)$ for $k < K$,
\item $\OTChc_0(\A,\B,k)$ for $k < K$,
\item $\OTChc_1(\A,\B,k)$ for $k < K$,
\item $\OTOut(\A,\B,k)$ for $k < K$,
\item $\SendOutShare(\A,\B,k)$ for $k < K$,
\item $\SendOutShare(\B,\A,k)$ $k < K$.
\end{itemize}

\subsection{Real = Ideal + Simulator}
Our goal is to keep simplifying the real protocol until it becomes clear how to extract out a suitable simulator. We first restructure the entire protocol as a composition of an initial part, an inductive part, and a final part, all followed by the hiding of the channels
\begin{itemize}
\item $\InShare(\A,\A,i)$ for $i < N$,
\item $\InShare(\A,\B,i)$ for $i < M$,
\item $\InShare(\B,\A,i)$ for $i < N$,
\item $\InShare(\B,\B,i)$ for $i < M$,
\item $\Share(\A,k)$ for $k < K$,
\item $\Share(\B,k)$ for $k < K$.
\end{itemize}

\noindent The initial part of the real protocol arises by composing together the respective initial parts for each party, and declaring their communication as internal. Specifically, we have the following protocol $\Init$:

\begin{itemize}
\item {\color{blue} $\LeakIn(\A,i)^\A_\adv \coloneqq \read{\In(\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakInRcvd(\B,i)^\B_\adv \coloneqq x \leftarrow \In(\B,i); \ \ret{\checkmark}$ for $i < M$}
\item $\InShareGen(\A,\A,i) \coloneqq x \leftarrow \In(\A,i); \ \samp{\flip}$ for $i < N$
\item $\InShareGen(\A,\B,i) \coloneqq x \leftarrow \In(\B,i); \ \samp{\flip}$ for $i < M$
\item $\InShareGen(\B,\A,i) \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \In(\A,i); \ \ret{x_A \oplus x}$ for $i < N$
\item $\InShareGen(\B,\B,i) \coloneqq x_A \leftarrow \InShareGen(\A,\B,i); \ x \leftarrow \In(\B,i); \ \ret{x_A \oplus x}$ for $i < M$
\item {\color{blue} $\LeakInShareGen(\A,\A,i)^\A_\adv \coloneqq \read{\InShareGen(\A,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakInShareGen(\B,\A,i)^\A_\adv \coloneqq \read{\InShareGen(\B,\A,i)}$ for $i < N$}
\item $\SendInShare(\B,\A,i) \coloneqq \read{\InShareGen(\B,\A,i)}$ for $i < N$
\item $\SendInShare(\A,\B,i) \coloneqq \read{\InShareGen(\A,\B,i)}$ for $i < M$
\item {\color{blue} $\LeakSendInShare(\B,\A,i)^\A_\adv \coloneqq \read{\SendInShare(\B,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakRcvdInShare(\A,\B,i)^\A_\adv \coloneqq \read{\SendInShare(\A,\B,i)}$ for $i < M$}
\item $\InShare(\A,\A,i) \coloneqq \read{\InShareGen(\A,\A,i)}$ for $i < N$
\item $\InShare(\A,\B,i) \coloneqq \read{\SendInShare(\A,\B,i)}$ for $i < M$
\item $\InShare(\B,\A,i) \coloneqq \read{\SendInShare(\B,\A,i)}$ for $i < N$
\item $\InShare(\B,\B,i) \coloneqq \read{\InShareGen(\B,\B,i)}$ for $i < M$
\item {\color{blue} $\LeakInShare(\A,\A,i)^\A_\adv \coloneqq \read{\InShare(\A,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakInShare(\A,\B,i)^\A_\adv \coloneqq \read{\InShare(\A,\B,i)}$ for $i < M$}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\InShareGen(\A,\A,i)$ for $i < N$,
\item $\InShareGen(\A,\B,i)$ for $i < M$,
\item $\InShareGen(\B,\A,i)$ for $i < N$,
\item $\InShareGen(\B,\B,i)$ for $i < M$,
\item $\SendInShare(\B,\A,i)$ for $i < N$,
\item $\SendInShare(\A,\B,i)$ for $i < M$.
\end{itemize}

\noindent The inductive part of the real protocol arises by composing together the respective inductive parts for each party plus the circuit-wide OT functionality, and declaring the communication with the OT functionality as internal. Specifically, we have the following protocol $\Circ(C,K)$:

\begin{itemize}
\item $\Circ(\epsilon,0)$ is the protocol $\zero$

\item $\Circ\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}\smallskip
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$\smallskip
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\A,i)}$
\item $\Share(\B,K) \coloneqq \read{\InShare(\B,\A,i)}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_0(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_1(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_2(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_3(\A,\B,K)}$}\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(\A,\B,K); \ \ret{\checkmark}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq c_1 \leftarrow \OTChc_1(\A,\B,K); \ \ret{\checkmark}$}\smallskip
\item $\OTOut(\A,\B,K) \coloneqq m_0 \leftarrow \OTMsg_0(\A,\B,K); \ m_1 \leftarrow \OTMsg_1(\A,\B,K); \ m_2 \leftarrow \OTMsg_2(\A,\B,K); \\ m_3 \leftarrow \OTMsg_3(\A,\B,K); \ c_0 \leftarrow \OTChc_0(\A,\B,K); \ c_1 \leftarrow \OTChc_1(\A,\B,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}

\item $\Circ\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}\smallskip
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$\smallskip
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\B,i)}$
\item $\Share(\B,K) \coloneqq \read{\InShare(\B,\B,i)}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_0(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_1(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_2(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_3(\A,\B,K)}$}\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(\A,\B,K); \ \ret{\checkmark}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq c_1 \leftarrow \OTChc_1(\A,\B,K); \ \ret{\checkmark}$}\smallskip
\item $\OTOut(\A,\B,K) \coloneqq m_0 \leftarrow \OTMsg_0(\A,\B,K); \ m_1 \leftarrow \OTMsg_1(\A,\B,K); \ m_2 \leftarrow \OTMsg_2(\A,\B,K); \\ m_3 \leftarrow \OTMsg_3(\A,\B,K); \ c_0 \leftarrow \OTChc_0(\A,\B,K); \ c_1 \leftarrow \OTChc_1(\A,\B,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}

\item $\Circ\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}\smallskip
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$\smallskip
\item $\Share(\A,K) \coloneqq \read{\Share(\A,k)}$
\item $\Share(\B,K) \coloneqq x_B \leftarrow \Share(\B,k); \ \ret{\neg x_B}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_0(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_1(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_2(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_3(\A,\B,K)}$}\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(\A,\B,K); \ \ret{\checkmark}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq c_1 \leftarrow \OTChc_1(\A,\B,K); \ \ret{\checkmark}$}\smallskip
\item $\OTOut(\A,\B,K) \coloneqq m_0 \leftarrow \OTMsg_0(\A,\B,K); \ m_1 \leftarrow \OTMsg_1(\A,\B,K); \ m_2 \leftarrow \OTMsg_2(\A,\B,K); \\ m_3 \leftarrow \OTMsg_3(\A,\B,K); \ c_0 \leftarrow \OTChc_0(\A,\B,K); \ c_1 \leftarrow \OTChc_1(\A,\B,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}

\item $\Circ\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}\smallskip
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$\smallskip
\item $\Share(\A,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{x_A \oplus y_A}$
\item $\Share(\B,K) \coloneqq x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_B \oplus y_B}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_0(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_1(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_2(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_3(\A,\B,K)}$}\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(\A,\B,K); \ \ret{\checkmark}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq c_1 \leftarrow \OTChc_1(\A,\B,K); \ \ret{\checkmark}$}\smallskip
\item $\OTOut(\A,\B,K) \coloneqq m_0 \leftarrow \OTMsg_0(\A,\B,K); \ m_1 \leftarrow \OTMsg_1(\A,\B,K); \ m_2 \leftarrow \OTMsg_2(\A,\B,K); \\ m_3 \leftarrow \OTMsg_3(\A,\B,K); \ c_0 \leftarrow \OTChc_0(\A,\B,K); \ c_1 \leftarrow \OTChc_1(\A,\B,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}

\item $\Circ\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \samp{\flip}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\SendBit(\A,\B,K)}$}\smallskip
\item $\RcvdBit(\B,\A,K) \coloneqq \OTOut(\A,\B,K)$\smallskip
\item $\Share(\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{(x_A * y_A) \oplus b_A}$
\item $\Share(\B,K) \coloneqq b_B \leftarrow \RcvdBit(\B,\A,K); \ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_B \oplus (x_B * y_B)}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item $\OTMsg_0(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$
\item $\OTMsg_1(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A}$
\item $\OTMsg_2(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus y_A}$
\item $\OTMsg_3(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A \oplus y_A}$\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_0(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_1(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_2(\A,\B,K)}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_3(\A,\B,K)}$}\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\Share(\B,k)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\Share(\B,l)}$\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(\A,\B,K); \ \ret{\checkmark}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq c_1 \leftarrow \OTChc_1(\A,\B,K); \ \ret{\checkmark}$}\smallskip
\item $\OTOut(\A,\B,K) \coloneqq m_0 \leftarrow \OTMsg_0(\A,\B,K); \ m_1 \leftarrow \OTMsg_1(\A,\B,K); \ m_2 \leftarrow \OTMsg_2(\A,\B,K); \\ m_3 \leftarrow \OTMsg_3(\A,\B,K); \ c_0 \leftarrow \OTChc_0(\A,\B,K); \ c_1 \leftarrow \OTChc_1(\A,\B,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\SendBit(\A,\B,k)$ for $k < K$,
\item $\RcvdBit(\B,\A,k)$ for $k < K$,
\item $\OTMsg_0(\A,\B,k)$ for $k < K$,
\item $\OTMsg_1(\A,\B,k)$ for $k < K$,
\item $\OTMsg_2(\A,\B,k)$ for $k < K$,
\item $\OTMsg_3(\A,\B,k)$ for $k < K$,
\item $\OTChc_0(\A,\B,k)$ for $k < K$
\item $\OTChc_1(\A,\B,k)$ for $k < K$,
\item $\OTOut(\A,\B,k)$ for $k < K$.
\end{itemize}

\noindent The final part of the real protocol arises by composing together the respective initial parts for each party, and declaring their communication as internal. Specifically, we have the following protocol $\Fin$:

\begin{itemize}
\item $\begin{cases*} \SendOutShare(\B,\A,k) \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \SendOutShare(\B,\A,k) \coloneqq \read{\SendOutShare(\B,\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\begin{cases*} \SendOutShare(\A,\B,k) \coloneqq \read{\Share(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \SendOutShare(\A,\B,k) \coloneqq \read{\SendOutShare(\A,\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item {\color{blue} $\LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\SendOutShare(\B,\A,k)}$ for $k < K$}
\item {\color{blue} $\LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\SendOutShare(\A,\B,k)}$ for $k < K$}
\item $\begin{cases*} \OutShare(\A,\A,k) \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \OutShare(\A,\A,k) \coloneqq \read{\OutShare(\A,\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\OutShare(\A,\B,k) \coloneqq \read{\SendOutShare(\A,\B,k)}$ for $k < K$
\item $\OutShare(\B,\A,k) \coloneqq \read{\SendOutShare(\B,\A,k)}$ for $k < K$
\item $\begin{cases*} \OutShare(\B,\B,k) \coloneqq \read{\Share(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \OutShare(\B,\B,k) \coloneqq \read{\OutShare(\B,\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item {\color{blue} $\LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\OutShare(\A,\A,k)}$ for $k < K$}
\item {\color{blue} $\LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\OutShare(\A,\B,k)}$ for $k < K$}
\item $\Out(\A,k) \coloneqq x_A \leftarrow \OutShare(\A,\A,k); \ x_B \leftarrow \OutShare(\A,\B,k); \ \ret{x_A \oplus x_B}$ for $k < K$
\item $\Out(\B,k) \coloneqq x_A \leftarrow \OutShare(\B,\A,k); \ x_B \leftarrow \OutShare(\B,\B,k); \ \ret{x_A \oplus x_B}$ for $k < K$
\item {\color{blue} $\LeakOut(\A,k)^\A_\adv \coloneqq \read{\Out(\A,k)}$ for $k < K$}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\OutShare(\A,\A,k)$ for $k < K$,
\item $\OutShare(\A,\B,k)$ for $k < K$,
\item $\OutShare(\B,\A,k)$ for $k < K$,
\item $\OutShare(\B,\B,k)$ for $k < K$,
\item $\SendOutShare(\B,\A,k)$ for $k < K$,
\item $\SendOutShare(\A,\B,k)$ for $k < K$.
\end{itemize}

\subsubsection{Simplifying The Real Protocol: Initial Phase}
The internal channels $\SendInShare(\B,\A,-)$, $\SendInShare(\A,\B,-)$ can be substituted away, which yields the following simplified version $\Init$ of the initial part of the real protocol:

\begin{itemize}
\item {\color{blue} $\LeakIn(\A,i)^\A_\adv \coloneqq \read{\In(\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakInRcvd(\B,i)^\B_\adv \coloneqq x \leftarrow \In(\B,i); \ \ret{\checkmark}$ for $i < M$}
\item $\InShareGen(\A,\A,i) \coloneqq x \leftarrow \In(\A,i); \ \samp{\flip}$ for $i < N$
\item $\InShareGen(\A,\B,i) \coloneqq x \leftarrow \In(\B,i); \ \samp{\flip}$ for $i < M$
\item $\InShareGen(\B,\A,i) \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \In(\A,i); \ \ret{x_A \oplus x}$ for $i < N$
\item $\InShareGen(\B,\B,i) \coloneqq x_A \leftarrow \InShareGen(\A,\B,i); \ x \leftarrow \In(\B,i); \ \ret{x_A \oplus x}$ for $i < M$
\item {\color{blue} $\LeakInShareGen(\A,\A,i)^\A_\adv \coloneqq \read{\InShareGen(\A,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakInShareGen(\B,\A,i)^\A_\adv \coloneqq \read{\InShareGen(\B,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakSendInShare(\B,\A,i)^\A_\adv \coloneqq \read{\InShareGen(\B,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakRcvdInShare(\A,\B,i)^\A_\adv \coloneqq \read{\InShareGen(\A,\B,i)}$ for $i < M$}
\item $\InShare(\A,\A,i) \coloneqq \read{\InShareGen(\A,\A,i)}$ for $i < N$
\item $\InShare(\A,\B,i) \coloneqq \read{\InShareGen(\A,\B,i)}$ for $i < M$
\item $\InShare(\B,\A,i) \coloneqq \read{\InShareGen(\B,\A,i)}$ for $i < N$
\item $\InShare(\B,\B,i) \coloneqq \read{\InShareGen(\B,\B,i)}$ for $i < M$
\item {\color{blue} $\LeakInShare(\A,\A,i)^\A_\adv \coloneqq \read{\InShare(\A,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakInShare(\A,\B,i)^\A_\adv \coloneqq \read{\InShare(\A,\B,i)}$ for $i < M$}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\InShareGen(\A,\A,i)$ for $i < N$,
\item $\InShareGen(\A,\B,i)$ for $i < M$,
\item $\InShareGen(\B,\A,i)$ for $i < N$,
\item $\InShareGen(\B,\B,i)$ for $i < M$.
\end{itemize}

\subsubsection{Simplifying The Real Protocol: Inductive Phase}
Our next order of business is to eliminate all channels interacting with the OT functionality. In the case of \emph{input-}, \emph{not-}, and \emph{xor} gates, the OT channels are divergent and only appear in the corresponding leakage channels. The leakage channels themselves are therefore divergent. For instance, the channel
\begin{itemize}
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_0(\A,\B,K)}$}
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\end{itemize}
and so we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\end{itemize}
Similarly, the channel
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(\A,\B,K); \ \ret{\checkmark}$}
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\end{itemize}
and so we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\end{itemize}
Finally, the channel
\begin{itemize}
\item $\OTOut(\A,\B,K) \coloneqq m_0 \leftarrow \OTMsg_0(\A,\B,K); \ m_1 \leftarrow \OTMsg_1(\A,\B,K); \ m_2 \leftarrow \OTMsg_2(\A,\B,K); \\ m_3 \leftarrow \OTMsg_3(\A,\B,K); \ c_0 \leftarrow \OTChc_0(\A,\B,K); \ c_1 \leftarrow \OTChc_1(\A,\B,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\end{itemize}
and so we may equivalently write the following:
\begin{itemize}
\item $\OTOut(\A,\B,K) \coloneqq \read{\OTOut(\A,\B,K)}$
\end{itemize}
In the case of an \emph{and} gate, we start by eliminating any mention of the OT channels from the leakage channels. For instance, substituting the channel
\begin{itemize}
\item $\OTMsg_0(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$
\end{itemize}
into the channel
\begin{itemize}
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\OTMsg_0(\A,\B,K)}$}
\end{itemize}
yields the following:
\begin{itemize}
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$}
\end{itemize}
Analogously, we have the following:
\begin{itemize}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus y_A}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A \oplus y_A}$}
\end{itemize}
We treat the receiver channels similarly. For instance, substituting the channel
\begin{itemize}
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\Share(\B,k)}$
\end{itemize}
into the channel
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\B,\A,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(\A,\B,K); \ \ret{\checkmark}$}
\end{itemize}
yields the following:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq x_B \leftarrow \Share(\B,k); \ \ret{\checkmark}$}
\end{itemize}
Analogously, we have the following:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq y_B \leftarrow \Share(\B,l); \ \ret{\checkmark}$}
\end{itemize}
At this point, none of the leakage channels refer to any of the OT channels anymore. So outside of the OT channels themselves, the only place where we still refer to an OT channel is in the channel
\begin{itemize}
\item $\RcvdBit(\B,\A,K) \coloneqq \OTOut(\A,\B,K)$
\end{itemize}
that stores the result of the OT exchange between Alice and Bob. 
 Substituting the channel
\begin{itemize}
\item $\OTOut(\A,\B,K) \coloneqq m_0 \leftarrow \OTMsg_0(\A,\B,K); \ m_1 \leftarrow \OTMsg_1(\A,\B,K); \ m_2 \leftarrow \OTMsg_2(\A,\B,K); \\ m_3 \leftarrow \OTMsg_3(\A,\B,K); \ c_0 \leftarrow \OTChc_0(\A,\B,K); \ c_1 \leftarrow \OTChc_1(\A,\B,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}
into the above thus yields the somewhat more verbose
\begin{itemize}
\item $\RcvdBit(\B,\A,K) \coloneqq m_0 \leftarrow \OTMsg_0(\A,\B,K); \ m_1 \leftarrow \OTMsg_1(\A,\B,K); \ m_2 \leftarrow \OTMsg_2(\A,\B,K); \\ m_3 \leftarrow \OTMsg_3(\A,\B,K); \ c_0 \leftarrow \OTChc_0(\A,\B,K); \ c_1 \leftarrow \OTChc_1(\A,\B,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}
with the advantage that it no longer mentions $\OTOut(\A,\B,K)$. We may further substitute the channels
\begin{itemize}
\item $\OTMsg_0(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$
\item $\OTMsg_1(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A}$
\item $\OTMsg_2(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus y_A}$
\item $\OTMsg_3(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A \oplus y_A}$
\end{itemize}
as well as the channels
\begin{itemize}
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\Share(\B,k)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\Share(\B,l)}$
\end{itemize}
to obtain the following:
\begin{itemize}
\item $\RcvdBit(\B,\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ x_B \leftarrow \Share(\B,k); \\ y_B \leftarrow \Share(\B,l); \ \ifte{x_B}{\big(\ifte{y_B}{\ret{b_A \oplus x_A \oplus y_A}}{\ret{b_A \oplus y_A}}\big)}{\big(\ifte{y_B}{\ret{b_A \oplus x_A}}{\ret{b_A}}\big)}$
\end{itemize}
Here we no longer refer to any of the OT channels. We can express the above more concisely as follows:
\begin{itemize}
\item $\RcvdBit(\B,\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_A \oplus (x_A * y_B) \oplus (x_B * y_A)}$
\end{itemize}
Summarizing, we can rewrite the inductive part $\Circ(C,K)$ of the real protocol as follows:

\begin{itemize}
\item $\Circ(\epsilon,0)$ is the protocol $\zero$

\item $\Circ\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}\smallskip
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$\smallskip
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\A,i)}$
\item $\Share(\B,K) \coloneqq \read{\InShare(\B,\A,i)}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}\smallskip
\item $\OTOut(\A,\B,K) \coloneqq \read{\OTOut(\A,\B,K)}$
\end{itemize}

\item $\Circ\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}\smallskip
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$\smallskip
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\B,i)}$
\item $\Share(\B,K) \coloneqq \read{\InShare(\B,\B,i)}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}\smallskip
\item $\OTOut(\A,\B,K) \coloneqq \read{\OTOut(\A,\B,K)}$
\end{itemize}

\item $\Circ\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}\smallskip
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$\smallskip
\item $\Share(\A,K) \coloneqq \read{\Share(\A,k)}$
\item $\Share(\B,K) \coloneqq x_B \leftarrow \Share(\B,k); \ \ret{\neg x_B}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}\smallskip
\item $\OTOut(\A,\B,K) \coloneqq \read{\OTOut(\A,\B,K)}$
\end{itemize}

\item $\Circ\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}\smallskip
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$\smallskip
\item $\Share(\A,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{x_A \oplus y_A}$
\item $\Share(\B,K) \coloneqq x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_B \oplus y_B}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}\smallskip
\item $\OTOut(\A,\B,K) \coloneqq \read{\OTOut(\A,\B,K)}$
\end{itemize}

\item $\Circ\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \samp{\flip}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\SendBit(\A,\B,K)}$}\smallskip
\item $\RcvdBit(\B,\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_A \oplus (x_A * y_B) \oplus (x_B * y_A)}$\smallskip
\item $\Share(\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{(x_A * y_A) \oplus b_A}$
\item $\Share(\B,K) \coloneqq b_B \leftarrow \RcvdBit(\B,\A,K); \ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_B \oplus (x_B * y_B)}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item $\OTMsg_0(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$
\item $\OTMsg_1(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A}$
\item $\OTMsg_2(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus y_A}$
\item $\OTMsg_3(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A \oplus y_A}$\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus y_A}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A \oplus y_A}$}\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\Share(\B,k)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\Share(\B,l)}$\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq x_B \leftarrow \Share(\B,k); \ \ret{\checkmark}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq y_B \leftarrow \Share(\B,l); \ \ret{\checkmark}$}\smallskip
\item $\OTOut(\A,\B,K) \coloneqq m_0 \leftarrow \OTMsg_0(\A,\B,K); \ m_1 \leftarrow \OTMsg_1(\A,\B,K); \ m_2 \leftarrow \OTMsg_2(\A,\B,K); \\ m_3 \leftarrow \OTMsg_3(\A,\B,K); \ c_0 \leftarrow \OTChc_0(\A,\B,K); \ c_1 \leftarrow \OTChc_1(\A,\B,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}
\end{itemize}

\noindent We now split the protocol $\Circ(C,K)$ into three parts. The first protocol $\Shares(C,K)$ performs the computation of shares and is defined as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\A,i)}$
\item $\Share(\B,K) \coloneqq \read{\InShare(\B,\A,i)}$
\end{itemize}

\item $\Shares\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\B,i)}$
\item $\Share(\B,K) \coloneqq \read{\InShare(\B,\B,i)}$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\Share(\A,k)}$
\item $\Share(\B,K) \coloneqq x_B \leftarrow \Share(\B,k); \ \ret{\neg x_B}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{x_A \oplus y_A}$
\item $\Share(\B,K) \coloneqq x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_B \oplus y_B}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \samp{\flip}$
\item $\RcvdBit(\B,\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_A \oplus (x_A * y_B) \oplus (x_B * y_A)}$
\item $\Share(\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{(x_A * y_A) \oplus b_A}$
\item $\Share(\B,K) \coloneqq b_B \leftarrow \RcvdBit(\B,\A,K); \ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_B \oplus (x_B * y_B)}$
\end{itemize}
\end{itemize}

\noindent The second protocol $\Adv(C,K)$ performs all leakages and is defined as follows:

\begin{itemize}
\item $\Adv(\epsilon,0)$ is the protocol $\zero$

\item $\Adv\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\SendBit(\A,\B,K)}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus y_A}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A \oplus y_A}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq x_B \leftarrow \Share(\B,k); \ \ret{\checkmark}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq y_B \leftarrow \Share(\B,l); \ \ret{\checkmark}$}
\end{itemize}
\end{itemize}

\noindent The third protocol $\OT(C,K)$ performs all Oblivious Transfer exchanges and is defined as follows:

\begin{itemize}
\item $\OT(\epsilon,0)$ is the protocol $\zero$

\item $\OT\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\OT(C,K)$ with the protocol
\begin{itemize}
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$\smallskip
\item $\OTOut(\A,\B,K) \coloneqq \read{\OTOut(\A,\B,K)}$
\end{itemize}

\item $\OT\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\OT(C,K)$ with the protocol
\begin{itemize}
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$\smallskip
\item $\OTOut(\A,\B,K) \coloneqq \read{\OTOut(\A,\B,K)}$
\end{itemize}

\item $\OT\big(C; \, \notgate(k),K+1\big)$ is the composition of $\OT(C,K)$ with the protocol
\begin{itemize}
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$\smallskip
\item $\OTOut(\A,\B,K) \coloneqq \read{\OTOut(\A,\B,K)}$
\end{itemize}

\item $\OT\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\OT(C,K)$ with the protocol
\begin{itemize}
\item $\OTMsg_0(\A,\B,K) \coloneqq \read{\OTMsg_0(\A,\B,K)}$
\item $\OTMsg_1(\A,\B,K) \coloneqq \read{\OTMsg_1(\A,\B,K)}$
\item $\OTMsg_2(\A,\B,K) \coloneqq \read{\OTMsg_2(\A,\B,K)}$
\item $\OTMsg_3(\A,\B,K) \coloneqq \read{\OTMsg_3(\A,\B,K)}$\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\OTChc_0(\A,\B,K)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\OTChc_1(\A,\B,K)}$\smallskip
\item $\OTOut(\A,\B,K) \coloneqq \read{\OTOut(\A,\B,K)}$
\end{itemize}

\item $\OT\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\OT(C,K)$ with the protocol
\begin{itemize}
\item $\OTMsg_0(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$
\item $\OTMsg_1(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A}$
\item $\OTMsg_2(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus y_A}$
\item $\OTMsg_3(\A,\B,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A \oplus y_A}$\smallskip
\item $\OTChc_0(\A,\B,K) \coloneqq \read{\Share(\B,k)}$
\item $\OTChc_1(\A,\B,K) \coloneqq \read{\Share(\B,l)}$\smallskip
\item $\OTOut(\A,\B,K) \coloneqq m_0 \leftarrow \OTMsg_0(\A,\B,K); \ m_1 \leftarrow \OTMsg_1(\A,\B,K); \ m_2 \leftarrow \OTMsg_2(\A,\B,K); \\ m_3 \leftarrow \OTMsg_3(\A,\B,K); \ c_0 \leftarrow \OTChc_0(\A,\B,K); \ c_1 \leftarrow \OTChc_1(\A,\B,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}
\end{itemize}

\noindent At this point, none of the channels defined by $\OT(C,K)$ are utilized anywhere outside of $\OT(C,K)$ and as such we may discard this protocol entirely. The inductive part of the real protocol therefore consists of the protocols $\Shares(C,K)$ and $\Adv(C,K)$, followed by the hiding of the channels
\begin{itemize}
\item $\SendBit(\A,\B,k)$ for $k < K$,
\item $\RcvdBit(\B,\A,k)$ for $k < K$.
\end{itemize}

\subsubsection{Simplifying The Real Protocol: Final Phase}
If wire $k$ is not an output, then the channels
\begin{itemize}
\item {\color{blue} $\LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\SendOutShare(\B,\A,k)}$}
\item $\OutShare(\B,\A,k) \coloneqq \read{\SendOutShare(\B,\A,k)}$
\end{itemize}
read from the divergent channel
\begin{itemize}
\item $\SendOutShare(\B,\A,k) \coloneqq \read{\SendOutShare(\B,\A,k)}$
\end{itemize}
and thus we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\LeakSendOutShare(\B,\A,k)^\A_\adv}$ for $k < K$}
\item $\OutShare(\B,\A,k) \coloneqq \read{\OutShare(\B,\A,k)}$
\end{itemize}
If wire $k$ is an output, then the channels
\begin{itemize}
\item {\color{blue} $\LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\SendOutShare(\B,\A,k)}$}
\item $\OutShare(\B,\A,k) \coloneqq \read{\SendOutShare(\B,\A,k)}$
\end{itemize}
read from the channel
\begin{itemize}
\item $\SendOutShare(\B,\A,k) \coloneqq \read{\Share(\A,k)}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item {\color{blue} $\LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)}$}
\item $\OutShare(\B,\A,k) \coloneqq \read{\Share(\A,k)}$
\end{itemize}
Summarizing the above, we get the following for channels $\LeakSendOutShare(\B,\A,-)^\A_\adv$ and $\OutShare(\B,\A,-)$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\LeakSendOutShare(\B,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item $\begin{cases*} \OutShare(\B,\A,k) \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \OutShare(\B,\A,k) \coloneqq \read{\OutShare(\B,\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\end{itemize}
If wire $k$ is not an output, then the channels
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\SendOutShare(\A,\B,k)}$}
\item $\OutShare(\A,\B,k) \coloneqq \read{\SendOutShare(\A,\B,k)}$
\end{itemize}
read from the divergent channel
\begin{itemize}
\item $\SendOutShare(\A,\B,k) \coloneqq \read{\SendOutShare(\A,\B,k)}$
\end{itemize}
and thus we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakRcvdOutShare(\A,\B,k)^\A_\adv}$ for $k < K$}
\item $\OutShare(\A,\B,k) \coloneqq \read{\OutShare(\A,\B,k)}$
\end{itemize}
If wire $k$ is an output, then the channels
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\SendOutShare(\A,\B,k)}$}
\item $\OutShare(\A,\B,k) \coloneqq \read{\SendOutShare(\A,\B,k)}$
\end{itemize}
read from the channel
\begin{itemize}
\item $\SendOutShare(\A,\B,k) \coloneqq \read{\Share(\B,k)}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\Share(\B,k)}$}
\item $\OutShare(\A,\B,k) \coloneqq \read{\Share(\B,k)}$
\end{itemize}
Summarizing the above, we get the following for channels $\LeakRcvdOutShare(\A,\B,k)^\A_\adv$ and $\OutShare(\A,\B,-)$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\Share(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakRcvdOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item $\begin{cases*} \OutShare(\A,\B,k) \coloneqq \read{\Share(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \OutShare(\A,\B,k) \coloneqq \read{\OutShare(\A,\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\end{itemize}
At this point, the internal channels $\SendOutShare(\B,\A,-)$, $\SendOutShare(\A,\B,-)$ are unused and can be eliminated. Our simplified version $\Fin$ of the final part of the real protocol is therefore as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\LeakSendOutShare(\B,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\Share(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakRcvdOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item $\begin{cases*} \OutShare(\A,\A,k) \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \OutShare(\A,\A,k) \coloneqq \read{\OutShare(\A,\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\begin{cases*} \OutShare(\A,\B,k) \coloneqq \read{\Share(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \OutShare(\A,\B,k) \coloneqq \read{\OutShare(\A,\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\begin{cases*} \OutShare(\B,\A,k) \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \OutShare(\B,\A,k) \coloneqq \read{\OutShare(\B,\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\begin{cases*} \OutShare(\B,\B,k) \coloneqq \read{\Share(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \OutShare(\B,\B,k) \coloneqq \read{\OutShare(\B,\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item {\color{blue} $\LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\OutShare(\A,\A,k)}$ for $k < K$}
\item {\color{blue} $\LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\OutShare(\A,\B,k)}$ for $k < K$}
\item $\Out(\A,k) \coloneqq x_A \leftarrow \OutShare(\A,\A,k); \ x_B \leftarrow \OutShare(\A,\B,k); \ \ret{x_A \oplus x_B}$ for $k < K$
\item $\Out(\B,k) \coloneqq x_A \leftarrow \OutShare(\B,\A,k); \ x_B \leftarrow \OutShare(\B,\B,k); \ \ret{x_A \oplus x_B}$ for $k < K$
\item {\color{blue} $\LeakOut(\A,k)^\A_\adv \coloneqq \read{\Out(\A,k)}$ for $k < K$}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\OutShare(\A,\A,k)$ for $k < K$,
\item $\OutShare(\A,\B,k)$ for $k < K$,
\item $\OutShare(\B,\A,k)$ for $k < K$,
\item $\OutShare(\B,\B,k)$ for $k < K$.
\end{itemize}

\subsubsection{Timing of Shares I}\label{sect:gmw_timing_1}
Since Bob is by assumption honest, the simulator does not have access to his inputs. Therefore, any computation that depends on the value of Bob's inputs must be eliminated. In particular, all of Bob's shares must be eliminated.

By design, summing up the respective shares $x_A \oplus x_B$ of each party on a given wire yields the actual value $x$ carried by the wire. If we got our hands on $x$, for example by inductively computing the circuit the same way the ideal functionality does, we could replace Bob's share $x_B$ by the sum $x \oplus x_A$. For this strategy to work, however, we need to arrange the timing so that Bob computes his shares after Alice.\medskip

\noindent To this end, we introduce new internal channels
\begin{itemize}
\item {\color{teal} $\InShareOk(\A,\A,i) \coloneqq \_ \leftarrow \InShare(\A,\A,i); \ \ret{\checkmark}$ for $i < N$}
\item {\color{teal} $\InShareOk(\A,\B,i) \coloneqq \_ \leftarrow \InShare(\A,\B,i); \ \ret{\checkmark}$ for $i < M$}
\item {\color{teal} $\InShareOk(\B,\A,i) \coloneqq \_ \leftarrow \InShare(\B,\A,i); \ \ret{\checkmark}$ for $i < N$}
\item {\color{teal} $\InShareOk(\B,\B,i) \coloneqq \_ \leftarrow \InShare(\B,\B,i); \ \ret{\checkmark}$ for $i < M$}
\end{itemize}
for the timing of input shares in the initial part of the protocol and
\begin{itemize}
\item {\color{teal} $\ShareOk(\A,k) \coloneqq \_ \leftarrow \Share(\A,k); \ \ret{\checkmark}$ for $k < K$}
\item {\color{teal} $\ShareOk(\B,k) \coloneqq \_ \leftarrow \Share(\B,k); \ \ret{\checkmark}$ for $k < K$}
\end{itemize}
for the timing of shares in the inductive part of the protocol.\medskip

Since the primary job of the simulator is to construct the appropriate leakage, we start by eliminating any mention of the Bob's shares from the leakage channels. Upon carefully examining the inductive part of the real protocol, we see that the only place where we leak information depending on Bob's shares is when we leak the timing of his shares on behalf of the OT functionality in the case of an \emph{and} gate. But even in this case, the \emph{value} of the shares is immaterial - it is only the timing information that matters.\medskip

\noindent Specifically, take the protocol $\Adv(C,K)$ in the case of an \emph{and} gate. We can write the channels
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq x_B \leftarrow \Share(\B,k); \ \ret{\checkmark}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq y_B \leftarrow \Share(\B,l); \ \ret{\checkmark}$}
\end{itemize}
equivalently as follows:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\ShareOk(\B,k)}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\ShareOk(\B,l)}$}
\end{itemize}
So the inductive part of the real protocol now has $\Adv(C,K)$ looking like so:

\begin{itemize}
\item $\Adv(\epsilon,0)$ is the protocol $\zero$

\item $\Adv\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\SendBit(\A,\B,K)}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus y_A}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A \oplus y_A}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\ShareOk(\B,k)}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\ShareOk(\B,l)}$}
\end{itemize}
\end{itemize}

\noindent We now amend Bob's shares with a gratuitous dependency on timing, which we will later convert into a dependency on the sum of shares of parties $0,\ldots,N$. To this end, we introduce new internal channels
\begin{itemize}
\item {\color{teal} $\InShareGenOk(\A,\A,i)$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\A,\B,i)$ for $i < M$}
\item {\color{teal} $\InShareGenOk(\B,\A,i)$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\B,\B,i)$ for $i < M$}
\end{itemize}
to keep track of the timing information in the protocol $\Init$ and
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,k)$ for $k < K$}
\item {\color{teal} $\RcvdBitOk(\A,\B,k)$ for $k < K$}
\end{itemize}
to keep track of the timing information in the protocol $\Shares(C,K)$. Call the following protocol fragment $\InitOk$:
\begin{itemize}
\item {\color{teal} $\InShareGenOk(\A,\A,i)$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\A,\B,i)$ for $i < M$}
\item {\color{teal} $\InShareGenOk(\B,\A,i)$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\B,\B,i)$ for $i < M$}
\item {\color{teal} $\InShareOk(\A,\A,i) \coloneqq \_ \leftarrow \InShare(\A,\A,i); \ \ret{\checkmark}$ for $i < N$}
\item {\color{teal} $\InShareOk(\A,\B,i) \coloneqq \_ \leftarrow \InShare(\A,\B,i); \ \ret{\checkmark}$ for $i < M$}
\item {\color{teal} $\InShareOk(\B,\A,i) \coloneqq \_ \leftarrow \InShare(\B,\A,i); \ \ret{\checkmark}$ for $i < N$}
\item {\color{teal} $\InShareOk(\B,\B,i) \coloneqq \_ \leftarrow \InShare(\B,\B,i); \ \ret{\checkmark}$ for $i < M$}
\end{itemize}
Call the following protocol fragment $\SharesOk(C,K)$:
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,k)$ for $k < K$}
\item {\color{teal} $\RcvdBitOk(\A,\B,k)$ for $k < K$}
\item {\color{teal} $\ShareOk(\A,k) \coloneqq \_ \leftarrow \Share(\A,k); \ \ret{\checkmark}$ for $k < K$}
\item {\color{teal} $\ShareOk(\B,k) \coloneqq \_ \leftarrow \Share(\B,k); \ \ret{\checkmark}$ for $k < K$}
\end{itemize}

\noindent In the presence of the channels $\InShareOk(\A,\A,-)$, $\InShareOk(\A,\B,-)$, $\InShareOk(\B,\A,-)$, $\InShareOk(\B,\B,-)$ and the protocol $\SharesOk(C,K)$ we can express the protocol $\Shares(C,K)$ equivalently as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\A,i)}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \InShareOk(\B,\A,i); \ \read{\InShare(\B,\A,i)}$
\end{itemize}

\item $\Shares\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\B,i)}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \InShareOk(\B,\B,i); \ \read{\InShare(\B,\B,i)}$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\Share(\A,k)}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \ShareOk(\B,k); \ x_B \leftarrow \Share(\B,k); \ \ret{\neg x_B}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{x_A \oplus y_A}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \ShareOk(\B,k); \ \_ \leftarrow \ShareOk(\B,l); \ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_B \oplus y_B}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \samp{\flip}$
\item $\RcvdBit(\B,\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_A \oplus (x_A * y_B) \oplus (x_B * y_A)}$
\item $\Share(\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{(x_A * y_A) \oplus b_A}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \RcvdBitOk(\A,\B,K); \ \_ \leftarrow \ShareOk(\B,k); \ \_ \leftarrow \ShareOk(\B,l); \\ b_B \leftarrow \RcvdBit(\B,\A,K); \ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_B \oplus (x_B * y_B)}$
\end{itemize}
\end{itemize}

\noindent Clearly, we can make the timing of shares independent of their value; this was the point of introducing the timing channels in the first place. For input shares, the timing only depends on the timing of the corresponding input, so we introduce new internal channels
\begin{itemize}
\item {\color{teal} $\InOk(\A,i) \coloneqq \_ \leftarrow \read{\In(\A,i)}; \ \ret{\checkmark}$ for $i < N$}
\item {\color{teal} $\InOk(\B,i) \coloneqq \_ \leftarrow \read{\In(\B,i)}; \ \ret{\checkmark}$ for $i < M$}
\end{itemize}
to keep track of whether an input has arrived. For a wire share, the timing depends on the timing of every input that recursively feeds into the wire. We can easily compute this in a new protocol $\WiresOk(C,K)$:

\begin{itemize}
\item $\WiresOk(\epsilon,0)$ is the protocol $\zero$
\item $\WiresOk\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \read{\InOk(\A,i)}$}
\end{itemize}
\item $\WiresOk\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \read{\InOk(\B,i)}$}
\end{itemize}
\item $\WiresOk\big(C; \, \notgate(k),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \_ \leftarrow \WireOk(k); \ \ret{\checkmark}$}
\end{itemize}
\item $\WiresOk\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$}
\end{itemize}
\item $\WiresOk\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$}
\end{itemize}
\end{itemize}

\noindent Our goal now is to show that the timing channels can be equivalently characterized as follows:
\begin{itemize}
\item {\color{teal} $\InShareOk(\A,\A,i) \coloneqq \read{\InOk(\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareOk(\A,\B,i) \coloneqq \read{\InOk(\B,i)}$ for $i < M$}
\item {\color{teal} $\InShareOk(\B,\A,i) \coloneqq \read{\InOk(\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareOk(\B,\B,i) \coloneqq \read{\InOk(\B,i)}$ for $i < M$}
\item {\color{teal} $\ShareOk(\A,k) \coloneqq \read{\WireOk(k)}$ for $k < K$}
\item {\color{teal} $\ShareOk(\B,k) \coloneqq \read{\WireOk(k)}$ for $k < K$}
\end{itemize}

\noindent In the presence of the channels $\InShareOk(\A,\A,-)$, $\InShareOk(\A,\B,-)$, $\InShareOk(\B,\A,-)$, $\InShareOk(\B,\B,-)$ and the protocol $\Shares(C,K)$ we can define the protocol $\SharesOk(C,K)$ equivalently as follows:

\begin{itemize}
\item $\SharesOk(\epsilon,0)$ is the protocol $\zero$

\item $\SharesOk\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\item {\color{teal} $\ShareOk(\A,K) \coloneqq \read{\InShareOk(\A,\A,i)}$}
\item {\color{teal} $\ShareOk(\B,K) \coloneqq \read{\InShareOk(\B,\A,i)}$}
\end{itemize}

\item $\SharesOk\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\item {\color{teal} $\ShareOk(\A,K) \coloneqq \read{\InShareOk(\A,\B,i)}$}
\item {\color{teal} $\ShareOk(\B,K) \coloneqq \read{\InShareOk(\B,\B,i)}$}
\end{itemize}

\item $\SharesOk\big(C; \, \notgate(k),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\item {\color{teal} $\ShareOk(\A,K) \coloneqq \read{\ShareOk(\A,k)}$}
\item {\color{teal} $\ShareOk(\B,K) \coloneqq \_ \leftarrow \ShareOk(\B,k); \ \ret{\checkmark}$}
\end{itemize}

\item $\SharesOk\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\item {\color{teal} $\ShareOk(\A,K) \coloneqq \_ \leftarrow \ShareOk(\A,k); \ \_ \leftarrow \ShareOk(\A,l); \ \ret{\checkmark}$}
\item {\color{teal} $\ShareOk(\B,K) \coloneqq \_ \leftarrow \ShareOk(\B,k); \ \_ \leftarrow \ShareOk(\B,l); \ \ret{\checkmark}$}
\end{itemize}

\item $\SharesOk\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \_ \leftarrow \ShareOk(\A,k); \ \_ \leftarrow \ShareOk(\A,l); \ \ret{\checkmark}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \_ \leftarrow \SendBitOk(\A,\B,K); \ \_ \leftarrow \ShareOk(\A,k); \ \_ \leftarrow \ShareOk(\A,l); \\ \_ \leftarrow \ShareOk(\B,k); \ \_ \leftarrow \ShareOk(\B,l); \ \ret{\checkmark}$}
\item {\color{teal} $\ShareOk(\A,K) \coloneqq \_ \leftarrow \SendBitOk(\A,\B,K); \ \_ \leftarrow \ShareOk(\A,k); \ \_ \leftarrow \ShareOk(\A,l); \ \ret{\checkmark}$}
\item {\color{teal} $\ShareOk(\B,K) \coloneqq \_ \leftarrow \RcvdBitOk(\A,\B,K); \ \_ \leftarrow \ShareOk(\B,k); \ \_ \leftarrow \ShareOk(\B,l); \ \ret{\checkmark}$}
\end{itemize}
\end{itemize}

\noindent We also observe that in the presence of the protocol $\Init$ we can define the protocol $\InitOk$ equivalently as follows:

\begin{itemize}
\item {\color{teal} $\InShareGenOk(\A,\A,i) \coloneqq \_ \leftarrow \InOk(\A,i); \ \ret{\checkmark}$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\A,\B,i) \coloneqq \_ \leftarrow \InOk(\B,i); \ \ret{\checkmark}$ for $i < M$}
\item {\color{teal} $\InShareGenOk(\B,\A,i) \coloneqq \_ \leftarrow \InOk(\A,i); \ \_ \leftarrow \InShareGenOk(\A,\A,i); \ \ret{\checkmark}$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\B,\B,i) \coloneqq \_ \leftarrow \InOk(\B,i); \ \_ \leftarrow \InShareGenOk(\A,\B,i); \ \ret{\checkmark}$ for $i < M$}
\item {\color{teal} $\InShareOk(\A,\A,i) \coloneqq \read{\InShareGenOk(\A,\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareOk(\A,\B,i) \coloneqq \read{\InShareGenOk(\A,\B,i)}$ for $i < M$}
\item {\color{teal} $\InShareOk(\B,\A,i) \coloneqq \read{\InShareGenOk(\B,\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareOk(\B,\B,i) \coloneqq \read{\InShareGenOk(\B,\B,i)}$ for $i < M$}
\end{itemize}

\noindent Furthermore, in the presence of the channels $\InOk(\A,-)$, $\InOk(\B,-)$ we can express the protocol $\InitOk$ equivalently as follows:

\begin{itemize}
\item {\color{teal} $\InShareGenOk(\A,\A,i) \coloneqq \read{\InOk(\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\A,\B,i) \coloneqq \read{\InOk(\B,i)}$ for $i < M$}
\item {\color{teal} $\InShareGenOk(\B,\A,i) \coloneqq \read{\InOk(\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\B,\B,i) \coloneqq \read{\InOk(\B,i)}$ for $i < M$}
\item {\color{teal} $\InShareOk(\A,\A,i) \coloneqq \read{\InOk(\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareOk(\A,\B,i) \coloneqq \read{\InOk(\B,i)}$ for $i < M$}
\item {\color{teal} $\InShareOk(\B,\A,i) \coloneqq \read{\InOk(\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareOk(\B,\B,i) \coloneqq \read{\InOk(\B,i)}$ for $i < M$}
\end{itemize}

\noindent Lastly, in the presence of the channels $\InShareOk(\A,\A,-)$, $\InShareOk(\A,\B,-)$, $\InShareOk(\B,\A,-)$, $\InShareOk(\B,\B,-)$ as well as the protocol $\WiresOk(C,K)$ we can express the protocol $\SharesOk(C,K)$ equivalently as the channels
\begin{itemize}
\item {\color{teal} $\ShareOk(\A,k) \coloneqq \read{\WireOk(k)}$ for $k < K$}
\item {\color{teal} $\ShareOk(\B,k) \coloneqq \read{\WireOk(k)}$ for $k < K$}
\end{itemize}
together with the following protocol $\SendRcvdBitsOk(C,K)$:

\begin{itemize}
\item $\SendRcvdBitsOk(\epsilon,0)$ is the protocol $\zero$

\item $\SendRcvdBitsOk\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\SendRcvdBitsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\end{itemize}

\item $\SendRcvdBitsOk\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\SendRcvdBitsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\end{itemize}

\item $\SendRcvdBitsOk\big(C; \, \notgate(k),K+1\big)$ is the composition of $\SendRcvdBitsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\end{itemize}

\item $\SendRcvdBitsOk\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\SendRcvdBitsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\end{itemize}

\item $\SendRcvdBitsOk\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\SendRcvdBitsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$}
\end{itemize}
\end{itemize}

\noindent We now revisit the case of an \emph{and} gate in the protocol $\Adv(C,K)$. We can write the channels
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\ShareOk(\B,k)}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\ShareOk(\B,l)}$}
\end{itemize}
equivalently as follows:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\WireOk(k)}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\WireOk(l)}$}
\end{itemize}
So the inductive part of the real protocol now has $\Adv(C,K)$ looking like so:

\begin{itemize}
\item $\Adv(\epsilon,0)$ is the protocol $\zero$

\item $\Adv\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\SendBit(\A,\B,K)}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus y_A}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A \oplus y_A}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\WireOk(k)}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\WireOk(l)}$}
\end{itemize}
\end{itemize}

\noindent In the presence of the channels $\InShareOk(\A,\A,-)$, $\InShareOk(\A,\B,-)$, $\InShareOk(\B,\A,-)$, $\InShareOk(\B,\B,-)$ and the channels $\ShareOk(\A,-)$, $\ShareOk(\B,-)$ as well as the protocols $\WiresOk$ and $\SharesOk$ we can express the protocol $\Shares(C,K)$ equivalently as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\A,i)}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \WireOk(K); \ \read{\InShare(\B,\A,i)}$
\end{itemize}

\item $\Shares\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\B,i)}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \WireOk(K); \ \read{\InShare(\B,\B,i)}$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\Share(\A,k)}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \WireOk(K); \ x_B \leftarrow \Share(\B,k); \ \ret{\neg x_B}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{x_A \oplus y_A}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \WireOk(K); \ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_B \oplus y_B}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \samp{\flip}$
\item $\RcvdBit(\B,\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_A \oplus (x_A * y_B) \oplus (x_B * y_A)}$
\item $\Share(\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{(x_A * y_A) \oplus b_A}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \WireOk(K); \ b_B \leftarrow \RcvdBit(\B,\A,K); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_B \oplus (x_B * y_B)}$
\end{itemize}
\end{itemize}

\subsubsection{Timing of Shares II}\label{sect:gmw_timing_2}
We now revisit the real protocol in the form we had at the beginning of Section \ref{sect:gmw_timing_1}. We first consider the protocol $\Adv(C,K)$ in the case of an \emph{and} gate. We want to write the channels
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq x_B \leftarrow \Share(\B,k); \ \ret{\checkmark}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq y_B \leftarrow \Share(\B,l); \ \ret{\checkmark}$}
\end{itemize}
in the form below:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ \ret{\checkmark}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq x_A \leftarrow \Share(\A,l); \ \ret{\checkmark}$}
\end{itemize}
So the inductive part of the real protocol now has $\Adv(C,K)$ looking like so:

\begin{itemize}
\item $\Adv(\epsilon,0)$ is the protocol $\zero$

\item $\Adv\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\SendBit(\A,\B,K)}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus y_A}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A \oplus y_A}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ \ret{\checkmark}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq x_A \leftarrow \Share(\A,l); \ \ret{\checkmark}$}
\end{itemize}
\end{itemize}

\noindent We now amend Bob's shares with a gratuitous dependency on Alice's shares. Specifically, we modify the protocol $\Shares(C,K)$ as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\A,i)}$
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ \read{\InShare(\B,\A,i)}$
\end{itemize}

\item $\Shares\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\B,i)}$
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ \read{\InShare(\B,\B,i)}$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\Share(\A,k)}$
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,k); \ \ret{\neg x_B}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{x_A \oplus y_A}$
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_B \oplus y_B}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \samp{\flip}$
\item $\RcvdBit(\B,\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_A \oplus (x_A * y_B) \oplus (x_B * y_A)}$
\item $\Share(\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{(x_A * y_A) \oplus b_A}$
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ b_B \leftarrow \RcvdBit(\B,\A,K); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_B \oplus (x_B * y_B)}$
\end{itemize}
\end{itemize}

\noindent It is not at all clear that the aforementioned amendments of $\Adv(C,K)$ and $\Shares(C,K)$ are sound. In the rest of this section we justify their soundness.\medskip

\noindent We start by introducing the channels
\begin{itemize}
\item {\color{teal} $\InShareOk(\A,\A,i) \coloneqq \_ \leftarrow \InShare(\A,\A,i); \ \ret{\checkmark}$ for $i < N$}
\item {\color{teal} $\InShareOk(\A,\B,i) \coloneqq \_ \leftarrow \InShare(\A,\B,i); \ \ret{\checkmark}$ for $i < M$}
\item {\color{teal} $\InShareOk(\B,\A,i) \coloneqq \_ \leftarrow \InShare(\B,\A,i); \ \ret{\checkmark}$ for $i < N$}
\item {\color{teal} $\InShareOk(\B,\B,i) \coloneqq \_ \leftarrow \InShare(\B,\B,i); \ \ret{\checkmark}$ for $i < M$}
\end{itemize}
for the timing of input shares in the initial part of the protocol and
\begin{itemize}
\item {\color{teal} $\ShareOk(\A,k) \coloneqq \_ \leftarrow \Share(\A,k); \ \ret{\checkmark}$ for $k < K$}
\item {\color{teal} $\ShareOk(\B,k) \coloneqq \_ \leftarrow \Share(\B,k); \ \ret{\checkmark}$ for $k < K$}
\end{itemize}
for the timing of shares in the inductive part of the protocol.\medskip

\noindent Take the protocol $\Adv(C,K)$ in the case of an \emph{and} gate. We can write the channels
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq x_B \leftarrow \Share(\B,k); \ \ret{\checkmark}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq y_B \leftarrow \Share(\B,l); \ \ret{\checkmark}$}
\end{itemize}
equivalently as follows:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\ShareOk(\A,k)}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\ShareOk(\A,l)}$}
\end{itemize}
So the inductive part of the real protocol now has $\Adv(C,K)$ looking like so:

\begin{itemize}
\item $\Adv(\epsilon,0)$ is the protocol $\zero$

\item $\Adv\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\SendBit(\A,\B,K)}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus y_A}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A \oplus y_A}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\ShareOk(\A,k)}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\ShareOk(\A,l)}$}
\end{itemize}
\end{itemize}

We now amend Bob's shares further: in the presence of the channels $\ShareOk(\A,-)$ we can turn the gratuitous dependency on Alice's shares into a dependency on the corresponding timing channel. Specifically, we can express the protocol $\Shares(C,K)$ equivalently as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\A,i)}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \ShareOk(\A,K); \ \read{\InShare(\B,\A,i)}$
\end{itemize}

\item $\Shares\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\B,i)}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \ShareOk(\A,K); \ \read{\InShare(\B,\B,i)}$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\Share(\A,k)}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \ShareOk(\A,K); \ x_B \leftarrow \Share(\B,k); \ \ret{\neg x_B}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{x_A \oplus y_A}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \ShareOk(\A,K); \ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_B \oplus y_B}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \samp{\flip}$
\item $\RcvdBit(\B,\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_A \oplus (x_A * y_B) \oplus (x_B * y_A)}$
\item $\Share(\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{(x_A * y_A) \oplus b_A}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \ShareOk(\A,K); \ b_B \leftarrow \RcvdBit(\B,\A,K); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_B \oplus (x_B * y_B)}$
\end{itemize}
\end{itemize}

\noindent We now carry out largely the same steps as before to make the timing of shares independent of their value. To this end, we introduce new internal channels
\begin{itemize}
\item {\color{teal} $\InOk(\A,i) \coloneqq \_ \leftarrow \read{\In(\A,i)}; \ \ret{\checkmark}$ for $i < N$}
\item {\color{teal} $\InOk(\B,i) \coloneqq \_ \leftarrow \read{\In(\B,i)}; \ \ret{\checkmark}$ for $i < M$}
\end{itemize}
to keep track of whether an input has arrived, and a new protocol $\WiresOk(C,K)$ that keeps track of the timing of wire shares:

\begin{itemize}
\item $\WiresOk(\epsilon,0)$ is the protocol $\zero$
\item $\WiresOk\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \read{\InOk(\A,i)}$}
\end{itemize}
\item $\WiresOk\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \read{\InOk(\B,i)}$}
\end{itemize}
\item $\WiresOk\big(C; \, \notgate(k),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \_ \leftarrow \WireOk(k); \ \ret{\checkmark}$}
\end{itemize}
\item $\WiresOk\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$}
\end{itemize}
\item $\WiresOk\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$}
\end{itemize}
\end{itemize}

\noindent Our goal is again to show that the timing channels can be equivalently characterized as follows:
\begin{itemize}
\item {\color{teal} $\InShareOk(\A,\A,i) \coloneqq \read{\InOk(\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareOk(\A,\B,i) \coloneqq \read{\InOk(\B,i)}$ for $i < M$}
\item {\color{teal} $\InShareOk(\B,\A,i) \coloneqq \read{\InOk(\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareOk(\B,\B,i) \coloneqq \read{\InOk(\B,i)}$ for $i < M$}
\item {\color{teal} $\ShareOk(\A,k) \coloneqq \read{\WireOk(k)}$ for $k < K$}
\item {\color{teal} $\ShareOk(\B,k) \coloneqq \read{\WireOk(k)}$ for $k < K$}
\end{itemize}
To this end, we introduce new internal channels
\begin{itemize}
\item {\color{teal} $\InShareGenOk(\A,\A,i)$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\A,\B,i)$ for $i < M$}
\item {\color{teal} $\InShareGenOk(\B,\A,i)$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\B,\B,i)$ for $i < M$}
\end{itemize}
to keep track of the timing information in the protocol $\Init$ and
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,k)$ for $k < K$}
\item {\color{teal} $\RcvdBitOk(\A,\B,k)$ for $k < K$}
\end{itemize}
to keep track of the timing information in the protocol $\Circ(C,K)$. Call the following protocol fragment $\InitOk$:
\begin{itemize}
\item {\color{teal} $\InShareGenOk(\A,\A,i)$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\A,\B,i)$ for $i < M$}
\item {\color{teal} $\InShareGenOk(\B,\A,i)$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\B,\B,i)$ for $i < M$}
\item {\color{teal} $\InShareOk(\A,\A,i) \coloneqq \_ \leftarrow \InShare(\A,\A,i); \ \ret{\checkmark}$ for $i < N$}
\item {\color{teal} $\InShareOk(\A,\B,i) \coloneqq \_ \leftarrow \InShare(\A,\B,i); \ \ret{\checkmark}$ for $i < M$}
\item {\color{teal} $\InShareOk(\B,\A,i) \coloneqq \_ \leftarrow \InShare(\B,\A,i); \ \ret{\checkmark}$ for $i < N$}
\item {\color{teal} $\InShareOk(\B,\B,i) \coloneqq \_ \leftarrow \InShare(\B,\B,i); \ \ret{\checkmark}$ for $i < M$}
\end{itemize}
Call the following protocol fragment $\SharesOk(C,K)$:
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,k)$ for $k < K$}
\item {\color{teal} $\RcvdBitOk(\A,\B,k)$ for $k < K$}
\item {\color{teal} $\ShareOk(\A,k) \coloneqq \_ \leftarrow \Share(\A,k); \ \ret{\checkmark}$ for $k < K$}
\item {\color{teal} $\ShareOk(\B,k) \coloneqq \_ \leftarrow \Share(\B,k); \ \ret{\checkmark}$ for $k < K$}
\end{itemize}

\noindent In the presence of the channels $\InShareOk(\A,\A,-)$, $\InShareOk(\A,\B,-)$, $\InShareOk(\B,\A,-)$, $\InShareOk(\B,\B,-)$ as well as the protocol $\Shares(C,K)$ we can define the protocol $\SharesOk(C,K)$ equivalently as follows:

\begin{itemize}
\item $\SharesOk(\epsilon,0)$ is the protocol $\zero$

\item $\SharesOk\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\item {\color{teal} $\ShareOk(\A,K) \coloneqq \read{\InShareOk(\A,\A,i)}$}
\item {\color{teal} $\ShareOk(\B,K) \coloneqq \_ \leftarrow \ShareOk(\A,K); \ \read{\InShareOk(\B,\A,i)}$}
\end{itemize}

\item $\SharesOk\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\item {\color{teal} $\ShareOk(\A,K) \coloneqq \read{\InShareOk(\A,\B,i)}$}
\item {\color{teal} $\ShareOk(\B,K) \coloneqq \_ \leftarrow \ShareOk(\A,K); \ \read{\InShareOk(\B,\B,i)}$}
\end{itemize}

\item $\SharesOk\big(C; \, \notgate(k),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\item {\color{teal} $\ShareOk(\A,K) \coloneqq \read{\ShareOk(\A,k)}$}
\item {\color{teal} $\ShareOk(\B,K) \coloneqq \_ \leftarrow \ShareOk(\A,K); \ \_ \leftarrow \ShareOk(\B,k); \ \ret{\checkmark}$}
\end{itemize}

\item $\SharesOk\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\item {\color{teal} $\ShareOk(\A,K) \coloneqq \_ \leftarrow \ShareOk(\A,k); \ \_ \leftarrow \ShareOk(\A,l); \ \ret{\checkmark}$}
\item {\color{teal} $\ShareOk(\B,K) \coloneqq \_ \leftarrow \ShareOk(\A,K); \ \_ \leftarrow \ShareOk(\B,k); \ \_ \leftarrow \ShareOk(\B,l); \ \ret{\checkmark}$}
\end{itemize}

\item $\SharesOk\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \_ \leftarrow \ShareOk(\A,k); \ \_ \leftarrow \ShareOk(\A,l); \ \ret{\checkmark}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \_ \leftarrow \SendBitOk(\A,\B,K); \ \_ \leftarrow \ShareOk(\A,k); \ \_ \leftarrow \ShareOk(\A,l); \\ \_ \leftarrow \ShareOk(\B,k); \ \_ \leftarrow \ShareOk(\B,l); \ \ret{\checkmark}$}
\item {\color{teal} $\ShareOk(\A,K) \coloneqq \_ \leftarrow \SendBitOk(\A,\B,K); \ \_ \leftarrow \ShareOk(\A,k); \ \_ \leftarrow \ShareOk(\A,l); \ \ret{\checkmark}$}
\item {\color{teal} $\ShareOk(\B,K) \coloneqq \_ \leftarrow \ShareOk(\A,K); \ \_ \leftarrow \RcvdBitOk(\A,\B,K); \\ \_ \leftarrow \ShareOk(\B,k); \ \_ \leftarrow \ShareOk(\B,l); \ \ret{\checkmark}$}
\end{itemize}
\end{itemize}

\noindent We also observe that in the presence of the protocol $\Init$ we can define the protocol $\InitOk$ equivalently as follows:

\begin{itemize}
\item {\color{teal} $\InShareGenOk(\A,\A,i) \coloneqq \_ \leftarrow \InOk(\A,i); \ \ret{\checkmark}$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\A,\B,i) \coloneqq \_ \leftarrow \InOk(\B,i); \ \ret{\checkmark}$ for $i < M$}
\item {\color{teal} $\InShareGenOk(\B,\A,i) \coloneqq \_ \leftarrow \InOk(\A,i); \ \_ \leftarrow \InShareGenOk(\A,\A,i); \ \ret{\checkmark}$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\B,\B,i) \coloneqq \_ \leftarrow \InOk(\B,i); \ \_ \leftarrow \InShareGenOk(\A,\B,i); \ \ret{\checkmark}$ for $i < M$}
\item {\color{teal} $\InShareOk(\A,\A,i) \coloneqq \read{\InShareGenOk(\A,\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareOk(\A,\B,i) \coloneqq \read{\InShareGenOk(\A,\B,i)}$ for $i < M$}
\item {\color{teal} $\InShareOk(\B,\A,i) \coloneqq \read{\InShareGenOk(\B,\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareOk(\B,\B,i) \coloneqq \read{\InShareGenOk(\B,\B,i)}$ for $i < M$}
\end{itemize}

\noindent Furthermore, in the presence of the channels $\InOk(\A,-)$, $\InOk(\B,-)$ we can express the protocol $\InitOk$ equivalently as follows:

\begin{itemize}
\item {\color{teal} $\InShareGenOk(\A,\A,i) \coloneqq \read{\InOk(\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\A,\B,i) \coloneqq \read{\InOk(\B,i)}$ for $i < M$}
\item {\color{teal} $\InShareGenOk(\B,\A,i) \coloneqq \read{\InOk(\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareGenOk(\B,\B,i) \coloneqq \read{\InOk(\B,i)}$ for $i < M$}
\item {\color{teal} $\InShareOk(\A,\A,i) \coloneqq \read{\InOk(\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareOk(\A,\B,i) \coloneqq \read{\InOk(\B,i)}$ for $i < M$}
\item {\color{teal} $\InShareOk(\B,\A,i) \coloneqq \read{\InOk(\A,i)}$ for $i < N$}
\item {\color{teal} $\InShareOk(\B,\B,i) \coloneqq \read{\InOk(\B,i)}$ for $i < M$}
\end{itemize}

\noindent In the presence of the channels $\InShareOk(\A,\A,-)$, $\InShareOk(\A,\B,-)$, $\InShareOk(\B,\A,-)$, $\InShareOk(\B,\B,-)$ as well as the protocol $\WiresOk(C,K)$ we can define the protocol $\SharesOk(C,K)$ equivalently as the channels
\begin{itemize}
\item {\color{teal} $\ShareOk(\A,k) \coloneqq \read{\WireOk(k)}$ for $k < K$}
\item {\color{teal} $\ShareOk(\B,k) \coloneqq \read{\WireOk(k)}$ for $k < K$}
\end{itemize}
together with the following protocol $\SendRcvdBitsOk(C,K)$:

\begin{itemize}
\item $\SendRcvdBitsOk(\epsilon,0)$ is the protocol $\zero$

\item $\SendRcvdBitsOk\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\SendRcvdBitsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\end{itemize}

\item $\SendRcvdBitsOk\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\SendRcvdBitsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\end{itemize}

\item $\SendRcvdBitsOk\big(C; \, \notgate(k),K+1\big)$ is the composition of $\SendRcvdBitsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\end{itemize}

\item $\SendRcvdBitsOk\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\SendRcvdBitsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \read{\SendBitOk(\A,\B,K)}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \read{\RcvdBitOk(\A,\B,K)}$}
\end{itemize}

\item $\SendRcvdBitsOk\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\SendRcvdBitsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(\A,\B,K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$}
\item {\color{teal} $\RcvdBitOk(\A,\B,K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$}
\end{itemize}
\end{itemize}

\noindent We now revisit the case of an \emph{and} gate in the protocol $\Adv(C,K)$. We can write the channels
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\ShareOk(\A,k)}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\ShareOk(\A,l)}$}
\end{itemize}
equivalently as follows:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\WireOk(k)}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\WireOk(l)}$}
\end{itemize}
So the inductive part of the real protocol now has $\Adv(C,K)$ looking like so:

\begin{itemize}
\item $\Adv(\epsilon,0)$ is the protocol $\zero$

\item $\Adv\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Adv\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\SendBit(\A,\B,K)}$}
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus y_A}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A \oplus y_A}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\WireOk(k)}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\WireOk(l)}$}
\end{itemize}
\end{itemize}

\noindent Finally, in the presence of the channels $\ShareOk(\A,-)$ we can characterize the protocol $\Shares(C,K)$ equivalently as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\A,i)}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \WireOk(K); \ \read{\InShare(\B,\A,i)}$
\end{itemize}

\item $\Shares\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\B,i)}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \WireOk(K); \ \read{\InShare(\B,\B,i)}$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\Share(\A,k)}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \WireOk(K); \ x_B \leftarrow \Share(\B,k); \ \ret{\neg x_B}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{x_A \oplus y_A}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \WireOk(K); \ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_B \oplus y_B}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \samp{\flip}$
\item $\RcvdBit(\B,\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_A \oplus (x_A * y_B) \oplus (x_B * y_A)}$
\item $\Share(\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{(x_A * y_A) \oplus b_A}$
\item $\Share(\B,K) \coloneqq \_ \leftarrow \WireOk(K); \ b_B \leftarrow \RcvdBit(\B,\A,K); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_B \oplus (x_B * y_B)}$
\end{itemize}
\end{itemize}

\noindent The resulting real protocol is identical to the form of the real protocol we had at the end of Section \ref{sect:gmw_timing_1}, which justifies the amendments to $\Adv(C,K)$ and $\Shares(C,K)$ we made at the beginning of this section.

\subsubsection{Sum Of Shares}
We continue to simplify the real protocol after amending $\Adv(C,K)$ and $\Shares(C,K)$ as indicated in Section \ref{sect:gmw_timing_2}.\medskip

\noindent We start by adding new internal channels
\begin{itemize}
\item $\SumShare(k) \coloneqq x_A \leftarrow \SumShare(\A,k); \ x_B\leftarrow \Share(\B,k); \ \ret{x_A \oplus x_B}$ for $k < K$
\end{itemize}
that keep track of the sum of shares on each wire $k$.\medskip

\noindent We now revisit the final part of the real protocol. We can express the channels
\begin{itemize}
\item {\color{blue} $\LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\OutShare(\A,\A,k)}$ for $k < K$}
\item {\color{blue} $\LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\OutShare(\A,\B,k)}$ for $k < K$}
\end{itemize}
equivalently as follows:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\Share(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\end{itemize}
We can express the channels
\begin{itemize}
\item $\Out(\A,k) \coloneqq x_A \leftarrow \OutShare(\A,\A,k); \ x_B \leftarrow \OutShare(\A,\B,k); \ \ret{x_A \oplus x_B}$ for $k < K$
\item $\Out(\B,k) \coloneqq x_A \leftarrow \OutShare(\B,\A,k); \ x_B \leftarrow \OutShare(\B,\B,k); \ \ret{x_A \oplus x_B}$ for $k < K$
\end{itemize}
equivalently as follows:
\begin{itemize}
\item $\begin{cases*} \Out(\A,k) \coloneqq x_A \leftarrow \Share(\A,k); \ x_B \leftarrow \Share(\B,k); \ \ret{x_A \oplus x_B} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\A,k) \coloneqq \read{\Out(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\begin{cases*} \Out(\B,k) \coloneqq x_A \leftarrow \Share(\A,k); \ x_B \leftarrow \Share(\B,k); \ \ret{x_A \oplus x_B} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\B,k) \coloneqq \read{\Out(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\end{itemize}
In presence of the channels $\SumShare(-)$ we can express the above equivalently as follows:
\begin{itemize}
\item $\begin{cases*} \Out(\A,k) \coloneqq \read{\SumShare(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\A,k) \coloneqq \read{\Out(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\begin{cases*} \Out(\B,k) \coloneqq \read{\SumShare(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\B,k) \coloneqq \read{\Out(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\end{itemize}
At this point, the internal channels $\OutShare(\A,\A,-)$, $\OutShare(\A,\B,-)$, $\OutShare(\B,\A,-)$, $\OutShare(\B,\B,-)$ are unused and can be eliminated. The simplified version $\Fin$ of the final part of the real protocol is therefore as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\LeakSendOutShare(\B,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\Share(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakRcvdOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\Share(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item $\begin{cases*} \Out(\A,k) \coloneqq \read{\SumShare(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\A,k) \coloneqq \read{\Out(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\begin{cases*} \Out(\B,k) \coloneqq \read{\SumShare(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\B,k) \coloneqq \read{\Out(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item {\color{blue} $\LeakOut(\A,k)^\A_\adv \coloneqq \read{\Out(\A,k)}$ for $k < K$}
\end{itemize}

\noindent We now show that for each wire, the respective shares of the two parties add up to the value carried by the wire. At the same time we express Bob's shares in a closed form, as the sum of Alice's shares plus the value on the wire. We proceed by an induction on circuits: in the presence of the protocol $\Init$ we can express the channels
\begin{itemize}
\item $\SumShare(k) \coloneqq x_A \leftarrow \Share(\A,k); \ x_B \leftarrow \Share(\B,k); \ \ret{x_A \oplus x_B}$ for $k < K$
\end{itemize}
together with the protocol $\Shares(C,K)$ equivalently as the channels
\begin{itemize}
\item $\Share(\B,k) \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \SumShare(k); \ \ret{x_A \oplus x}$ for $k < K$
\end{itemize}
together with the following new form of the protocol $\Shares(C,K)$:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\A,i)}$
\item $\SumShare(K) \coloneqq \In(\A,i)$
\end{itemize}

\item $\Shares\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\B,i)}$
\item $\SumShare(K) \coloneqq \In(\B,i)$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\Share(\A,k)}$
\item $\SumShare(K) \coloneqq x \leftarrow \SumShare(k); \ \ret{\neg x}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{x_A \oplus y_A}$
\item $\SumShare(K) \coloneqq x \leftarrow \SumShare(k); \ y \leftarrow \SumShare(l); \ \ret{x \oplus y}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \samp{\flip}$
\item $\RcvdBit(\B,\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_A \oplus (x_A * y_B) \oplus (x_B * y_A)}$
\item $\Share(\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{(x_A * y_A) \oplus b_A}$
\item $\SumShare(K) \coloneqq x \leftarrow \SumShare(k); \ y \leftarrow \SumShare(l); \ \ret{x * y}$
\end{itemize}
\end{itemize}

\noindent To see why this works, we consider each gate in turn.
\begin{itemize}
\item In the case of an \emph{input} gate for Alice's input, we start by substituting the inductive form of the channel
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ \read{\InShare(\B,\A,i)}$
\end{itemize}
into the closed form of the channel
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,K); \ \ret{x_A \oplus x_B}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \InShare(\B,\A,i); \ \ret{x_A \oplus x_B}$
\end{itemize}
By canceling out two applications of $x_A \oplus -$ we can reformulate the channel $\Share(\B,K)$ as follows:
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \InShare(\B,\A,i); \ \ret{x_A \oplus (x_A \oplus x_B)}$
\end{itemize}
The above can be expressed more concisely as
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ x \leftarrow \SumShare(K); \ \ret{x_A \oplus x}$
\end{itemize}
and this is the desired closed form of the channel $\Share(\B,K)$.

We can now turn our attention to the sum of shares. In the presence of the channel
\begin{itemize}
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\A,i)}$
\end{itemize}
and the channel
\begin{itemize}
\item $\InShare(\A,\A,i) \coloneqq \read{\InShareGen(\A,\A,i)}$
\end{itemize}
from the protocol $\Init$ we can write the channel
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \InShare(\B,\A,i); \ \ret{x_A \oplus x_B}$
\end{itemize}
equivalently as follows:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x_B \leftarrow \InShare(\B,\A,i); \ \ret{x_A \oplus x_B}$
\end{itemize}
In the presence of the channels
\begin{itemize}
\item $\InShare(\B,\A,i) \coloneqq \read{\InShareGen(\B,\A,i)}$ 
\item $\InShareGen(\B,\A,i) \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \In(\A,i); \ \ret{x_A \oplus x}$
\end{itemize}
from the protocol $\Init$ we can further write the channel $\SumShare(K)$ as follows:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \In(\A,i); \ \ret{x_A \oplus (x_A \oplus x)}$
\end{itemize}
We can cancel out the two applications of $x_A \oplus -$:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ \read{\In(\A,i)}$
\end{itemize}
This is almost what we want except for the extra dependency on the channel $\InShareGen(\A,\A,i)$. But it is easy to see that this dependency can be dropped because the channel
\begin{itemize}
\item $\InShareGen(\A,\A,i) \coloneqq x \leftarrow \In(\A,i); \ \samp{\flip}$
\end{itemize}
only reads from the channel $\In(\A,i)$, which $\SumShare(K)$ reads from as well:\begin{itemize}
\item $\SumShare(K) \coloneqq \read{\In(\A,i)}$
\end{itemize}
But this is precisely the desired inductive form of the channel $\SumShare(K)$.

\item In the case of an \emph{input} gate for Bob's input, we start by substituting the inductive form of the channel
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ \read{\InShare(\B,\B,i)}$
\end{itemize}
into the closed form of the channel
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,K); \ \ret{x_A \oplus x_B}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \InShare(\B,\B,i); \ \ret{x_A \oplus x_B}$
\end{itemize}
By canceling out two applications of $x_A \oplus -$ we can reformulate the channel $\Share(\B,K)$ as follows:
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \InShare(\B,\B,i); \ \ret{x_A \oplus (x_A \oplus x_B)}$
\end{itemize}
The above can be expressed more concisely as
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ x \leftarrow \SumShare(K); \ \ret{x_A \oplus x}$
\end{itemize}
and this is the desired closed form of the channel $\Share(\B,K)$.

We can now turn our attention to the sum of shares. In the presence of the channel
\begin{itemize}
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\B,i)}$
\end{itemize}
and the channel
\begin{itemize}
\item $\InShare(\A,\B,i) \coloneqq \read{\InShareGen(\A,\B,i)}$
\end{itemize}
from the protocol $\Init$ we can write the channel
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \InShare(\B,\B,i); \ \ret{x_A \oplus x_B}$
\end{itemize}
equivalently as follows:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \InShareGen(\A,\B,i); \ x_B \leftarrow \InShare(\B,\B,i); \ \ret{x_A \oplus x_B}$
\end{itemize}
In the presence of the channels
\begin{itemize}
\item $\InShare(\B,\B,i) \coloneqq \read{\InShareGen(\B,\B,i)}$ 
\item $\InShareGen(\B,\B,i) \coloneqq x_A \leftarrow \InShareGen(\A,\B,i); \ x \leftarrow \In(\B,i); \ \ret{x_A \oplus x}$
\end{itemize}
from the protocol $\Init$ we can further write the channel $\SumShare(K)$ as follows:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \InShareGen(\A,\B,i); \ x \leftarrow \In(\B,i); \ \ret{x_A \oplus (x_A \oplus x)}$
\end{itemize}
We can cancel out the two applications of $x_A \oplus -$:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \InShareGen(\A,\B,i); \ \read{\In(\B,i)}$
\end{itemize}
This is almost what we want except for the extra dependency on the channel $\InShareGen(\A,\B,i)$. But it is easy to see that this dependency can be dropped because the channel
\begin{itemize}
\item $\InShareGen(\A,\B,i) \coloneqq x \leftarrow \In(\B,i); \ \samp{\flip}$
\end{itemize}
only reads from the channel $\In(\B,i)$, which $\SumShare(K)$ reads from as well: \begin{itemize}
\item $\SumShare(K) \coloneqq \read{\In(\B,i)}$
\end{itemize}
But this is precisely the desired inductive form of the channel $\SumShare(K)$.

\item In the case of a \emph{not} gate, we start by substituting the inductive form of the channel
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,k); \ \ret{\neg x_B}$
\end{itemize}
into the closed form of the channel
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,K); \ \ret{x_A \oplus x_B}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,k); \ \ret{x_A \oplus (\neg x_B)}$
\end{itemize}
By canceling out two applications of $x_A \oplus -$ we can reformulate the channel $\Share(\B,K)$ as follows:
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,k); \ \ret{x_\Sigma \oplus (x_\Sigma \oplus (\neg x_B))}$
\end{itemize}
The above can be expressed more concisely as
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ x \leftarrow \SumShare(K); \ \ret{x_A \oplus x}$
\end{itemize}
and this is the desired closed form of the channel $\Share(\B,K)$.

We can now turn our attention to the sum of shares. Substituting the channel
\begin{itemize}
\item $\Share(\A,K) \coloneqq \read{\Share(\A,k)}$
\end{itemize}
into the channel
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,k); \ \ret{x_A \oplus (\neg x_B)}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,k); \ x_B \leftarrow \Share(\B,k); \ \ret{x_A \oplus (\neg x_B)}$
\end{itemize}
The negation can be brought to the top level:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,k); \ x_B \leftarrow \Share(\B,k); \ \ret{\neg (x_A \oplus x_B)}$
\end{itemize}
But this is precisely what we get if we substitute the closed form of the channel
\begin{itemize}
\item $\SumShare(k) \coloneqq x_A \leftarrow \Share(\A,k); \ x_B \leftarrow \Share(\B,k); \ \ret{x_A \oplus x_B}$
\end{itemize}
into the desired inductive form of the channel
\begin{itemize}
\item $\SumShare(K) \coloneqq x \leftarrow \SumShare(k); \ \ret{\neg x}$
\end{itemize}
so we are done.

\item In the case of an \emph{xor} gate, we start by substituting the inductive form of the channel
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_B \oplus y_B}$
\end{itemize}
into the closed form of the channel
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,K); \ \ret{x_A \oplus x_B}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\SumShare(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_A \oplus (x_B \oplus y_B)}$
\end{itemize}
By canceling out two applications of $x_A \oplus -$ we can reformulate the channel $\Share(B,K)$ as follows:
\begin{itemize}
\item $\Share(B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_A \oplus \big(x_A \oplus (x_A \oplus y_B)\big)}$
\end{itemize}
The above can be expressed more concisely as
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ x \leftarrow \SumShare(K); \ \ret{x_A \oplus x}$
\end{itemize}
and this is the desired closed form of the channel $\Share(\B,K)$.

We can now turn our attention to the sum of shares. Substituting the channel
\begin{itemize}
\item $\Share(\A,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{x_A \oplus y_A}$
\end{itemize}
into the channel
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_A \oplus (x_B \oplus y_B)}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{(x_A \oplus y_A) \oplus (x_B \oplus y_B)}$
\end{itemize}
After a slight rearrangement we get the following:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,k); \ x_B \leftarrow \Share(\B,k); \\ y_A \leftarrow \Share(\A,l); \ y_B \leftarrow \Share(\B,l); \ \ret{(x_A \oplus x_B) \oplus (y_A \oplus y_B)}$
\end{itemize}
But this is precisely what we get if we substitute the channels
\begin{itemize}
\item $\SumShare(k) \coloneqq x_A \leftarrow \Share(\A,k); \ x_B \leftarrow \Share(\B,k); \ \ret{x_A \oplus x_B}$
\item $\SumShare(l) \coloneqq y_A \leftarrow \Share(\A,l); \ y_B \leftarrow \Share(\B,l); \ \ret{y_A \oplus y_B}$
\end{itemize}
into the desired inductive form of the channel
\begin{itemize}
\item $\SumShare(K) \coloneqq x \leftarrow \SumShare(k); \ y \leftarrow \SumShare(l); \ \ret{x \oplus y}$
\end{itemize}
so we are done.

\item In the case of an \emph{and} gate, we start by substituting the inductive form of the channel
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ b_B \leftarrow \RcvdBit(\B,\A,K); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_B \oplus (x_B * y_B)}$
\end{itemize}
into the closed form of the channel
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,K); \ x_B \leftarrow \Share(\B,K); \ \ret{x_A \oplus x_B}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,K); \ b_B \leftarrow \RcvdBit(\B,\A,K); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_A \oplus (b_B \oplus (x_B * y_B))}$
\end{itemize}
By canceling out two applications of $x_A \oplus -$ we can reformulate the channel $\Share(\B,K)$ as follows:
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_A \leftarrow \Share(\A,K); \ b_B \leftarrow \RcvdBit(\B,\A,K); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_A \oplus \big(x_A \oplus (b_B \oplus (x_B * y_B))\big)}$
\end{itemize}
The above can be expressed more concisely as
\begin{itemize}
\item $\Share(\B,K) \coloneqq x_A\leftarrow \SumShare(\A,K); \ x \leftarrow \SumShare(K); \ \ret{x_A \oplus x}$
\end{itemize}
and this is the desired closed form of the channel $\Share(\B,K)$.

We can now turn our attention to the sum of shares. Substituting the channels
\begin{itemize}
\item $\Share(\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{(x_A * y_A) \oplus b_A}$
\item $\RcvdBit(\B,\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_A \oplus (x_A * y_B) \oplus (x_B * y_A)}$
\end{itemize}
into the channel
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,K); \ b_B \leftarrow \RcvdBit(\B,\A,K); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{x_A \oplus (b_B \oplus (x_B * y_B))}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumShare(K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ x_B \leftarrow \Share(\B,k); \\ y_B \leftarrow \Share(\B,l); \ \ret{\big((x_A * y_A) \oplus b_A\big) \oplus \big(\big(b_A \oplus (x_A * y_B) \oplus (x_B * y_A)\big) \oplus (x_B * y_B)\big)}$
\end{itemize}
After a slight rearrangement we get the following:
\begin{itemize}
\item $\SumShare(K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ x_B \leftarrow \Share(\B,k); \\ y_B \leftarrow \Share(\B,l); \ \ret{(x_A * y_A) \oplus \big(b_A \oplus \big(b_A \oplus (x_A * y_B) \oplus (x_B * y_A)\big)\big) \oplus (x_B * y_B)}$
\end{itemize}
Canceling out the two applications of $b_A \oplus -$ yields the following:
\begin{itemize}
\item $\SumShare(K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{(x_A * y_A) \oplus (x_A * y_B) \oplus (x_B * y_A) \oplus (x_B * y_B)}$
\end{itemize}
We can drop the dependency on the unused channel
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \samp{\flip}$
\end{itemize}
because it only reads from the channels $\Share(\A,k)$ and $\Share(\A,l)$, which $\SumShare(K)$ reads from as well:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ x_B \leftarrow \Share(\B,k); \\ y_B \leftarrow \Share(\B,l); \ \ret{(x_A * y_A) \oplus (x_A * y_B) \oplus (x_B * y_A) \oplus (x_B * y_B)}$
\end{itemize}
After a slight rearrangement we get the following:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,k); \ x_B \leftarrow \Share(\B,k); \ y_A \leftarrow \Share(\A,l); \\ y_B \leftarrow \Share(\B,l); \ \ret{(x_A * y_A) \oplus (x_A * y_B) \oplus (x_B * y_A) \oplus (x_B * y_B)}$
\end{itemize}
The above is equivalent to the following:
\begin{itemize}
\item $\SumShare(K) \coloneqq x_A \leftarrow \Share(\A,k); \ x_B \leftarrow \Share(\B,k); \\ y_A \leftarrow \Share(\A,l); \ y_B \leftarrow \Share(\B,l); \ \ret{(x_A \oplus x_B) * (y_A \oplus y_B)}$
\end{itemize}
But this is precisely what we get if we substitute the channels
\begin{itemize}
\item $\SumShare(k) \coloneqq x_A \leftarrow \Share(\A,k); \ x_B \leftarrow \Share(B,k); \ \ret{x_A \oplus x_B}$
\item $\SumShare(l) \coloneqq y_A \leftarrow \Share(A,l); \ y_B \leftarrow \Share(B,l); \ \ret{y_A \oplus y_B}$
\end{itemize}
into the desired inductive form of the channel
\begin{itemize}
\item $\SumShare(k) \coloneqq x \leftarrow \Share(k); \ y \leftarrow \Share(l); \ \ret{x * y}$
\end{itemize}
so we are done.
\end{itemize}

We have now shown that summing up Alice's and Bob's respective shares $x_A \oplus x_B$ on a given wire yields the actual value $x$ carried by the wire. Currently the computation is performed by the channels $\SumShare(-)$ but we can extract it out into a separate protocol $\Wires(C,K)$ as defined in the ideal functionality. Specifically, we introduce new internal channels
\begin{itemize}
\item $\Wire(k) \coloneqq \read{\SumShare(k)}$ for $k < K$
\end{itemize}
and observe that together with the protocol $\Shares(C,K)$ we can express them equivalently as the channels
\begin{itemize}
\item $\SumShare(k) \coloneqq \read{\Wire(k)}$ for $k < K$
\end{itemize}
together with the aforementioned protocol $\Wires(C,K)$ and the following new form of the protocol $\Shares(C,K)$:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\A,i)}$
\end{itemize}

\item $\Shares\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\B,i)}$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq \read{\Share(\A,k)}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\item $\Share(\A,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{x_A \oplus y_A}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \samp{\flip}$
\item $\RcvdBit(\B,\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_A \oplus (x_A * y_B) \oplus (x_B * y_A)}$
\item $\Share(\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{(x_A * y_A) \oplus b_A}$
\end{itemize}
\end{itemize}

\subsubsection{Eliminating Bob's Shares}\label{sect:gmw_eliminating_shares}
We begin by eliminating the channels $\InShareGen(\B,\A,-)$, $\InShareGen(\B,\B,-)$, $\InShare(\B,\A,-)$, $\InShare(\B,\B,-)$ from the initial part of the protocol. Substituting the channels
\begin{itemize}
\item $\InShareGen(\B,\A,i) \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \In(\A,i); \ \ret{x_A \oplus x}$ for $i < N$
\end{itemize}
into the channels
\begin{itemize}
\item {\color{blue} $\LeakInShareGen(\B,\A,i)^\A_\adv \coloneqq \read{\InShareGen(\B,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakSendInShare(\B,\A,i)^\A_\adv \coloneqq \read{\InShareGen(\B,\A,i)}$ for $i < N$}
\end{itemize}
yields the following:
\begin{itemize}
\item {\color{blue} $\LeakInShareGen(\B,\A,i)^\A_\adv \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \In(\A,i); \ \ret{x_A \oplus x}$ for $i < N$}
\item {\color{blue} $\LeakSendInShare(\B,\A,i)^\A_\adv \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \In(\A,i); \ \ret{x_A \oplus x}$ for $i < N$}
\end{itemize}
Substituting the channels
\begin{itemize}
\item $\InShareGen(\B,\A,i) \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \In(\A,i); \ \ret{x_A \oplus x}$ for $i < N$
\item $\InShareGen(\B,\B,i) \coloneqq x_A \leftarrow \InShareGen(\A,\B,i); \ x \leftarrow \In(\B,i); \ \ret{x_A \oplus x}$ for $i < M$
\end{itemize}
into the channels
\begin{itemize}
\item $\InShare(\B,\A,i) \coloneqq \read{\InShareGen(\B,\A,i)}$ for $i < N$
\item $\InShare(\B,\B,i) \coloneqq \read{\InShareGen(\B,\B,i)}$ for $i < M$
\end{itemize}
yields the following:
\begin{itemize}
\item $\InShare(\B,\A,i) \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \In(\A,i); \ \ret{x_A \oplus x}$ for $i < N$
\item $\InShare(\B,\B,i) \coloneqq x_A \leftarrow \InShareGen(\A,\B,i); \ x \leftarrow \In(\B,i); \ \ret{x_A \oplus x}$ for $i < M$
\end{itemize}
At this point, the internal channels $\InShareGen(\B,\A,-)$, $\InShareGen(\B,\B,-)$ are unused and can be eliminated.\smallskip

\noindent The top-level internal channels $\InShare(\B,\A,-)$, $\InShare(\B,\B,-)$ are unused by the rest of the protocol and can also be eliminated. The resulting version $\Init$ of the initial part of the real protocol is therefore as follows:

\begin{itemize}
\item {\color{blue} $\LeakIn(\A,i)^\A_\adv \coloneqq \read{\In(\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakInRcvd(\B,i)^\B_\adv \coloneqq x \leftarrow \In(\B,i); \ \ret{\checkmark}$ for $i < M$}
\item $\InShareGen(\A,\A,i) \coloneqq x \leftarrow \In(\A,i); \ \samp{\flip}$ for $i < N$
\item $\InShareGen(\A,\B,i) \coloneqq x \leftarrow \In(\B,i); \ \samp{\flip}$ for $i < M$
\item {\color{blue} $\LeakInShareGen(\A,\A,i)^\A_\adv \coloneqq \read{\InShareGen(\A,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakInShareGen(\B,\A,i)^\A_\adv \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \In(\A,i); \ \ret{x_A \oplus x}$ for $i < N$}
\item {\color{blue} $\LeakSendInShare(\B,\A,i)^\A_\adv \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \In(\A,i); \ \ret{x_A \oplus x}$ for $i < N$}
\item {\color{blue} $\LeakRcvdInShare(\A,\B,i)^\A_\adv \coloneqq \read{\InShareGen(\A,\B,i)}$ for $i < M$}
\item $\InShare(\A,\A,i) \coloneqq \read{\InShareGen(\A,\A,i)}$ for $i < N$
\item $\InShare(\A,\B,i) \coloneqq \read{\InShareGen(\A,\B,i)}$ for $i < M$
\item {\color{blue} $\LeakInShare(\A,\A,i)^\A_\adv \coloneqq \read{\InShare(\A,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakInShare(\A,\B,i)^\A_\adv \coloneqq \read{\InShare(\A,\B,i)}$ for $i < M$}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\InShareGen(\A,\A,i)$ for $i < N$,
\item $\InShareGen(\A,\B,i)$ for $i < M$.
\end{itemize}

\noindent We now eliminate the channels $\RcvdBit(\B,\A,-)$, $\Share(\B,-)$ from the inductive part of the real protocol. We can extract the computation of the channels $\RcvdBit(\B,\A,-)$ into a separate protocol $\RcvdBits(C,K)$:

\begin{itemize}
\item $\RcvdBits(\epsilon,0)$ is the protocol $\zero$

\item $\RcvdBits\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\RcvdBits(C,K)$ with the protocol
\begin{itemize}
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\end{itemize}

\item $\RcvdBits\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\RcvdBits(C,K)$ with the protocol
\begin{itemize}
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\end{itemize}

\item $\RcvdBits\big(C; \, \notgate(k),K+1\big)$ is the composition of $\RcvdBits(C,K)$ with the protocol
\begin{itemize}
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\end{itemize}

\item $\RcvdBits\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\RcvdBits(C,K)$ with the protocol
\begin{itemize}
\item $\RcvdBit(\B,\A,K) \coloneqq \read{\RcvdBit(\B,\A,K)}$
\end{itemize}

\item $\RcvdBits\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\RcvdBits(C,K)$ with the protocol
\begin{itemize}
\item $\RcvdBit(\B,\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \\ x_B \leftarrow \Share(\B,k); \ y_B \leftarrow \Share(\B,l); \ \ret{b_A \oplus (x_A * y_B) \oplus (x_B * y_A)}$
\end{itemize}
\end{itemize}

\noindent After the extraction, the protocol $\Shares(C,K)$ is left looking as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\A,i)}$
\end{itemize}

\item $\Shares\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\B,i)}$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\Share(\A,K) \coloneqq \read{\Share(\A,k)}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item $\Share(\A,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{x_A \oplus y_A}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \samp{\flip}$
\item $\Share(\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{(x_A * y_A) \oplus b_A}$
\end{itemize}
\end{itemize}

None of the channels defined by $\RcvdBits(C,K)$ are utilized anywhere outside of $\RcvdBits(C,K)$ and as such we may discard this protocol fragment entirely. This in particular eliminates all references to the channels $\Share(\B,-)$ from the inductive part of the protocol. To summarize, the inductive part of the real protocol now consists of the protocols $\Shares(C,K)$ and $\Adv(C,K)$, followed by the hiding of the channels
\begin{itemize}
\item $\SendBit(\A,\B,k)$ for $k < K$.
\end{itemize}
We recall that on the top level we also have the protocol $\Wires(C,K)$ and the channels below:
\begin{itemize}
\item $\SumShare(k) \coloneqq \read{\Wire(k)}$ for $k < K$
\item $\Share(\B,k) \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \SumShare(k); \ \ret{x_A \oplus x}$ for $k < K$
\end{itemize}

\noindent We now eliminate all references to Bob's shares from the final part of the protocol. If wire $k$ is an output, then the channels
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\Share(\B,k)}$}
\item {\color{blue} $\LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\Share(\B,k)}$}
\end{itemize}
read from the channel
\begin{itemize}
\item $\Share(\B,k) \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \SumShare(k); \ \ret{x_A \oplus x}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \SumShare(k); \ \ret{x_A \oplus x}$}
\item {\color{blue} $\LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \SumShare(k); \ \ret{x_A \oplus x}$}
\end{itemize}
We thus get the following for channels $\LeakRcvdOutShare(\A,\B,-)^\A_\adv$ and $\LeakOutShare(\A,\B,-)^\A_\adv$: 
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \SumShare(k); \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakRcvdOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \SumShare(k); \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\end{itemize}
The top-level internal channels $\Share(\B,-)$ are now unused by the rest of the protocol and can be eliminated. The resulting version $\Fin$ of the final part of the real protocol is as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\LeakSendOutShare(\B,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \SumShare(k); \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakRcvdOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \SumShare(k); \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item $\begin{cases*} \Out(\A,k) \coloneqq \read{\SumShare(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\A,k) \coloneqq \read{\Out(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\begin{cases*} \Out(\B,k) \coloneqq \read{\SumShare(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\B,k) \coloneqq \read{\Out(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item {\color{blue} $\LeakOut(\A,k)^\A_\adv \coloneqq \read{\Out(\A,k)}$ for $k < K$}
\end{itemize}

As a final step before the extraction of the simulator, we eliminate any reference to the channels $\SumShare(-)$ from the final part of the real protocol. If wire $k$ is an output, then we can substitute the channel
\begin{itemize}
\item $\SumShare(k) \coloneqq \read{\Wire(k)}$
\end{itemize}
into the channels
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \SumShare(k); \ \ret{x_A \oplus x}$}
\item {\color{blue} $\LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \SumShare(k); \ \ret{x_A \oplus x}$}
\end{itemize}
which yields the following:
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Wire(k); \ \ret{x_A \oplus x}$}
\item {\color{blue} $\LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Wire(k); \ \ret{x_A \oplus x}$}
\end{itemize}
We thus get the following for channels $\LeakRcvdOutShare(\A,\B,-)^\A_\adv$ and $\LeakOutShare(\A,\B,-)^\A_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Wire(k); \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakRcvdOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Wire(k); \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\end{itemize}
If wire $k$ is an output, then the channels
\begin{itemize}
\item $\Out(\A,k) \coloneqq \read{\SumShare(k)}$
\item $\Out(\B,k) \coloneqq \read{\SumShare(k)}$
\end{itemize}
read from the channel
\begin{itemize}
\item $\SumShare(k) \coloneqq \read{\Wire(k)}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item $\Out(\A,k) \coloneqq \read{\Wire(k)}$
\item $\Out(\B,k) \coloneqq \read{\Wire(k)}$
\end{itemize}
We thus get the following for channels $\Out(\A,-)$ and $\Out(\B,-)$:
\begin{itemize}
\item $\begin{cases*} \Out(\A,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\A,k) \coloneqq \read{\Out(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\begin{cases*} \Out(\B,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\B,k) \coloneqq \read{\Out(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\end{itemize}
The top-level internal channels $\SumShare(-)$ are now unused by the rest of the protocol and can be eliminated. The resulting version $\Fin$ of the final part of the real protocol is as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\LeakSendOutShare(\B,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Wire(k); \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakRcvdOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Wire(k); \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item $\begin{cases*} \Out(\A,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\A,k) \coloneqq \read{\Out(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\begin{cases*} \Out(\B,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\B,k) \coloneqq \read{\Out(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item {\color{blue} $\LeakOut(\A,k)^\A_\adv \coloneqq \read{\Out(\A,k)}$ for $k < K$}
\end{itemize}

\subsubsection{Extracting The Simulator}\label{sect:gmw_extracting_simulator}
We are now ready to extract the simulator. The internal protocol $\Wires(C,K)$ together with the output channels
\begin{itemize}
\item $\begin{cases*} \Out(\A,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\A,k) \coloneqq \read{\Out(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\begin{cases*} \Out(\B,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\B,k) \coloneqq \read{\Out(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\end{itemize}
will be factored out as coming from the ideal functionality. In particular, this leaves us with following version $\Fin$ of the final part of the soon-to-be simulator:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\LeakSendOutShare(\B,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Wire(k); \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakRcvdOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Wire(k); \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\LeakOut(\A,k)^\A_\adv \coloneqq \read{\Out(\A,k)}$ for $k < K$}
\end{itemize}

\noindent In the remainder of the soon-to-be simulator, we must eliminate any references to the channels $\In(\A,-)$,
 $\Wire(-)$, $\Out(\A,-)$, $\Out(\B,-)$. We begin with the initial part of the real protocol. Recall the leakage
\begin{itemize}
\item {\color{blue} $\LeakIn(\A,i)^\id_\adv \coloneqq \In(\A,i)$ for $i < N$}
\item {\color{blue} $\LeakInRcvd(\B,i)^\id_\adv \coloneqq x\leftarrow \In(\B,i); \ \ret{\checkmark}$ for $i < M$}
\end{itemize}
from the ideal functionality. In the presence of these channels we can write the protocol $\Init$ -- forming the initial part of the simulator -- equivalently as follows:

\begin{itemize}
\item {\color{blue} $\LeakIn(\A,i)^{\A}_\adv \coloneqq \read{\LeakIn(\A,i)^\id_\adv}$ for $i < N$}
\item {\color{blue} $\LeakInRcvd(\B,i)^{\B}_\adv \coloneqq \read{\LeakInRcvd(\B,i)^\id_\adv}$ for $i < M$}
\item $\InShareGen(\A,\A,i) \coloneqq x \leftarrow \LeakIn(\A,i)^\id_\adv; \ \samp{\flip}$ for $i < N$
\item $\InShareGen(\A,\B,i) \coloneqq \_ \leftarrow \LeakInRcvd(\B,i)^\id_\adv; \ \samp{\flip}$ for $i < M$
\item {\color{blue} $\LeakInShareGen(\A,\A,i)^\A_\adv \coloneqq \read{\InShareGen(\A,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakInShareGen(\B,\A,i)^\A_\adv \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \LeakIn(\A,i)^\id_\adv; \ \ret{x_A \oplus x}$ for $i < N$}
\item {\color{blue} $\LeakSendInShare(\B,\A,i)^\A_\adv \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \LeakIn(\A,i)^\id_\adv; \ \ret{x_A \oplus x}$ for $i < N$}
\item {\color{blue} $\LeakRcvdInShare(\A,\B,i)^\A_\adv \coloneqq \read{\InShareGen(\A,\B,i)}$ for $i < M$}
\item $\InShare(\A,\A,i) \coloneqq \read{\InShareGen(\A,\A,i)}$ for $i < N$
\item $\InShare(\A,\B,i) \coloneqq \read{\InShareGen(\A,\B,i)}$ for $i < M$
\item {\color{blue} $\LeakInShare(\A,\A,i)^\A_\adv \coloneqq \read{\InShare(\A,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakInShare(\A,\B,i)^\A_\adv \coloneqq \read{\InShare(\A,\B,i)}$ for $i < M$}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\InShareGen(\A,\A,i)$ for $i < N$,
\item $\InShareGen(\A,\B,i)$ for $i < M$.
\end{itemize}

\noindent We continue with the final part of the soon-to-be simulator. Recall the definition of the output channels
\begin{itemize}
\item $\begin{cases*} \Out(\A,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\A,k) \coloneqq \read{\Out(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\item $\begin{cases*} \Out(\B,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \Out(\B,k) \coloneqq \read{\Out(\B,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$
\end{itemize}
in the ideal functionality. If wire $k$ is an output, then the channels
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Wire(k); \ \ret{x_A \oplus x}$}
\item {\color{blue} $\LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Wire(k); \ \ret{x_A \oplus x}$}
\end{itemize}
can be expressed equivalently as
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Out(\A,k); \ \ret{x_A \oplus x}$}
\item {\color{blue} $\LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Out(\A,k); \ \ret{x_A \oplus x}$}
\end{itemize}
since we have the definition below:
\begin{itemize}
\item $\Out(\A,k) \coloneqq \read{\Wire(k)}$
\end{itemize}
We thus get the following for channels $\LeakRcvdOutShare(\A,\B,-)^\A_\adv$ and $\LeakOutShare(\A,\B,-)^\A_\adv$: 
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Out(\A,k); \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakRcvdOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Out(\A,k); \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\end{itemize}
The latest version $\Fin$ of the final part of the soon-to-be simulator is therefore as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\LeakSendOutShare(\B,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Out(\A,k); \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakRcvdOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Out(\A,k); \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\LeakOut(\A,k)^\A_\adv \coloneqq \read{\Out(\A,k)}$ for $k < K$}
\end{itemize}

\noindent We now recall the leakage
\begin{itemize}
\item {\color{blue} $\LeakOut(\A,k)^\id_\adv \coloneqq \read{\Out(\A,k)}$ for $k < K$}
\end{itemize}
from the ideal functionality. If wire $k$ is an output, then the channels
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Out(\A,k); \ \ret{x_A \oplus x}$}
\item {\color{blue} $\LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \Out(\A,k); \ \ret{x_A \oplus x}$}
\end{itemize}
can be expressed equivalently as
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \LeakOut(\A,k)^\id_\adv; \ \ret{x_A \oplus x}$}
\item {\color{blue} $\LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \LeakOut(\A,k)^\id_\adv; \ \ret{x_A \oplus x}$}
\end{itemize}
We thus get the following for channels $\LeakRcvdOutShare(\A,\B,-)^\A_\adv$ and $\LeakOutShare(\A,\B,-)^\A_\adv$: 
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \LeakOut(\A,k)^\id_\adv; \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakRcvdOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \LeakOut(\A,k)^\id_\adv; \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\end{itemize}
Finally, the channels
\begin{itemize}
\item {\color{blue} $\LeakOut(\A,k)^\A_\adv \coloneqq \read{\Out(\A,k)}$ for $k < K$}
\end{itemize}
can be expressed equivalently as
\begin{itemize}
\item {\color{blue} $\LeakOut(\A,k)^\A_\adv \coloneqq \read{\LeakOut(\A,k)^\id_\adv}$ for $k < K$}
\end{itemize}
The final version $\Fin$ of the final part of the simulator is therefore as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\LeakSendOutShare(\B,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \LeakOut(\A,k)^\id_\adv; \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakRcvdOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \LeakOut(\A,k)^\id_\adv; \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\LeakOut(\A,k)^\A_\adv \coloneqq \read{\LeakOut(\A,k)^\id_\adv}$ for $k < K$}
\end{itemize}

\subsubsection{The Simulator}
The simulator consists of three parts. In the initial phase, we have the protocol $\Init$:

\begin{itemize}
\item {\color{blue} $\LeakIn(\A,i)^{\A}_\adv \coloneqq \read{\LeakIn(\A,i)^\id_\adv}$ for $i < N$}
\item {\color{blue} $\LeakInRcvd(\B,i)^{\B}_\adv \coloneqq \read{\LeakInRcvd(\B,i)^\id_\adv}$ for $i < M$}
\item $\InShareGen(\A,\A,i) \coloneqq x \leftarrow \LeakIn(\A,i)^\id_\adv; \ \samp{\flip}$ for $i < N$
\item $\InShareGen(\A,\B,i) \coloneqq \_ \leftarrow \LeakInRcvd(\B,i)^\id_\adv; \ \samp{\flip}$ for $i < M$
\item {\color{blue} $\LeakInShareGen(\A,\A,i)^\A_\adv \coloneqq \read{\InShareGen(\A,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakInShareGen(\B,\A,i)^\A_\adv \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \LeakIn(\A,i)^\id_\adv; \ \ret{x_A \oplus x}$ for $i < N$}
\item {\color{blue} $\LeakSendInShare(\B,\A,i)^\A_\adv \coloneqq x_A \leftarrow \InShareGen(\A,\A,i); \ x \leftarrow \LeakIn(\A,i)^\id_\adv; \ \ret{x_A \oplus x}$ for $i < N$}
\item {\color{blue} $\LeakRcvdInShare(\A,\B,i)^\A_\adv \coloneqq \read{\InShareGen(\A,\B,i)}$ for $i < M$}
\item $\InShare(\A,\A,i) \coloneqq \read{\InShareGen(\A,\A,i)}$ for $i < N$
\item $\InShare(\A,\B,i) \coloneqq \read{\InShareGen(\A,\B,i)}$ for $i < M$
\item {\color{blue} $\LeakInShare(\A,\A,i)^\A_\adv \coloneqq \read{\InShare(\A,\A,i)}$ for $i < N$}
\item {\color{blue} $\LeakInShare(\A,\B,i)^\A_\adv \coloneqq \read{\InShare(\A,\B,i)}$ for $i < M$}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\InShareGen(\A,\A,i)$ for $i < N$,
\item $\InShareGen(\A,\B,i)$ for $i < M$.
\end{itemize}

\noindent In the inductive phase, we have the protocol $\Circ(C,K)$, obtained by merging the two protocols $\Shares(C,K)$ and $\Adv(C,K)$ from earlier:

\begin{itemize}
\item $\Circ(\epsilon,0)$ is the protocol $\zero$

\item $\Circ\big(C; \, \inputgate(\A,i),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}\smallskip
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\A,i)}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Circ\big(C; \, \inputgate(\B,i),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}\smallskip
\item $\Share(\A,K) \coloneqq \read{\InShare(\A,\B,i)}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Circ\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}\smallskip
\item $\Share(\A,K) \coloneqq \read{\Share(\A,k)}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Circ\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq \read{\SendBit(\A,\B,K)}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\LeakSendBit(\A,\B,K)^\A_\adv}$}\smallskip
\item $\Share(\A,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{x_A \oplus y_A}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(\A,\B,K)^\ot_\adv}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv}$}
\end{itemize}

\item $\Circ\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(\A,\B,K) \coloneqq x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \samp{\flip}$
\item {\color{blue} $\LeakSendBit(\A,\B,K)^\A_\adv \coloneqq \read{\SendBit(\A,\B,K)}$}\smallskip
\item $\Share(\A,K) \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{(x_A * y_A) \oplus b_A}$
\item {\color{blue} $\LeakShare(\A,K)^\A_\adv \coloneqq \read{\Share(\A,K)}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A}$}
\item {\color{blue} $\LeakOTMsg_1(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A}$}
\item {\color{blue} $\LeakOTMsg_2(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus y_A}$}
\item {\color{blue} $\LeakOTMsg_3(\A,\B,K)^\ot_\adv \coloneqq b_A \leftarrow \SendBit(\A,\B,K); \ x_A \leftarrow \Share(\A,k); \ y_A \leftarrow \Share(\A,l); \ \ret{b_A \oplus x_A \oplus y_A}$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(\A,\B,K)^\ot_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ \ret{\checkmark}$}
\item {\color{blue} $\LeakOTChcRcvd_1(\A,\B,K)^\ot_\adv \coloneqq x_A \leftarrow \Share(\A,l); \ \ret{\checkmark}$}
\end{itemize}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\SendBit(\A,\B,k)$ for $k < K$.
\end{itemize}

\noindent In the final phase, we have the protocol $\Fin$:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakSendOutShare(\B,\A,k)^\A_\adv \coloneqq \read{\LeakSendOutShare(\B,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \LeakOut(\A,k)^\id_\adv; \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakRcvdOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakRcvdOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\Share(\A,k)} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\A,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\A,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq x_A \leftarrow \Share(\A,k); \ x \leftarrow \LeakOut(\A,k)^\id_\adv; \ \ret{x_A \oplus x} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ an output} \\ \LeakOutShare(\A,\B,k)^\A_\adv \coloneqq \read{\LeakOutShare(\A,\B,k)^\A_\adv} \\ \hspace{10pt} \text{for $k < K$ if wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\LeakOut(\A,k)^\A_\adv \coloneqq \read{\LeakOut(\A,k)^\id_\adv}$ for $k < K$}
\end{itemize}

\noindent The composition of the three parts is followed by the hiding of the channels
\begin{itemize}
\item $\InShare(\A,\A,i)$ for $i < N$,
\item $\InShare(\A,\B,i)$ for $i < M$,
\item $\Share(\A,k)$ for $k < K$.
\end{itemize}

\noindent Composing the ideal protocol with the simulator, and substituting away the ideal leakage
\begin{itemize}
\item $\LeakIn(\A,i)^\id_\adv$ for $i < N$,
\item $\LeakInRcvd(\B,i)^\id_\adv$ for $i < M$,
\item $\Out(\A,k)^\id_\adv$ for $k < K$,
\item $\Out(\B,k)^\id_\adv$ for $k < K$
\end{itemize}
as indicated in Section \ref{sect:gmw_extracting_simulator} yields precisely the version of the real protocol we had at the end of Section \ref{sect:gmw_eliminating_shares}.