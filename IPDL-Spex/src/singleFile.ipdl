lang IPDL

import BASEGMWN .

parameter N : nat .
parameter K : nat .

`` Sigma

function xor : bool * bool -> bool .
function ** : bool * bool  -> bool .
function neg : bool -> bool .
distribution flip : unit -> bool .

`` assumptions

expression-assumption %automatic andFalseLeft using x : 
   (x : bool)  |= 
   **( (False, x) ) = False .

    expression-assumption %automatic andFalseRight using x : 
   (x : bool)  |= 
   **( (x, False) ) = False . 

   expression-assumption %automatic andTrueLeft using x : 
   (x : bool)  |= 
   **( (True, x) ) = x .

    expression-assumption %automatic andTrueRight using x : 
   (x : bool)  |= 
   **( (x, True) ) = x .
   
    expression-assumption %automatic xorFalseLeft using x : 
   (x : bool)  |= 
   xor( (False, x) ) = x .

    expression-assumption %automatic xorFalseRight using x : 
   (x : bool)  |= 
   xor( (x, False) ) = x . 
   
    expression-assumption %automatic xorFalse using x : 
   (x : bool)  |= 
   xor( (x, x) ) = False . 
   
   expression-assumption %automatic falseXor using x : 
   (x : bool)  |= 
   xor( (False, False) ) = False . 

   expression-assumption %manual xor-idem-2 using x, y :
    (x : bool) (y : bool) |=
    xor( (x, xor((y, x ))) ) = y .

    expression-assumption %manual xor-idem-1 using x, y :
    (x : bool) (y : bool) |=
    xor( (x, xor((x, y ))) ) = y .

    expression-assumption %manual xor-idem-3 using x, y :
    (x : bool) (y : bool) |=
    xor( (xor((x, y)), y) ) = x .

    expression-assumption %manual xor-comm using x, y :
    (x : bool) (y : bool) |=
    xor((x, y)) = xor((y, x)) .

    expression-assumption %manual neg-over-xor using x, y : 
    (x : bool) (y : bool) |=
    xor( (x, neg(y)) ) = neg( xor((x, y)) ) .

    expression-assumption %manual rearrange-xor using x1, x2, x3, x4 : 
    (x1 : bool) (x2 : bool)
    (x3 : bool) (x4 : bool) |=
    xor( ( xor((x1, x2)) , xor((x3, x4)) ) ) 
    =
    xor( ( xor((x1, x3)) , xor((x2, x4)) ) )  .

    expression-assumption %manual middle-xor using x1, x2, x3, x4 : 
    (x1 : bool) (x2 : bool)
    (x3 : bool) (x4 : bool) |=
    xor( ( xor((x1, x2)) , xor((x3, x4)) ) ) 
    =
    xor( ( xor( (x1, xor( (x2, x3) ) ) ) , x4 ) ) .

    expression-assumption %manual derived-xor-and-rule using e1, e2, e3, e4, e5, e6 :
    (e1 : bool) (e2 : bool) (e3 : bool)
    (e4 : bool) (e5 : bool) (e6 : bool) |=
    xor( (  xor(( **((e1, e2)) , **((e3, e2)) ))  , 
            xor(( **((e4, e5)) , **((e4, e6)) ))  
       ) )
    =    
    xor((
        **((xor((e1, e3)), e2)) ,
        **((e4, xor((e5, e6)))) 
    )) . 

    expression-assumption %manual derived-xor-rule using e1, e2, e3, e4 :
    (e1 : bool) (e2 : bool) (e3 : bool)
    (e4 : bool) |=
    xor(( xor((e1, xor((e2, e3)) ))  , e4 )) 
    = 
    xor(( xor((e1, e2)) , xor((e3, e4)) )) .

    expression-assumption %manual distrib-twice using e1, e2, e3, e4 :
    (e1 : bool) (e2 : bool) (e3 : bool)
    (e4 : bool) |=
    **(( xor((e1, e2)) , xor((e3, e4)) ))
    =
    xor(
    ( xor((**((e1, e3)) , **((e1, e4))))
        ,
      xor((**((e2, e3)) , **((e2, e4))))  
    )
    )
    .


hypothesis not (isNotGate(0)) .
hypothesis not (isXorGate(0)) .
hypothesis not (isAndGate(0)) .
hypothesis isHonest(N + 1) .

`` for the anonymous protocols

channel context deltaSRW = 
 
 input OTMsg-0[s, r, w] : bool ;
 input OTMsg-1[s, r, w] : bool ;
 input OTMsg-2[s, r, w] : bool ;
 input OTMsg-3[s, r, w] : bool ;

 input OTChc-0[s, r, w] : bool ;
 input OTChc-1[s, r, w] : bool ;

 output OTMsg-0OtAdv[s, r, w] : bool ;
 output OTMsg-1OtAdv[s, r, w] : bool ;
 output OTMsg-2OtAdv[s, r, w] : bool ;
 output OTMsg-3OtAdv[s, r, w] : bool ;

 output OTMsgRcvd-0OtAdv[s, r, w] : unit ;
 output OTMsgRcvd-1OtAdv[s, r, w] : unit ;
 output OTMsgRcvd-2OtAdv[s, r, w] : unit ;
 output OTMsgRcvd-3OtAdv[s, r, w] : unit ;

 output OTChc-0OtAdv[s, r, w] : bool ;
 output OTChc-1OtAdv[s, r, w] : bool ;

 output OTChcRcvd-0OtAdv[s, r, w] : unit ;
 output OTChcRcvd-1OtAdv[s, r, w] : unit ;

 output OTOut[s, r, w] : bool ;
 output OTOutOtAdv[s, r, w] : bool 

.

protocol 1OutOf4OTIdeal-Honest-Honest =
   ( OTMsg-0OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-0OtAdv[s, r, w] ; return om
   ) ||
      ( OTMsg-1OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-1OtAdv[s, r, w] ; return om
   ) ||
      ( OTMsg-2OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-2OtAdv[s, r, w] ; return om
   ) ||
      ( OTMsg-3OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-3OtAdv[s, r, w] ; return om
   )  ||
      ( OTMsgRcvd-0OtAdv[s, r, w] ::= 
       m0 : bool <- read OTMsg-0[s, r, w] ; return ()
   ) ||
      ( OTMsgRcvd-1OtAdv[s, r, w] ::= 
       m1 : bool <- read OTMsg-1[s, r, w] ; return ()
   ) ||
      ( OTMsgRcvd-2OtAdv[s, r, w] ::= 
       m2 : bool <- read OTMsg-2[s, r, w] ; return ()
   ) ||
      ( OTMsgRcvd-3OtAdv[s, r, w] ::= 
       m3 : bool <- read OTMsg-3[s, r, w] ; return ()
   ) || 
      ( OTChc-0OtAdv[s, r, w] ::= 
       oc : bool <- read OTChc-0OtAdv[s, r, w] ; return oc
   ) ||
      ( OTChc-1OtAdv[s, r, w] ::= 
       oc : bool <- read OTChc-1OtAdv[s, r, w] ; return oc
   ) || 
      ( OTChcRcvd-0OtAdv[s, r, w] ::= 
       c0 : bool <- read OTChc-0[s, r, w] ; return ()
   ) ||
      ( OTChcRcvd-1OtAdv[s, r, w] ::= 
       c1 : bool <- read OTChc-1[s, r, w] ; return ()
   ) || 
     ( OTOut[s, r, w] ::=
      
           m0 : bool <- read OTMsg-0[s, r, w] ;
           m1 : bool <- read OTMsg-1[s, r, w] ;
           m2 : bool <- read OTMsg-2[s, r, w] ;
           m3 : bool <- read OTMsg-3[s, r, w] ;
           c0 : bool <- read OTChc-0[s, r, w] ;
           c1 : bool <- read OTChc-1[s, r, w] ;
           (if c0 then
             if c1 then return m3 else return m2
           else 
             if c1 then return m1 else return m0
           )  
       
   ) || 
      ( OTOutOtAdv[s, r, w] ::= 
       out : bool <- read OTOutOtAdv[s, r, w] ; return out
   )
  .

  protocol 1OutOf4OTIdeal-Honest-SemiHonest =
   ( OTMsg-0OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-0OtAdv[s, r, w] ; return om
   ) ||
      ( OTMsg-1OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-1OtAdv[s, r, w] ; return om
   ) ||
      ( OTMsg-2OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-2OtAdv[s, r, w] ; return om
   ) ||
      ( OTMsg-3OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-3OtAdv[s, r, w] ; return om
   )  ||
      ( OTMsgRcvd-0OtAdv[s, r, w] ::= 
       m0 : bool <- read OTMsg-0[s, r, w] ; return ()
   ) ||
      ( OTMsgRcvd-1OtAdv[s, r, w] ::= 
       m1 : bool <- read OTMsg-1[s, r, w] ; return ()
   ) ||
      ( OTMsgRcvd-2OtAdv[s, r, w] ::= 
       m2 : bool <- read OTMsg-2[s, r, w] ; return ()
   ) ||
      ( OTMsgRcvd-3OtAdv[s, r, w] ::= 
       m3 : bool <- read OTMsg-3[s, r, w] ; return ()
   ) || 
      ( OTChc-0OtAdv[s, r, w] ::= 
       oc : bool <- read OTChc-0[s, r, w] ; return oc
   ) ||
      ( OTChc-1OtAdv[s, r, w] ::= 
       oc : bool <- read OTChc-1[s, r, w] ; return oc
   ) || 
      ( OTChcRcvd-0OtAdv[s, r, w] ::= 
       oc : unit <- read OTChcRcvd-0OtAdv[s, r, w] ; return oc
   ) ||
      ( OTChcRcvd-1OtAdv[s, r, w] ::= 
       oc : unit <- read OTChcRcvd-1OtAdv[s, r, w] ; return oc
   ) || 
     ( OTOut[s, r, w] ::=
      
           m0 : bool <- read OTMsg-0[s, r, w] ;
           m1 : bool <- read OTMsg-1[s, r, w] ;
           m2 : bool <- read OTMsg-2[s, r, w] ;
           m3 : bool <- read OTMsg-3[s, r, w] ;
           c0 : bool <- read OTChc-0[s, r, w] ;
           c1 : bool <- read OTChc-1[s, r, w] ;
           (if c0 then
             if c1 then return m3 else return m2
           else 
             if c1 then return m1 else return m0
           )  
       
   ) || 
      ( OTOutOtAdv[s, r, w] ::= 
       out : bool <- read OTOut[s, r, w] ; return out
   )
  .

  protocol 1OutOf4OTIdeal-SemiHonest-Honest =
   ( OTMsg-0OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-0[s, r, w] ; return om
   ) ||
      ( OTMsg-1OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-1[s, r, w] ; return om
   ) ||
      ( OTMsg-2OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-2[s, r, w] ; return om
   ) ||
      ( OTMsg-3OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-3[s, r, w] ; return om
   )  ||
      ( OTMsgRcvd-0OtAdv[s, r, w] ::= 
       om : unit <- read OTMsgRcvd-0OtAdv[s, r, w] ; return om
   ) ||
      ( OTMsgRcvd-1OtAdv[s, r, w] ::= 
       om : unit <- read OTMsgRcvd-1OtAdv[s, r, w] ; return om
   ) ||
      ( OTMsgRcvd-2OtAdv[s, r, w] ::= 
       om : unit <- read  OTMsgRcvd-2OtAdv[s, r, w] ; return om
   ) ||
      ( OTMsgRcvd-3OtAdv[s, r, w] ::= 
       om : unit <- read OTMsgRcvd-3OtAdv[s, r, w] ; return om
   ) || 
      ( OTChc-0OtAdv[s, r, w] ::= 
       oc : bool <- read OTChc-0OtAdv[s, r, w] ; return oc
   ) ||
      ( OTChc-1OtAdv[s, r, w] ::= 
       oc : bool <- read OTChc-1OtAdv[s, r, w] ; return oc
   ) || 
      ( OTChcRcvd-0OtAdv[s, r, w] ::= 
       c0 : bool <- read OTChc-0[s, r, w] ; return ()
   ) ||
      ( OTChcRcvd-1OtAdv[s, r, w] ::= 
       c1 : bool <- read OTChc-1[s, r, w] ; return ()
   ) || 
     ( OTOut[s, r, w] ::=
      
           m0 : bool <- read OTMsg-0[s, r, w] ;
           m1 : bool <- read OTMsg-1[s, r, w] ;
           m2 : bool <- read OTMsg-2[s, r, w] ;
           m3 : bool <- read OTMsg-3[s, r, w] ;
           c0 : bool <- read OTChc-0[s, r, w] ;
           c1 : bool <- read OTChc-1[s, r, w] ;
           (if c0 then
             if c1 then return m3 else return m2
           else 
             if c1 then return m1 else return m0
           )  
       
   ) || 
      ( OTOutOtAdv[s, r, w] ::= 
       out : bool <- read OTOutOtAdv[s, r, w] ; return out
   )
  .

protocol 1OutOf4OTIdeal-SemiHonest-SemiHonest =
   ( OTMsg-0OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-0[s, r, w] ; return om
   ) ||
      ( OTMsg-1OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-1[s, r, w] ; return om
   ) ||
      ( OTMsg-2OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-2[s, r, w] ; return om
   ) ||
      ( OTMsg-3OtAdv[s, r, w] ::= 
       om : bool <- read OTMsg-3[s, r, w] ; return om
   )  ||
      ( OTMsgRcvd-0OtAdv[s, r, w] ::= 
       om : unit <- read OTMsgRcvd-0OtAdv[s, r, w] ; return om
   ) ||
      ( OTMsgRcvd-1OtAdv[s, r, w] ::= 
       om : unit <- read OTMsgRcvd-1OtAdv[s, r, w] ; return om
   ) ||
      ( OTMsgRcvd-2OtAdv[s, r, w] ::= 
       om : unit <- read  OTMsgRcvd-2OtAdv[s, r, w] ; return om
   ) ||
      ( OTMsgRcvd-3OtAdv[s, r, w] ::= 
       om : unit <- read OTMsgRcvd-3OtAdv[s, r, w] ; return om
   ) || 
      ( OTChc-0OtAdv[s, r, w] ::= 
       oc : bool <- read OTChc-0[s, r, w] ; return oc
   ) ||
      ( OTChc-1OtAdv[s, r, w] ::= 
       oc : bool <- read OTChc-1[s, r, w] ; return oc
   ) || 
      ( OTChcRcvd-0OtAdv[s, r, w] ::= 
       oc : unit <- read OTChcRcvd-0OtAdv[s, r, w] ; return oc
   ) ||
      ( OTChcRcvd-1OtAdv[s, r, w] ::= 
       oc : unit <- read OTChcRcvd-1OtAdv[s, r, w] ; return oc
   ) || 
     ( OTOut[s, r, w] ::=
      
           m0 : bool <- read OTMsg-0[s, r, w] ;
           m1 : bool <- read OTMsg-1[s, r, w] ;
           m2 : bool <- read OTMsg-2[s, r, w] ;
           m3 : bool <- read OTMsg-3[s, r, w] ;
           c0 : bool <- read OTChc-0[s, r, w] ;
           c1 : bool <- read OTChc-1[s, r, w] ;
           (if c0 then
             if c1 then return m3 else return m2
           else 
             if c1 then return m1 else return m0
           )  
       
   ) || 
      ( OTOutOtAdv[s, r, w] ::= 
       out : bool <- read OTOut[s, r, w] ; return out
   )
  .

protocol 1OutOf4OTReal-Honest-Honest .
protocol 1OutOf4OTReal-Honest-SemiHonest .
protocol 1OutOf4OTReal-SemiHonest-Honest .
protocol 1OutOf4OTReal-SemiHonest-SemiHonest . 

approx-assumption HH2HH using nil : 
emptyCCtxt ; 
no inputs ; 
no assumptions
 |= 
 1OutOf4OTReal-Honest-Honest = 1OutOf4OTIdeal-Honest-Honest .

approx-assumption SHH2SHH using nil : 
emptyCCtxt ; 
no inputs ; 
no assumptions
 |= 
 1OutOf4OTReal-SemiHonest-Honest = 1OutOf4OTIdeal-SemiHonest-Honest .

 approx-assumption HSH2HSH using nil : 
emptyCCtxt ; 
no inputs ; 
no assumptions
 |= 
 1OutOf4OTReal-Honest-SemiHonest = 1OutOf4OTIdeal-Honest-SemiHonest .

 approx-assumption SHSH2SHSH using nil : 
emptyCCtxt ; 
no inputs ; 
no assumptions
 |= 
 1OutOf4OTReal-SemiHonest-SemiHonest = 1OutOf4OTIdeal-SemiHonest-SemiHonest .

channel context deltaNMK = 
 
 input OTMsg-0[n, m, k] : bool ;
 input OTMsg-1[n, m, k] : bool ;
 input OTMsg-2[n, m, k] : bool ;
 input OTMsg-3[n, m, k] : bool ;

 input OTChc-0[n, m, k] : bool ;
 input OTChc-1[n, m, k] : bool ;

 output OTMsg-0OtAdv[n, m, k] : bool ;
 output OTMsg-1OtAdv[n, m, k] : bool ;
 output OTMsg-2OtAdv[n, m, k] : bool ;
 output OTMsg-3OtAdv[n, m, k] : bool ;

 output OTMsgRcvd-0OtAdv[n, m, k] : unit ;
 output OTMsgRcvd-1OtAdv[n, m, k] : unit ;
 output OTMsgRcvd-2OtAdv[n, m, k] : unit ;
 output OTMsgRcvd-3OtAdv[n, m, k] : unit ;

 output OTChc-0OtAdv[n, m, k] : bool ;
 output OTChc-1OtAdv[n, m, k] : bool ;

 output OTChcRcvd-0OtAdv[n, m, k] : unit ;
 output OTChcRcvd-1OtAdv[n, m, k] : unit ;

 output OTOut[n, m, k] : bool ;
 output OTOutOtAdv[n, m, k] : bool 

.

embedding phi from deltaSRW to deltaNMK = 
   OTMsg-0[s, r, w] |->  OTMsg-0[n, m, k] ;
   OTMsg-1[s, r, w] |->  OTMsg-1[n, m, k] ;
   OTMsg-2[s, r, w] |->  OTMsg-2[n, m, k] ;
   OTMsg-3[s, r, w] |->  OTMsg-3[n, m, k] ;

   OTChc-0[s, r, w] |-> OTChc-0[n, m, k] ;
   OTChc-1[s, r, w] |-> OTChc-1[n, m, k] ;

  OTMsg-0OtAdv[s, r, w] |-> OTMsg-0OtAdv[n, m, k] ;
  OTMsg-1OtAdv[s, r, w] |-> OTMsg-1OtAdv[n, m, k] ;
  OTMsg-2OtAdv[s, r, w] |-> OTMsg-2OtAdv[n, m, k] ;
  OTMsg-3OtAdv[s, r, w] |-> OTMsg-3OtAdv[n, m, k] ;

  OTMsgRcvd-0OtAdv[s, r, w] |-> OTMsgRcvd-0OtAdv[n, m, k] ;
  OTMsgRcvd-1OtAdv[s, r, w] |-> OTMsgRcvd-1OtAdv[n, m, k] ;
  OTMsgRcvd-2OtAdv[s, r, w] |-> OTMsgRcvd-2OtAdv[n, m, k] ;
  OTMsgRcvd-3OtAdv[s, r, w] |-> OTMsgRcvd-3OtAdv[n, m, k] ;

  OTChc-0OtAdv[s, r, w] |-> OTChc-0OtAdv[n, m, k] ;
  OTChc-1OtAdv[s, r, w] |-> OTChc-1OtAdv[n, m, k] ;

  OTChcRcvd-0OtAdv[s, r, w] |-> OTChcRcvd-0OtAdv[n, m, k] ;
  OTChcRcvd-1OtAdv[s, r, w] |-> OTChcRcvd-1OtAdv[n, m, k] ;

  OTOut[s, r, w] |-> OTOut[n, m, k] ;
  OTOutOtAdv[s, r, w] |-> OTOutOtAdv[n, m, k]
.

channel context deltaNMKfam = 
  input OTMsg-0[bound N + 2 bound N + 2 bound K] : bool ;
  input OTMsg-1[bound N + 2 bound N + 2 bound K] : bool ;
  input OTMsg-2[bound N + 2 bound N + 2 bound K] : bool ;
  input OTMsg-3[bound N + 2 bound N + 2 bound K] : bool ;

  input OTChc-0[bound N + 2 bound N + 2 bound K] : bool ;
  input OTChc-1[bound N + 2 bound N + 2 bound K] : bool ;
  
  output OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
  output OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
  output OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
  output OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] : bool ;

  output OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
  output OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
  output OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
  output OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] : unit ; 

  output OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
  output OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] : bool ;

  output OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
  output OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] : unit ;

  output OTOut[bound N + 2 bound N + 2 bound K] : bool ;
  output OTOutOtAdv[bound N + 2 bound N + 2 bound K] : bool 
  .

protocol 1OutOf4OTIdeal = 
     family 1OutOf4OTIdeal[bound N + 2 bound N + 2 bound K] 
     indices: n, m, k
     bounds: bound N + 2 bound N + 2 bound K ::=
     ( when ( isHonest(n) and isHonest(m) ) -->  
      embed(1OutOf4OTIdeal-Honest-Honest, phi)
     ) ;;
     ( when ( isSemiHonest(n) and isHonest(m) ) -->  
      embed(1OutOf4OTIdeal-SemiHonest-Honest, phi)
     ) ;;
     ( when ( isHonest(n) and isSemiHonest(m) ) -->  
      embed(1OutOf4OTIdeal-Honest-SemiHonest, phi)
     ) ;;
     ( when ( isSemiHonest(n) and isSemiHonest(m) ) -->  
      embed(1OutOf4OTIdeal-SemiHonest-SemiHonest, phi)
     )
  . 

`` deltaReal 

channel context deltaReal =

input    In[bound N + 2 dependentBound I] : bool ;
output   Out[bound N + 2 bound K] : bool ;
output   CtrbPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   InPartyAdv[bound N + 2 dependentBound I] : bool ;
output   InRcvdPartyAdv[bound N + 2 dependentBound I] : unit ;
output   InSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   InShare$PartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   InShare$-SumPartyAdv[bound N + 1 bound N + 2 dependentBound I] : bool ;
output   OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTOutOtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OutPartyAdv[bound N + 2 bound K] : bool ;
output   OutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OutShareSumPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   RcvdOutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SendBitPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SendInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   SendOutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SharePartyAdv[bound N + 2 bound K] : bool
 .

`` real

protocol real = 
   newfamily SendInShare[bound N + 2 bound N + 2 dependentBound I]
              indices: m, n, i 
             bounds: bound N + 2 bound N + 2 dependentBound I : bool in
   newfamily OTMsg-0[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in  
   newfamily OTMsg-1[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in 
   newfamily OTMsg-2[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in 
   newfamily OTMsg-3[bound N + 2 bound N + 2 bound K ]
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in 
   newfamily OTChc-0[bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k 
             bounds: bound N + 2 bound N + 2 bound K : bool in  
   newfamily OTChc-1[bound N + 2 bound N + 2 bound K ]
              indices: m, n,  k 
             bounds: bound N + 2 bound N + 2 bound K : bool in                             
   newfamily OTOut[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in          
   newfamily SendOutShare[bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k 
             bounds: bound N + 2 bound N + 2 bound K : bool in          
   parties || 1OutOf4OTReal
  where
 1OutOf4OTReal = 
    (family 1OutOf4OTReal[bound N + 2 bound N + 2 bound K] 
     indices: n, m, k
     bounds: bound N + 2 bound N + 2 bound K ::=
     ( when ( isHonest(n) and isHonest(m) ) -->  
      embed(1OutOf4OTReal-Honest-Honest, phi)
     ) ;;
     ( when ( isSemiHonest(n) and isHonest(m) ) -->  
      embed(1OutOf4OTReal-SemiHonest-Honest, phi)
     ) ;;
     ( when ( isHonest(n) and isSemiHonest(m) ) -->  
      embed(1OutOf4OTReal-Honest-SemiHonest, phi)
     ) ;;
     ( when ( isSemiHonest(n) and isSemiHonest(m) ) -->  
      embed(1OutOf4OTReal-SemiHonest-SemiHonest, phi)
     )
    ) 
 and 
 parties = 
   ( newfamily InShare[bound N + 2 bound N + 2 dependentBound I] 
              indices: n, m, i 
             bounds: bound N + 2 bound N + 2 dependentBound I : bool in   
   newfamily Share[bound N + 2 bound K]  
              indices: n, k 
             bounds: bound N + 2 bound K : bool in
   partyInitial || partyInductive || partyFinal           
  where
 partyInitial = (
  newfamily InShare$[bound N + 2 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I : bool in
  newfamily InShare$-Sum[bound N + 1 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 1 bound N + 2 dependentBound I : bool in
  (
    (family InPartyAdv[bound N + 2 dependentBound I] 
            indices: n, i
            bounds: bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         in : bool <- read In[n, i] ; return in
       ) 
       ;; 
       (when (isHonest(n)) --> 
         in : bool <- read InPartyAdv[n, i] ; return in
       )       
     )
     ||
     (family InRcvdPartyAdv[bound N + 2 dependentBound I] 
        indices: n, i
            bounds:  bound N + 2 dependentBound I ::=
       (when (isHonest(n)) --> 
         x : bool <- read In[n, i] ; return ()
       ) 
       ;; 
       (when (isSemiHonest(n))  --> 
         in : unit <- read InRcvdPartyAdv[n, i] ; return in
       )       
     )
     ||
     (family InShare$[bound N + 2 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (m = N + 1) --> 
             x : bool <- read In[n, i] ;
             s : bool <- read InShare$-Sum[N, n, i] ;
             return xor( (x, s) )
       )
       ;;
       (otherwise --> 
         x : bool <- read In[n, i] ; samp flip (())
       )      
     )
     ||
      (family InShare$PartyAdv
               [bound N + 2 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
          in : bool <- read InShare$[m, n, i] ; return in
       )
       ;;
       (when (isHonest(n))  --> 
         in : bool <- read InShare$PartyAdv[m, n, i] ; return in
       )      
     )
     ||
     (family InShare$-Sum[(bound N + 1 bound N + 2 dependentBound I)] 
             indices: m, n, i  
            bounds: bound N + 1 bound N + 2 dependentBound I ::=
        (when (m = 0) --> 
          in : bool <- read InShare$[0, n, i] ; return in
        )
        ;;
        (otherwise --> 
           x : bool <- read InShare$[m, n, i] ;
           s : bool <- read InShare$-Sum[m - 1, n, i] ;
           return xor((s, x))
        )    
     )
     ||
     (family InShare$-SumPartyAdv
              [bound N + 1 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 1 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read InShare$-Sum[m, n, i] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read InShare$-SumPartyAdv[m, n, i] ;
         return s
       )       
     )
     ||
     (family SendInShare[bound N + 2 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
        in : bool <- read InShare$[m, n, i] ; return in
     )  
     ||
     (family SendInSharePartyAdv
              [bound N + 2 bound N + 2 dependentBound I]  
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendInShare[m, n, i] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SendInSharePartyAdv[m, n, i] ;
         return s
       )        
     )   
     ||
     (family RcvdInSharePartyAdv
              [bound N + 2 bound N + 2 dependentBound I] 
             indices: n, m, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendInShare[n, m, i] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
          s : bool <- read RcvdInSharePartyAdv[n, m, i] ; 
          return s
       )        
     ) 
     ||
     (family InShare[bound N + 2 bound N + 2 dependentBound I] 
             indices: n, m, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
        s : bool <- read SendInShare[n, m, i] ; return s
     )        
     ||
     (family InSharePartyAdv
              [bound N + 2 bound N + 2 dependentBound I] 
             indices: n, m, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read InShare[n, m, i] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read InSharePartyAdv[n, m, i] ;
         return s
       )        
     )  
  ) 
  )
  and partyInductive = (
   newfamily SendBit[bound N + 2 bound N + 2 bound K]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily RcvdBit[bound N + 2 bound N + 2 bound K]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily Ctrb[bound N + 2 bound N + 2 bound K]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily CtrbSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in   
  family Circuit[bound N + 2 bound K]  
          indices: n, k 
         bounds: bound N + 2 bound K ::= 
   (when (isInputGate(k)) -->          
      ( 
       ( family SendBit[bound N + 2 bound N + 2 bound K ] 
                 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBit[n, m, k] ; return sb
 )
 ||
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBitPartyAdv[n, m, k] ; return sb 
 )               
 ||
 ( family RcvdBit[bound N + 2 bound N + 2 bound K ] 
           indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    rb : bool <- read RcvdBit[n, m, k] ; return rb
 )
 ||
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K ] 
          indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
   rb : bool <- read RcvdBitPartyAdv[n, m, k] ; return rb          
 ) 
 ||
 ( family Ctrb[bound N + 2 bound N + 2 bound K ] 
           indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    b : bool <- read Ctrb[n, m, k] ; return b           
 )
 ||
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K ] 
           indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbPartyAdv[n, m, k] ; return b           
 )  
 ||
 (family CtrbSum[bound N + 2 bound N + 2 bound K ] 
          indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbSum[n, m, k] ; return b  
 )
 ||
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K ] 
            indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbSumPartyAdv[n, m, k] ; return b           
 )  
 ||
     ( family Share[ bound N + 2 bound K] 
         indices: n, k 
         bounds: bound N + 2 bound K ::= 
       in : bool <- read InShare[n, wire0(k), wire1(k)] ; return in
     )
     ||
     (family SharePartyAdv[ bound N + 2 bound K]  indices: n, k  
             bounds: bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Share[n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SharePartyAdv[n, k] ; return s
       )        
     )
     ||
     ( family OTMsg-0[bound N + 2 bound N + 2 bound K ] 
               indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-0[n, m, k] ; return om
     )
     ||
     ( family OTMsg-1[bound N + 2 bound N + 2 bound K ]  
        indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-1[n, m, k] ; return om
     )
     ||
     ( family OTMsg-2[bound N + 2 bound N + 2 bound K ] 
       indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-2[n, m, k] ; return om
     )
     ||
     ( family OTMsg-3[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-3[n, m, k]; return om
     )
     ||
     ( family OTChc-0[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-0[m, n, k]; return oc
     )
     ||
     ( family OTChc-1[bound N + 2 bound N + 2 bound K ]  
        indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-1[m, n, k] ; return oc
     )
     )
   )
   ;;
   (when (isNotGate(k)) -->    
      (
       ( family SendBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBit[n, m, k]; return sb
 )
 ||
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBitPartyAdv[n, m, k]; return sb 
 )               
 ||
 ( family RcvdBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    rb : bool <- read RcvdBit[n, m, k]; return rb
 )
 ||
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
   rb : bool <- read RcvdBitPartyAdv[n, m, k]; 
      return rb          
 ) 
 ||
 ( family Ctrb[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    b : bool <- read Ctrb[n, m, k]; return b           
 )
 ||
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbPartyAdv[n, m, k]; return b           
 )  
 ||
 (family CtrbSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbSum[n, m, k]; return b  
 )
 ||
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSumPartyAdv[n, m, k]; return b           
 )  
 ||
     ( family Share[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::= 
        (when (n = N + 1) --> 
          x : bool <- read Share[n, wire0(k)] ; return neg(x)
        )
        ;;
        (when (not(n = N + 1))--> 
          s : bool <- read Share[n, wire0(k)] ; return s
        )
          
     )
     ||
     (family SharePartyAdv[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Share[n, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SharePartyAdv[n, k] ; return s
       )        
     )
     ||
     ( family OTMsg-0[bound N + 2 bound N + 2 bound K ]  
        indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-0[n, m, k] ; return om
     )
     ||
     ( family OTMsg-1[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-1[n, m, k] ; return om
     )
     ||
     ( family OTMsg-2[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-2[n, m, k] ; return om
     )
     ||
     ( family OTMsg-3[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-3[n, m, k] ; return om
     )
     ||
     ( family OTChc-0[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-0[m, n, k] ; return oc
     )
     ||
     ( family OTChc-1[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-1[m, n, k] ; return oc
     )
     ) 
   )
   ;;
   (when (isXorGate(k)) --> 
      ( 
       ( family SendBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBit[n, m, k]; return sb
 )
 ||
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBitPartyAdv[n, m, k]; 
       return sb 
 )               
 ||
 ( family RcvdBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    rb : bool <- read RcvdBit[n, m, k]; return rb
 )
 ||
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
   rb : bool <- read RcvdBitPartyAdv[n, m, k]; 
      return rb          
 ) 
 ||
 ( family Ctrb[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    b : bool <- read Ctrb[n, m, k]; return b           
 )
 ||
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbPartyAdv[n, m, k]; return b           
 )  
 ||
 (family CtrbSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbSum[n, m, k]; return b  
 )
 ||
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSumPartyAdv[n, m, k]; return b           
 )          
 ||
     ( family Share[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::= 
        x : bool <- read Share[n, wire0(k)] ;
        y : bool <- read Share[n, wire1(k)];
        return  xor((x, y))
     )
     ||
     (family SharePartyAdv[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Share[n, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SharePartyAdv[n, k]; 
            return s
       )        
     )
     ||
     ( family OTMsg-0[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-0[n, m, k];
          return om
     )
     ||
     ( family OTMsg-1[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-1[n, m, k];
          return om
     )
     ||
     ( family OTMsg-2[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-2[n, m, k];
          return om
     )
     ||
     ( family OTMsg-3[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-3[n, m, k];
          return om
     )
     ||
     ( family OTChc-0[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-0[m, n, k];
          return oc
     )
     ||
     ( family OTChc-1[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-1[m, n, k];
          return oc
     )   
   ) 
   )
      ;;
   (when (isAndGate(k)) -->
     ( 
     ( family SendBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
            x : bool <- read Share[n, wire0(k)] ; 
            y : bool <- read Share[n, wire1(k)] ;
            samp flip (())
       )
       ;;
       (when (m <= n) --> 
         sb : bool <- read SendBit[n, m, k];
          return sb
       )   
     )
     ||
      (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendBit[n, m, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SendBitPartyAdv[n, m, k]; 
            return s
       )        
     )
     ||
     ( family OTMsg-0[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
         b : bool <- read SendBit[n, m, k] ;
         x : bool <- read Share[n, wire0(k)] ;
         y : bool <- read Share[n, wire1(k)] ;
         return b
       )
       ;;
       (when (m  <= n) --> 
         om : bool <- read OTMsg-0[n, m, k];
          return om
       )   
     )
     ||
     ( family OTMsg-1[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
          b : bool <- read SendBit[n, m, k] ;
          x : bool <- read Share[n, wire0(k)] ;
          y : bool <- read Share[n, wire1(k)] ;
          return xor((x, b))
       )
       ;;
       (when (m  <= n) --> 
         om : bool <- read OTMsg-1[n, m, k];
          return om
       )   
     )
     ||
     ( family OTMsg-2[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
         b : bool <- read SendBit[n, m, k] ;
          x : bool <- read Share[n, wire0(k)] ;
          y : bool <- read Share[n, wire1(k)] ;
          return xor((y, b))
       )
       ;;
       (when (m  <= n) --> 
         om : bool <- read OTMsg-2[n, m, k];
          return om
       )   
     )
     ||
     ( family OTMsg-3[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
         b : bool <- read SendBit[n, m, k] ;
          x : bool <- read Share[n, wire0(k)] ;
          y : bool <- read Share[n, wire1(k)] ;
          return xor( ( xor( (x, y) ), b )  )   
       )
       ;;
       (when (m <= n) --> 
         om : bool <- read OTMsg-3[n, m, k];
          return om
       )   
     )
     ||
     ( family OTChc-0[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
      (when (m < n) --> 
         x : bool <- read Share[n, wire0(k)];
          return x
      )
       ;;
       (when (n  <= m) --> 
         oc : bool <- read OTChc-0[m, n, k];
          return oc
       )   
     )
     ||
     ( family OTChc-1[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (m < n) --> 
         x : bool <- read Share[n, wire1(k)];
          return x
       )
       ;;
       (when (n <= m) --> 
         oc : bool <- read OTChc-1[m, n, k];
          return oc
       )   
     )
     ||
     ( family RcvdBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
          out : bool <- read OTOut[m, n, k];
              return out
    )
    ||
     (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (isSemiHonest(n)) --> 
         s : bool <- read RcvdBit[n, m, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read RcvdBitPartyAdv[n, m, k]; 
            return s
       )        
     )
      ||
      ( family Ctrb[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
      (when (n < m) --> 
         s : bool <- read SendBit[n, m, k];
          return s
       )
       ;;
       (when (n = m) --> 
         x : bool <- read Share[n, wire0(k)] ;
         y : bool <- read Share[n, wire1(k)];
          return **((x, y))
          
       )
       ;;
       (when (m < n) --> 
         r : bool <- read RcvdBit[n, m, k];
          return r
       )   
     )
     ||
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
         s : bool <- read Ctrb[n, m, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read CtrbPartyAdv[n, m, k]; 
            return s
       )               
 )  
      ||
      (family CtrbSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when (m = 0) --> 
     b : bool <- read Ctrb[n, 0, k];
          return b
   )
   ;;
   (when (not (m = 0)) --> 
     s : bool <- read CtrbSum[n, m - 1, k] ;
     b : bool <- read Ctrb[n, m, k];
     return xor((s, b)) 
   )
 )
 ||
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (isSemiHonest(n)) --> 
         s : bool <- read CtrbSum[n, m, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read CtrbSumPartyAdv[n, m, k]; 
            return s
       )        
     )
      ||   
 ( family Share[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::= 
          bs : bool <- read CtrbSum[n, N + 1, k];
              return bs
 )   
 ||
     (family SharePartyAdv[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Share[n, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SharePartyAdv[n, k]; 
            return s
       )        
     ) 
     )
   )
   )
  and 
  partyFinal = (
   newfamily OutShare[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily OutShareSum[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K : bool in
   (
     (family SendOutShare[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isOutputWire(k)) --> 
         s : bool <- read Share[n, k] ; return s
       ) 
       ;; 
       (when (not (isOutputWire(k))) --> 
         s : bool <- read SendOutShare[m, n, k] ; return s
       )       
     )
     ||
     (family SendOutSharePartyAdv
               [bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendOutShare[m, n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SendOutSharePartyAdv[m, n, k] ;
         return s
       )       
     )
     ||
     (family RcvdOutSharePartyAdv
               [bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendOutShare[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read RcvdOutSharePartyAdv[n, m, k] ;
         return s
       )       
     )
     || 
     (family OutShare[bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       s : bool <- read SendOutShare[n, m, k] ; return s       
     )
     ||
     (family OutSharePartyAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read OutShare[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutSharePartyAdv[n, m, k] ;
         return s
       )       
     )
     ||
     (family OutShareSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (m = 0) --> 
         s : bool <- read OutShare[n, 0, k] ;
         return s
       )
       ;;
       (otherwise -->
         s : bool <- read OutShareSum[n, m - 1, k] ;
         x : bool <- read OutShare[n, m, k] ;
         return xor((s, x))
       )
     )        
     ||
     (family OutShareSumPartyAdv
              [bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read OutShareSum[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutShareSumPartyAdv[n, m, k] ;
         return s
       )       
     )
     ||
     (family Out[bound N + 2 bound K]  indices: n, k
            bounds: bound N + 2 bound K ::=
       s : bool <- read OutShareSum[n, N + 1, k] ;
       return s
     )
     ||
     (family OutPartyAdv[bound N + 2 bound K]  indices: n, k
             bounds: bound N + 2 bound K  ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Out[n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutPartyAdv[n, k] ;
         return s
       )       
     )
   )
   )
)
.

protocol restr =
   newfamily InShare[bound N + 2 bound N + 2 dependentBound I] 
              indices: n, m, i 
             bounds: bound N + 2 bound N + 2 dependentBound I : bool in   
   newfamily Share[bound N + 2 bound K]  
              indices: n, k 
             bounds: bound N + 2 bound K : bool in
(             
     restrInitial || restrInductive || restrFinal
  where    
   restrInitial = 
(   
    newfamily InShare$[bound N + 2 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I : bool in
  newfamily InShare$-Sum[bound N + 1 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 1 bound N + 2 dependentBound I : bool in       
   newfamily SendInShare[bound N + 2 bound N + 2 dependentBound I]
              indices: m, n, i 
             bounds: bound N + 2 bound N + 2 dependentBound I : bool in
   ( 
     (family InPartyAdv[bound N + 2 dependentBound I] 
            indices: n, i
            bounds: bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         in : bool <- read In[n, i] ; return in
       ) 
       ;; 
       (when (isHonest(n)) --> 
         in : bool <- read InPartyAdv[n, i] ; return in
       )       
     ) 
    ||
     (family InRcvdPartyAdv[bound N + 2 dependentBound I] 
        indices: n, i
            bounds:  bound N + 2 dependentBound I ::=
       (when (isHonest(n)) --> 
         x : bool <- read In[n, i] ; return ()
       ) 
       ;; 
       (when (isSemiHonest(n))  --> 
         in : unit <- read InRcvdPartyAdv[n, i] ; return in
       )       
     )
    ||
     (family InShare$[bound N + 2 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (m = N + 1) --> 
             x : bool <- read In[n, i] ;
             s : bool <- read InShare$-Sum[N, n, i] ;
             return xor( (x, s) )
       )
       ;;
       (otherwise --> 
         x : bool <- read In[n, i] ; samp flip (())
       )      
     )
     ||
     (family InShare$-Sum[(bound N + 1 bound N + 2 dependentBound I)] 
             indices: m, n, i  
            bounds: bound N + 1 bound N + 2 dependentBound I ::=
        (when (m = 0) --> 
          in : bool <- read InShare$[0, n, i] ; return in
        )
        ;;
        (otherwise --> 
           x : bool <- read InShare$[m, n, i] ;
           s : bool <- read InShare$-Sum[m - 1, n, i] ;
           return xor((s, x))
        )    
     )
     ||
       (family InShare$PartyAdv
               [bound N + 2 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
          in : bool <- read InShare$[m, n, i] ; return in
       )
       ;;
       (when (isHonest(n))  --> 
         in : bool <- read InShare$PartyAdv[m, n, i] ; return in
       )      
     )
     ||
     (family InShare$-SumPartyAdv
              [bound N + 1 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 1 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read InShare$-Sum[m, n, i] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read InShare$-SumPartyAdv[m, n, i] ;
         return s
       )       
     )
     ||
     (family SendInShare[bound N + 2 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
        in : bool <- read InShare$[m, n, i] ; return in
     )  
     ||
     (family SendInSharePartyAdv
              [bound N + 2 bound N + 2 dependentBound I]  
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendInShare[m, n, i] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SendInSharePartyAdv[m, n, i] ;
         return s
       )        
     )   
     ||
     (family RcvdInSharePartyAdv
              [bound N + 2 bound N + 2 dependentBound I] 
             indices: n, m, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendInShare[n, m, i] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
          s : bool <- read RcvdInSharePartyAdv[n, m, i] ; 
          return s
       )        
     ) 
     ||
    (family InShare[bound N + 2 bound N + 2 dependentBound I] 
             indices: n, m, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
        s : bool <- read SendInShare[n, m, i] ; return s
     )      
     ||
     (family InSharePartyAdv
              [bound N + 2 bound N + 2 dependentBound I] 
             indices: n, m, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read InShare[n, m, i] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read InSharePartyAdv[n, m, i] ;
         return s
       )        
     ) 
     ) `` end new    
 ) `` ends restrInitial
 and 
  restrInductive = 
(  
   newfamily OTMsg-0[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in  
   newfamily OTMsg-1[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in 
   newfamily OTMsg-2[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in 
   newfamily OTMsg-3[bound N + 2 bound N + 2 bound K ]
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in 
   newfamily OTChc-0[bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k 
             bounds: bound N + 2 bound N + 2 bound K : bool in  
   newfamily OTChc-1[bound N + 2 bound N + 2 bound K ]
              indices: m, n,  k 
             bounds: bound N + 2 bound N + 2 bound K : bool in                             
   newfamily OTOut[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in   
   newfamily SendBit[bound N + 2 bound N + 2 bound K]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily RcvdBit[bound N + 2 bound N + 2 bound K]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily Ctrb[bound N + 2 bound N + 2 bound K]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily CtrbSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in 
   ( `` start new
    family Circuit[bound N + 2 bound K]  
          indices: n, k 
         bounds: bound N + 2 bound K ::=  
      ( `` start circuit
       (when (isInputGate(k)) -->          
      ( 
         (family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-0[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-0OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-1[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c0 : bool <- read OTChc-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-0OtAdv[n, m, k] ; 
       return oc
     )   
   )
   ||
   (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c1 : bool <- read OTChc-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   ( family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-0[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-1[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-2[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-3[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m0 : bool <- read OTMsg-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m1 : bool <- read OTMsg-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m2 : bool <- read OTMsg-2[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m3 : bool <- read OTMsg-3[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTOutOtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       out : bool <- read OTOut[n, m, k] ; return out
     ) 
     ;;
     (when (isHonest(m))--> 
       out : bool <- read OTOutOtAdv[n, m, k] ; return out
     )   
   )
   ||
   (family OTOut[bound N + 2 bound N + 2 bound K]  
     indices: n, m, k 
     bounds: bound N + 2 bound N + 2 bound K ::=
     m0 : bool <- read OTMsg-0[n, m, k] ;
     m1 : bool <- read OTMsg-1[n, m, k] ;
     m2 : bool <- read OTMsg-2[n, m, k] ;
     m3 : bool <- read OTMsg-3[n, m, k] ;
     c0 : bool <- read OTChc-0[n, m, k] ;
     c1 : bool <- read OTChc-1[n, m, k] ;
         ( if c0 
         then if c1 then return m3 else return m2
         else if c1 then return m1 else return m0
         )
   ) 
   ||
       ( family SendBit[bound N + 2 bound N + 2 bound K ]
                 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBit[n, m, k] ; return sb
 )
 ||
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBitPartyAdv[n, m, k] ; return sb 
 )               
 ||
 ( family RcvdBit[bound N + 2 bound N + 2 bound K ] 
           indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    rb : bool <- read RcvdBit[n, m, k] ; return rb
 )
 ||
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K ] 
          indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
   rb : bool <- read RcvdBitPartyAdv[n, m, k] ; return rb          
 ) 
 ||
 ( family Ctrb[bound N + 2 bound N + 2 bound K ] 
           indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    b : bool <- read Ctrb[n, m, k] ; return b           
 )
 ||
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K ] 
           indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbPartyAdv[n, m, k] ; return b           
 )  
 ||
 (family CtrbSum[bound N + 2 bound N + 2 bound K ] 
          indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbSum[n, m, k] ; return b  
 )
 ||
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K ] 
            indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbSumPartyAdv[n, m, k] ; return b           
 )  
 ||
     ( family Share[ bound N + 2 bound K] 
         indices: n, k 
         bounds: bound N + 2 bound K ::= 
       in : bool <- read InShare[n, wire0(k), wire1(k)] ; return in
     )
     ||
     (family SharePartyAdv[ bound N + 2 bound K]  indices: n, k  
             bounds: bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Share[n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SharePartyAdv[n, k] ; return s
       )        
     )
     ||
     ( family OTMsg-0[bound N + 2 bound N + 2 bound K ] 
               indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-0[n, m, k] ; return om
     )
     ||
     ( family OTMsg-1[bound N + 2 bound N + 2 bound K ]  
        indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-1[n, m, k] ; return om
     )
     ||
     ( family OTMsg-2[bound N + 2 bound N + 2 bound K ] 
       indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-2[n, m, k] ; return om
     )
     ||
     ( family OTMsg-3[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-3[n, m, k]; return om
     )
     ||
     ( family OTChc-0[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-0[m, n, k]; return oc
     )
     ||
     ( family OTChc-1[bound N + 2 bound N + 2 bound K ]  
        indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-1[m, n, k] ; return oc
     )
     )
   )
   ;;
   (when (isNotGate(k)) -->    
      (    (family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-0[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-0OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-1[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c0 : bool <- read OTChc-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-0OtAdv[n, m, k] ; 
       return oc
     )   
   )
   ||
   (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c1 : bool <- read OTChc-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   ( family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-0[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-1[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-2[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-3[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m0 : bool <- read OTMsg-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m1 : bool <- read OTMsg-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m2 : bool <- read OTMsg-2[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m3 : bool <- read OTMsg-3[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTOutOtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       out : bool <- read OTOut[n, m, k] ; return out
     ) 
     ;;
     (when (isHonest(m))--> 
       out : bool <- read OTOutOtAdv[n, m, k] ; return out
     )   
   )
   ||
   (family OTOut[bound N + 2 bound N + 2 bound K]  
     indices: n, m, k 
     bounds: bound N + 2 bound N + 2 bound K ::=
     m0 : bool <- read OTMsg-0[n, m, k] ;
     m1 : bool <- read OTMsg-1[n, m, k] ;
     m2 : bool <- read OTMsg-2[n, m, k] ;
     m3 : bool <- read OTMsg-3[n, m, k] ;
     c0 : bool <- read OTChc-0[n, m, k] ;
     c1 : bool <- read OTChc-1[n, m, k] ;
         ( if c0 
         then if c1 then return m3 else return m2
         else if c1 then return m1 else return m0
         )
   ) 
   ||
       ( family SendBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBit[n, m, k]; return sb
 )
 ||
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBitPartyAdv[n, m, k]; return sb 
 )               
 ||
 ( family RcvdBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    rb : bool <- read RcvdBit[n, m, k]; return rb
 )
 ||
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
   rb : bool <- read RcvdBitPartyAdv[n, m, k]; 
      return rb          
 ) 
 ||
 ( family Ctrb[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    b : bool <- read Ctrb[n, m, k]; return b           
 )
 ||
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbPartyAdv[n, m, k]; return b           
 )  
 ||
 (family CtrbSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbSum[n, m, k]; return b  
 )
 ||
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSumPartyAdv[n, m, k]; return b           
 )  
 ||
     ( family Share[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::= 
        (when (n = N + 1) --> 
          x : bool <- read Share[n, wire0(k)] ; return neg(x)
        )
        ;;
        (when (not(n = N + 1))--> 
          s : bool <- read Share[n, wire0(k)] ; return s
        )
          
     )
     ||
     (family SharePartyAdv[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Share[n, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SharePartyAdv[n, k] ; return s
       )        
     )
     ||
     ( family OTMsg-0[bound N + 2 bound N + 2 bound K ]  
        indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-0[n, m, k] ; return om
     )
     ||
     ( family OTMsg-1[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-1[n, m, k] ; return om
     )
     ||
     ( family OTMsg-2[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-2[n, m, k] ; return om
     )
     ||
     ( family OTMsg-3[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-3[n, m, k] ; return om
     )
     ||
     ( family OTChc-0[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-0[m, n, k] ; return oc
     )
     ||
     ( family OTChc-1[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-1[m, n, k] ; return oc
     )
     ) 
   )
   ;;
   (when (isXorGate(k)) --> 
      (    (family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-0[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-0OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-1[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c0 : bool <- read OTChc-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-0OtAdv[n, m, k] ; 
       return oc
     )   
   )
   ||
   (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c1 : bool <- read OTChc-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   ( family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-0[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-1[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-2[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-3[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m0 : bool <- read OTMsg-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m1 : bool <- read OTMsg-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m2 : bool <- read OTMsg-2[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m3 : bool <- read OTMsg-3[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTOutOtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       out : bool <- read OTOut[n, m, k] ; return out
     ) 
     ;;
     (when (isHonest(m))--> 
       out : bool <- read OTOutOtAdv[n, m, k] ; return out
     )   
   )
   ||
   (family OTOut[bound N + 2 bound N + 2 bound K]  
     indices: n, m, k 
     bounds: bound N + 2 bound N + 2 bound K ::=
     m0 : bool <- read OTMsg-0[n, m, k] ;
     m1 : bool <- read OTMsg-1[n, m, k] ;
     m2 : bool <- read OTMsg-2[n, m, k] ;
     m3 : bool <- read OTMsg-3[n, m, k] ;
     c0 : bool <- read OTChc-0[n, m, k] ;
     c1 : bool <- read OTChc-1[n, m, k] ;
         ( if c0 
         then if c1 then return m3 else return m2
         else if c1 then return m1 else return m0
         )
   ) 
   ||
       ( family SendBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBit[n, m, k]; return sb
 )
 ||
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBitPartyAdv[n, m, k]; 
       return sb 
 )               
 ||
 ( family RcvdBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    rb : bool <- read RcvdBit[n, m, k]; return rb
 )
 ||
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
   rb : bool <- read RcvdBitPartyAdv[n, m, k]; 
      return rb          
 ) 
 ||
 ( family Ctrb[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    b : bool <- read Ctrb[n, m, k]; return b           
 )
 ||
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbPartyAdv[n, m, k]; return b           
 )  
 ||
 (family CtrbSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbSum[n, m, k]; return b  
 )
 ||
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSumPartyAdv[n, m, k]; return b           
 )          
 ||
     ( family Share[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::= 
        x : bool <- read Share[n, wire0(k)] ;
        y : bool <- read Share[n, wire1(k)];
        return  xor((x, y))
     )
     ||
     (family SharePartyAdv[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Share[n, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SharePartyAdv[n, k]; 
            return s
       )        
     )
     ||
     ( family OTMsg-0[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-0[n, m, k];
          return om
     )
     ||
     ( family OTMsg-1[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-1[n, m, k];
          return om
     )
     ||
     ( family OTMsg-2[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-2[n, m, k];
          return om
     )
     ||
     ( family OTMsg-3[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-3[n, m, k];
          return om
     )
     ||
     ( family OTChc-0[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-0[m, n, k];
          return oc
     )
     ||
     ( family OTChc-1[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-1[m, n, k];
          return oc
     )   
   ) 
   )
      ;;
   (when (isAndGate(k)) -->
     ( 
        (family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-0[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-0OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-1[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c0 : bool <- read OTChc-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-0OtAdv[n, m, k] ; 
       return oc
     )   
   )
   ||
   (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c1 : bool <- read OTChc-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   ( family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-0[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-1[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-2[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-3[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m0 : bool <- read OTMsg-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m1 : bool <- read OTMsg-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m2 : bool <- read OTMsg-2[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m3 : bool <- read OTMsg-3[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTOutOtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       out : bool <- read OTOut[n, m, k] ; return out
     ) 
     ;;
     (when (isHonest(m))--> 
       out : bool <- read OTOutOtAdv[n, m, k] ; return out
     )   
   )
   ||
   (family OTOut[bound N + 2 bound N + 2 bound K]  
     indices: n, m, k 
     bounds: bound N + 2 bound N + 2 bound K ::=
     m0 : bool <- read OTMsg-0[n, m, k] ;
     m1 : bool <- read OTMsg-1[n, m, k] ;
     m2 : bool <- read OTMsg-2[n, m, k] ;
     m3 : bool <- read OTMsg-3[n, m, k] ;
     c0 : bool <- read OTChc-0[n, m, k] ;
     c1 : bool <- read OTChc-1[n, m, k] ;
         ( if c0 
         then if c1 then return m3 else return m2
         else if c1 then return m1 else return m0
         )
   ) 
   ||
   
     ( family SendBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
            x : bool <- read Share[n, wire0(k)] ; 
            y : bool <- read Share[n, wire1(k)] ;
            samp flip (())
       )
       ;;
       (when (m <= n) --> 
         sb : bool <- read SendBit[n, m, k];
          return sb
       )   
     )
     ||
      (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendBit[n, m, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SendBitPartyAdv[n, m, k]; 
            return s
       )        
     )
     ||
     ( family OTMsg-0[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
         b : bool <- read SendBit[n, m, k] ;
         x : bool <- read Share[n, wire0(k)] ;
         y : bool <- read Share[n, wire1(k)] ;
         return b
       )
       ;;
       (when (m  <= n) --> 
         om : bool <- read OTMsg-0[n, m, k];
          return om
       )   
     )
     ||
     ( family OTMsg-1[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
          b : bool <- read SendBit[n, m, k] ;
          x : bool <- read Share[n, wire0(k)] ;
          y : bool <- read Share[n, wire1(k)] ;
          return xor((x, b))
       )
       ;;
       (when (m  <= n) --> 
         om : bool <- read OTMsg-1[n, m, k];
          return om
       )   
     )
     ||
     ( family OTMsg-2[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
         b : bool <- read SendBit[n, m, k] ;
          x : bool <- read Share[n, wire0(k)] ;
          y : bool <- read Share[n, wire1(k)] ;
          return xor((y, b))
       )
       ;;
       (when (m  <= n) --> 
         om : bool <- read OTMsg-2[n, m, k];
          return om
       )   
     )
     ||
     ( family OTMsg-3[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
         b : bool <- read SendBit[n, m, k] ;
          x : bool <- read Share[n, wire0(k)] ;
          y : bool <- read Share[n, wire1(k)] ;
          return xor( ( xor( (x, y) ), b )  )   
       )
       ;;
       (when (m <= n) --> 
         om : bool <- read OTMsg-3[n, m, k];
          return om
       )   
     )
     ||
     ( family OTChc-0[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
      (when (m < n) --> 
         x : bool <- read Share[n, wire0(k)];
          return x
      )
       ;;
       (when (n <= m) --> 
         oc : bool <- read OTChc-0[m, n, k];
          return oc
       )   
     )
     ||
     ( family OTChc-1[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (m < n) --> 
         x : bool <- read Share[n, wire1(k)];
          return x
       )
       ;;
       (when (n  <= m) --> 
         oc : bool <- read OTChc-1[m, n, k];
          return oc
       )   
     )
     ||
     ( family RcvdBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
          out : bool <- read OTOut[m, n, k];
              return out
    )
    ||
     (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (isSemiHonest(n)) --> 
         s : bool <- read RcvdBit[n, m, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read RcvdBitPartyAdv[n, m, k]; 
            return s
       )        
     )
      ||
      ( family Ctrb[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
      (when (n < m) --> 
         s : bool <- read SendBit[n, m, k];
          return s
       )
       ;;
       (when (n = m) --> 
         x : bool <- read Share[n, wire0(k)] ;
         y : bool <- read Share[n, wire1(k)];
          return **((x, y))
          
       )
       ;;
       (when (m < n) --> 
         r : bool <- read RcvdBit[n, m, k];
          return r
       )   
     )
     ||
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
         s : bool <- read Ctrb[n, m, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read CtrbPartyAdv[n, m, k]; 
            return s
       )               
 )  
      ||
      (family CtrbSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when (m = 0) --> 
     b : bool <- read Ctrb[n, 0, k];
          return b
   )
   ;;
   (when (not (m = 0)) --> 
     s : bool <- read CtrbSum[n, m - 1, k] ;
     b : bool <- read Ctrb[n, m, k];
     return xor((s, b)) 
   )
 )
 ||
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (isSemiHonest(n)) --> 
         s : bool <- read CtrbSum[n, m, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read CtrbSumPartyAdv[n, m, k]; 
            return s
       )        
     )
      ||   
 ( family Share[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::= 
          bs : bool <- read CtrbSum[n, N + 1, k];
              return bs
 )   
 ||
     (family SharePartyAdv[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Share[n, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SharePartyAdv[n, k]; 
            return s
       )        
     ) 
     )
   )    
      ) `` end circuit
   
   ) `` end new
     
)  `` ends restrinductive
and  
restrFinal = 
(
   newfamily SendOutShare[bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k 
             bounds: bound N + 2 bound N + 2 bound K : bool in          
   newfamily OutShare[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily OutShareSum[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K : bool in
   ( 
     (family SendOutShare[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isOutputWire(k)) --> 
         s : bool <- read Share[n, k] ; return s
       ) 
       ;; 
       (when (not (isOutputWire(k))) --> 
         s : bool <- read SendOutShare[m, n, k] ; return s
       )       
     )
     ||
    (family SendOutSharePartyAdv
               [bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendOutShare[m, n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SendOutSharePartyAdv[m, n, k] ;
         return s
       )       
     )
     ||
     (family RcvdOutSharePartyAdv
               [bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendOutShare[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read RcvdOutSharePartyAdv[n, m, k] ;
         return s
       )       
     )
     || 
     (family OutShare[bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       s : bool <- read SendOutShare[n, m, k] ; return s       
     )
     ||
     (family OutSharePartyAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read OutShare[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutSharePartyAdv[n, m, k] ;
         return s
       )       
     )
     ||
     (family OutShareSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (m = 0) --> 
         s : bool <- read OutShare[n, 0, k] ;
         return s
       )
       ;;
       (otherwise -->
         s : bool <- read OutShareSum[n, m - 1, k] ;
         x : bool <- read OutShare[n, m, k] ;
         return xor((s, x))
       )
     )        
     ||
     (family OutShareSumPartyAdv
              [bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read OutShareSum[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutShareSumPartyAdv[n, m, k] ;
         return s
       )       
     )
     ||
     (family Out[bound N + 2 bound K]  indices: n, k
            bounds: bound N + 2 bound K ::=
       s : bool <- read OutShareSum[n, N + 1, k] ;
       return s
     )
     ||
     (family OutPartyAdv[bound N + 2 bound K]  indices: n, k
             bounds: bound N + 2 bound K  ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Out[n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutPartyAdv[n, k] ;
         return s
       )       
     )
   ) `` end new

) `` ends restrFinal

) . `` ends the where and the protocol declaration

`` here we have some intermediate protocols that will be used to check intermediate steps

`` pInt1


protocol pInt1 = 
 newfamily InShare[bound N + 2 bound N + 2 dependentBound I] 
   indices: n, m, i 
   bounds: bound N + 2 bound N + 2 dependentBound I : bool in 
 newfamily Share[bound N + 2 bound K] 
   indices: n, k 
   bounds: bound N + 2 bound K : bool in 
 (simpleRestrInitial || splitCirc1 || restrFinal)
where
simpleRestrInitial = 
( newfamily InShare$[bound N + 2 bound N + 2 dependentBound I] 
  indices: m, n, i 
  bounds: bound N + 2 bound N + 2 dependentBound I : bool in
 newfamily InShare$-Sum[bound N + 1 bound N + 2 dependentBound I] 
  indices: m, n, i 
  bounds: bound N + 1 bound N + 2 dependentBound I : bool in
  (
  (family InPartyAdv[bound N + 2 dependentBound I]
  indices: n, i bounds: bound N + 2 dependentBound I ::= 
   (when (isSemiHonest(n)) --> 
     nf(in : bool <- read In[n, i], return in) 
   )  ;; 
   (when (isHonest(n)) --> nf(in : bool <- read InPartyAdv[n, i], return in)
   )
)
||
(
family InRcvdPartyAdv[bound N + 2 dependentBound I]
  indices: n, i bounds: bound N + 2 dependentBound I ::= 
  (when (isHonest(n)) --> 
    nf(x : bool <- read In[n, i], return () )
  ) ;;
  ( when (isSemiHonest(n)) --> nf(in : unit <- read InRcvdPartyAdv[n, i], return in)
  )
)
||
(
family InShare[bound N + 2 bound N + 2 dependentBound I]
  indices: n, m, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
 nf(in : bool <- read InShare$[n, m, i], return in)
)
||
(
family InShare$[bound N + 2 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when (m = N + 1) --> 
    nf((s : bool <- read InShare$-Sum[N, n, i]) 
        x : bool <- read In[n, i], 
        return xor((x, s)))
  ) ;; 
  (otherwise --> nf(x : bool <- read In[n, i], samp flip (()) )
  )
)
||
(
family InShare$-Sum[bound N + 1 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 1 bound N + 2 dependentBound I ::= 
  (when (0 = m) --> 
    nf(in : bool <- read InShare$[0, n, i], return in) 
  ) ;; 
  (otherwise --> 
    nf((s : bool <- read InShare$-Sum[m - 1, n, i]) 
        x : bool <- read InShare$[m, n, i], 
        return xor((s, x)))
  )      
)
||
(
family InShare$-SumPartyAdv[bound N + 1 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 1 bound N + 2 dependentBound I ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read InShare$-Sum[m, n, i], return s) 
  ) ;;
  (when (isHonest(n)) --> 
    nf(s : bool <- read InShare$-SumPartyAdv[m, n, i], return s)
  )  
)
||
(
family InShare$PartyAdv[bound N + 2 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
 (when (isSemiHonest(n)) --> 
    nf(in : bool <- read InShare$[m, n, i], return in) 
 ) ;; 
 (when (isHonest(n)) --> 
   nf(in : bool <- read InShare$PartyAdv[m, n, i], return in)
 )  
)
||
(
family InSharePartyAdv[bound N + 2 bound N + 2 dependentBound I]
  indices: n, m, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when (isSemiHonest(n)) --> nf(s : bool <- read InShare[n, m, i], return s)
  ) 
  ;; 
  (when (isHonest(n)) --> nf(s : bool <- read InSharePartyAdv[n, m, i], return s))
)
||
(
family RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I]
  indices: n, m, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when (isSemiHonest(n)) --> nf(in : bool <- read InShare$[n, m, i], return in) 
  ) ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read RcvdInSharePartyAdv[n, m, i], return s)
  )  
)
||
(
family SendInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when (isSemiHonest(n)) --> 
    nf(in : bool <- read InShare$[m, n, i], return in)
  ) ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read SendInSharePartyAdv[m, n, i], return s)
  )  
)
  )
)`` end simplRestrInitial  
and
splitCirc1 = (
 newfamily SendBit[bound N + 2 bound N + 2 bound K] 
  indices: n, m, k 
  bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily RcvdBit[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k 
   bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily Ctrb[bound N + 2 bound N + 2 bound K] 
  indices: n, m, k 
  bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily CtrbSum[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k 
   bounds: bound N + 2 bound N + 2 bound K : bool in
 (adv || shares)
 where 
adv = (
   family Adv[bound K] indices: k bounds: bound K ::=
  (`` start group 
(when (isInputGate(k)) --> 
(
(family CtrbPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool  <- read CtrbPartyAdv[n, m, k], return b) 
)
||
(
family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(b : bool <- read CtrbSumPartyAdv[n, m, k], return b) 
)
||
(
family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-0OtAdv[n, m, k], return oc) 
)
||
(

family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-1OtAdv[n, m, k], return oc)
)
||
(
family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(oc : unit <- read OTChcRcvd-0OtAdv[n, m, k], return oc)
)
||
(

family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : unit <- read OTChcRcvd-1OtAdv[n, m, k], return oc) 
)
||
(

family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-0OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : bool <- read OTMsg-1OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-3OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-0OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : unit <- read OTMsgRcvd-1OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-3OtAdv[n, m, k], return om) 
)
||
(
family OTOutOtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(out : bool <- read OTOutOtAdv[n, m, k], return out) 
)
||
(
family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb :  bool <- read RcvdBitPartyAdv[n, m, k], return rb) 
)
||
(
family SendBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb :  bool <- read SendBitPartyAdv[n, m, k], return sb) 
)
||
(
family SharePartyAdv[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read  Share[n, k], return s) 
  )  
  ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read SharePartyAdv[n, k], return s)
  )  
)
) `` end input gate
) `` end when
;;
(when (isNotGate(k)) --> 
(
(family CtrbPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool  <- read CtrbPartyAdv[n, m, k], return b) 
)
||
(
family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(b : bool <- read CtrbSumPartyAdv[n, m, k], return b) 
)
||
(
family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-0OtAdv[n, m, k], return oc) 
)
||
(

family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-1OtAdv[n, m, k], return oc)
)
||
(
family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(oc : unit <- read OTChcRcvd-0OtAdv[n, m, k], return oc)
)
||
(

family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : unit <- read OTChcRcvd-1OtAdv[n, m, k], return oc) 
)
||
(

family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-0OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : bool <- read OTMsg-1OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-3OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-0OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : unit <- read OTMsgRcvd-1OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-3OtAdv[n, m, k], return om) 
)
||
(
family OTOutOtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(out : bool <- read OTOutOtAdv[n, m, k], return out) 
)
||
(
family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb :  bool <- read RcvdBitPartyAdv[n, m, k], return rb) 
)
||
(
family SendBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb :  bool <- read SendBitPartyAdv[n, m, k], return sb) 
)
||
(
family SharePartyAdv[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read  Share[n, k], return s) 
  )  
  ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read SharePartyAdv[n, k], return s)
  )  
)
) `` end not gate
) `` end when
;;
(when (isXorGate(k)) --> 
(
(family CtrbPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool  <- read CtrbPartyAdv[n, m, k], return b) 
)
||
(
family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(b : bool <- read CtrbSumPartyAdv[n, m, k], return b) 
)
||
(
family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-0OtAdv[n, m, k], return oc) 
)
||
(

family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-1OtAdv[n, m, k], return oc)
)
||
(
family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(oc : unit <- read OTChcRcvd-0OtAdv[n, m, k], return oc)
)
||
(

family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : unit <- read OTChcRcvd-1OtAdv[n, m, k], return oc) 
)
||
(

family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-0OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : bool <- read OTMsg-1OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-3OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-0OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : unit <- read OTMsgRcvd-1OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-3OtAdv[n, m, k], return om) 
)
||
(
family OTOutOtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(out : bool <- read OTOutOtAdv[n, m, k], return out) 
)
||
(
family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb :  bool <- read RcvdBitPartyAdv[n, m, k], return rb) 
)
||
(
family SendBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb :  bool <- read SendBitPartyAdv[n, m, k], return sb) 
)
||
(
family SharePartyAdv[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read  Share[n, k], return s) 
  )
  ;; 
  ( when (isHonest(n)) --> 
    nf(s : bool <- read SharePartyAdv[n, k], return s)
  )  
)
) `` end xor gate
) `` end when
;;

(when (isAndGate(k)) --> 
(
(family CtrbPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=  
   (when (isSemiHonest(n)) --> nf(s : bool <- read Ctrb[n, m, k], return s) 
   )
   ;; 
   (when (isHonest(n)) --> nf(s : bool <- read CtrbPartyAdv[n, m, k], return s)
   )
)
||
(
family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when (isSemiHonest(n)) --> 
     nf(s : bool <- read CtrbSum[n, m, k], return s) 
   )  
   ;; 
   (when (isHonest(n)) --> 
   nf(s : bool <- read CtrbSumPartyAdv[n, m, k], return s)
   )
)
||
(
family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isSemiHonest(m))) --> 
      nf(x : bool <- read Share[m, wire0(k)], return x) 
    )  
    ;; 
    (when ((m <= n) or (isHonest(m)) ) --> 
    nf(oc : bool <- read OTChc-0OtAdv[n, m, k], return oc)
    )
)
||
(

family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isSemiHonest(m))) --> 
     nf(x : bool <- read Share[m, wire1(k)], return x) 
    ) 
    ;; 
       (when ((m <= n) or (isHonest(m)) ) -->  
        nf(oc : bool <- read OTChc-1OtAdv[n, m, k], return oc)
       ) 
)
||
(
family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when ((n < m) and (isHonest(m))) --> 
    nf(x : bool <- read Share[m, wire0(k)], return()) 
   ) 
   ;; 
   (when ((m <= n) or (isSemiHonest(m))) --> 
    nf(oc : unit <- read OTChcRcvd-0OtAdv[n, m, k], return oc)
   ) 
)
||
(

family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 (when ((n < m) and (isHonest(m))) --> 
   nf(x : bool <- read Share[m, wire1(k)], return()) 
 )  
  ;; 
  (when ((m <= n) or (isSemiHonest(m))) --> 
   nf(oc : unit <- read OTChcRcvd-1OtAdv[n, m, k], return oc)
   )
)
||
(

family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isSemiHonest(n))) --> 
     nf((b : bool <- read SendBit[n, m, k])
        (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return b) 
    )    
    ;; 
    (when ((m <= n) or (isHonest(n))) --> 
     nf(om : bool <- read OTMsg-0OtAdv[n, m, k], return om)
    ) 
)
||
(
family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isSemiHonest(n))) --> 
         nf((b : bool <- read SendBit[n, m, k])
            (x : bool <- read Share[n, wire0(k)]) 
             y : bool <- read Share[n, wire1(k)], return xor((x, b))) 
    )
   ;; 
   (when ((m <= n) or (isHonest(n))) -->  
     nf(om : bool <- read OTMsg-1OtAdv[n, m, k], return om)
   )
)
||
(

family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   ( when ((n < m) and (isSemiHonest(n))) -->  
    nf((b : bool <- read SendBit[n, m, k])
       (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return xor((y, b))
      )
   )    
    ;; 
    (when ((m <= n) or (isHonest(n)))
    --> nf(om : bool <- read OTMsg-2OtAdv[n, m, k], return om)
    ) 
)
||
(

family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when ((n < m) and (isSemiHonest(n))) -->  
    nf((b : bool <- read SendBit[n, m, k])
       (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return xor((xor((x, y)), b))
      )
   )     
    ;; 
    (when ((m <= n) or (isHonest(n))) --> 
      nf(om : bool <- read OTMsg-3OtAdv[n, m, k], return om)
    )  
)
||
(
family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=  
  (when ((n < m) and (isHonest(n))) --> 
    nf((b : bool <- read SendBit[n, m, k])
       (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return()
      )
  )      
    ;; 
  (when ((m <= n) or (isSemiHonest(n))) -->  
    nf(om : unit <- read OTMsgRcvd-0OtAdv[n, m, k], return om)
  )  
)
||
(
family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when ((n < m) and (isHonest(n))) --> 
    nf((b : bool <- read SendBit[n, m, k])
       (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return()
      )
   )        
    ;; 
    (when ((m <= n) or (isSemiHonest(n))) --> 
     nf(om : unit <- read OTMsgRcvd-1OtAdv[n, m, k], return om)
    ) 
)
||
(
family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isHonest(n))) --> 
     nf((b : bool <- read SendBit[n, m, k])
        (x : bool <- read Share[n, wire0(k)]) 
         y : bool <- read Share[n, wire1(k)], return()
       ) 
    )   
    ;; 
    (when ((m <= n) or (isSemiHonest(n))) --> 
      nf(om : unit <- read OTMsgRcvd-2OtAdv[n, m, k], return om)
    )  
)
||
(
family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isHonest(n))) --> 
   nf((b : bool <-  read SendBit[n, m, k])
      (x : bool <- read Share[n, wire0(k)]) 
       y : bool <- read Share[n, wire1(k)], return()
     ) 
  )   
    ;; 
   ( when ((m <= n) or (isSemiHonest(n))) --> 
    nf(om : unit <- read OTMsgRcvd-3OtAdv[n, m, k], return om)
   ) 
)
||
(
family OTOutOtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
     (when (isSemiHonest(m)) --> 
       nf(out : bool <- read RcvdBit[m, n, k], return out)
     )  
     ;; 
     (when (isHonest(m)) --> 
       nf(out : bool <- read OTOutOtAdv[n, m, k], return out)
     )  
)
||
(
family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read RcvdBit[n, m, k], return s) 
  )  
    ;; 
   ( when (isHonest(n))  --> 
     nf(s : bool <- read RcvdBitPartyAdv[n, m, k], return s)
   )  
)
||
(
family SendBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read SendBit[n, m, k], return s) 
  ) ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read SendBitPartyAdv[n, m, k], return s)
  )  
)
||
(
family SharePartyAdv[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::=  
   (when (isSemiHonest(n)) --> 
     nf(s : bool <- read Share[n, k], return s) 
   )  
   ;; 
   (when (isHonest(n)) --> 
     nf(s : bool <- read SharePartyAdv[n, k], return s)
   )
)     
) `` end and gate
) `` end when
)`` end group   
 )

 and 
 shares = (
  family Shares[bound K] indices: k bounds: bound K ::=
   
   (when (isInputGate(k)) --> 
   (
    (family Ctrb[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
     nf(b : bool <- read Ctrb[n, m, k], return b) 
    )
    ||
(
family CtrbSum[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool <- read CtrbSum[n, m, k], return b) 
)
||
(
family RcvdBit[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb : bool <- read RcvdBit[n, m, k], return rb) 
)
||
(
family SendBit[bound N + 2 bound N + 2 bound K] 
 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb : bool <- read SendBit[n, m, k], return sb) 
)
||
(
family Share[bound N + 2 bound K] 
 indices: n, k bounds: bound N + 2 bound K ::=
  nf(in : bool <- read InShare[n, wire0(k), wire1(k)], return in) 
)
   
   ) ``end input gate
   ) ``end when 
 ;;
( when (isNotGate(k)) -->
(
 (family Ctrb[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
     nf(b : bool <- read Ctrb[n, m, k], return b) 
)
||
(
family CtrbSum[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool <- read CtrbSum[n, m, k], return b) 
)
||
(
family RcvdBit[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb : bool <- read RcvdBit[n, m, k], return rb) 
)
||
(
family SendBit[bound N + 2 bound N + 2 bound K] 
 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb : bool <- read SendBit[n, m, k], return sb) 
)
||
(
family Share[bound N + 2 bound K] 
 indices: n, k bounds: bound N + 2 bound K ::=
  (when (n = N + 1) --> nf(x : bool <- read Share[n, wire0(k)], return neg(x)) 
  )
  ;; 
  (when (not (n = N + 1)) --> nf(s : bool <- read Share[n, wire0(k)], return s)  
  )
)
) `` end not gate
) `` end when
;; 
( when (isXorGate(k)) -->
(
 (family Ctrb[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
     nf(b : bool <- read Ctrb[n, m, k], return b) 
)
||
(
family CtrbSum[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool <- read CtrbSum[n, m, k], return b) 
)
||
(
family RcvdBit[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb : bool <- read RcvdBit[n, m, k], return rb) 
)
||
(
family SendBit[bound N + 2 bound N + 2 bound K] 
 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb : bool <- read SendBit[n, m, k], return sb) 
)
||
(
family Share[bound N + 2 bound K] 
 indices: n, k bounds: bound N + 2 bound K ::=
  nf((x : bool <- read Share[n, wire0(k)]) y : bool <- read
    Share[n, wire1(k)], return xor((x, y))) 
)
) `` end xor gate
) `` end when  
;; 
( when (isAndGate(k)) --> 
(
(family Ctrb[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when (n < m) --> nf(s : bool <- read SendBit[n, m, k], return s) )
    ;; 
    (when (m = n) --> 
     nf((x : bool <- read Share[n, wire0(k)]) 
         y : bool <- read Share[n, wire1(k)], return **((x, y))
       ) 
    )   
    ;;
    (when (m < n) --> nf(r : bool <- read RcvdBit[n, m, k], return r)
    )
)
||
(
family CtrbSum[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=  
  (when (0 = m)  --> nf(b : bool <- read Ctrb[n, 0, k], return b) )
  ;; 
  (when (not (0 = m)) --> 
   nf((b : bool <- read Ctrb[n, m, k]) 
       s : bool <- read CtrbSum[n, m - 1, k], return xor((s, b)) 
     )
  )   
)
||
(
family RcvdBit[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   nf((b : bool <- read SendBit[m, n, k])
      (xm : bool <- read Share[m, wire0(k)])
      (xn : bool <- read Share[n, wire0(k)])
      (ym : bool <- read Share[m, wire1(k)]) 
       yn : bool <- read Share[n, wire1(k)], 
        return xor((xor((**((xm, yn)), **((xn, ym)))), b))
     )
)
||
(
family SendBit[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 (when (n < m) --> 
  nf((x : bool <- read Share[n, wire0(k)]) 
      y : bool <- read Share[n, wire1(k)], samp flip(())
    ) 
 )   
 ;; 
 (when (m <= n) --> nf(sb : bool <- read SendBit[n, m, k], return sb)
 )
)
||
(
family Share[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::= 
  nf(bs : bool <- read CtrbSum[n, N + 1, k], return bs)
)
) `` end and gate
) `` end when
   
  ) `` end shares

) `` end splitcirc
and 
restrFinal = 
(
   newfamily SendOutShare[bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k 
             bounds: bound N + 2 bound N + 2 bound K : bool in          
   newfamily OutShare[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily OutShareSum[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K : bool in
   ( 
     (family SendOutShare[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isOutputWire(k)) --> 
         s : bool <- read Share[n, k] ; return s
       ) 
       ;; 
       (when (not (isOutputWire(k))) --> 
         s : bool <- read SendOutShare[m, n, k] ; return s
       )       
     )
     ||
    (family SendOutSharePartyAdv
               [bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendOutShare[m, n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SendOutSharePartyAdv[m, n, k] ;
         return s
       )       
     )
     ||
     (family RcvdOutSharePartyAdv
               [bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendOutShare[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read RcvdOutSharePartyAdv[n, m, k] ;
         return s
       )       
     )
     || 
     (family OutShare[bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       s : bool <- read SendOutShare[n, m, k] ; return s       
     )
     ||
     (family OutSharePartyAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read OutShare[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutSharePartyAdv[n, m, k] ;
         return s
       )       
     )
     ||
     (family OutShareSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (m = 0) --> 
         s : bool <- read OutShare[n, 0, k] ;
         return s
       )
       ;;
       (otherwise -->
         s : bool <- read OutShareSum[n, m - 1, k] ;
         x : bool <- read OutShare[n, m, k] ;
         return xor((s, x))
       )
     )        
     ||
     (family OutShareSumPartyAdv
              [bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read OutShareSum[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutShareSumPartyAdv[n, m, k] ;
         return s
       )       
     )
     ||
     (family Out[bound N + 2 bound K]  indices: n, k
            bounds: bound N + 2 bound K ::=
       s : bool <- read OutShareSum[n, N + 1, k] ;
       return s
     )
     ||
     (family OutPartyAdv[bound N + 2 bound K]  indices: n, k
             bounds: bound N + 2 bound K  ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Out[n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutPartyAdv[n, k] ;
         return s
       )       
     )
   ) `` end new

) `` ends restrFinal
.

`` end pInt1

`` idealPlusSim goes here

channel context deltaIdealPlusSim = 
   input In[bound N + 2 dependentBound I] : bool ;
   
   output Out[bound N + 2 bound K] : bool ;
  
   output InPartyAdv[bound N + 2 dependentBound I] : bool ;
   output InRcvdPartyAdv[bound N + 2 dependentBound I] : unit ;
   output InSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
   output InShare$PartyAdv[bound N + 1 bound N + 2 dependentBound I] : bool ;
   output InShare$PartyAdv[bound N + 1 bound N + 2 dependentBound I] : bool ;
   output InShare$PartyAdv[fixedBound N + 1 bound N + 2 dependentBound I] : bool ;
   output InShare$-SumPartyAdv[bound N + 1 bound N + 2 dependentBound I] : bool ;
   output RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
   output SendInSharePartyAdv[bound N + 1 bound N + 2 dependentBound I] : bool ;
   output SendInSharePartyAdv[fixedBound N + 1 bound N + 2 dependentBound I] : bool ;
    
    output SendOutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
    output RcvdOutSharePartyAdv[bound N + 2 bound N + 1 bound K] : bool ;
    output RcvdOutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] : bool ;
    output OutSharePartyAdv[bound N + 2 bound N + 1 bound K] : bool ;
    output OutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] : bool ;
    output OutShareSumPartyAdv[bound N + 2 bound N + 1 bound K] : bool ;
    output OutShareSumPartyAdv[bound N + 2 fixedBound N + 1 bound K] : bool ;
    output OutPartyAdv[bound N + 2 bound K] : bool ; 
    output CtrbPartyAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output CtrbSumPartyAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output OTChc-0OtAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output OTChc-1OtAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output OTChcRcvd-0OtAdv[bound (N + 2) bound (N + 1) bound K] : unit ;
    output OTChcRcvd-1OtAdv[bound (N + 2) bound (N + 1) bound K] : unit ;
    output OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K] : unit ;
    output OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K] : unit ; 
    output OTOutOtAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output RcvdBitPartyAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output SendBitPartyAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output SharePartyAdv[bound (N + 2) bound K] : bool ;
    output OTMsgRcvd-0OtAdv[bound (N + 2) bound (N + 2) bound K] : unit ;
    output OTMsgRcvd-1OtAdv[bound (N + 2) bound (N + 2) bound K] : unit ;
    output OTMsgRcvd-2OtAdv[bound (N + 2) bound (N + 2) bound K] : unit ;
    output OTMsgRcvd-3OtAdv[bound (N + 2) bound (N + 2) bound K] : unit ;
    output OTMsg-0OtAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output OTMsg-1OtAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output OTMsg-2OtAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output OTMsg-3OtAdv[bound (N + 2) bound (N + 2) bound K] : bool
. 

protocol idealPlusSim = 
    newfamily InIdAdv[bound N + 2 dependentBound I] 
      indices: n, i 
      bounds: bound N + 2 dependentBound I : bool in
    newfamily InRcvdIdAdv[bound N + 2 dependentBound I] 
      indices: n, i
      bounds: bound N + 2 dependentBound I : unit in
    newfamily OutIdAdv[bound N + 2 bound K] 
      indices: n, k
      bounds: bound N + 2 bound K : bool in  
  ideal || sim  
  where ideal = ( newfamily Wire[bound K] indices: k bounds: bound K : bool in
   (
     (family InIdAdv[bound N + 2 dependentBound I] 
       indices: n, i 
       bounds: bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
          in : bool <- read In[n, i] ; return in
       )
       ;;
       (when (isHonest(n)) --> 
          in : bool <- read InIdAdv[n, i] ; return in
       )
     ) 
     ||
     (family InRcvdIdAdv[bound N + 2 dependentBound I] 
        indices: n, i 
        bounds: bound N + 2 dependentBound I ::=
       (when (isHonest(n)) --> 
          in : bool <- read In[n, i] ; return ()
       )
       ;;
       (when (isSemiHonest(n)) --> 
          in : unit <- read InRcvdIdAdv[n, i] ; 
            return in
       )
     ) 
  ) 
  ||
  (
     family Wires[bound K] indices: k bounds: bound K ::= 
       (
        family Wire[bound K]  indices: k bounds: bound K ::= 
         (when (isInputGate(k)) --> 
             i : bool <- read In[wire0(k) , wire1(k)] ; 
               return i
         )
         ;;
         (when (isNotGate(k)) --> 
           x : bool <- read Wire[wire0(k)] ;
           return neg(x)
         )
         ;;
         (when (isXorGate(k)) --> 
            x : bool <- read Wire[wire0(k)] ;
            y : bool <- read Wire[wire1(k)] ;
           return xor( (x, y) ) 
         )
         ;;
         (when (isAndGate(k)) --> 
           x : bool <- read Wire[wire0(k)] ; 
           y : bool <- read Wire[wire1(k)] ;
           return **( (x, y) ) 
         )
       )
  )
  ||
  (   (family OutIdAdv[bound N + 2 bound K] 
         indices: n, k bounds: bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
          out : bool <- read Out[n, k] ; return out
       )
       ;;
       (when (isHonest(n)) --> 
          out : bool <- read OutIdAdv[n, k] ; return out
       )
     )
     ||
     (family Out[bound N + 2 bound K]  indices: n, k bounds: bound N + 2 bound K ::=
       (when (isOutputWire(k)) --> 
          out : bool <- read Wire[k] ; return out
       )
       ;;
       (when (not (isOutputWire(k))) --> 
          o : bool <- read Out[n, k] ; return o
       )
     
     )
  )
  ) and
  sim = (
     newfamily InShare[bound N + 1  bound N + 2 dependentBound I]
               indices: m, n, i 
               bounds: bound N + 1  bound N + 2 dependentBound I : bool in
     newfamily Share[bound N + 1 bound K]
               indices: n, k
               bounds: bound N + 1 bound K : bool in
     newfamily ShareSum[bound N + 1 bound K]
               indices: m, k
               bounds: bound N + 1 bound K : bool in
  initialSim || finalSim || shareSim || inductiveSim
  where 
   initialSim = 
  (
      newfamily InShare$[bound N + 1  bound N + 2 dependentBound I]  
                 indices: m, n, i 
                bounds: bound N + 1  bound N + 2 dependentBound I : bool in
      newfamily InShare$-Sum[bound N + 1  bound N + 2 dependentBound I] 
                 indices: m, n, i 
                bounds: bound N + 1  bound N + 2 dependentBound I : bool in
     (
     (family InPartyAdv[bound N + 2 dependentBound I]  indices: n, i
             bounds: bound N + 2 dependentBound I ::=
        ( (when (isSemiHonest(n)) -->
            in : bool <- read InIdAdv [n, i] ; 
               return in  
         ) 
         ;;
         (when (isHonest(n)) --> 
            in : bool <- read InPartyAdv[n, i] ; 
               return in  
         )
       
       )      
     )
     ||
     (family InRcvdPartyAdv[bound N + 2 dependentBound I]  indices: n, i
             bounds: bound N + 2 dependentBound I ::=
             
       (when (isHonest(n)) -->
 x : unit <- read InRcvdIdAdv[n, i] ; return ()
 )
;;
when (isSemiHonest(n)) -->
 in : unit <- read InRcvdPartyAdv[n, i] ; return in
      
     )
     ||
     (family InShare$[bound N + 1  bound N + 2 dependentBound I]  indices: m, n, i 
             bounds: bound N + 1  bound N + 2 dependentBound I ::= 
       ( (when (isSemiHonest(n)) -->
            x : bool <- read InIdAdv[n, i] ; 
              samp flip (()) 
         ) 
         ;;
         (when (isHonest(n)) -->
            x : unit <- read InRcvdIdAdv[n, i] ; 
              samp flip (())
         )
       
       )         
     ) 
     ||
     (  
family InShare$PartyAdv[bound N + 1 bound N + 2 dependentBound I] 
     indices: m, n, i
     bounds: bound N + 1 bound N + 2 dependentBound I
::=
(when (isSemiHonest(n)) -->
 in : bool <- read InShare$[m, n, i] ; return in
)
;;
when (isHonest(n)) -->
 in : bool <- read InShare$PartyAdv[m, n, i] ; return in
)
||
(
family InShare$PartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] 
     indices: m, n, i
bounds: fixedBound (N + 1) bound (N + 2) dependentBound I
::=
(when (isSemiHonest(n)) -->
  s : bool <- read InShare$-Sum[N, n, i] ;
  x : bool <- read InIdAdv[n, i] ; 
  return xor((x, s))
)
;;
when (isHonest(n)) -->
 in : bool <- read InShare$PartyAdv[N + 1, n, i] ; return in
 )    
     ||
     (family InShare$-Sum[bound N + 1  bound N + 2 dependentBound I] 
              indices: m, n, i 
             bounds: bound N + 1  bound N + 2 dependentBound I ::=             
       ( (when (m = 0) --> 
            in : bool <- read InShare$ [0, n, i] ; return in
         ) 
         ;; 
         (otherwise --> 
            s : bool <- read InShare$-Sum [m - 1, n, i] ;
            x : bool <- read InShare$ [m, n, i] ;
            return xor((s, x))
         )
       )      
     )
     ||
     (
       family InShare$-SumPartyAdv[bound (N + 1) bound (N + 2) dependentBound I] 
       indices: m, n, i
       bounds: bound (N + 1) bound (N + 2) dependentBound I
::=
(when (isSemiHonest(n)) -->
 s : bool <- read InShare$-Sum[m, n, i] ; return s
 )
;;
when (isHonest(n)) -->
 s : bool <- read InShare$-SumPartyAdv[m, n, i] ; return s      
             
     ) 
     ||
     (
      family SendInSharePartyAdv[bound (N + 1) bound (N + 2) dependentBound I] 
    indices: m, n, i
bounds: bound (N + 1) bound (N + 2) dependentBound I
::=
(when (isSemiHonest(n)) -->
 in : bool <- read InShare$[m, n, i] ; return in)
;;
when (isHonest(n)) -->
 s : bool <- read SendInSharePartyAdv[m, n, i] ; return s
      )
      ||
      (
      family SendInSharePartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] 
      indices: m, n, i
      bounds: fixedBound (N + 1) bound (N + 2) dependentBound I ::=
(when (isSemiHonest(n)) -->
 s : bool <- read InShare$-Sum[N, n, i] ; 
 x : bool <- read InIdAdv[n, i] ; 
 return xor((x, s))
)
;;
when (isHonest(n)) -->
 s : bool <- read SendInSharePartyAdv[N + 1, n, i] ; return s
      )
     || 
     (family RcvdInSharePartyAdv[bound (N + 2) bound (N + 2) dependentBound I] 
     indices: n, m, i
     bounds: bound (N + 2) bound (N + 2) dependentBound I ::=
(when (isSemiHonest(n)) -->
 in : bool <- read InShare$[n, m, i] ; return in
)
;;
when (isHonest(n)) -->
 s : bool <- read RcvdInSharePartyAdv[n, m, i] ; return s
     )    
     ||
     (family InShare[bound N + 1  bound N + 2 dependentBound I]
              indices: m, n, i 
             bounds: bound N + 1  bound N + 2 dependentBound I ::= 
         in : bool <- read InShare$ [m, n, i] ; return in     
     ) 
     ||
     (family InSharePartyAdv[bound (N + 2) bound (N + 2) dependentBound I] 
     indices: n, m, i
     bounds: bound (N + 2) bound (N + 2) dependentBound I ::=
(when (isSemiHonest(n)) -->
 s : bool <- read InShare[n, m, i] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read InSharePartyAdv[n, m, i] ; return s
     ) 
    )
  ) 
  and
   finalSim = 
    (
      (family SendOutSharePartyAdv[bound N + 2 bound N + 2 bound K] 
        indices: m, n, k
        bounds: bound N + 2 bound N + 2 bound K  ::=
(when ((isOutputWire(k)) and (isSemiHonest(n))) -->
 s : bool <- read Share[n, k] ; return s
)
;;
when (not (isOutputWire(k)) or (isHonest(n))) -->
 s : bool <- read SendOutSharePartyAdv[m, n, k] ; return s
       )
       ||
       (family RcvdOutSharePartyAdv[bound N + 2 bound N + 1 bound K] 
         indices: n, m, k
         bounds: bound N + 2 bound N + 1 bound K
::=
(when ((isOutputWire(k)) and (isSemiHonest(n))) -->
 s : bool <- read Share[m, k] ; return s)
;;
when (not (isOutputWire(k)) or (isHonest(n))) -->
 s : bool <- read RcvdOutSharePartyAdv[n, m, k] ; return s
)      
 ||
 (
 family RcvdOutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K] 
  indices: n, m, k
  bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
(when ((isOutputWire(k)) and (isSemiHonest(n))) -->
   w : bool <- read OutIdAdv[n, k] ; 
   xs : bool <- read ShareSum[N, k] ; 
   return xor((xs, w))
)
;;
when (not (isOutputWire(k)) or (isHonest(n))) -->
 s : bool <- read RcvdOutSharePartyAdv[n,  N + 1, k] ; return s
 ) 
       ||
      (family OutSharePartyAdv[bound (N + 2) bound (N + 1) bound K]
       indices: n, m, k
       bounds: bound (N + 2) bound (N + 1) bound K
::=
(when ((isOutputWire(k)) and (isSemiHonest(n))) -->
 s : bool <- read Share[m, k] ; return s)
;;
when (not (isOutputWire(k)) or (isHonest(n))) -->
 s : bool <- read OutSharePartyAdv[n, m, k] ; return s
)
||
(
family OutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K] 
  indices: n, m, k
  bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
(when ((isOutputWire(k)) and (isSemiHonest(n))) -->
  w : bool <- read OutIdAdv[n, k] ;  
  xs : bool <- read ShareSum[N, k] ; 
  return xor((xs, w))
)
;;
when (not (isOutputWire(k)) or (isHonest(n))) -->
 s : bool <- read OutSharePartyAdv[n,  N + 1, k] ; return s
) 
       ||
        (
 family OutShareSumPartyAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
(when ((isOutputWire(k)) and (isSemiHonest(n))) -->
 s : bool <- read ShareSum[m, k] ; return s)
;;
when (not (isOutputWire(k)) or (isHonest(n))) -->
 s : bool <- read OutShareSumPartyAdv[n, m, k] ; return s
 )    
 ||
 (
 family OutShareSumPartyAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
(when ((isOutputWire(k)) and (isSemiHonest(n))) -->
 w : bool <- read OutIdAdv[n, k] ; return w
)
;;
when (not (isOutputWire(k)) or (isHonest(n))) -->
 s : bool <- read OutShareSumPartyAdv[n,  N + 1, k] ; return s
 ) 
       ||
       (family OutPartyAdv[((bound (N + 2))(bound K))]  indices: n, k
          bounds: bound N + 2 bound K ::=       
(when (isSemiHonest(n)) -->
 s : bool <- read OutIdAdv[n, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read OutPartyAdv[n, k] ; return s
         
       )
    ) 
   and
   shareSim = 
  (  family ShareSum[bound N + 1 bound K] 
             indices: m, k 
             bounds: bound N + 1 bound K ::=
     (
      (when (m = 0) --> 
         s : bool <- read Share[0, k] ; return s
      )
      ;;
      (when (not (m = 0)) --> 
          xs : bool <- read ShareSum[m - 1, k] ; 
          xm : bool <- read Share[m, k] ;
          return xor((xs, xm))  
      )
     )
   )
   and inductiveSim = 
   (
       newfamily SendBit[bound N + 1  bound N + 2 bound K]  indices: n, m, k 
                 bounds: bound N + 1  bound N + 2 bound K : bool in
       newfamily RcvdBit[bound N + 1 bound N + 1 bound K ]  indices: n, m, k
                 bounds: bound N + 1 bound N + 1 bound K : bool in 
       newfamily RcvdBit[bound N + 1 fixedBound N + 1 bound K]  indices: n, m, k
                 bounds: bound N + 1 fixedBound N + 1 bound K : bool in            
       newfamily Ctrb[bound N + 1  bound N + 2 bound K]  indices: n, m, k 
                 bounds: bound N + 1  bound N + 2 bound K : bool in
       newfamily CtrbSum[bound N + 1  bound N + 2 bound K]  indices: n, m, k 
                 bounds: bound N + 1  bound N + 2 bound K : bool in
family Circ[bound K] indices: k bounds: bound K ::=
( 
      (when (isInputGate(k)) --> 
(
 (family Ctrb[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound N + 1  bound N + 2 bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 1) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 1) bound K
::=
 rb : bool <- read RcvdBit[n, m, k]; return rb
)
||
(family RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] indices: n, m, k
bounds:  bound (N + 1) fixedBound (N + 1) bound K
::=
 rb : bool <- read RcvdBit[n,  N + 1, k]; return rb
)
||
(family SendBit[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds:  bound (N + 1) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k]; return sb
)
||
(family Share[bound (N + 1) bound K] indices: n, k
bounds:  bound (N + 1) bound K
::=
 in : bool <- read InShare[n, wire0(k) , wire1(k)] ; return in
)
||
(family CtrbPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbPartyAdv[n, m, k] ; return b
)
||
(family CtrbSumPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSumPartyAdv[n, m, k] ; return b
)
||
(family OTChc-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 oc : bool <- read OTChc-0OtAdv[n, m, k]; return oc
)
||
(family OTChc-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 oc : bool <- read OTChc-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-0OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-0OtAdv[n,  N + 1, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-1OtAdv[n,  N + 1, k]; return oc
)
||
(family OTMsg-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-0OtAdv[n, m, k]; return om
)
||
(family OTMsg-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-1OtAdv[n, m, k]; return om
)
||
(family OTMsg-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-2OtAdv[n, m, k]; return om
)
||
(family OTMsg-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-3OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-0OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-1OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-2OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-3OtAdv[n, m, k]; return om
)
||
(family OTOutOtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 out : bool <- read OTOutOtAdv[n, m, k] ; return out
)
||
(family RcvdBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBitPartyAdv[n, m, k]; return rb
)
||
(family SendBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBitPartyAdv[n, m, k]; return sb
)
||
(family SharePartyAdv[bound (N + 2) bound K] indices: n, k
bounds: bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read Share[n, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read SharePartyAdv[n, k] ; return s
)
   )
   ) 
     ;;
   ( 
      when (isNotGate(k)) --> 
( 
(family Ctrb[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 1) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 1) bound K
::=
 rb : bool <- read RcvdBit[n, m, k]; return rb
)
||
(family RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 1) fixedBound (N + 1) bound K
::=
 rb : bool <- read RcvdBit[n,  N + 1, k]; return rb
)
||
(family SendBit[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k]; return sb
)
||
(family Share[bound (N + 1) bound K] indices: n, k
bounds: bound (N + 1) bound K
::=
 s : bool <- read Share[n, wire0(k)] ; return s
)
||
(family CtrbPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbPartyAdv[n, m, k] ; return b
)
||
(family CtrbSumPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSumPartyAdv[n, m, k] ; return b
)
||
(family OTChc-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 oc : bool <- read OTChc-0OtAdv[n, m, k]; return oc
)
||
(family OTChc-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 oc : bool <- read OTChc-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-0OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-0OtAdv[n,  N + 1, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-1OtAdv[n,  N + 1, k]; return oc
)
||
(family OTMsg-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-0OtAdv[n, m, k]; return om
)
||
(family OTMsg-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-1OtAdv[n, m, k]; return om
)
||
(family OTMsg-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-2OtAdv[n, m, k]; return om
)
||
(family OTMsg-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-3OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-0OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-1OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-2OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-3OtAdv[n, m, k]; return om
)
||
(family OTOutOtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 out : bool <- read OTOutOtAdv[n, m, k] ; return out
)
||
(family RcvdBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBitPartyAdv[n, m, k]; return rb
)
||
(family SendBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBitPartyAdv[n, m, k]; return sb
)
||
(family SharePartyAdv[bound (N + 2) bound K] indices: n, k
bounds: bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read Share[n, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read SharePartyAdv[n, k] ; return s
)
) 
   ) 
   ;;
( 
      when (isXorGate(k)) --> 
(
(family Ctrb[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 1) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 1) bound K
::=
 rb : bool <- read RcvdBit[n, m, k]; return rb
)
||
(family RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 1) fixedBound (N + 1) bound K
::=
 rb : bool <- read RcvdBit[n,  N + 1, k]; return rb
)
||
(family SendBit[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k]; return sb
)
||
(family Share[bound (N + 1) bound K] indices: n, k
bounds: bound (N + 1) bound K
::=
 x : bool <- read Share[n, wire0(k)] ; 
 y : bool <- read Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family CtrbPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbPartyAdv[n, m, k] ; return b
)
||
(family CtrbSumPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSumPartyAdv[n, m, k] ; return b
)
||
(family OTChc-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 oc : bool <- read OTChc-0OtAdv[n, m, k]; return oc
)
||
(family OTChc-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 oc : bool <- read OTChc-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-0OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-0OtAdv[n,  N + 1, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-1OtAdv[n,  N + 1, k]; return oc
)
||
(family OTMsg-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-0OtAdv[n, m, k]; return om
)
||
(family OTMsg-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-1OtAdv[n, m, k]; return om
)
||
(family OTMsg-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-2OtAdv[n, m, k]; return om
)
||
(family OTMsg-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-3OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-0OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-1OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-2OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-3OtAdv[n, m, k]; return om
)
||
(family OTOutOtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 out : bool <- read OTOutOtAdv[n, m, k] ; return out
)
||
(family RcvdBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBitPartyAdv[n, m, k]; return rb
)
||
(family SendBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBitPartyAdv[n, m, k]; return sb
)
||
(family SharePartyAdv[bound (N + 2) bound K] indices: n, k
bounds: bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read Share[n, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read SharePartyAdv[n, k] ; return s
)
) 
   ) 
   ;;
( when (isAndGate(k)) -->
(
(family Ctrb[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <- read SendBit[n, m, k] ; return s)
;;
(when (m = n) -->
 x : bool <- read Share[n, wire0(k)] ; 
 y : bool <- read Share[n, wire1(k)] ;
 return **((x, y))
)
;;
when (m < n) -->
 r : bool <- read RcvdBit[n, m, k]; return r
)
||
(family CtrbSum[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
(when (0 = m) -->
 b : bool <- read Ctrb[n, 0, k] ; return b)
;;
when not (0 = m) -->
 b : bool <- read Ctrb[n, m, k] ; 
 s : bool <- read CtrbSum[n, m - 1, k] ;
 return xor((s, b))
)
||
(family RcvdBit[bound (N + 1) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 1) bound K
::=
   b : bool <- read SendBit[m, n, k] ; 
  xm : bool <- read Share[m, wire0(k)] ; 
  xn : bool <- read Share[n, wire0(k)] ;
  ym : bool <- read Share[m, wire1(k)] ;
  yn : bool <- read Share[n, wire1(k)] ; 
  return xor(( xor( (**((xm, yn)) , **((xn, ym))) ) , b) )
)
||
(family RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 1) fixedBound (N + 1) bound K
::=
 r : bool <- read RcvdBit[n, m, k]; return r
)
||
(family SendBit[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <- read Share[n, wire0(k)] ;
 y : bool <- read Share[n, wire1(k)] ;
 samp flip (())
)
;;
when (m <= n) -->
 sb : bool <- read SendBit[n, m, k]; return sb
)
||
(family Share[bound (N + 1) bound K] indices: n, k
bounds: bound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[n,  N + 1, k] ; return bs
)
||
(family CtrbPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read Ctrb[n, m, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read CtrbPartyAdv[n, m, k] ; return s
)
||
(family CtrbSumPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read CtrbSum[n, m, k] ; return s
)
;;
when (isHonest(n)) -->
 s : bool <- read CtrbSumPartyAdv[n, m, k] ; return s
)
||
(family OTChc-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isSemiHonest(m)) and n < m) -->
 x : bool <- read Share[m, wire0(k)]; return x
 )
;;
when ((isHonest(m)) or m <= n) -->
 oc : bool <- read OTChc-0OtAdv[n, m, k]; return oc
)
||
(family OTChc-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isSemiHonest(m)) and n < m) -->
 x : bool <- read Share[m, wire1(k)]; return x
)
;;
when ((isHonest(m)) or m <= n) -->
 oc : bool <- read OTChc-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
(when ((isHonest(m)) and n < m) -->
 x : bool <- read Share[m, wire0(k)] ; return ()
)
;;
when ((isSemiHonest(m)) or m <= n) -->
 oc : unit <- read OTChcRcvd-0OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
(when (n < N + 1) -->
 x : bool <- read ShareSum[N, wire0(k)] ; return ())
;;
when (n = N + 1) -->
 oc : unit <- read OTChcRcvd-0OtAdv[n,  N + 1, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
(when ((isHonest(m)) and n < m) -->
 x : bool <- read Share[m, wire1(k)] ; return ())
;;
when ((isSemiHonest(m)) or m <= n) -->
 oc : unit <- read OTChcRcvd-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
(when (n < N + 1) -->
 x : bool <- read ShareSum[N, wire1 (k)] ; return ()
)
;;
when (n = N + 1) -->
 oc : unit <- read OTChcRcvd-1OtAdv[n,  N + 1, k]; return oc
)
||
(family OTMsg-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isSemiHonest(n)) and n < m) -->
  b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ; 
  return b
)
;;
when ((isHonest(n)) or m <= n) -->
 om : bool <- read OTMsg-0OtAdv[n, m, k]; return om
)
||
(family OTMsg-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isSemiHonest(n)) and n < m) -->
  b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ; 
  return xor((x, b))
)
;;
when ((isHonest(n)) or m <= n) -->
 om : bool <- read OTMsg-1OtAdv[n, m, k]; return om
)
||
(family OTMsg-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isSemiHonest(n)) and n < m) -->
  b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ;  
  return xor((y, b))
)
;;
when ((isHonest(n)) or m <= n) -->
 om : bool <- read OTMsg-2OtAdv[n, m, k]; return om
)
||
(family OTMsg-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isSemiHonest(n)) and n < m) -->
  b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ; 
  return xor((xor((x, y)), b))
)
;;
when ((isHonest(n)) or m <= n) -->
 om : bool <- read OTMsg-3OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isHonest(n)) and n < m) -->
  b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ; return () 
)
;;
when ((isSemiHonest(n)) or m <= n) -->
 om : unit <- read OTMsgRcvd-0OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isHonest(n)) and n < m) -->
  b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ;  
  return () 
)
;;
when ((isSemiHonest(n)) or m <= n) -->
 om : unit <- read OTMsgRcvd-1OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isHonest(n)) and n < m) -->
 b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ;  
  return () 
)
;;
when ((isSemiHonest(n)) or m <= n) -->
 om : unit <- read OTMsgRcvd-2OtAdv[n, m, k]; return om
)
||

(family OTMsgRcvd-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isHonest(n)) and n < m) -->
  b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ;  
  return () 
)
;;
when ((isSemiHonest(n)) or m <= n) -->
 om : unit <- read OTMsgRcvd-3OtAdv[n, m, k]; return om
)
||
(family OTOutOtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (isSemiHonest(m)) -->
 out : bool <- read RcvdBit[m, n, k] ; return out)
;;
when (isHonest(m)) -->
 out : bool <- read OTOutOtAdv[n, m, k] ; return out
)
||
(family RcvdBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read RcvdBit[n, m, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read RcvdBitPartyAdv[n, m, k] ; return s
)
||
(family SendBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read SendBit[n, m, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read SendBitPartyAdv[n, m, k] ; return s
)
||
(family SharePartyAdv[bound (N + 2) bound K] indices: n, k
bounds: bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read Share[n, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read SharePartyAdv[n, k] ; return s
)
)

)
     ) ) ) .

`` all subproofs go after this line
strict subproof eliminateOTDivergent = 
  on branch isSemiHonest(n) of family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-0[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-0[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(n) of family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-1[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-1[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(n) of family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-2[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-2[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(n) of family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-3[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-3[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables m to x, n to y, k to z of fam OTChc-0[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(m) of family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-0[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(m) of family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-0[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables x to m, y to n, z to k of fam OTChc-0[bound N + 2 bound N + 2 bound K] then
    rename variables m to x, n to y, k to z of fam OTChc-1[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(m) of family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-1[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(m) of family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-1[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables x to m, y to n, z to k of fam OTChc-1[bound N + 2 bound N + 2 bound K] then
    diverge on fam OTOut[bound N + 2 bound N + 2 bound K] 
    with fam OTMsg-0[bound N + 2 bound N + 2 bound K]  
    var o then
    on branch isSemiHonest(m) of family OTOutOtAdv[bound N + 2 bound N + 2 bound K]  (
       diverge on fam OTOutOtAdv[bound N + 2 bound N + 2 bound K] 
       with fam OTOut[bound N + 2 bound N + 2 bound K]  
       var out
    ) then
    merge cases for fam OTOutOtAdv[bound N + 2 bound N + 2 bound K]
.

strict subproof addSharesOK = 
group  
   fam ShareOK[bound N + 2 bound K],
   fam SendBit-OK[bound N + 2 bound N + 2 bound K],
   fam RcvdBit-OK[bound N + 2 bound N + 2 bound K],
   fam Ctrb-OK[bound N + 2 bound N + 2 bound K],
   fam CtrbSum-OK[bound N + 2 bound N + 2 bound K]
in SharesOK 
indices: k
bounds: bound K .

strict subproof addInitOK =
group  
  fam InShareOK[bound N + 2 bound N + 2 dependentBound I],
  fam InShare$-OK[bound N + 2 bound N + 2 dependentBound I],
  fam InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I]
in InitOK 
indices: m, n, i
bounds: bound N + 2 bound N + 2 dependentBound I .

strict subproof changeShares = 
 sym from 
( branch when (isInputGate(k)) of fam Shares[bound K]
 change fam Share[fixedBound N + 1 bound K]
 with x : unit <- read InShareOK[N + 1, wire0(k), wire1(k)] ;
      in : bool <- read InShare[N + 1, wire0(k), wire1(k)] ;
      return in
 in 
 (branch when (isNotGate(k))  of fam Shares[bound K]
  change fam Share[fixedBound N + 1 bound K]
  with 
       s : unit <- read ShareOK[N + 1, wire0(k)] ;
       x : bool <- read Share[N + 1, wire0(k)] ;
       return neg(x)
  in (
   branch when (isXorGate(k)) of fam Shares[bound K]
   change fam Share[fixedBound N + 1 bound K]
   with  
         a : unit <- read ShareOK[N + 1, wire0(k)] ;
         b : unit <- read ShareOK[N + 1, wire1(k)] ;
         x : bool <- read Share[N + 1, wire0(k)] ;
         y : bool <- read Share[N + 1, wire1(k)] ;
         return xor((x, y)) 
   in (branch when (isAndGate(k)) of fam Shares[bound K]
   change fam Share[fixedBound N + 1 bound K]
   with
    x : unit <- read CtrbSum-OK[N + 1, N + 1, k] ;
    bs : bool <- read CtrbSum[N + 1, N + 1, k] ;
    return bs    
   in currentProtocol
   )
  )        
  ) 
)  (
   ungroup fam SharesOK[bound K] then
   ungroup fam InitOK[bound N + 2 bound N + 2 dependentBound I] then
   on branch isInputGate(k) of group Shares[bound K](
     subst fam InShareOK[bound N + 2 bound N + 2 dependentBound I] 
     into fam Share[fixedBound N + 1 bound K]
   ) then
   on branch isNotGate(k) of group Shares[bound K](
     subst fam ShareOK[bound N + 2 bound K]
     into fam Share[fixedBound N + 1 bound K]
   ) then
   on branch isXorGate(k) of group Shares[bound K](
     subst fam ShareOK[bound N + 2 bound K]
     into fam Share[fixedBound N + 1 bound K] then
     rename x to inA in fam Share[fixedBound N + 1 bound K] then
     subst fam ShareOK[bound N + 2 bound K]
     into fam Share[fixedBound N + 1 bound K] then
     rename x to y, inA to x in fam Share[fixedBound N + 1 bound K]  
   )  then 
   on branch isAndGate(k) of group Shares[bound K](
     subst fam CtrbSum-OK[bound N + 2 bound N + 2 bound K]
     into fam Share[fixedBound N + 1 bound K] 
   ) then
   call addSharesOK then
   call addInitOK 
   ) 
.

strict subproof addInOK = 
 add internal family In-OK 
     indices: n, i 
     bounds: bound N + 2 dependentBound I 
     typed: unit 
     assigned: 
       in : bool <- read In[n, i] ; 
       return ()
.

strict subproof addWiresOK =
 add internal family Wire-OK
     indices: k
     bounds: bound K 
     typed: unit
     assigned: 
          (when (isInputGate(k)) --> 
            in : unit <- read In-OK[wire0(k), wire1(k)] ;
            return in
          )
          ;;
          (when (isNotGate(k)) --> 
            w : unit <- read Wire-OK[wire0(k)] ;
            return ()
          )
          ;;
          (when (isXorGate(k)) --> 
            w0 : unit <- read Wire-OK[wire0(k)] ;
            w1 : unit <- read Wire-OK[wire1(k)] ;
            return () 
          )
          ;;
          (when (isAndGate(k)) --> 
            w0 : unit <- read Wire-OK[wire0(k)] ;
            w1 : unit <- read Wire-OK[wire1(k)] ;
            return () 
          ) then
  group  
   fam Wire-OK[bound K]
in Wires-OK 
indices: k
bounds: bound K        
.

strict subproof splitShareOK = 
 split fam ShareOK[bound N + 2 bound K] on first index inside group SharesOK[bound K]
.

strict subproof sym3 = 
 add internal family InShareOK
indices: m, n, i
bounds: bound N + 2 bound N + 2 dependentBound I 
typed: unit 
assigned: 
 is : bool <- read InShare[m, n, i] ; return () then
add internal family ShareOK
indices: n, k
bounds: bound N + 2 bound K
typed: unit
assigned: x : bool <- read Share[n, k] ; return ()
.

strict subproof sym4 =
 on branch isAndGate(k) of group Adv[bound K](
on branch n < N + 1 of family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K](
  sym from change fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] 
    with x : unit <- read ShareOK[N + 1, wire0(k)] ; return ()
    in currentProtocol(
      subst fam ShareOK[bound N + 2 bound K]
      into fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] 
    )
) then
on branch n < N + 1 of family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K](
  sym from change fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] 
    with x : unit <- read ShareOK[N + 1, wire1(k)] ; return ()
    in currentProtocol(
      subst fam ShareOK[bound N + 2 bound K]
      into fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] 
    )
)
)
.

strict subproof sym5 = 
 add internal family InShare$-OK
indices: m, n, i
bounds: bound N + 2  bound N + 2 dependentBound I
typed: unit
assigned: is : bool <- read InShare$[m, n, i] ; return () then
add internal family InShare$Sum-OK
indices: m, n, i
bounds: bound N + 1  bound N + 2 dependentBound I
typed: unit
assigned: is : bool <- read InShare$-Sum[m, n, i] ; return () then
add internal family SendBit-OK
indices: n, m, k
bounds: bound N + 2  bound N + 2 bound K
typed: unit
assigned: s : bool <- read SendBit[n, m, k] ; return () then
add internal family RcvdBit-OK
indices: n, m, k
bounds: bound N + 2  bound N + 2 bound K
typed: unit
assigned: r : bool <- read RcvdBit[n, m, k] ; return () then
add internal family Ctrb-OK
indices: n, m, k
bounds: bound N + 2  bound N + 2 bound K
typed: unit
assigned: c : bool <- read Ctrb[n, m, k] ; return () then
add internal family CtrbSum-OK
indices: n, m, k
bounds: bound N + 2  bound N + 2 bound K
typed: unit
assigned: c : bool <- read CtrbSum[n, m, k] ; return ()
.

strict subproof sym8 = 
 sym from 
         branch
          when (isInputGate(k)) 
         of 
          fam Shares[bound K] 
         change 
          fam Share[fixedBound (N + 1) bound K] 
         with 
          x : unit <- read InShareOK[N + 1, wire0(k), wire1(k)] ;
          in : bool <- read InShare[N + 1, wire0(k), wire1(k)] ;
          return in
         in 
         (branch
           when (isNotGate(k)) 
         of 
           fam Shares[bound K] 
         change 
          fam Share[fixedBound (N + 1) bound K] 
         with 
          s : unit <- read ShareOK[N + 1, wire0(k)] ;
          x : bool <- read Share[N + 1, wire0(k)];
          return neg(x)
         in 
         (branch
            when (isXorGate(k))
          of  
           fam Shares[bound K] 
          change 
           fam Share[fixedBound (N + 1) bound K] 
          with 
           a : unit <- read ShareOK[N + 1, wire0(k)] ;
           b : unit <- read ShareOK[N + 1, wire1(k)] ;
           x : bool <- read Share[N + 1, wire0(k)] ;
           y : bool <- read Share[N + 1, wire1(k)] ;
           return xor((x, y))
         in 
          (branch
            when (isAndGate(k))
          of  
           fam Shares[bound K] 
          change 
           fam Share[fixedBound (N + 1) bound K] 
          with 
           x : unit <- read CtrbSum-OK[N + 1, N + 1, k] ;
           bs : bool <- read CtrbSum[N + 1, N + 1, k] ;
           return bs 
         in currentProtocol
          ) ) )
 ( on branch isInputGate(k) of group Shares[bound K] (
     subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
      into fam Share[fixedBound (N + 1) bound K]
   ) then
   on branch isNotGate(k) of group Shares[bound K] (
     subst fam ShareOK[bound (N + 2) bound K]
      into fam Share[fixedBound (N + 1) bound K]
   ) then  
   on branch isXorGate(k) of group Shares[bound K] (
     subst fam ShareOK[bound (N + 2) bound K]
      into fam Share[fixedBound (N + 1) bound K] then
     rename x to inA in fam Share[fixedBound (N + 1) bound K] then
     subst fam ShareOK[bound (N + 2) bound K]
      into fam Share[fixedBound (N + 1) bound K] then
     rename x to y, inA to x 
      in fam Share[fixedBound (N + 1) bound K] 
   ) then 
   on branch isAndGate(k) of group Shares[bound K] (
     subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
      into fam Share[fixedBound (N + 1) bound K]
   )  
 )
 .

strict subproof inIndSym7 = 
 sym from
       change 
        fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]  
        with
         s : bool <- read SendBit[n, m, B] ;  return ()
        in currentProtocol
(  
  sym from 
          change 
        fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
        with
         (when (n < m) --> 
           s : bool <- read SendBit[n, m, B] ;  return () 
         )
         ;;
         (when (m <= n) --> 
           s : bool <- read SendBit[n, m, B] ;  return () 
         )
        in currentProtocol 
         ( merge cases for fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         ) then

 case distinction on family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] (
  case:(
   using branch when isAndGate(B)
         of group Shares[fixedBound B]
         ( 
           using branch when n < m
            of family SendBit[bound (N + 2) bound (N + 2) fixedBound B]
            ( drop read 
                fam SendBit[bound (N + 2) bound (N + 2) fixedBound B]
              from fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
            )
         )       
 )

 case: (
  using branch when isAndGate(B)
         of group Shares[fixedBound B]
         ( 
           using branch when m <= n
            of family SendBit[bound (N + 2) bound (N + 2) fixedBound B]
            ( diverge 
                on fam SendBit[bound (N + 2) bound (N + 2) fixedBound B] 
                with fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
                var sb
            )
         )
 )
 )
)

. 

strict subproof inIndSym10 =
 rewrite family CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
  to c : bool <- read CtrbSum[n, m, B] ; return ()
  by induction on m bound M
  (
  case distinction on family CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B](
   case: (subst fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
     into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B] then 
    sym from 
     change fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
     with c : bool <- read CtrbSum[n, M, B] ;  return ()
     in currentProtocol 
     (
       using branch when isAndGate(B) of
        group Shares[fixedBound B]
        ( subst fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
           into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
        ) then     
        rename b to c in fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
    )
  ) 
   
   case: ( subst fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
      into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B] then
     rename c to b in fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B] then
     subst fam CtrbSum-OK[bound (N + 2) bound M fixedBound B]
      into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B] then       
     rename c to s in fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B] then       
     sym from 
      change fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
        with c : bool <- read CtrbSum[n, M, B] ; return ()
          in currentProtocol 
      ( using branch when isAndGate(B) of
        group Shares[fixedBound B]
        ( subst fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
           into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
        )
      )
   )
  
  
  ) then
   
  merge cases for fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
  
  )

.

strict subproof inIndSym11 =
 sym from 
   change 
        fam ShareOK[bound (N + 1) fixedBound B]
        with
         x : bool <- read Share[n, B] ; return ()
        in currentProtocol
  ( using branch when isAndGate(B)
     of group Shares[fixedBound B]
    (subst fam Share[bound (N + 1) fixedBound B]
      into fam ShareOK[bound (N + 1) fixedBound B] then
     rename bs to c in fam ShareOK[bound (N + 1) fixedBound B]  
    ) 
  )      
.

strict subproof inIndSym12 =
 sym from 
   change 
        chn ShareOK[N + 1, B]
        with
         x : bool <- read Share[N + 1, B] ; return ()
        in currentProtocol
  ( using branch when isAndGate(B)
     of group Shares[fixedBound B]
    (subst chn Share[N + 1, B]
      into chn ShareOK[N + 1, B] then
     rename bs to c in chn ShareOK[N + 1, B]  
    ) then
    subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
     into chn ShareOK[N + 1, B]
  )      
.   

strict subproof changeComp =
sym from
     change fam SharesOK[bound K]
        with 
           (when (isInputGate(k)) -->
         (  
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(
family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 i : unit <- read InShareOK[n, wire0(k), wire1(k)] ; return i
)
||
(
family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 i : unit <- read InShareOK[N + 1, wire0(k), wire1(k)] ;
 return i
)
         )
) 
;;
(when (isNotGate(k)) -->
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(
family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : unit <- read ShareOK[n, wire0(k)] ; return x
)
||
(
family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : unit <- read ShareOK[N + 1, wire0(k)] ; 
 return x
)
)
)
;;
(when (isXorGate(k)) -->
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(
family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : unit <- read ShareOK[n, wire0(k)] ;
 y : unit <- read ShareOK[n, wire1(k)] ; 
 return ()
)
||
(
family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : unit <- read ShareOK[N + 1, wire0(k)] ;
 y : unit <- read ShareOK[N + 1, wire1(k)] ; 
 return ()
)
)
)
;;
(when (isAndGate(k)) -->
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : unit <- read SendBit-OK[n, m, k] ; return s
) 
;;
(when (m < n) -->
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
;;
(when (m = n) -->
 x : unit <- read ShareOK[n, wire0(k)] ; 
 y : unit <- read ShareOK[n, wire1(k)] ; 
 return () 
)
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (0 = m) -->
 c : unit <- read Ctrb-OK[n, 0, k] ; return c
)
;;
(when (not (0 = m)) -->
  x : unit <- read CtrbSum-OK[n, m - 1, k] ;
  y : unit <- read Ctrb-OK[n, m, k] ; 
  return () 
)
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : unit <- read SendBit-OK[m, n, k] ;
 xm : unit <- read ShareOK[m, wire0(k)] ;
 xn : unit <- read ShareOK[n, wire0(k)] ; 
 ym : unit <- read ShareOK[m, wire1(k)] ; 
 yn : unit <- read ShareOK[n, wire1(k)] ; 
 return ()
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : unit <- read ShareOK[n, wire0(k)] ;
 y : unit <- read ShareOK[n, wire1(k)] ; 
    return ()
)
;;
(when (m <= n) -->
 sb : unit <- read SendBit-OK[n, m, k] ; return sb
)
)
||
(family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 c : unit <- read CtrbSum-OK[n, N + 1, k] ; return c
)
||
(family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 c : unit <- read CtrbSum-OK[N + 1, N + 1, k] ;
 return c  
)
)
)
  in currentProtocol 
(
in the presence of 
  fam InitOK[bound (N + 2) bound (N + 2) dependentBound I]
  rewrite
  group Shares[bound K] and SharesOK[bound K]
  to
  (
(family Shares[bound K] 
 indices: k
 bounds: bound K
::=
(
(when (isInputGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read  Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read  CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read  RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read  SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <- read  InShare[n, wire0(k), wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 in : bool <- read  InShare[N + 1, wire0(k), wire1(k)] ;
 x : unit <- read  InShareOK[N + 1, wire0(k), wire1(k)] ; 
 return in
)
)
)
;;
(when (isNotGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read  Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read  CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read  RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read  SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <- read  Share[n, wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 s : unit <- read  ShareOK[N + 1, wire0(k)] ;
 x : bool <- read  Share[N + 1, wire0(k)] ; 
 return neg(x)
)
)
)
;;
(when (isXorGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read  Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read  CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read  RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read  SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <- read  Share[n, wire0(k)] ;
 y : bool <- read  Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 a : unit <- read  ShareOK[N + 1, wire0(k)] ;
 b : unit <- read  ShareOK[N + 1, wire1(k)] ;
 x : bool <- read  Share[N + 1, wire0(k)] ;
 y : bool <- read  Share[N + 1, wire1(k)] ; 
 return xor((x, y))
)
) 
)
;;
(when (isAndGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <- read  SendBit[n, m, k] ; return s
)
;;
(when (m = n) -->
 x : bool <- read  Share[n, wire0(k)] ;
 y : bool <- read  Share[n, wire1(k)] ;
 return **((x, y))
) 
;;
(when (m < n) -->
 r : bool <- read  RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (0 = m) -->
 b : bool <- read  Ctrb[n, 0, k] ; return b
)
;;
(when (not (0 = m)) -->
  b : bool <- read  Ctrb[n, m, k] ;
  s : bool <- read  CtrbSum[n, m - 1, k] ; 
  return xor((s, b))
)
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read  SendBit[m, n, k] ;
 xm : bool <- read  Share[m, wire0(k)] ;
 xn : bool <- read  Share[n, wire0(k)] ;
 ym : bool <- read  Share[m, wire1(k)] ;
 yn : bool <- read  Share[n, wire1(k)] ; 
    return xor( (  xor( (**((xm, yn)) , **((xn, ym))) ),  b) )
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <- read  Share[n, wire0(k)] ;
 y : bool <- read  Share[n, wire1(k)] ;
 samp flip(())
) 
;;
(when (m <= n) -->
 sb : bool <- read  SendBit[n, m, k] ; return sb
)
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <- read  CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 bs : bool <- read  CtrbSum[N + 1, N + 1, k] ;
 x : unit <- read  CtrbSum-OK[N + 1, N + 1, k] ;
 return bs
)
)
)
)
)
||
(family SharesOK[bound K] 
 indices: k
 bounds: bound K
::=
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : bool <- read  Ctrb[n, m, k] ;  return ()
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : bool <- read  CtrbSum[n, m, k] ;  return ()
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : bool <- read  RcvdBit[n, m, k] ;  return ()
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : bool <- read  SendBit[n, m, k] ;  return ()
)
||
(family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <- read  Share[n, k] ; return ()
)
||
(family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <- read  Share[N + 1, k] ; return ()
)
)
)
)
  by induction on k bound B 
 (
  ungroup fam InitOK[bound (N + 2) bound (N + 2) dependentBound I] then
  case distinction on group SharesOK[fixedBound B] 
  (
   case: (
    using branch when isInputGate(B) of group Shares[fixedBound B]( 
    sym var c terms n, m, B 
          diverge fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
          into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] var c then
    sym var c terms n, m, B 
          diverge fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
          into fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B] var c then    
    sym var r terms n, m, B 
          diverge fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B]
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] var r then 
    sym var s terms n, m, B 
          diverge fam SendBit[bound (N + 2) bound (N + 2) fixedBound B]
          into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] var s then    
    subst fam InShareOK[bound N + 2 bound N + 2 dependentBound I ]
    into chn ShareOK[N + 1, B] then
      sym from 
          change 
        chn ShareOK[N + 1, B]
        with
         x : bool <- read Share[N + 1, B] ; return ()
        in currentProtocol  
        (  subst chn Share[N + 1, B] into chn ShareOK[N + 1, B] then
           subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
            into chn ShareOK[N + 1, B] then 
           rename in to is in chn ShareOK[N + 1, B] 
        ) then
    rename indices to x, y in fam ShareOK[bound(N + 1) fixedBound B] then
      subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
       into fam ShareOK[bound (N + 1) fixedBound B] then
      rename indices to n, k in fam ShareOK[bound(N + 1) fixedBound B] then
      rename is to in in fam ShareOK[bound(N + 1) fixedBound B] then
      sym from 
         change 
        fam ShareOK[bound(N + 1) fixedBound B]
        with
         x : bool <- read Share[n, B] ; return ()
        in currentProtocol 
         ( subst
             fam Share[bound (N + 1) fixedBound B] into
             fam ShareOK[bound (N + 1) fixedBound B]
         )     
                 
   ) 
   ) 

   case: (
    using branch when isNotGate(B) of group Shares[fixedBound B]( 

    sym var c terms n, m, B 
          diverge fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
          into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] var c then
    sym var c terms n, m, B 
          diverge fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
          into fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B] var c then    
    sym var r terms n, m, B 
          diverge fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B]
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] var r then 
    sym var s terms n, m, B 
          diverge fam SendBit[bound (N + 2) bound (N + 2) fixedBound B]
          into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] var s then
    using group SharesOK[bound B]
       ( subst fam ShareOK[fixedBound (N + 1) bound B] into
               chn ShareOK[N + 1, B] ) then
      sym from 
       change chn ShareOK[N + 1, B]
       with
         x : bool <- read Share[N + 1, B] ; return ()
        in currentProtocol ( 
          subst chn Share[N + 1, B] into chn ShareOK[N + 1, B] then
          using group SharesOK[bound B]
           ( 
             subst fam ShareOK[fixedBound (N + 1) bound B] 
              into chn ShareOK[N + 1, B]
           ) 
         ) then
      using group SharesOK[bound B]
       ( subst fam ShareOK[bound (N + 1) bound B] into
               fam ShareOK[bound(N + 1) fixedBound B] ) then
      sym from 
       change 
        fam ShareOK[bound (N + 1) fixedBound B]
        with
         x : bool <- read Share[n, B] ; return ()
        in currentProtocol 
         (
         subst fam Share[bound (N + 1) fixedBound B]
          into fam ShareOK[bound (N + 1) fixedBound B] then
         rename s to x in fam ShareOK[bound(N + 1) fixedBound B]   
         )          
   )
   ) 

   case:(
    using branch when isXorGate(B) of group Shares[fixedBound B]( 

    sym var c terms n, m, B 
          diverge fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
          into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] var c then
    sym var c terms n, m, B 
          diverge fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
          into fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B] var c then    
    sym var r terms n, m, B 
          diverge fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B]
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] var r then 
    sym var s terms n, m, B 
          diverge fam SendBit[bound (N + 2) bound (N + 2) fixedBound B]
          into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] var s then 
      using group SharesOK[bound B]
       ( subst fam ShareOK[fixedBound (N + 1) bound B] into
               chn ShareOK[N + 1, B] then
         rename x to a in chn ShareOK[N + 1, B] then 
         subst fam ShareOK[fixedBound (N + 1) bound B] into
               chn ShareOK[N + 1, B] then 
         rename x to y, a to x in chn ShareOK[N + 1, B] ) then       
     sym from 
        change 
        chn ShareOK[N + 1, B]
        with
         x : bool <- read Share[N + 1, B] ; return ()
        in currentProtocol 
        ( 
        subst chn Share[N + 1, B] into chn ShareOK[N + 1, B] then 
        using group SharesOK[bound B] 
         (subst fam ShareOK[fixedBound (N + 1) bound B] into
               chn ShareOK[N + 1, B] then
         rename x to a in chn ShareOK[N + 1, B] then 
         subst fam ShareOK[fixedBound (N + 1) bound B] into
               chn ShareOK[N + 1, B] then 
         rename x to y, a to x in chn ShareOK[N + 1, B]
         ) 
        ) then
     using group SharesOK[bound B]
       ( subst fam ShareOK[bound (N + 1) bound B] into
               fam ShareOK[bound (N + 1) fixedBound B] then
         rename x to a in fam ShareOK[bound (N + 1) fixedBound B] then 
         subst fam ShareOK[bound (N + 1) bound B] into
               fam ShareOK[bound (N + 1) fixedBound B] then 
         rename x to y, a to x in fam ShareOK[bound (N + 1) fixedBound B] ) then    
     sym from 
      change 
        fam ShareOK[bound (N + 1) fixedBound B]
        with
         x : bool <- read Share[n, B] ; return ()
        in currentProtocol (
            subst fam Share[bound (N + 1) fixedBound B] 
             into fam ShareOK[bound (N + 1) fixedBound B]
            )
  )

   )

   case: (
    on branch n < m of family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] (
    using group SharesOK[bound B]( 
    subst fam ShareOK[bound (N + 1) bound B] 
        into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
    rename x to a in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
    subst fam ShareOK[bound (N + 1) bound B] 
        into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
    rename x to y, a to x in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
    ) 
  ) then 
  call inIndSym7 then
   using group SharesOK[bound B]
        (
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
         rename x to a in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then     
         rename x to yn, a to xn 
          in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then    
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
         rename x to a in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
         rename x to ym, a to xm 
          in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
         rename xm to a, xn to xm, yn to xn, ym to yn, a to ym 
          in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then        
         rename indices to x, y, z
           in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then     
         subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then         
         rename indices to n, m, k
           in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then     
         rename s to b in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]       
        ) then
       sym from 
         change 
        fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
        with
         r : bool <- read RcvdBit[n, m, B] ;  return ()
        in currentProtocol
       (
         using branch when isAndGate(B)
         of group Shares[fixedBound B]
         (subst fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B] 
           into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]  )
       ) then
       on branch n < m of 
        family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] 
       (subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
         into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
       ) then
       on branch m < n of 
        family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] 
       (subst fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
         into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
       ) then
       unsplit fam ShareOK[bound (N + 1) bound B] 
        and fam ShareOK[fixedBound (N + 1) bound B] inside group SharesOK[bound B] then
       using group SharesOK[bound B]
        ( on branch m = n 
          of family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] 
          (
            subst fam ShareOK[bound (N + 2) bound B] 
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
            rename x to a in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
            subst fam ShareOK[bound (N + 2) bound B] 
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
            rename x to y, a to x 
              in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] 
          )   
        ) then
        split fam ShareOK[bound (N + 2) bound B] inside group SharesOK[bound B] then   
        sym from 
         change 
        fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
        with
         c : bool <- read Ctrb[n, m, B] ; return ()
        in currentProtocol
        (
         sym from 
          change 
        fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
        with
         (when (n < m) --> 
           c : bool <- read Ctrb[n, m, B] ;  return ()
         )
         ;;
         (when (m < n) --> 
           c : bool <- read Ctrb[n, m, B] ;  return ()
         )
         ;;
         (when (m = n) --> 
           c : bool <- read Ctrb[n, m, B] ;  return ()
         )
        in currentProtocol
         (merge cases for fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] ) then
        case distinction on family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
        (
        
         case: (
         using branch when isAndGate(B) of
          group Shares[fixedBound B]
          (using branch when n < m of
            family Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
           (subst fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]) 
          )
        )
         
         case: (
         using branch when isAndGate(B) of
          group Shares[fixedBound B]
          (using branch when m < n of
            family Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
           (subst fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]) 
          )
        ) 
         
         case:   (
         using branch when isAndGate(B) of
          group Shares[fixedBound B]
          (using branch when n = m of
            family Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
           (subst fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]) 
          )
        ) 
        
        )
        ) then
  call inIndSym10 then
  subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B] 
            into fam ShareOK[bound (N + 1) fixedBound B] then
  call inIndSym11 then 
  subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
   into chn ShareOK[N + 1, B] then
  call inIndSym12 
   )  

  ) then
  merge cases for fam SharesOK[fixedBound B] then
  call addInitOK 

  )
)

.

strict subproof asym0 =
  sym from 
   change fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
     with is : unit <- read InShare$-OK[m, n, i] ;  return ()
       in currentProtocol
  (subst fam InShare$-OK[bound (N + 2) bound (N + 2) dependentBound I] 
    into fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I] 
  )        
 . 

strict subproof asym1 =
  sym from
    change 
     fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I]
    with
       s : unit <- read InShare$Sum-OK[N, n, i] ; 
       x : unit <- read In-OK[n, i] ;
       return () 
    in currentProtocol
  (subst fam In-OK[bound (N + 2) dependentBound I]
    into fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I] then
   subst fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
    into fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I]
  )             
 .
 
 strict subproof asym2 = 
  compose fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
   with fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I] in group then
sym from 
  change 
   fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
  with
        (when (0 = m) -->
           in : unit <- read InShare$-OK[m, n, i] ; return () 
        )
        ;;
        (otherwise -->
           s : unit <- read InShare$Sum-OK[m - 1, n, i] ; 
           x : unit <- read InShare$-OK[m, n, i] ;
              return () 
        )
        in currentProtocol (
in the presence of 
   fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I],
   fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]
rewrite 
 group InShare$-OK[bound N + 1 bound N + 2 dependentBound I] and InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I]
 to (
    (family InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I]
     indices: m ,n ,i 
     bounds: bound N + 1 bound N + 2 dependentBound I ::= 
     is : bool <- read InShare$-Sum[m ,n ,i] ; return ()
    ) 
    || 
    (family InShare$-OK[bound N + 1 bound N + 2 dependentBound I]
      indices: m ,n ,i 
      bounds: bound N + 1 bound N + 2 dependentBound I ::= 
      x : bool <- read In [n ,i] ; return ()
    )
   )
   by induction on m bound M
(
turn otherwise into neg 
     for fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
case distinction on  family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
  case: (
    subst fam InShare$-OK[fixedBound M bound N + 2 dependentBound I]
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]     
  )

  case: (
    subst fam InShare$Sum-OK[bound M bound (N + 2) dependentBound I] 
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
subst fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
rename is to s in fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  )
) then 
sym from 
             change 
              fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
             with 
              is : bool <- read InShare$-Sum[M, n, i] ;  return ()
             in currentProtocol
(
sym from 
    change 
              fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
             with 
              ( when (M = 0) --> 
                 is : bool <- read InShare$-Sum[M, n, i] ;  return ()
              )
              ;;
              ( when (not (M = 0)) --> 
                 is : bool <- read InShare$-Sum[M, n, i] ;  return ()
              )
             in currentProtocol
    (merge cases for 
      fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]  
    ) then
   turn otherwise into neg 
      for fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I] then
    case distinction on family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
 
     case: (
     
 subst branch when m = 0 of 
    fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
    into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  then
      drop read branch when not (m = N + 1) of  
            fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
         from fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
     )

     case: (
      subst branch when not (m = 0) of 
    fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
    into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  then
      drop read branch when not (m = N + 1) of  
            fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
         from fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
     )
    ) then 
     turn neg into otherwise 
      for fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
)
)
) then
decompose fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
   with fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
 . 

strict subproof asym01 =
  sym from change 
        fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I]
        with
          x : unit <- read In-OK[n, i] ; return ()
        in currentProtocol
 ( subst fam In-OK[bound (N + 2) dependentBound I] 
     into fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] then
    rename in to x in 
     fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I]     
 )   
 .  

strict subproof indProofInitOK =
 in the presence of fam In-OK[bound N + 2 dependentBound I] 
rewrite group InitOK[bound (N + 2) bound (N + 2) dependentBound I]
 to
   (family InShare$-OK[bound (N + 2) bound (N + 2) dependentBound I] 
     indices: m, n, i
     bounds: bound (N + 2) bound (N + 2) dependentBound I
::=
 x : unit <- read In-OK[n, i] ; return ()
)
||
(family InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]  
     indices: m, n, i
     bounds: bound (N + 1) bound (N + 2) dependentBound I
::=
x : unit <- read In-OK[n, i] ; return ()
)
||
(family InShareOK[bound (N + 2) bound (N + 2) dependentBound I] 
     indices: m, n, i
     bounds: bound (N + 2) bound (N + 2) dependentBound I
::=
x : unit <- read In-OK[n, i] ; return ()
)
 by induction on m bound M (
case distinction on
family InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
   (
    case:(
    using group InitOK[bound M bound (N + 2) dependentBound I](
    subst fam InShare$Sum-OK[bound M bound (N + 2) dependentBound I]
     into fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
    )
    )

    case:(
      idle
    ) 
   ) then
merge cases for fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I] then
   subst fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
    into fam InShareOK[fixedBound M bound (N + 2) dependentBound I] then
   turn otherwise into neg 
    for fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
   case distinction on family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
   case: (
    subst  fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
     into  fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
   )  
   case: 
   (using group InitOK[bound M bound N + 2 dependentBound I ](
    subst fam InShare$Sum-OK[bound M bound (N + 2) dependentBound I]
     into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] ) then
    subst fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
     into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
   ) 
   ) then 
   merge cases for fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
) 
. 

strict subproof symInput =
 sym from 
             change 
              fam ShareOK[bound (N + 1) fixedBound B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol(  
     using group Wires-OK[fixedBound B]
     (
       using branch when isInputGate(B) of channel Wire-OK[B]
       (subst chn Wire-OK[B] 
         into fam ShareOK[bound (N + 1) fixedBound B]
       )
     ) then
     unit-ext on fam ShareOK[bound (N + 1) fixedBound B] at 1 then
     rename in to x in fam ShareOK[bound (N + 1) fixedBound B] 
             ) 
.   

strict subproof symInputC =
  sym from 
             change 
              chn ShareOK[N + 1, B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
   (
            using group Wires-OK[fixedBound B]
            (using branch when isInputGate(B)
              of channel Wire-OK[B]
             (subst chn Wire-OK[B]
              into chn ShareOK[N + 1, B]
             ) )
              then
              unit-ext on chn ShareOK[N + 1, B] at 1 then 
              rename in to x in chn ShareOK[N + 1, B]
  ) 
. 

strict subproof wireSymNot =
   sym from 
             change 
              fam ShareOK[bound (N + 1) fixedBound B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
   (
     using group Wires-OK[fixedBound B]
     (
       using branch when isNotGate(B) 
       of channel Wire-OK[B]
       (subst chn Wire-OK[B] 
         into fam ShareOK[bound (N + 1) fixedBound B])
     ) 
   )    
 .
 
 strict subproof wireSymNotC =
    sym from 
             change 
              chn ShareOK[N + 1, B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
   (
            using group Wires-OK[fixedBound B]
            (using branch when isNotGate(B)
              of channel Wire-OK[B]
             (subst chn Wire-OK[B]
              into chn ShareOK[N + 1, B]) 
            )
  )
 .

 strict subproof wireSymXor =
  sym from 
             change 
              fam ShareOK[bound (N + 1) fixedBound B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
   (
     using group Wires-OK[fixedBound B]
     (
       using branch when isXorGate(B) 
       of channel Wire-OK[B]
       (subst chn Wire-OK[B] 
         into fam ShareOK[bound (N + 1) fixedBound B])
     ) 
   )    
 .

strict subproof wireSymXorC =
  sym from 
             change 
              chn ShareOK[N + 1, B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
   (
            using group Wires-OK[fixedBound B]
            (using branch when isXorGate(B)
              of channel Wire-OK[B]
             (subst chn Wire-OK[B]
              into chn ShareOK[N + 1, B]) 
            )
  )
 .
 strict subproof wireSymAnd =
  sym from 
             change 
              fam ShareOK[bound (N + 1) fixedBound B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
   (
     using group Wires-OK[fixedBound B]
     (
       using branch when isAndGate(B) 
       of channel Wire-OK[B]
       (subst chn Wire-OK[B] 
         into fam ShareOK[bound (N + 1) fixedBound B])
     ) 
   )          
 . 

 strict subproof wireSymAndC =
   sym from 
             change 
              chn ShareOK[N + 1, B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
   (
            using group Wires-OK[fixedBound B]
            (using branch when isAndGate(B)
              of channel Wire-OK[B]
             (subst chn Wire-OK[B]
              into chn ShareOK[N + 1, B]) 
            )
  )
 .

strict subproof symRcvdBit =
    sym from
             change 
              fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
             with 
              (when (m < n) --> 
                sb : unit <- read SendBit-OK[m, n, B]  ;
                xm : unit <- read ShareOK[m, wire0(B)] ;
                xn : unit <- read ShareOK[n, wire0(B)] ;
                ym : unit <- read ShareOK[m, wire1(B)] ; 
                yn : unit <- read ShareOK[n, wire1(B)] ; 
                return () 
              ) ;;
              (when (n <= m) --> 
                sb : unit <- read SendBit-OK[m, n, B]  ;
                xm : unit <- read ShareOK[m, wire0(B)] ;
                xn : unit <- read ShareOK[n, wire0(B)] ;
                ym : unit <- read ShareOK[m, wire1(B)] ; 
                yn : unit <- read ShareOK[n, wire1(B)] ; 
                return () 
              )
             in currentProtocol
  ( merge cases for 
     fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
  )
.

strict subproof indWiresShares =
 in the presence of 
  fam InitOK[bound (N + 2) bound (N + 2) dependentBound I]
  rewrite 
   group Wires-OK[bound K] and SharesOK[bound K]
  to
  ( 
 (family SharesOK[bound K] 
    indices: k
    bounds: bound K
::=
(when (isInputGate(k)) -->
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(family ShareOK[bound (N + 1) bound K]
  indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
  indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
)
;;
(when (isNotGate(k)) -->
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(family ShareOK[bound (N + 1) bound K]
  indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
  indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
)
;;
(when (isXorGate(k)) -->
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(family ShareOK[bound (N + 1) bound K]
  indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
  indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
)
;;
(when (isAndGate(k)) -->
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return ()
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (m < n) -->
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return ()
)
;;
(when (n <= m) -->
 rb : unit <- read RcvdBit-OK[n, m, k] ; return rb
)
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return ()
)
;;
(when (m <= n) -->
 sb : unit <- read SendBit-OK[n, m, k] ; return sb
)
)
||
(family ShareOK[bound (N + 1) bound K]
  indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
  indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
 )
)
||
(family Wires-OK[bound K] 
  indices: k
  bounds: bound K
::=
family Wire-OK[bound K] 
 indices: k
 bounds: bound K
::=
(when (isInputGate(k)) -->
 in : unit <- read In-OK[wire0(k), wire1(k)] ; return in
)
;;
(when (isNotGate(k)) -->
 w : unit <- read Wire-OK[wire0(k)] ; return ()
)
;;
(when (isXorGate(k)) -->
 w0 : unit <- read Wire-OK[wire0(k)] ;
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
;;
(when (isAndGate(k)) -->
 w0 : unit <- read Wire-OK[wire0(k)] ;
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
)
)
  by induction on k bound B 
(  
ungroup fam InitOK[bound (N + 2) bound (N + 2) dependentBound I] then
remove fam ShareOK[bound (N + 1) bound B] from group SharesOK[bound B] then
         merge cases for fam ShareOK[bound (N + 1) bound B] then
         remove fam ShareOK[fixedBound (N + 1) bound B]
           from group SharesOK[bound B] then  
         merge cases for fam ShareOK[fixedBound (N + 1) bound B] then
         unsplit fam ShareOK[bound (N + 1) bound B]
          and fam ShareOK[fixedBound (N + 1) bound B] then
 case distinction on group SharesOK[fixedBound B](
  case: (
    subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
          into fam ShareOK[bound (N + 1) fixedBound B] then
           call symInput  then
           subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
           into chn ShareOK[N + 1, B] then
           call symInputC 
  )

 case: (
    subst fam ShareOK[bound (N + 2) bound B]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          unit-ext on fam ShareOK[bound (N + 1) fixedBound B] at 1 then
           call wireSymNot then
           subst fam ShareOK[bound (N + 2) bound B]
           into chn ShareOK[N + 1, B] then
           unit-ext on chn ShareOK[N + 1, B] at 1 then
           call wireSymNotC    
  )

  case: (
     subst fam ShareOK[bound (N + 2) bound B]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          rename w to w0 in fam ShareOK[bound (N + 1) fixedBound B] then           
          subst fam ShareOK[bound (N + 2) bound B]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          rename w to w1 in fam ShareOK[bound (N + 1) fixedBound B] then           
          call wireSymXor then
           subst fam ShareOK[bound (N + 2) bound B]
           into chn ShareOK[N + 1, B] then
           rename w to w0 in chn ShareOK[N + 1, B] then
           subst fam ShareOK[bound (N + 2) bound B]
           into chn ShareOK[N + 1, B] then
           rename w to w1 in chn ShareOK[N + 1, B] then
           call wireSymXorC        
  )

    case: (
    case distinction on 
          family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         (
           case: (
            subst fam ShareOK[bound (N + 2) bound B]
             into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
            rename w to w0 in 
             fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
            subst fam ShareOK[bound (N + 2) bound B]
             into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
            rename w to w1 in 
             fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
           )
           
           case: ( idle )
         
         ) then
         rename indices to m, n, k in  
          fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
         call symRcvdBit then 
         case distinction on
          family RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         ( 
           case: (
            using branch when m < n of
            family  SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
            ( subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
               into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
            ) then
            subst fam ShareOK[bound (N + 2) bound B]
             into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
            subst fam ShareOK[bound (N + 2) bound B]
             into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
            rename w to w0 in 
             fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
            subst fam ShareOK[bound (N + 2) bound B]
             into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
            subst fam ShareOK[bound (N + 2) bound B]
             into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
            rename w to w1 in 
             fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
           )
           
           case: (
           using branch when n <= m of 
           family  SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
           (
            diverge on
             fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
             with
             fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
             var rb
           )
              
           )
          ) then 
          rename indices to n, m, k in  
          fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]  then
      case distinction on
  family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
 (
  
   case: (
    using branch when n < m of 
     family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
    (subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
      into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
    ) 
   )
   
  case: (
    using branch when m < n of 
     family RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
    (subst fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
      into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
    ) 
   )
   
   case: (
     subst fam ShareOK[bound (N + 2) bound B]
      into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
     rename w to w0 in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
      subst fam ShareOK[bound (N + 2) bound B]
      into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
     rename w to w1 in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
   )
 
 ) then 
 merge cases for 
  fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
          then
      in the presence of fam  Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
      rewrite family CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
      to 
       w0 : unit <- read Wire-OK[wire0(B)] ;
       w1 : unit <- read Wire-OK[wire1(B)] ;
       return () 
      by induction on m bound M
      (
        case distinction on family CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B](
          case: (
            subst fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
             into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
          )
          case: (subst fam CtrbSum-OK[bound N + 2 bound M fixedBound B]
         into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B] then
       subst fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
         into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]) 

        ) then
      merge cases for 
        fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
      ) then
          subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          call wireSymAnd then
          subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
           into chn ShareOK[N + 1, B] then
          call wireSymAndC

    )
 ) then 
 call addInitOK then
         split fam ShareOK[bound (N + 2) bound B] on first index then
         move family ShareOK[bound (N + 1) bound B] 
          on each branch of group SharesOK[bound B] then
         move family ShareOK[fixedBound (N + 1) bound B] 
          on each branch of group SharesOK[bound B] 
  )  
.

strict subproof addHidden = 
  sym from 
  extend currentProtocol 
  with internal family Hidden
  indices: k
  bounds: bound K 
  typed: unit
  assigned:
   return ()
 ( absorb fam Hidden[bound K]  
 )
.

strict subproof addHiddenGroup =
group  
  fam Hidden[bound K]
in HiddenGroup 
indices: k
bounds: bound K 
.

strict subproof symSharesInput =
  sym from 
             change 
              chn Share[N + 1, B]
             with 
              in : bool <- read InShare[N + 1, wire0(B),wire1(B)] ; 
              w : unit <- read Wire-OK[B] ;
              return in
             in currentProtocol
            (
              rename in to is in chn Share[N + 1, B] then
              using group Wires-OK[bound K]
              (subst fam Wire-OK[bound K]
                into chn  Share[N + 1, B]
              ) then  
              rename in to x, is to in
               in chn Share[N + 1, B]
            )             
 .

 strict subproof symSharesNot = 
  sym from 
            change 
              chn Share[N + 1, B]
             with 
              w : unit <- read Wire-OK[B] ;
              x : bool <- read Share[N + 1, wire0(B)] ; 
              return neg(x)
             in currentProtocol
           (
             using group Wires-OK[bound K]
              (subst fam Wire-OK[bound K]
                into chn  Share[N + 1, B]
              )  
           ) 
 .
 
 strict subproof symSharesXor = 
  sym from 
            change 
              chn Share[N + 1, B]
             with 
              w : unit <- read Wire-OK[B] ;
              x : bool <- read Share[N + 1, wire0(B)] ; 
              y : bool <- read Share[N + 1, wire1(B)] ; 
              return xor((x, y))
             in currentProtocol
           (
             using group Wires-OK[bound K]
              (subst fam Wire-OK[bound K]
                into chn  Share[N + 1, B]
              )  
           ) 
 .
  
 strict subproof symSharesAnd = 
  sym from 
            change 
              chn Share[N + 1, B]
             with 
              bs : bool <- read CtrbSum[N + 1, N + 1, B] ; 
              w : unit <- read Wire-OK[B] ; 
              return bs
             in currentProtocol
           (
             using group Wires-OK[bound K]
              (subst fam Wire-OK[bound K]
                into chn  Share[N + 1, B]
              )  
           )
 .

strict subproof indTimingShares =
 in the presence of 
 fam InitOK[bound N + 2 bound N + 2 dependentBound I],
 fam Wires-OK[bound K],
 fam ShareOK[fixedBound (N + 1) bound K],
 fam CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
rewrite group HiddenGroup[bound K] and Shares[bound K]
  to 
  (
(family HiddenGroup[bound K] 
  indices: k
  bounds: bound K
::=
(family Hidden[bound K] 
  indices: k
  bounds: bound K
::=
return ()
)
)
||
 (
    family Shares[bound K]
     indices: k
  bounds: bound K
::=
(
(when (isInputGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <- read InShare[n , wire0(k) , wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 in : bool <- read InShare[N + 1, wire0(k) , wire1(k)] ; 
 w : unit <- read  Wire-OK[k] ; 
 return in
) 
)
)
;;
(when (isNotGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <- read Share[n , wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read  Wire-OK[k] ;
 x : bool <- read Share[N + 1 , wire0(k)] ; 
 return neg(x)
) 
)
)
;;
(when (isXorGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <- read Share[n , wire0(k)] ;  
 y : bool <- read Share[n , wire1(k)] ; 
 return  xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read  Wire-OK[k] ;
 x : bool <- read Share[N + 1, wire0(k)] ; 
 y : bool <- read Share[N + 1, wire1(k)] ; 
 return  xor((x, y))
)
)
)
;;
when (isAndGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <- read SendBit[n, m, k] ; return s
) 
;;
(when (m = n) -->
 x : bool <- read Share[n , wire0(k)] ;
 y : bool <- read Share[n , wire1(k)] ; 
 return  **((x, y))
) 
;;
(when (m < n) -->
 r : bool <- read RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (0 = m) -->
 b : bool <- read Ctrb[n, 0, k] ; return b
) 
;;
(when not (0 = m) -->
 b : bool <- read Ctrb[n, m, k] ; 
 s : bool <- read CtrbSum[n, m - 1, k] ; 
 return xor((s, b))
) 
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read SendBit[m, n, k] ;
 xm : bool <- read Share[m , wire0(k)] ; 
 xn : bool <- read Share[n , wire0(k)] ; 
 ym : bool <- read Share[m , wire1(k)] ; 
 yn : bool <- read Share[n, wire1(k)] ; 
 return xor( ( xor( (**((xm, yn)), **((xn, ym))) ) , b) ) 
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <- read Share[n , wire0(k)] ;
 y : bool <- read Share[n , wire1(k)] ; 
  samp flip (())
)
;;
(when (m <= n) -->
 sb : bool <- read SendBit[n, m, k] ; return sb
)
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[N + 1, N + 1, k] ;
 w : unit <- read Wire-OK[k] ; 
 return bs
)
)
) 
 )
)
  by induction on k bound B (
ungroup fam InitOK[bound N + 2 bound N + 2 dependentBound I] then
case distinction on group Shares[fixedBound B] (
  case: (
     subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I] 
      into chn Share[N + 1, B] then 
     call symSharesInput
  )
  case: (
    subst fam ShareOK[fixedBound (N + 1) bound K] 
      into chn Share[N + 1, B] then 
     call symSharesNot
  )
  case: (
    subst fam ShareOK[fixedBound (N + 1) bound K] 
      into chn Share[N + 1, B] then 
     rename w to w0 in chn Share[N + 1, B] then
     subst fam ShareOK[fixedBound (N + 1) bound K] 
      into chn Share[N + 1, B] then 
     rename w to w1 in chn Share[N + 1, B] then      
     call symSharesXor
  )
  case: (
    subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
      into chn Share[N + 1, B] then    
     call symSharesAnd
  )
) then
call addInitOK
)

.

strict subproof addCtrbsOK = 
group  
   fam SendBit-OK[bound N + 2 bound N + 2 bound K],
   fam RcvdBit-OK[bound N + 2 bound N + 2 bound K],
   fam Ctrb-OK[bound N + 2 bound N + 2 bound K],
   fam CtrbSum-OK[bound N + 2 bound N + 2 bound K]
in Ctrbs-OK 
indices: k
bounds: bound K .

strict subproof restoreCtrbsOK = 
 call addCtrbsOK then
 sym from 
  change fam Ctrbs-OK[bound K]
    with 
    (
(when isInputGate(k) --> (
 (family SendBit-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k 
    bounds: bound N + 2 bound N + 2 bound K ::= 
    s : unit <- read SendBit-OK[n ,m ,k ] ;
    return s
 ) || 
 (family RcvdBit-OK[bound N + 2 bound N + 2 bound K] 
    indices: n ,m ,k 
    bounds: bound N + 2 bound N + 2 bound K ::= 
    r : unit <- read RcvdBit-OK[n ,m ,k ] ; 
    return r 
 ) || 
 (family CtrbSum-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k 
    bounds: bound N + 2 bound N + 2 bound K ::= 
    c : unit <- read CtrbSum-OK[n ,m ,k] ; return c
 ) || 
 (family Ctrb-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k 
    bounds: bound N + 2 bound N + 2 bound K ::= 
    c : unit <- read Ctrb-OK[n ,m ,k ] ; return c 
 ) 
 )
) 
 ;; 
( when isNotGate(k) --> (
 (family SendBit-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k 
    bounds: bound N + 2 bound N + 2 bound K ::= 
    s : unit <- read SendBit-OK[n ,m ,k ] ; return s
 ) || 
 (family RcvdBit-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    r : unit <- read RcvdBit-OK[n ,m ,k ] ; return r 
 ) || 
 (family CtrbSum-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    c : unit <- read CtrbSum-OK[n ,m ,k ] ; return c 
 ) || 
 (family Ctrb-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    c : unit <- read Ctrb-OK[n ,m ,k ] ; return c 
 )
 )
)   
;; 
( when isXorGate(k) --> (
 (family SendBit-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k 
    bounds: bound N + 2 bound N + 2 bound K ::= 
    s : unit <- read SendBit-OK[n ,m ,k ] ; return s
 ) || 
 (family RcvdBit-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    r : unit <- read RcvdBit-OK[n ,m ,k ] ; return r 
 ) || 
 (family CtrbSum-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    c : unit <- read CtrbSum-OK[n ,m ,k ] ; return c 
 ) || 
 (family Ctrb-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    c : unit <- read Ctrb-OK[n ,m ,k ] ; return c 
 )
 )
)    
;; 
(
when isAndGate(k)--> (
 (family SendBit-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    (
    (when n < m --> 
     w0 : unit <- read Wire-OK[wire0(k)] ; 
     w1 : unit <- read Wire-OK[wire1(k)] ; 
     return ()
   ) 
   ;; 
   (when m <= n --> 
    sb : unit <- read SendBit-OK[n ,m ,k ] ; 
    return sb
   )
   ) 
 ) || 
 (family RcvdBit-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    (
    (when m < n --> 
      w0 : unit <- read Wire-OK[wire0(k)] ; 
      w1 : unit <- read Wire-OK[wire1(k)] ;
      return ()
    ) 
    ;; 
    (when n <= m --> 
      rb : unit <- read RcvdBit-OK[n ,m ,k ] ; 
      return rb
    )
    ) 
 ) || 
 (family CtrbSum-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    w0 : unit <- read Wire-OK[wire0(k)] ;
    w1 : unit <- read Wire-OK[wire1(k)] ;
    return ()
 ) || 
 (family Ctrb-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
     w0 : unit <- read Wire-OK[wire0(k)] ;
     w1 : unit <- read Wire-OK[wire1(k)] ; 
     return ()
 )
 )
)
)
      in currentProtocol
  ( combine fam Ctrbs-OK[bound K] then
    call addCtrbsOK 
  )         
.  

strict subproof introShareSumOK = 
 sym from 
  extend currentProtocol 
  with internal family ShareSum-OK 
  indices: m, k 
  bounds: bound N + 1 bound K 
  typed: unit
  assigned:
   s : bool  <- read ShareSum[m, k] ;
   return ()
 ( absorb fam ShareSum-OK[bound N + 1 bound K]  
 )
.

strict subproof sym20 =
 sym from  
         branch 
          when isAndGate(k)
         of
          fam Adv[bound K]
         change
          fam  OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K]
         with
          (when (n < N + 1) -->
             x : unit <- read ShareSum-OK[N, wire1(k)] ; return ()
          )  
          ;;
          (when (n = N + 1) -->
             oc : unit <- read OTChcRcvd-1OtAdv[n, N + 1, k] ; return oc
          )
          in
          (
          branch 
           when isAndGate(k)
         of
          fam Adv[bound K]
         change
          fam  OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K]
         with
          (when (n < N + 1) -->
             x : unit <- read ShareSum-OK[N, wire0(k)] ; return ()
          )   
          ;;
          (when (n = N + 1) -->
             oc : unit <- read OTChcRcvd-0OtAdv[n, N + 1, k] ; return oc
          )
          in
          currentProtocol)
       (
       on branch isAndGate(k)
          of group Adv[bound K]
         (on branch n < N + 1 
           of family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K]
           ( subst fam ShareSum-OK[bound (N + 1) bound K] 
              into fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] then
             rename s to x 
              in fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K]      
           ) then
           on branch n < N + 1
           of family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K]
           ( subst fam ShareSum-OK[bound (N + 1) bound K] 
              into fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] then
             rename s to x 
              in fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K]      
           )
           
         )
     )     
   . 

strict subproof symShareSumOK0 =
  sym from
        change 
         fam ShareSum-OK[fixedBound M bound K]
        with
         s : bool <- read ShareSum[M, k] ;  return ()
        in 
        currentProtocol
       (call subst1 then
       rename s to x in fam ShareSum-OK[fixedBound M bound K]
       )                             
 .
 
strict subproof subst1 = 
    subst branch when (0 = m)
    of fam ShareSum[bound (N + 2) bound K]
    into fam  ShareSum-OK[fixedBound M bound K] 

 . 
strict subproof symShareSumOKM = 
  sym from
        change 
         fam ShareSum-OK[fixedBound M bound K]
        with
         s : bool <- read ShareSum[M, k] ;  return ()
        in 
        currentProtocol
       (call subst2 then
       rename xm to x, xs to s 
         in fam ShareSum-OK[fixedBound M bound K]
       )        
 .

strict subproof subst2 = 
 subst branch when not (0 = m)
    of fam ShareSum[bound (N + 2) bound K]
    into fam  ShareSum-OK[fixedBound M bound K] 
 . 

strict subproof inIndSym9 =
 sym from 
         change 
        fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
        with
         c : bool <- read Ctrb[n, m, B] ; return ()
        in currentProtocol
        (
         sym from 
          change 
        fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
        with
         (when (n < m) --> 
           c : bool <- read Ctrb[n, m, B] ;  return ()
         )
         ;;
         (when (m < n) --> 
           c : bool <- read Ctrb[n, m, B] ;  return ()
         )
         ;;
         (when (m = n) --> 
           c : bool <- read Ctrb[n, m, B] ;  return ()
         )
        in currentProtocol
         (merge cases for fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] ) then
        on branch n < m of 
           family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
         (
         using branch when isAndGate(B) of
          group Shares[fixedBound B]
          (using branch when n < m of
            family Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
           (subst fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]) 
          )
        ) then 
        on branch m < n of 
           family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
         (
         using branch when isAndGate(B) of
          group Shares[fixedBound B]
          (using branch when m < n of
            family Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
           (subst fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]) 
          )
        ) then 
        on branch n = m of 
           family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
         (
         using branch when isAndGate(B) of
          group Shares[fixedBound B]
          (using branch when n = m of
            family Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
           (subst fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]) 
          )
        ) 
        )
        .  
strict subproof addGroupOS = 
  group 
    fam OutShareSum[bound (N + 2) bound (N + 2) bound K]
  in GroupOS
  indices: n, m, k
  bounds: bound (N + 2) bound (N + 2) bound K
 . 

 strict subproof addBranchGroupOS =
  sym from  
   change 
        fam GroupOS[bound (N + 2) bound (N + 2) bound K]
        with (
        (when (isOutputWire(k))  --> 
         (family OutShareSum[bound N + 2 bound N + 2 bound K ]
          indices: n ,m ,k 
          bounds: bound N + 2 bound N + 2 bound K ::= 
          (when (0 = m) --> 
           s : bool <- read OutShare [n ,0 ,k ] ; return s 
          ) ;;
          (otherwise --> 
            s : bool <- read OutShareSum [n ,m - 1 ,k ] ; 
            x : bool <- read OutShare [n ,m ,k ] ;
            return xor((s ,x ))
          )
         ) 
        )  ;;
        (when (not isOutputWire(k))  --> 
         (family OutShareSum[bound N + 2 bound N + 2 bound K ]
          indices: n ,m ,k 
          bounds: bound N + 2 bound N + 2 bound K ::= 
          (when (0 = m) --> 
           s : bool <- read OutShare [n ,0 ,k ] ; return s 
          ) ;;
          (otherwise --> 
            s : bool <- read OutShareSum [n ,m - 1 ,k ] ; 
            x : bool <- read OutShare [n ,m ,k ] ;
            return xor((s ,x ))
          )
         )
        )
        ) 
        in currentProtocol
    (
   merge cases for fam GroupOS[bound (N + 2) bound (N + 2) bound K]
    )
 .

strict subproof indShareSum = 
 in the presence of 
  fam Share[bound (N + 1) fixedBound B],
  fam InShare[bound (N + 2) bound (N + 2) dependentBound I],
  fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I] 
 rewrite family ShareSum[bound (N + 1) fixedBound B]
 to i : bool <- read InShare$-Sum[m, wire0(B), wire1(B)] ; 
    return i
 by induction on m bound M (

 case distinction on 
     channel ShareSum[M, B]
   (
   
   case: (
    subst fam Share[bound (N + 1) fixedBound B]
     into chn ShareSum[M, B] then
    subst fam InShare[bound (N + 2) bound (N + 2) dependentBound I]  
     into chn ShareSum[M, B] then
      sym from
   change chn ShareSum[M, B]
        with
         in : bool <- read InShare$-Sum[M, wire0(B), wire1(B)] ;
         return in
        in currentProtocol
       (
        
           subst branch when m = 0 of fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
            into chn ShareSum[M, B]
        
       )
   )

    case: (
    subst fam Share[bound (N + 1) fixedBound B]
     into chn ShareSum[M, B] then
    subst fam InShare[bound (N + 2) bound (N + 2) dependentBound I]  
     into chn ShareSum[M, B] then 
    subst fam ShareSum[bound M fixedBound B]
     into chn ShareSum[M, B] then
    rename i to s, in to x 
     in chn ShareSum[M, B] then   
      sym from
   change chn ShareSum[M, B]
        with
         in : bool <- read InShare$-Sum[M, wire0(B), wire1(B)] ;
         return in
        in currentProtocol
       (
        
           subst branch when (not (m = 0))
            of fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
            into chn ShareSum[M, B] 
         
       )
          )
   ) then 
   merge cases for chn ShareSum[M, B] then
   rename in to i 
    in chn ShareSum[M, B]
  )  
.
strict subproof addInternalsInputBranch = 
 sym from 
  extend 
   ( 
    extend 
     (extend currentProtocol 
        with internal family InShare$Sum-OK
                     indices: m, p, i 
                     bounds: bound (N + 1) bound (N + 2) dependentBound I  
                     typed: unit 
                     assigned: 
                       i : bool  <- read InShare$-Sum[m, p, i] ;
                      return ()
     )
     with internal family InShare$-OK 
                   indices: m, p, i
                   bounds: bound (N + 1) bound (N + 2) dependentBound I  
                   typed: unit
                   assigned:   
                      i : bool  <- read InShare$[m, p, i] ;
                      return ()
   ) 
  with internal family In-OK 
                indices: p, i 
                bounds: bound (N + 2) dependentBound I 
                typed: unit
                assigned: 
                  i : bool <- read In[p, i] ; return ()
 (
  absorb fam In-OK[bound (N + 2) dependentBound I] then
  absorb fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] then
  absorb fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
 )      
 .   

strict subproof pSetupInd0 =
  in the presence of 
   fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I],
   fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
  rewrite family InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]    
  to i : bool <- read InShare$-Sum[m, p, i] ;
     return ()
  by induction on m bound M (
     case distinction on 
      family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
     (
     
     case: (
     subst fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I]
      into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
     sym from 
    change 
        fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
        with
         i : bool  <- read InShare$-Sum[M, p, i] ;
         return ()
        in currentProtocol
        ( subst branch when m = 0 of fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
           into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
       rename in to i 
        in fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
        )      
     )
     
     case: (
     subst fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I]
      into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
     rename i to x 
      in fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
     subst fam InShare$Sum-OK[bound M bound (N + 2) dependentBound I]
      into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then 
     rename i to s  
      in fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
      sym from
   change 
        fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
        with
         i : bool  <- read InShare$-Sum[M, p, i] ;
         return ()
        in currentProtocol
       (
           subst branch when not (m = 0) 
            of fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
            into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
      )                      
     )
     
     ) then
     merge cases for
      fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  )  
.

strict subproof dropInShare$ = 
  rename indices to m, p, i
     in fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] then
    drop read branch when not (m = N + 1)  of fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
             from fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] then
    rename indices to m, n, i
     in fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]    
 .

 strict subproof rewriteSharesBoundNotAux =
  in the presence of 
  fam Shares[bound B],
  fam Share[bound (N + 1) fixedBound B] 
 rewrite family ShareSum[bound (N + 1) fixedBound B]
 to s : bool <- read ShareSum[m, wire0(B)] ; return s
 by induction on m bound M (
 remove and merge fam ShareSum[bound(N + 1) bound B] 
      from group Shares[bound B] then
     case distinction on  
       channel ShareSum[M, B]
     (
       case:(
       subst fam Share[bound (N + 1) fixedBound B]
        into chn ShareSum[M, B]
       )
       case:(
        subst fam Share[bound (N + 1) fixedBound B]
        into chn ShareSum[M, B] then
        rename s to new in chn ShareSum[M, B] then
        subst fam ShareSum[bound M fixedBound B]
        into chn ShareSum[M, B] 
       )
     ) then
    sym from change chn ShareSum[M, B]
       with
        (when (0 = M) -->
           s : bool <- read ShareSum[M, wire0(B)] ; return s
        )
       ;;
        (when (not (0 = M)) -->
           s : bool <- read ShareSum[M, wire0(B)] ; return s
        )
       in currentProtocol (
         case distinction on channel
        ShareSum[M, B]
       (
         case: (
           subst branch when (m = 0) of fam ShareSum[bound (N + 1) bound B]
        into chn ShareSum[M, B]
        )
         case: (
         subst  branch when not (m = 0) of fam ShareSum[bound (N + 1) bound B]
        into chn ShareSum[M, B] then
           rename xm to new, xs to s
            in chn  ShareSum[M, B] 
         )
       )
       ) then
       merge cases for chn ShareSum[M, B] then 
      move family ShareSum[bound (N + 1) bound B] 
       on each branch of group Shares[bound B]
    )
 .
 strict subproof setupIndShareSumXor = 
in the presence of
  fam Shares[bound B],
  fam Share[bound (N + 1) fixedBound B] 
 rewrite family ShareSum[bound (N + 1) fixedBound B]
 to x : bool <- read ShareSum[m, wire0(B)] ; 
    y : bool <- read ShareSum[m, wire1(B)] ; 
    return xor((x, y))
 by induction on m bound M (
remove and merge fam ShareSum[bound (N + 1) bound B]
    from group Shares[bound B] then
case distinction on channel ShareSum[M, B]
  (
  
   case: (
   
     subst fam Share[bound (N + 1) fixedBound B]
      into chn ShareSum[M, B] then
     sym from change 
        chn ShareSum[M, B]
        with
         x : bool <- read ShareSum[M, wire0(B)] ;
         y : bool <- read ShareSum[M, wire1(B)] ;
         return xor((x, y))
        in currentProtocol
        ( call pSubstFamCaseChn0 then
        rename s to x 
          in chn ShareSum[M, B] then
          call pSubstFamCaseChn0 then
        rename s to y 
          in chn ShareSum[M, B] 
        )  
   )
   
   case: (
     subst fam ShareSum[bound M fixedBound B] 
      into chn ShareSum[M, B] then
     rename x to a, y to b 
       in chn ShareSum[M, B] then
     subst fam Share[bound (N + 1) fixedBound B]
      into chn ShareSum[M, B] then
     use expression assumption rearrange-xor
          on chn ShareSum[M, B] at 1 then        
     sym from change 
        chn ShareSum[M, B]
        with
         x : bool <- read ShareSum[M, wire0(B)] ;
         y : bool <- read ShareSum[M, wire1(B)] ; 
         return xor((x, y))
        in currentProtocol
        (subst branch when not (m = 0) of fam ShareSum[bound (N + 1) bound B] 
   into chn ShareSum[M, B] at x then
         rename xs to a, xm to x in chn ShareSum[M, B] then
           subst branch when not (m = 0) of fam ShareSum[bound (N + 1) bound B] 
   into chn ShareSum[M, B] at y then
         rename xs to b, xm to y in chn ShareSum[M, B]                
        
        )
   )
  ) then
  merge cases for chn ShareSum[M, B] then
  move family ShareSum[bound (N + 1) bound B]
    on each branch of group Shares[bound B] 
 )  
.
strict subproof pSubstFamCaseChn0 =
  subst branch when m = 0 of fam ShareSum[bound (N + 1) bound B] 
   into chn ShareSum[M, B]
 . 

strict subproof pSubstFamCaseChn1 =
  subst branch when not (m = 0) of fam ShareSum[bound (N + 1) bound B] 
   into chn ShareSum[M, B]
 .  

strict subproof addColAndColSum =
 sym from
  extend
  (extend currentProtocol 
        with internal family Col
                     indices: i, j
                     bounds: bound (N + 2) bound (N + 2)
                     typed: bool 
                     assigned: 
                       c : bool  <- read CtrbSum[i, j, B] ;
                      return c
     )
  with internal family ColSum
                     indices: i, j
                     bounds: bound (N + 2) bound (N + 2)
                     typed: bool 
                     assigned: 
                     ( (when (i = 0) --> 
                        c : bool <- read Col[0, j] ; return c
                      ) 
                      ;;
                      (when (not (i = 0)) --> 
                        bs : bool <- read ColSum[i - 1, j] ;
                        bi : bool <- read Col[i, j] ;
                        return xor((bs, bi))
                      )  
                     ) 
 (
   absorb fam Col[bound (N + 2) bound (N + 2)] then
   absorb fam ColSum[bound (N + 2) bound (N + 2)]
 )    
 .

strict subproof setupIndSSAnd = 
in the presence of 
 fam Share[bound (N + 1) fixedBound B] ,
 fam ColSum[bound (N + 2) bound (N + 2)] ,
 fam Col[bound (N + 2) bound (N + 2)]
rewrite family ShareSum[bound (N + 1) fixedBound B]
to c : bool <- read ColSum[m, N + 1] ; return c
by induction on m bound M
(
 case distinction on 
  channel ShareSum[M, B]
 (
 
  case:(
  subst fam Share[bound (N + 1) fixedBound B]
   into chn ShareSum[M, B] then 
  sym from change 
        chn ShareSum[M, B]
        with
         c : bool <- read ColSum[M, N + 1] ; return c
        in currentProtocol
        ( 
   subst branch when i = 0 of fam ColSum[bound (N + 2) bound (N + 2)]
    into chn ShareSum[M, B] then
          subst fam Col[bound (N + 2) bound (N + 2)]
           into chn ShareSum[M, B] then
          rename c to bs in chn ShareSum[M, B] 
        )
  )
  
  case: (
  subst fam Share[bound (N + 1) fixedBound B]
   into chn ShareSum[M, B] then
  subst fam ShareSum[bound M fixedBound B]
   into chn ShareSum[M, B] then
   sym from change 
        chn ShareSum[M, B]
        with
         c : bool <- read ColSum[M, N + 1] ; return c
        in currentProtocol
        (      
   subst  branch when (not (i = 0)) of  fam ColSum[bound (N + 2) bound (N + 2)]
    into chn ShareSum[M, B] then
 subst fam Col[bound (N + 2) bound (N + 2)]
    into chn ShareSum[M, B]  then 
 rename c to t in chn ShareSum[M, B]  then 
 rename bs to c in chn ShareSum[M, B]  then 
 rename t to bs in chn ShareSum[M, B] 
 )       
  ) 
   
 ) then 
 merge cases for chn ShareSum[M, B] 
)     
.

strict subproof changeColToInductive =
 sym from  
             change fam Col[bound (N + 2) bound (N + 2)]
             with 
              (when (j = 0) --> 
                c : bool  <- read Ctrb[i, 0, B] ; 
                return c
              )
              ;;
              (when (not (j = 0)) --> 
                bs : bool <- read Col[i, j - 1] ;
                bj : bool <- read Ctrb[i, j, B] ;
                return xor((bs, bj))
              )
             in currentProtocol
 (
 in the presence of 
 fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
 rewrite family Col[bound (N + 2) bound (N + 2)]
 to c : bool <- read CtrbSum[i, j, B] ; return c
 by induction on j bound J
(
  case distinction on 
   family Col[bound (N + 2) fixedBound J]
  (
   case: (
    sym from 
  change
   fam Col[bound (N + 2) fixedBound J]
  with c : bool <- read CtrbSum[i, J, B] ; return c
  in currentProtocol 
  (  subst branch when (m = 0) of fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
       into fam Col[bound (N + 2) fixedBound J] then
    rename b to c in fam Col[bound (N + 2) fixedBound J]
  ) 
   )
   
   case: (
    subst fam Col[bound (N + 2) bound J]
     into fam Col[bound (N + 2) fixedBound J] then
    sym from 
  change
   fam Col[bound (N + 2) fixedBound J]
  with c : bool <- read CtrbSum[i, J, B] ; return c
  in currentProtocol 
(   subst branch when (not (m = 0)) of fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
     into fam Col[bound (N + 2) fixedBound J] then 
  rename b to bj, s to c 
   in fam Col[bound (N + 2) fixedBound J]      
 )
   )
  ) then  
 merge cases for fam Col[bound (N + 2) fixedBound J]      
)
)
.     

strict subproof addRowAndRowSum =
 sym from
 ( extend
   (extend currentProtocol 
        with internal family Row
                     indices: i, j
                     bounds: bound (N + 2) bound (N + 2)
                     typed: bool 
                     assigned: 
                      ( when (i = 0) --> 
                         c : bool <- read Ctrb[0, j, B] ; return c
                      )
                      ;;
                      (when (not (i = 0)) -->
                        r : bool <- read Row[i - 1, j] ;
                        bi : bool <- read Ctrb[i, j, B] ;
                        return xor((r, bi)) 
                      )
     )
     with internal family RowSum
                     indices: i, j
                     bounds: bound (N + 2) bound (N + 2)
                     typed: bool 
                     assigned: 
                      ( when (j = 0) --> 
                         r : bool <- read Row[i, 0] ; return r
                      )
                      ;;
                      (when (not (j = 0)) -->
                        r : bool <- read RowSum[i, j - 1] ;
                        bj : bool <- read Row[i, j] ;
                        return xor((r, bj)) 
                      ) 
 )
(
 absorb fam Row[bound (N + 2) bound (N + 2)] then
 absorb fam RowSum[bound (N + 2) bound (N + 2)]
 )       
 .

strict subproof symColSumSameCasesPartTwo =
 sym from 
 change chn ColSum[X, Y]
 with
  (when (Y = 0) --> 
    r : bool <- read RowSum[X, Y] ; return r
  )
   ;;
  (when (not (Y = 0)) --> 
    r : bool <- read RowSum[X, Y] ; return r
  )
   in currentProtocol
   (merge cases for chn ColSum[X, Y])
. 

strict subproof setupIndColRowPartTwo =
  in the presence of 
   fam Row[bound (N + 2) bound (N + 2)] ,
   fam Col[bound (N + 2) bound (N + 2)] 
  rewrite group 
  RowSum[fixedBound X bound N + 2] and ColSum[fixedBound X bound N + 2]
  to  
  (
   (family RowSum[fixedBound X bound (N + 2)]
 indices: i, j
 bounds: fixedBound X bound (N + 2)
::=
 c : bool <- read ColSum[0, j] ; return c
)
||
(family ColSum[fixedBound X bound (N + 2)]
  indices: i, j
 bounds: fixedBound X bound (N + 2)
::=
 c : bool <- read Col[0, j] ; return c
)
  )
  by induction on j bound Y (
        call symColSumSameCasesPartTwo then
        merge case for chn RowSum[X, Y] and chn ColSum[X, Y]
         into group CGroup then
        case distinction on 
         group CGroup[bound 1] 
        (
        case:(
          subst  branch when (i = 0) of fam Row[bound (N + 2) bound (N + 2)]
           into chn RowSum[X, Y] then   
        sym from 
  change chn RowSum[X, Y] 
  with c : bool <- read Col[0, Y] ; return c
  in currentProtocol
  (
   subst branch when (j = 0) of fam Col[bound (N + 2) bound (N + 2)]
     into chn RowSum[X, Y] 
  )   then
        subst chn RowSum[X, Y] into chn ColSum[X, Y] then
       sym from
 change chn RowSum[X, Y] 
 with c : bool <- read ColSum[X, Y] ; return c
 in currentProtocol
 (
   subst chn ColSum[X, Y]
    into chn RowSum[X, Y]
 ) then
        use assumptions for X in chn RowSum[X, Y]
       )
        
       case: (
        subst fam RowSum[fixedBound X bound Y]
         into chn RowSum[X, Y] then
        subst fam ColSum[fixedBound X bound Y]
         into chn RowSum[X, Y] then
        rename c to bs
            in chn RowSum[X, Y] then
         subst branch when (i = 0) of fam Row[bound (N + 2) bound (N + 2)]
          into chn RowSum[X, Y] then
        rename c to bj   
          in chn RowSum[X, Y] then
        sym from
  change chn RowSum[X, Y]
  with  c : bool <- read Col[X, Y] ; return c
  in currentProtocol
  (
     subst branch when (not (j = 0)) of fam Col[bound (N + 2) bound (N + 2)]
        into chn RowSum[X, Y] then
     use assumptions for X in chn RowSum[X, Y]
  ) then               
        subst chn RowSum[X, Y] into chn ColSum[X, Y] then
        sym from
 change chn RowSum[X, Y]
 with  c : bool <- read ColSum[X, Y] ; return c
 in currentProtocol
 (subst chn ColSum[X, Y] 
  into chn RowSum[X, Y]
 ) then 
        use assumptions for X in chn RowSum[X, Y] then
        use assumptions for X in chn ColSum[X, Y]
       )         
        ) then
        merge cases for fam CGroup[bound 1] then
        ungroup fam CGroup[bound 1]  
)
.
strict subproof symForRowSumPart2Zero =
 sym from
   change chn RowSum[X, Y]
   with 
     c : bool <- read ColSum[X, Y] ;
     return c
   in currentProtocol
  ( subst chn ColSum[X, Y]
     into chn RowSum[X, Y]
  )
.     
strict subproof symForColSumPart2Zero =
 sym from
  change chn ColSum[X, Y]
    with 
      bi : bool <- read Col[X, Y] ;
      bs : bool <- read ColSum[X - 1, Y] ;
      return xor((bs, bi))
    in currentProtocol
    ( use assumptions for Y in chn ColSum[X, Y])
. 

strict subproof symRSPartTwoNZ =
 sym from 
  change chn RowSum[X, Y] 
  with
   bi : bool <- read Col[X, Y] ;
   bs : bool <- read ColSum[X - 1, Y] ;
   return xor((bs, bi)) 
  in currentProtocol
       ( subst fam ColSum[bound X bound (N + 2)] 
          into chn RowSum[X, Y] then
         subst branch when (not (j = 0)) of fam Col[bound (N + 2) bound (N + 2)]
            into chn RowSum[X, Y] then 
         rename bj to b, bs to bc
             in chn RowSum[X, Y] then  
         subst branch when (not (j = 0)) of fam RowSum[bound X bound (N + 2)]
            into chn RowSum[X, Y] then 
         rename bj to br, r to bs
          in chn RowSum[X, Y]
       )
 .

strict subproof setupIndColRow =
 in the presence of 
  fam Col[bound (N + 2) bound (N + 2)] ,
  fam Row[bound (N + 2) bound (N + 2)]   
 rewrite group 
  RowSum[bound (N + 2) bound (N + 2)] and ColSum[bound (N + 2) bound (N + 2)]
 to 
 (
 (family ColSum[bound (N + 2) bound (N + 2)] 
  indices: i, j
  bounds: bound (N + 2) bound (N + 2)
::=
 r : bool <- read RowSum[i, j] ; return r
)
||
(family RowSum[bound (N + 2) bound (N + 2)] 
  indices: i, j
  bounds: bound (N + 2) bound (N + 2)
::=
(when (0 = j) -->
  r : bool <- read Row[i, 0] ; return r
)  
;;
(when (not (0 = j)) -->
  bj : bool <- read Row[i, j] ; 
   r : bool <- read RowSum[i, j - 1] ;
   return xor((r, bj))
)
)
 )
 by induction on i bound X
`` big induction starts here
( 
case distinction on family ColSum[fixedBound X bound (N + 2)] (
    case:(
`` this branch works, keep
in the presence of 
   fam Row[bound (N + 2) bound (N + 2)] ,
   fam Col[bound (N + 2) bound (N + 2)] ,
   fam ColSum[fixedBound X bound (N + 2)]
  rewrite family RowSum[fixedBound X bound (N + 2)]
  to c : bool <- read ColSum[0, j] ; return c
  by induction on j bound Y
  (
    case distinction on
     channel RowSum[X, Y]
    (
    
     case: (
      
        subst branch when (i = 0) of fam Row[bound (N + 2) bound (N + 2)]
         into chn RowSum[X, Y] then
       sym from change 
        chn RowSum[X, Y]
        with c : bool <- read ColSum[0, Y] ; return c
        in currentProtocol
   (  subst fam ColSum[fixedBound X bound (N + 2)]
         into chn RowSum[X, Y] then         
          subst branch when (j = 0) of fam Col[bound (N + 2) bound (N + 2)]
           into chn RowSum[X, Y] 
  ) 
     )
     
     case: (
      subst fam RowSum[fixedBound X bound Y]
       into chn RowSum[X, Y] then
      rename c to cs in chn RowSum[X, Y] then
      subst branch when (i = 0) of fam Row[bound (N + 2) bound (N + 2)]
         into chn RowSum[X, Y] then
      rename c to bj in chn RowSum[X, Y] then
      subst fam ColSum[fixedBound X bound (N + 2)] 
       into chn RowSum[X, Y] then
      rename c to bs in chn RowSum[X, Y] then
      sym from change 
        chn RowSum[X, Y]
        with c : bool <- read ColSum[0, Y] ; return c
        in currentProtocol
       (
        subst fam ColSum[fixedBound X bound (N + 2)]
         into chn RowSum[X, Y] then 
        subst branch when (not (j = 0)) of fam Col[bound (N + 2) bound (N + 2)]
         into chn RowSum[X, Y] 
       )  
     )  
    ) then
      merge cases for chn RowSum[X, Y]
      ) then
   compose fam RowSum[fixedBound X bound (N + 2)]
    with fam ColSum[fixedBound X bound (N + 2)] in group then
sym from change 
  fam RowSum[fixedBound X bound (N + 2)] and ColSum[fixedBound X bound (N + 2)]
 with 
  (family ColSum[fixedBound X bound (N + 2)] 
  indices: i, j
  bounds: fixedBound X bound (N + 2) 
::=
 r : bool <- read RowSum[X, j] ; return r
)
||
(family RowSum[fixedBound X bound (N + 2)] 
  indices: i, j
  bounds: fixedBound X bound (N + 2) 
::=
(when (0 = j) -->
  r : bool <- read Row[X, 0] ; return r
)
;;
(when (not (0 = j)) -->
 bj : bool <- read Row[X, j] ;
 r : bool <- read RowSum[X, j - 1] ;
 return xor((r, bj))
)
)
       in currentProtocol
(
call setupIndColRowPartTwo
) then
decompose fam RowSum[fixedBound X bound (N + 2)]
    with fam ColSum[fixedBound X bound (N + 2)]
)

case: (
`` this branch works too, keep
rewrite family RowSum[fixedBound X bound (N + 2)]
 to c : bool <- read ColSum[X, j] ; return c
 by induction on j bound Y
 (   
   case distinction on
    channel RowSum[X, Y]
   (
    case: 
    (  subst branch when (not (i = 0)) of fam Row[bound (N + 2) bound (N + 2)]
         into chn RowSum[X, Y] then  
       sym from 
        change
         chn RowSum[X, Y]
         with 
          c : bool <- read ColSum[X, Y] ; return c
         in
         currentProtocol
       ( subst fam ColSum[fixedBound X bound (N + 2)]
          into chn RowSum[X, Y] then
         subst fam ColSum[bound X bound (N + 2)]
          into chn RowSum[X, Y] then   
         use assumptions for Y in chn RowSum[X, Y] then
         subst branch when (j = 0) of fam Col[bound (N + 2) bound (N + 2)]
            into chn RowSum[X, Y] then  
         rename c to bi in chn RowSum[X, Y] then
         subst branch when (j = 0) of fam RowSum[bound X bound N + 2]
            into chn RowSum[X, Y]
      )
    )
    
    case:
    (
      subst fam RowSum[fixedBound X bound Y]
       into chn RowSum[X, Y] then
      subst fam ColSum[fixedBound X bound (N + 2)]
       into chn RowSum[X, Y] then 
      rename bi to bc in chn RowSum[X, Y] then 
      subst branch when (not (i = 0)) of fam Row[bound (N + 2) bound (N + 2)]
        into chn RowSum[X, Y] then 
      use expression assumption rearrange-xor
          on chn RowSum[X, Y] at 1 then 
      rename r to br
       in chn RowSum[X, Y] then    
      subst fam ColSum[bound X bound (N + 2)]     
       into chn RowSum[X, Y] then 
       sym from 
        change
         chn RowSum[X, Y]
         with 
          c : bool <- read ColSum[X, Y] ; return c
         in
         currentProtocol
       (  
         subst fam ColSum[fixedBound X bound (N + 2)]
          into chn RowSum[X, Y] then
         subst fam ColSum[bound X bound (N + 2)]
          into chn RowSum[X, Y] then   
         subst branch when (not (j = 0)) of fam Col[bound (N + 2) bound (N + 2)]
            into chn RowSum[X, Y] then  
         rename bj to bi 
          in chn RowSum[X, Y] then
         subst  branch when (not (j = 0)) of fam RowSum[bound X bound (N + 2)]
            into chn RowSum[X, Y] then    
         rename bj to br, bs to bc  
          in chn RowSum[X, Y] 
       )            
    )   
   ) then
   merge cases for chn RowSum[X, Y]
 ) then 
 compose fam RowSum[fixedBound X bound (N + 2)]
    with fam ColSum[fixedBound X bound (N + 2)] in group then
 sym from
  change  
   fam RowSum[fixedBound X bound (N + 2)]
    and ColSum[fixedBound X bound (N + 2)]
  with ((family ColSum[fixedBound X bound (N + 2)] 
  indices: i, j
  bounds: fixedBound X bound (N + 2)
::=
 r : bool <- read RowSum[X, j] ; return r
)
||
(family RowSum[fixedBound X bound (N + 2)]
  indices: i, j
  bounds: fixedBound X bound (N + 2)
::=
(when (0 = j) -->
 r : bool <- read Row[X, 0] ; return r
) 
;;
(when (not (0 = j)) -->
  bj : bool <- read Row[X, j] ; 
   r : bool <- read RowSum[X, j - 1] ;
   return xor((r, bj))
)
)
)
       in currentProtocol 
(       
rewrite group  
        RowSum[fixedBound X bound (N + 2)]
    and ColSum[fixedBound X bound (N + 2)]
   to  (
   (family ColSum[fixedBound X bound (N + 2)] 
  indices: i, j
  bounds: fixedBound X bound (N + 2) ::=
   bi : bool <- read Col[X, j] ; 
   bs : bool <- read ColSum[X - 1, j] ;
   return xor((bs, bi))
)
||
(
family RowSum[fixedBound X bound (N + 2)]
  indices: i, j
  bounds: fixedBound X bound (N + 2)
::=
 c : bool <- read ColSum[X, j] ; return c
)
   )
   by induction on j bound Y (
       call symColSumSameCasesPartTwo then
       merge case for chn RowSum[X, Y] and chn ColSum[X, Y]
         into group CGroup then
       case distinction on
        group CGroup[bound 1]
       (
         case: (
          subst branch when (not (i = 0)) of fam Row[bound (N + 2) bound (N + 2)]
             into chn RowSum[X, Y] then
          sym from
       change chn RowSum[X, Y]
       with 
        bi : bool <- read Col[X, 0] ;
        bs : bool <- read ColSum[X - 1, 0] ;
        return xor((bs, bi))
       in currentProtocol
       ( subst fam ColSum[bound X bound (N + 2)]
          into chn RowSum[X, Y] then
         subst branch when (j = 0)  of fam RowSum[bound X bound (N + 2)]
          into chn RowSum[X, Y] then
         subst branch when (j = 0) of fam Col[bound (N + 2) bound (N + 2)]
          into chn RowSum[X, Y] then
         rename c to bi in chn RowSum[X, Y]
        )            then
          subst chn RowSum[X, Y] 
           into chn ColSum[X, Y] then
          call symForRowSumPart2Zero then
          call symForColSumPart2Zero
         )
         case: (
         rename r to new in chn RowSum[X, Y] then
         subst branch when (not (i = 0)) of fam Row[bound (N + 2) bound (N + 2)]
             into chn RowSum[X, Y] then
         subst fam RowSum[fixedBound X bound Y]  
          into chn RowSum[X, Y] then 
         rename bi to b, r to br
          in chn RowSum[X, Y] then 
         subst fam ColSum[fixedBound X bound Y] 
          into chn RowSum[X, Y] then 
         rename bi to bc in chn RowSum[X, Y] then 
         subst fam ColSum[bound X bound (N + 2)] 
          into chn RowSum[X, Y] then 
         rename r to bs in chn RowSum[X, Y] then 
         use expression assumption rearrange-xor
          on chn RowSum[X, Y] at 1 then        
         call symRSPartTwoNZ then
         subst chn RowSum[X, Y] into chn ColSum[X, Y] then
         call symForRowSumPart2Zero              
         )
       ) then
       merge cases for fam CGroup[bound 1] then
       ungroup fam CGroup[bound 1] 
   )    
) then
decompose fam RowSum[fixedBound X bound (N + 2)]
    with fam ColSum[fixedBound X bound (N + 2)]
)
) then
merge cases for fam ColSum[fixedBound X bound (N + 2)]
`` ends big induction below
) 
.

strict subproof addSqr =
 sym from
  (extend currentProtocol 
        with internal family Sqr
                     indices:  i 
                     bounds: bound (N + 2)
                     typed: bool 
                     assigned: 
                       c : bool  <- read ColSum[i, i] ;
                      return c
  )
  (
   absorb fam Sqr[bound (N + 2)]
  )
 .  

 strict subproof revertColSumInductive =
 sym from
        change fam ColSum[bound (N + 2) bound (N + 2)]
       with 
       (when (0 = i) -->
         c : bool <- read Col[0, j] ; return c
       )
       ;;
       (when (not (0 = i)) -->
         bi : bool <- read Col[i, j] ;
         bs : bool <- read ColSum[i - 1, j] ;
         return xor((bs, bi))
       )        
       in currentProtocol
       (
       compose
 fam RowSum[bound (N + 2) bound (N + 2)]
with  
 fam ColSum[bound (N + 2) bound (N + 2)]
in group then  
call setupIndColRow then
decompose
 fam RowSum[bound (N + 2) bound (N + 2)]
with  
 fam ColSum[bound (N + 2) bound (N + 2)]
       )
.  
strict subproof addWire =
  sym from
   extend currentProtocol with
    internal family Wire indices: k bounds: bound K 
    typed: bool 
    assigned: s : bool <- read ShareSum[N + 1, k] ;
              return s
 (absorb fam Wire[bound K])              
.
 
strict subproof addWiresGroup =
group  
  fam Wire[bound K]
in Wires
indices: k
bounds: bound K
. 
strict subproof symInputWS =
  sym from change 
       chn Wire[B]
       with  s : bool <- read ShareSum[N + 1, B] ; return s
       in currentProtocol
       ( subst chn ShareSum[N + 1, B]
          into chn Wire[B] )
.        
`` all subproofs end with this line

start with real over deltaReal

approx generalize for fam 1OutOf4OTReal[bound N + 2 bound N + 2 bound K] (
  approx case distinction on chn 1OutOf4OTReal[m, n, k] (
    case: (
      approx embed 1OutOf4OTReal-Honest-Honest along phi
      with inputs  ( chn OTMsg-0[s, r, w] ,
  chn OTMsg-1[s, r, w] ,
  chn OTMsg-2[s, r, w] ,
  chn OTMsg-3[s, r, w] ,
  chn OTChc-0[s, r, w] ,
  chn OTChc-1[s, r, w] ) (
       use approx axiom HH2HH
      )
    )
     case: (
      approx embed 1OutOf4OTReal-SemiHonest-Honest along phi
      with inputs  ( chn OTMsg-0[s, r, w] ,
  chn OTMsg-1[s, r, w] ,
  chn OTMsg-2[s, r, w] , 
  chn OTMsg-3[s, r, w] ,
  chn OTChc-0[s, r, w] , 
  chn OTChc-1[s, r, w] ) (
       use approx axiom SHH2SHH
      )
    )
     case: (
      approx embed 1OutOf4OTReal-Honest-SemiHonest along phi
      with inputs  ( chn OTMsg-0[s, r, w] ,
  chn OTMsg-1[s, r, w] ,
  chn OTMsg-2[s, r, w] ,
  chn OTMsg-3[s, r, w] ,
  chn OTChc-0[s, r, w] ,
  chn OTChc-1[s, r, w] ) (
       use approx axiom HSH2HSH
      )
    ) case: (
      approx embed 1OutOf4OTReal-SemiHonest-SemiHonest along phi
      with inputs  ( chn OTMsg-0[s, r, w], 
  chn OTMsg-1[s, r, w], 
  chn OTMsg-2[s, r, w], 
  chn OTMsg-3[s, r, w], 
  chn OTChc-0[s, r, w], 
  chn OTChc-1[s, r, w] ) (
       use approx axiom SHSH2SHSH
      )
    )
  )
) then-approx
combine fam 1OutOf4OTReal[bound N + 2 bound N + 2 bound K] into families then
move family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] 
on each branch of group Circuit[bound N + 2 bound K] then
move family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] 
on each branch of group Circuit[bound N + 2 bound K] then
move family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] 
on each branch of group Circuit[bound N + 2 bound K] then
move family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] 
on each branch of group Circuit[bound N + 2 bound K] then
move family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K ]
on each branch of group Circuit[bound N + 2 bound K] then
move family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K ]
on each branch of group Circuit[bound N + 2 bound K] then
move family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K ]
on each branch of group Circuit[bound N + 2 bound K] then
move family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K ]
on each branch of group Circuit[bound N + 2 bound K] then
move family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
on each branch of group Circuit[bound N + 2 bound K] then
move family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
on each branch of group Circuit[bound N + 2 bound K] then
move family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K ] 
on each branch of group Circuit[bound N + 2 bound K] then
move family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K ] 
on each branch of group Circuit[bound N + 2 bound K] then
move family OTOut[bound N + 2 bound N + 2 bound K] 
on each branch of group Circuit[bound N + 2 bound K] then
move family OTOutOtAdv[bound N + 2 bound N + 2 bound K ]
on each branch of group Circuit[bound N + 2 bound K] then
`` up to here is gmwn.ipdl: restructure restr and check-proof restr holds
on branch isSemiHonest(n) of family SendInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I](
    subst fam SendInShare[bound N + 2 bound N + 2 dependentBound I]
    into fam SendInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I]
) then
rename variables m to x, n to y, i to z of fam SendInShare[bound N + 2 bound N + 2 dependentBound I] then
on branch isSemiHonest(n) of family RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I](
    subst fam SendInShare[bound N + 2 bound N + 2 dependentBound I]
    into fam RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I]
) then
subst fam SendInShare[bound N + 2 bound N + 2 dependentBound I]
into  fam InShare[bound N + 2 bound N + 2 dependentBound I] then
absorb fam SendInShare[bound N + 2 bound N + 2 dependentBound I] then
on branch isInputGate(k) of group Circuit[bound N + 2 bound K] (
    call eliminateOTDivergent
) then
`` not
on branch isNotGate(k) of group Circuit[bound N + 2 bound K] (
   call eliminateOTDivergent
) then
`` xor
on branch isXorGate(k) of group Circuit[bound N + 2 bound K] (
   call eliminateOTDivergent
) then
``and 
on branch isAndGate(k) of group Circuit[bound N + 2 bound K] (
    subst fam OTMsg-0[bound N + 2 bound N + 2 bound K]
    into fam OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] then   
   subst fam OTMsg-1[bound N + 2 bound N + 2 bound K]
    into fam OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTMsg-2[bound N + 2 bound N + 2 bound K]
    into fam OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTMsg-3[bound N + 2 bound N + 2 bound K]
    into fam OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTMsg-0[bound N + 2 bound N + 2 bound K]
       into fam OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTMsg-1[bound N + 2 bound N + 2 bound K]
       into fam OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTMsg-2[bound N + 2 bound N + 2 bound K]
       into fam OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTMsg-3[bound N + 2 bound N + 2 bound K]
       into fam OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam RcvdBit[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(m) of family OTOutOtAdv[bound N + 2 bound N + 2 bound K](
        reverse subst fam RcvdBit[bound N + 2 bound N + 2 bound K]
                in fam OTOutOtAdv[bound N + 2 bound N + 2 bound K]
                using fam OTOut[bound N + 2 bound N + 2 bound K] 
    ) then
    rename variables m to x, n to y, k to z of fam RcvdBit[bound N + 2 bound N + 2 bound K] then
    subst fam OTOut[bound N + 2 bound N + 2 bound K] into  fam RcvdBit[bound N + 2 bound N + 2 bound K] then
    rename variables x to n, y to m, z to k of fam RcvdBit[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam OTMsg-0[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam OTMsg-1[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam OTMsg-2[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam OTMsg-3[bound N + 2 bound N + 2 bound K] then
    subst or diverge fam OTMsg-0[bound N + 2 bound N + 2 bound K]
    into fam RcvdBit[bound N + 2 bound N + 2 bound K] var z then
    on branch m < n of family RcvdBit[bound N + 2 bound N + 2 bound K](
        subst fam OTMsg-1[bound N + 2 bound N + 2 bound K] 
        into fam RcvdBit[bound N + 2 bound N + 2 bound K] then
        subst fam OTMsg-2[bound N + 2 bound N + 2 bound K] 
        into fam RcvdBit[bound N + 2 bound N + 2 bound K] then
        subst fam OTMsg-3[bound N + 2 bound N + 2 bound K] 
        into fam RcvdBit[bound N + 2 bound N + 2 bound K] then 
        rename x to xm, y to ym in fam RcvdBit[bound N + 2 bound N + 2 bound K] then
        subst fam OTChc-0[bound N + 2 bound N + 2 bound K] 
        into fam RcvdBit[bound N + 2 bound N + 2 bound K] then
        rename x to xn in fam RcvdBit[bound N + 2 bound N + 2 bound K] then
        subst fam OTChc-1[bound N + 2 bound N + 2 bound K] 
        into fam RcvdBit[bound N + 2 bound N + 2 bound K] then
        rename x to yn in fam RcvdBit[bound N + 2 bound N + 2 bound K] 
    ) then
    rename variables m to n, n to m, k to k of fam OTMsg-0[bound N + 2 bound N + 2 bound K] then
    rename variables m to n, n to m, k to k of fam OTMsg-1[bound N + 2 bound N + 2 bound K] then
    rename variables m to n, n to m, k to k of fam OTMsg-2[bound N + 2 bound N + 2 bound K] then
    rename variables m to n, n to m, k to k of fam OTMsg-3[bound N + 2 bound N + 2 bound K] then
    rename variables m to n, n to m, k to k of fam OTChc-0[bound N + 2 bound N + 2 bound K] then
    rename variables m to n, n to m, k to k of fam OTChc-1[bound N + 2 bound N + 2 bound K] then
    subst fam OTChc-0[bound N + 2 bound N + 2 bound K] 
       into fam OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTChc-1[bound N + 2 bound N + 2 bound K] 
       into fam OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] then   
    subst fam OTChc-0[bound N + 2 bound N + 2 bound K] 
       into fam OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTChc-1[bound N + 2 bound N + 2 bound K] 
       into fam OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam OTChc-0[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam OTChc-1[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam SendBit[bound N + 2 bound N + 2 bound K] then
 sym from change fam RcvdBit[bound N + 2 bound N + 2 bound K]
          with 
  (when (m < n) -->        
  nf(               (b : bool <- read SendBit[m, n, k])
                  (xm : bool <- read Share[m, wire0(k)])
                  (xn : bool <- read Share[n, wire0(k)])
                  (ym : bool <- read Share[m, wire1(k)]) 
                   yn : bool <- read Share[n, wire1(k)], 
                  
                  return xor (
                    ( xor (( **((xm, yn))  , **((xn, ym))  )), 
                    b)
                  )

    ) 
   ) ;;
 (when (n <= m) -->
      nf(z : bool <- read RcvdBit[n, m, k], return z)
 ) 
  in currentProtocol(    
  on branch (m < n) of family RcvdBit[bound N + 2 bound N + 2 bound K] (     
 on reaction of fam RcvdBit[bound N + 2 bound N + 2 bound K] (
  if-ext on yn then if-ext on xn
 )
 )
 ) then
 sym from change fam RcvdBit[bound N + 2 bound N + 2 bound K]
          with 
  (when (m < n) -->        
  nf(               (b : bool <- read SendBit[m, n, k])
                  (xm : bool <- read Share[m, wire0(k)])
                  (xn : bool <- read Share[n, wire0(k)])
                  (ym : bool <- read Share[m, wire1(k)]) 
                   yn : bool <- read Share[n, wire1(k)], 
                  
                  return xor (
                    ( xor (( **((xm, yn))  , **((xn, ym))  )), 
                    b)
                  )

    ) 
   ) ;;
 (when (n <= m) -->
   nf(               (b : bool <- read SendBit[m, n, k])
                  (xm : bool <- read Share[m, wire0(k)])
                  (xn : bool <- read Share[n, wire0(k)])
                  (ym : bool <- read Share[m, wire1(k)]) 
                   yn : bool <- read Share[n, wire1(k)], 
                  
                  return xor (
                    ( xor (( **((xm, yn))  , **((xn, ym))  )), 
                    b)
                  )

    ) 
 ) 
  in currentProtocol(    
  on branch (n <= m) of family RcvdBit[bound N + 2 bound N + 2 bound K] (     
 diverge on fam RcvdBit[bound N + 2 bound N + 2 bound K] 
     with branch n <= m 
     of fam SendBit[bound N + 2 bound N + 2 bound K] 
     var z 
 )
 ) then 
 merge cases for fam RcvdBit[bound N + 2 bound N + 2 bound K] then
 rename variables m to n, n to m, k to k of fam SendBit[bound N + 2 bound N + 2 bound K]
    
) then
combine fam Circuit[bound N + 2 bound K] then
`` up to here is 1gmwn, minus the sym from pInt0, add it back to check, but the check worked
absorb fam OTOut[ bound N + 2 bound N + 2 bound K] then 
absorb fam OTMsg-0[bound N + 2 bound N + 2 bound K] then
absorb fam OTMsg-1[bound N + 2 bound N + 2 bound K] then
absorb fam OTMsg-2[bound N + 2 bound N + 2 bound K] then
absorb fam OTMsg-3[bound N + 2 bound N + 2 bound K] then
absorb fam OTChc-0[bound N + 2 bound N + 2 bound K] then
absorb fam OTChc-1[bound N + 2 bound N + 2 bound K] then
sym from pInt1(
  combine fam Adv[bound K] then
  combine fam Shares[bound K] 
) 
`` up to here is 2gmwn.ipdl: checked with restructure pInt1 and check-proof pInt1
subst  fam SendOutShare[bound N + 2 bound N + 2 bound K] 
into fam SendOutSharePartyAdv[bound N + 2 bound N + 2 bound K] then
rename variables m to n, n to m, k to k  
 of  fam SendOutShare[bound N + 2 bound N + 2 bound K]  then
subst  fam SendOutShare[bound N + 2 bound N + 2 bound K] 
into fam RcvdOutSharePartyAdv[bound N + 2 bound N + 2 bound K] then
subst or diverge fam SendOutShare[bound N + 2 bound N + 2 bound K] 
into fam OutShare[bound N + 2 bound N + 2 bound K] var z then
absorb  fam SendOutShare[bound N + 2 bound N + 2 bound K] then 
add internal family ShareSum 
indices: m, k 
bounds: bound N + 2 bound K
typed: bool
assigned: 
(when (m = 0) --> 
 s : bool <- read Share[0, k] ; return s
) ;;
(when (not (m = 0))  --> 
 xs : bool <- read ShareSum[m - 1, k] ;
 xm : bool <- read Share[m, k] ;
 return xor( (xs, xm) )
) then
on all branches of fam Adv[bound K] 
split fam OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] on second index then
on all branches of fam Adv[bound K] 
split fam OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] on second index then
on all branches of fam Shares[bound K]
split fam Share[bound N + 2 bound K] on first index then 
on branch (isNotGate(k)) of group Shares[bound K] (
    remove only branch of fam Share[bound N + 1 bound K]
) then
save current configuration then
call sym3 then
call sym4 then 
call sym5 then
call sym8 then
call addInitOK then
call addSharesOK then
call addInOK then 
call addWiresOK then
call splitShareOK then
compose fam Shares[bound K] with fam SharesOK[bound K] in group 
call changeComp then
ungroup fam InitOK[bound N + 2 bound N + 2 dependentBound I] then
rename indices to m, n, i in fam InShare[bound (N + 2) bound (N + 2) dependentBound I] then
subst fam InShare[bound (N + 2) bound (N + 2) dependentBound I]
 into fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I] then
rename in to is in fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I] then
rename indices to m, n, i in fam InShare[bound (N + 2) bound (N + 2) dependentBound I] then
call asym0 then
turn otherwise into neg for fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] then
split fam InShare$-OK[bound (N + 2) bound (N + 2) dependentBound I] on first index then
drop read branch when not m = N + 1 of 
  fam InShare$[bound N + 2 bound N + 2 dependentBound I ] 
  from fam InShare$-OK[bound N + 1 bound N + 2 dependentBound I ] then
subst fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
 into fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I] then
rename s to is, x to in
 in fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I] then
call asym1 then
compose fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
   with fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I] in group then
`` start asym2   
sym from 
  change 
   fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
  with
        (when (0 = m) -->
           in : unit <- read InShare$-OK[m, n, i] ; return () 
        )
        ;;
        (otherwise -->
           s : unit <- read InShare$Sum-OK[m - 1, n, i] ; 
           x : unit <- read InShare$-OK[m, n, i] ;
              return () 
        )
        in currentProtocol
(
in the presence of 
   fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I],
   fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]
rewrite 
 group InShare$-OK[bound N + 1 bound N + 2 dependentBound I] and InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I]
 to (
    (family InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I]
     indices: m ,n ,i 
     bounds: bound N + 1 bound N + 2 dependentBound I ::= 
     is : bool <- read InShare$-Sum[m ,n ,i] ; return ()
    ) 
    || 
    (family InShare$-OK[bound N + 1 bound N + 2 dependentBound I]
      indices: m ,n ,i 
      bounds: bound N + 1 bound N + 2 dependentBound I ::= 
      x : bool <- read In [n ,i] ; return ()
    )
   )
   by induction on m bound M
(
turn otherwise into neg 
     for fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
case distinction on  family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
  case: (
    subst fam InShare$-OK[fixedBound M bound N + 2 dependentBound I]
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]     
  )

  case: (
    subst fam InShare$Sum-OK[bound M bound (N + 2) dependentBound I] 
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
subst fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
rename is to s in fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  )
) then 
sym from 
             change 
              fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
             with 
              is : bool <- read InShare$-Sum[M, n, i] ;  return ()
             in currentProtocol
(
sym from 
    change 
              fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
             with 
              ( when (M = 0) --> 
                 is : bool <- read InShare$-Sum[M, n, i] ;  return ()
              )
              ;;
              ( when (not (M = 0)) --> 
                 is : bool <- read InShare$-Sum[M, n, i] ;  return ()
              )
             in currentProtocol
    (merge cases for 
      fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]  
    ) then
   turn otherwise into neg 
      for fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I] then
    case distinction on family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
 
     case: (
     
 subst branch when m = 0 of 
    fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
    into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  then
      drop read branch when not (m = N + 1) of  
            fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
         from fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
     )

     case: (
      subst branch when not (m = 0) of 
    fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
    into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  then
      drop read branch when not (m = N + 1) of  
            fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
         from fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
     )
    ) then 
     turn neg into otherwise 
      for fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
)
)
) then
decompose fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
   with fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I] then
``end asym2   
call asym01 then
unsplit fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I]
 and fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I] then
call addInitOK then
call indProofInitOK then
decompose fam Shares[bound K] with fam SharesOK[bound K] then
compose fam Wires-OK[bound K] with fam SharesOK[bound K] in group then
call indWiresShares then
decompose fam Wires-OK[bound K] with fam SharesOK[bound K] then
remove fam ShareOK[bound (N + 1) bound K]
           from group SharesOK[bound K] then
merge cases for fam ShareOK[bound (N + 1) bound K] then
remove fam ShareOK[fixedBound (N + 1) bound K]
           from group SharesOK[bound K] then
merge cases for fam ShareOK[fixedBound (N + 1) bound K] then
change name fam SharesOK[bound K] to Ctrbs-OK then
on branch isAndGate(k) of group Adv[bound K] (
  on branch n < N + 1 of
   family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K ]
  (subst fam ShareOK[fixedBound (N + 1) bound K]
    into fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K ]) then
  on branch n < N + 1 of
   family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K ]
  (subst fam ShareOK[fixedBound (N + 1) bound K]
    into fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K ])
) then
call addHidden then
call addHiddenGroup then
compose fam HiddenGroup[bound K] with fam Shares[bound K] in group then
combine fam Ctrbs-OK[bound K] then
call indTimingShares then
decompose fam HiddenGroup[bound K] with fam Shares[bound K] then
ungroup fam HiddenGroup[bound K] then
absorb fam Hidden[bound K] then
call restoreCtrbsOK  then
`` the sym proof
sym from
 branch 
          when (isInputGate (k))
         of
          fam Shares[bound K]
         change
          fam Share[fixedBound (N + 1) bound K]
         with
          xs : bool <- read ShareSum[N, k] ;
          in : bool <- read InShare[N + 1, wire0(k), wire1(k)] ;
          return in
          in 
          (
          branch 
          when (isNotGate(k))
         of
          fam Shares[bound K]
         change
          fam Share[fixedBound (N + 1) bound K]
         with
          xs : bool <- read ShareSum[N, k] ;
          x : bool <- read Share[N + 1, wire0(k)] ; 
          return neg(x)
          in 
          (
          branch 
          when (isXorGate(k))
         of
          fam Shares[bound K] 
         change
          fam Share[fixedBound (N + 1) bound K] 
         with
          xs : bool <- read ShareSum[N, k] ;
          x : bool <- read Share[N + 1, wire0(k)] ;
          y : bool <- read Share[N + 1, wire1(k)] ; 
          return xor((x, y)) 
          in 
          (branch 
          when (isAndGate(k))
         of
          fam Shares[bound K] 
         change
          fam Share[fixedBound (N + 1) bound K]
         with
          xs : bool <- read ShareSum[N, k] ;
          bs : bool <- read CtrbSum[N + 1, N + 1, k] ;
          return bs
          in 
          (branch 
          when (isAndGate(k))
         of
          fam Adv[bound K] 
         change
          fam OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K]
         with
          (when (n < N + 1) -->
            x : bool <- read ShareSum[N, wire1(k)] ;
            return ()
          )  
          ;;
         (when (n = N + 1) -->
           oc : unit <- read OTChcRcvd-1OtAdv[n, N + 1, k] ;
           return oc
         )
          in
          (
          branch 
          when (isAndGate(k))
         of
          fam Adv[bound K]
         change
          fam OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K]
         with
          (when (n < N + 1) -->
            x : bool <- read ShareSum[N, wire0(k)] ;
            return ()
          )  
          ;;
          (when (n = N + 1) -->
            oc : unit <- read OTChcRcvd-0OtAdv[n, N + 1, k] ;
            return oc
          ) 
          in savedProtocol
          ))
          )
          )
          ) 
          over savedDelta 
(
call sym3 then
call introShareSumOK then
sym from  
         branch 
          when isAndGate(k)
         of
          fam Adv[bound K]
         change
          fam  OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K]
         with
          (when (n < N + 1) -->
             x : unit <- read ShareSum-OK[N, wire1(k)] ; return ()
          )  
          ;;
          (when (n = N + 1) -->
             oc : unit <- read OTChcRcvd-1OtAdv[n, N + 1, k] ; return oc
          )
          in
          (
          branch 
           when isAndGate(k)
         of
          fam Adv[bound K]
         change
          fam  OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K]
         with
          (when (n < N + 1) -->
             x : unit <- read ShareSum-OK[N, wire0(k)] ; return ()
          )   
          ;;
          (when (n = N + 1) -->
             oc : unit <- read OTChcRcvd-0OtAdv[n, N + 1, k] ; return oc
          )
          in
          currentProtocol)
(
  on branch isAndGate(k)
          of group Adv[bound K] (
on branch n < N + 1 
           of family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K]
           ( subst fam ShareSum-OK[bound (N + 1) bound K] 
              into fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] then
             rename s to x 
              in fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K]      
           ) then
           on branch n < N + 1
           of family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K]
           ( subst fam ShareSum-OK[bound (N + 1) bound K] 
              into fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] then
             rename s to x 
              in fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K]      
           )
          )
) then
sym from
         change 
          fam Shares[bound K]
    with
    (when isInputGate(k) -->(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <- read InShare[n, wire0(k), wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 in : bool <- read InShare[N + 1, wire0(k), wire1(k)] ; 
 xs : unit <- read ShareSum-OK[N, k] ; 
 return in
)
)
)
;;
(when isNotGate(k) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <- read Share[n, wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <- read Share[N + 1, wire0(k)] ;
 xs : unit <- read ShareSum-OK[N, k] ;
 return neg(x)
)
)
)
;;
(when (isXorGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <- read Share[n, wire0(k)] ;
 y : bool <- read Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <- read Share[N + 1, wire0(k)] ;
 xs : unit <- read ShareSum-OK[N, k] ; 
 y : bool <- read Share[N + 1, wire1(k)] ; 
 return xor((x, y))
)
)
)
;;
(when isAndGate(k) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <- read SendBit[n, m, k] ; return s
) 
;;
(when (m = n) -->
 x : bool <- read Share[n, wire0(k)] ;
 y : bool <- read Share[n, wire1(k)] ;
 return **((x, y))
)
;;
(when (m < n) -->
 r : bool <- read RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (0 = m) -->
 b : bool <- read Ctrb[n, 0, k] ; return b
)
;;
(when not (0 = m) -->
 b : bool <- read Ctrb[n, m, k] ;
 s : bool <- read CtrbSum[n, m - 1, k] ; 
 return xor((s, b))
)
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read SendBit[m, n, k] ;
 xm : bool <- read Share[m, wire0(k)] ;
 xn : bool <- read Share[n, wire0(k)] ;
 ym : bool <- read Share[m, wire1(k)] ;
 yn : bool <- read Share[n, wire1(k)] ; 
 return xor( ( xor( ( **((xm, yn)) , **((xn, ym)) ) )  , b ) )
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <- read Share[n, wire0(k)] ;
 y : bool <- read Share[n, wire1(k)] ;
 samp flip (()) 
) 
;;
when (m <= n) -->
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[N + 1, N + 1, k] ; 
 xs : unit <- read ShareSum-OK[N, k] ; 
 return bs 
)
)
)
    in currentProtocol (
 on branch isInputGate(k)
  of group Shares[bound K]
  (subst fam ShareSum-OK[bound (N + 1) bound K]
    into fam Share[fixedBound (N + 1) bound K] then
   rename s to xs in fam Share[fixedBound (N + 1) bound K] 
  ) then
  on branch isNotGate(k)
  of group Shares[bound K]
  (subst fam ShareSum-OK[bound (N + 1) bound K]
    into fam Share[fixedBound (N + 1) bound K] then
   rename s to xs in fam Share[fixedBound (N + 1) bound K] 
  ) then
  on branch isXorGate(k)
  of group Shares[bound K]
  (subst fam ShareSum-OK[bound (N + 1) bound K]
    into fam Share[fixedBound (N + 1) bound K] then
   rename s to xs in fam Share[fixedBound (N + 1) bound K] 
  ) then
  on branch isAndGate(k)
  of group Shares[bound K]
  (subst fam ShareSum-OK[bound (N + 1) bound K]
    into fam Share[fixedBound (N + 1) bound K] then
   rename s to xs in fam Share[fixedBound (N + 1) bound K] 
  )
    ) then
call addInOK then 
call addWiresOK then
call sym5 then 
call addInitOK then
call addSharesOK then
sym from 
        change
          fam ShareSum-OK[bound (N + 1) bound K]
         with
          (when (m = 0) -->
             s : unit <- read ShareOK[0, k] ;  return ()
          )
          ;;
          (when (not (m = 0)) -->
             ss : unit <- read ShareSum-OK[m - 1, k] ;
              s : unit <- read ShareOK[m, k] ;
             return ()
          )
          in
          currentProtocol ( 
    in the presence of 
      fam ShareSum[bound N + 2 bound K] ,
      fam SharesOK[bound K]  
     rewrite family ShareSum-OK[bound (N + 1) bound K]
     to s : bool <- read ShareSum[m, k] ;  return ()
     by induction on m bound M 
     (
       case distinction on
       family ShareSum-OK[fixedBound M bound K]
       (
        case: (
        using group SharesOK[bound K]
        (subst fam ShareOK[bound (N + 2) bound K]
          into fam ShareSum-OK[fixedBound M bound K] then
         call symShareSumOK0
        )
        ) 
        
        case:  ( using group SharesOK[bound K]
        (subst fam ShareOK[bound (N + 2) bound K]
          into fam ShareSum-OK[fixedBound M bound K] then
         subst fam ShareSum-OK[bound M bound K]
          into fam ShareSum-OK[fixedBound M bound K] then
         call symShareSumOKM 
        )
        ) 
       ) then
       merge cases for fam  ShareSum-OK[fixedBound M bound K]
     )
          )  then
  split fam ShareOK[bound (N + 2) bound K] 
     inside group SharesOK[bound K] then
  compose fam Shares[bound K] with fam SharesOK[bound K] in group then
sym from
     change fam SharesOK[bound K]
        with 
           (when (isInputGate(k)) --> (
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(
family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 i : unit <- read InShareOK[n, wire0(k), wire1(k)] ; return i
)
||
(
family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 i : unit <- read InShareOK[N + 1, wire0(k), wire1(k)] ;
 ss : unit <- read ShareSum-OK[N, k] ;
 return i
)
)
)
;;
(when (isNotGate(k)) --> (
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(
family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : unit <- read ShareOK[n, wire0(k)] ; return x
)
||
(
family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : unit <- read ShareOK[N + 1, wire0(k)] ;
 ss : unit <- read ShareSum-OK[N, k] ;  
 return x
)
) 
)
;;
(when (isXorGate(k)) --> (
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(
family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : unit <- read ShareOK[n, wire0(k)] ;
 y : unit <- read ShareOK[n, wire1(k)] ; 
 return ()
)
||
(
family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 ss : unit <- read ShareSum-OK[N, k] ;
 x : unit <- read ShareOK[N + 1, wire0(k)] ;
 y : unit <- read ShareOK[N + 1, wire1(k)] ; 
 return ()
)
)
) 
;;
(when (isAndGate(k)) --> (
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : unit <- read SendBit-OK[n, m, k] ; return s
) 
;;
(when (m < n) -->
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
;;
(when (m = n) -->
 x : unit <- read ShareOK[n, wire0(k)] ; 
 y : unit <- read ShareOK[n, wire1(k)] ; 
 return () 
)
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (0 = m) -->
 c : unit <- read Ctrb-OK[n, 0, k] ; return c
)
;;
(when (not (0 = m)) -->
  x : unit <- read CtrbSum-OK[n, m - 1, k] ;
  y : unit <- read Ctrb-OK[n, m, k] ; 
  return () 
)
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : unit <- read SendBit-OK[m, n, k] ;
 xm : unit <- read ShareOK[m, wire0(k)] ;
 xn : unit <- read ShareOK[n, wire0(k)] ; 
 ym : unit <- read ShareOK[m, wire1(k)] ; 
 yn : unit <- read ShareOK[n, wire1(k)] ; 
 return ()
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : unit <- read ShareOK[n, wire0(k)] ;
 y : unit <- read ShareOK[n, wire1(k)] ; 
    return ()
)
;;
(when (m <= n) -->
 sb : unit <- read SendBit-OK[n, m, k] ; return sb
)
)
||
(family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 c : unit <- read CtrbSum-OK[n, N + 1, k] ; return c
)
||
(family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 c : unit <- read CtrbSum-OK[N + 1, N + 1, k] ;
 ss : unit <- read ShareSum-OK[N, k] ;
 return c  
)
)
)
          in currentProtocol (
in the presence of 
  fam InitOK[bound (N + 2) bound (N + 2) dependentBound I]
rewrite group Shares[bound K] and SharesOK[bound K]
   to (
   (family  Shares[bound K] 
 indices: k
 bounds: bound K
::=
(when (isInputGate(k)) --> (
(family  Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family  CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family  RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family  SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family  Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <- read InShare[n, wire0(k), wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 in : bool <- read InShare[N + 1, wire0(k), wire1(k)] ; 
 xs : unit <- read ShareSum-OK[N, k] ; 
 return in
)
)
   )
;;
(when (isNotGate(k)) --> (
(family  Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family  CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family  RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family  SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family  Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <- read Share[n, wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
  x : bool <- read Share[N + 1, wire0(k)] ; 
  xs : unit <- read ShareSum-OK[N, k] ;
  return neg(x)
)
)
)
;;
(when (isXorGate(k)) --> (
(family  Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family  CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family  RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family  SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family  Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <- read Share[n, wire0(k)] ;
 y : bool <- read Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <- read Share[N + 1, wire0(k)] ;
 xs : unit <- read ShareSum-OK[N, k] ;
 y : bool <- read Share[N + 1, wire1(k)] ; 
 return xor((x, y))
)
)
)
;;
(when (isAndGate(k)) --> (
(family  Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <- read SendBit[n, m, k] ; return s
)
;;
(when (m = n) -->
 x : bool <- read Share[n, wire0(k)] ;
 y : bool <- read Share[n, wire1(k)] ;
 return **((x, y))
)
;;
(when (m < n) -->
 r : bool <- read RcvdBit[n, m, k] ; return r
)
)
||
(family  CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (0 = m) -->
 b : bool <- read Ctrb[n, 0, k] ; return b
)
;;
(when not (0 = m) -->
  b : bool <- read Ctrb[n, m, k] ;
  s : bool <- read CtrbSum[n, m - 1, k] ; 
  return xor((s, b))
)
)
||
(family  RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read SendBit[m, n, k] ;
 xm : bool <- read Share[m, wire0(k)] ;
 xn : bool <- read Share[n, wire0(k)] ;
 ym : bool <- read Share[m, wire1(k)] ;
 yn : bool <- read Share[n, wire1(k)] ; 
 return xor( ( xor( (**((xm, yn)) , **((xn, ym)) ) )  , b ) ) 
)
||
(family  SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <- read Share[n, wire0(k)] ; 
 y : bool <- read Share[n, wire1(k)] ;
 samp flip (()) 
)
;;
(when (m <= n) -->
 sb : bool <- read SendBit[n, m, k] ; return sb
)
)
||
(family  Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[N + 1, N + 1, k] ;
 xs : unit <- read ShareSum-OK[N, k] ;
 return bs
)
)
)
   )
||
(family SharesOK[bound K] 
 indices: k
 bounds: bound K
::= (
(family  Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : bool <- read Ctrb[n, m, k] ;  return ()
)
||
(family  CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : bool <- read CtrbSum[n, m, k] ;  return ()
)
||
(family  RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : bool <- read RcvdBit[n, m, k] ;  return ()
)
||
(family  SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : bool <- read SendBit[n, m, k] ;  return ()
)
||
(family  ShareOK[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <- read Share[n, k] ; return ()
)
||
(family ShareOK[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <- read Share[N + 1, k] ; return ()
)
)
)
   )
   by induction on k bound B 
   (
   ungroup fam InitOK[bound N + 2 bound N + 2 dependentBound I] then
   case distinction on group SharesOK[fixedBound B](
    case: (
      using branch when (isInputGate(B))
    of group Shares[fixedBound B]
     ( sym var c terms n, m, B 
         diverge fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
         into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var c then
       sym var c terms n, m, B 
         diverge fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
         into fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var c then  
       sym var r terms n, m, B 
         diverge fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B]
         into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var r then
       sym var s terms n, m, B 
         diverge fam SendBit[bound (N + 2) bound (N + 2) fixedBound B]
         into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var s then  
       rename indices to x, y in fam ShareOK[bound (N + 1) fixedBound B] then
       subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]  
        into fam ShareOK[bound (N + 1) fixedBound B] then
       rename indices to n, k in fam ShareOK[bound (N + 1) fixedBound B] then 
       rename is to in in fam ShareOK[bound (N + 1) fixedBound B] then
       sym from 
         change 
        fam ShareOK[bound(N + 1) fixedBound B]
        with
         x : bool <- read Share[n, B] ; return ()
        in currentProtocol 
         ( subst
             fam Share[bound (N + 1) fixedBound B] into
             fam ShareOK[bound (N + 1) fixedBound B]
         )
     ) then
     subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
      into chn ShareOK[N + 1, B] then
      sym from
         change 
          chn ShareOK[N + 1, B]
         with
          x : bool <- read Share[N + 1, B] ; return ()
         in currentProtocol
       (
        using branch when (isInputGate(B))
        of group Shares[fixedBound B]
        (subst chn Share[N + 1, B]
          into chn ShareOK[N + 1, B] then
         rename in to is, xs to ss 
          in chn ShareOK[N + 1, B] 
        )
      )
    )
    case: (
        using branch when (isNotGate(B))
    of group Shares[fixedBound B]
     ( sym var c terms n, m, B 
         diverge fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
         into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var c then
       sym var c terms n, m, B 
         diverge fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
         into fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var c then  
       sym var r terms n, m, B 
         diverge fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B]
         into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var r then
       sym var s terms n, m, B 
         diverge fam SendBit[bound (N + 2) bound (N + 2) fixedBound B]
         into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var s then  
       unit-ext on fam ShareOK[bound (N + 1) fixedBound B] at 1 then
       using group SharesOK[bound B]
       (
        subst fam ShareOK[bound (N + 1) bound B]
         into fam ShareOK[bound (N + 1) fixedBound B]
       ) then
       sym from 
       change 
        fam ShareOK[bound (N + 1) fixedBound B]
        with
         x : bool <- read Share[n, B] ; return ()
        in currentProtocol 
         (
         subst fam Share[bound (N + 1) fixedBound B]
          into fam ShareOK[bound (N + 1) fixedBound B] then
         rename s to x in fam ShareOK[bound(N + 1) fixedBound B]   
         )        
       ) then
       using group SharesOK[bound B]
        (
         subst fam ShareOK[fixedBound (N + 1) bound B]
         into chn ShareOK[N + 1, B]
        ) then 
       sym from
         change 
          chn ShareOK[N + 1, B]
         with
          x : bool <- read Share[N + 1, B] ; return ()
         in currentProtocol
       (
        using branch when (isNotGate(B))
        of group Shares[fixedBound B]
        (subst chn Share[N + 1, B]
          into chn ShareOK[N + 1, B] then
         rename xs to ss 
          in chn ShareOK[N + 1, B] 
        )
      )
    )
    case: (
     using branch when (isXorGate(B))
    of group Shares[fixedBound B]
     ( sym var c terms n, m, B 
         diverge fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
         into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var c then
       sym var c terms n, m, B 
         diverge fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
         into fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var c then  
       sym var r terms n, m, B 
         diverge fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B]
         into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var r then
       sym var s terms n, m, B 
         diverge fam SendBit[bound (N + 2) bound (N + 2) fixedBound B]
         into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var s then  
     using group SharesOK[bound B]
       ( 
         subst fam ShareOK[bound (N + 1) bound B]
         into fam ShareOK[bound (N + 1) fixedBound B] then
         rename x to a in fam ShareOK[bound (N + 1) fixedBound B] then
         subst fam ShareOK[bound (N + 1) bound B]
         into fam ShareOK[bound (N + 1) fixedBound B] then
         rename x to y, a to x in fam ShareOK[bound (N + 1) fixedBound B] 
       ) then
       sym from 
         change 
        fam ShareOK[bound(N + 1) fixedBound B]
        with
         x : bool <- read Share[n, B] ; return ()
        in currentProtocol 
         ( subst
             fam Share[bound (N + 1) fixedBound B] into
             fam ShareOK[bound (N + 1) fixedBound B]
         )
     ) then
     using group SharesOK[bound B]
     ( subst
             fam ShareOK[fixedBound (N + 1) bound B] into
             chn ShareOK[N + 1, B] then
       rename x to x0 in chn ShareOK[N + 1, B] then  
       subst
             fam ShareOK[fixedBound (N + 1) bound B] into
             chn ShareOK[N + 1, B] then
       rename x to x1 in chn ShareOK[N + 1, B] then             
       sym from
         change 
          chn ShareOK[N + 1, B]
         with
          x : bool <- read Share[N + 1, B] ; return ()
         in currentProtocol
       (
        using branch when (isXorGate(B))
        of group Shares[fixedBound B]
        (subst chn Share[N + 1, B]
          into chn ShareOK[N + 1, B] then
         rename xs to ss, x to x0, y to x1
          in chn ShareOK[N + 1, B] 
        )
      )
     )
    )
    case: (
     case distinction on family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
     (
      case: (
        using group SharesOK[bound B]
        (
          subst fam ShareOK[bound (N + 1) bound B] 
           into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
          rename x to a in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
          subst fam ShareOK[bound (N + 1) bound B] 
           into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
          rename x to y, a to x in 
           fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
        )
      )
      
      case: (idle)
     ) then
     call inIndSym7 then
     using group SharesOK[bound B]
        (
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
         rename x to a in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then     
         rename x to yn, a to xn 
          in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then    
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
         rename x to a in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
         rename x to ym, a to xm 
          in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
         rename xm to a, xn to xm, yn to xn, ym to yn, a to ym 
          in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then        
         rename indices to x, y, z
           in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then     
         subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then         
         rename indices to n, m, k
           in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then     
         rename s to b in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         
        ) then
        sym from 
         change 
        fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
        with
         r : bool <- read RcvdBit[n, m, B] ;  return ()
        in currentProtocol
       (
         using branch when isAndGate(B)
         of group Shares[fixedBound B]
         (subst fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B] 
           into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]  )
       ) then
       case distinction on family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] (
     case: (
      subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
          into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] 
     )

     case: (
       subst fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
          into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] 
     )
     case: ( idle )
   ) then
 unsplit fam ShareOK[bound (N + 1) bound B] 
           and fam ShareOK[fixedBound (N + 1) bound B] inside group SharesOK[bound B] then 
 using group SharesOK[bound B]
       (
          case distinction on family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] (
             case: ( idle )
              case: ( idle )
               case: ( subst fam ShareOK[bound (N + 2) bound B] 
              into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
             rename x to a
              in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
              subst fam ShareOK[bound (N + 2) bound B] 
              into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
             rename x to y, a to x
              in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]  )

          )
       ) then
 split fam ShareOK[bound (N + 2) bound B] inside group SharesOK[bound B] then
 call inIndSym9 then
 call inIndSym10 then
  subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B] 
            into fam ShareOK[bound (N + 1) fixedBound B] then
  call inIndSym11 then
  subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
            into chn ShareOK[N + 1, B] then
  sym from
         change 
          chn ShareOK[N + 1, B]
         with
          x : bool <- read Share[N + 1, B] ; return ()
         in currentProtocol
       (
        using branch when (isAndGate(B))
        of group Shares[fixedBound B]
        (subst chn Share[N + 1, B]
          into chn ShareOK[N + 1, B] then
         rename xs to ss, bs to c
          in chn ShareOK[N + 1, B] 
        )
      )
    )
   ) then 
   merge cases for fam SharesOK[fixedBound B] then
   call addInitOK
   )
          ) then
    decompose fam Shares[bound K] with fam SharesOK[bound K] then
    ungroup fam InitOK[bound N + 2 bound N + 2 dependentBound I] then
    rename indices to m, n, i in fam InShare[bound (N + 2) bound (N + 2) dependentBound I] then
subst fam InShare[bound (N + 2) bound (N + 2) dependentBound I]
 into fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I] then
rename in to is in fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I] then
rename indices to m, n, i in fam InShare[bound (N + 2) bound (N + 2) dependentBound I] then
call asym0 then
split fam InShare$-OK[bound (N + 2) bound (N + 2) dependentBound I]       
 on first index then
turn otherwise into neg for fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] then
drop read branch when not m = N + 1 of 
  fam InShare$[bound N + 2 bound N + 2 dependentBound I ] 
  from fam InShare$-OK[bound N + 1 bound N + 2 dependentBound I ] then
subst fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
 into fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I] then
rename s to is, x to in
 in fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I] then
call asym1 then
compose fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
   with fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I] in group then
`` start asym2
sym from 
  change 
   fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
  with
        (when (0 = m) -->
           in : unit <- read InShare$-OK[m, n, i] ; return () 
        )
        ;;
        (otherwise -->
           s : unit <- read InShare$Sum-OK[m - 1, n, i] ; 
           x : unit <- read InShare$-OK[m, n, i] ;
              return () 
        )
        in currentProtocol
(
in the presence of 
   fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I],
   fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]
rewrite 
 group InShare$-OK[bound N + 1 bound N + 2 dependentBound I] and InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I]
 to (
    (family InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I]
     indices: m ,n ,i 
     bounds: bound N + 1 bound N + 2 dependentBound I ::= 
     is : bool <- read InShare$-Sum[m ,n ,i] ; return ()
    ) 
    || 
    (family InShare$-OK[bound N + 1 bound N + 2 dependentBound I]
      indices: m ,n ,i 
      bounds: bound N + 1 bound N + 2 dependentBound I ::= 
      x : bool <- read In [n ,i] ; return ()
    )
   )
   by induction on m bound M
(
turn otherwise into neg 
     for fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
case distinction on  family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
  case: (
    subst fam InShare$-OK[fixedBound M bound N + 2 dependentBound I]
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]     
  )

  case: (
    subst fam InShare$Sum-OK[bound M bound (N + 2) dependentBound I] 
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
subst fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
rename is to s in fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  )
) then 
sym from 
             change 
              fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
             with 
              is : bool <- read InShare$-Sum[M, n, i] ;  return ()
             in currentProtocol
(
sym from 
    change 
              fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
             with 
              ( when (M = 0) --> 
                 is : bool <- read InShare$-Sum[M, n, i] ;  return ()
              )
              ;;
              ( when (not (M = 0)) --> 
                 is : bool <- read InShare$-Sum[M, n, i] ;  return ()
              )
             in currentProtocol
    (merge cases for 
      fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]  
    ) then
   turn otherwise into neg 
      for fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I] then
    case distinction on family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
 
     case: (
     
 subst branch when m = 0 of 
    fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
    into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  then
      drop read branch when not (m = N + 1) of  
            fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
         from fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
     )

     case: (
      subst branch when not (m = 0) of 
    fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
    into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  then
      drop read branch when not (m = N + 1) of  
            fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
         from fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
     )
    ) then 
     turn neg into otherwise 
      for fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
)
)
) then
decompose fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
   with fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I] then
`` end asym2   
call asym01 then
unsplit fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I]
 and fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I] then
call addInitOK then
call indProofInitOK then
move family ShareSum-OK[bound (N + 1) bound K] on each
 branch of group SharesOK[bound K] then
compose fam Wires-OK[bound K] with fam SharesOK[bound K] in group then
in the presence of fam InitOK[bound (N + 2) bound (N + 2) dependentBound I]
 rewrite group Wires-OK[bound K] and SharesOK[bound K]
 to 
 (
  (family  SharesOK[bound K] 
 indices: k
 bounds: bound K
::=
(when (isInputGate(k)) --> (
(family  Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family  CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family  RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family  SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(family  ShareOK[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family  ShareSum-OK[bound (N + 1) bound K] 
 indices: m, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
)
;;
(when (isNotGate(k)) --> (
(family  Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family  CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family  RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family  SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(family  ShareOK[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family  ShareSum-OK[bound (N + 1) bound K] 
 indices: m, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
)
;;
(when (isXorGate(k)) --> (
(family  Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family  CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family  RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family  SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(family  ShareOK[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family  ShareSum-OK[bound (N + 1) bound K] 
 indices: m, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
)
;;
(when (isAndGate(k)) --> (
(family  Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
||
(family  CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
||
(family  RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (m < n) -->
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
;;
(when (n <= m) -->
 rb : unit <- read RcvdBit-OK[n, m, k] ; return rb
)
)
||
(family  SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
;;
(
when (m <= n) -->
 sb : unit <- read SendBit-OK[n, m, k] ; return sb
)
)
||
(family  ShareOK[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family  ShareSum-OK[bound (N + 1) bound K] 
 indices: m, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
)
)
||
(family Wires-OK[bound K] 
 indices: k
 bounds: bound K
::=
family Wire-OK[bound K] 
 indices: k
 bounds: bound K
::= (
(when (isInputGate(k)) -->
 in : unit <- read In-OK[wire0(k), wire1(k)] ; return in
)
;;
(when (isNotGate(k)) -->
 w : unit <- read Wire-OK[wire0(k)] ; return ()
)
;;
(when (isXorGate(k)) -->
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
;;
(when (isAndGate(k)) -->
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
)
)
)
 by induction on k bound B (
  ungroup fam InitOK[bound N + 2 bound N + 2 dependentBound I] then
        remove fam ShareOK[bound (N + 1) bound B] from group SharesOK[bound B] then
        merge cases for fam ShareOK[bound (N + 1) bound B] then    
        remove fam ShareOK[fixedBound (N + 1) bound B] from group SharesOK[bound B] then
        merge cases for fam ShareOK[fixedBound (N + 1) bound B] then        
        remove fam ShareSum-OK[bound (N + 1) bound B] from group SharesOK[bound B] then
        merge cases for fam ShareSum-OK[bound (N + 1) bound B] then
        remove and merge fam ShareSum-OK[bound (N + 1) fixedBound B] 
          from group SharesOK[fixedBound B] then
        unsplit fam ShareOK[bound (N + 1) bound B] and 
                fam ShareOK[fixedBound (N + 1) bound B] then
        case distinction on group SharesOK[fixedBound B] (
  case: (
          subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          call symInput 
       )
  case: (
          subst fam ShareOK[bound (N + 2) bound B]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          unit-ext on fam ShareOK[bound (N + 1) fixedBound B] at 1 then
          call wireSymNot            
       )
  case:  (
          subst fam ShareOK[bound (N + 2) bound B]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          rename w to w0 in fam ShareOK[bound (N + 1) fixedBound B] then           
          subst fam ShareOK[bound (N + 2) bound B]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          rename w to w1 in fam ShareOK[bound (N + 1) fixedBound B] then           
          call wireSymXor            
       )
  case: (
         case distinction on family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
         (
         case: (subst fam ShareOK[bound (N + 2) bound B]
                into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
                rename w to w0 in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
                subst fam ShareOK[bound (N + 2) bound B]
                into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
                rename w to w1 in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
         )       
         case: (idle)
         ) then
         rename indices to m, n, k 
          in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
         call symRcvdBit then 
         case distinction on family RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
         (
          case: (
          using branch when (m < n)
           of family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          ( 
            subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
             into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          ) then
          subst fam ShareOK[bound (N + 2) bound B]
           into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
          subst fam ShareOK[bound (N + 2) bound B]
           into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
          rename w to w0 in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then  
          subst fam ShareOK[bound (N + 2) bound B]
           into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
          subst fam ShareOK[bound (N + 2) bound B]
           into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
          rename w to w1 in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] 
         )
          
          case: (
          using branch when n <= m 
           of family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          (  diverge on fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] 
              with fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] var rb  
          ) 
                )
         
         ) then
         rename indices to n, m, k
          in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then  
         case distinction on
          family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ]
         (
           case: (
           using branch when (n < m)
            of family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          (subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] 
            into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          )  
           )
           case: (
           using branch when (m < n)
            of family RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          (subst fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] 
            into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          )  
           )
           case: (
           subst fam ShareOK[bound (N + 2) bound B] 
            into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
           rename w to w0 in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
           subst fam ShareOK[bound (N + 2) bound B] 
            into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
           rename w to w1 in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ]       
           )
         ) then 
         merge cases for fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
         in the presence of fam  Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] 
         rewrite family CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B ]
         to w0 : unit <- read Wire-OK[wire0(B)] ;
            w1 : unit <- read Wire-OK[wire1(B)] ;
            return ()
         by induction on m bound M
         (
           case distinction on 
           family CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B ]
           (
           case: (
            subst fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
             into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
           )
           case: (
           subst fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
             into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B] then
           subst fam CtrbSum-OK[bound (N + 2) bound M fixedBound B]
             into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]  
           )
           ) then
           merge cases for fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B ]
         ) then   
         subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          into fam ShareOK[bound (N + 1) fixedBound B] then
          call wireSymAnd 
       ) 
      ) then
      remove fam ShareOK[bound (N + 1) fixedBound B]
        from group SharesOK[fixedBound B] then
      merge cases for fam ShareOK[bound (N + 1) fixedBound B] then
      in the presence of fam ShareOK[bound (N + 1) fixedBound B] 
       rewrite family ShareSum-OK[bound (N + 1) fixedBound B]
       to w : unit <- read Wire-OK[B] ; return w
       by induction on m bound M
       (
        case distinction on 
         channel ShareSum-OK[M, B]
        ( case: (
           subst fam ShareOK[bound (N + 1) fixedBound B]
            into chn ShareSum-OK[M, B]
          )
        
          case: (
            subst fam ShareOK[bound (N + 1) fixedBound B]
            into chn ShareSum-OK[M, B] then
            subst fam ShareSum-OK[bound M fixedBound B]
            into chn ShareSum-OK[M, B]
          )
        
        ) then
        merge cases for chn ShareSum-OK[M, B] then
         sym from 
         change 
          chn ShareSum-OK[M, B]
         with
          w : unit <- read Wire-OK[B] ; return w
         in currentProtocol (
            unit-ext on  chn ShareSum-OK[M, B] at 1
          )   
      ) then
       move family ShareOK[bound (N + 1) fixedBound B]
        on each branch of group SharesOK[fixedBound B] then
       move family ShareSum-OK[bound (N + 1) fixedBound B]
        on each branch of group SharesOK[fixedBound B] then
   case distinction on group SharesOK[fixedBound B] (
  case: ( 
         subst fam InShareOK[bound N + 2 bound N + 2 dependentBound I]         
          into chn ShareOK[N + 1, B] then 
         subst fam ShareSum-OK[bound (N + 1) fixedBound B]         
          into chn ShareOK[N + 1, B] then
         using group Wires-OK[fixedBound B]
         (
          using branch when isInputGate(B)
           of channel Wire-OK[B]
           (subst chn Wire-OK[B]
           into chn ShareOK[N + 1, B])
         ) then
         sym from
             change 
              chn ShareOK[N + 1, B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
        (
          using group Wires-OK[fixedBound B]
          ( using branch when isInputGate(B)
            of channel Wire-OK[B]
             (subst chn Wire-OK[B] into chn ShareOK[N + 1, B] then
              unit-ext on chn ShareOK[N + 1, B] at 1
             )
            )
       )       
       )
  case: (  subst fam ShareSum-OK[bound (N + 1) fixedBound B]         
          into chn ShareOK[N + 1, B] then
         rename w to w0 in chn ShareOK[N + 1, B] then
         subst fam ShareOK[bound (N + 2) bound B]         
          into chn ShareOK[N + 1, B] then
          using group Wires-OK[fixedBound B]
         (
          using branch when isNotGate(B)
           of channel Wire-OK[B]
           (subst chn Wire-OK[B]
           into chn ShareOK[N + 1, B])
         ) then
         unit-ext on chn ShareOK[N + 1, B] at 1 then
         call wireSymNotC  
       )  
  case:  ( subst fam ShareOK[bound (N + 2) bound B]         
          into chn ShareOK[N + 1, B] then
         rename w to w0 in chn ShareOK[N + 1, B] then
         subst fam ShareOK[bound (N + 2) bound B]         
          into chn ShareOK[N + 1, B] then
         rename w to w1 in chn ShareOK[N + 1, B] then
         subst fam ShareSum-OK[bound (N + 1) fixedBound B]   
          into chn ShareOK[N + 1, B] then
         using group Wires-OK[fixedBound B]
         (
          using branch when isXorGate(B)
           of channel Wire-OK[B]
           (subst chn Wire-OK[B]
           into chn ShareOK[N + 1, B])
         ) then
         call wireSymXorC               
       )
  case:  (
       subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
        into chn ShareOK[N + 1, B] then
       subst fam ShareSum-OK[bound (N + 1) fixedBound B]
        into chn ShareOK[N + 1, B] then    
       using group Wires-OK[fixedBound B]
       (
         using branch when (isAndGate(B))
          of channel Wire-OK[B]
         (subst chn Wire-OK[B]
           into chn ShareOK[N + 1, B] ) 
       ) then
       call wireSymAndC
       )
 ) then
  call addInitOK then
           split fam ShareOK[bound (N + 2) bound B] on first index then
           move family ShareOK[bound (N + 1) bound B] 
            on each branch of group SharesOK[bound B] then
           move family ShareOK[fixedBound (N + 1) bound B] 
            on each branch of group SharesOK[bound B] then
          move family ShareSum-OK[bound (N + 1) bound B] 
            on each branch of group SharesOK[bound B]      
  ) then
  decompose fam Wires-OK[bound K] with fam SharesOK[bound K] then 
    remove fam ShareOK[bound (N + 1) bound K]
           from group SharesOK[bound K] then
merge cases for fam ShareOK[bound (N + 1) bound K] then
remove fam ShareOK[fixedBound (N + 1) bound K]
           from group SharesOK[bound K] then
merge cases for fam ShareOK[fixedBound (N + 1) bound K] then
remove fam ShareSum-OK[bound (N + 1) bound K]
           from group SharesOK[bound K] then
merge cases for fam ShareSum-OK[bound (N + 1) bound K] then 
change name fam SharesOK[bound K] to Ctrbs-OK then
on branch isAndGate(k) of group Adv[bound K] (
  on branch n < N + 1 of
   family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K ]
  (subst fam ShareSum-OK[bound (N + 1) bound K]
    into fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K ]) then
  on branch n < N + 1 of
   family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K ]
  (subst fam ShareSum-OK[bound (N + 1) bound K]
    into fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K ])
) then
     `` now induction for Shares
      call addHidden then
call addHiddenGroup then
compose fam HiddenGroup[bound K] with fam Shares[bound K] in group then
  in the presence of fam ShareSum-OK [bound N + 1 bound K ] 
  rewrite group HiddenGroup[bound K] and Shares[bound K]
  to 
   (
    (family HiddenGroup[bound K]  
      indices: k
      bounds: bound K ::=
     family Hidden[bound K] 
      indices: k
      bounds: bound K ::=
       return ()
    )
   ||
 (
    family Shares[bound K]
     indices: k
  bounds: bound K
::=
(
(when (isInputGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <- read InShare[n , wire0(k) , wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 in : bool <- read InShare[N + 1, wire0(k) , wire1(k)] ; 
 w : unit <- read  Wire-OK[k] ; 
 return in
) 
)
)
;;
(when (isNotGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <- read Share[n , wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read  Wire-OK[k] ;
 x : bool <- read Share[N + 1 , wire0(k)] ; 
 return neg(x)
) 
)
)
;;
(when (isXorGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <- read Share[n , wire0(k)] ;  
 y : bool <- read Share[n , wire1(k)] ; 
 return  xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read  Wire-OK[k] ;
 x : bool <- read Share[N + 1, wire0(k)] ; 
 y : bool <- read Share[N + 1, wire1(k)] ; 
 return  xor((x, y))
)
)
)
;;
when (isAndGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <- read SendBit[n, m, k] ; return s
) 
;;
(when (m = n) -->
 x : bool <- read Share[n , wire0(k)] ;
 y : bool <- read Share[n , wire1(k)] ; 
 return  **((x, y))
) 
;;
(when (m < n) -->
 r : bool <- read RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (0 = m) -->
 b : bool <- read Ctrb[n, 0, k] ; return b
) 
;;
(when not (0 = m) -->
 b : bool <- read Ctrb[n, m, k] ; 
 s : bool <- read CtrbSum[n, m - 1, k] ; 
 return xor((s, b))
) 
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read SendBit[m, n, k] ;
 xm : bool <- read Share[m , wire0(k)] ; 
 xn : bool <- read Share[n , wire0(k)] ; 
 ym : bool <- read Share[m , wire1(k)] ; 
 yn : bool <- read Share[n, wire1(k)] ; 
 return xor( ( xor( (**((xm, yn)), **((xn, ym))) ) , b) ) 
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <- read Share[n , wire0(k)] ;
 y : bool <- read Share[n , wire1(k)] ; 
  samp flip (())
)
;;
(when (m <= n) -->
 sb : bool <- read SendBit[n, m, k] ; return sb
)
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[N + 1, N + 1, k] ;
 w : unit <- read Wire-OK[k] ; 
 return bs
)
)
) 
 )
   )
  by induction on k bound B
  (
  case distinction on group Shares[fixedBound B]
  (
    case: (
    subst fam ShareSum-OK[bound (N + 1) bound K]
     into chn Share[N + 1, B]
  )
    case: (
    subst fam ShareSum-OK[bound (N + 1) bound K]
     into chn Share[N + 1, B]
  )
    case: (
    subst fam ShareSum-OK[bound (N + 1) bound K]
     into chn Share[N + 1, B]
  ) 
    case: (
    subst fam ShareSum-OK[bound (N + 1) bound K]
     into chn Share[N + 1, B]
  )  
  )
  ) then
  decompose fam HiddenGroup[bound K] with fam Shares[bound K] then
ungroup fam HiddenGroup[bound K] then
absorb fam Hidden[bound K] then
absorb fam ShareSum-OK[bound (N + 1) bound K]
) then 
`` up to here is 3gmwn.ipdl: checked with check-proof pInt2 but without then after 2gmwn.ipdl
subst fam OutShare[bound (N + 2) bound (N + 2) bound K]
  into fam OutSharePartyAdv[bound (N + 2) bound (N + 2) bound K] then
 call addGroupOS then
 call addBranchGroupOS then
 case distinction on group GroupOS[bound (N + 2) bound (N + 2) bound K](
   case: (
    turn otherwise into neg 
      for fam OutShareSum[bound (N + 2) bound (N + 2) bound K] then
 in the presence of
      fam OutShare[bound (N + 2) bound (N + 2) bound K] ,
      fam ShareSum[bound (N + 2) bound K] 
     rewrite family  OutShareSum[bound (N + 2) bound (N + 2) bound K]
     to s : bool <- read ShareSum[m, k] ; return s
     by induction on m bound M (
  case distinction on family  OutShareSum[bound N + 2 fixedBound M bound K ] (

   case: (
    using branch when isOutputWire(k)
     of family OutShare[bound (N + 2) bound (N + 2) bound K]
   (subst fam OutShare[bound (N + 2) bound (N + 2) bound K]
     into fam OutShareSum[bound (N + 2) fixedBound M bound K]  
   ) then
  sym from 
 change 
        fam OutShareSum[bound (N + 2) fixedBound M bound K]
        with
         s : bool <- read ShareSum[M, k] ; return s
        in currentProtocol
 (
  subst branch when (m = 0) of fam ShareSum[bound (N + 2) bound K]
   into fam OutShareSum[bound (N + 2) fixedBound M bound K]
     
 )
   )

   case: (
   rename s to is in 
    fam OutShareSum[bound (N + 2) fixedBound M bound K] then
    using branch when isOutputWire(k)
     of family OutShare[bound (N + 2) bound (N + 2) bound K]
   (subst fam OutShare[bound (N + 2) bound (N + 2) bound K]
     into fam OutShareSum[bound (N + 2) fixedBound M bound K]  
   ) then
  rename s to iis 
   in  fam OutShareSum[bound (N + 2) fixedBound M bound K] then
   subst fam OutShareSum[bound (N + 2) bound M bound K]
              into fam OutShareSum[bound (N + 2) fixedBound M bound K] then
  rename iis to xm, s to xs 
               in fam OutShareSum[bound (N + 2) fixedBound M bound K] then
  sym from 
           change fam OutShareSum[bound (N + 2) fixedBound M bound K]
          with s : bool <- read ShareSum[M, k] ; return s
          in currentProtocol
  ( 
    subst branch when not (m = 0) of fam ShareSum[bound (N + 2) bound K] 
     into fam OutShareSum[bound (N + 2) fixedBound M bound K] 
  )
   )
  ) then
       merge cases for fam OutShareSum[bound (N + 2) fixedBound M bound K]
     )
   )

   case: (
    case distinction on 
    family OutShareSum[bound (N + 2) bound (N + 2) bound K]
   (
     case: (
    diverge on 
     fam OutShareSum[bound (N + 2) bound (N + 2) bound K]
    with branch not (isOutputWire(k)) 
    of fam OutShare[bound (N + 2) bound (N + 2) bound K]
    var o  
    )
    
    case: (
    diverge on 
     fam OutShareSum[bound (N + 2) bound (N + 2) bound K]
    with branch not (isOutputWire(k)) 
    of fam OutShare[bound (N + 2) bound (N + 2) bound K]
    var o  
    )
   ) then 
   merge cases for fam OutShareSum[bound (N + 2) bound (N + 2) bound K] 

   )

 ) then
 combine fam GroupOS[bound (N + 2) bound (N + 2) bound K] then
 subst fam OutShareSum[bound (N + 2) bound (N + 2) bound K] 
  into fam OutShareSumPartyAdv[bound (N + 2) bound (N + 2) bound K] then
 sym from 
        change 
       fam Out[bound (N + 2) bound K]
        with
         (when (isOutputWire(k)) --> 
           s : bool <- read OutShareSum[n, N + 1, k] ; return s 
         )
         ;;
         (when (not (isOutputWire(k)) ) --> 
           s : bool <- read OutShareSum[n, N + 1, k] ; return s
         )
        in currentProtocol
       ( merge cases for fam Out[bound (N + 2) bound K]) then
      case distinction on
 family Out[bound (N + 2) bound K]
(

 case: (
    focus fam OutShareSum[bound (N + 2) bound (N + 2) bound K] ,
          fam Out[bound (N + 2) bound K]
              (  
              using branch when isOutputWire(k)
               of family OutShareSum[bound (N + 2) bound (N + 2) bound K]
              (subst fam OutShareSum[bound (N + 2) bound (N + 2) bound K]
               into fam Out[bound (N + 2) bound K]) 
              )
 )
 
 case: (
     focus fam OutShareSum[bound (N + 2) bound (N + 2) bound K] ,
          fam Out[bound (N + 2) bound K]
              (  
              using branch when not (isOutputWire(k))
               of family OutShareSum[bound (N + 2) bound (N + 2) bound K]
              (diverge on fam Out[bound (N + 2) bound K] 
                with fam OutShareSum[bound (N + 2) bound (N + 2) bound K] 
                var o
              )
              )
 )

) then 
absorb fam OutShare[bound (N + 2) bound (N + 2) bound K] then
absorb fam OutShareSum[bound (N + 2) bound (N + 2) bound K] then
split fam ShareSum[bound (N + 2) bound K] on first index then
move family ShareSum[bound (N + 1) bound K] 
 on each branch of group Shares[bound K] then      
move family ShareSum[fixedBound (N + 1) bound K] 
 on each branch of group Shares[bound K] then
sym from 
     change fam Shares[bound K]
     with (
     (when  isInputGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <-  read InShare[n, wire0(k), wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
 )
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 i : bool <-  read In[wire0(k), wire1(k)] ; 
    return i
)
))
;;
(when  isNotGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <-  read Share[n, wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
    xs : bool <-  read ShareSum[N, k] ; 
    return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
 )
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, wire0(k)] ;
    return neg(x)
)
))
;;
(when  isXorGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, wire0(k)] ; 
 y : bool <-  read ShareSum[N + 1, wire1(k)] ; 
 return xor((x, y))
)
))
;;
(when  isAndGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <-  read SendBit[n, m, k] ; return s
)
;;
(when (m = n) -->
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
 return **((x, y))
)
;;
(when (m < n) -->
 r : bool <-  read RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (m = 0) -->
 b : bool <-  read Ctrb[n, 0, k] ; return b
)
;;
(when not (m = 0) -->
 b : bool <-  read Ctrb[n, m, k] ; 
 s : bool <-  read CtrbSum[n, m - 1, k] ; 
 return xor((s, b))
)
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read SendBit[m, n, k] ; 
 xm : bool <-  read Share[m, wire0(k)] ; 
 xn : bool <-  read Share[n, wire0(k)] ; 
 ym : bool <-  read Share[m, wire1(k)] ; 
 yn : bool <-  read Share[n, wire1(k)] ; 
 return xor( ( xor(( **((xm, yn)), **((xn, ym))  )) , b) )
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
    samp flip (()) 
)
;;
(when (m <= n) -->
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <-  read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
    xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))   
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, wire0(k)] ; 
 y : bool <-  read ShareSum[N + 1, wire1(k)] ; 
 return **((x, y))
)
))    

     )
        in currentProtocol 
(
in the presence of 
 fam InShare[bound (N + 2) bound (N + 2) dependentBound I], 
 fam InShare$[bound (N + 2) bound (N + 2) dependentBound I],
 fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
rewrite family Shares[bound K]
to (
(when  isInputGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <-  read InShare[n, wire0(k), wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 in : bool <- read InShare[N + 1, wire0(k), wire1(k)] ; 
 xs : bool <- read ShareSum[N, k] ;
 return in
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 xm : bool <-  read Share[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, xm))
)    
))
;;
(when  isNotGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <-  read Share[n, wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read Share[N + 1, wire0(k)] ; 
 xs : bool <-  read ShareSum[N, k] ;
    return neg(x) 
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ;
 return xor((xs, xm)) 
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 xm : bool <-  read Share[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, xm)) 
)
))
;;
(when  isXorGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read Share[N + 1, wire0(k)] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 y : bool <-  read Share[N + 1, wire1(k)] ; 
 return xor((x, y))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 xm : bool <-  read Share[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, xm))
)
))
;;
(when  isAndGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <-  read SendBit[n, m, k] ; return s
)
;;
(when (m = n) -->
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
 return **((x, y))
)
;;
(when (m < n) -->
 r : bool <-  read RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (m = 0) -->
 b : bool <-  read Ctrb[n, 0, k] ; return b
)
;;
(when not (m = 0) -->
 b : bool <-  read Ctrb[n, m, k] ; 
 s : bool <-  read CtrbSum[n, m - 1, k] ; 
 return xor((s, b))
)
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read SendBit[m, n, k] ; 
 xm : bool <-  read Share[m, wire0(k)] ; 
 xn : bool <-  read Share[n, wire0(k)] ; 
 ym : bool <-  read Share[m, wire1(k)] ; 
 yn : bool <-  read Share[n, wire1(k)] ; 
 return xor( (xor( ( **((xm, yn)), **((xn, ym)) ) ) , b ) )
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
    samp flip (()) 
)
;;
(when (m <= n) -->
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <-  read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 bs : bool <-  read CtrbSum[N + 1, N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return bs
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 xm : bool <-  read Share[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, xm))
)
))
)
by induction on k bound B 
( `` induction starts here
turn otherwise into neg 
 for fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I] then
turn otherwise into neg 
 for fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] then
case distinction on group Shares[fixedBound B] (
  case: (
    sym from
  change chn Share[N + 1, B]
  with
   in : bool <- read InShare[N + 1, wire0(B), wire1(B)] ; 
   xs : bool <- read ShareSum[N, B] ;
   return in
  in (
        change 
        chn ShareSum[N + 1, B]
        with
         xm : bool <- read Share[N + 1, B] ;
         xs : bool <- read ShareSum[N, B] ;
         return xor((xs, xm))
        in 
        currentProtocol)
(
    subst chn Share[N + 1, B] 
     into chn ShareSum[N + 1, B] then
    sym from
         change 
        chn Share[N + 1, B] 
        with
          x : bool <- read ShareSum[N + 1, B] ;
          xs : bool <- read ShareSum[N, B] ;
          return xor((xs, x))
        in currentProtocol
       ( subst chn ShareSum[N + 1, B]
          into chn Share[N + 1, B] then
         use expression assumption xor-idem-1
          on chn Share[N + 1, B] at 1  
       ) then
    call indShareSum then
    subst fam ShareSum[bound (N + 1) fixedBound B]
         into chn ShareSum[N + 1, B] then
    sym from  
   change 
        fam ShareSum[bound (N + 1) fixedBound B]
        with
        (when (0 = m) -->
           s : bool <- read Share[0, B] ; return s
        )   
        ;;
        (when (not (0 = m)) -->
           xm : bool <- read Share[m, B] ; 
           xs : bool <- read ShareSum[m - 1, B] ; 
           return xor((xs, xm)) 
        )
        in currentProtocol
       (
        call  indShareSum
       ) then
       subst fam InShare[bound (N + 2) bound (N + 2) dependentBound I] 
         into chn ShareSum[N + 1, B] then
       subst fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]
         into chn ShareSum[N + 1, B] then
       use expression assumption xor-idem-2
          on chn ShareSum[N + 1, B] at 1 then
       call addInternalsInputBranch then
        sym from 
        change 
        chn ShareSum[N + 1, B]
        with
         s : unit <- read InShare$Sum-OK[N, wire0(B), wire1(B)] ;
         x : bool <- read In[wire0(B), wire1(B)] ;
         return x
        in currentProtocol
       ( subst fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
          into chn ShareSum[N + 1, B] then
         rename i to s in chn ShareSum[N + 1, B] 
       )  then
  sym from 
       change 
        fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
        with
         (when (0 = m) -->
           in : unit <- read InShare$-OK[0, p, i] ; 
           return ()
         )
         ;;
         (when (not (0 = m)) -->
           s : unit <- read InShare$Sum-OK[m - 1, p, i] ;
           x : unit <- read InShare$-OK[m, p, i] ;
           return ()
         )
        in currentProtocol ( 
    rename indices
         to m, p, i in fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I] then
    rename indices
         to m, p, i in fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] then
    call pSetupInd0 then
    rename indices
         to m, n, i in fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I] then
    rename indices
         to m, n, i in fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
        ) then
    call dropInShare$ then
    sym from change 
        fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I]
        with
         i : unit <- read In-OK[p, i] ;
         return ()
        in currentProtocol
        ( subst fam In-OK[bound (N + 2) dependentBound I] 
           into fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] then
          rename i to x 
           in fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
        ) then
    in the presence of
   fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
  rewrite family InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
  to i : unit  <- read In-OK[p, i] ; return ()
  by induction on m bound M
  ( case distinction on 
     family InShare$Sum-OK[fixedBound M  bound (N + 2) dependentBound I]
    (
      case:(
       subst fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
        into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
      )
      
      case:(
        subst fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
         into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then 
        subst fam InShare$Sum-OK[bound M bound (N + 2) dependentBound I] 
         into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
     )  
    ) then
     merge cases for 
        fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
   ) then
   subst fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
       into chn ShareSum[N + 1, B] then
      subst fam In-OK[bound (N + 2) dependentBound I] 
       into chn ShareSum[N + 1, B] then
      rename x to i in chn ShareSum[N + 1, B] then
   absorb fam In-OK[bound (N + 2) dependentBound I] then
  absorb fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] then
  absorb fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]                     
)
  )
  case:(sym from change 
        chn Share[N + 1, B]
             with
         x : bool <- read Share[N + 1, wire0(B)] ;
         xs : bool <- read ShareSum[N, B] ; 
         return neg(x)
        in (
        change 
        chn ShareSum[N + 1, B]
        with
         xm : bool <- read Share[N + 1, B] ;
         xs : bool <- read ShareSum[N, B] ;
         return xor((xs, xm))
        in 
        currentProtocol) (
     subst chn Share[N + 1, B]
      into chn ShareSum[N + 1, B] then
     sym from  change 
        chn Share[N + 1, B]
        with
         x : bool <- read ShareSum[N + 1, B] ;
         xs : bool <- read ShareSum[N, B] ;
         return xor((xs, x))
        in currentProtocol
  (  subst chn ShareSum[N + 1, B]
      into chn Share[N + 1, B] then
     use expression assumption xor-idem-1
          on chn Share[N + 1, B] at 1
  ) then
  call rewriteSharesBoundNotAux then
    subst fam ShareSum[bound (N + 1) fixedBound B]
     into chn ShareSum[N + 1, B] then
  sym from  change
         fam ShareSum[bound (N + 1) fixedBound B]
        with
         (when (0 = m) -->
           s : bool <- read Share[0, B] ; return s
         )   
          ;;
         (when (not (0 = m)) -->
           xm : bool <- read Share[m, B] ;
           xs : bool <- read ShareSum[m - 1, B] ;
           return xor((xs, xm))
        )
        in
        currentProtocol 
  (call rewriteSharesBoundNotAux) then
       use expression assumption neg-over-xor on chn ShareSum[N + 1, B] at 1 then
       remove and merge fam ShareSum[fixedBound (N + 1) bound B]
      from group Shares[bound B] then
     sym from  change 
        chn ShareSum[N + 1, B]
        with
        x : bool <- read ShareSum[N + 1, wire0(B)] ;
        return neg(x) 
        in currentProtocol
   (
        subst fam ShareSum[fixedBound (N + 1) bound B]
         into chn ShareSum[N + 1, B] then 
        rename xm to x, xs to s in chn ShareSum[N + 1, B]
   ) then
     move family ShareSum[fixedBound (N + 1) bound B]
      on each branch of group Shares[bound B]         
))
  case:(
    sym from change 
        chn Share[N + 1, B]
        with
         x : bool <- read Share[N + 1, wire0(B)] ;
         xs : bool <- read ShareSum[N, B] ;
         y : bool <- read Share[N + 1, wire1(B)] ;
         return xor((x, y))
        in (
        change 
        chn ShareSum[N + 1, B]
        with
         xm : bool <- read Share[N + 1, B] ;
         xs : bool <- read ShareSum[N, B] ;
         return xor((xs, xm))
        in 
        currentProtocol) 
        (
         subst chn Share[N + 1, B]
   into chn ShareSum[N + 1, B] then
 sym from change 
        chn Share[N + 1, B]
        with
         x : bool <- read ShareSum[N + 1, B] ;
         xs : bool <- read ShareSum[N, B] ;
         return xor((xs, x))
        in currentProtocol
     ( subst chn ShareSum[N + 1, B] 
        into chn Share[N + 1, B] then
       use expression assumption xor-idem-1
          on chn Share[N + 1, B] at 1   
     ) then
     call setupIndShareSumXor then
 rename x to a, y to b in chn ShareSum[N + 1, B] then 
 subst fam ShareSum[bound (N + 1) fixedBound B]
  into chn ShareSum[N + 1, B] then  
 use expression assumption rearrange-xor
          on chn ShareSum[N + 1, B] at 1 then    
 remove and merge fam ShareSum[fixedBound (N + 1) bound B]
  from group Shares[bound B] then
 sym from change 
        chn ShareSum[N + 1, B]
        with
         x : bool <- read ShareSum[N + 1, wire0(B)] ;
         y : bool <- read ShareSum[N + 1, wire1(B)] ; 
         return xor((x, y))
        in currentProtocol
         (
         subst fam ShareSum[fixedBound (N + 1) bound B] 
          into chn ShareSum[N + 1, B] then
        rename xs to x, xm to a
           in chn ShareSum[N + 1, B] then
         subst fam ShareSum[fixedBound (N + 1) bound B] 
          into chn ShareSum[N + 1, B] then
        rename xs to y, xm to b
           in chn ShareSum[N + 1, B]
        ) then           
 sym from change 
        fam ShareSum[bound (N + 1) fixedBound B]
        with (
         (when (0 = m) -->
           s : bool <- read Share[0, B] ; return s
         )  
         ;;
         (when not (0 = m) -->
           xm : bool <- read Share[m, B] ;
           xs : bool <- read ShareSum[m - 1, B] ;
           return xor((xs, xm)) 
         ))
        in currentProtocol
        (call setupIndShareSumXor) then
 move family ShareSum[fixedBound (N + 1) bound B]
  on each branch of group Shares[bound B]
        )
  )
  case:(
    sym from
        change 
        chn Share[N + 1, B]
        with
         bs : bool <- read CtrbSum[N + 1, N + 1, B] ;
         xs : bool <- read ShareSum[N, B] ;
         return bs 
        in (
        change 
        chn ShareSum[N + 1, B]
        with
         xm : bool <- read Share[N + 1, B] ;
         xs : bool <- read ShareSum[N, B] ;
         return xor((xs, xm))
        in 
        currentProtocol) 
(
subst chn Share[N + 1, B]
 into chn ShareSum[N + 1, B] then       
sym from 
   change chn Share[N + 1, B]
   with
    x : bool <- read ShareSum[N + 1, B] ;
    xs : bool <- read ShareSum[N, B] ;
    return xor((xs, x))
   in currentProtocol
  ( subst chn ShareSum[N + 1, B] 
     into chn Share[N + 1 , B] then
    use expression assumption xor-idem-1
          on chn Share[N + 1, B] at 1  
  
  ) then
  call addColAndColSum then
`` turn the family ShareSum(up to N + 1, fixed B) into closed form, reads from ColSum
call setupIndSSAnd then
subst fam ShareSum[bound (N + 1) fixedBound B]
 into chn ShareSum[N + 1, B] then
`` put  the family ShareSum(up to N + 1, fixed B) back in its original form 
 sym from
  change fam ShareSum[bound (N + 1) fixedBound B]
  with
 (when (0 = m) -->
   s : bool <- read Share[0, B] ; return s
 )  
 ;;
 (when (not (0 = m)) -->
   xm : bool <- read Share[m, B] ; 
   xs : bool <- read ShareSum[m - 1, B] ;
   return xor((xs, xm))
 )
 in currentProtocol
 (call setupIndSSAnd) then
 sym from change 
        chn ShareSum[N + 1, B]
        with
         c : bool  <- read ColSum[N + 1, N + 1] ;
             return c
        in currentProtocol
        ( 
     subst branch when (not (i = 0)) of fam ColSum[bound (N + 2) bound (N + 2)]
      into chn ShareSum[N + 1, B]  then
 subst fam Col[bound (N + 2) bound (N + 2)]
      into chn ShareSum[N + 1, B] then
 rename c to t in chn ShareSum[N + 1, B] then
 rename bs to c in chn ShareSum[N + 1, B] then     
 rename t to bs in chn ShareSum[N + 1, B]
      ) then
call changeColToInductive then
`` add Row and RowSum
call addRowAndRowSum  then
compose
 fam RowSum[bound (N + 2) bound (N + 2)]
with  
 fam ColSum[bound (N + 2) bound (N + 2)]
in group then
call setupIndColRow then
decompose
 fam RowSum[bound (N + 2) bound (N + 2)]
with  
 fam ColSum[bound (N + 2) bound (N + 2)] then
call addSqr then
sym from change 
        chn ShareSum[N + 1, B]
        with
         c : bool  <- read Sqr[N + 1] ;
         return c
        in currentProtocol
        ( subst fam Sqr[bound (N + 2)] 
           into chn ShareSum[N + 1, B]
        ) then         
call revertColSumInductive then
sym from
        change fam Sqr[bound (N + 2)]
        with
        (when (i = 0) --> 
          c : bool <- read Col[0, 0] ; return c
        )
        ;;
        (when (not (i = 0)) -->
          bs : bool <- read Sqr[i - 1] ; 
          br : bool <- read Row[i - 1, i] ;
          bc : bool <- read Col[i, i] ;
          return xor((xor((bs, br)), bc))
        )
        in currentProtocol (
in the presence of 
        fam Col[bound (N + 2) bound (N + 2)] ,
        fam Row[bound (N + 2) bound (N + 2)] , 
        fam ColSum[bound (N + 2) bound (N + 2)] ,
        fam RowSum[bound (N + 2) bound (N + 2)]
       rewrite family Sqr[bound (N + 2)]
       to c : bool <- read ColSum[i, i] ; return c
       by induction on i bound B (
case distinction on channel Sqr[B]
        (
          case: (
            sym from
       change chn Sqr[B]
       with c : bool <- read ColSum[0, 0] ; return c
       in currentProtocol
       ( subst branch when (i = 0) of fam ColSum[bound (N + 2) bound (N + 2)]
          into chn Sqr[B]
       ) 
          )
       case: (
        sym from
       change chn Sqr[B]
       with c : bool <- read ColSum[B, B] ; return c
       in currentProtocol (
subst branch when (not (i = 0)) of fam ColSum[bound (N + 2) bound (N + 2)]
           into chn Sqr[B] then
compose
 fam RowSum[bound (N + 2) bound (N + 2)]
with  
 fam ColSum[bound (N + 2) bound (N + 2)]
in group then  
call setupIndColRow then
decompose
 fam RowSum[bound (N + 2) bound (N + 2)]
with  
 fam ColSum[bound (N + 2) bound (N + 2)] then
 subst fam ColSum[bound (N + 2) bound (N + 2)]
         into chn Sqr[B] then
        subst branch when (not (j = 0)) of fam RowSum[bound (N + 2) bound (N + 2)]
          into chn Sqr[B] then
sym from
   change chn Sqr[B]
     with 
      bi : bool <- read Col[B, B] ;
      bj : bool <- read Row[B - 1, B] ;
      r : bool <- read Sqr[B - 1] ;
      return xor((xor((r, bj)), bi)) 
    in currentProtocol       
       (
       subst fam Sqr[bound B] 
        into chn Sqr[B] then 
       subst fam ColSum[bound (N + 2) bound (N + 2)]
        into chn Sqr[B] 
       ) then
         rename bi to bc, bj to br, r to bs
          in chn Sqr[B] then
        call revertColSumInductive
       )
       )
        ) then
sym from 
  change chn Sqr[B]
  with c : bool <- read ColSum[B, B] ; return c
  in currentProtocol
  (
       sym from 
       change chn Sqr[B]
       with 
       (when (B = 0) -->
       c : bool <- read ColSum[B, B] ; return c
       )
       ;; 
       (when (not (B = 0)) -->
       c : bool <- read ColSum[B, B] ; return c
       )
       in currentProtocol
       (
       merge cases for chn Sqr[B]
       ) then
       case distinction on channel Sqr[B]
       (
         case: (use assumptions for B in chn Sqr[B])
         case: (idle)
       )
  )        
       )
        ) then
absorb fam ColSum[bound (N + 2) bound (N + 2)] then
absorb fam RowSum[bound (N + 2) bound (N + 2)] then
in the presence of 
    fam Row[bound (N + 2) bound (N + 2)] ,
    fam Col[bound (N + 2) bound (N + 2)],
    fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B],
    fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B],
    fam SendBit[bound (N + 2) bound (N + 2) fixedBound B],
    fam Shares[bound B]
  rewrite family Sqr[bound (N + 2)]
  to      
   xs : bool <- read ShareSum[i, wire0(B)] ;
   ys : bool <- read ShareSum[i, wire1(B)] ;
   return **((xs, ys))
  by induction on i bound Z 
(
case distinction on channel Sqr[Z] (
 case:(
 subst branch when (j = 0) of fam Col[bound (N + 2) bound (N + 2)]
         into chn Sqr[Z] then  
       subst branch when (m = n) of fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
           into chn Sqr[Z] then
       sym from
   change  chn Sqr[Z] 
   with 
    xs : bool <- read ShareSum[0, wire0(B)] ;
    ys : bool <- read ShareSum[0, wire1(B)] ;
    return **((xs, ys))
   in currentProtocol
       ( remove and merge 
          fam ShareSum[bound (N + 1) bound B]  
         from group Shares[bound B] then
         subst branch when (m = 0) of fam ShareSum[bound (N + 1) bound B]  
           into chn Sqr[Z] then 
         rename s to x in chn Sqr[Z] then
         subst branch when (m = 0) of fam ShareSum[bound (N + 1) bound B]  
           into chn Sqr[Z] then 
         rename s to y in chn Sqr[Z] then
         move family ShareSum[bound (N + 1) bound B]  
          on each branch of group Shares[bound B]  
       ) 
 )
 case: (
         rename bs to s in chn Sqr[Z] then
         subst branch when (not (j = 0)) of fam Col[bound (N + 2) bound (N + 2)]
         into chn Sqr[Z] then  
         rename bs to bc, s to bs, bj to b
          in chn Sqr[Z] then 
         use expression assumption middle-xor
          on chn Sqr[Z] at 1 then
         `` add internal families
         sym from
   extend
    (extend currentProtocol 
     with internal family DiagRef 
      indices: i 
      bounds: bound Z 
      typed: bool 
      assigned: 
       b : bool <- read Ctrb[i, Z, B] ;
       sb : bool <- read Ctrb[Z, i, B] ;
       return xor((b, sb))
   )
   with internal family RowCol 
      indices: i 
      bounds: bound Z 
      typed: bool 
      assigned: 
        br : bool <- read Row[i, Z] ;
        bc : bool <- read Col[Z, i] ;
        return xor((br, bc))
        (
         absorb fam RowCol[bound Z] then
         absorb fam DiagRef[bound Z]
        ) then
        `` add rowcol in Sqr
        sym from
       change 
       chn Sqr[Z]
       with 
        b : bool <- read Ctrb[Z, Z, B] ;
        brc : bool <- read RowCol[Z - 1] ; 
        bs : bool <- read Sqr[Z - 1] ; 
        return xor(( xor((bs, brc)) , b ))
       in currentProtocol
       ( subst fam RowCol[bound Z]
         into chn Sqr[Z]
       )  then
sym from
 change fam RowCol[bound Z]
 with  
        (when (i = 0) --> 
          d : bool <- read DiagRef[0] ; return d
        )
        ;;
        (when (not (i = 0)) -->
           bs : bool <- read RowCol[i - 1] ;
           bi : bool <- read DiagRef[i] ;
           return xor((bs, bi))
        )
 in currentProtocol (
in the presence of  
   fam DiagRef[bound Z] ,
   fam Row[bound (N + 2) bound (N + 2)] ,
   fam Col[bound (N + 2) bound (N + 2)] 
  rewrite family RowCol[bound Z]
  to bc : bool <- read Col[Z, i] ;
     br : bool <- read Row[i, Z] ;
     return xor((br, bc))
  by induction on i bound M 
     ( case distinction on 
       channel RowCol[M]
     (
       case:(
        subst fam DiagRef[bound Z] 
         into chn RowCol[M] then
       sym from 
        change chn RowCol[M]
        with
         br : bool  <- read Row[M, Z] ;
         bc : bool  <- read Col[Z, M] ;
         return xor((br, bc))
        in currentProtocol
       ( subst branch when (i = 0) of fam Row[bound (N + 2) bound (N + 2)]
           into chn RowCol[M] then 
         rename c to b in chn RowCol[M] then
            subst branch when (j = 0) of fam Col[bound (N + 2) bound (N + 2)]
             into chn RowCol[M] then
         rename c to sb in chn RowCol[M] 
      )       
       )
       case:(
        subst fam RowCol[bound M]
         into chn RowCol[M] then
        subst fam DiagRef[bound Z] 
         into chn RowCol[M] then
        use expression assumption rearrange-xor
          on chn RowCol[M] at 1 then        
        sym from 
        change chn RowCol[M]
        with
         br : bool  <- read Row[M, Z] ;
         bc : bool  <- read Col[Z, M] ;
         return xor((br, bc))
        in currentProtocol
     ( subst branch when (not (i = 0)) of fam Row[bound (N + 2) bound (N + 2)]
           into chn RowCol[M] then    
       rename r to br, bi to b
        in chn RowCol[M] then
            subst branch when (not (j = 0)) of fam Col[bound (N + 2) bound (N + 2)]
             into chn RowCol[M] then 
       rename bs to bc, bj to sb in chn RowCol[M]
      )  
       )
     ) then
     merge cases for chn RowCol[M]     
    )
 ) then
subst  branch when (n < m) of fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
  into fam DiagRef[bound Z] then 
 subst branch when (m < n)  of fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
  into fam DiagRef[bound Z] then
subst fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B]
 into fam DiagRef[bound Z] then
use expression assumption xor-comm
          on fam DiagRef[bound Z] at 1 then
use expression assumption xor-idem-3
          on fam DiagRef[bound Z] at 1 then
drop read branch when (n < m) of fam SendBit[bound (N + 2) bound (N + 2) fixedBound B] 
       from fam DiagRef[bound Z] then
in the presence of
  fam DiagRef[bound Z] ,
  fam Shares[bound B]
 rewrite family RowCol[bound Z] 
 to  
  xs : bool <- read ShareSum[i, wire0(B)] ;
  ys : bool <- read ShareSum[i, wire1(B)] ;
  xn : bool <- read Share[Z, wire0(B)] ;
  yn : bool <- read Share[Z, wire1(B)] ;
  return xor( ( **((xs, yn)), **((xn, ys))  ) )
 by induction on i bound M 
(
case distinction on channel RowCol[M] (
case:(
subst fam DiagRef[bound Z]
        into chn RowCol[M] then
sym from
       change chn RowCol[M]
       with 
  xs : bool <- read ShareSum[M, wire0(B)] ;
  ys : bool <- read ShareSum[M, wire1(B)] ;
  xn : bool <- read Share[Z, wire0(B)] ;
  yn : bool <- read Share[Z, wire1(B)] ;
  return xor( (**((xs, yn)),  **((xn, ys)) ) )
 in currentProtocol
(
remove and merge fam ShareSum[bound (N + 1) bound B] 
      from group Shares[bound B] then
    subst branch when (m = 0) of fam ShareSum[bound (N + 1) bound B]   
     into chn RowCol[M] then
    rename s to xs in chn RowCol[M] then 
    subst branch when (m = 0) of fam ShareSum[bound (N + 1) bound B]   
     into chn RowCol[M] then
    rename s to ys, xs to xm, ys to ym
      in chn RowCol[M] then 
    move family ShareSum[bound (N + 1) bound B]   
     on each branch of group Shares[bound B]     
))

case:(
      subst fam DiagRef[bound Z]
        into chn RowCol[M] then
      rename xm to xi, ym to yi in chn RowCol[M] then
      subst fam RowCol[bound M]
        into chn RowCol[M] then
      use expression assumption rearrange-xor
          on chn RowCol[M] at 1 then        
      use expression assumption derived-xor-and-rule
          on chn RowCol[M] at 1 then       
       sym from
       change chn RowCol[M]
       with 
  xs : bool <- read ShareSum[M, wire0(B)] ;
  ys : bool <- read ShareSum[M, wire1(B)] ;
  xn : bool <- read Share[Z, wire0(B)] ;
  yn : bool <- read Share[Z, wire1(B)] ;
  return xor( ( **((xs, yn)), **((xn, ys))  ) )
 in currentProtocol
       (
       remove and merge fam ShareSum[bound (N + 1) bound B]
        from group Shares[bound B] then
       subst branch when (not (m = 0)) of fam ShareSum[bound (N + 1) bound B] 
        into chn RowCol[M] then  
      rename xs to as, xm to am 
       in chn RowCol[M] then
      subst branch when (not (m = 0)) of fam ShareSum[bound (N + 1) bound B] 
        into chn RowCol[M] then  
      rename xs to ys, xm to yi, as to xs, am to xi 
       in chn RowCol[M] then 
      move family ShareSum[bound (N + 1) bound B] 
       on each branch of group Shares[bound B]
     )               
     )
) then
merge cases for chn RowCol[M]
) then
absorb fam DiagRef[bound Z] then
subst fam Sqr[bound Z] into chn Sqr[Z] then
        subst fam RowCol[bound Z] into chn Sqr[Z] then
        subst branch when (m = n) of fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
           into chn Sqr[Z] then
        rename x to xn, y to yn
         in chn Sqr[Z] then
        absorb fam RowCol[bound Z] then
        use expression assumption derived-xor-rule
          on chn Sqr[Z] at 1 then
sym from
       change chn Sqr[Z]
       with
        x : bool <- read ShareSum[Z, wire0(B)] ;
        y : bool <- read ShareSum[Z, wire1(B)] ;        
        return **((x, y)) 
       in currentProtocol
       (
         remove and merge fam ShareSum[bound (N + 1) bound B]
          from group Shares[bound B] then
         subst branch when (not (m = 0)) of fam ShareSum[bound (N + 1) bound B]
           into chn Sqr[Z] then
         rename xs to as, xm to am
          in chn Sqr[Z] then
         subst branch when (not (m = 0)) of fam ShareSum[bound (N + 1) bound B]
           into chn Sqr[Z] then 
        rename xs to ys, xm to yn, as to xs, am to xn
         in chn Sqr[Z] then
        use expression assumption distrib-twice
          on chn Sqr[Z] at 1 then
        move family ShareSum[bound (N + 1) bound B]
         on each branch of group Shares[bound B]   
       ) then
        rename x to xs, y to ys in chn Sqr[Z]          
 )
) then
 sym from 
       change 
       chn Sqr[Z]
       with 
        xs : bool <- read ShareSum[Z, wire0(B)] ;
        ys : bool <- read ShareSum[Z, wire1(B)] ;
        return **((xs, ys)) 
       in currentProtocol
 (
      sym from
         change 
       chn Sqr[Z]
       with 
       (when (Z = 0) --> 
        xs : bool <- read ShareSum[Z, wire0(B)] ;
        ys : bool <- read ShareSum[Z, wire1(B)] ;
        return **((xs, ys))  
       ) ;;
       (when (not (Z = 0)) --> 
        xs : bool <- read ShareSum[Z, wire0(B)] ;
        ys : bool <- read ShareSum[Z, wire1(B)] ;
        return **((xs, ys))  
       )
        in currentProtocol
        (merge cases for chn Sqr[Z]
        ) then
        case distinction on channel Sqr[Z]
        (
          case: (
            use assumptions for Z in chn Sqr[Z]
          )
          case: (idle)
        )
 )
) then
absorb fam Col[bound (N + 2) bound (N + 2)] then
absorb fam Row[bound (N + 2) bound (N + 2)] then
subst fam Sqr[bound (N + 2)] 
 into chn ShareSum[N + 1, B] then
 rename xs to x, ys to y
 in chn ShareSum[N + 1, B] then
absorb fam Sqr[bound (N + 2)] 
)
  )

) then
turn neg into otherwise
 for fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I] then
turn neg into otherwise
 for fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]
)  
) then
`` up to here is 4gwmn.ipdl, checked with check-proof pInt3
call addWire then
compose fam Shares[bound K] with fam Wire[bound K] in group then
sym from 
             change fam Shares[bound K] and Wire[bound K]
             with 
              (
                ( family Shares[bound K] 
 indices: k 
 bounds: bound K ::= 
 (
     (when  isInputGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <-  read InShare[n, wire0(k), wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
 )
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 w : bool <- read Wire[k] ; return w
)
))
;;
(when  isNotGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <-  read Share[n, wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
    xs : bool <-  read ShareSum[N, k] ; 
    return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
 )
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 w : bool <- read Wire[k] ; return w
)
))
;;
(when  isXorGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 w : bool <- read Wire[k] ; return w
)
))
;;
(when  isAndGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <-  read SendBit[n, m, k] ; return s
)
;;
(when (m = n) -->
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
 return **((x, y))
)
;;
(when (m < n) -->
 r : bool <-  read RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (m = 0) -->
 b : bool <-  read Ctrb[n, 0, k] ; return b
)
;;
(when not (m = 0) -->
 b : bool <-  read Ctrb[n, m, k] ; 
 s : bool <-  read CtrbSum[n, m - 1, k] ; 
 return xor((s, b))
)
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read SendBit[m, n, k] ; 
 xm : bool <-  read Share[m, wire0(k)] ; 
 xn : bool <-  read Share[n, wire0(k)] ; 
 ym : bool <-  read Share[m, wire1(k)] ; 
 yn : bool <-  read Share[n, wire1(k)] ; 
 return xor( ( xor(( **((xm, yn)), **((xn, ym))  )) , b) )
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
    samp flip (()) 
)
;;
(when (m <= n) -->
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <-  read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
    xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))   
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 w : bool <- read Wire[k] ; return w
)
))    
     ) 
)
||
(
family Wire[bound K] 
 indices: k
 bounds: bound K ::=
 (when isInputGate(k) -->  
   i : bool <- read In[wire0(k), wire1(k)] ; return i
 ) ;;
 (when isNotGate(k) --> 
   x : bool <- read Wire[wire0(k)] ; return neg(x)
 ) ;;
 (when isXorGate(k) --> 
   x : bool <- read Wire[wire0(k)] ;
   y : bool <- read Wire[wire1(k)] ;
   return xor((x, y))
 ) ;;
 (when isAndGate(k) --> 
   x : bool <- read Wire[wire0(k)] ;
   y : bool <- read Wire[wire1(k)] ;
   return **((x, y)) 
 ) 
)
              )
             in currentProtocol
(
 in the presence of
  fam InShare[bound N + 2 bound N + 2 dependentBound I]
 rewrite group Shares[bound K] and Wire[bound K]
 to (
    ( family Shares[bound K] 
 indices: k 
 bounds: bound K ::= 
 (
     (when  isInputGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <-  read InShare[n, wire0(k), wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
 )
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 i : bool <-  read In[wire0(k), wire1(k)] ; 
    return i
)
))
;;
(when  isNotGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <-  read Share[n, wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
    xs : bool <-  read ShareSum[N, k] ; 
    return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
 )
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, wire0(k)] ;
    return neg(x)
)
))
;;
(when  isXorGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, wire0(k)] ; 
 y : bool <-  read ShareSum[N + 1, wire1(k)] ; 
 return xor((x, y))
)
))
;;
(when  isAndGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <-  read SendBit[n, m, k] ; return s
)
;;
(when (m = n) -->
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
 return **((x, y))
)
;;
(when (m < n) -->
 r : bool <-  read RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (m = 0) -->
 b : bool <-  read Ctrb[n, 0, k] ; return b
)
;;
(when not (m = 0) -->
 b : bool <-  read Ctrb[n, m, k] ; 
 s : bool <-  read CtrbSum[n, m - 1, k] ; 
 return xor((s, b))
)
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read SendBit[m, n, k] ; 
 xm : bool <-  read Share[m, wire0(k)] ; 
 xn : bool <-  read Share[n, wire0(k)] ; 
 ym : bool <-  read Share[m, wire1(k)] ; 
 yn : bool <-  read Share[n, wire1(k)] ; 
 return xor( ( xor(( **((xm, yn)), **((xn, ym))  )) , b) )
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
    samp flip (()) 
)
;;
(when (m <= n) -->
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <-  read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
    xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))   
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, wire0(k)] ; 
 y : bool <-  read ShareSum[N + 1, wire1(k)] ; 
 return **((x, y))
)
))    
     ) 
)
||
(
family Wire[bound K] 
 indices: k
 bounds: bound K ::=
  s : bool <- read ShareSum[N + 1, k] ; return s
)
 )
  by induction on k bound B (
    remove chn ShareSum[N + 1, B] 
        from group Shares[fixedBound B] then
    merge case for chn Wire[B] and chn ShareSum[N + 1, B]
         into group CGroup then
    case distinction on group CGroup[bound 1](
        case: (
         subst chn Wire[B] into chn ShareSum[N + 1, B] then 
         call symInputWS
        )
        case: (
         subst chn Wire[B] into chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn Wire[B] then
         call symInputWS then
         rename s to x in chn ShareSum[N + 1, B] 
        )
        case: (
         subst chn Wire[B] into chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn ShareSum[N + 1, B] at x then
         rename s to x in chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn ShareSum[N + 1, B] then
         rename s to y in chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn Wire[B] then
         rename s to x in chn Wire[B] then
         subst fam Wire[bound B] into chn Wire[B] then
         rename s to y in chn Wire[B] then
         call symInputWS 
        )
        case: (
        subst chn Wire[B] into chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn ShareSum[N + 1, B] then
         rename s to x in chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn ShareSum[N + 1, B] then
         rename s to y in chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn Wire[B] then
         rename s to x in chn Wire[B] then
         subst fam Wire[bound B] into chn Wire[B] then
         rename s to y in chn Wire[B] then
         call symInputWS
        )
       ) then
       combine fam CGroup[bound 1] then
       merge cases for chn Wire[B] then
       move channel ShareSum[N + 1, B] on each branch of group Shares[fixedBound B]    
    )   
) then
decompose fam Shares[bound K] with fam Wire[bound K] then
remove and merge fam ShareSum[fixedBound N + 1 bound K]
 from group Shares[bound K] then
call addWiresGroup then
split fam InShare$PartyAdv[bound (N + 2) bound (N + 2) dependentBound I] on first index then
on branch isSemiHonest(n) of 
 family InShare$PartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] (
   subst fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]
    into fam InShare$PartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I]
 ) then
split fam SendInSharePartyAdv[bound (N + 2) bound (N + 2) dependentBound I] 
 on first index then
on branch isSemiHonest(n) of family 
 SendInSharePartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] (
  subst fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]
   into fam SendInSharePartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] 
) then
split fam InShare [bound (N + 2) bound (N + 2) dependentBound I] 
 on first index then
subst fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]
 into fam InShare[fixedBound (N + 1) bound (N + 2) dependentBound I] then
split fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] on 
 first index then
absorb fam InShare$[fixedBound (N + 1) bound (N + 2) dependentBound I] then
absorb fam InShare[fixedBound (N + 1) bound (N + 2) dependentBound I] then
remove fam RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 from group Shares[bound K] then
 split fam RcvdBit[bound (N + 2) bound (N + 2) bound K]  
  on second index then
move family  RcvdBit[bound (N + 2) bound (N + 1) bound K] 
 on each branch of group Shares[bound K] then
move family RcvdBit[bound (N + 2) fixedBound (N + 1) bound K] 
 on each branch of group Shares[bound K] then
on branch isAndGate(k) of group Shares[bound K] (
  diverge on fam RcvdBit[bound (N + 2) fixedBound (N + 1) bound K]  
   with branch m <= n of fam SendBit[bound (N + 2) bound (N + 2) bound K] 
    var r
  ) then
on all branches of fam Shares[bound K] 
 split fam SendBit[bound (N + 2) bound (N + 2) bound K] on first index then
on all branches of fam Shares[bound K] 
 split fam RcvdBit[bound (N + 2) bound (N + 1) bound K] 
    on first index then
on all branches of fam Shares[bound K]
 split fam RcvdBit[bound (N + 2) fixedBound (N + 1) bound K] 
     on first index then
on all branches of fam Shares[bound K]
 split fam CtrbSum[bound (N + 2) bound (N + 2) bound K] 
     on first index then
on all branches of fam Shares[bound K]
 split fam Ctrb[bound (N + 2) bound (N + 2) bound K] 
    on first index then
 extract  
  fam Ctrb[fixedBound (N + 1) bound (N + 2) bound K],
  fam CtrbSum[fixedBound (N + 1) bound (N + 2) bound K],
  fam SendBit[fixedBound (N + 1) bound (N + 2) bound K],
  fam RcvdBit[fixedBound (N + 1) bound (N + 1) bound K],
  fam RcvdBit[fixedBound (N + 1) fixedBound (N + 1) bound K]
 from group Shares[bound K]
 into group Ctrbs then
 group-absorb group Ctrbs[bound K] then
 split fam RcvdOutSharePartyAdv[bound N + 2 bound N + 2 bound K]
 on second index then
split fam OutSharePartyAdv[bound N + 2 bound N + 2 bound K]
 on second index then
 remove and merge fam Share[fixedBound N + 1 bound K] 
 from group Shares[bound K] then
 on branch (isSemiHonest(n) and isOutputWire(k))
 of family RcvdOutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] (
  subst fam Share[fixedBound N + 1 bound K] 
   into fam RcvdOutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] 
) then
on branch (isSemiHonest(n) and isOutputWire(k))
 of family OutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] (
  subst fam Share[fixedBound N + 1 bound K] 
   into fam OutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] 
) then
absorb fam Share[fixedBound N + 1 bound K] then
on branch (isSemiHonest(n) and isOutputWire(k))
 of family RcvdOutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] (
  subst fam ShareSum[fixedBound N + 1 bound K] 
   into fam RcvdOutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] 
) then
on branch (isSemiHonest(n) and isOutputWire(k))
 of family OutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] (
  subst fam ShareSum[fixedBound N + 1 bound K] 
   into fam OutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] 
) then
split fam OutShareSumPartyAdv[bound (N + 2) bound (N + 2) bound K]
 on second index then
on branch (isSemiHonest(n) and isOutputWire(k))
 of family OutShareSumPartyAdv[bound N + 2 fixedBound N + 1 bound K] (
  subst fam ShareSum[fixedBound N + 1 bound K] 
   into fam OutShareSumPartyAdv[bound N + 2 fixedBound N + 1 bound K] 
) then
on branch isOutputWire(k)
 of family Out[bound N + 2 bound K] (
  subst fam ShareSum[fixedBound N + 1 bound K]
   into fam Out[bound N + 2 bound K] 
) then
absorb fam ShareSum[fixedBound N + 1 bound K] then
remove and merge fam ShareSum[bound N + 1 bound K]
 from group Shares[bound K] then
merge case for fam Adv[bound K]
 and fam Shares[bound K] into group Circ then
rename indices to m, n, i in fam InShare[bound N + 1 bound N + 2 dependentBound I ] then 
sym from change 
        fam OutShareSumPartyAdv[bound (N + 2) fixedBound (N + 1) bound K]
        with 
         (when (isSemiHonest(n) and isOutputWire(k)) -->
           out : bool <- read Out[n, k] ; return out
         ) ;;
         (when (isHonest(n) or not isOutputWire(k)) -->
           s : bool <- read OutShareSumPartyAdv[n, N + 1, k] ; return s
         )
        in currentProtocol
       (
       on branch (isSemiHonest(n) and isOutputWire(k))
        of family OutShareSumPartyAdv[bound (N + 2) fixedBound (N + 1) bound K] (
        subst fam Out[bound N + 2 bound K]
         into fam OutShareSumPartyAdv[bound (N + 2) fixedBound (N + 1) bound K] 
       )
       ) then
 sym from change 
        fam OutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K]
        with 
         (when (isSemiHonest(n) and isOutputWire(k)) -->
           out : bool <- read Out[n, k] ;
           xs : bool <- read ShareSum[N, k] ; 
           return xor((xs, out))
         ) ;;
         (when (isHonest(n) or not isOutputWire(k)) -->
           s : bool <- read OutSharePartyAdv[n, N + 1, k] ; return s
         )  
        in currentProtocol
       (
       on branch (isSemiHonest(n) and isOutputWire(k))
         of family OutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K] (
         subst fam Out[bound N + 2 bound K] 
          into fam OutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K]  
       )
       ) then             
sym from change 
        fam RcvdOutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K]
        with 
         (when (isSemiHonest(n) and isOutputWire(k)) -->
           out : bool <- read Out[n, k] ;
           xs : bool <- read  ShareSum[N, k] ;
           return xor((xs, out))
         ) ;;
         (when (isHonest(n) or not isOutputWire(k)) -->
           s : bool <- read RcvdOutSharePartyAdv[n, N + 1, k] ; return s
         )
        in currentProtocol
       (
       on branch (isSemiHonest(n) and isOutputWire(k))
        of family RcvdOutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K] (
         subst fam Out[bound N + 2 bound K]
          into fam RcvdOutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K]
        ) 
       ) then
discard branch m = N + 1 of fam InShare$[bound (N + 1) bound (N + 2) dependentBound I] then
sym from idealPlusSim over deltaIdealPlusSim (
on branch isSemiHonest(n) 
 of family InShare$[bound (N + 1) bound (N + 2) dependentBound I](
   subst fam InIdAdv[bound N + 2 dependentBound I] 
    into fam InShare$[bound (N + 1) bound (N + 2) dependentBound I]
 ) then
 on branch isSemiHonest(n)
  of family InPartyAdv[bound (N + 2) dependentBound I] (
  subst fam InIdAdv[bound N + 2 dependentBound I] 
   into fam InPartyAdv[bound (N + 2) dependentBound I]
  ) then
 on branch isSemiHonest(n)
  of family InShare$PartyAdv[fixedBound N + 1 bound (N + 2) dependentBound I] ( 
  subst fam InIdAdv[bound N + 2 dependentBound I] 
   into fam InShare$PartyAdv[fixedBound N + 1 bound (N + 2) dependentBound I] then
   rename in to x in fam InShare$PartyAdv[fixedBound N + 1 bound (N + 2) dependentBound I]
 ) then
 on branch isSemiHonest(n)
  of family SendInSharePartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] (
   subst fam InIdAdv[bound N + 2 dependentBound I] 
    into fam SendInSharePartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] then
   rename in to x in fam SendInSharePartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] 
 ) then
 on branch isHonest(n) 
  of family InShare$[bound (N + 1) bound (N + 2) dependentBound I] (
   subst fam InRcvdIdAdv[bound (N + 2) dependentBound I]
    into fam InShare$[bound (N + 1) bound (N + 2) dependentBound I]
 ) then
 on branch isHonest(n)
  of family InRcvdPartyAdv[bound (N + 2) dependentBound I] (
   subst fam InRcvdIdAdv[bound (N + 2) dependentBound I]
    into fam InRcvdPartyAdv[bound (N + 2) dependentBound I] then
    rename in to x in fam InRcvdPartyAdv[bound (N + 2) dependentBound I]
 ) then
 on branch isSemiHonest(n)
  of family OutPartyAdv[bound N + 2 bound K] (
  subst fam OutIdAdv[bound N + 2 bound K]
   into fam OutPartyAdv[bound N + 2 bound K] then
  rename out to s in fam OutPartyAdv[bound N + 2 bound K]
 ) then
 on branch (isSemiHonest(n) and isOutputWire(k))
  of family OutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K] (
  subst fam OutIdAdv[bound N + 2 bound K]
   into fam OutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K] 
 ) then
 on branch (isSemiHonest(n) and isOutputWire(k))
  of family OutShareSumPartyAdv[bound (N + 2) fixedBound (N + 1) bound K] (
  subst fam OutIdAdv[bound N + 2 bound K]
   into fam OutShareSumPartyAdv[bound (N + 2) fixedBound (N + 1) bound K]
 ) then
 on branch (isSemiHonest(n) and isOutputWire(k))
  of family RcvdOutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K] (
   subst fam OutIdAdv[bound N + 2 bound K]
    into fam RcvdOutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K]
  ) then 
 on branch isOutputWire(k)
  of family Out [bound (N + 2) bound K] (
  rename out to w in fam Out [bound (N + 2) bound K] 
 ) then
 merge cases for fam InShare$[bound (N + 1) bound (N + 2) dependentBound I] then
 rename in to x in fam InShare$[bound (N + 1) bound (N + 2) dependentBound I] then
 absorb fam OutIdAdv[bound (N + 2) bound K] then
 absorb fam InRcvdIdAdv[bound (N + 2) dependentBound I] then  
 absorb fam InIdAdv[bound (N + 2) dependentBound I] then
 on branch isAndGate(k) of group Circ[bound K] (
 fix index for fam RcvdBit[bound N + 1 fixedBound N + 1 bound K ]
 )
)

check-proof idealPlusSim
show-bounds
quit
