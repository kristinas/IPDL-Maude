lang IPDL

import BASEGMWN .

parameter N : nat .
parameter K : nat .

`` Sigma

function xor : bool * bool -> bool .
function ** : bool * bool  -> bool .
function neg : bool -> bool .
distribution flip : unit -> bool .

`` assumptions

expression-assumption %automatic andFalseLeft using x : 
   (x : bool)  |= 
   **( (False, x) ) = False .

    expression-assumption %automatic andFalseRight using x : 
   (x : bool)  |= 
   **( (x, False) ) = False . 

   expression-assumption %automatic andTrueLeft using x : 
   (x : bool)  |= 
   **( (True, x) ) = x .

    expression-assumption %automatic andTrueRight using x : 
   (x : bool)  |= 
   **( (x, True) ) = x .
   
    expression-assumption %automatic xorFalseLeft using x : 
   (x : bool)  |= 
   xor( (False, x) ) = x .

    expression-assumption %automatic xorFalseRight using x : 
   (x : bool)  |= 
   xor( (x, False) ) = x . 
   
    expression-assumption %automatic xorFalse using x : 
   (x : bool)  |= 
   xor( (x, x) ) = False . 
   
   expression-assumption %automatic falseXor using x : 
   (x : bool)  |= 
   xor( (False, False) ) = False . 

   expression-assumption %manual xor-idem-2 using x, y :
    (x : bool) (y : bool) |=
    xor( (x, xor((y, x ))) ) = y .

    expression-assumption %manual xor-idem-1 using x, y :
    (x : bool) (y : bool) |=
    xor( (x, xor((x, y ))) ) = y .

    expression-assumption %manual xor-idem-3 using x, y :
    (x : bool) (y : bool) |=
    xor( (xor((x, y)), y) ) = x .

    expression-assumption %manual xor-comm using x, y :
    (x : bool) (y : bool) |=
    xor((x, y)) = xor((y, x)) .

    expression-assumption %manual neg-over-xor using x, y : 
    (x : bool) (y : bool) |=
    xor( (x, neg(y)) ) = neg( xor((x, y)) ) .

    expression-assumption %manual rearrange-xor using x1, x2, x3, x4 : 
    (x1 : bool) (x2 : bool)
    (x3 : bool) (x4 : bool) |=
    xor( ( xor((x1, x2)) , xor((x3, x4)) ) ) 
    =
    xor( ( xor((x1, x3)) , xor((x2, x4)) ) )  .

    expression-assumption %manual middle-xor using x1, x2, x3, x4 : 
    (x1 : bool) (x2 : bool)
    (x3 : bool) (x4 : bool) |=
    xor( ( xor((x1, x2)) , xor((x3, x4)) ) ) 
    =
    xor( ( xor( (x1, xor( (x2, x3) ) ) ) , x4 ) ) .

    expression-assumption %manual derived-xor-and-rule using e1, e2, e3, e4, e5, e6 :
    (e1 : bool) (e2 : bool) (e3 : bool)
    (e4 : bool) (e5 : bool) (e6 : bool) |=
    xor( (  xor(( **((e1, e2)) , **((e3, e2)) ))  , 
            xor(( **((e4, e5)) , **((e4, e6)) ))  
       ) )
    =    
    xor((
        **((xor((e1, e3)), e2)) ,
        **((e4, xor((e5, e6)))) 
    )) . 

    expression-assumption %manual derived-xor-rule using e1, e2, e3, e4 :
    (e1 : bool) (e2 : bool) (e3 : bool)
    (e4 : bool) |=
    xor(( xor((e1, xor((e2, e3)) ))  , e4 )) 
    = 
    xor(( xor((e1, e2)) , xor((e3, e4)) )) .

    expression-assumption %manual distrib-twice using e1, e2, e3, e4 :
    (e1 : bool) (e2 : bool) (e3 : bool)
    (e4 : bool) |=
    **(( xor((e1, e2)) , xor((e3, e4)) ))
    =
    xor(
    ( xor((**((e1, e3)) , **((e1, e4))))
        ,
      xor((**((e2, e3)) , **((e2, e4))))  
    )
    )
    .


hypothesis not (isNotGate(0)) .
hypothesis not (isXorGate(0)) .
hypothesis not (isAndGate(0)) .
hypothesis isHonest(N + 1) .

`` deltaRealSplit 

channel context deltaRealSplit =

input    In[bound N + 2 dependentBound I] : bool ;
output   Out[bound N + 2 bound K] : bool ;
output   CtrbPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   InPartyAdv[bound N + 2 dependentBound I] : bool ;
output   InRcvdPartyAdv[bound N + 2 dependentBound I] : unit ;
output   InSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   InShare$PartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   InShare$-SumPartyAdv[bound N + 1 bound N + 2 dependentBound I] : bool ;
output   OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] : unit ;
output   OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] : unit ;
output   OTChcRcvd-0OtAdv[bound N + 2 bound N + 1 bound K] : unit ;
output   OTChcRcvd-1OtAdv[bound N + 2 bound N + 1 bound K] : unit ;
output   OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTOutOtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OutPartyAdv[bound N + 2 bound K] : bool ;
output   OutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OutShareSumPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   RcvdOutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SendBitPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SendInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   SendOutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SharePartyAdv[bound N + 2 bound K] : bool
 .

protocol pInt3 =
 newfamily Ctrb[bound N + 2 bound N + 2 bound K ]
           indices: n, m, k
           bounds: bound N + 2 bound N + 2 bound K : bool in   
 newfamily CtrbSum[bound N + 2 bound N + 2 bound K ]
           indices: n, m, k
           bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily InShare[bound N + 2 bound N + 2 dependentBound I]
           indices: n, m, i
           bounds: bound N + 2 bound N + 2 dependentBound I : bool in
 newfamily InShare$[bound N + 2 bound N + 2 dependentBound I]
           indices: m, n, i
           bounds: bound N + 2 bound N + 2 dependentBound I : bool in
 newfamily InShare$-Sum[bound N + 1 bound N + 2 dependentBound I]
           indices: m, n, i
           bounds: bound N + 1 bound N + 2 dependentBound I : bool in          
 newfamily RcvdBit[bound N + 2 bound N + 2 bound K ]
           indices: n, m, k
           bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily SendBit[bound N + 2 bound N + 2 bound K ]
           indices: n, m, k
           bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily Share[bound N + 1 bound K ]
           indices: n, k
           bounds: bound N + 1 bound K : bool in
 newfamily Share[fixedBound N + 1 bound K ]
           indices: n, k
           bounds: fixedBound N + 1 bound K : bool in
 newfamily ShareSum[bound N + 1 bound K ]
           indices: m, k
           bounds: bound N + 1 bound K : bool in          
 newfamily ShareSum[fixedBound N + 1 bound K ]
           indices: m, k
           bounds: fixedBound N + 1 bound K : bool in (
(family Adv[bound K] 
 indices: k 
 bounds: bound K ::= 
 (when isInputGate(k) --> (
 (family SharePartyAdv[bound N + 2 bound K] 
 indices: n ,k 
 bounds: bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read Share[n ,k ] ; return s 
  )
  ;; 
  (when isHonest(n) -->
    s : bool <- read SharePartyAdv[n ,k] ; return s 
  )
 ) || 
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  sb : bool <- read SendBitPartyAdv[n ,m ,k ] ; return sb 
 ) || 
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  rb : bool <- read RcvdBitPartyAdv[n ,m ,k ] ; return rb 
 ) ||
 (family OTOutOtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  out : bool <- read OTOutOtAdv[n ,m ,k ] ; return out
 ) ||
 (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-3OtAdv[n ,m ,k ] ; return om
 ) || 
 (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-2OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-1OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-0OtAdv[n ,m ,k ] ; return om
 ) || 
 (family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-3OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-2OtAdv[n ,m , k ] ; return om 
 ) || 
 (family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-1OtAdv[n ,m ,k] ; return om 
 ) || 
 (family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-0OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-1OtAdv[n ,N + 1 ,k ] ; return oc 
 ) || 
 (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-1OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::=
  oc : unit <- read OTChcRcvd-0OtAdv[n ,N + 1 ,k ] ; return oc
 ) || 
 (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-0OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  oc : bool <- read OTChc-1OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  oc : bool <- read OTChc-0OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSumPartyAdv[n ,m ,k ] ; return b 
 ) || 
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbPartyAdv[n ,m ,k ] ; return b )
)) ;; 
(when isNotGate(k) --> (
 (family SharePartyAdv[bound N + 2 bound K] 
 indices: n ,k 
 bounds: bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read Share[n ,k ] ; return s 
  )
  ;; 
  (when isHonest(n) -->
    s : bool <- read SharePartyAdv[n ,k] ; return s 
  )
 ) || 
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  sb : bool <- read SendBitPartyAdv[n ,m ,k ] ; return sb 
 ) || 
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  rb : bool <- read RcvdBitPartyAdv[n ,m ,k ] ; return rb 
 ) ||
 (family OTOutOtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  out : bool <- read OTOutOtAdv[n ,m ,k ] ; return out
 ) ||
 (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-3OtAdv[n ,m ,k ] ; return om
 ) || 
 (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-2OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-1OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-0OtAdv[n ,m ,k ] ; return om
 ) || 
 (family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-3OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-2OtAdv[n ,m , k ] ; return om 
 ) || 
 (family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-1OtAdv[n ,m ,k] ; return om 
 ) || 
 (family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-0OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-1OtAdv[n ,N + 1 ,k ] ; return oc 
 ) || 
 (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-1OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::=
  oc : unit <- read OTChcRcvd-0OtAdv[n ,N + 1 ,k ] ; return oc
 ) || 
 (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-0OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  oc : bool <- read OTChc-1OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  oc : bool <- read OTChc-0OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSumPartyAdv[n ,m ,k ] ; return b 
 ) || 
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbPartyAdv[n ,m ,k ] ; return b ) 
 )) ;; 
(when isXorGate(k) --> (
 (family SharePartyAdv[bound N + 2 bound K] 
 indices: n ,k 
 bounds: bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read Share[n ,k ] ; return s 
  )
  ;; 
  (when isHonest(n) -->
    s : bool <- read SharePartyAdv[n ,k] ; return s 
  )
 ) || 
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  sb : bool <- read SendBitPartyAdv[n ,m ,k ] ; return sb 
 ) || 
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  rb : bool <- read RcvdBitPartyAdv[n ,m ,k ] ; return rb 
 ) ||
 (family OTOutOtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  out : bool <- read OTOutOtAdv[n ,m ,k ] ; return out
 ) ||
 (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-3OtAdv[n ,m ,k ] ; return om
 ) || 
 (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-2OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-1OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-0OtAdv[n ,m ,k ] ; return om
 ) || 
 (family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-3OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-2OtAdv[n ,m , k ] ; return om 
 ) || 
 (family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-1OtAdv[n ,m ,k] ; return om 
 ) || 
 (family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-0OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-1OtAdv[n ,N + 1 ,k ] ; return oc 
 ) || 
 (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-1OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::=
  oc : unit <- read OTChcRcvd-0OtAdv[n ,N + 1 ,k ] ; return oc
 ) || 
 (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-0OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  oc : bool <- read OTChc-1OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  oc : bool <- read OTChc-0OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSumPartyAdv[n ,m ,k ] ; return b 
 ) || 
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbPartyAdv[n ,m ,k ] ; return b ) 
)) ;; 
(when isAndGate(k) --> (
 (family SharePartyAdv[bound N + 2 bound K] 
 indices: n, k 
 bounds: bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read Share[n ,k ] ; return s 
  ) ;; 
  (when isHonest(n) -->
    s : bool <- read SharePartyAdv[n ,k ] ; return s 
  )
  ) || 
  (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read SendBit[n ,m ,k ] ; return s 
  ) ;; 
  (when isHonest(n) -->
    s : bool <- read SendBitPartyAdv[n ,m ,k ] ; return s 
  )
  ) || 
  (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read RcvdBit[n ,m ,k ] ; return s
  ) ;; 
  (when isHonest(n) -->
    s : bool <- read RcvdBitPartyAdv[n ,m ,k ] ; return s 
  )
  ) || 
  (family OTOutOtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(m) -->
    out : bool <- read RcvdBit[m ,n ,k ] ; return out 
  ) ;; 
  (when isHonest(m) -->
    out : bool <- read OTOutOtAdv[n ,m ,k ] ; return out 
  )
  ) || 
  (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isHonest(n))) -->
    b : bool <- read SendBit[n ,m ,k ] ;
    x : bool <- read Share[n , wire0(k)] ;
    y : bool <- read Share[n , wire1(k)] ; 
    return ()
  ) ;; 
  (when ((m <= n) or (isSemiHonest(n))) -->
    om : unit <- read OTMsgRcvd-3OtAdv[n ,m ,k ] ; return om 
  )
  ) ||
  (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isHonest(n) )) -->
    b : bool <- read SendBit[n ,m ,k ] ;
    x : bool <- read Share[n , wire0(k)] ; 
    y : bool <- read Share[n , wire1(k)] ; 
    return ()
  ) ;; 
  (when ((m <= n) or (isSemiHonest(n))) -->
    om : unit <- read OTMsgRcvd-2OtAdv[n ,m ,k ] ; return om
  )
  ) || 
  (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isHonest(n))) -->
    b : bool <- read SendBit[n ,m ,k ] ;
    x : bool <- read Share[n , wire0(k)] ;
    y : bool <- read Share[n , wire1(k)] ; 
    return ()
  ) ;; 
  (when ((m <= n) or (isSemiHonest(n))) -->
    om : unit <- read OTMsgRcvd-1OtAdv[n ,m ,k ] ; return om
  )
  ) || 
  (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
   (when ((n < m) and (isHonest(n))) -->
     b : bool <- read SendBit[n ,m ,k ] ;
     x : bool <- read Share[n , wire0(k)] ;
     y : bool <- read Share[n , wire1(k)] ; 
     return ()
   ) ;;
   (when ((m <= n) or (isSemiHonest(n))) -->
     om : unit <- read OTMsgRcvd-0OtAdv[n ,m ,k ] ; return om
   )
   ) ||
   (family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isSemiHonest(n))) -->
     b : bool <- read SendBit[n ,m ,k ] ;
     x : bool <- read Share[n , wire0(k)] ;
     y : bool <- read Share[n , wire1(k)] ; 
     return xor((xor((x ,y )), b))
  ) ;; 
  (when ((m <= n) or (isHonest(n))) -->
    om : bool <- read OTMsg-3OtAdv[n ,m ,k ] ; return om
  )
  ) || 
  (family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isSemiHonest(n))) -->
    b : bool <- read SendBit[n ,m ,k ] ;
    x : bool <- read Share[n, wire0(k)] ;
    y : bool <- read Share[n, wire1(k)] ; 
    return xor((y ,b ))
   ) ;; 
   (when ((m <= n) or (isHonest(n))) -->
     om : bool <- read OTMsg-2OtAdv[n ,m ,k ] ; return om 
   )
   ) || 
   (family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isSemiHonest(n))) -->
    b : bool <- read SendBit[n ,m, k] ;
    x : bool <- read Share[n , wire0(k)] ;
    y : bool <- read Share[n , wire1(k)] ; 
    return xor((x ,b ))
  ) ;; 
  (when ((m <= n) or (isHonest(n))) -->
    om : bool <- read OTMsg-1OtAdv[n, m ,k ] ; return om 
  )
  ) || 
  (family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isSemiHonest(n))) -->
    b : bool <- read SendBit[n ,m ,k ] ;
    x : bool <- read Share[n , wire0(k)] ;
    y : bool <- read Share[n , wire1(k)] ; 
    return b
  ) ;; 
  (when ((m <= n) or (isHonest(n))) -->
    om : bool <- read OTMsg-0OtAdv[n ,m ,k ] ; return om
  )
  ) || 
  (family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::= 
  (when n < N + 1 --> 
     x : bool <- read ShareSum[N , wire1(k)] ; return ()
  ) ;; 
  (when n = N + 1 --> 
   oc : unit <- read OTChcRcvd-1OtAdv[n ,N + 1 ,k ] ; return oc
  )
  ) || 
  (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  (when ((n < m) and (isHonest(m))) -->
    x : bool <- read Share[m , wire1(k)] ; 
    return ()
  ) ;; 
  (when ((m <= n) or (isSemiHonest(m))) -->
   oc : unit <- read OTChcRcvd-1OtAdv[n ,m ,k ] ; return oc
  )
  ) || 
  (family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::= 
  (when n < N + 1 --> 
     x : bool <- read ShareSum[N , wire0(k)] ; return ()
  ) ;; 
  (when n = N + 1 --> 
    oc : unit <- read OTChcRcvd-0OtAdv[n ,N + 1 ,k ] ; return oc
  )
  ) || 
  (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  (when ((n < m) and (isHonest(m)))  -->
    x : bool <- read Share[m , wire0(k)] ; 
    return ()
  ) ;; 
  (when ((m <= n) or (isSemiHonest(m))) -->
    oc : unit <- read OTChcRcvd-0OtAdv[n ,m ,k ] ; return oc
  )
  ) ||
  (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isSemiHonest(m))) -->
    x : bool <- read Share[m , wire1(k)] ; 
    return x 
  ) ;; 
  (when ((m <= n) or (isHonest(m))) -->
    oc : bool <- read OTChc-1OtAdv[n , m, k ] ; return oc
  )
  ) || 
(family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isSemiHonest(m))) -->
    x : bool <- read Share[m ,wire0(k)] ; return x 
  )
  ;; 
  (when ((m <= n) or (isHonest(m))) -->
    oc : bool <- read OTChc-0OtAdv[n ,m ,k ] ; return oc 
  )
)
||  
(family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read CtrbSum[n ,m ,k ] ; return s 
  ) 
  ;; 
  (when isHonest(n) -->
    s : bool <- read CtrbSumPartyAdv[n ,m ,k ] ; return s 
  )
) || 
( family CtrbPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read Ctrb[n ,m ,k ] ; return s
  )
  ;; 
  (when isHonest(n) -->
    s : bool <- read CtrbPartyAdv[n ,m ,k ] ; return s 
  )
) 
))
)
 ||
(family InPartyAdv[bound N + 2 dependentBound I] 
 indices: n ,i 
 bounds: bound N + 2 dependentBound I ::= 
  (when isSemiHonest(n) -->
    in : bool <- read In[n ,i ] ; return in 
  )
  ;; 
  (when isHonest(n) -->
    in : bool <- read InPartyAdv[n ,i ] ; return in 
  )
) ||
(family InRcvdPartyAdv[bound N + 2 dependentBound I] 
 indices: n ,i 
 bounds: bound N + 2 dependentBound I ::= 
  (when isHonest(n) -->
    x : bool <- read In[n ,i ] ; return ()
  )
  ;; 
  (when isSemiHonest(n) -->
    in : unit <- read InRcvdPartyAdv[n ,i ] ; return in 
  )
) ||
(family InShare[bound N + 2 bound N + 2 dependentBound I] 
 indices: n ,m ,i 
 bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  in : bool <- read InShare$[n ,m ,i ] ; return in 
) ||
(family InShare$[bound N + 2 bound N + 2 dependentBound I] 
 indices: m ,n ,i 
 bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when m = N + 1 --> 
    s : bool <- read InShare$-Sum[N ,n ,i ] ;
    x : bool <- read In[n ,i ] ; 
    return xor((x ,s ))
  )
   ;; 
  (otherwise --> 
    x : bool <- read In[n ,i ] ; samp flip (())
  )
) ||
(family InShare$-Sum[bound N + 1 bound N + 2 dependentBound I] 
 indices: m ,n ,i 
 bounds: bound N + 1 bound N + 2 dependentBound I ::= 
  (when 0 = m --> 
    in : bool <- read InShare$[0, n ,i ] ; return in 
  )
  ;; 
  (otherwise --> 
    s : bool <- read InShare$-Sum[m - 1 ,n ,i ] ; 
    x : bool <- read InShare$[m ,n ,i ] ; 
    return xor((s ,x ))
  )
) ||
(family InShare$-SumPartyAdv[bound N + 1 bound N + 2 dependentBound I] 
 indices: m ,n ,i 
 bounds: bound N + 1 bound N + 2 dependentBound I ::= 
  (when isSemiHonest(n) -->
    s : bool <- read InShare$-Sum[m ,n ,i ] ; return s
  )
  ;; 
  (when isHonest(n) -->
    s : bool <- read InShare$-SumPartyAdv[m ,n ,i ] ; return s 
  )
) ||
(family InShare$PartyAdv[bound N + 2 bound N + 2 dependentBound I] 
 indices: m ,n ,i 
 bounds: bound N + 2 bound N + 2 dependentBound I ::= 
 (when isSemiHonest(n) --> 
   in : bool <- read InShare$[m ,n ,i ] ; return in 
 ) 
 ;; 
 (when isHonest(n) --> 
   in : bool <- read InShare$PartyAdv[m ,n ,i ] ; return in 
 )
) ||
(family InSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] 
 indices: n ,m ,i 
 bounds: bound N + 2 bound N + 2 dependentBound I ::= 
 (when isSemiHonest(n) -->
 
   s : bool <- read InShare[n ,m ,i ] ; return s 
 ) 
 ;; 
 (when isHonest(n ) -->
 
   s : bool <- read InSharePartyAdv[n ,m ,i ] ; return s 
 )
) ||
(family Out[bound N + 2 bound K ]
  indices: n ,k 
  bounds: bound N + 2 bound K ::= 
   (when isOutputWire(k) --> 
     s : bool <- read ShareSum[N + 1 ,k ] ; return s
   ) ;; 
   (when not isOutputWire(k) --> 
     o : bool <- read Out[n ,k ] ; return o 
   )
) ||
(family OutPartyAdv[bound N + 2 bound K] 
 indices: n ,k 
 bounds: bound N + 2 bound K ::= 
  (when isSemiHonest(n) --> 
    s : bool <- read Out[n ,k ] ; return s 
  ) 
  ;; 
  (when isHonest(n) -->
    s : bool <- read OutPartyAdv[n ,k ] ; return s 
  )
) ||
(family OutSharePartyAdv[bound N + 2 bound N + 2 bound K ]
  indices: n ,m ,k 
  bounds: bound N + 2 bound N + 2 bound K ::= 
   (when (isSemiHonest(n) and isOutputWire(k)) --> 
     s : bool <- read Share[m ,k ] ; return s 
   ) ;; 
   (when (isHonest(n) or not isOutputWire(k)) --> 
     s : bool <- read OutSharePartyAdv[n ,m ,k ] ; return s 
   )
) ||
(family OutShareSumPartyAdv[bound N + 2 bound N + 2 bound K ]
  indices: n ,m ,k 
  bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (isSemiHonest(n) and isOutputWire(k)) --> 
    s : bool <- read ShareSum[m ,k ] ; return s
  ) ;; 
  (when (isHonest(n) or not isOutputWire(k)) --> 
    s : bool <- read OutShareSumPartyAdv[n ,m ,k ] ; return s 
  )
) ||
(family RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] 
 indices: n ,m ,i 
 bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when isSemiHonest(n) --> 
    in : bool <- read InShare$[n ,m ,i ] ; return in
  ) 
  ;; 
  (when isHonest(n) --> 
    s : bool <- read RcvdInSharePartyAdv[n ,m ,i ] ; return s 
  )
) ||
(family RcvdOutSharePartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(n) and isOutputWire(k) --> 
    s : bool <- read Share[m, k] ; return s 
  )
  ;; 
  (when isHonest(n) or not isOutputWire(k) --> 
    s : bool <- read RcvdOutSharePartyAdv[n ,m ,k ] ; return s 
  )
) ||
(family SendInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] 
 indices: m ,n ,i 
 bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when isSemiHonest(n) --> 
    in : bool <- read InShare$[m ,n ,i ] ; return in
  )
  ;; 
  (when isHonest(n) --> 
    s : bool <- read SendInSharePartyAdv[m ,n ,i ] ; return s 
  )
) ||
(family SendOutSharePartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: m ,n ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(n) and isOutputWire(k) --> 
    s : bool <- read Share[n ,k ] ; 
    return s
  ) 
  ;; 
  (when isHonest(n) or not isOutputWire(k) -->
    s : bool <- read SendOutSharePartyAdv[m ,n ,k ]  ; return s 
  )
) ||
( family Shares[bound K] 
 indices: k 
 bounds: bound K ::= 
 (
     (when  isInputGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <-  read InShare[n, wire0(k), wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
 )
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 i : bool <-  read In[wire0(k), wire1(k)] ; 
    return i
)
))
;;
(when  isNotGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <-  read Share[n, wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
    xs : bool <-  read ShareSum[N, k] ; 
    return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
 )
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, wire0(k)] ;
    return neg(x)
)
))
;;
(when  isXorGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, wire0(k)] ; 
 y : bool <-  read ShareSum[N + 1, wire1(k)] ; 
 return xor((x, y))
)
))
;;
(when  isAndGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <-  read SendBit[n, m, k] ; return s
)
;;
(when (m = n) -->
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
 return **((x, y))
)
;;
(when (m < n) -->
 r : bool <-  read RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (m = 0) -->
 b : bool <-  read Ctrb[n, 0, k] ; return b
)
;;
(when not (m = 0) -->
 b : bool <-  read Ctrb[n, m, k] ; 
 s : bool <-  read CtrbSum[n, m - 1, k] ; 
 return xor((s, b))
)
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read SendBit[m, n, k] ; 
 xm : bool <-  read Share[m, wire0(k)] ; 
 xn : bool <-  read Share[n, wire0(k)] ; 
 ym : bool <-  read Share[m, wire1(k)] ; 
 yn : bool <-  read Share[n, wire1(k)] ; 
 return xor( ( xor(( **((xm, yn)), **((xn, ym))  )) , b) )
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
    samp flip (()) 
)
;;
(when (m <= n) -->
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <-  read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
    xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))   
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, wire0(k)] ; 
 y : bool <-  read ShareSum[N + 1, wire1(k)] ; 
 return **((x, y))
)
))    
     ) 
)
)
 . 
`` idealPlusSim goes here

channel context deltaIdealPlusSim = 
   input In[bound N + 2 dependentBound I] : bool ;
   
   output Out[bound N + 2 bound K] : bool ;
  
   output InPartyAdv[bound N + 2 dependentBound I] : bool ;
   output InRcvdPartyAdv[bound N + 2 dependentBound I] : unit ;
   output InSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
   output InShare$PartyAdv[bound N + 1 bound N + 2 dependentBound I] : bool ;
   output InShare$PartyAdv[bound N + 1 bound N + 2 dependentBound I] : bool ;
   output InShare$PartyAdv[fixedBound N + 1 bound N + 2 dependentBound I] : bool ;
   output InShare$-SumPartyAdv[bound N + 1 bound N + 2 dependentBound I] : bool ;
   output RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
   output SendInSharePartyAdv[bound N + 1 bound N + 2 dependentBound I] : bool ;
   output SendInSharePartyAdv[fixedBound N + 1 bound N + 2 dependentBound I] : bool ;
    
    output SendOutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
    output RcvdOutSharePartyAdv[bound N + 2 bound N + 1 bound K] : bool ;
    output RcvdOutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] : bool ;
    output OutSharePartyAdv[bound N + 2 bound N + 1 bound K] : bool ;
    output OutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] : bool ;
    output OutShareSumPartyAdv[bound N + 2 bound N + 1 bound K] : bool ;
    output OutShareSumPartyAdv[bound N + 2 fixedBound N + 1 bound K] : bool ;
    output OutPartyAdv[bound N + 2 bound K] : bool ; 
    output CtrbPartyAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output CtrbSumPartyAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output OTChc-0OtAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output OTChc-1OtAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output OTChcRcvd-0OtAdv[bound (N + 2) bound (N + 1) bound K] : unit ;
    output OTChcRcvd-1OtAdv[bound (N + 2) bound (N + 1) bound K] : unit ;
    output OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K] : unit ;
    output OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K] : unit ; 
    output OTOutOtAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output RcvdBitPartyAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output SendBitPartyAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output SharePartyAdv[bound (N + 2) bound K] : bool ;
    output OTMsgRcvd-0OtAdv[bound (N + 2) bound (N + 2) bound K] : unit ;
    output OTMsgRcvd-1OtAdv[bound (N + 2) bound (N + 2) bound K] : unit ;
    output OTMsgRcvd-2OtAdv[bound (N + 2) bound (N + 2) bound K] : unit ;
    output OTMsgRcvd-3OtAdv[bound (N + 2) bound (N + 2) bound K] : unit ;
    output OTMsg-0OtAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output OTMsg-1OtAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output OTMsg-2OtAdv[bound (N + 2) bound (N + 2) bound K] : bool ;
    output OTMsg-3OtAdv[bound (N + 2) bound (N + 2) bound K] : bool
. 

protocol idealPlusSim = 
    newfamily InIdAdv[bound N + 2 dependentBound I] 
      indices: n, i 
      bounds: bound N + 2 dependentBound I : bool in
    newfamily InRcvdIdAdv[bound N + 2 dependentBound I] 
      indices: n, i
      bounds: bound N + 2 dependentBound I : unit in
    newfamily OutIdAdv[bound N + 2 bound K] 
      indices: n, k
      bounds: bound N + 2 bound K : bool in  
  ideal || sim  
  where ideal = ( newfamily Wire[bound K] indices: k bounds: bound K : bool in
   (
     (family InIdAdv[bound N + 2 dependentBound I] 
       indices: n, i 
       bounds: bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
          in : bool <- read In[n, i] ; return in
       )
       ;;
       (when (isHonest(n)) --> 
          in : bool <- read InIdAdv[n, i] ; return in
       )
     ) 
     ||
     (family InRcvdIdAdv[bound N + 2 dependentBound I] 
        indices: n, i 
        bounds: bound N + 2 dependentBound I ::=
       (when (isHonest(n)) --> 
          in : bool <- read In[n, i] ; return ()
       )
       ;;
       (when (isSemiHonest(n)) --> 
          in : unit <- read InRcvdIdAdv[n, i] ; 
            return in
       )
     ) 
  ) 
  ||
  (
     family Wires[bound K] indices: k bounds: bound K ::= 
       (
        family Wire[bound K]  indices: k bounds: bound K ::= 
         (when (isInputGate(k)) --> 
             i : bool <- read In[wire0(k) , wire1(k)] ; 
               return i
         )
         ;;
         (when (isNotGate(k)) --> 
           x : bool <- read Wire[wire0(k)] ;
           return neg(x)
         )
         ;;
         (when (isXorGate(k)) --> 
            x : bool <- read Wire[wire0(k)] ;
            y : bool <- read Wire[wire1(k)] ;
           return xor( (x, y) ) 
         )
         ;;
         (when (isAndGate(k)) --> 
           x : bool <- read Wire[wire0(k)] ; 
           y : bool <- read Wire[wire1(k)] ;
           return **( (x, y) ) 
         )
       )
  )
  ||
  (   (family OutIdAdv[bound N + 2 bound K] 
         indices: n, k bounds: bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
          out : bool <- read Out[n, k] ; return out
       )
       ;;
       (when (isHonest(n)) --> 
          out : bool <- read OutIdAdv[n, k] ; return out
       )
     )
     ||
     (family Out[bound N + 2 bound K]  indices: n, k bounds: bound N + 2 bound K ::=
       (when (isOutputWire(k)) --> 
          out : bool <- read Wire[k] ; return out
       )
       ;;
       (when (not (isOutputWire(k))) --> 
          o : bool <- read Out[n, k] ; return o
       )
     
     )
  )
  ) and
  sim = (
     newfamily InShare[bound N + 1  bound N + 2 dependentBound I]
               indices: m, n, i 
               bounds: bound N + 1  bound N + 2 dependentBound I : bool in
     newfamily Share[bound N + 1 bound K]
               indices: n, k
               bounds: bound N + 1 bound K : bool in
     newfamily ShareSum[bound N + 1 bound K]
               indices: m, k
               bounds: bound N + 1 bound K : bool in
  initialSim || finalSim || shareSim || inductiveSim
  where 
   initialSim = 
  (
      newfamily InShare$[bound N + 1  bound N + 2 dependentBound I]  
                 indices: m, n, i 
                bounds: bound N + 1  bound N + 2 dependentBound I : bool in
      newfamily InShare$-Sum[bound N + 1  bound N + 2 dependentBound I] 
                 indices: m, n, i 
                bounds: bound N + 1  bound N + 2 dependentBound I : bool in
     (
     (family InPartyAdv[bound N + 2 dependentBound I]  indices: n, i
             bounds: bound N + 2 dependentBound I ::=
        ( (when (isSemiHonest(n)) -->
            in : bool <- read InIdAdv [n, i] ; 
               return in  
         ) 
         ;;
         (when (isHonest(n)) --> 
            in : bool <- read InPartyAdv[n, i] ; 
               return in  
         )
       
       )      
     )
     ||
     (family InRcvdPartyAdv[bound N + 2 dependentBound I]  indices: n, i
             bounds: bound N + 2 dependentBound I ::=
             
       (when (isHonest(n)) -->
 x : unit <- read InRcvdIdAdv[n, i] ; return ()
 )
;;
when (isSemiHonest(n)) -->
 in : unit <- read InRcvdPartyAdv[n, i] ; return in
      
     )
     ||
     (family InShare$[bound N + 1  bound N + 2 dependentBound I]  indices: m, n, i 
             bounds: bound N + 1  bound N + 2 dependentBound I ::= 
       ( (when (isSemiHonest(n)) -->
            x : bool <- read InIdAdv[n, i] ; 
              samp flip (()) 
         ) 
         ;;
         (when (isHonest(n)) -->
            x : unit <- read InRcvdIdAdv[n, i] ; 
              samp flip (())
         )
       
       )         
     ) 
     ||
     (  
family InShare$PartyAdv[bound N + 1 bound N + 2 dependentBound I] 
     indices: m, n, i
     bounds: bound N + 1 bound N + 2 dependentBound I
::=
(when (isSemiHonest(n)) -->
 in : bool <- read InShare$[m, n, i] ; return in
)
;;
when (isHonest(n)) -->
 in : bool <- read InShare$PartyAdv[m, n, i] ; return in
)
||
(
family InShare$PartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] 
     indices: m, n, i
bounds: fixedBound (N + 1) bound (N + 2) dependentBound I
::=
(when (isSemiHonest(n)) -->
  s : bool <- read InShare$-Sum[N, n, i] ;
  x : bool <- read InIdAdv[n, i] ; 
  return xor((x, s))
)
;;
when (isHonest(n)) -->
 in : bool <- read InShare$PartyAdv[N + 1, n, i] ; return in
 )    
     ||
     (family InShare$-Sum[bound N + 1  bound N + 2 dependentBound I] 
              indices: m, n, i 
             bounds: bound N + 1  bound N + 2 dependentBound I ::=             
       ( (when (m = 0) --> 
            in : bool <- read InShare$ [0, n, i] ; return in
         ) 
         ;; 
         (otherwise --> 
            s : bool <- read InShare$-Sum [m - 1, n, i] ;
            x : bool <- read InShare$ [m, n, i] ;
            return xor((s, x))
         )
       )      
     )
     ||
     (
       family InShare$-SumPartyAdv[bound (N + 1) bound (N + 2) dependentBound I] 
       indices: m, n, i
       bounds: bound (N + 1) bound (N + 2) dependentBound I
::=
(when (isSemiHonest(n)) -->
 s : bool <- read InShare$-Sum[m, n, i] ; return s
 )
;;
when (isHonest(n)) -->
 s : bool <- read InShare$-SumPartyAdv[m, n, i] ; return s      
             
     ) 
     ||
     (
      family SendInSharePartyAdv[bound (N + 1) bound (N + 2) dependentBound I] 
    indices: m, n, i
bounds: bound (N + 1) bound (N + 2) dependentBound I
::=
(when (isSemiHonest(n)) -->
 in : bool <- read InShare$[m, n, i] ; return in)
;;
when (isHonest(n)) -->
 s : bool <- read SendInSharePartyAdv[m, n, i] ; return s
      )
      ||
      (
      family SendInSharePartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] 
      indices: m, n, i
      bounds: fixedBound (N + 1) bound (N + 2) dependentBound I ::=
(when (isSemiHonest(n)) -->
 s : bool <- read InShare$-Sum[N, n, i] ; 
 x : bool <- read InIdAdv[n, i] ; 
 return xor((x, s))
)
;;
when (isHonest(n)) -->
 s : bool <- read SendInSharePartyAdv[N + 1, n, i] ; return s
      )
     || 
     (family RcvdInSharePartyAdv[bound (N + 2) bound (N + 2) dependentBound I] 
     indices: n, m, i
     bounds: bound (N + 2) bound (N + 2) dependentBound I ::=
(when (isSemiHonest(n)) -->
 in : bool <- read InShare$[n, m, i] ; return in
)
;;
when (isHonest(n)) -->
 s : bool <- read RcvdInSharePartyAdv[n, m, i] ; return s
     )    
     ||
     (family InShare[bound N + 1  bound N + 2 dependentBound I]
              indices: m, n, i 
             bounds: bound N + 1  bound N + 2 dependentBound I ::= 
         in : bool <- read InShare$ [m, n, i] ; return in     
     ) 
     ||
     (family InSharePartyAdv[bound (N + 2) bound (N + 2) dependentBound I] 
     indices: n, m, i
     bounds: bound (N + 2) bound (N + 2) dependentBound I ::=
(when (isSemiHonest(n)) -->
 s : bool <- read InShare[n, m, i] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read InSharePartyAdv[n, m, i] ; return s
     ) 
    )
  ) 
  and
   finalSim = 
    (
      (family SendOutSharePartyAdv[bound N + 2 bound N + 2 bound K] 
        indices: m, n, k
        bounds: bound N + 2 bound N + 2 bound K  ::=
(when ((isOutputWire(k)) and (isSemiHonest(n))) -->
 s : bool <- read Share[n, k] ; return s
)
;;
when (not (isOutputWire(k)) or (isHonest(n))) -->
 s : bool <- read SendOutSharePartyAdv[m, n, k] ; return s
       )
       ||
       (family RcvdOutSharePartyAdv[bound N + 2 bound N + 1 bound K] 
         indices: n, m, k
         bounds: bound N + 2 bound N + 1 bound K
::=
(when ((isOutputWire(k)) and (isSemiHonest(n))) -->
 s : bool <- read Share[m, k] ; return s)
;;
when (not (isOutputWire(k)) or (isHonest(n))) -->
 s : bool <- read RcvdOutSharePartyAdv[n, m, k] ; return s
)      
 ||
 (
 family RcvdOutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K] 
  indices: n, m, k
  bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
(when ((isOutputWire(k)) and (isSemiHonest(n))) -->
   w : bool <- read OutIdAdv[n, k] ; 
   xs : bool <- read ShareSum[N, k] ; 
   return xor((xs, w))
)
;;
when (not (isOutputWire(k)) or (isHonest(n))) -->
 s : bool <- read RcvdOutSharePartyAdv[n,  N + 1, k] ; return s
 ) 
       ||
      (family OutSharePartyAdv[bound (N + 2) bound (N + 1) bound K]
       indices: n, m, k
       bounds: bound (N + 2) bound (N + 1) bound K
::=
(when ((isOutputWire(k)) and (isSemiHonest(n))) -->
 s : bool <- read Share[m, k] ; return s)
;;
when (not (isOutputWire(k)) or (isHonest(n))) -->
 s : bool <- read OutSharePartyAdv[n, m, k] ; return s
)
||
(
family OutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K] 
  indices: n, m, k
  bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
(when ((isOutputWire(k)) and (isSemiHonest(n))) -->
  w : bool <- read OutIdAdv[n, k] ;  
  xs : bool <- read ShareSum[N, k] ; 
  return xor((xs, w))
)
;;
when (not (isOutputWire(k)) or (isHonest(n))) -->
 s : bool <- read OutSharePartyAdv[n,  N + 1, k] ; return s
) 
       ||
        (
 family OutShareSumPartyAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
(when ((isOutputWire(k)) and (isSemiHonest(n))) -->
 s : bool <- read ShareSum[m, k] ; return s)
;;
when (not (isOutputWire(k)) or (isHonest(n))) -->
 s : bool <- read OutShareSumPartyAdv[n, m, k] ; return s
 )    
 ||
 (
 family OutShareSumPartyAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
(when ((isOutputWire(k)) and (isSemiHonest(n))) -->
 w : bool <- read OutIdAdv[n, k] ; return w
)
;;
when (not (isOutputWire(k)) or (isHonest(n))) -->
 s : bool <- read OutShareSumPartyAdv[n,  N + 1, k] ; return s
 ) 
       ||
       (family OutPartyAdv[((bound (N + 2))(bound K))]  indices: n, k
          bounds: bound N + 2 bound K ::=       
(when (isSemiHonest(n)) -->
 s : bool <- read OutIdAdv[n, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read OutPartyAdv[n, k] ; return s
         
       )
    ) 
   and
   shareSim = 
  (  family ShareSum[bound N + 1 bound K] 
             indices: m, k 
             bounds: bound N + 1 bound K ::=
     (
      (when (m = 0) --> 
         s : bool <- read Share[0, k] ; return s
      )
      ;;
      (when (not (m = 0)) --> 
          xs : bool <- read ShareSum[m - 1, k] ; 
          xm : bool <- read Share[m, k] ;
          return xor((xs, xm))  
      )
     )
   )
   and inductiveSim = 
   (
       newfamily SendBit[bound N + 1  bound N + 2 bound K]  indices: n, m, k 
                 bounds: bound N + 1  bound N + 2 bound K : bool in
       newfamily RcvdBit[bound N + 1 bound N + 1 bound K ]  indices: n, m, k
                 bounds: bound N + 1 bound N + 1 bound K : bool in 
       newfamily RcvdBit[bound N + 1 fixedBound N + 1 bound K]  indices: n, m, k
                 bounds: bound N + 1 fixedBound N + 1 bound K : bool in            
       newfamily Ctrb[bound N + 1  bound N + 2 bound K]  indices: n, m, k 
                 bounds: bound N + 1  bound N + 2 bound K : bool in
       newfamily CtrbSum[bound N + 1  bound N + 2 bound K]  indices: n, m, k 
                 bounds: bound N + 1  bound N + 2 bound K : bool in
family Circ[bound K] indices: k bounds: bound K ::=
( 
      (when (isInputGate(k)) --> 
(
 (family Ctrb[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound N + 1  bound N + 2 bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 1) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 1) bound K
::=
 rb : bool <- read RcvdBit[n, m, k]; return rb
)
||
(family RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] indices: n, m, k
bounds:  bound (N + 1) fixedBound (N + 1) bound K
::=
 rb : bool <- read RcvdBit[n,  N + 1, k]; return rb
)
||
(family SendBit[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds:  bound (N + 1) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k]; return sb
)
||
(family Share[bound (N + 1) bound K] indices: n, k
bounds:  bound (N + 1) bound K
::=
 in : bool <- read InShare[n, wire0(k) , wire1(k)] ; return in
)
||
(family CtrbPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbPartyAdv[n, m, k] ; return b
)
||
(family CtrbSumPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSumPartyAdv[n, m, k] ; return b
)
||
(family OTChc-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 oc : bool <- read OTChc-0OtAdv[n, m, k]; return oc
)
||
(family OTChc-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 oc : bool <- read OTChc-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-0OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-0OtAdv[n,  N + 1, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-1OtAdv[n,  N + 1, k]; return oc
)
||
(family OTMsg-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-0OtAdv[n, m, k]; return om
)
||
(family OTMsg-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-1OtAdv[n, m, k]; return om
)
||
(family OTMsg-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-2OtAdv[n, m, k]; return om
)
||
(family OTMsg-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-3OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-0OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-1OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-2OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-3OtAdv[n, m, k]; return om
)
||
(family OTOutOtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 out : bool <- read OTOutOtAdv[n, m, k] ; return out
)
||
(family RcvdBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBitPartyAdv[n, m, k]; return rb
)
||
(family SendBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBitPartyAdv[n, m, k]; return sb
)
||
(family SharePartyAdv[bound (N + 2) bound K] indices: n, k
bounds: bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read Share[n, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read SharePartyAdv[n, k] ; return s
)
   )
   ) 
     ;;
   ( 
      when (isNotGate(k)) --> 
( 
(family Ctrb[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 1) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 1) bound K
::=
 rb : bool <- read RcvdBit[n, m, k]; return rb
)
||
(family RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 1) fixedBound (N + 1) bound K
::=
 rb : bool <- read RcvdBit[n,  N + 1, k]; return rb
)
||
(family SendBit[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k]; return sb
)
||
(family Share[bound (N + 1) bound K] indices: n, k
bounds: bound (N + 1) bound K
::=
 s : bool <- read Share[n, wire0(k)] ; return s
)
||
(family CtrbPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbPartyAdv[n, m, k] ; return b
)
||
(family CtrbSumPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSumPartyAdv[n, m, k] ; return b
)
||
(family OTChc-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 oc : bool <- read OTChc-0OtAdv[n, m, k]; return oc
)
||
(family OTChc-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 oc : bool <- read OTChc-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-0OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-0OtAdv[n,  N + 1, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-1OtAdv[n,  N + 1, k]; return oc
)
||
(family OTMsg-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-0OtAdv[n, m, k]; return om
)
||
(family OTMsg-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-1OtAdv[n, m, k]; return om
)
||
(family OTMsg-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-2OtAdv[n, m, k]; return om
)
||
(family OTMsg-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-3OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-0OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-1OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-2OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-3OtAdv[n, m, k]; return om
)
||
(family OTOutOtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 out : bool <- read OTOutOtAdv[n, m, k] ; return out
)
||
(family RcvdBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBitPartyAdv[n, m, k]; return rb
)
||
(family SendBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBitPartyAdv[n, m, k]; return sb
)
||
(family SharePartyAdv[bound (N + 2) bound K] indices: n, k
bounds: bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read Share[n, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read SharePartyAdv[n, k] ; return s
)
) 
   ) 
   ;;
( 
      when (isXorGate(k)) --> 
(
(family Ctrb[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 1) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 1) bound K
::=
 rb : bool <- read RcvdBit[n, m, k]; return rb
)
||
(family RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 1) fixedBound (N + 1) bound K
::=
 rb : bool <- read RcvdBit[n,  N + 1, k]; return rb
)
||
(family SendBit[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k]; return sb
)
||
(family Share[bound (N + 1) bound K] indices: n, k
bounds: bound (N + 1) bound K
::=
 x : bool <- read Share[n, wire0(k)] ; 
 y : bool <- read Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family CtrbPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbPartyAdv[n, m, k] ; return b
)
||
(family CtrbSumPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSumPartyAdv[n, m, k] ; return b
)
||
(family OTChc-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 oc : bool <- read OTChc-0OtAdv[n, m, k]; return oc
)
||
(family OTChc-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 oc : bool <- read OTChc-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-0OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-0OtAdv[n,  N + 1, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
 oc : unit <- read OTChcRcvd-1OtAdv[n,  N + 1, k]; return oc
)
||
(family OTMsg-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-0OtAdv[n, m, k]; return om
)
||
(family OTMsg-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-1OtAdv[n, m, k]; return om
)
||
(family OTMsg-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-2OtAdv[n, m, k]; return om
)
||
(family OTMsg-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : bool <- read OTMsg-3OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-0OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-1OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-2OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 om : unit <- read OTMsgRcvd-3OtAdv[n, m, k]; return om
)
||
(family OTOutOtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 out : bool <- read OTOutOtAdv[n, m, k] ; return out
)
||
(family RcvdBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBitPartyAdv[n, m, k]; return rb
)
||
(family SendBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBitPartyAdv[n, m, k]; return sb
)
||
(family SharePartyAdv[bound (N + 2) bound K] indices: n, k
bounds: bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read Share[n, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read SharePartyAdv[n, k] ; return s
)
) 
   ) 
   ;;
( when (isAndGate(k)) -->
(
(family Ctrb[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <- read SendBit[n, m, k] ; return s)
;;
(when (m = n) -->
 x : bool <- read Share[n, wire0(k)] ; 
 y : bool <- read Share[n, wire1(k)] ;
 return **((x, y))
)
;;
when (m < n) -->
 r : bool <- read RcvdBit[n, m, k]; return r
)
||
(family CtrbSum[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
(when (0 = m) -->
 b : bool <- read Ctrb[n, 0, k] ; return b)
;;
when not (0 = m) -->
 b : bool <- read Ctrb[n, m, k] ; 
 s : bool <- read CtrbSum[n, m - 1, k] ;
 return xor((s, b))
)
||
(family RcvdBit[bound (N + 1) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 1) bound K
::=
   b : bool <- read SendBit[m, n, k] ; 
  xm : bool <- read Share[m, wire0(k)] ; 
  xn : bool <- read Share[n, wire0(k)] ;
  ym : bool <- read Share[m, wire1(k)] ;
  yn : bool <- read Share[n, wire1(k)] ; 
  return xor(( xor( (**((xm, yn)) , **((xn, ym))) ) , b) )
)
||
(family RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 1) fixedBound (N + 1) bound K
::=
 r : bool <- read RcvdBit[n, m, k]; return r
)
||
(family SendBit[bound (N + 1) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 1) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <- read Share[n, wire0(k)] ;
 y : bool <- read Share[n, wire1(k)] ;
 samp flip (())
)
;;
when (m <= n) -->
 sb : bool <- read SendBit[n, m, k]; return sb
)
||
(family Share[bound (N + 1) bound K] indices: n, k
bounds: bound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[n,  N + 1, k] ; return bs
)
||
(family CtrbPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read Ctrb[n, m, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read CtrbPartyAdv[n, m, k] ; return s
)
||
(family CtrbSumPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read CtrbSum[n, m, k] ; return s
)
;;
when (isHonest(n)) -->
 s : bool <- read CtrbSumPartyAdv[n, m, k] ; return s
)
||
(family OTChc-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isSemiHonest(m)) and n < m) -->
 x : bool <- read Share[m, wire0(k)]; return x
 )
;;
when ((isHonest(m)) or m <= n) -->
 oc : bool <- read OTChc-0OtAdv[n, m, k]; return oc
)
||
(family OTChc-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isSemiHonest(m)) and n < m) -->
 x : bool <- read Share[m, wire1(k)]; return x
)
;;
when ((isHonest(m)) or m <= n) -->
 oc : bool <- read OTChc-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
(when ((isHonest(m)) and n < m) -->
 x : bool <- read Share[m, wire0(k)] ; return ()
)
;;
when ((isSemiHonest(m)) or m <= n) -->
 oc : unit <- read OTChcRcvd-0OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
(when (n < N + 1) -->
 x : bool <- read ShareSum[N, wire0(k)] ; return ())
;;
when (n = N + 1) -->
 oc : unit <- read OTChcRcvd-0OtAdv[n,  N + 1, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) bound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 1) bound K
::=
(when ((isHonest(m)) and n < m) -->
 x : bool <- read Share[m, wire1(k)] ; return ())
;;
when ((isSemiHonest(m)) or m <= n) -->
 oc : unit <- read OTChcRcvd-1OtAdv[n, m, k]; return oc
)
||
(family OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K] indices: n, m, k
bounds: bound (N + 2) fixedBound (N + 1) bound K
::=
(when (n < N + 1) -->
 x : bool <- read ShareSum[N, wire1 (k)] ; return ()
)
;;
when (n = N + 1) -->
 oc : unit <- read OTChcRcvd-1OtAdv[n,  N + 1, k]; return oc
)
||
(family OTMsg-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isSemiHonest(n)) and n < m) -->
  b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ; 
  return b
)
;;
when ((isHonest(n)) or m <= n) -->
 om : bool <- read OTMsg-0OtAdv[n, m, k]; return om
)
||
(family OTMsg-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isSemiHonest(n)) and n < m) -->
  b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ; 
  return xor((x, b))
)
;;
when ((isHonest(n)) or m <= n) -->
 om : bool <- read OTMsg-1OtAdv[n, m, k]; return om
)
||
(family OTMsg-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isSemiHonest(n)) and n < m) -->
  b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ;  
  return xor((y, b))
)
;;
when ((isHonest(n)) or m <= n) -->
 om : bool <- read OTMsg-2OtAdv[n, m, k]; return om
)
||
(family OTMsg-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isSemiHonest(n)) and n < m) -->
  b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ; 
  return xor((xor((x, y)), b))
)
;;
when ((isHonest(n)) or m <= n) -->
 om : bool <- read OTMsg-3OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-0OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isHonest(n)) and n < m) -->
  b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ; return () 
)
;;
when ((isSemiHonest(n)) or m <= n) -->
 om : unit <- read OTMsgRcvd-0OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-1OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isHonest(n)) and n < m) -->
  b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ;  
  return () 
)
;;
when ((isSemiHonest(n)) or m <= n) -->
 om : unit <- read OTMsgRcvd-1OtAdv[n, m, k]; return om
)
||
(family OTMsgRcvd-2OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isHonest(n)) and n < m) -->
 b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ;  
  return () 
)
;;
when ((isSemiHonest(n)) or m <= n) -->
 om : unit <- read OTMsgRcvd-2OtAdv[n, m, k]; return om
)
||

(family OTMsgRcvd-3OtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when ((isHonest(n)) and n < m) -->
  b : bool <- read SendBit[n, m, k] ;
  x : bool <- read Share[n, wire0(k)] ;
  y : bool <- read Share[n, wire1(k)] ;  
  return () 
)
;;
when ((isSemiHonest(n)) or m <= n) -->
 om : unit <- read OTMsgRcvd-3OtAdv[n, m, k]; return om
)
||
(family OTOutOtAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (isSemiHonest(m)) -->
 out : bool <- read RcvdBit[m, n, k] ; return out)
;;
when (isHonest(m)) -->
 out : bool <- read OTOutOtAdv[n, m, k] ; return out
)
||
(family RcvdBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read RcvdBit[n, m, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read RcvdBitPartyAdv[n, m, k] ; return s
)
||
(family SendBitPartyAdv[bound (N + 2) bound (N + 2) bound K] indices: n, m, k
bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read SendBit[n, m, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read SendBitPartyAdv[n, m, k] ; return s
)
||
(family SharePartyAdv[bound (N + 2) bound K] indices: n, k
bounds: bound (N + 2) bound K
::=
(when (isSemiHonest(n)) -->
 s : bool <- read Share[n, k] ; return s)
;;
when (isHonest(n)) -->
 s : bool <- read SharePartyAdv[n, k] ; return s
)
)

)
     ) ) ) .

`` subproofs
strict subproof addWire =
  sym from
   extend currentProtocol with
    internal family Wire indices: k bounds: bound K 
    typed: bool 
    assigned: s : bool <- read ShareSum[N + 1, k] ;
              return s
 (absorb fam Wire[bound K])              
.
 
strict subproof addWiresGroup =
group  
  fam Wire[bound K]
in Wires
indices: k
bounds: bound K
. 
strict subproof symInputWS =
  sym from change 
       chn Wire[B]
       with  s : bool <- read ShareSum[N + 1, B] ; return s
       in currentProtocol
       ( subst chn ShareSum[N + 1, B]
          into chn Wire[B] )
.  
`` subproofs go above this line


start with pInt3 over deltaRealSplit 

call addWire then
compose fam Shares[bound K] with fam Wire[bound K] in group then
sym from 
             change fam Shares[bound K] and Wire[bound K]
             with 
              (
                ( family Shares[bound K] 
 indices: k 
 bounds: bound K ::= 
 (
     (when  isInputGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <-  read InShare[n, wire0(k), wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
 )
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 w : bool <- read Wire[k] ; return w
)
))
;;
(when  isNotGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <-  read Share[n, wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
    xs : bool <-  read ShareSum[N, k] ; 
    return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
 )
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 w : bool <- read Wire[k] ; return w
)
))
;;
(when  isXorGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 w : bool <- read Wire[k] ; return w
)
))
;;
(when  isAndGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <-  read SendBit[n, m, k] ; return s
)
;;
(when (m = n) -->
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
 return **((x, y))
)
;;
(when (m < n) -->
 r : bool <-  read RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (m = 0) -->
 b : bool <-  read Ctrb[n, 0, k] ; return b
)
;;
(when not (m = 0) -->
 b : bool <-  read Ctrb[n, m, k] ; 
 s : bool <-  read CtrbSum[n, m - 1, k] ; 
 return xor((s, b))
)
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read SendBit[m, n, k] ; 
 xm : bool <-  read Share[m, wire0(k)] ; 
 xn : bool <-  read Share[n, wire0(k)] ; 
 ym : bool <-  read Share[m, wire1(k)] ; 
 yn : bool <-  read Share[n, wire1(k)] ; 
 return xor( ( xor(( **((xm, yn)), **((xn, ym))  )) , b) )
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
    samp flip (()) 
)
;;
(when (m <= n) -->
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <-  read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
    xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))   
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 w : bool <- read Wire[k] ; return w
)
))    
     ) 
)
||
(
family Wire[bound K] 
 indices: k
 bounds: bound K ::=
 (when isInputGate(k) -->  
   i : bool <- read In[wire0(k), wire1(k)] ; return i
 ) ;;
 (when isNotGate(k) --> 
   x : bool <- read Wire[wire0(k)] ; return neg(x)
 ) ;;
 (when isXorGate(k) --> 
   x : bool <- read Wire[wire0(k)] ;
   y : bool <- read Wire[wire1(k)] ;
   return xor((x, y))
 ) ;;
 (when isAndGate(k) --> 
   x : bool <- read Wire[wire0(k)] ;
   y : bool <- read Wire[wire1(k)] ;
   return **((x, y)) 
 ) 
)
              )
             in currentProtocol
(
 in the presence of
  fam InShare[bound N + 2 bound N + 2 dependentBound I]
 rewrite group Shares[bound K] and Wire[bound K]
 to (
    ( family Shares[bound K] 
 indices: k 
 bounds: bound K ::= 
 (
     (when  isInputGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <-  read InShare[n, wire0(k), wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
 )
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 i : bool <-  read In[wire0(k), wire1(k)] ; 
    return i
)
))
;;
(when  isNotGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <-  read Share[n, wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
    xs : bool <-  read ShareSum[N, k] ; 
    return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
 )
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, wire0(k)] ;
    return neg(x)
)
))
;;
(when  isXorGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <-  read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
 xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, wire0(k)] ; 
 y : bool <-  read ShareSum[N + 1, wire1(k)] ; 
 return xor((x, y))
)
))
;;
(when  isAndGate(k) --> (
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <-  read SendBit[n, m, k] ; return s
)
;;
(when (m = n) -->
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
 return **((x, y))
)
;;
(when (m < n) -->
 r : bool <-  read RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (m = 0) -->
 b : bool <-  read Ctrb[n, 0, k] ; return b
)
;;
(when not (m = 0) -->
 b : bool <-  read Ctrb[n, m, k] ; 
 s : bool <-  read CtrbSum[n, m - 1, k] ; 
 return xor((s, b))
)
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <-  read SendBit[m, n, k] ; 
 xm : bool <-  read Share[m, wire0(k)] ; 
 xn : bool <-  read Share[n, wire0(k)] ; 
 ym : bool <-  read Share[m, wire1(k)] ; 
 yn : bool <-  read Share[n, wire1(k)] ; 
 return xor( ( xor(( **((xm, yn)), **((xn, ym))  )) , b) )
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,  m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <-  read Share[n, wire0(k)] ; 
 y : bool <-  read Share[n, wire1(k)] ;
    samp flip (()) 
)
;;
(when (m <= n) -->
 sb : bool <-  read SendBit[n, m, k] ; return sb
)
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <-  read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, k] ; 
    xs : bool <-  read ShareSum[N, k] ; 
 return xor((xs, x))   
)
||
(family ShareSum[bound (N + 1) bound K]
 indices: m, k
 bounds: bound (N + 1) bound K
::=
(when (m = 0) -->
 s : bool <-  read Share[0, k] ; return s
)
;;
(when not (m = 0) -->
 xm : bool <-  read Share[m, k] ; 
 xs : bool <-  read ShareSum[m - 1, k] ; 
 return xor((xs, xm))
)
)
||
(family ShareSum[fixedBound (N + 1) bound K]
 indices: m, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <-  read ShareSum[N + 1, wire0(k)] ; 
 y : bool <-  read ShareSum[N + 1, wire1(k)] ; 
 return **((x, y))
)
))    
     ) 
)
||
(
family Wire[bound K] 
 indices: k
 bounds: bound K ::=
  s : bool <- read ShareSum[N + 1, k] ; return s
)
 )
  by induction on k bound B (
    remove chn ShareSum[N + 1, B] 
        from group Shares[fixedBound B] then
    merge case for chn Wire[B] and chn ShareSum[N + 1, B]
         into group CGroup then
    case distinction on group CGroup[bound 1](
        case: (
         subst chn Wire[B] into chn ShareSum[N + 1, B] then 
         call symInputWS
        )
        case: (
         subst chn Wire[B] into chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn Wire[B] then
         call symInputWS then
         rename s to x in chn ShareSum[N + 1, B] 
        )
        case: (
         subst chn Wire[B] into chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn ShareSum[N + 1, B] at x then
         rename s to x in chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn ShareSum[N + 1, B] then
         rename s to y in chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn Wire[B] then
         rename s to x in chn Wire[B] then
         subst fam Wire[bound B] into chn Wire[B] then
         rename s to y in chn Wire[B] then
         call symInputWS 
        )
        case: (
        subst chn Wire[B] into chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn ShareSum[N + 1, B] then
         rename s to x in chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn ShareSum[N + 1, B] then
         rename s to y in chn ShareSum[N + 1, B] then
         subst fam Wire[bound B] into chn Wire[B] then
         rename s to x in chn Wire[B] then
         subst fam Wire[bound B] into chn Wire[B] then
         rename s to y in chn Wire[B] then
         call symInputWS
        )
       ) then
       combine fam CGroup[bound 1] then
       merge cases for chn Wire[B] then
       move channel ShareSum[N + 1, B] on each branch of group Shares[fixedBound B]    
    )   
) then
decompose fam Shares[bound K] with fam Wire[bound K] then
remove and merge fam ShareSum[fixedBound N + 1 bound K]
 from group Shares[bound K] then
call addWiresGroup then
split fam InShare$PartyAdv[bound (N + 2) bound (N + 2) dependentBound I] on first index then
on branch isSemiHonest(n) of 
 family InShare$PartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] (
   subst fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]
    into fam InShare$PartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I]
 ) then
split fam SendInSharePartyAdv[bound (N + 2) bound (N + 2) dependentBound I] 
 on first index then
on branch isSemiHonest(n) of family 
 SendInSharePartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] (
  subst fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]
   into fam SendInSharePartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] 
) then
split fam InShare [bound (N + 2) bound (N + 2) dependentBound I] 
 on first index then
subst fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]
 into fam InShare[fixedBound (N + 1) bound (N + 2) dependentBound I] then
split fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] on 
 first index then
absorb fam InShare$[fixedBound (N + 1) bound (N + 2) dependentBound I] then
absorb fam InShare[fixedBound (N + 1) bound (N + 2) dependentBound I] then
remove fam RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 from group Shares[bound K] then
 split fam RcvdBit[bound (N + 2) bound (N + 2) bound K]  
  on second index then
move family  RcvdBit[bound (N + 2) bound (N + 1) bound K] 
 on each branch of group Shares[bound K] then
move family RcvdBit[bound (N + 2) fixedBound (N + 1) bound K] 
 on each branch of group Shares[bound K] then
on branch isAndGate(k) of group Shares[bound K] (
  diverge on fam RcvdBit[bound (N + 2) fixedBound (N + 1) bound K]  
   with branch m <= n of fam SendBit[bound (N + 2) bound (N + 2) bound K] 
    var r
  ) then
on all branches of fam Shares[bound K] 
 split fam SendBit[bound (N + 2) bound (N + 2) bound K] on first index then
on all branches of fam Shares[bound K] 
 split fam RcvdBit[bound (N + 2) bound (N + 1) bound K] 
    on first index then
on all branches of fam Shares[bound K]
 split fam RcvdBit[bound (N + 2) fixedBound (N + 1) bound K] 
     on first index then
on all branches of fam Shares[bound K]
 split fam CtrbSum[bound (N + 2) bound (N + 2) bound K] 
     on first index then
on all branches of fam Shares[bound K]
 split fam Ctrb[bound (N + 2) bound (N + 2) bound K] 
    on first index then
 extract  
  fam Ctrb[fixedBound (N + 1) bound (N + 2) bound K],
  fam CtrbSum[fixedBound (N + 1) bound (N + 2) bound K],
  fam SendBit[fixedBound (N + 1) bound (N + 2) bound K],
  fam RcvdBit[fixedBound (N + 1) bound (N + 1) bound K],
  fam RcvdBit[fixedBound (N + 1) fixedBound (N + 1) bound K]
 from group Shares[bound K]
 into group Ctrbs then
 group-absorb group Ctrbs[bound K] then
 split fam RcvdOutSharePartyAdv[bound N + 2 bound N + 2 bound K]
 on second index then
split fam OutSharePartyAdv[bound N + 2 bound N + 2 bound K]
 on second index then
 remove and merge fam Share[fixedBound N + 1 bound K] 
 from group Shares[bound K] then
 on branch (isSemiHonest(n) and isOutputWire(k))
 of family RcvdOutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] (
  subst fam Share[fixedBound N + 1 bound K] 
   into fam RcvdOutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] 
) then
on branch (isSemiHonest(n) and isOutputWire(k))
 of family OutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] (
  subst fam Share[fixedBound N + 1 bound K] 
   into fam OutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] 
) then
absorb fam Share[fixedBound N + 1 bound K] then
on branch (isSemiHonest(n) and isOutputWire(k))
 of family RcvdOutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] (
  subst fam ShareSum[fixedBound N + 1 bound K] 
   into fam RcvdOutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] 
) then
on branch (isSemiHonest(n) and isOutputWire(k))
 of family OutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] (
  subst fam ShareSum[fixedBound N + 1 bound K] 
   into fam OutSharePartyAdv[bound N + 2 fixedBound N + 1 bound K] 
) then
split fam OutShareSumPartyAdv[bound (N + 2) bound (N + 2) bound K]
 on second index then
on branch (isSemiHonest(n) and isOutputWire(k))
 of family OutShareSumPartyAdv[bound N + 2 fixedBound N + 1 bound K] (
  subst fam ShareSum[fixedBound N + 1 bound K] 
   into fam OutShareSumPartyAdv[bound N + 2 fixedBound N + 1 bound K] 
) then
on branch isOutputWire(k)
 of family Out[bound N + 2 bound K] (
  subst fam ShareSum[fixedBound N + 1 bound K]
   into fam Out[bound N + 2 bound K] 
) then
absorb fam ShareSum[fixedBound N + 1 bound K] then
remove and merge fam ShareSum[bound N + 1 bound K]
 from group Shares[bound K] then
merge case for fam Adv[bound K]
 and fam Shares[bound K] into group Circ then
rename indices to m, n, i in fam InShare[bound N + 1 bound N + 2 dependentBound I ] then 
sym from change 
        fam OutShareSumPartyAdv[bound (N + 2) fixedBound (N + 1) bound K]
        with 
         (when (isSemiHonest(n) and isOutputWire(k)) -->
           out : bool <- read Out[n, k] ; return out
         ) ;;
         (when (isHonest(n) or not isOutputWire(k)) -->
           s : bool <- read OutShareSumPartyAdv[n, N + 1, k] ; return s
         )
        in currentProtocol
       (
       on branch (isSemiHonest(n) and isOutputWire(k))
        of family OutShareSumPartyAdv[bound (N + 2) fixedBound (N + 1) bound K] (
        subst fam Out[bound N + 2 bound K]
         into fam OutShareSumPartyAdv[bound (N + 2) fixedBound (N + 1) bound K] 
       )
       ) then
 sym from change 
        fam OutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K]
        with 
         (when (isSemiHonest(n) and isOutputWire(k)) -->
           out : bool <- read Out[n, k] ;
           xs : bool <- read ShareSum[N, k] ; 
           return xor((xs, out))
         ) ;;
         (when (isHonest(n) or not isOutputWire(k)) -->
           s : bool <- read OutSharePartyAdv[n, N + 1, k] ; return s
         )  
        in currentProtocol
       (
       on branch (isSemiHonest(n) and isOutputWire(k))
         of family OutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K] (
         subst fam Out[bound N + 2 bound K] 
          into fam OutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K]  
       )
       ) then             
sym from change 
        fam RcvdOutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K]
        with 
         (when (isSemiHonest(n) and isOutputWire(k)) -->
           out : bool <- read Out[n, k] ;
           xs : bool <- read  ShareSum[N, k] ;
           return xor((xs, out))
         ) ;;
         (when (isHonest(n) or not isOutputWire(k)) -->
           s : bool <- read RcvdOutSharePartyAdv[n, N + 1, k] ; return s
         )
        in currentProtocol
       (
       on branch (isSemiHonest(n) and isOutputWire(k))
        of family RcvdOutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K] (
         subst fam Out[bound N + 2 bound K]
          into fam RcvdOutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K]
        ) 
       ) then
discard branch m = N + 1 of fam InShare$[bound (N + 1) bound (N + 2) dependentBound I] then
sym from idealPlusSim over deltaIdealPlusSim (
on branch isSemiHonest(n) 
 of family InShare$[bound (N + 1) bound (N + 2) dependentBound I](
   subst fam InIdAdv[bound N + 2 dependentBound I] 
    into fam InShare$[bound (N + 1) bound (N + 2) dependentBound I]
 ) then
 on branch isSemiHonest(n)
  of family InPartyAdv[bound (N + 2) dependentBound I] (
  subst fam InIdAdv[bound N + 2 dependentBound I] 
   into fam InPartyAdv[bound (N + 2) dependentBound I]
  ) then
 on branch isSemiHonest(n)
  of family InShare$PartyAdv[fixedBound N + 1 bound (N + 2) dependentBound I] ( 
  subst fam InIdAdv[bound N + 2 dependentBound I] 
   into fam InShare$PartyAdv[fixedBound N + 1 bound (N + 2) dependentBound I] then
   rename in to x in fam InShare$PartyAdv[fixedBound N + 1 bound (N + 2) dependentBound I]
 ) then
 on branch isSemiHonest(n)
  of family SendInSharePartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] (
   subst fam InIdAdv[bound N + 2 dependentBound I] 
    into fam SendInSharePartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] then
   rename in to x in fam SendInSharePartyAdv[fixedBound (N + 1) bound (N + 2) dependentBound I] 
 ) then
 on branch isHonest(n) 
  of family InShare$[bound (N + 1) bound (N + 2) dependentBound I] (
   subst fam InRcvdIdAdv[bound (N + 2) dependentBound I]
    into fam InShare$[bound (N + 1) bound (N + 2) dependentBound I]
 ) then
 on branch isHonest(n)
  of family InRcvdPartyAdv[bound (N + 2) dependentBound I] (
   subst fam InRcvdIdAdv[bound (N + 2) dependentBound I]
    into fam InRcvdPartyAdv[bound (N + 2) dependentBound I] then
    rename in to x in fam InRcvdPartyAdv[bound (N + 2) dependentBound I]
 ) then
 on branch isSemiHonest(n)
  of family OutPartyAdv[bound N + 2 bound K] (
  subst fam OutIdAdv[bound N + 2 bound K]
   into fam OutPartyAdv[bound N + 2 bound K] then
  rename out to s in fam OutPartyAdv[bound N + 2 bound K]
 ) then
 on branch (isSemiHonest(n) and isOutputWire(k))
  of family OutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K] (
  subst fam OutIdAdv[bound N + 2 bound K]
   into fam OutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K] 
 ) then
 on branch (isSemiHonest(n) and isOutputWire(k))
  of family OutShareSumPartyAdv[bound (N + 2) fixedBound (N + 1) bound K] (
  subst fam OutIdAdv[bound N + 2 bound K]
   into fam OutShareSumPartyAdv[bound (N + 2) fixedBound (N + 1) bound K]
 ) then
 on branch (isSemiHonest(n) and isOutputWire(k))
  of family RcvdOutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K] (
   subst fam OutIdAdv[bound N + 2 bound K]
    into fam RcvdOutSharePartyAdv[bound (N + 2) fixedBound (N + 1) bound K]
  ) then 
 on branch isOutputWire(k)
  of family Out [bound (N + 2) bound K] (
  rename out to w in fam Out [bound (N + 2) bound K] 
 ) then
 merge cases for fam InShare$[bound (N + 1) bound (N + 2) dependentBound I] then
 rename in to x in fam InShare$[bound (N + 1) bound (N + 2) dependentBound I] then
 absorb fam OutIdAdv[bound (N + 2) bound K] then
 absorb fam InRcvdIdAdv[bound (N + 2) dependentBound I] then  
 absorb fam InIdAdv[bound (N + 2) dependentBound I] then
 on branch isAndGate(k) of group Circ[bound K] (
 fix index for fam RcvdBit[bound N + 1 fixedBound N + 1 bound K ]
 )
)

check-proof idealPlusSim
quit
