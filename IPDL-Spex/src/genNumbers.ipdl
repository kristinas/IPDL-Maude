lang IPDL 
parameter N : nat .

function xor : bool * bool -> bool .
distribution flip : unit -> bool .
channel context delta = 
 output C : bool ; 
 output In-OK[bound N + 2 dependentBound I] : unit ; 
 output InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I ] : unit ;
 output InShare$-OK[bound N + 2 bound N + 2 dependentBound I ] : unit ;
 output InShareOK[bound N + 2 bound N + 2 dependentBound I ] : unit ; 
 input In[bound N + 2 dependentBound I ] : bool 
.
protocol real = 
 (C ::= return True) 
  ||
 (family In-OK [bound N + 2 dependentBound I ]indices: n ,i bounds: bound N + 2 dependentBound I ::= nf (in : bool <- read In [n ,i ],return ())
)
||
(family InitOK [bound N + 2 bound N + 2 dependentBound I ]indices: m ,n ,i bounds: bound N + 2 bound N + 2 dependentBound I ::= (
 (family InShareOK [bound N + 2 bound N + 2
    dependentBound I ]indices: m ,n ,i bounds: bound N + 2 bound N + 2 dependentBound I ::= nf (is : unit <- read InShare$-OK [m ,n ,i ],return ()) ) || (family InShare$Sum-OK [bound N +
    1 bound N + 2 dependentBound I ]indices: m ,n ,i bounds: bound N + 1 bound N + 2 dependentBound I ::= when 0 = m --> nf (in : unit <- read InShare$-OK [m ,n ,i ],return ());;
    otherwise --> nf ((s : unit <- read InShare$Sum-OK [m - 1 ,n ,i ])x : unit <- read InShare$-OK [m ,n ,i ],return ()))|| (family InShare$-OK [bound N + 2 bound N + 2 dependentBound
    I ]indices: m ,n ,i bounds: bound N + 2 bound N + 2 dependentBound I ::= when m = N + 1 --> nf ((s : unit <- read InShare$Sum-OK [N ,n ,i ])x : unit <- read In-OK [n ,i ],return (
    ));; when not m = N + 1 --> nf (x : unit <- read In-OK [n ,i ],return ()))
    )
)    

.

strict subproof regroupInitOK =
  group  
  fam InShareOK[fixedBound M bound N + 2 dependentBound I],
  fam InShare$-OK[fixedBound M bound N + 2 dependentBound I],
  fam InShare$Sum-OK[fixedBound M bound N + 2 dependentBound I]
in InitOK 
indices: m, n, i
bounds: fixedBound M bound N + 2 dependentBound I
.

start with real over delta

in the presence of fam In-OK[bound N + 2 dependentBound I] 
rewrite group InitOK[bound (N + 2) bound (N + 2) dependentBound I]
 to
   (family InShare$-OK[bound (N + 2) bound (N + 2) dependentBound I] 
     indices: m, n, i
     bounds: bound (N + 2) bound (N + 2) dependentBound I
::=
 x : unit <- read In-OK[n, i] ; return ()
)
||
(family InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]  
     indices: m, n, i
     bounds: bound (N + 1) bound (N + 2) dependentBound I
::=
x : unit <- read In-OK[n, i] ; return ()
)
||
(family InShareOK[bound (N + 2) bound (N + 2) dependentBound I] 
     indices: m, n, i
     bounds: bound (N + 2) bound (N + 2) dependentBound I
::=
x : unit <- read In-OK[n, i] ; return ()
)
 by induction on m bound M 
( 
case distinction on
family InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
   (
    case:(
    using group InitOK[bound M bound (N + 2) dependentBound I](
    subst fam InShare$Sum-OK[bound M bound (N + 2) dependentBound I]
     into fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
    )
    )

    case:(
      idle
    ) 
   ) then
merge cases for fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I] then
   subst fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
    into fam InShareOK[fixedBound M bound (N + 2) dependentBound I] then
   turn otherwise into neg 
    for fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
   case distinction on family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
   case: (
    subst  fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
     into  fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
   )  
   case: 
   (using group InitOK[bound M bound N + 2 dependentBound I ](
    subst fam InShare$Sum-OK[bound M bound (N + 2) dependentBound I]
     into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] ) then
    subst fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
     into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
   ) 
   ) then 
   merge cases for fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
)