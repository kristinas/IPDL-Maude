***( SpeX/Lang/IPDL

  This file is part of the SpeX-languages suite.

  Copyright : (C) 2024 IPDLMaude
  License   : GNU General Public License v2.0 or later (GPL-2.0-or-later)
  Author    : ipdlmaude@gmail.com

)

sload ../../Language.maude
sload ./Data.maude
sload ./strategies.maude

********************************************************************************

fmod IPDL/ENV is
  protecting APPROX-EQ-CONFIG .
  protecting MAP{Qid, Protocol} .
  protecting IPDL/DECL .
  protecting GRAMMAR .
  protecting SET{TypeContextElem} . 
  protecting LIST{ApproxEqConfig} .
  protecting ATERM/READ .
  protecting MAP{Qid, PairSetIO} .
  protecting MAP{Qid, IPDLEmbedding} .
  
  var L : IPDL .
  var QIS QIS' : QidSet .
  var QIL : QidList .
  var q q' : Qid .
  vars I I1 I2 VS DT CT IT RT1 RT2 : ATerm .
  var pConf pConf' : ProtocolConfig .
  var aConf aConf' crtConf : ApproxEqConfig .
  var Sigma : Signature .
  var Delta : ChannelContext .
  var Gamma Gamma' : TypeContext .
  var Ins Outs : Set{CNameBound} .
  var A : Set{BoolTerm} .
  var P P' : Protocol .
  var R1 R2 : Reaction .
  var T1 T2 : IPDLType . 
  var t1 t2 : IPDLPreType .
  var protMap protMap' : Map{Qid, Protocol} .
  var cnb : CNameBound .
  var deltaMap deltaMap' : Map{Qid, PairSetIO} .
  var w : Width .
  var l : Length .
  var embMap embMap' : Map{Qid, IPDLEmbedding} .

  var PCL1 PCL2 : List{ApproxEqConfig} .

 sort Env .
  op buildEnv_________ : 
      List{ApproxEqConfig}        *** for the approx level
   ***   List{ProtocolConfig}        *** for applying the rules, will be built by declarations
      Map{Qid, PairSetIO}   *** save all declared Deltas, as pairs Ins, Delta
      Map{Qid, Protocol}    *** save declared protocols
      Map{Qid, IPDLEmbedding} *** save declared embeddings
      Module                *** for storing the assumptions and their generated strategies
      Set{TypeContextElem}  *** for variables occuring in reactions and/or gamma in rules
      QidSet                *** names of assumptions to avoid duplicates
      TypeContext           *** for parameters, e.g. N : Nat, C : Circuit etc.
      *** Set{Qid}          *** for variables occuring in Delta in rules
      ApproxEqConfig        *** the current configuration
      -> Env [ctor frozen] .
 
  var env : Env .
  var m m' : Module .
  var TCS TCS'  : Set{TypeContextElem} .
  var PS PS' : TypeContext .
  var countb contextb : ComplexityBound .

  op getCrtConf_ : Env -> ApproxEqConfig .
  eq getCrtConf (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf) = crtConf .

  op setCrtConf__ : Env ApproxEqConfig -> Env .
  eq setCrtConf (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf) aConf 
   = (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS aConf) .

  op pushPConfig__ : Env ProtocolConfig -> Env .
  eq pushPConfig (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf) pConf
   = buildEnv (aConfig(pConf, emptyBound, emptyBound) PCL1) 
              deltaMap protMap embMap m TCS QIS PS crtConf .

  op popPConfig_ : Env -> Env .
  eq popPConfig (buildEnv (aConfig(pConf, countb, contextb) PCL1) 
     deltaMap protMap embMap m TCS QIS PS crtConf)
   = buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf . 

  op pushAConfig__ : Env ApproxEqConfig -> Env .
  eq pushAConfig (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf) aConf
   = buildEnv (aConf PCL1) deltaMap protMap embMap m TCS QIS PS crtConf .

  op popAConfig_ : Env -> Env .
  eq popAConfig (buildEnv (aConfig(pConf, countb, contextb) PCL1) deltaMap protMap embMap m TCS QIS PS crtConf)
   = buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf .  

  op getEmbMap_ : Env -> Map{Qid, IPDLEmbedding} .
  eq getEmbMap (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) = embMap .

  op setEmbMap__ : Env Map{Qid, IPDLEmbedding} -> Env .
  eq setEmbMap (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) embMap' 
   = (buildEnv PCL1 deltaMap protMap embMap' m TCS QIS PS crtConf ) .

  op getDeltaMap_ : Env -> Map{Qid, PairSetIO} .
  eq getDeltaMap (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) = deltaMap .

  op setDeltaMap__ : Env Map{Qid, PairSetIO} -> Env .
  eq setDeltaMap (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) deltaMap' 
   = (buildEnv PCL1 deltaMap' protMap embMap m TCS QIS PS crtConf ) .
  
  op getEnvParams_ : Env -> TypeContext .
  eq getEnvParams (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) = PS .

  op setEnvParams__ : Env TypeContext -> Env .
  eq setEnvParams (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) PS' = 
                   buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS' crtConf .

  op getModule_ : Env -> Module .
  eq getModule (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) = m .

  op setModule__ : Env Module -> Env .
  eq setModule (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) m' = 
                buildEnv PCL1 deltaMap protMap embMap m' TCS QIS PS crtConf  .

  op getAConfig_ : Env -> ApproxEqConfig .
  eq getAConfig (buildEnv (aConf PCL1) deltaMap protMap embMap m TCS QIS PS crtConf ) = aConf .              

  op setAConfig__ : Env ApproxEqConfig -> Env .
  eq setAConfig (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) aConf' =    
                (buildEnv (aConf' PCL1) deltaMap protMap embMap m TCS QIS PS crtConf ) .

  op getPConfig_ : Env -> ProtocolConfig .
  eq getPConfig (buildEnv (aConfig(pConf, countb, contextb) PCL1) 
                 deltaMap protMap embMap m TCS QIS PS crtConf ) = pConf .

  op setPConfig__ : Env ProtocolConfig -> Env .
  eq setPConfig (buildEnv (aConfig(pConf, countb, contextb) PCL1) 
                  deltaMap protMap embMap m TCS QIS PS crtConf ) pConf'
   = buildEnv (aConfig(pConf', countb, contextb) PCL1) 
              deltaMap protMap embMap m TCS QIS PS crtConf .

  op getPMap_ : Env -> Map{Qid, Protocol} .
  eq getPMap (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf) = protMap .

  op setPMap__ : Env Map{Qid, Protocol} -> Env .
  eq setPMap (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) protMap' = 
              buildEnv PCL1 deltaMap protMap' embMap m TCS QIS PS crtConf  .

  op setAssums__ : Env QidSet -> Env .
  eq setAssums (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) QIS' = 
                buildEnv PCL1 deltaMap protMap embMap m TCS QIS' PS crtConf  .

  op getAssums_ : Env -> QidSet .
  eq getAssums (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) = QIS .

  op setEnvVars__ : Env Set{TypeContextElem} -> Env .
  eq setEnvVars (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) TCS' = 
                 buildEnv PCL1 deltaMap protMap embMap m TCS' QIS PS crtConf  .

  op getEnvVars_ : Env -> Set{TypeContextElem} .
  eq getEnvVars (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) = TCS .

  op findProtocolInEnv__ : Env Qid -> Protocol .
  eq findProtocolInEnv (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) q = 
     if $hasMapping(protMap, q) then protMap[q] else emptyProtocol fi .

  op findDeltaInEnv__ : Env Qid -> ChannelContext .
  eq findDeltaInEnv  (buildEnv PCL1 deltaMap protMap embMap m TCS QIS PS crtConf ) q = 
     if $hasMapping(deltaMap, q) then toChannelContext (deltaMap[q]) else emptyChannelCtx fi .   
     

  op emptyEnv : -> Env .
  eq emptyEnv = buildEnv emptyAConfig empty empty empty
  (smod 'TEST is
    protecting 'STRATS .
    sorts none . 
    none none none none 
    *** rl strat sd
    none none none endsm
  ) empty none emptyTypeContext emptyAConfig .

  *** helpers and updates
  
   var H : Header .
  var IL : ImportList .
  var SS : SortSet .
  var SSDS : SubsortDeclSet .
  var OPDS : OpDeclSet .
  var MAS : MembAxSet .
  var EQS : EquationSet .
  var RLS : RuleSet .
  var SDCLS : StratDeclSet .
  var SDEFS : StratDefSet .

  op symBase__ : ProtocolConfig Protocol -> ProtocolConfig .
  eq symBase pConfig(Sigma, Delta, P, Ins, Outs, A) P'  
   = pConfig(Sigma, Delta, P', Ins, Outs, A) .

  op addHypothesis__ : BoolTerm ProtocolConfig -> ProtocolConfig .
  eq addHypothesis bt 
      pConfig(Sigma, Delta, P, Ins, Outs, A) = 
      pConfig(Sigma, Delta, P, Ins, Outs, (A, bt) )
  .             

  op addTypeToSig__ : Qid ProtocolConfig -> ProtocolConfig .
  eq addTypeToSig q 
      pConfig(Sigma (typesOf QIS), Delta, P, Ins, Outs, A) = 
      pConfig(Sigma (typesOf(QIS ; q)), Delta, P, Ins, Outs, A )
  .

  op addOpToSig____ : Qid IPDLPreType IPDLPreType ProtocolConfig -> ProtocolConfig .
  eq addOpToSig q t1 t2
      pConfig(Sigma, Delta, P, Ins, Outs, A) = 
      pConfig(Sigma (q : preToType(t1) ~> preToType(t2)), Delta, P, Ins, Outs, A )
  .  

  op addDistToSig____ : Qid IPDLPreType IPDLPreType ProtocolConfig -> ProtocolConfig .
  eq addDistToSig q t1 t2
      pConfig(Sigma, Delta, P, Ins, Outs, A) = 
      pConfig(Sigma (q : preToType(t1) ~>> preToType(t2)), Delta, P, Ins, Outs, A )
      .

  op listTypes_ : Env -> QidList .
  ceq listTypes env = list(QIS)
   if aConfig(pConfig(Sigma (typesOf QIS) , Delta, P, Ins, Outs, A), countb, contextb) 
      := getAConfig env .

  op listOps_ : Env -> QidList .
  ceq listOps env = list(listOpsAux Sigma)
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .   

  op listOpsAux_ : Signature -> QidSet .
  eq listOpsAux ((q : T1 ~> T2) Sigma) = q ; (listOpsAux Sigma) .
  eq listOpsAux Sigma = none [owise] .

  op listDists_ : Env -> QidList .
  ceq listDists env = list(listDistsAux Sigma) 
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .       

  op listDistsAux_ : Signature -> QidSet .
  eq listDistsAux ((q : T1 ~>> T2) Sigma) = q ; (listDistsAux Sigma) .
  eq listDistsAux Sigma = none [owise] .

  op listParameters_ : Env -> QidList .
  ceq listParameters env
   = listParametersAux PS 
  if PS := getEnvParams env .  

  var bd : Bounds .
  var bdl bdl' : List{Bounds} .

  op listCNB : CNameBound -> QidList .
  eq listCNB(chn q) = q .
  eq listCNB(chn (q[ntlist1])) = q '`[ (listNatTerms(ntlist1)) '`] .
  eq listCNB(fam (q[bdl])) = q '`[ listBounds(bdl) '`] .

  op listBounds : List{Bounds} -> QidList .
  eq listBounds(nil) = none .
  eq listBounds(bound nt) = 'bound (listNatTerm nt) .
  eq listBounds(fixedBound nt) = 'fixedBound (listNatTerm nt) .
  eq listBounds(dependentBound q) = 'dependentBound q .
  eq listBounds(bd bdl') = listBounds(bd) listBounds(bdl') .


  op listParametersAux_ : TypeContext -> QidList .
  eq listParametersAux emptyTypeContext = none .
  eq listParametersAux (q : typeName q') = q ': q' .
  eq listParametersAux ((q : typeName q') PS) =
     q ': q' '\n (listParametersAux PS) . 

  op listHypos_ : Env -> QidList .
  ceq listHypos env = listHyposAux A 
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .       
 

  var bt bt1 bt2 : BoolTerm .
  var nt nt1 nt2 : NatTerm .

  op listHyposAux_ : Set{BoolTerm} -> QidList .
  eq listHyposAux empty = none .
  eq listHyposAux bt = listBoolTerm bt .
  eq listHyposAux (bt, A) = (listBoolTerm bt) '\n (listHyposAux A) .

  op listBoolTerm_ : BoolTerm -> QidList .
  eq listBoolTerm falseBT = 'false .
  eq listBoolTerm trueBT = 'true .
  eq listBoolTerm (neg bt) = 'not listBoolTerm bt .
  eq listBoolTerm (bt1 conj bt2) = listBoolTerm bt1 '\s 'and listBoolTerm bt2 .
  eq listBoolTerm (bt1 disj bt2) = listBoolTerm bt1 '\s 'or listBoolTerm bt2 .
  eq listBoolTerm (nt1 =T= nt2) = listNatTerm nt1 '= listNatTerm nt2 .
  eq listBoolTerm (nt1 <T nt2) = listNatTerm nt1 '< listNatTerm nt2 .
  eq listBoolTerm (nt1 <=T nt2) = listNatTerm nt1 '<= listNatTerm nt2 .
  eq listBoolTerm (apply q nt ) = q '`(  (listNatTerm nt)  '`) .

  var  n : Nat .
  var ntlist1 ntlist2 : List{NatTerm} .

  op listNatTerm_ : NatTerm -> QidList .
  eq listNatTerm qidAsTerm(q) = q .
  eq listNatTerm natAsTerm(n) = qid(n) .
  eq listNatTerm (nt1 + nt2) = (listNatTerm nt1) '+ (listNatTerm nt2) .
  eq listNatTerm (nt1 - nt2) = (listNatTerm nt1) '- (listNatTerm nt2) .
  eq listNatTerm (nt1 * nt2) = (listNatTerm nt1) '* (listNatTerm nt2) .
  eq listNatTerm (fun q nt) = q '`( (listNatTerm nt) '`) .

  op listNatTerms : List{NatTerm} -> QidList .
  eq listNatTerms(nt) = listNatTerm nt .
  eq listNatTerms(ntlist1 ntlist2) = listNatTerms(ntlist1) listNatTerms(ntlist2) .

  op listChannels_ : Env -> QidList .
  ceq listChannels env = listChannelsAux Delta 
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .       


  op listChannelsAux_ : ChannelContext -> QidList .
  eq listChannelsAux emptyChannelCtx = nil .
  eq listChannelsAux (Delta (chn q :: T1)) = q '\n (listChannelsAux Delta) .  
  eq listChannelsAux (Delta (fam (q[bdl]) :: T1)) = 
     q '`[ listBounds(bdl) '`] '\n (listChannelsAux Delta) .

  op listProtocols_ : Env -> QidList .
  ceq listProtocols env = 
     list(listProtocolsAux protMap)
   if protMap := getPMap env .   

  op listProtocolsAux_ : Map{Qid, Protocol} -> QidSet .
  eq listProtocolsAux empty = none .
  eq listProtocolsAux (protMap, q |-> P) = q ; (listProtocolsAux protMap) . 

  op getCrtProtocol_ : Env -> Protocol .
  ceq getCrtProtocol env = P
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .       
    

  op getPConfProtocol_ : List{ApproxEqConfig} -> Protocol .
  eq getPConfProtocol 
      (aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) PCL1) 
   = P .       

  op listAssums_ : Env -> QidList .    
  ceq listAssums env = 
     show-qids(list(QIS))
   if QIS := getAssums env .

  op getChannel__ : Env CNameBound -> Protocol .
  ceq getChannel env cnb = getChannel P cnb 
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .

  *** generate the decls from the config .
  op decls_ : Env -> DeclList{IPDL} .
  ceq decls env =
    type-decls(Sigma) op-decls(Sigma) dist-decls(Sigma) prot-decls(protMap) 
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env 
   /\ protMap := getPMap env .

  op prot-decls : Map{Qid, Protocol} -> DeclList{IPDL} .
  eq prot-decls(empty) = nil .
  eq prot-decls((q |-> P, protMap)) =
    Decl[IPDL]{protocol q = P .} prot-decls(protMap) .

  op type-decls : Signature -> DeclList{IPDL} .
  eq type-decls((typesOf (q ; QIS)) Sigma)
    = Decl[IPDL]{type q .} type-decls((typesOf QIS) Sigma) .
  eq type-decls((typesOf none) Sigma) = type-decls(Sigma) .
  eq type-decls(Sigma) = nil [owise] .

  op op-decls : Signature -> DeclList{IPDL} .
  eq op-decls((q : T1 ~> T2) Sigma)
   = Decl[IPDL]{function q : typeToPre(T1) -> typeToPre(T2) .} op-decls(Sigma) .
  eq op-decls(Sigma) = nil [owise] .

  op dist-decls : Signature -> DeclList{IPDL} .
  eq dist-decls((q : T1 ~>> T2) Sigma)
   = Decl[IPDL]{distribution q : typeToPre(T1) -> typeToPre(T2) .} dist-decls(Sigma) .
  eq dist-decls(Sigma) = nil [owise] .

  op addProtocol___ : Qid Protocol Map{Qid, Protocol} -> Map{Qid, Protocol} .
  eq addProtocol q P protMap = (protMap, q |-> P) .

  op addInput___ : CNameBound IPDLType ProtocolConfig -> ProtocolConfig .
  eq addInput cnb T1 
     pConfig(Sigma, Delta, P, Ins, Outs, A) =
     pConfig(Sigma,
             Delta ( cnb :: T1),
             P,
             insert(cnb, Ins),
             Outs,
             A
            )     
  .           
 
  op addOutput___ : CNameBound IPDLType ProtocolConfig -> ProtocolConfig .
  eq addOutput cnb T1 pConfig(Sigma, Delta, P, Ins, Outs, A) =
     pConfig(Sigma,
             Delta ( cnb :: T1),
             P,
             Ins,
             insert(cnb, Outs),
             A
            )    
  . 

 op addImport__ : Module Qid -> Module .
 eq addImport (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) q =
  (smod H is
    (IL
    including q . 
    )
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) . 

endfm

fmod IPDL/LANGUAGE is
  protecting IPDL/LID .
  protecting IPDL/ENV .
  protecting GRAMMAR .
  protecting PROTOCOL .

  op grammar : IPDL -> Grammar .
  eq grammar(IPDL)
   = grammar 'IPDL/Syntax is
      'ApproxProof ::=
          just 'StrictProof
        | "_ then-approx _" : 'ApproxProof 'ApproxProof [prec(47) assoc]
        | "sym-approx from _ (_)" : 'IPDLProtocol 'ApproxProof [none]
        | "use approx assumption _ on _" : 'AssumName 'CNameBoundList [none] 
        | "use approx assumption _ " : 'AssumName [none] 
        | "call-approx _" : 'SName [none]
        | "in the presence of _ rewrite _ to _ by generalization of _"
           : 'CNameBoundList 'RuleTarget 'Cases 'SName [none]
        | "approx generalize for _ ( _ )" 
           : 'CNameBound 'ApproxCongrProof [none]
      'ApproxCongrProof ::= 
         "approx embed _ along _ with inputs _ ( _ ) " 
           : 'IPDLProtocol 'EmbedName 'CNameBoundList 'ApproxCongrProof [none]
        | "use approx axiom _" : 'AssumName [none]  
        | "approx case distinction on _ ( _ )"
           : 'CNameBound 'ApproxCongrProofCaseList [none] 
      'StrictProof 
         ::=
            "start with _ over _" : 'PName 'DName [none]
          | "merge cases for _" : 'CNameBound [none] 
          | "merge case _ = _ with otherwise for _ " : 'CName 'NatTerm 'CNameBound [none]  
          | "absorb _" : 'CNameBound [none]
          | "group-absorb _" : 'RuleTarget [none]
          | "restructure _" : 'IPDLProtocol [none]
          | lit "bring declarations of hidden channels in front"
          | "rename _ in _" : 'QidPairList 'CNameBound [none]
          | "rename variables _ of _" : 'QidPairList 'CNameBound [none]
          | "combine _" : 'CNameBound [none]
          | "combine _ into families" : 'CNameBound [none]
          | "compose _ with _ in group" : 'CNameBound 'CNameBound [none] 
          | "decompose _ with _" : 'CNameBound 'CNameBound [none]
          | "turn neg into otherwise for_" : 'CNameBound [none] 
          | "turn otherwise into neg for_" : 'CNameBound [none]  
          | "drop read _ from _" : 'CNameBound 'CNameBound [none]
          | "drop read branch _ of _ from _" : 'WhenCond 'CNameBound 'CNameBound [none]
          | "fold _ into _" : 'CNameBound 'CNameBound [none]
          | "subst _ into _" : 'CNameBound 'CNameBound [none]
          | "subst _ into _ at _" : 'CNameBound 'CNameBound 'VId [none]
          | "subst branch _ of _ into _" : 'WhenCond 'CNameBound 'CNameBound [none]
          | "subst branch _ of _ into _ at _" : 'WhenCond 'CNameBound 'CNameBound 'VId [none]
          | "use assumption _ on _" : 'AssumName 'CNameBoundList [none]
          | "use expression assumption _ on _ at _" : 'AssumName 'CNameBoundList 'NatTerm [none]
          | "_then_" : 'StrictProof 'StrictProof  [prec(45) assoc]
          | "sym from _ ( _ )" : 'IPDLProtocol 'StrictProof [none]
          | "sym from _ over _ ( _ )" : 'IPDLProtocol 'ChnCtxt 'StrictProof [none]
          | lit "todo"
          | lit "idle"
          | "case distinction on _ (_)" : 'RuleTarget 'ProofCaseList [none]
          *** | "try case distinction on _ : (case: _)" : 'RuleTarget 'StrictProof [none]
          *** | "try case distinction on _ : (case: _ done) (case: _)" : 'RuleTarget 'StrictProof 'StrictProof [none]
          | "in the presence of _ rewrite _ to _ by induction on _ bound _ (_)" :
              'CNameBoundList 'RuleTarget 'Cases 'NatTerm 'NatTerm 'StrictProof  [none]
          | "rewrite _ to _ by induction on _ bound _ (_)" :
              'RuleTarget 'Cases 'NatTerm 'NatTerm 'StrictProof  [none]   
          | "try in the presence of _ rewrite _ to _ by induction on _ bound _ : _" :
               'CNameBoundList 'RuleTarget 'Cases 'NatTerm 'NatTerm 'StrictProof  
              [prec(46)]    
          | "try rewrite _ to _ by induction on _ bound _ : _" :
               'RuleTarget 'Cases 'NatTerm 'NatTerm 'StrictProof  
              [prec(46)]        
          | "try sym from _ : _ done "  : 'IPDLProtocol 'StrictProof [none]
          | "try sym from _ : _ "  : 'IPDLProtocol 'StrictProof [prec(46)]
          | "try sym from _ over _ : _ " 
              : 'IPDLProtocol 'ChnCtxt 'StrictProof [prec(46)]    
          | "split _ on first index" : 'CNameBound [prec(31)]
          | "split _ on first index inside _ " : 'CNameBound 'RuleTarget [prec(31)]
          | "split _ on second index" : 'CNameBound [prec(31)]
          | "unsplit _" : 'CNameIndex [prec(31)]
          | "add internal family _ indices: _ bounds: _ typed: _ assigned: _" 
             : 'CName 'NatTermList 'BoundList 'IPDLPreType 'Cases
            [none]
          | "add internal channel _ typed: _ assigned: _" 
             : 'CNameIndex 'IPDLPreType 'Cases [none]
          | "on branch _ of _ (_)" : 'BoolTerm 'RuleTarget 'StrictProof 
          | "remove only branch of _" : 'CNameBound 
            [none] 
          | "try on branch _ of _ : _" : 'BoolTerm 'RuleTarget 'StrictProof  [none] 
          | "try on branch _ of _ : _ done" : 'BoolTerm 'RuleTarget 'StrictProof  [none] 
          | "move _ on each branch of _" : 'RuleTarget 'RuleTarget [none]   
          | "diverge on _ with _ var _ " : 'CNameBound 'CNameBound 'VId [none]
          | "diverge on _ with branch _ of _ var _ " : 'CNameBound 'BoolTerm  'CNameBound 'VId [none]
          | "reverse subst _ in _ using _" : 'CNameBound 'CNameBound 'CNameBound [none]
          | "subst or diverge _ into _ var _" : 'CNameBound 'CNameBound 'VId [none]
          | "on reaction of _ ( _)" : 'CNameBound 'ReactionProof [none] 
          | "on all branches of _ split _ on first index" : 'CNameBound 'CNameBound [none]
          | "on all branches of _ split _ on second index" : 'CNameBound 'CNameBound [none]
          | "group _ in _ indices: _ bounds: _" : 'CNameBoundList 'PName 'NatTermList 'BoundList [none]
          | "call _" : 'SName 
          | "use lemma _ trust" : 'SName 
          | "use lemma _ run" : 'SName 
          | "ungroup _" : 'CNameBound 
          | "using _ ( _ )" : 'RuleTarget 'StrictProof [none]
          | "using branch _ of _ ( _ )" : 'WhenCond 'RuleTarget 'StrictProof [none]
          | "sym var _ terms _ diverge _ into _ var _ " : 
             'VId 'NatTermList 'CNameBound 'CNameBound 'VId [none] 
          | lit "save current configuration" [none]  
          | "split _ inside _ " : 'CNameBound 'RuleTarget [none] 
          | "unsplit _ and _ " : 'CNameBound 'CNameBound [none]
          | "unsplit _ and _ inside _ " : 'CNameBound 'CNameBound 'RuleTarget [none]
          | "unit-ext on _ at _ " : 'CNameBound 'NatTerm [none]
          | "rename indices to _ in _" : 'NatTermList 'CNameBound [none]
          | "remove _ from _" : 'CNameBound 'RuleTarget [none]
          | "change name _ to _ " : 'CNameBound 'CName [none]
          | "focus _ (_)" : 'CNameBoundList 'StrictProof [none]
          | "use assumptions for _ in _" : 'VId 'CNameBound [none]
          | "remove and merge _ from _" : 'CNameBound 'RuleTarget [none]
          | "merge case for _ and _ into group _" : 'CNameBound 'CNameBound 'CName [none]
          | "extract _ from _ into group _" : 'CNameBoundList 'RuleTarget 'CName [none]
          | "discard branch _ of _ " : 'BoolTerm 'CNameBound [none]
          | "fix index for _" : 'CNameBound [none]
      'ReactionProof   
        ::= "if-ext on _" : 'VId 
          | lit "idle"
         | "_then_" : 'ReactionProof 'ReactionProof  [prec(45) assoc]  
      'TopDecl 
         ::=
            just 'Import
          | just 'TypeDecl
          | just 'OpDecl
          | just 'DistDecl
          | just 'EmbedDecl
         *** | just 'InDecl
         *** | just 'OutDecl
          | just 'DeltaDecl
          | just 'PDecl
          | just 'AssumDecl
          | just 'ParamDecl
          | just 'HypoDecl
          | just 'SubProofDecl
          | just 'ApproxAssumDecl
          | just 'LemmaDecl
       'Import 
         ::= "import _ ." : 'ModuleName
       'ModuleName
         ::= token "mName" 
        'LemmaDecl 
         ::= "lemma _ = _ => _ : _ ."
           : 'SName 'IPDLProtocol 'IPDLProtocol  'StrictProof [none]
        'SubProofDecl 
         ::= "strict subproof _ = _ ." : 'SName 'StrictProof [none]
           | "approx subproof _ = _ ." : 'SName 'ApproxProof [none]  
         'SName 
          ::= token "sname" 
        'ApproxAssumDecl 
         ::= "approx-assumption _ using _ : _ ; _ ; _ |= _ = _ ."
           : 'AssumName 'QList 'ChnCtxt 'CNameBoundList 'BoolTermList 
             'IPDLProtocol 'IPDLProtocol [none]  
         *** approx-assumption X using varsInProtocols : Delta ; Ins ; A |= P1 = P2 .
        'AssumDecl 
         ::= "reaction-assumption _ using _ : _ ; _ ; _ |= _ = _ ." 
              : 'AssumName 'QList 'ChnCtxt 'TypeCtxt 'QList 
                'IPDLReaction 'IPDLReaction [none] 
              *** assumption A using vars : Delta ; Gamma ; Ins |= R1 = R2 . 
            | "expression-assumption %manual _ using _ : _ |= _ = _ ." :
               'AssumName 'QList 'TypeCtxt 'IPDLExpr 'IPDLExpr [none]
            | "expression-assumption %automatic _ using _ : _ |= _ = _ ." :
               'AssumName 'QList 'TypeCtxt 'IPDLExpr 'IPDLExpr [none]
            | "protocol-assumption _ using _ : _ ; _ ; _ |= _ = _ ."
           : 'AssumName 'QList 'ChnCtxt 'CNameBoundList 'BoolTermList 
             'IPDLProtocol 'IPDLProtocol [none]     
        'DeltaDecl 
         ::= "channel context _ = _ ." :
             'DName 'ChannelDeclList [none]
         'EmbedDecl 
         ::= "embedding _ from _ to _ = _ ." : 
             'EmbedName 'DName 'DName 'CNameMap [none]      
         'EmbedName 
         ::= token "embedName" [none]
         'CNameMap 
         ::= "_ |-> _ " : 'CNameIndex 'CNameIndex [prec(10)]
           | lit "emptyCNameMap"    
           | "_ ; _ " : 'CNameMap 'CNameMap [assoc prec(20)]
        'ChannelDecl 
         ::= 
            "input _ : _ " : 'CFName 'IPDLPreType [prec(10)]
          | "output _ : _ " : 'CFName 'IPDLPreType [prec(10)] 
         'ChannelDeclList 
         ::= just 'ChannelDecl 
          |  "_ ; _" : 'ChannelDeclList 'ChannelDeclList [assoc prec (20)]
        'AssumName 
         ::= token "assumName" [exclude("%manual" "%automatic")]
        'AssumOption 
         ::= lit "manual"
           | lit "automatic" 
        'ChnCtxt 
         ::= just 'TypedChn
          | "_ _" : 'ChnCtxt 'ChnCtxt [assoc]
          | lit "emptyCCtxt"
          | lit "savedDelta"
          | just 'DName
        'TypedChn 
         ::= "( _ :: _ )" : 'CNameBound 'IPDLPreType [none]
        'TypeCtxt 
         ::= just 'TypedVar
          | "_ _" : 'TypeCtxt 'TypeCtxt [assoc]
          | lit "emptyTCtxt"
        'TypedVar 
         ::= "_ : _ " : 'VId 'IPDLPreType [none] 
        'ApproxCongrProofCase 
         ::= "case: (_)" : 'ApproxCongrProof
        'ApproxCongrProofCaseList 
         ::= just 'ApproxCongrProofCase
          | "_ _" : 'ApproxCongrProofCaseList 'ApproxCongrProofCaseList [assoc]
        'ProofCase 
         ::= "case: (_)" : 'StrictProof
        'ProofCaseList 
         ::= just 'ProofCase
          | "_ _" : 'ProofCaseList 'ProofCaseList [assoc]
        'QidPair 
         ::= "_to_" : 'VId 'VId  [prec(31)]
        'QidPairList 
         ::= just 'QidPair 
           | "_,_" : 'QidPairList 'QidPairList [assoc]
        'QList
         ::= bubble "qlist" [exclude(":" "|=" ")" "nil"
           "todo" "fixedBound" "dependentBound" "bound" "bounds:")]
          | lit "nil"       
       'ParamDecl 
         ::= "parameter _ : _ ." : 'ParamName 'IPDLPreType [none]   
       'TypeDecl
         ::= "type _ ." : 'TDId
       'HypoDecl
         ::= "hypothesis _ ." : 'BoolTerm  [prec(23)]
       'OpDecl
         ::= "function _ : _ -> _ ." : 'FName 'IPDLPreType 'IPDLPreType [none]  
       'IPDLPreType 
         ::= just 'TId
          | " _ * _ " : 'IPDLPreType 'IPDLPreType [none] 
          | "( _ )" : 'IPDLPreType [none]
       'FName 
         ::= token "fname"  [exclude ("bound" "dependentBound" "fixedBound" "not")] 
       'PName 
         ::= token "pname" 
         [exclude ("where" "not" "emptyProtocol" "currentProtocol" "savedProtocol"
                   "(" ")" "[" "||" "new" "newfamily" "family")]
       'ParamName 
         ::= token "paramName"    
       'DName 
         ::= token "dname" [exclude ("savedDelta" "emptyCCtxt" "(" "then" "and")]   
       'TDId
         ::= token "tdid" 
       'TId
         ::= token "tid" [exclude(";")]
       'DistDecl
         ::= "distribution _ : _ -> _ ." : 'DName 'IPDLPreType 'IPDLPreType [none] 
       'VId
         ::= token "vid" [exclude("True" "False" "()" ",")]
       'IPDLExpr 
         ::= just 'VId     
          | lit "True" 
          | lit "False"
          | lit "()" 
          | "_ ( _ )" : 'FName 'IPDLExpr [prec(19)]
          | "(_ , _)"  : 'IPDLExpr 'IPDLExpr [none]
          | "fst _" : 'IPDLExpr 
          | "snd _" : 'IPDLExpr 
       'IPDLReaction  
         ::=  "return _" : 'IPDLExpr [prec(19)]
          *** | "samp _" : 'DName
          | "samp _ ( _  )" : 'DName 'IPDLExpr [none]
          | "read _" : 'CNameIndex [prec (19)]
          | "read" : 'CNameIndex [none]
          | "if _ then _ else _ " : 'IPDLExpr 'IPDLReaction 'IPDLReaction [prec (21)]
          | " _ : _ <- _ ; _" : 'VId 'IPDLPreType 'IPDLReaction 'IPDLReaction [prec(20)]
          | "nf(_, _)" : 'BindList 'IPDLReaction [none]
          | "preNF(_, _)" : 'BindList 'IPDLReaction [none] 
          | "( _ )" : 'IPDLReaction [none]
       'BindList
         ::= just 'BindReaction
          | "_ _" : 'BindList 'BindList [assoc]
          | lit "nil"
       'BindReaction
         ::= "_:_<- read _" : 'VId 'IPDLPreType 'CNameIndex [none]
          | "_:_<~ _" : 'VId 'IPDLPreType 'IPDLReaction [none] 
       'CName 
         ::= token "cname" [exclude("then" "todo")]
          *** |  "__" : 'CName 'CScripts [none]
        'RuleTarget ::=
            "channel _" : 'CNameIndex 
          | "family _" : 'FamilyName *** was 'FamilyNameBound
          | "group _" : 'FamilyName *** was 'FamilyNameBound
        'CNameIndex ::=   
            just 'CName
          | "_ [ _ ]" : 'CName 'NatTermList [prec(1)] 
        'BoundedIndex ::= 
            "_<_ " : 'VId 'NatTerm [prec(11)]
          | "_=_ " : 'VId 'NatTerm [prec(11)]
        'BoundedIndexList ::= 
            just 'BoundedIndex
          | "_,_" : 'BoundedIndexList 'BoundedIndexList [assoc]
        'BasicFamilyNameBound ::= 
            "_ [ _ ]" : 'CName 'BoundedIndexList [prec(1)]  
       'CScripts
         ::= bubble "cscripts" [min-tokens(4) max-tokens(4) exclude("." ":" "then" "todo")]
       'IPDLProtocol 
         ::= lit "emptyProtocol"
          | lit "currentProtocol"
          | lit "savedProtocol"
          | "( _ )" : 'IPDLProtocol [none]
          | just 'PName
          | "_ ::= _" : 'CNameIndex 'Cases [prec(23) format('d 'd 'd 'd)]
          | "family _ indices: _ bounds: _ ::= _" : 
              'FamilyName 'NatTermList 'BoundList 'Cases [prec(23)]
                *** the list of natterms should only contain qids
          | "_ || _" : 'IPDLProtocol 'IPDLProtocol [assoc prec(31) format('d 'd 'd 'd)]
          | "new _ : _ in _" : 'CNameIndex 'IPDLPreType 'IPDLProtocol 
             [prec(35) format('o 'b 'd 'r 'o 'n 'd)] 
          | "newfamily _ indices: _ bounds: _  : _ in _" 
            : 'FamilyName 'NatTermList 'BoundList 'IPDLPreType 'IPDLProtocol  
             [prec(35)]
          | "newNF(_, _)" : 'TypedCNameList 'IPDLProtocol [none]
          | "_where_" : 'IPDLProtocol 'LocalDeclList [prec(34)]
          | "change _ with _ in _" : 'CNameBound 'Cases 'IPDLProtocol [prec(36)]
          | "extend _ with internal channel _ typed: _ assigned: _" :
            'IPDLProtocol 'CNameIndex 'IPDLPreType 'Cases [prec(36)]
          | "extend _ with internal family _ indices: _ bounds: _ typed: _ assigned: _" :
            'IPDLProtocol 'CName 'NatTermList 'BoundList 'IPDLPreType 'Cases [prec(36)]  
          | "create group _ indices: _ bounds: _ from _ in _"  : 
             'PName 'NatTermList 'BoundList 'CNameBoundList 'IPDLProtocol [prec(36)]
          | "branch _ of _ change _ with _ in _" :
             'WhenCond 'CNameBound 'CNameBound 'Cases 'IPDLProtocol [prec(36)]   
          | "gather _ from _ hiding _" : 
             'CNameBoundList 'IPDLProtocol 'CNameBoundList [prec(36)]  
          | "embed(_, _)" : 'IPDLProtocol 'EmbedName [none]    
        'LocalDeclList ::= 
            just 'LocalDecl 
          | "_and_" : 'LocalDeclList 'LocalDeclList [assoc prec(33)]  
         'LocalDecl ::=
            "_=_" : 'PName 'IPDLProtocol [prec(32)]
        'TypedCName
         ::= "<_ : _>" : 'CName 'IPDLPreType [none]
           | "{ _ _ : _ }" : 'FamilyName 'NatTermList 'IPDLPreType [prec(10)]
        'TypedCNameList
         ::= just 'TypedCName
          | lit "empty"
          | "_ _" : 'TypedCNameList 'TypedCNameList [assoc] 
       'PDecl 
         ::= "protocol _ = _ ." : 'PName 'IPDLProtocol [none]
           | "protocol _ ." : 'PName [none]
       'NatTerm 
         ::= just 'NId 
           | "_ + _" : 'NatTerm 'NatTerm [assoc prec(9)]
           | "_ - _" : 'NatTerm 'NatTerm [prec(9)]
           | "_ * _" : 'NatTerm 'NatTerm [assoc prec(7)]
           | "_ ( _ )" : 'FName 'NatTerm [prec(5)]
           | "( _ )" : 'NatTerm [none]
       'NId ::= 
           token "nid" [exclude("+" "," "-" "*" "(" ")" "[" "]" "bound" "fixedBound" "dependentBound"
                              "bounds:" )]      
       'NatTermList ::=
            just 'NatTerm
          | "_,_" : 'NatTermList 'NatTermList [assoc]    
       'ConstId ::=
           token "cid" [exclude("bound" "fixedBound" "dependentBound" "+" "-" "*")] 
        'BoolTerm ::=
             lit "falseBT"
           | lit "trueBT"
           | "_ = _" : 'NatTerm 'NatTerm [prec(11)]        
           | "_ < _" : 'NatTerm 'NatTerm [prec(11)]        
           | "_ <= _" : 'NatTerm 'NatTerm [prec(11)]        
           | "_ and _" : 'BoolTerm 'BoolTerm [prec(15)]        
           | "_ or _" : 'BoolTerm 'BoolTerm [prec(15)] 
           | "not _" : 'BoolTerm [prec(13)]        
           | "_ ( _ )" : 'PredName 'NatTerm [prec(11)]
       'BoolTermList ::=
              just 'BoolTerm 
            | lit "no assumptions" 
            | "_,_" : 'BoolTerm 'BoolTerm [assoc]   
       'PredName ::=
           token "predId"  [exclude("not" "when")]
       'Bound ::=
            "bound _" : 'NatTerm 
          | "fixedBound _" : 'NatTerm  
          | "dependentBound _" : 'FName    
       'BoundList ::=
            just 'Bound 
          | "_ _" : 'BoundList 'BoundList [assoc]    
       'BasicFamilyName ::=
             "_ [ _ ]" : 'CName 'BoundList [prec(1)]
       'BasicFamilyNameBound ::= 
             "_ [ _ ]" : 'CName 'BoundedIndexList [prec(1)]       
       'FamilyName ::=
           just 'BasicFamilyName
         | "_ and _ " : 'BasicFamilyName 'BasicFamilyName [prec(2)]
       'FamilyNameBound ::=
           just 'BasicFamilyNameBound
         | "_ and _ " : 'BasicFamilyNameBound 'BasicFamilyNameBound [prec(2)]   
       'CFName ::= 
            just 'CNameIndex
          | just 'FamilyName *** was 'FamilyNameBound       
       'Command
         ::= lit "show-types" [format('b 'o)]
          |  lit "show-ops" [format('b 'o)]
          |  lit "show-dists" [format('b 'o)]
          |  lit "show-channels" [format('b 'o)]
          |  lit "show-parameters" [format('b 'o)]
          |  lit "show-assums" [format('b 'o)]
          |  lit "show-protocols" [format('b 'o)]
          |  lit "show-hypotheses" [format('b 'o)]
          |  lit "show all" [format('b 'd 'o)]
          |  lit "show-bounds" [format('b 'o)]
          | "show-protocol _" : 'PName
          | "check-proof _" : 'PName
          | "get-channel _" : 'CName
          | lit "current-protocol" [format('b 'o)]
          | lit "enable-typechecking" [format('b 'o)]
          | lit "disable-typechecking" [format('b 'o)]
       'CNameBound ::=
             "chn _" : 'CNameIndex [prec(3)]
            | "fam _" : 'FamilyName [prec(3)]
         'CNameBoundList ::=
              just 'CNameBound
            | lit "no inputs"
            | lit "savedOuts"
            | "_,_" : 'CNameBoundList 'CNameBoundList [assoc prec(5)] 
        'WhenCond ::= 
            lit "otherwise"
          | "when _" : 'BoolTerm [prec(19)]
         'When ::=
           "_ --> _ " : 'WhenCond 'Cases [prec(20)]
         'WhenList ::=
              lit "emptyWhen"
            | "( _ )" : 'WhenList [none]  
            | just 'When 
            | "_ ;; _" : 'WhenList 'WhenList [assoc prec(21)]
         'Cases ::=
              just 'IPDLReaction   
            | just 'IPDLProtocol
            | just 'WhenList 

     endgr .
endfm

*** ----------------------------------------------------------------------------

view IPDL from LANGUAGE to IPDL/LANGUAGE is
  sort Lid to IPDL .
  op Lid to IPDL .
endv

********************************************************************************

fmod IPDL/READ is
  protecting IPDL/ENV .
  protecting IPDL/DECL .
  protecting IPDL/CMD .
  protecting IPDL/PROOF .
  protecting ATERM/READ .
  pr LIST-AND-SET{CNameBound} . 
  pr LIST-AND-SET{BoolTerm} . 

  var L : IPDL .
  var QIL : QidList .
  vars I T T1 T2 P I1 I2 I3 I4 I5 I6 DT CT IT R1 R2 VS P1 P2 IS AS : ATerm .
  var q : Qid .
  var env : Env .
  var Sigma : Signature .
  var Delta : ChannelContext .
  var Ins Outs : Set{CNameBound} .
  var A : Set{BoolTerm} .
  var protMap : Map{Qid, Protocol} .

  *** helper
  sort Paired .
  op _paired_ : List{NatTerm} List{Bounds} -> Paired [ctor] .

  vars ntl1 ntl2 : List{NatTerm} .
  vars bdl1 bdl2 : List{Bounds} .

  op read-boundedIndices : IPDL ATerm -> Paired .
  eq read-boundedIndices(L, {'_=_[I1, I2] : 'BoundedIndex}) 
   = (qidAsTerm read-qid(I1)) paired (fixedBound read-natTerm(L, I2)) .  
  eq read-boundedIndices(L, {'_<_[I, {'_`(_`)[I1, I2] : 'NatTerm}] : 'BoundedIndex})
   = (qidAsTerm read-qid(I1)) paired (dependentBound read-qid(I1)) .  
  eq read-boundedIndices(L, {'_<_[I1, I2] : 'BoundedIndex})  
   = (qidAsTerm read-qid(I1)) paired (bound read-natTerm(L, I2)) . 
  ceq read-boundedIndices(L, {'_`,_[I1, I2] : 'BoundedIndexList}) 
   = (ntl1 ntl2) paired (bdl1 bdl2) 
  if ntl1 paired bdl1 := read-boundedIndices(L, I1)
  /\ ntl2 paired bdl2 := read-boundedIndices(L, I2) [owise] .  


  op read-decl : IPDL Env ATerm  ~> Decl{IPDL} .
  eq read-decl(L, env, {'hypothesis_.[I] : 'HypoDecl})
  = Decl[L]{hypothesis read-boolTerm(L, I) .} .
  eq read-decl(L, env, {'type_.[I] : 'TypeDecl})
  = Decl[L]{type read-qid(I) .} .
  eq read-decl(L, env, {'function_:_->_.[I, T1, T2] : 'OpDecl} )
   = Decl[L]{function read-qid(I) : read-type(L, T1) -> read-type(L, T2) .} . 
  eq read-decl(L, env, {'distribution_:_->_.[I, T1, T2] : 'DistDecl} )
   = Decl[L]{distribution read-qid(I) : read-type(L, T1) -> read-type(L, T2) .} . 
  eq read-decl(L, env, {'channel`context_=_. [I1, I2] : 'DeltaDecl})
   = Decl[L]{channel context read-qid(I1) = 
              read-channelDeclList(L, emptyChannelCtx pairSetIO emptyChannelCtx, I2) .} .
  eq read-decl(L, env, {'embedding_from_to_=_. [I, I1, I2, I3] : 'EmbedDecl} ) 
   = Decl[L]{embedding read-qid(I) from read-qid(I1) to read-qid(I2) = read-cNameMap(L, I3) .} .           
***   ceq read-decl(L, env, {'input_:_.[I, T1] : 'InDecl} )
***    = Decl[L]{input (chn read-cNameIndex(L, I)) : read-type(L, T1) .} 
***   if I :: 'CName . 
***   ceq read-decl(L, env, {'input_:_.[I, T1] : 'InDecl} )
***    = Decl[L]{input (chn read-cNameIndex(L, I)) : read-type(L, T1) .} 
***   if I :: 'CNameIndex .
***   ceq read-decl(L, env, {'input_:_.[I, T1] : 'InDecl} )
***    = Decl[L]{input (fam read-familyName(L, I)) : read-type(L, T1) .} 
***   if I :: 'FamilyName .
  eq read-decl(L, env, {'parameter_:_.[I, T1] : 'ParamDecl} )
   = Decl[L]{parameter read-qid(I) : read-type(L, T1) .} .  
***   ceq read-decl(L, env, {'output_:_.[I, T1] : 'OutDecl} )
***    = Decl[L]{output (chn read-cNameIndex(L, I)) : read-type(L, T1) .} 
***   if I :: 'CName . 
***   ceq read-decl(L, env, {'output_:_.[I, T1] : 'OutDecl} )
***    = Decl[L]{output (chn read-cNameIndex(L, I)) : read-type(L, T1) .} 
***   if I :: 'CNameIndex .   
***   ceq read-decl(L, env, {'output_:_.[I, T1] : 'OutDecl} )
***    = Decl[L]{output (fam read-familyName(L, I)) : read-type(L, T1) .} 
***   if I :: 'FamilyName .   
  eq read-decl(L, env, {'protocol_=_.[I, P] : 'PDecl} )
   = Decl[L]{protocol read-qid(I) = read-protocol(L, env, P) .} . 
  eq read-decl(L, env, {'protocol_.[I] : 'PDecl})
   = Decl[L]{protocol read-qid(I) .} .
  eq read-decl(L, env, {'import_.[I] : 'Import} )
   = Decl[L]{import read-qid(I) .} . 
  eq read-decl(L, env, 
      {'approx-assumption_using_:_;_;_|=_=_.[I, VS, DT, IS, AS, P1, P2] : 'ApproxAssumDecl}) 
   = Decl[L]{approx assumption read-qid(I) using read-vars(L, VS) : 
       read-delta(L, env, DT) ; 
       makeSet(read-cNameBoundList(L, env, IS)) ; 
       read-boolTermList(L, AS) |= 
       read-protocol(L, env, P1) = 
       read-protocol(L, env, P2) .} .   
  eq read-decl(L, env, 
      {'protocol-assumption_using_:_;_;_|=_=_.[I, VS, DT, IS, AS, P1, P2] : 'AssumDecl}) 
   = Decl[L]{protocol-assumption read-qid(I) using read-vars(L, VS) : 
       read-delta(L, env, DT) ; 
       makeSet(read-cNameBoundList(L, env, IS)) ; 
       read-boolTermList(L, AS) |= 
       read-protocol(L, env, P1) = 
       read-protocol(L, env, P2) .} .         
  eq read-decl(L, env, {'reaction-assumption_using_:_;_;_|=_=_.[
     I, VS, DT, CT, IT, R1, R2] : 'AssumDecl} )
   = Decl[L]{reaction-assumption read-qid(I) using read-vars(L, VS) : 
            read-delta(L, env, DT) ; read-gamma(L, CT) ; 
            read-inputs(L, IT) |= read-reaction(L, R1) = read-reaction(L, R2) . } .
   eq read-decl(L, env, {'expression-assumption`%manual_using_:_|=_=_.[
     I, VS, DT, I1, I2] : 'AssumDecl} )
   = Decl[L]{assumption manual read-qid(I) using read-vars(L, VS) : read-gamma(L, DT)  
             |= read-expression(L, I1) = read-expression(L, I2) . } .
   eq read-decl(L, env, {'expression-assumption`%automatic_using_:_|=_=_.[
     I, VS, DT, I1, I2] : 'AssumDecl} )
   = Decl[L]{assumption automatic read-qid(I) using read-vars(L, VS) : read-gamma(L, DT)  
             |= read-expression(L, I1) = read-expression(L, I2) . } .
   eq read-decl(L, env, {'strict`subproof_=_.[I1, I2] : 'SubProofDecl})
    = Decl[L]{strict subproof read-qid(I1) = read-proof(L, env, I2) .} . 
   eq read-decl(L, env, {'lemma_=_=>_:_.[I, I1, I2, I3] : 'LemmaDecl})
    = Decl[L]{lemma read-qid(I) = 
      read-protocol(L, env, I1) => read-protocol(L, env, I2) : 
      read-proof(L, env, I3) .} . 
   eq read-decl(L, env, {'approx`subproof_=_.[I1, I2] : 'SubProofDecl})
    = Decl[L]{approx subproof read-qid(I1) = read-approxProof(L, env, I2) .} . 


  op read-cNameMap : IPDL ATerm -> CNameMap .
  eq read-cNameMap(L, {'emptyCNameMap.CNameMap : 'CNameMap}) = emptyCNameMap .
  eq read-cNameMap(L, {'_|->_ [I1, I2] : 'CNameMap}) 
   = read-cNameIndex(L, I1) to read-cNameIndex(L, I2) .
  eq read-cNameMap(L, {'_;_ [I1, I2] : 'CNameMap}) 
   = read-cNameMap(L, I1) ; read-cNameMap(L, I2) .
          
  var deltaPair : PairSetIO .
  var dIns dOuts : ChannelContext .

  op read-channelDeclList : IPDL PairSetIO ATerm -> PairSetIO .
  ceq read-channelDeclList(L, deltaPair, I) 
   = read-channelDecl(L, deltaPair, I)
  if I :: 'ChannelDecl .
  eq read-channelDeclList(L, deltaPair, {'_;_ [I1, I2] : 'ChannelDeclList}) 
   = union read-channelDeclList(L, deltaPair, I1) read-channelDeclList(L, deltaPair, I2) . 

  op read-channelDecl : IPDL PairSetIO ATerm -> PairSetIO . 
  ceq read-channelDecl(L, dIns pairSetIO dOuts, {'input_:_ [I1, T] : 'ChannelDecl})
   = (dIns (chn read-cNameIndex(L, I1) :: preToType(read-type(L, T)))) pairSetIO dOuts 
  if I1 :: 'CName .
  ceq read-channelDecl(L,  dIns pairSetIO dOuts, {'input_:_ [I1, T] : 'ChannelDecl})
   =  (dIns (chn read-cNameIndex(L, I1) :: preToType(read-type(L, T)))) pairSetIO dOuts 
  if I1 :: 'CNameIndex .
  ceq read-channelDecl(L,  dIns pairSetIO dOuts, {'input_:_ [I1, T] : 'ChannelDecl})
   = (dIns (fam read-familyName(L, I1) :: preToType(read-type(L, T)))) pairSetIO dOuts 
  if I1 :: 'BasicFamilyName .
  ceq read-channelDecl(L,  dIns pairSetIO dOuts, {'output_:_ [I1, T] : 'ChannelDecl})
   =  dIns pairSetIO ( (chn read-cNameIndex(L, I1) :: preToType(read-type(L, T))) dOuts) 
   if I1 :: 'CName .
  ceq read-channelDecl(L,  dIns pairSetIO dOuts, {'output_:_ [I1, T] : 'ChannelDecl})
   =  dIns pairSetIO ( (chn read-cNameIndex(L, I1) :: preToType(read-type(L, T))) dOuts) 
   if I1 :: 'CNameIndex .
  ceq read-channelDecl(L,  dIns pairSetIO dOuts, {'output_:_ [I1, T] : 'ChannelDecl})
   =  dIns pairSetIO ( (fam read-familyName(L, I1) :: preToType(read-type(L, T))) dOuts) 
   if I1 :: 'BasicFamilyName .   

  op read-assumOption : IPDL ATerm -> AssumOption .           
  eq read-assumOption(L, {'manual.AssumOption : 'AssumOption}) 
   = manualIPDL .
  eq read-assumOption(L, {'automatic.AssumOption : 'AssumOption}) 
   = automaticIPDL . 
 
  var countb contextb : ComplexityBound .

  op read-delta : IPDL Env ATerm -> ChannelContext .
  eq read-delta(L, env, {'emptyCCtxt.ChnCtxt : 'ChnCtxt}) = emptyChannelCtx .
  ceq read-delta(L, env, {'savedDelta.ChnCtxt : 'ChnCtxt}) = Delta 
   if aConfig(pConfig(Sigma, Delta, P:Protocol, Ins, Outs, A), 
               countb, contextb) := getCrtConf env .
  eq read-delta(L, env, {'`(_::_`)[I, T] : 'TypedChn} ) =
     read-cNameBound(L, I) :: preToType(read-type(L, T)) .
  eq read-delta(L, env, {'__[I1, I2] : 'ChnCtxt}) 
   = read-delta(L, env, I1) read-delta(L, env, I2) . 
  ceq read-delta(L, env, I) 
   = findDeltaInEnv env read-qid(I)
   if I :: 'DName . 

  op read-gamma : IPDL ATerm -> TypeContext .
  eq read-gamma(L, {'emptyTCtxt.TypeCtxt : 'TypeCtxt}) = emptyTypeContext .
  eq read-gamma(L, {'_:_[I, T] : 'TypedVar}) =
     read-qid(I) : preToType(read-type(L, T)) .
  eq read-gamma(L, {'__[I1, I2] : 'TypeCtxt}) 
   = read-gamma(L, I1) read-gamma(L, I2) .

  op read-vars : IPDL ATerm -> QidSet .
  ceq read-vars(L, {'qlist[I] : 'QList}) = 
      set(QIL) 
  if QIL := read-qids(I) . 

  op read-inputs : IPDL ATerm -> Set{CNameBound} .
  eq read-inputs(L, {'nil.QList : 'QList}) = empty .
  ceq read-inputs(L, {'qlist[I] : 'QList}) = 
      mkInputs(QIL) 
  if QIL := read-qids(I) .

  op mkInputs : QidList -> Set{CNameBound} .
  eq mkInputs(nil) = empty .
  eq mkInputs(q ; QIL) = (chn q) mkInputs(QIL) .
   
  op read-expression : IPDL ATerm -> IPDLExpression .
  eq read-expression(L, {'True.IPDLExpr : 'IPDLExpr}) = True .
  eq read-expression(L, {'False.IPDLExpr : 'IPDLExpr}) = False .
  eq read-expression(L, {'`(`).IPDLExpr : 'IPDLExpr}) = () .
  eq read-expression(L, {'fst_[I] : 'IPDLExpr}) 
   = fst (read-expression(L, I)) .
  eq read-expression(L, {'snd_[I] : 'IPDLExpr}) 
   = snd (read-expression(L, I)) . 
  eq read-expression(L, {'`(_`,_`)[I1, I2] : 'IPDLExpr}) 
  = pair(read-expression(L, I1), read-expression(L, I2)) .
  eq read-expression(L, {'_`(_`)[I1, I2] : 'IPDLExpr}) 
   = ap read-qid(I1) read-expression(L, I2) .
  eq read-expression(L, I) = read-qid(I) [owise] . *** for variables

  op read-reaction : IPDL ATerm -> Reaction .
  eq read-reaction(L, {'return_[I] : 'IPDLReaction}) 
   = return read-expression(L, I) .
  eq read-reaction(L, {'read_[I] : 'IPDLReaction}) 
   = read read-cNameIndex(L, I) .
  eq read-reaction(L, {'read[I] : 'IPDLReaction}) 
   = read read-cNameIndex(L, I) . 
  eq read-reaction(L, {'if_then_else_[I, I1, I2] : 'IPDLReaction}) 
   = if read-expression(L, I) then read-reaction(L, I1) else read-reaction(L, I2) .
  eq read-reaction(L, {'_:_<-_;_[I, T, I1, I2] : 'IPDLReaction}) 
   = read-qid(I) : preToType(read-type(L, T)) <- read-reaction(L, I1) ; read-reaction(L, I2) . 
  *** eq read-reaction(L, {'samp_[I1] : 'IPDLReaction}) 
  ***  = samp (read-qid(I1) < () > ) .  
  eq read-reaction(L, {'samp_`(_`)[I1, I2] : 'IPDLReaction}) 
   = samp (read-qid(I1) < read-expression(L, I2) > ) .
  eq read-reaction(L, {'nf`(_`,_`)[I1, I2] : 'IPDLReaction}) 
   = nf(read-binds(L, I1) , read-reaction(L, I2) ) .   
  eq read-reaction(L, {'preNF`(_`,_`)[I1, I2] : 'IPDLReaction}) 
   = preNF(read-binds(L, I1) , read-reaction(L, I2) ) . 
  eq read-reaction(L, {'`(_`) [I] : 'IPDLReaction})
   = read-reaction(L, I) . 

  op read-cNameIndex : IPDL ATerm -> ChannelName .
  eq read-cNameIndex(L, {I : 'CName}) 
   = read-qid(I) .
  eq read-cNameIndex(L, {'_`[_`][I1, I2] : 'CNameIndex}) 
   = read-qid(I1)[ read-natTerms(L, I2)] .

  op read-cNameBound : IPDL ATerm -> CNameBound .
  eq read-cNameBound(L, {'chn_[I] : 'CNameBound} ) =
     chn read-cNameIndex(L, I) .
  eq read-cNameBound(L, {'fam_[I] : 'CNameBound} ) =
     fam read-familyName(L, I) . 

  op read-cNameBoundList : IPDL Env ATerm -> List{CNameBound} .   
  eq read-cNameBoundList(L, env, {'no`inputs.CNameBoundList : 'CNameBoundList})
   = nil .
  ceq read-cNameBoundList(L, env, I) 
   =  read-cNameBound(L, I)
  if I :: 'CNameBound .
  eq read-cNameBoundList(L, env, {'_`,_[I1, I2] : 'CNameBoundList}) 
   = read-cNameBoundList(L, env, I1) read-cNameBoundList(L, env, I2) .  
  ceq read-cNameBoundList(L, env,  {'savedOuts.CNameBoundList : 'CNameBoundList} ) 
   = Outs
   if aConfig(pConfig(Sigma, Delta, P:Protocol, Ins, Outs, A), 
              countb, contextb) := getCrtConf env .

  op read-binds : IPDL ATerm -> BindList . 
  eq read-binds(L, {'nil.BindList : 'BindList}) 
   = emptyBRList .
  eq read-binds(L, {'_:_<~_[I, T, I2] : 'BindReaction}) 
   = read-qid(I) : preToType(read-type(L, T)) <~ read-reaction(L, I2) .
  eq read-binds(L, {'_:_<-`read_[I, T, I2] : 'BindReaction}) 
   = read-qid(I) : preToType(read-type(L, T)) <- read read-cNameIndex(L, I2) . 
  eq read-binds(L, {'__[I1, I2] : 'BindList}) 
   = read-binds(L, I1) read-binds(L, I2) . 
 
  var bds : List{Bounds} .
  var nlist : List{NatTerm} .
  var cn : ChannelName .
  var w : Width .
  var l : Length .

  op read-protocol : IPDL Env ATerm -> Protocol .
  eq read-protocol(L, env, {'emptyProtocol.IPDLProtocol : 'IPDLProtocol}) 
   = emptyProtocol .
  eq read-protocol(L, env, {'`(_`) [I] : 'IPDLProtocol})
   = read-protocol(L, env, I) .
  ceq read-protocol(L, env, {I : 'PName}) 
   = if $hasMapping(protMap, q) then protMap[q] else emptyProtocol fi 
  if q := read-qid(I) /\
     protMap := getPMap env . 
  eq read-protocol(L, env, {'new_:_in_[I, I1, I2] : 'IPDLProtocol}) 
   = new read-cNameIndex(L, I) : preToType(read-type(L, I1)) in read-protocol(L, env, I2) .
  eq read-protocol(L, env, {'newfamily_indices:_bounds:_:_in_[I, I1, I2, T, I3]  : 'IPDLProtocol}) 
   = newfamily read-familyName(L,I) 
               read-natTerms(L, I1) 
               read-bounds(L, I2) 
             : preToType(read-type(L, T)) 
     in read-protocol(L, env, I3)
  .  
  eq read-protocol(L, env, {'_||_[I1, I2] : 'IPDLProtocol}) 
   = read-protocol(L, env, I1) || read-protocol(L, env, I2) .
  eq read-protocol(L, env, {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol}) 
   = family 
       read-familyName(L, I) 
       read-natTerms(L, I1) 
       read-bounds(L, I2) ::= read-cases(L, env, I3)
  . 
  eq read-protocol(L, env, {'_::=_[I1, I2] : 'IPDLProtocol}) 
   = read-cNameIndex(L, I1) ::= read-cases(L, env, I2) .
  eq read-protocol(L, env, {'emptyProtocol.IPDLProtocol : 'IPDLProtocol}) = emptyProtocol .
  ceq read-protocol(L, env, {'currentProtocol.IPDLProtocol : 'IPDLProtocol})
   = P:Protocol if pConfig(Sigma, Delta, P:Protocol, Ins, Outs, A) := getPConfig env . 
  ceq read-protocol(L, env, {'savedProtocol.IPDLProtocol : 'IPDLProtocol})
   = P:Protocol 
   if aConfig(pConfig(Sigma, Delta, P:Protocol, Ins, Outs, A)
              , countb, contextb) := getCrtConf env .  
  eq read-protocol(L, env, {'newNF`(_`,_`)[I1, I2] : 'IPDLProtocol} ) =
     newNF(read-typedCNameList(L, I1), read-protocol(L, env, I2) ) .
  eq read-protocol(L, env, {'_where_[I1, I2] : 'IPDLProtocol}) 
   = read-protocol(L, setPMap env (getPMap env, read-localDecls(L, env, I2)) ,I1) .
  eq read-protocol(L, env, {'change_with_in_ [ I, I1, I2 ] : 'IPDLProtocol }) 
   = change read-cNameBound(L, I) 
     with   read-cases(L, env, I1)
     in     read-protocol(L, env, I2) .
  eq read-protocol(L, env, {'extend_with`internal`channel_typed:_assigned:_ [ I, I1, T, I2 ] : 'IPDLProtocol }) 
   = addInternalChannel read-cNameIndex(L, I1) 
     typed preToType(read-type(L, T))  
     assigned read-cases(L, env, I2)
     in read-protocol(L, env, I) . 
  eq read-protocol(L, env, {'extend_with`internal`family_indices:_bounds:_typed:_assigned:_ 
       [ I, I1, I2, I3, T, I4 ] : 'IPDLProtocol }) 
   = addInternalFamily read-qid(I1)
     typed preToType(read-type(L, T))  
     params read-natTerms(L, I2) read-bounds(L, I3)
     assigned read-cases(L, env, I4)
     in read-protocol(L, env, I) 
  .

  var phi : IPDLEmbedding .

  eq read-protocol(L, env, {'gather_from_hiding_ [I1, I2, I3] : 'IPDLProtocol } )
   = gather read-cNameBoundList(L, env, I1) from read-protocol(L, env, I2) 
     hiding read-cNameBoundList(L, env, I3) .
  ceq read-protocol(L, env, {'embed`(_`,_`)[I1, I2] : 'IPDLProtocol} )   
   = embedProtocol(read-protocol(L, env, I1), phi) 
  if phi := (getEmbMap env)[read-qid(I2)] .
  eq read-protocol(L, env, {'create`group_indices:_bounds:_from_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol}) 
    = group read-cNameBoundList(L, env, I3)
      named read-qid(I)
      params read-natTerms(L, I1) read-bounds(L, I2)
      in read-protocol(L, env, I4) 
  .      
  eq read-protocol(L, env,  
     {'branch_of_change_with_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol })
   = branch read-whenCond(L, I)
     of read-cNameBound(L, I1)
     change read-cNameBound(L, I2)
     with read-cases(L, env, I3)
     in read-protocol(L, env, I4) .

  op read-localDecls : IPDL Env ATerm -> Map{Qid, Protocol} . 
  ceq read-localDecls(L, env, I) 
   = read-localDecl(L, env, I) if I :: 'LocalDecl .
  eq read-localDecls(L, env, {'_and_[I1, I2] : 'LocalDeclList}) 
   = read-localDecls(L, env, I1), read-localDecls(L, env, I2) . 

  op read-localDecl : IPDL Env ATerm -> Map{Qid, Protocol} .
  eq read-localDecl(L, env, {'_=_[I1, I2] : 'LocalDecl}) 
   = read-qid(I1) |-> read-protocol(L, env, I2) .

  op read-typedCNameList : IPDL ATerm -> TypedCNameList .
  eq read-typedCNameList(L, {'empty.TypedCNameList : 'TypedCNameList}) 
   = emptyTypedCNameList .
  eq read-typedCNameList(L, {'<_:_>[I1, I2] : 'TypedCName})
   = < read-qid(I1) :  preToType(read-type(L, I2)) > .
  eq read-typedCNameList(L, {'`{__:_`}[I1, I2, T] : 'TypedCName'})
   = { read-familyName(L,I1) read-natTerms(L, I2) : preToType(read-type(L, T)) } .
  eq read-typedCNameList(L, {'__[I1, I2] : 'TypedCNameList}) 
   = read-typedCNameList(L, I1) read-typedCNameList(L, I2) .  

  op read-type : IPDL ATerm -> IPDLPreType .
  eq read-type(L, {'`(_`) [I] : 'IPDLPreType})
   = read-type(L, I) . 
  eq read-type(L, {'_*_[T1, T2] : 'IPDLPreType}) = read-type(L, T1) * read-type(L, T2) .
  eq read-type(L, I) = read-qid(I) [owise].  

  op read-natTerms : IPDL ATerm -> List{NatTerm} .
  eq read-natTerms(L, {I : 'Nat}) 
   = read-natTerm(L, {I : 'Nat}) .
  eq read-natTerms(L, {I : 'CId}) 
   = read-natTerm(L, {I : 'CId}) . 
  eq read-natTerms(L, {I : 'NatTerm})
   = read-natTerm(L, {I : 'NatTerm}) .
  eq read-natTerms(L, {'_`,_[I1, I2] : 'NatTermList}) 
   = read-natTerms(L, I1) read-natTerms(L, I2) . 

  op toNatTerms : QidList -> List{NatTerm} .
  eq toNatTerms(nil) = nil .
  eq toNatTerms(q QIL) = qidAsTerm(q) toNatTerms(QIL) .

  op read-bound : IPDL ATerm -> Bounds .
  eq read-bound(L, {'bound_[I] : 'Bound}) 
   = bound read-natTerm(L, I) .
  eq read-bound(L, {'fixedBound_[I] : 'Bound}) 
   = fixedBound read-natTerm(L, I) .
  eq read-bound(L, {'dependentBound_[I] : 'Bound}) 
   = dependentBound read-qid(I) .  

  op read-natTerm : IPDL ATerm -> NatTerm .
  eq read-natTerm(L, {'_+_[I1, I2] : 'NatTerm}) 
   = read-natTerm(L, I1) + read-natTerm(L, I2) .
  eq read-natTerm(L, {'_-_[I1, I2] : 'NatTerm}) 
   = read-natTerm(L, I1) - read-natTerm(L, I2) .
  eq read-natTerm(L, {'_*_[I1, I2] : 'NatTerm}) 
   = read-natTerm(L, I1) * read-natTerm(L, I2) .
  eq read-natTerm(L, {'_`(_`)[I1, I2] : 'NatTerm})
   = fun read-qid(I1) read-natTerm(L, I2) . 
  eq read-natTerm(L, {'`(_`)[I] : 'NatTerm})
   = read-natTerm(L, I) .     
  eq read-natTerm(L, {I : 'Nat}) = natAsTerm(rat(string(read-qid(I)), 10)) .
  eq read-natTerm(L, {I : 'CId}) = qidAsTerm(read-qid(I)) .

  op read-basicFamilyName : IPDL ATerm -> FamilyName .
  eq read-basicFamilyName(L, {'_`[_`][I1, I2] : 'BasicFamilyName})
   = read-qid(I1)[read-bounds(L, I2)] .  

  var q1 q2 : Qid .
  var blist : List{Bounds} .
  op read-familyName : IPDL ATerm -> FamilyName .
  ceq read-familyName(L, I) 
    = read-basicFamilyName(L, I)
   if I :: 'BasicFamilyName .
  ceq read-familyName(L, {'_and_[I1, I2] : 'FamilyName})
    = ('Comp[qidAsTerm q1 qidAsTerm q2])[blist] 
   if q1[blist] := read-basicFamilyName(L, I1)
   /\ q2[blist] := read-basicFamilyName(L, I2) . 

  op read-basicFamilyNameBound : IPDL ATerm -> FamilyName .
 ceq read-basicFamilyNameBound(L, {'_`[_`][I1, I2] : 'BasicFamilyNameBound})
   = read-qid(I1)[bdl1] 
 if ntl1 paired bdl1 := read-boundedIndices(L, I2) .
 
 op read-familyNameBound : IPDL ATerm -> FamilyName .
  ceq read-familyNameBound(L, I) 
    = read-basicFamilyNameBound(L, I)
   if I :: 'BasicFamilyNameBound .
  ceq read-familyNameBound(L, {'_and_[I1, I2] : 'FamilyName})
    = ('Comp[qidAsTerm q1 qidAsTerm q2])[blist] 
   if q1[blist] := read-basicFamilyNameBound(L, I1)
   /\ q2[blist] := read-basicFamilyNameBound(L, I2) .  

  op read-boolTerm : IPDL ATerm -> BoolTerm .
  eq read-boolTerm(L, {'falseBT.BoolTerm : 'BoolTerm}) 
   = falseBT .
  eq read-boolTerm(L, {'trueBT.BoolTerm : 'BoolTerm}) 
   = trueBT .
  eq read-boolTerm(L, {'_=_[I1, I2] : 'BoolTerm}) 
   = read-natTerm(L, I1) =T= read-natTerm(L, I2) .
  eq read-boolTerm(L, {'_<_[I1, I2] : 'BoolTerm}) 
   = read-natTerm(L, I1) <T read-natTerm(L, I2) .
  eq read-boolTerm(L, {'_<=_[I1, I2] : 'BoolTerm}) 
   = read-natTerm(L, I1) <=T read-natTerm(L, I2) .
  eq read-boolTerm(L, {'_and_[I1, I2] : 'BoolTerm}) 
   = read-boolTerm(L, I1) conj read-boolTerm(L, I2) . 
  eq read-boolTerm(L, {'_or_[I1, I2] : 'BoolTerm}) 
   = read-boolTerm(L, I1) disj read-boolTerm(L, I2) .
  eq read-boolTerm(L, {'not_[I1] : 'BoolTerm}) 
   = neg read-boolTerm(L, I1) .
  eq read-boolTerm(L, {'_`(_`)[I1, I2] : 'BoolTerm})
   = apply read-qid(I1) read-natTerm(L, I2) . 

  op read-boolTermList : IPDL ATerm -> Set{BoolTerm} .
  eq read-boolTermList(L, {'no`assumptions.BoolTermList : 'BoolTermList})
   = empty .
  ceq read-boolTermList(L, I) = 
      read-boolTerm(L, I)
   if I :: 'BoolTerm .        
   eq read-boolTermList(L, {'_`,_[I1, I2] : 'BoolTermList}) 
   = (read-boolTermList(L, I1), read-boolTermList(L, I2)) .

  op read-bounds : IPDL ATerm -> List{Bounds} .
  eq read-bounds(L, {I : 'Bound})
   = read-bound(L, {I : 'Bound}) .
  eq read-bounds(L, {'__[I1, I2] : 'BoundList}) 
   = read-bounds(L, I1) read-bounds(L, I2) .

  op read-whenCond : IPDL ATerm -> WhenCond .
  eq read-whenCond(L, {'otherwise.WhenCond : 'WhenCond}) 
   = otherwise .
   eq read-whenCond(L, {'when_[I] : 'WhenCond}) 
   = when read-boolTerm(L, I) .

  op read-when : IPDL Env ATerm -> When .
  eq read-when(L, env, {'_-->_[I1, I2] : 'When}) 
   = read-whenCond(L, I1) --> read-cases(L, env, I2) . 
    *** because we don't allow cases in where

  op read-whenList : IPDL Env ATerm -> WhenList .
  eq read-whenList(L, env, {'emptyWhen.WhenList : 'WhenList}) 
   = emptyWhen .
  eq read-whenList(L, env, {'`(_`) [I] : 'WhenList})
   = read-whenList(L, env, I) . 
  eq read-whenList(L, env, {I : 'When}) = read-when(L, env, {I : 'When}) .
  eq read-whenList(L, env, {'_;;_[I1, I2] : 'WhenList}) 
   = read-whenList(L, env, I1) ;; read-whenList(L, env, I2) .

  op read-cases : IPDL Env ATerm -> Cases .
  ceq read-cases(L, env, I) = read-reaction(L, I)
  if I :: 'IPDLReaction .
  ceq read-cases(L, env, I) = read-protocol(L, env, I) 
   if I :: 'IPDLProtocol .
  ceq read-cases(L, env, I) = read-whenList(L, env, I) 
  if I :: 'WhenList .

  
  *** read command  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op read-cmd : IPDL Env ATerm ~> Cmd{IPDL} .
  eq read-cmd(L, env, {'show-types.Command : 'Command})
   = Cmd[L]{show-types} .
  eq read-cmd(L, env, {'show-ops.Command : 'Command})
   = Cmd[L]{show-ops} .
  eq read-cmd(L, env, {'show-dists.Command : 'Command})
   = Cmd[L]{show-dists} . 
  eq read-cmd(L, env, {'show-channels.Command : 'Command})
   = Cmd[L]{show-channels} . 
  eq read-cmd(L, env, {'show-parameters.Command : 'Command})
   = Cmd[L]{show-parameters} .   
  eq read-cmd(L, env, {'show-protocols.Command : 'Command})
   = Cmd[L]{show-protocols} .
  eq read-cmd(L, env, {'show-hypotheses.Command : 'Command})
   = Cmd[L]{show-hypotheses} . 
  eq read-cmd(L, env, {'show-assums.Command : 'Command})
   = Cmd[L]{show-assums} .
  eq read-cmd(L, env, {'show-bounds.Command : 'Command})
   = Cmd[L]{show-bounds} . 
  eq read-cmd(L, env, {'show-protocol_[{'pname[I] : 'PName}] : 'Command})
   = Cmd[L]{show-protocol read-qid(I)} .
  eq read-cmd(L, env, {'check-proof_[{'pname[I] : 'PName}] : 'Command})
   = Cmd[L]{check-proof read-qid(I)} . 
  eq read-cmd(L, env, {'current-protocol.Command : 'Command})
   = Cmd[L]{current-protocol} . 
  eq read-cmd(L, env, {'show`all.Command : 'Command})
   = Cmd[L]{show all} . 
  eq read-cmd(L, env, {'get-channel_[{'cname[I] : 'CName}] : 'Command})
   = Cmd[L]{get-channel chn (read-qid(I))} . 
  eq read-cmd(L, env, {'enable-typechecking.Command : 'Command})
   = Cmd[L]{enable-typechecking} . 
  eq read-cmd(L, env, {'disable-typechecking.Command : 'Command})
   = Cmd[L]{disable-typechecking} .   

  *** read proof  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --

  op read-approxCongrProof : IPDL Env ATerm -> ApproxCongrProof{IPDL} .
  eq read-approxCongrProof(L, env, 
      {'approx`embed_along_with`inputs_`(_`) [I1, I2, I3, I4] : 'ApproxCongrProof})
   = ApproxCongrProof[L]
      {approx embed read-protocol(L, env, I1) along read-qid(I2) 
       with inputs makeSet(read-cNameBoundList(L, env, I3)) ( read-approxCongrProof(L, env, I4))} .
  eq read-approxCongrProof(L, env, {'use`approx`axiom_ [I] : 'ApproxCongrProof})     
   = ApproxCongrProof[L]{use approx axiom read-qid(I)} .
  eq read-approxCongrProof(L, env, {'approx`case`distinction`on_`(_`) [I1, I2] : 'ApproxCongrProof} ) 
    = ApproxCongrProof[L]
      {approx case distinction on read-cNameBound(L, I1)( read-approxProofCases(L, env, I2))} .

  op read-approxProofCases : IPDL Env ATerm -> ApproxCongrProofCaseList .
  eq read-approxProofCases(L, env, {'case:`(_`) [I] : 'ApproxCongrProofCase})     
   = approxCase read-approxCongrProof(L, env, I) .
  eq read-approxProofCases(L, env, {'__[I1, I2] : 'ApproxCongrProofCaseList}) 
    = read-approxProofCases(L, env, I1) read-approxProofCases(L, env, I2) . 


  op read-approxProof : IPDL Env ATerm -> ApproxProof{IPDL} .
  ceq read-approxProof(L, env, I)
   = read-proof(L, env, I)
   if I :: 'StrictProof .
  eq read-approxProof(L, env, {'_then-approx_ [I1, I2] : 'ApproxProof})
   = ApproxProof[L]{read-approxProof(L, env, I1) then-approx read-approxProof(L, env, I2)} . 
  eq read-approxProof(L, env, {'sym-approx`from_`(_`) [I1, I2] : 'ApproxProof} )
   = ApproxProof[L]{sym-approx from read-protocol(L, env, I1) ( read-approxProof(L, env, I2) )} .
  eq read-approxProof(L, env, {'use`approx`assumption_on_[I1, I2] : 'ApproxProof} )
   = ApproxProof[L]{use approx assumption read-qid(I1) on read-cNameBoundList(L, env, I2)} . 
  eq read-approxProof(L, env, {'use`approx`assumption_[I1] : 'ApproxProof} )
   = ApproxProof[L]{use approx assumption read-qid(I1)} .  
  eq read-approxProof(L, env, {'call-approx_[I1] : 'ApproxProof} ) 
   = ApproxProof[L]{call-approx read-qid(I1)} .
  eq read-approxProof(L, env, 
      {'in`the`presence`of_rewrite_to_by`generalization`of_ [I1, I2, I3, I4] : 'ApproxProof})   
   = ApproxProof[L]
      {in the presence of read-cNameBoundList(L, env, I1) 
       rewrite read-ruleTarget(L, I2) to
       read-cases(L, env, I3) by generalization of read-qid(I4) } . 
  eq read-approxProof(L, env, {'approx`generalize`for_`(_`)  [I1, I2] : 'ApproxProof})     
   = ApproxProof[L]{approx generalize for read-cNameBound(L, I1) ( read-approxCongrProof(L, env, I2) )} .
 
  var n : Nat .

  op read-proof : IPDL Env ATerm -> Proof{IPDL} .
  eq read-proof(L, env, {'todo.StrictProof : 'StrictProof})
   = Proof[L]{todo} .
  eq read-proof(L, env, {'idle.StrictProof : 'StrictProof})
   = Proof[L]{idle} . 
  eq read-proof(L, env, {'bring`declarations`of`hidden`channels`in`front.StrictProof : 'StrictProof}) 
   = Proof[L]{bring declarations of hidden channels in front} .
  eq read-proof(L, env, {'start`with_over_[I1, I2] : 'StrictProof})
   = Proof[L]{start with read-qid(I1) over read-qid(I2)} .   
  eq read-proof(L, env, {'absorb_[I] : 'StrictProof}) 
   = Proof[L]{absorb read-cNameBound(L, I)} .
  eq read-proof(L, env, {'group-absorb_[I] : 'StrictProof}) 
   = Proof[L]{group-absorb read-ruleTarget(L, I)} .  
  eq read-proof(L, env, {'decompose_with_[I1, I2] : 'StrictProof}) 
   = Proof[L]{decompose read-cNameBound(L, I1) with read-cNameBound(L, I2)} . 
  eq read-proof(L, env, {'restructure_[I] : 'StrictProof}) 
   = Proof[L]{restructure read-protocol(L, env, I)} . 
  eq read-proof(L, env, {'compose_with_in`group [I1, I2] : 'StrictProof })
   = Proof[L]{compose read-cNameBound(L, I1) with read-cNameBound(L, I2) in group} .  
  eq read-proof(L, env, {'combine_[I] : 'StrictProof}) 
   = Proof[L]{combine read-cNameBound(L, I)} .
  eq read-proof(L, env, {'combine_into`families[I] : 'StrictProof}) 
   = Proof[L]{combine read-cNameBound(L, I) into families} .  
  eq read-proof(L, env, {'unsplit_[I] : 'StrictProof}) 
   = Proof[L]{unsplit read-cNameIndex(L, I)} .  
  eq read-proof(L, env, {'split_on`first`index [ I ] : 'StrictProof } ) 
   = Proof[L]{split read-cNameBound(L, I) on first index} .
  eq read-proof(L, env, {'split_on`first`index`inside_ [ I1, I2 ] : 'StrictProof } ) 
   = Proof[L]{split read-cNameBound(L, I1) on first index inside read-ruleTarget(L, I2)} .  
  eq read-proof(L, env, {'split_on`second`index [ I ] : 'StrictProof } ) 
   = Proof[L]{split read-cNameBound(L, I) on second index} .    
  eq read-proof(L, env, {'merge`cases`for_[I] : 'StrictProof}) 
   = Proof[L]{merge cases for read-cNameBound(L, I)} .
  eq read-proof(L, env, {'merge`case_=_with`otherwise`for_[I, I1, I2] : 'StrictProof}) 
   = Proof[L]{merge case read-qid(I) = read-natTerm(L, I1) with otherwise for read-cNameBound(L, I2)} .       
  eq read-proof(L, env, {'turn`neg`into`otherwise`for_[I] : 'StrictProof}) 
   = Proof[L]{turn neg into otherwise for read-cNameBound(L, I)} .    
  eq read-proof(L, env, {'turn`otherwise`into`neg`for_[I] : 'StrictProof}) 
   = Proof[L]{turn otherwise into neg for read-cNameBound(L, I)} .     
  eq read-proof(L, env, {'drop`read_from_[I1, I2] : 'StrictProof}) 
   = Proof[L]{drop read read-cNameBound(L, I1) from read-cNameBound(L, I2)} . 
  eq read-proof(L, env, {'drop`read`branch_of_from_[I, I1, I2] : 'StrictProof}) 
   = Proof[L]{drop read branch read-whenCond(L, I) 
               of read-cNameBound(L, I1) from read-cNameBound(L, I2)} .  
  eq read-proof(L, env, {'rename_in_[I1, I2] : 'StrictProof}) 
   = Proof[L]{rename read-qidPairList(L, I1) in read-cNameBound(L, I2)} . 
   eq read-proof(L, env, {'rename`variables_of_[I1, I2] : 'StrictProof}) 
   = Proof[L]{rename variables read-qidPairList(L, I1) of read-cNameBound(L, I2)} .  
  eq read-proof(L, env, {'fold_into_[I1, I2] : 'StrictProof}) 
   = Proof[L]{fold read-cNameBound(L, I1) into read-cNameBound(L, I2)} .
  eq read-proof(L, env, {'subst_into_[I1, I2] : 'StrictProof}) 
   = Proof[L]{subst read-cNameBound(L, I1) into read-cNameBound(L, I2)} .       
  eq read-proof(L, env, {'subst_into_at_[I1, I2, I3] : 'StrictProof}) 
   = Proof[L]{subst read-cNameBound(L, I1) into read-cNameBound(L, I2) at read-qid(I3)} .
  eq read-proof(L, env, {'subst`branch_of_into_[I, I1, I2] : 'StrictProof}) 
   = Proof[L]{subst branch read-whenCond(L, I) of read-cNameBound(L, I1) into read-cNameBound(L, I2)} .        
  eq read-proof(L, env, {'subst`branch_of_into_at_[I, I1, I2, I3] : 'StrictProof}) 
   = Proof[L]{subst branch read-whenCond(L, I) of read-cNameBound(L, I1) 
               into read-cNameBound(L, I2) at read-qid(I3)} .        
***   eq read-proof(L, env, {'use`assumption_on_[{'assumName[I1] : 'AssumName}, {'cname[I2] : 'CName}] : 'StrictProof}) 
***    = Proof[L]{use assumption read-qid(I1) on read-qid(I2)} . 
  eq read-proof(L, env, {'use`assumption_on_[I1 , I2] : 'StrictProof}) 
   = Proof[L]{use assumption read-qid(I1) on read-cNameBoundList(L, env, I2)} .    
  ceq read-proof(L, env, {'use`expression`assumption_on_at_[I1 , I2, I3] : 'StrictProof}) 
   = Proof[L]{use expression assumption read-qid(I1) on read-cNameBoundList(L, env, I2) at n} 
  if natAsTerm n := read-natTerm(L, I3) .     
  eq read-proof(L, env, {'_then_[I1, I2] : 'StrictProof}) 
   = Proof[L]{read-proof(L, env, I1) then read-proof(L, env, I2)} .
  eq read-proof(L, env, {'sym`from_`(_`)[I1, I2] : 'StrictProof}) 
   = Proof[L]{sym from read-protocol(L, env, I1) ( read-proof(L, env, I2) ) } . 
  eq read-proof(L, env, {'sym`from_over_`(_`)[I, I1, I2] : 'StrictProof}) 
   = Proof[L]{sym from read-protocol(L, env, I) over (read-delta(L, env, I1)) 
              ( read-proof(L, env, I2) ) } .               
  eq read-proof(L, env, {'try`sym`from_:_done[I1, I2] : 'StrictProof}) 
   = Proof[L]{try sym from read-protocol(L, env, I1) : read-proof(L, env, I2) done } .
  eq read-proof(L, env, {'try`sym`from_:_[I1, I2] : 'StrictProof}) 
   = Proof[L]{try sym from read-protocol(L, env, I1) : read-proof(L, env, I2) } .  
  eq read-proof(L, env, {'try`sym`from_over_:_[I, I1, I2] : 'StrictProof}) 
   = Proof[L]{try sym from read-protocol(L, env, I) over 
               read-delta(L, env, I1) : read-proof(L, env, I2) } .               
  eq read-proof(L, env, 
      {'add`internal`family_indices:_bounds:_typed:_assigned:_ [I, I1, I2, T, I3] : 'StrictProof}) 
   = Proof[L]{add internal family read-qid(I) indices: read-natTerms(L, I1) 
              bounds: read-bounds(L, I2) typed: preToType(read-type(L, T)) 
              assigned: read-cases(L, env, I3)} .
  eq read-proof(L, env, 
      {'add`internal`channel_typed:_assigned:_ [I, T, I3] : 'StrictProof}) 
   = Proof[L]{add internal channel read-cNameIndex(L, I) 
              typed: preToType(read-type(L, T)) 
              assigned: read-cases(L, env, I3)} .            
  eq read-proof(L, env, {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5] : 'StrictProof}) 
   = Proof[L]
     {in the presence of read-cNameBoundList(L, env, I) 
      rewrite read-ruleTarget(L, I1) to read-cases(L, env, I2) 
      by induction on read-natTerm(L, I3) bound read-natTerm (L, I4) (read-proof(L, env, I5))}  . 
   eq read-proof(L, env, {'rewrite_to_by`induction`on_bound_`(_`) 
                [I1, I2, I3, I4, I5] : 'StrictProof}) 
   = Proof[L]
     {
      rewrite read-ruleTarget(L, I1) to read-cases(L, env, I2) 
      by induction on read-natTerm(L, I3) bound read-natTerm (L, I4) (read-proof(L, env, I5))}  .    
   eq read-proof(L, env, {'try`in`the`presence`of_rewrite_to_by`induction`on_bound_:_ 
                [I, I1, I2, I3, I4, I5] : 'StrictProof}) 
   = Proof[L]
     {try in the presence of read-cNameBoundList(L, env, I) 
      rewrite read-ruleTarget(L, I1) to read-cases(L, env, I2) 
      by induction on read-natTerm(L, I3) bound read-natTerm (L, I4) : read-proof(L, env, I5) }  . 
   eq read-proof(L, env, {'try`rewrite_to_by`induction`on_bound_:_ 
                [I1, I2, I3, I4, I5] : 'StrictProof}) 
   = Proof[L]
     {try 
      rewrite read-ruleTarget(L, I1) to read-cases(L, env, I2) 
      by induction on read-natTerm(L, I3) bound read-natTerm (L, I4) : read-proof(L, env, I5) }  .          
   eq read-proof(L, env, {'case`distinction`on_`(_`) [I1, I2] : 'StrictProof} ) 
   =  Proof[L]{case distinction on read-ruleTarget(L, I1) ( read-proofCaseList(L, env, I2) )} .
   eq read-proof(L, env, {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'StrictProof} ) 
   =  Proof[L]{try case distinction on read-ruleTarget(L, I1) : (case: read-proof(L, env, I2) )} .
   eq read-proof(L, env, {'try`case`distinction`on_:`(case:_done`)`(case:_`) [I, I1, I2] : 'StrictProof} ) 
   =  Proof[L]{try case distinction on read-ruleTarget(L, I) :
                (case: read-proof(L, env, I1) done)
                (case: read-proof(L, env, I2))
                } .   
   eq read-proof(L, env,  {'on`branch_of_`(_`) [I, I1, I2] : 'StrictProof }) 
    = Proof[L]{on branch read-boolTerm(L, I) of read-ruleTarget(L, I1) ( read-proof(L, env, I2) )} .
   eq read-proof(L, env,  {'try`on`branch_of_:_ [I, I1, I2] : 'StrictProof }) 
    = Proof[L]{try on branch read-boolTerm(L, I) of read-ruleTarget(L, I1) : read-proof(L, env, I2) } .
   eq read-proof(L, env,  {'try`on`branch_of_:_done [I, I1, I2] : 'StrictProof }) 
    = Proof[L]{try on branch read-boolTerm(L, I) of read-ruleTarget(L, I1) : read-proof(L, env, I2) done} . 
 
   eq read-proof(L, env, {'move_on`each`branch`of_ [I1, I2] : 'StrictProof }) 
    = Proof[L]{move read-ruleTarget(L, I1) on each branch of read-ruleTarget(L, I2) } . 
   eq read-proof(L, env, {'diverge`on_with_var_ [I, I1, I2] : 'StrictProof}) 
    =  Proof[L]{diverge on read-cNameBound(L, I) 
                      with read-cNameBound(L, I1)
                      var read-qid(I2)} .
   eq read-proof(L, env, {'diverge`on_with`branch_of_var_ [I, I1, I2, I3] : 'StrictProof}) 
    =  Proof[L]{diverge on read-cNameBound(L, I) 
                      with branch read-boolTerm(L, I1)
                      of read-cNameBound(L, I2)
                      var read-qid(I3)} .                   
   eq read-proof(L, env, {'reverse`subst_in_using_ [I1, I2, I3] : 'StrictProof})
    = Proof[L]{reverse subst read-cNameBound(L, I1) 
                       in read-cNameBound(L, I2) 
                       using read-cNameBound(L, I3)} .
   eq read-proof(L, env, {'subst`or`diverge_into_var_ [I1, I2, I3] : 'StrictProof}) 
    = Proof[L]{subst or diverge read-cNameBound(L, I1)  
               into read-cNameBound(L, I2)  var read-qid(I3)}  .
   eq read-proof(L, env, {'on`reaction`of_`(_`) [I1, I2] : 'StrictProof})
    = Proof[L]{on reaction of read-cNameBound(L, I1) (read-reactionProof(L, I2))} .
   eq read-proof(L, env, {'remove`only`branch`of_ [I] : 'StrictProof})
    = Proof[L]{remove only branch of read-cNameBound(L, I)} .
   eq read-proof(L, env, {'extract_from_into`group_ [I1, I2, I3] : 'StrictProof})
    = Proof[L]{extract read-cNameBoundList(L, env, I1) 
               from read-ruleTarget(L, I2)
               into group read-qid(I3)} . 
   eq read-proof(L, env, {'discard`branch_of_[I1, I2] : 'StrictProof}) 
    = Proof[L]{discard branch read-boolTerm(L, I1) of read-cNameBound(L, I2)} .   
   eq read-proof(L, env, {'fix`index`for_[I] : 'StrictProof}) 
    = Proof[L]{fix index for read-cNameBound(L, I)} .             
   eq read-proof(L, env, {'on`all`branches`of_split_on`first`index [I1, I2] : 'StrictProof})
    = Proof[L]{on all branches of read-cNameBound(L, I1) 
               split read-cNameBound(L, I2) on first index} .
   eq read-proof(L, env, {'on`all`branches`of_split_on`second`index [I1, I2] : 'StrictProof})
    = Proof[L]{on all branches of read-cNameBound(L, I1) 
               split read-cNameBound(L, I2) on second index} . 
   eq read-proof(L, env, {'group_in_indices:_bounds:_[I, I1, I2, I3] : 'StrictProof})
    = Proof[L]{group read-cNameBoundList(L, env, I) 
               in read-qid(I1) 
               indices: read-natTerms(L, I2) 
               bounds: read-bounds(L, I3)} .
   eq read-proof(L, env, {'call_ [I] : 'StrictProof})
   = Proof[L]{call read-qid(I)} .
   eq read-proof(L, env, {'use`lemma_run [I] : 'StrictProof})
   = Proof[L]{use lemma read-qid(I) run} .
   eq read-proof(L, env, {'use`lemma_trust [I] : 'StrictProof})
   = Proof[L]{use lemma read-qid(I) trust} .
   eq read-proof(L, env, {'ungroup_ [I] : 'StrictProof})
   = Proof[L]{ungroup read-cNameBound(L, I)} .
   eq read-proof(L, env, {'using_`(_`) [I1, I2] : 'StrictProof})
    = Proof[L]{using read-ruleTarget(L, I1) ( read-proof(L, env, I2) )} .
   eq read-proof(L, env, {'using`branch_of_`(_`) [I, I1, I2] : 'StrictProof})
    = Proof[L]{using branch read-whenCond(L, I) of read-ruleTarget(L, I1) ( read-proof(L, env, I2) )} . 
   eq read-proof(L, env,
       {'sym`var_terms_diverge_into_var_ [I, I1, I2, I3, I4] : 'StrictProof})
    = Proof[L]{
      sym var read-qid(I) terms read-natTerms(L, I1)
      diverge read-cNameBound(L, I2)  
               into read-cNameBound(L, I3)  var read-qid(I4)
      } .   
   eq read-proof(L, env, {'save`current`configuration.StrictProof : 'StrictProof})   
    = Proof[L]{save current configuration} .
   eq read-proof(L, env,{'split_inside_[I1, I2] : 'StrictProof})
    = Proof[L]{split read-cNameBound(L, I1) inside read-ruleTarget(L, I2)} . 
   eq read-proof(L, env,{'unsplit_and_[I1, I2] : 'StrictProof})
    = Proof[L]{unsplit read-cNameBound(L, I1) and read-cNameBound(L, I2)} .
   eq read-proof(L, env,{'unsplit_and_inside_[I1, I2, I3] : 'StrictProof})
    = Proof[L]{unsplit read-cNameBound(L, I1) and read-cNameBound(L, I2)
               inside read-ruleTarget(L, I3)} .
   ceq read-proof(L, env,{'unit-ext`on_at_[I1, I2] : 'StrictProof})
    = Proof[L]{unit-ext on read-cNameBound(L, I1) at n} 
   if natAsTerm n := read-natTerm(L, I2) .
   eq read-proof(L, env,{'rename`indices`to_in_[I1, I2] : 'StrictProof})
    = Proof[L]{rename indices to read-natTerms(L, I1) in read-cNameBound(L, I2)} . 
   eq read-proof(L, env,{'remove_from_[I1, I2] : 'StrictProof})
    = Proof[L]{remove read-cNameBound(L, I1) from read-ruleTarget(L, I2)} .
   eq read-proof(L, env,{'change`name_to_[I1, I2] : 'StrictProof})
    = Proof[L]{change name read-cNameBound(L, I1) to read-qid(I2)} .
   eq read-proof(L, env,{'focus_`(_`)[I1, I2] : 'StrictProof})
    = Proof[L]{focus read-cNameBoundList(L, env, I1)(read-proof(L, env, I2))} .  
   eq read-proof(L, env, {'remove`and`merge_from_ [I1, I2] : 'StrictProof})
    = Proof[L]{remove and merge read-cNameBound(L, I1) from read-ruleTarget(L, I2) } .
   eq read-proof(L, env, {'use`assumptions`for_in_ [I1, I2] : 'StrictProof})
    = Proof[L]{use assumptions for read-qid(I1) in read-cNameBound(L, I2)} .
   eq read-proof(L, env, {'merge`case`for_and_into`group_ [I1, I2, I3] : 'StrictProof} )
    = Proof[L]{merge cases for 
                read-cNameBound(L, I1) and read-cNameBound(L, I2) 
                into group read-qid(I3)} . 

   op read-reactionProof :  IPDL ATerm -> ReactionProof{IPDL} .
   eq read-reactionProof(L, {'idle.ReactionProof : 'ReactionProof})
   = ReactionProof[L]{idle} . 
   eq read-reactionProof(L, {'_then_[I1, I2] : 'ReactionProof}) 
   = ReactionProof[L]{read-reactionProof(L, I1) then read-reactionProof(L, I2)} .
   eq read-reactionProof(L, {'if-ext`on_ [I] : 'ReactionProof}) 
    = ReactionProof[L]{if-ext on read-qid(I)} .


   op read-ruleTarget : IPDL ATerm -> RuleTarget .
   eq read-ruleTarget(L, {'channel_[I] : 'RuleTarget})
    = channel read-cNameIndex(L, I) . 
   eq read-ruleTarget(L, {'family_[I] : 'RuleTarget})
    = family read-familyName(L, I) . 
   eq read-ruleTarget(L, {'group_[I] : 'RuleTarget})
    = group read-familyName(L, I) .  

   op read-proofCaseList : IPDL Env ATerm -> ProofCaseList . 
   ceq read-proofCaseList(L, env, I)          
     = read-proofCase(L, env, I) 
    if I :: 'ProofCase .
   eq read-proofCaseList(L, env, {'__[I1, I2] : 'ProofCaseList}) 
    = read-proofCaseList(L, env, I1) read-proofCaseList(L, env, I2) .

   op read-proofCase : IPDL Env ATerm -> ProofCase . 
   eq read-proofCase(L, env, {'case:`(_`) [I] : 'ProofCase})
    = case read-proof(L, env, I) . 

   op read-qidPairList : IPDL ATerm -> QidPairList . 
   ceq read-qidPairList(L, I)          
     = read-qidPair(L, I) 
    if I :: 'QidPair .
   eq read-qidPairList(L, {'_`,_[I1, I2] : 'QidPairList}) 
    = read-qidPairList(L, I1) read-qidPairList(L, I2) .

   op read-qidPair : IPDL ATerm -> QidPair .            
   eq read-qidPair(L,{'_to_[I1, I2] : 'QidPair}) 
    = << read-qid(I1), read-qid(I2)>> .  
endfm

********************************************************************************

fmod IPDL/SHOW is
  protecting IPDL/DECL .
  protecting PROTOCOL .

  var  L : IPDL .
  var cn : ChannelName .
  var  I q : Qid .
  var T : IPDLType .
  vars t1 t2 : IPDLPreType .
  var P P1 P2 : Protocol .
  var Delta dIns dOuts : ChannelContext .
  var Gamma GammaVar : TypeContext .
  var Ins : Set{CNameBound} .
  var R R1 R2 : Reaction .
  var E E1 E2 : IPDLExpression .
  var QIS : QidSet .
  var QIL : QidList .
  
  op show-decl : Decl{IPDL} -> Term .
  eq show-decl(Decl[L]{type I .})
   = 'type_.[show-decl-type(L, I)] .
  eq show-decl(Decl[L]{hypothesis bt .})
   = 'hypothesis_.[show-boolTerm(L, bt)] . 
***   eq show-decl(Decl[L]{input (chn I) : t1 .})
***    = 'input_.[ 
***        show-cNameIndex(L, I) , 
***        show-type(L, t1)] .
***   eq show-decl(Decl[L]{input (fam (I[bdl])) : t1 .})
***    = 'input_.[ 
***        show-familyName(L, I[bdl]) , 
***        show-type(L, t1)] .     
  eq show-decl(Decl[L]{channel context q = dIns pairSetIO dOuts .})
   = 'channel`context_=_. [
       mk-bubble('dname, show-qid(q)),
       '_;_ [
         show-insDelta(L, dIns),
         show-outsDelta(L, dOuts)
       ]
   ] .
  eq show-decl(Decl[L]{parameter I : t1 .})
   = 'input_.[ 
       mk-bubble('paramName, show-qid(I)) , 
       show-type(L, t1)] .      
***    eq show-decl(Decl[L]{output (chn I) : t1 .})
***    = 'output_.[ 
***        show-cNameIndex(L, I) ,  
***        show-type(L, t1)] . 
***   eq show-decl(Decl[L]{output (fam (I[bdl])) : t1 .})
***    = 'output_.[ 
***        show-familyName(L, I[bdl]) , 
***        show-type(L, t1)] .          
  eq show-decl(Decl[L]{function I : t1 -> t2 .})
   = 'function_:_->_.[
       mk-bubble('fname, show-qid(I)),
       show-type(L, t1),
       show-type(L, t2)] .
  eq show-decl(Decl[L]{distribution I : t1 -> t2 .})
   = 'distribution_:_->_.[
       mk-bubble('dname, show-qid(I)),
       show-type(L, t1),
       show-type(L, t2)] .
  eq show-decl(Decl[L]{protocol I = P .}) =
     'protocol_=_.[
      mk-bubble('pname, show-qid(I)),
      show-protocol(L, P) 
     ] . 
  eq show-decl(Decl[L]{protocol I .}) =
     'protocol_.[
      mk-bubble('pname, show-qid(I))
     ] .   
  eq show-decl(Decl[L]{reaction-assumption I using QIS : Delta ; Gamma ; Ins |= R1 = R2 .}) =   
     'reaction-assumption_using_:_;_;_|=_=_.[
       mk-bubble('assumName, show-qid(I)), 
       show-qids(list(QIS)), 
       show-delta(L, Delta), 
       show-gamma(L, Gamma), 
       show-inputs(L, Ins), 
       show-reaction(L, R1), 
       show-reaction(L, R2)
       ] .
   eq show-decl(Decl[L]{assumption manual I using QIS : Gamma |= E1 = E2 .}) =   
     'expression-assumption`%manual_using_:_|=_=_.[
       mk-bubble('assumName, show-qid(I)), 
       show-qids(list(QIS)), 
       show-gamma(L, Gamma), 
       show-expression(L, E1), 
       show-expression(L, E2)
       ] .   
   eq show-decl(Decl[L]{assumption automatic I using QIS : Gamma |= E1 = E2 .}) =   
     'expression-assumption`%automatic_using_:_|=_=_.[
       mk-bubble('assumName, show-qid(I)), 
       show-qids(list(QIS)), 
       show-gamma(L, Gamma), 
       show-expression(L, E1), 
       show-expression(L, E2)
       ] .        

  op show-assumOption :   IPDL AssumOption -> Term .   
  eq show-assumOption(L, manualIPDL) = 'manual.AssumOption . 
  eq show-assumOption(L, automaticIPDL) = 'automatic.AssumOption . 

  var aO : AssumOption .
 
  op show-delta : IPDL ChannelContext -> Term .
  eq show-delta(L, emptyChannelCtx) = 'emptyCCtxt.ChnCtxt .
  eq show-delta(L, chn q :: T) = 
     '_::_[
        mk-bubble('cname, show-qid(q)), 
        show-type(L, typeToPre(T))] .
  eq show-delta(L, (chn q :: T) Delta) =
     '__[ 
        show-delta(L, chn q :: T),
        show-delta(L, Delta )
      ] .        

  op show-gamma : IPDL TypeContext -> Term .
  eq show-gamma(L, emptyTypeContext) = 'emptyTCtxt.TypeCtxt .
  eq show-gamma(L, q : T) = 
     '_:_[
        mk-bubble('vid, show-qid(q)), 
        show-type(L, typeToPre(T))] .
  eq show-gamma(L, (q : T) Gamma) =
     '__[ 
        show-gamma(L, q : T),
        show-gamma(L, Gamma )
      ] .  

   var cnb : CNameBound . 

  op show-cNameBound : IPDL CNameBound -> Term .  

  op show-insDelta : IPDL ChannelContext -> Term .
  eq show-insDelta(L, cnb :: T) =
     'input_:_ [
       show-cNameBound(L, cnb),
       show-type(L, typeToPre(T))
     ] .
   eq show-insDelta(L, (cnb :: T) Delta) =
     '_;_[
     show-insDelta(L, cnb :: T),
     show-insDelta(L, Delta)
     ] 
     .  

  op show-outsDelta : IPDL ChannelContext -> Term .
  eq show-outsDelta(L, cnb :: T) =
     'output_:_ [
       show-cNameBound(L, cnb),
       show-type(L, typeToPre(T))
     ] .
   eq show-outsDelta(L, (cnb :: T) Delta) =
     '_;_[
     show-outsDelta(L, cnb :: T),
     show-outsDelta(L, Delta)
     ] 
     .   

  op show-inputs : IPDL Set{CNameBound} -> Term .
  eq show-inputs(L, Ins) =
     show-qids(toQidList(Ins)) .    

  op toQidList : Set{CNameBound} -> QidList .
  eq toQidList(empty) = none .
  eq toQidList(((chn q), Ins)) = q ; toQidList(Ins) .
 
 var ntlist : List{NatTerm} .

  op show-protocol : IPDL Protocol -> Term .
  eq show-protocol(L, emptyProtocol) = 
     'emptyProtocol.IPDLProtocol .
  eq show-protocol(L, cn ::= cases ) = 
     '_::=_[ 
      show-cNameIndex(L, cn),
      show-cases(L, cases) ] .
  eq show-protocol(L, family cn[bdl] ntlist bdl ::= cases) 
   =  'family_indices:_bounds:_::=_[
      show-familyName(L, cn[bdl]), 
      show-natTerms(L, ntlist), 
      show-bounds(L, bdl), 
      show-cases(L, cases) ] .    
  eq show-protocol(L, P || P1 ) = 
     '_||_[ 
      show-protocol(L, P),
      show-protocol(L, P1) ] . 
  eq show-protocol(L, new cn : T in P ) =           
     'new_:_in_[
      show-cNameIndex(L, cn),
      show-type(L, typeToPre(T)),
      show-protocol(L, P)
     ] .
  eq show-protocol(L, newfamily q[bdl] ntlist bdl : T in P)  
   = 'newfamily_indices:_bounds:_:_in_[
      show-familyName(L, q[bdl]), 
      show-natTerms(L, ntlist), 
      show-bounds(L, bdl), 
      show-type(L, typeToPre(T)),
      show-protocol(L, P) ] . 
  var phi : IPDLEmbedding .    
  eq show-protocol(L, embedProtocol(P, phi))
   = 'embed`(_`,_`)[
       show-protocol(L, P),
       mk-bubble('embedName, show-qid(getEmbedName(phi)))
   ] .
  eq show-protocol(L, protocolRef(q))
   = 'protocolRef[
     mk-bubble('pname, show-qid(q)) 
   ] .   

  var ltq : TypedCNameList .
 
  eq show-protocol(L, newNF(ltq, P)) =
     'newNF`(_`,_`)[
       show-typedCNameList(L, ltq), 
       show-protocol(L, P)] .
 
  op show-cNameIndex : IPDL ChannelName -> Term .
  eq show-cNameIndex(L, q) 
   = mk-bubble('cname, show-qid(q)).
  eq show-cNameIndex(L, q[ntlist]) 
   = '_`[_`][ 
        mk-bubble('cname, show-qid(q)),
        show-natTerms(L, ntlist)
      ] .
  
   var fn : FamilyName .
   var nlist : List{NatTerm} .
   var tcn : TypedCName .

  op show-typedCNameList : IPDL TypedCNameList -> Term .
  eq show-typedCNameList(L, emptyTypedCNameList) =
     'empty.TypedCNameList .
  eq show-typedCNameList(L, < cn : T > ) =
     '<_:_>[ 
        show-cNameIndex(L, cn),
        show-type(L, typeToPre(T))
      ] .
  eq show-typedCNameList(L, {fn nlist : T}) =  
     '`{__:_`}[
        show-familyName(L, fn), 
        show-natTerms(L, nlist), 
        show-type(L, typeToPre(T))] .  
  ceq show-typedCNameList(L, tcn ltq) =
     '__[ 
        show-typedCNameList(L, tcn ),
        show-typedCNameList(L, ltq )
      ] 
   if ltq =/= emptyTypedCNameList .        

  var nt nt1 nt2 : NatTerm .
  var x : Nat .

  op show-natTerm : IPDL NatTerm -> Term .
  eq show-natTerm(L, nt1 + nt2) 
   = '_+_[
       show-natTerm(L, nt1), 
       show-natTerm(L, nt2)] .
  eq show-natTerm(L, nt1 - nt2) 
   = '_-_[
       show-natTerm(L, nt1), 
       show-natTerm(L, nt2)] .
  eq show-natTerm(L, nt1 * nt2) 
   = '_*_[
       show-natTerm(L, nt1), 
       show-natTerm(L, nt2)] .
  eq show-natTerm(L, fun q nt1) 
   = '_`(_`)[
       mk-bubble('fname, show-qid(q)), 
       show-natTerm(L, nt1)] . 
  eq show-natTerm(L, qidAsTerm(q)) 
   = mk-bubble('nid, show-qid(q)) .
  eq show-natTerm(L, natAsTerm(x)) 
   = mk-bubble('nid, show-qid(qid(x))) .  

  op show-natTerms : IPDL List{NatTerm} -> Term .
  eq show-natTerms(L, nt) = show-natTerm(L, nt) .
  eq show-natTerms(L, nt ntlist) 
   = '_`,_[ 
        show-natTerm(L, nt),
        show-natTerms(L, ntlist)
      ] .                

  var bt bt1 bt2 : BoolTerm .

  op show-boolTerm : IPDL BoolTerm -> Term .
  eq show-boolTerm(L, falseBT) 
   = 'falseBT.BoolTerm .
  eq show-boolTerm(L, trueBT) 
   = 'trueBT.BoolTerm . 
  eq show-boolTerm(L, nt1 =T= nt2) 
   = '_=_[show-natTerm(L, nt1), show-natTerm(L, nt2)] .
  eq show-boolTerm(L, nt1 <T nt2) 
   = '_<_[show-natTerm(L, nt1), show-natTerm(L, nt2)] .    
  eq show-boolTerm(L, nt1 <=T nt2) 
   = '_<=_[show-natTerm(L, nt1), show-natTerm(L, nt2)] .
  eq show-boolTerm(L, neg bt) 
   = 'not_[show-boolTerm(L, bt)] .
  eq show-boolTerm(L, bt1 conj bt2) 
   = '_and_[show-boolTerm(L, bt1), show-boolTerm(L, bt2)] .       
  eq show-boolTerm(L, bt1 disj bt2) 
   = '_or_[show-boolTerm(L, bt1), show-boolTerm(L, bt2)] .        
  eq show-boolTerm(L, apply q nt) 
   = '_`(_`)[mk-bubble('predId, show-qid(q)), show-natTerm(L, nt)] . 

  op show-bound : IPDL Bounds -> Term .
  eq show-bound(L, bound nt) 
   = 'bound_[show-natTerm(L, nt)] . 
  eq show-bound(L, fixedBound nt) 
   = 'fixedBound_[show-natTerm(L, nt)] . 
  eq show-bound(L, dependentBound q) 
   = 'dependentBound_[mk-bubble('fname, show-qid(q))] .  

  var bd : Bounds .
  var bdl : List{Bounds} .

  op show-bounds : IPDL List{Bounds} -> Term .
  eq show-bounds(L, bd) = show-bound(L, bd) .
  eq show-bounds(L, bd bdl) 
   = '__[ 
        show-bound(L, bd),
        show-bounds(L, bdl)
      ] .

   var q1 q2 : Qid .

   op show-familyName : IPDL FamilyName -> Term .
   *** eq show-familyName(L, q[nlist][bdl]) =
   ***    '_`[_`]['_`[_`][mk-bubble('cname, show-qid(q)), show-natTerms(L, nlist)],
   ***            show-bounds(L, bdl)] .
   eq show-familyName(L, q[bdl]) =     
      '_`[_`][
         mk-bubble('cname, show-qid(q)), 
         show-bounds(L, bdl)
         ] .  
   eq show-familyName(L, 'Comp[qidAsTerm q1 qidAsTerm q2][bdl]) 
    = '_and_ [
        show-familyName(L, q1[bdl]),
        show-familyName(L, q2[bdl])
    ] .      

  op show-whenCond : IPDL WhenCond -> Term .
  eq show-whenCond(L, otherwise) 
   = 'otherwise.WhenCond .       
  eq show-whenCond(L, when bt) 
   = 'when_[show-boolTerm(L, bt)] .

  var wCond : WhenCond .
  var cases : Cases .

  op show-when : IPDL When -> Term .
  eq show-when(L, wCond --> cases) 
   = '_-->_[ 
        show-whenCond(L, wCond),
        show-cases(L, cases)
      ] .

  var w : When .
  var wl : WhenList .

  op show-whenList : IPDL WhenList -> Term .
  eq show-whenList(L, emptyWhen) 
   = 'emptyWhen.WhenList .
  eq show-whenList(L, w) 
   = show-when(L, w) .
  eq show-whenList(L, w ;; wl) 
   = '_;;_[ 
        show-when(L, w),
        show-whenList(L, wl)
      ] .    

  op show-cases : IPDL Cases -> Term . 
  eq show-cases(L, R) = show-reaction(L, R) .
  eq show-cases(L, P) = show-protocol(L, P) .
  eq show-cases(L, wl) = show-whenList(L, wl) .

  op show-reaction : IPDL Reaction -> Term .
  eq show-reaction(L, samp (q < E >) ) =
     'samp_`(_`)[
       mk-bubble('dname, show-qid(q)),
       show-expression(L, E)
     ] .   
  eq show-reaction(L, return E) =
     'return_[
       show-expression(L, E)
     ] .
  eq show-reaction(L, read q) =
    'read_[
      show-cNameIndex(L, q)    
    ] .   
  eq show-reaction(L, read cn) =
    'read[
      show-cNameIndex(L, cn)    
    ] .
  eq show-reaction(L, if E then R1 else R2) =  
    'if_then_else_[
      show-expression(L, E),
      show-reaction(L, R1),
      show-reaction(L, R2)
    ] .
  eq show-reaction(L, q : T <- R1 ; R2) =  
    '_:_<-_;_[
      mk-bubble('vid, show-qid(q)),
      show-type(L, typeToPre(T)),
      show-reaction(L, R1),
      show-reaction(L, R2)
    ] .  
  eq show-reaction(L, nf(BL, R)) =  
    'nf`(_`,_`)[
       show-binds(L, BL), 
       show-reaction(L, R)] . 
  eq show-reaction(L, preNF(BL, R)) =  
    'preNF`(_`,_`)[
       show-binds(L, BL), 
       show-reaction(L, R)] .  

  var BL BL1 : BindList .
  op show-binds : IPDL BindList -> Term .
  eq show-binds(L, emptyBRList) = 
     'nil.BindList .
  eq show-binds(L, q : T <~ R) =
     '_:_<~_[
      mk-bubble('vid, show-qid(q)),
      show-type(L, typeToPre(T)),
      show-reaction(L, R)      
     ] .  
   eq show-binds(L, q : T <- read cn) =
     '_:_<-`read_[
      mk-bubble('vid, show-qid(q)),
      show-type(L, typeToPre(T)),
      show-cNameIndex(L, cn)
     ] .        
  eq show-binds(L, (q : T <~ R) BL1) =
     '__[
      show-binds(L, q : T <~ R),
      show-binds(L, BL1)
     ] .
  eq show-binds(L, (q : T <- read cn) BL1) =
     '__[
      show-binds(L, q : T <- read cn),
      show-binds(L, BL1)
     ] .   
  

  op show-expression : IPDL IPDLExpression -> Term .  
  eq show-expression(L, True) = 'True.IPDLExpr .
  eq show-expression(L, False) = 'False.IPDLExpr .
  eq show-expression(L, ()) = '`(`).IPDLExpr . 
  eq show-expression(L, q) = mk-bubble('vid, show-qid(q)) .
  eq show-expression(L, fst E) = 
     'fst_[
      show-expression(L, E)
     ] .
  eq show-expression(L, snd E) = 
     'snd_[
      show-expression(L, E)
     ] .   
  eq show-expression(L, ap q E) = 
     '_`(_`)[
      mk-bubble('fname, show-qid(q)),
      show-expression(L, E)
     ] .
  eq show-expression(L, pair(E1, E2)) =
    '`(_`,_`)[
      show-expression(L, E1),
      show-expression(L, E2)
    ] .
  
  op show-decl-type : IPDL IPDLPreType -> Term .
  eq show-decl-type(L, I)
   = mk-bubble('tdid, show-qid(I)) .

  op show-type : IPDL IPDLPreType -> Term .
  eq show-type(L, I)
   = mk-bubble('tid, show-qid(I)) . 
  eq show-type(L, t1 * t2)
   = '_*_[show-type(L, t1), show-type(L, t2)] .


  *** the methods below show terms in AS

   var whenList whenList1 whenList2 : WhenList .
   
  
   var ntlist1 ntlist2 : List{NatTerm} .
   var blist blist1 blist2 : List{Bounds} .
   var n : Nat .


  op showAS-cases : QidSet Cases -> Term .
  eq showAS-cases(QIS, R) 
   = showAS-reaction(QIS, R) .
  eq showAS-cases(QIS, P) 
   = showAS-protocol(QIS, P) .
  eq showAS-cases(QIS, whenList) 
   = showAS-whenList(QIS, whenList) .

   var whenCond : WhenCond .
   var when : When .
 
  op showAS-whenList : QidSet WhenList -> Term .
  eq showAS-whenList(QIS, when) 
   = showAS-when(QIS, when) .
  eq showAS-whenList(QIS, when ;; whenList) 
   = '_;;_[
     showAS-when(QIS, when),
     showAS-whenList(QIS, whenList)
   ] .

  op showAS-when : QidSet When -> Term .
  eq showAS-when(QIS, whenCond --> R) 
   = '_-->_[
      showAS-whenCond(QIS, whenCond),
      showAS-reaction(QIS, R)
   ] .
  eq showAS-when(QIS, whenCond --> P) 
   = '_-->_[
      showAS-whenCond(QIS, whenCond),
      showAS-protocol(QIS, P)
   ] . 

  op showAS-whenCond : QidSet WhenCond -> Term .
  eq showAS-whenCond(QIS, whenCond)
   = upTerm(whenCond) .

  op showAS-natTerm : QidSet NatTerm -> Term .
  eq showAS-natTerm(QIS ; q , qidAsTerm(q)) = 'qidAsTerm_[var(q, 'Qid)] .
  eq showAS-natTerm(QIS, qidAsTerm(q)) = upTerm(qidAsTerm(q)) .
  eq showAS-natTerm(QIS, natAsTerm(n)) = upTerm(natAsTerm(n)) .
  eq showAS-natTerm(QIS, nt1 + nt2) 
   = '_+_[
       showAS-natTerm(QIS, nt1), 
       showAS-natTerm(QIS, nt2)] .
  eq showAS-natTerm(QIS, nt1 - nt2) 
   = '_-_[
       showAS-natTerm(QIS, nt1), 
       showAS-natTerm(QIS, nt2)] .     
  eq showAS-natTerm(QIS, nt1 * nt2) 
   = '_*_[
       showAS-natTerm(QIS, nt1), 
       showAS-natTerm(QIS, nt2)] .     
  eq showAS-natTerm(QIS, fun q nt) 
   = 'fun__[
       upTerm(q), 
       showAS-natTerm(QIS, nt)] .     

  op showAS-natTerms : QidSet List{NatTerm} -> Term . 
  eq showAS-natTerms(QIS, nt) = showAS-natTerm(QIS, nt) .
  eq showAS-natTerms(QIS, ntlist1 ntlist2) = 
     '__[ 
        showAS-natTerms(QIS, ntlist1),
        showAS-natTerms(QIS, ntlist2)
      ] .

  op showAS-boolTerm : QidSet BoolTerm -> Term .
  eq showAS-boolTerm(QIS, bt)
   = upTerm(bt) .

  var A : Set{BoolTerm} .

  op showAS-boolTerms : QidSet Set{BoolTerm} -> Term .
  eq showAS-boolTerms(QIS, empty) = 
     'A:Set`{BoolTerm`} .
      
  eq showAS-boolTerms(QIS, (A, bt))
   = '_`,_['A:Set`{BoolTerm`}, showAS-boolTermsAux(QIS, (A, bt))]. 
 
  op showAS-boolTermsAux : QidSet Set{BoolTerm} -> NeGroundTermList .
  eq showAS-boolTermsAux(QIS, bt) =
     showAS-boolTerm(QIS, bt) .
  eq showAS-boolTermsAux(QIS, (bt, A)) =
     showAS-boolTerm(QIS, bt) , showAS-boolTermsAux(QIS, A) .    

  op showAS-bound : QidSet Bounds -> Term .
  eq showAS-bound(QIS, bd)
   = upTerm(bd) .
  
  op showAS-bounds : QidSet List{Bounds} -> Term .
  eq showAS-bounds(QIS, blist)
   = upTerm(blist) .

  op showAS-cName : QidSet ChannelName -> Term .
  ceq showAS-cName(QIS, q) = var(q, 'ChannelName) 
  if q in QIS .
  eq showAS-cName(QIS, q) = upTerm(q) [owise].
  ceq showAS-cName(QIS, q[nlist]) =
     '_`[_`][
      var(q, 'Qid),
      showAS-natTerms(QIS, nlist)
     ] 
   if q in QIS .
   eq showAS-cName(QIS, q[nlist]) =
     '_`[_`][
      upTerm(q),
      showAS-natTerms(QIS, nlist)
     ] 
   [owise] .   

  op showAS-protocol : QidSet Protocol -> Term .
  eq showAS-protocol(QIS, emptyProtocol) 
   = 'emptyProtocol.Protocol .
  eq showAS-protocol(QIS, protocolRef(q)) 
   = 'protocolRef[upTerm(q)] . 
  eq showAS-protocol(QIS, cn ::= cases) 
   =  '_::=_[
        showAS-cName(QIS, cn),
        showAS-cases(QIS, cases)
      ] .
  eq showAS-protocol(QIS, P || P1) 
   = '_||_[
      showAS-protocol(QIS, P),
      showAS-protocol(QIS, P1)
     ] .    
  eq showAS-protocol(QIS, new q : T in P) *** TODO: missing for q[nlist]!
   = 'new_:_in_[
      var(q, 'Qid),
      upTerm(T),
      showAS-protocol(QIS, P)
     ] .
  eq showAS-protocol(QIS, newfamily q[blist] nlist blist : T in P)
   = 'newfamily___:_in_[
      '_`[_`][var(q, 'Qid),
      showAS-bounds(QIS, blist)
      ],
      showAS-natTerms(addIndices(QIS, nlist), nlist),
      showAS-bounds(QIS, blist),
      upTerm(T),
      showAS-protocol(QIS, P)
     ] . 
  eq showAS-protocol(QIS, family q[blist] nlist blist ::= cases)
   = 'family___::=_[
      '_`[_`][var(q, 'Qid),
      showAS-bounds(QIS, blist)
      ],
      showAS-natTerms(addIndices(QIS, nlist), nlist),
      showAS-bounds(QIS, blist),
      showAS-cases(addIndices(QIS, nlist), cases)
     ] .   
   eq showAS-protocol(QIS, newNF(ltq, P)) 
    = 'newNF[
       showAS-typedCNameList(QIS, ltq),
       showAS-protocol(QIS, P)
    ] . 

   op assumChannels_ : Protocol -> List{CNameBound} .
   eq assumChannels newNF(ltq, P) = nil .
   eq assumChannels (cn ::= cases) = chn cn .
   eq assumChannels (family fn nlist blist ::= cases) = fam fn .
   eq assumChannels (new cn : T in P) = nil .
   eq assumChannels (newfamily fn nlist blist : T in P) = nil .
   eq assumChannels (P1 || P2) = (assumChannels P1) (assumChannels P2) .
   eq assumChannels (protocolRef(q)) = nil .

   op showAS-typedCNameList :  QidSet TypedCNameList -> Term . 
   eq showAS-typedCNameList(QIS, < cn : T >)
    = '<_:_>[ showAS-cName(QIS, cn), upTerm(T)] . 
   eq showAS-typedCNameList(QIS, {(q[blist]) nlist : T})
    =  '`{__:_`}['_`[_`][var(q, 'Qid),
      showAS-bounds(QIS, blist)
      ],
                 showAS-natTerms(addIndices(QIS, nlist), nlist),
                 upTerm(T) ] .

  op addIndices : QidSet List{NatTerm} -> QidSet .
  eq addIndices(QIS, qidAsTerm q) = (QIS ; q) .
  eq addIndices(QIS, (qidAsTerm q) nlist) = addIndices(QIS ; q, nlist) .         


  op showAS-reaction : QidSet Reaction -> Term .
  eq showAS-reaction(QIS, samp (q < E >)) = 
     'samp_['_<_>[upTerm(q), showAS-expression(QIS, E)]].
  eq showAS-reaction(QIS, return E) =
     'return_[showAS-expression(QIS, E)] .
  ceq showAS-reaction(QIS, read q) = 
     'read_[var(q, 'ChannelName)] 
  if q in QIS .
  eq showAS-reaction(QIS, read q) = 
     'read_[upTerm(q)] 
  [owise]. 
  ceq showAS-reaction(QIS, read (q[nlist]) ) 
   = 'read_[
       '_`[_`][var(q, 'Qid), showAS-natTerms(QIS, nlist)]
   ] 
   if q in QIS .
  eq showAS-reaction(QIS, read (q[nlist]) ) 
   = 'read_[
       '_`[_`][upTerm(q), showAS-natTerms(QIS, nlist)]
   ] 
  [owise] .    
  eq showAS-reaction(QIS, if E then R1 else R2) = 
     'if_then_else_[
        showAS-expression(QIS, E), 
        showAS-reaction(QIS, R1),
        showAS-reaction(QIS, R2)] .
  eq showAS-reaction(QIS, q : T <- R1 ; R2) =  
      '_:_<-_;_[
      showAS-expression(QIS, q),
      upTerm(T),
      showAS-reaction(QIS, R1),
      showAS-reaction(QIS, R2)
      ] . 
  eq showAS-reaction(QIS, nf(BL, R)) =  
    'nf[
       showAS-binds(QIS, BL), 
       showAS-reaction(QIS, R)
       ] . 
  eq showAS-reaction(QIS, preNF(BL, R)) =  
    'preNF[
       showAS-binds(QIS, BL), 
       showAS-reaction(QIS, R)] .          

  op showAS-expression : QidSet Expression -> Term .
  eq showAS-expression(QIS, True) = 'True.IPDLExpression .
  eq showAS-expression(QIS, False) = 'False.IPDLExpression .
  eq showAS-expression(QIS, ()) = upTerm(()).
  eq showAS-expression((QIS ; q), q) = var(q, 'Qid) .
  eq showAS-expression(QIS, q) = upTerm(q) [owise] .
  eq showAS-expression(QIS, fst E) = 
     'fst_[
      showAS-expression(QIS, E)
     ] .
  eq showAS-expression(QIS, snd E) = 
     'snd_[
      showAS-expression(QIS, E)
     ] .   
  eq showAS-expression(QIS, ap q E) = 
     'ap__[
      upTerm(q), *** no function variables
      showAS-expression(QIS, E)
     ] .
  eq showAS-expression(QIS, pair(E1, E2)) =
    'pair[
      showAS-expression(QIS, E1),
      showAS-expression(QIS, E2)
    ] .

    op showAS-expressionIPDL : QidSet Expression -> Term .
  eq showAS-expressionIPDL(QIS, True) = 'True.IPDLExpression .
  eq showAS-expressionIPDL(QIS, False) = 'False.IPDLExpression .
  eq showAS-expressionIPDL(QIS, ()) = upTerm(()).
  eq showAS-expressionIPDL((QIS ; q), q) = var(q, 'IPDLExpression) .
  eq showAS-expressionIPDL(QIS, q) = upTerm(q) [owise] .
  eq showAS-expressionIPDL(QIS, fst E) = 
     'fst_[
      showAS-expressionIPDL(QIS, E)
     ] .
  eq showAS-expressionIPDL(QIS, snd E) = 
     'snd_[
      showAS-expressionIPDL(QIS, E)
     ] .   
  eq showAS-expressionIPDL(QIS, ap q E) = 
     'ap__[
      upTerm(q), *** no function variables
      showAS-expressionIPDL(QIS, E)
     ] .
  eq showAS-expressionIPDL(QIS, pair(E1, E2)) =
    'pair[
      showAS-expressionIPDL(QIS, E1),
      showAS-expressionIPDL(QIS, E2)
    ] .

  op showAS-binds : QidSet BindList -> Term .
  eq showAS-binds(QIS, emptyBRList) = 'emptyBRList.BRList .
  eq showAS-binds(QIS, q : T <~ R) = 
      '_:_<~_[ 
        showAS-expression(QIS, q),
        upTerm(T),
        showAS-reaction(QIS, R)
      ] .
  eq showAS-binds(QIS, q : T <- R) = 
      '_:_<-_[ 
        showAS-expression(QIS, q),
        upTerm(T),
        showAS-reaction(QIS, R)
      ] .  
  eq showAS-binds(QIS, (q : T <~ R) BL1) =
     '__[
      showAS-bindsAux(QIS, (q : T <~ R) BL1)
     ] .
  eq showAS-binds(QIS, (q : T <- R) BL1) =
     '__[
      showAS-bindsAux(QIS, (q : T <- R) BL1)
     ] .       

  op showAS-bindsAux : QidSet BindList -> NeGroundTermList .  
  eq showAS-bindsAux(QIS, q : T <~ R) = 
     '_:_<~_[ 
        showAS-expression(QIS, q),
        upTerm(T),
        showAS-reaction(QIS, R)
      ]
   .
  eq showAS-bindsAux(QIS, q : T <- R) = 
     '_:_<-_[ 
        showAS-expression(QIS, q),
        upTerm(T),
        showAS-reaction(QIS, R)
      ]
  .
  eq showAS-bindsAux(QIS, (q : T <- R) BL1) =
     showAS-bindsAux(QIS, q : T <- R ) , showAS-bindsAux(QIS, BL1) .
  eq showAS-bindsAux(QIS, (q : T <~ R) BL1) =
     showAS-bindsAux(QIS, q : T <~ R ) , showAS-bindsAux(QIS, BL1) .   


  op showAS-delta : ChannelContext -> Term .
  eq showAS-delta(Delta) = 'Delta:ChannelContext .
  *** eq showAS-delta(emptyChannelCtx)  = 'Delta:ChannelContext .
  *** eq showAS-delta(Delta) = '__['Delta:ChannelContext, showAS-deltaAux(Delta)]  [owise] .  

  var tc : TypedChannel .

  op showAS-deltaAux : ChannelContext -> NeGroundTermList .
  eq showAS-deltaAux(fam (q[blist]) :: T)
   = '_::_['fam_['_`[_`][var(q, 'Qid), showAS-bounds(none, blist)]], upTerm(T)] .
  eq showAS-deltaAux(chn cn :: T) =
    '_::_['chn_[var(cn, 'ChannelName)],upTerm(T)] .
  eq showAS-deltaAux(tc Delta) =
     showAS-deltaAux(tc) , showAS-deltaAux(Delta) .  

  op showAS-gamma : TypeContext -> Term .
  eq showAS-gamma(emptyTypeContext)  = 'Gamma:TypeContext .
  eq showAS-gamma(Gamma) = '__['Gamma:TypeContext, showAS-gammaAux(Gamma)]  [owise] .  

  op showAS-gammaAux : TypeContext -> NeGroundTermList .
  eq showAS-gammaAux(q : typeName q1) =
    '_:_[var(q, 'Qid), 'typeName_[upTerm(q1)]] . *** TODO: correct here!
  eq showAS-gammaAux((q : T) Gamma) =
     showAS-gammaAux(q : T) , showAS-gammaAux(Gamma) . 

  op showAS-inputs : Set{CNameBound} -> Term .
  eq showAS-inputs(Ins) = 'Ins:Set`{CNameBound`} . 
  *** eq showAS-inputs(empty)  = 'empty.Set`{CNameBound`} .
  *** eq showAS-inputs(Ins) = showAS-inputsAux(Ins)  [owise] .

  op showAS-outputs : Set{CNameBound} -> Term .
  eq showAS-outputs(Ins)  = 'Outs:Set`{CNameBound`} .
  *** eq showAS-outputs(Ins) = '_`,_['Outs:Set`{CNameBound`}, showAS-inputsAux(Ins)]  [owise] .

  op showAS-inputsAux : Set{CNameBound} -> NeGroundTermList .
  eq showAS-inputsAux(fam (q[blist])) =
     'fam_['_`[_`][var(q, 'Qid), showAS-bounds(none, blist)]] .
  eq showAS-inputsAux(chn cn) = 'chn_[var(cn, 'ChannelName)] .
  eq showAS-inputsAux((cnb, Ins)) =
     showAS-inputsAux(cnb) , showAS-inputsAux(Ins) .   

endfm

********************************************************************************

mod IPDL/ANALYSIS-STATE is
  
  protecting IPDL/READ .
  protecting IPDL/SHOW .
  protecting NUM/SHOW .
  protecting IPDL/LANGUAGE .

  protecting PROTOCOL-EQ-HELPERS .
  protecting APPROX-EQUALITY .

  protecting SET{Int} .
 
  var L : IPDL .
  var QIS QIS' : QidSet .
  var QIL : QidList .
  var q ns : Qid .
  vars I I1 I2 I3 I4 I5 VS DT CT IT RT1 RT2 RP1 RP2 : ATerm .
  var aConf : ApproxEqConfig .
  var pConf pConf' : ProtocolConfig .
  var Sigma : Signature .
  var Delta : ChannelContext .
  var Gamma Gamma' : TypeContext .
  var Ins Outs : Set{CNameBound} .
  var A : Set{BoolTerm} .
  var P P' P2 : Protocol .
  var R1 R2 : Reaction .
  var T1 T2 : IPDLType . 
  var t1 t2 : IPDLPreType .
  var protMap protMap' : Map{Qid, Protocol} .
  var cnb : CNameBound .
  var blist blist1 blist2 : List{Bounds} .
  var fn1 fn2 : FamilyName .
  var deltaMap : Map{Qid, PairSetIO} .
  var embMap embMap' : Map{Qid, IPDLEmbedding} .

  var ISet : Set{Int} .
  var i i' : Int .

  var PCL1 PCL2 : List{ApproxEqConfig} .
  
  var env env' : Env .
  var m m' : Module .
  var TCS TCS'  : Set{TypeContextElem} .
  var PS PS' : TypeContext .
   var wid : Width .
   var len : Length .
   var env1 env2 : Env .
   var aStrat1 aStrat2 : Strategy .
    var aProof pr1 pr2 : Proof{IPDL} .
   var q1 q2 q' : Qid .
   var cnb1 cnb2 : CNameBound .
   var qpl : QidPairList .
     var dIns dOuts : ChannelContext .
  var Sigma' : Signature .
  var Delta' : ChannelContext .
  var Ins' Outs' : Set{CNameBound} .
  vars A' : Set{BoolTerm} .
  var aStrat aStrat' : Strategy .
  var Tm : Term .
  var TP : Type .

  var cn1 cn2 : ChannelName . 
   var cnb3 : CNameBound .

   var H : Header .
  var IL : ImportList .
  var SS : SortSet .
  var SSDS : SubsortDeclSet .
  var OPDS : OpDeclSet .
  var MAS : MembAxSet .
  var EQS : EquationSet .
  var RLS : RuleSet .
  var SDCLS : StratDeclSet .
  var SDEFS : StratDefSet .

  op srewPConfig__ : Env Strategy -> Env .
  ceq srewPConfig env aStrat = setPConfig env (downTerm(Tm, eConfig))
  if {Tm, TP} := 
      metaSrewrite(  
        getModule env,
        upTerm(getPConfig env),
        aStrat,
        breadthFirst,
        0
      )  [label srewPConfig]  .
  eq srewPConfig env aStrat = env [owise] .   

  op srewAConfig__ : Env Strategy -> Env .
  ceq srewAConfig env aStrat = setAConfig env (downTerm(Tm, emptyAConfig))
  if {Tm, TP} := 
      metaSrewrite(  
        (getModule env),
        upTerm(getAConfig env),
        aStrat,
        breadthFirst,
        0
      )  [label srewAConfig]  .
  *** eq srewAConfig env aStrat = env [owise] . 


  var countb contextb : ComplexityBound .

   ***  set the protocol in newNF
  *** also update Delta, Ins, Outs
  *** a default 'emptyProtocol for no update at protocol, used internal only.
  op updatePConfig___ : Env Qid Qid -> Env .
  ceq updatePConfig (buildEnv (aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A)
                                       , countb, contextb) PCL1)
        (deltaMap, q2 |-> dIns pairSetIO dOuts)  
        protMap embMap m TCS QIS PS aConf
        ) 
       q1 q2
       =
      (buildEnv 
        (aConfig(
         pConfig(Sigma, dIns dOuts, P, toCNameBoundSet dIns, toCNameBoundSet dOuts, A),
         emptyBound, emptyBound)
         PCL1
        )
        (deltaMap, q2 |-> dIns pairSetIO  dOuts) protMap embMap m TCS QIS PS aConf) 
  if q1 == 'emptyProtocol . 
  eq updatePConfig 
       (buildEnv (aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) PCL1)
        (deltaMap, q2 |-> dIns pairSetIO  dOuts)  
        (protMap, q1 |-> P2) embMap m TCS QIS PS aConf
        ) 
       q1 q2
       =
      (buildEnv 
         (aConfig(pConfig(Sigma, dIns dOuts, 
           computeNF(P2), 
           toCNameBoundSet dIns, toCNameBoundSet dOuts, A), emptyBound, emptyBound) PCL1) 
         (deltaMap, q2 |->  dIns pairSetIO dOuts) (protMap, q1 |-> P2) embMap m 
         TCS QIS PS aConf
      ) 
           [owise]   .


  op _>>=_ : Env ATerm -> Env .
  ceq env >>= {'hypothesis_.[I] : 'HypoDecl}
   =  setPConfig env (pConfig (Sigma, Delta, P, Ins, Outs, (A, read-boolTerm(IPDL, I)))) 
  if pConfig(Sigma, Delta, P, Ins, Outs, A) := getPConfig env .

  *** setDeltaMap to record the channel context 
  *** updatePConfig to change Delta, Ins, Outs in the current env
  eq env >>= {'channel`context_=_. [I1, I2] : 'DeltaDecl } 
    = updatePConfig 
         (setDeltaMap env (getDeltaMap env, 
            read-qid(I1) |-> 
            read-channelDeclList(IPDL, emptyChannelCtx pairSetIO emptyChannelCtx ,I2) )
         )
       'emptyProtocol read-qid(I1)
   .

  var n : Nat .
  eq env >>= {'embedding_from_to_=_. [I, I1, I2, I3] : 'EmbedDecl}
   = setEmbMap env 
      (getEmbMap env, 
      (read-qid(I) |-> 
        read-qid(I) 
        from (toChannelContext ((getDeltaMap env)[read-qid(I1)])) 
        to (toChannelContext ((getDeltaMap env)[read-qid(I2)]) ) 
        is read-cNameMap(IPDL, I3) ))
  .    
  eq env >>= {'type_.[I] : 'TypeDecl}
   =  setPConfig env (addTypeToSig read-qid(I) (getPConfig env) ) .
  eq env >>= {'function_:_->_.[I, I1, I2] : 'OpDecl}
   = setPConfig env ( addOpToSig read-qid(I) read-type(IPDL, I1) read-type(IPDL, I2) (getPConfig env) ) .
  eq env >>= {'distribution_:_->_.[I, I1, I2] : 'DistDecl}
   = setPConfig env ( addDistToSig read-qid(I) read-type(IPDL, I1) read-type(IPDL, I2)  (getPConfig env) )  . 
***   ceq env >>= {'input_:_.[I, I1] : 'InDecl}
***    = setPConfig env (addInput (chn read-cNameIndex(IPDL, I)) preToType(read-type(IPDL, I1)) (getPConfig env)) 
***   if I :: 'CNameIndex .
***   ceq env >>= {'input_:_.[I, I1] : 'InDecl}
***    = setPConfig env (addInput (chn read-cNameIndex(IPDL, I)) preToType(read-type(IPDL, I1)) (getPConfig env)) 
***   if I :: 'CName .
***   ceq env >>= {'input_:_.[I, I1] : 'InDecl}
***    = setPConfig env (addInput (fam read-familyName(IPDL, I)) preToType(read-type(IPDL, I1)) (getPConfig env)) 
***   if I :: 'FamilyName .
  eq env >>= {'parameter_:_.[I, I1] : 'ParamDecl}
   = setEnvParams env 
       (getEnvParams env , read-qid(I) : preToType(read-type(IPDL, I1))) .
***   ceq env >>= {'output_:_.[I, I1] : 'OutDecl}
***    = setPConfig env (addOutput (chn read-cNameIndex(IPDL, I)) preToType(read-type(IPDL, I1)) (getPConfig env)) 
***   if I :: 'CName .       
***   ceq env >>= {'output_:_.[I, I1] : 'OutDecl}
***    = setPConfig env (addOutput (chn read-cNameIndex(IPDL, I)) preToType(read-type(IPDL, I1)) (getPConfig env)) 
***   if I :: 'CNameIndex . 
***   ceq env >>= {'output_:_.[I, I1] : 'OutDecl}
***    = setPConfig env (addOutput (fam read-familyName(IPDL, I)) preToType(read-type(IPDL, I1)) (getPConfig env)) 
***   if I :: 'FamilyName . 
  eq env >>= {'protocol_=_.[I, I1] : 'PDecl}
   = setPMap env 
             (addProtocol read-qid(I) read-protocol(IPDL, env, I1) (getPMap env)) . 
  eq env >>= {'protocol_.[I] : 'PDecl}
   = setPMap env 
             (addProtocol read-qid(I) protocolRef(read-qid(I)) (getPMap env)) .            
  eq env >>= {'import_.[I] : 'Import}
   = setModule env (addImport (getModule env) read-qid(I))
  .    
  eq env >>= {I : 'AssumName}
   = setAssums env (getAssums env ; read-qid(I)) .            

 *** strict proofs
 *** init proof
 eq env >>= {'start`with_over_[I1, I2] : 'StrictProof}   
   = srewPConfig 
      ( updatePConfig env read-qid(I1) read-qid(I2) ) 
      ( 'sugar-newNF[none]{empty} 
      ; 'allNewToFront[[empty]] 
      )
   .
   ceq env >>= {'fold_into_[I1, I2] : 'StrictProof}
   = srewPConfig env ('fold[[upTerm(cnb1), upTerm(cnb2) ]]) 
  if cnb1 := read-cNameBound(IPDL, I1) 
  /\ cnb2 := read-cNameBound(IPDL, I2) .
  eq env >>= {'rename_in_[I1, I2] : 'StrictProof}
   = srewPConfig env ('applyAlphaNFPr[[upTerm(read-cNameBound(IPDL, I2)), 
                                       upTerm(read-qidPairList(IPDL, I1) emptyQidPairList) ]]) 
  .
  eq env >>= {'rename`variables_of_[I1, I2] : 'StrictProof}
   = srewPConfig env ('applyAlphaFamilyThree[[upTerm(read-cNameBound(IPDL, I2)), 
                                       upTerm(read-qidPairList(IPDL, I1) emptyQidPairList) ]]) 
  .
  eq env >>= {'absorb_[I] : 'StrictProof}
   = srewPConfig env ('absorb[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .
  ceq env >>= {'group-absorb_[I] : 'StrictProof}
   = srewPConfig env ('absorbGroup[[ upTerm(fam fn1) ]]) 
  if group fn1 := read-ruleTarget(IPDL, I)
  .
  eq env >>= {'decompose_with_[I1, I2] : 'StrictProof}
   = srewPConfig env 
     ('applyUngroupFamiliesNew[[upTerm(read-cNameBound(IPDL, I1)), upTerm(read-cNameBound(IPDL, I2))]])
  .
  eq env >>= {'save`current`configuration.StrictProof : 'StrictProof}
   = setCrtConf env (getAConfig env)
  .  
  eq env >>= {'split_on`first`index [ I ] : 'StrictProof } 
   = srewPConfig env ('topSplitFstIndex[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .
  ceq env >>= {'split_on`first`index`inside_ [ I1, I2 ] : 'StrictProof } 
   = srewPConfig 
      env 
      ('applySplitFstBranches[[upTerm(fam fn1), upTerm(read-cNameBound(IPDL, I1))]]) 
   if group fn1 := read-ruleTarget(IPDL, I2)  
  .
  eq env >>= {'unsplit_ [ I ] : 'StrictProof } 
   = srewPConfig env ('topUnsplit[[upTerm(read-cNameIndex(IPDL, I)) ]]) 
  .
  eq env >>= {'split_on`second`index [ I ] : 'StrictProof } 
   = srewPConfig env ('topSplitSndIndex[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .
  eq env >>= {'turn`otherwise`into`neg`for_[I] : 'StrictProof}
   = srewPConfig env ('applyOtherwiseToNeg[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .
  eq env >>= {'turn`neg`into`otherwise`for_[I] : 'StrictProof}
   = srewPConfig env ('applyNegToOtherwise[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .
  eq env >>= {'combine_[I] : 'StrictProof}
   = srewPConfig env ('applyNewCombine[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .
   eq env >>= {'combine_into`families[I] : 'StrictProof}
   = srewPConfig env ('applyNewCombineFam[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .
  eq env >>= {'compose_with_in`group [I1, I2] : 'StrictProof }
   = srewPConfig env 
     ('applyGroupFamiliesNew[[upTerm(read-cNameBound(IPDL, I1)), upTerm(read-cNameBound(IPDL, I2))]])
  .   
  ceq env >>= {'call_[I] : 'StrictProof} 
   = srewPConfig env
     (q [[ empty ]]) 
   if q := read-qid(I)  .
  ceq env >>= {'use`lemma_run [I] : 'StrictProof} 
   = setModule 
    (
     srewPConfig env
     (q [[ empty ]]) 
    ) 
     (runLemma env (getModule env) ({'use`lemma_run[I] : 'StrictProof} )) 
   if q := read-qid(I).

*** helper
  op runLemma___ : Env Module ATerm -> Module .
  ceq runLemma env m ({'use`lemma_run[I1] : 'StrictProof} )
   = if qid(q '-flag) in (getAllStratNames m)
       then m
       else (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS (SDCLS
     strat qid(q '-flag) : nil @ 'ProtocolConfig [none] .
     ) (SDEFS
     sd qid(q '-flag)[[ empty ]] := idle [none] .
     )
     endsm
     )
       fi
  if q := read-qid(I1)
  /\ (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS
    SDEFS
     endsm
  ) := m .

   ceq env >>= {'use`lemma_trust [I] : 'StrictProof} 
   = srewPConfig env
     (qid(q '-trust) [[ empty ]]) 
   if q := read-qid(I)  . 
  eq env >>= {'ungroup_[I] : 'StrictProof} 
   = srewPConfig env
     ('applyDropName[[upTerm(read-cNameBound(IPDL, I)) ]])
  .   
  eq env >>= {'subst_into_[I1, I2] : 'StrictProof}
   = srewPConfig env ('subst[[upTerm(read-cNameBound(IPDL, I1)), upTerm(read-cNameBound(IPDL, I2)) ]]) 
  .
  eq env >>= {'subst_into_at_[I1, I2, I3] : 'StrictProof}
   = srewPConfig env 
    ('substAt[[upTerm(read-cNameBound(IPDL, I1)), 
               upTerm(read-cNameBound(IPDL, I2)), 
               upTerm(read-qid(I3))]]) 
  .
  eq env >>= {'drop`read_from_[I1, I2] : 'StrictProof}
   = srewPConfig env ('dropSubsume[[upTerm(read-cNameBound(IPDL, I1)), upTerm(read-cNameBound(IPDL, I2)) ]]) 
  .
  ceq env >>= {'drop`read`branch_of_from_[I, I1, I2] : 'StrictProof}
   = srewPConfig env 
      ('metaDropSubsumeCase[[
          upTerm(read-cNameBound(IPDL, I1)), 
          upTerm(read-cNameBound(IPDL, I2)),
          upTerm(bt) ]]) 
  if when bt := read-whenCond(IPDL, I)       
  .
  eq env >>= {'add`internal`family_indices:_bounds:_typed:_assigned:_ [I, I1, I2, CT, I3] : 'StrictProof}
   = srewPConfig env 
     ('addInternalFam[[
        upTerm(read-qid(I)), 
        upTerm(preToType(read-type(IPDL, CT))),
        upTerm(read-natTerms(IPDL, I1)), 
        upTerm(read-bounds(IPDL, I2)),
        upTerm(computeNF(read-cases(IPDL, env, I3)))   ]]
      ) .  
  eq env >>= {'add`internal`channel_typed:_assigned:_ [I, CT, I3] : 'StrictProof}
   = srewPConfig env 
     ('applyAddInternalChannel[[
        upTerm(read-cNameIndex(IPDL, I)), 
        upTerm(preToType(read-type(IPDL, CT))),
        upTerm(computeNF(read-cases(IPDL, env, I3)))   ]]
      ) .      
  eq env >>= {'merge`cases`for_[I] : 'StrictProof}
   = srewPConfig env ('mergeCases[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .  
  ceq env >>= {'move_on`each`branch`of_ [I1, I2] : 'StrictProof }
   = srewPConfig env ('metaMoveFamToGroup[[ upTerm(fam fn1), upTerm(fam fn2) ]])
  if family fn1 := read-ruleTarget(IPDL, I1)
  /\ group fn2 := read-ruleTarget(IPDL, I2)
  . 
   ceq env >>= {'move_on`each`branch`of_ [I1, I2] : 'StrictProof }
   = srewPConfig env ('applyAddChnToGroupSameCases[[ upTerm(fam fn2), upTerm(cn) ]])
  if channel cn := read-ruleTarget(IPDL, I1)
  /\ group fn2 := read-ruleTarget(IPDL, I2)
  . 
  eq env >>= {'merge`case_=_with`otherwise`for_[I, I1, I2] : 'StrictProof}
   = srewPConfig env ('mergeCaseWithOtherwise[[upTerm(read-cNameBound(IPDL, I2)), upTerm(read-natTerm(IPDL, I1)) ]]) 
  . 
  eq env >>= {'use`assumption_on_[I1, I2] : 'StrictProof} 
   = srewPConfig env ( qid('apply read-qid(I1)) [[upTerm(read-cNameBoundList(IPDL, env, I2)) ]] ) . 
  ceq env >>= {'use`expression`assumption_on_at_[I1, I2, I3] : 'StrictProof} 
   = srewPConfig env 
      ( qid('apply read-qid(I1)) [[upTerm(read-cNameBoundList(IPDL, env, I2)) , upTerm(n) ]] ) 
  if natAsTerm n := read-natTerm(IPDL, I3) .   
  eq env >>= {'todo.StrictProof : 'StrictProof} 
   = env . 
  eq env >>= {'idle.StrictProof : 'StrictProof} 
   = env .  
  ceq env >>= {'_then_[I1, I2] : 'StrictProof} 
   = env' >>= I2 
  if env' := env >>= I1 . 
  eq env >>= {'diverge`on_with_var_ [I, I1, I2] : 'StrictProof }
    = srewPConfig env 
       ('applySubstDivergeFamily[[
           upTerm(read-cNameBound(IPDL, I)),
           upTerm(read-cNameBound(IPDL, I1)), 
           upTerm(read-qid(I2)) ]]) .
   eq env >>= {'diverge`on_with`branch_of_var_ [I, I1, I2, I3] : 'StrictProof }
    = srewPConfig env 
       ('metaCaseDiverge[[
           upTerm(read-cNameBound(IPDL, I2)),
           upTerm(read-cNameBound(IPDL, I)),
           upTerm(read-boolTerm(IPDL, I1)), 
           upTerm(read-qid(I3)) ]]) .        
   eq env >>= {'reverse`subst_in_using_ [I1, I2, I3] : 'StrictProof }
    = srewPConfig env
       (
         'substNFReadRevFamilies[[
            upTerm(read-cNameBound(IPDL, I3)), 
            upTerm(read-cNameBound(IPDL, I2)), 
            upTerm(read-cNameBound(IPDL, I1))
         ]]
       ) .   
   eq env >>= {'subst`or`diverge_into_var_ [I1, I2, I3] : 'StrictProof}
    = srewPConfig env
       ('applySubstOrDiverge[[
          upTerm(read-cNameBound(IPDL, I1)), 
          upTerm(read-cNameBound(IPDL, I2)), 
          upTerm(read-qid(I3))
       ]]) .
   eq env >>= {'remove`only`branch`of_ [I] : 'StrictProof}
    = srewPConfig env 
       ('applyRemoveBranch[[ upTerm(read-cNameBound(IPDL, I)) ]])
   .
   ceq env >>= {'extract_from_into`group_ [I1, I2, I3] : 'StrictProof}
    = srewPConfig env 
       ('applyExtractSubgroup[[ 
          upTerm(fam fn1), 
          upTerm(read-cNameBoundList(IPDL, env, I1)),
          upTerm(read-qid(I3)) ]])
   if group fn1 := read-ruleTarget(IPDL, I2)    
   .   
   ceq env >>= {'discard`branch_of_ [I1, I2] : 'StrictProof}
    = srewPConfig env 
       ('metaDropBranch[[ 
          upTerm(read-cNameBound(IPDL, I2)), 
          upTerm(q),
          upTerm(nt) ]])
   if qidAsTerm q =T= nt := read-boolTerm(IPDL, I1)    
   .   
   eq env >>= {'fix`index`for_ [I] : 'StrictProof}
    = srewPConfig env 
       ('applyFixIndex[[ upTerm(read-cNameBound(IPDL, I)) ]])
   .       
   ceq env >>= {'split_inside_[I1, I2] : 'StrictProof} 
    = srewPConfig env 
       ('applySplitInsideGroup[[ upTerm(fam fn1), upTerm(read-cNameBound(IPDL, I1)) ]])
   if group fn1 := read-ruleTarget(IPDL, I2) .    
   eq env >>= {'unsplit_and_[I1, I2] : 'StrictProof}
    = srewPConfig env 
       ('metaUnsplit2[[ upTerm(read-cNameBound(IPDL, I1)), 
                             upTerm(read-cNameBound(IPDL, I2))]]) .
   ceq env >>= {'unsplit_and_inside_[I1, I2, I3] : 'StrictProof} 
    = srewPConfig env 
       ('applyUnsplitGroup[[ upTerm(fam fn1),
                             upTerm(read-cNameBound(IPDL, I1)), 
                             upTerm(read-cNameBound(IPDL, I2))
                             ]])
   if group fn1 := read-ruleTarget(IPDL, I3) .   
   ceq env >>= {'unit-ext`on_at_[I1, I2] : 'StrictProof}
    = srewPConfig env
       ('applyUnitExt[[ upTerm(read-cNameBound(IPDL, I1)), upTerm(n) ]])
   if natAsTerm n := read-natTerm(IPDL, I2) .  
   ceq env >>= {'rename`indices`to_in_[I1, I2] : 'StrictProof}
    = srewPConfig env
       ('metaRenameIndices[[ upTerm(read-cNameBound(IPDL, I2)), upTerm(qlist) ]])
    if qlist := natTermsToQid (read-natTerms(IPDL, I1)) .

   var qlist : QidList .
   op natTermsToQid : List{NatTerm} -> QidList .
   eq natTermsToQid(nil) = nil .
   eq natTermsToQid(qidAsTerm q) = q .
   eq natTermsToQid( (qidAsTerm q) tlist ) = q (natTermsToQid(tlist)) .


   ceq env >>= {'remove_from_[I1, I2] : 'StrictProof}
    = srewPConfig env
       ('applyRemoveFromGroupCases[[ upTerm(fam fn1), 
                                     upTerm(read-cNameBound(IPDL, I1)) ]])
   if group fn1 := read-ruleTarget(IPDL, I2) .                                   
   eq env >>= {'change`name_to_[I1, I2] : 'StrictProof}
    = srewPConfig env
       ('applyRenameGroup[[ upTerm(read-cNameBound(IPDL, I1)), upTerm(read-qid(I2)) ]]) .
   eq env >>= {'focus_`(_`)[I1, I2] : 'StrictProof}
     = srewPConfig
       (addStratDecls env {'focus_`(_`)[I1, I2] : 'StrictProof})
       (generatedStrategyCall env) .
   ceq env >>= {'remove`and`merge_from_ [I1, I2] : 'StrictProof}
    = srewPConfig env  
       ('applyRemoveMergeFromGroupCases[[ upTerm(fam fn1), upTerm(read-cNameBound(IPDL, I1)) ]]) 
   if group fn1 := read-ruleTarget(IPDL, I2) .
   ceq env >>= {'use`assumptions`for_in_ [I1, I2] : 'StrictProof}
    = srewPConfig env
      ('applyAlphaAssumChn[[upTerm(cn), upTerm(read-qid(I1))]]) 
   if chn cn := read-cNameBound(IPDL, I2) .
   eq env >>= {'merge`case`for_and_into`group_ [I1, I2, I3] : 'StrictProof} 
    = srewPConfig env 
      ('metaMerge[[ upTerm(read-cNameBound(IPDL, I1)),
                           upTerm(read-cNameBound(IPDL, I2)),
                           upTerm(read-qid(I3)) ]]) .

   eq env >>= {'on`all`branches`of_split_on`first`index [I1, I2] : 'StrictProof}
    = srewPConfig env
      ('applySplitFstBranches[[ 
         upTerm(read-cNameBound(IPDL, I1)),
         upTerm(read-cNameBound(IPDL, I2))
       ]]) .
   eq env >>= {'on`all`branches`of_split_on`second`index [I1, I2] : 'StrictProof}
    = srewPConfig env
      ('applySplitSndBranches[[ 
         upTerm(read-cNameBound(IPDL, I1)),
         upTerm(read-cNameBound(IPDL, I2))
       ]]) . 
  eq env >>= {'subst`branch_of_into_[I, I1, I2] : 'StrictProof}
   = srewPConfig
       (addStratDecls env {'subst`branch_of_into_[I, I1, I2] : 'StrictProof})
       (generatedStrategyCall env)
  .    
  eq env >>= {'subst`branch_of_into_at_[I, I1, I2, I3] : 'StrictProof}
   = srewPConfig
       (addStratDecls env {'subst`branch_of_into_at_[I, I1, I2, I3] : 'StrictProof})
       (generatedStrategyCall env)
  .     
  eq env >>= {'sym`from_`(_`)[I1, I2] : 'StrictProof}
   = srewPConfig
       (addStratDecls env {'sym`from_`(_`)[I1, I2] : 'StrictProof})
       (generatedStrategyCall env) .    
  eq env >>= {'sym`from_over_`(_`)[I, I1, I2] : 'StrictProof}
   = srewPConfig
       (addStratDecls env {'sym`from_over_`(_`)[I, I1, I2] : 'StrictProof})
       (generatedStrategyCall env) .             
  eq env >>= {'restructure_[I1] : 'StrictProof}
   = srewPConfig
       (addStratDecls env {'restructure_[I1] : 'StrictProof})
       (generatedStrategyCall env) .         
  eq env >>= {'bring`declarations`of`hidden`channels`in`front.StrictProof : 'StrictProof}        
   = srewPConfig env ('allNewToFront[[empty]]) .
  eq env >>= {'on`branch_of_`(_`) [I, I1, I2] : 'StrictProof }
   = srewPConfig
       (addStratDecls env {'on`branch_of_`(_`) [I, I1, I2] : 'StrictProof })
       (generatedStrategyCall env) .     
  eq env >>= {'case`distinction`on_`(_`) [I1, I2] : 'StrictProof}
   = srewPConfig
       (addStratDecls env {'case`distinction`on_`(_`) [I1, I2] : 'StrictProof})
       (generatedStrategyCall env) . 
  eq env >>= {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5 ] : 'StrictProof}
   = srewPConfig
       (addStratDecls env {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5 ] : 'StrictProof})
       (generatedStrategyCall env) . 
  eq env >>= {'rewrite_to_by`induction`on_bound_`(_`) 
                [I1, I2, I3, I4, I5 ] : 'StrictProof}
   = srewPConfig
       (addStratDecls env {'rewrite_to_by`induction`on_bound_`(_`) 
                [I1, I2, I3, I4, I5 ] : 'StrictProof})
       (generatedStrategyCall env) .      
  eq env >>= {'using_`(_`) [I1, I2] : 'StrictProof}
   = srewPConfig 
      (addStratDecls env {'using_`(_`) [I1, I2] : 'StrictProof})
      (generatedStrategyCall env) .
  eq env >>= {'using`branch_of_`(_`) [I, I1, I2] : 'StrictProof}
   = srewPConfig 
      (addStratDecls env {'using`branch_of_`(_`) [I, I1, I2] : 'StrictProof})
      (generatedStrategyCall env) .
  eq env >>= {'sym`var_terms_diverge_into_var_ [I, I1, I2, I3, I4] : 'StrictProof}
   = srewPConfig 
     env 
     ('symSubstDiverge[[ 
         upTerm(read-cNameBound(IPDL, I3)),
         upTerm(read-cNameBound(IPDL, I2)),
         upTerm(read-natTerms(IPDL, I1)),
         upTerm(read-qid(I)),
         upTerm(read-qid(I4))
       ]]) .


        
  *** helpers, meta rules

    *** do typeOf in the module of the env
  *** send the typeOf as a term

  var someTerm : Term .

  op metaTypeInCtx__ : Env Term -> IPDLType .
  ceq metaTypeInCtx env someTerm = 
   downTerm(Tm, bool)
  if {Tm, TP} := metaReduce( getModule env, someTerm )
  .
  
  op metaGetOutputs__ : Env Term -> Set{CNameBound} .
  ceq metaGetOutputs env someTerm = 
   downTerm(Tm, chn 'C)
  if {Tm, TP} := metaReduce( getModule env, someTerm )
  .

  op metaOccurs__ : Env Term -> Bool .
  ceq metaOccurs env someTerm = 
   downTerm(Tm, true)
  if {Tm, TP} := metaReduce( getModule env, someTerm )
  .

  op metaIsElemB__ : Env Term -> Bool .
  ceq metaIsElemB env someTerm = 
   downTerm(Tm, true)
  if {Tm, TP} := metaReduce( getModule env, someTerm )
  .

  op metaTypeOf__ : Env Term -> TypeWithError .
  ceq metaTypeOf env someTerm = 
   downTerm(Tm, bool)
  if {Tm, TP} := metaReduce( getModule env, someTerm )
  .
    
   
  *** helper,  addGenDecl
  op addGenDecl___ : Env Module ATerm -> Module .
 eq addGenDecl env m {'_then_[I1, I2] : 'StrictProof} 
  = addGenDecl env (
     addGenDecl env m I1
    ) I2 .
 *** create group
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ){'group_in_indices:_bounds:_[I, I1, I2, I3] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .
    )
    (SDEFS
       sd q[[ empty ]] := 
        matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using  'SYM[ 'Delta1:ChannelContext <- 'Delta:ChannelContext ; 
                 'O1:Set`{CNameBound`} <- 'Outs:Set`{CNameBound`} ; 
                 'P1:Protocol <- 'group_named_params__in_[
       upTerm(read-cNameBoundList(IPDL, env, I)),
       upTerm(read-qid(I1)),
       upTerm(read-natTerms(IPDL, I2)),
       upTerm(read-bounds(IPDL, I3)),
       'P:Protocol
   ]]
  {
    'applyDropName[[  upTerm(fam (read-qid(I1)[read-bounds(IPDL, I3)])) ]] 
  } 
  [none] .
 )
     endsm
  )    
 if  m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 . 
 *** subst branch into family at
  ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ){'subst`branch_of_into_at_[I, I1, I2, I3] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .
    )
    (SDEFS
       sd q[[ empty ]] := 
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    :  matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using  ('CONG-COMP-RIGHT[
        'Q:Protocol  <- 'removeAll__['P:Protocol, upTerm(  cnb1 (fam fn1) )] ;
        'P1:Protocol <- 'keepAll__['P:Protocol, upTerm( cnb1 (fam fn1) )]
        ]
  { 'select-case-subst-family-r[
      'bt:BoolTerm <- upTerm(bt)
     ]{
         'substAt[[ upTerm(cnb1), upTerm(fam fn1), upTerm(read-qid(I3)) ]]
     } }
     or-else 
     'select-case-subst-family-r[
      'bt:BoolTerm <- upTerm(bt)
     ]{
         'substAt[[ upTerm(cnb1), upTerm(fam fn1) , upTerm(read-qid(I3))]]
     }
        )   [none] .
  )
     endsm
  )  
   if  m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ cnb1 := read-cNameBound(IPDL, I1)
 /\ (fam fn1) := read-cNameBound(IPDL, I2) 
 /\ when bt := read-whenCond(IPDL, I)
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 . 
 *** subst branch into channel at
   ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ){'subst`branch_of_into_at_[I, I1, I2, I3] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .
    )
    (SDEFS
       sd q[[ empty ]] := 
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    :  matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using  ('CONG-COMP-RIGHT[
        'Q:Protocol  <- 'removeAll__['P:Protocol, upTerm(  cnb1 (chn cn) )] ;
        'P1:Protocol <- 'keepAll__['P:Protocol, upTerm( cnb1 (chn cn) )]
        ]
  { 'select-case-subst-family-r-gen[
      'bt:BoolTerm <- upTerm(bt)
     ]{
         'substAt[[ upTerm(cnb1), upTerm(chn cn) , upTerm(read-qid(I3)) ]]
     } }
     or-else 
     'select-case-subst-family-r-gen[
      'bt:BoolTerm <- upTerm(bt)
     ]{
         'substAt[[ upTerm(cnb1), upTerm(chn cn) , upTerm(read-qid(I3)) ]]
     } 
     ) [none] .
  )
     endsm
  )  
   if  m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ cnb1 := read-cNameBound(IPDL, I1)
 /\ chn cn := read-cNameBound(IPDL, I2) 
 /\ when bt := read-whenCond(IPDL, I)
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 .
  *** subst branch into family
  ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ){'subst`branch_of_into_[I, I1, I2] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .
    )
    (SDEFS
       sd q[[ empty ]] := 
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    :  matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using  ('CONG-COMP-RIGHT[
        'Q:Protocol  <- 'removeAll__['P:Protocol, upTerm(  cnb1 (fam fn1) )] ;
        'P1:Protocol <- 'keepAll__['P:Protocol, upTerm( cnb1 (fam fn1) )]
        ]
  { 'select-case-subst-family-r[
      'bt:BoolTerm <- upTerm(bt)
     ]{
         'subst[[ upTerm(cnb1), upTerm(fam fn1) ]]
     } }
     or-else 
     'select-case-subst-family-r[
      'bt:BoolTerm <- upTerm(bt)
     ]{
         'subst[[ upTerm(cnb1), upTerm(fam fn1) ]]
     }
        )   [none] .
  )
     endsm
  )  
   if  m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ cnb1 := read-cNameBound(IPDL, I1)
 /\ (fam fn1) := read-cNameBound(IPDL, I2) 
 /\ when bt := read-whenCond(IPDL, I)
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 . 
 *** subst branch into channel
   ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ){'subst`branch_of_into_[I, I1, I2] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .
    )
    (SDEFS
       sd q[[ empty ]] := 
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    :  matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using  ('CONG-COMP-RIGHT[
        'Q:Protocol  <- 'removeAll__['P:Protocol, upTerm(  cnb1 (chn cn) )] ;
        'P1:Protocol <- 'keepAll__['P:Protocol, upTerm( cnb1 (chn cn) )]
        ]
  { 'select-case-subst-family-r-gen[
      'bt:BoolTerm <- upTerm(bt)
     ]{
         'subst[[ upTerm(cnb1), upTerm(chn cn) ]]
     } }
     or-else 
     'select-case-subst-family-r-gen[
      'bt:BoolTerm <- upTerm(bt)
     ]{
         'subst[[ upTerm(cnb1), upTerm(chn cn) ]]
     } 
     ) [none] .
  )
     endsm
  )  
   if  m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ cnb1 := read-cNameBound(IPDL, I1)
 /\ chn cn := read-cNameBound(IPDL, I2) 
 /\ when bt := read-whenCond(IPDL, I)
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 .
 *** focus 
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'focus_`(_`)[I1, I2] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .
    )
    (SDEFS
       sd q[[ empty ]] := 
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    :  matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using  'CONG-COMP-RIGHT[
        'Q:Protocol  <- 'removeAll__['P:Protocol, upTerm(  cnbl )] ;
        'P1:Protocol <- 'keepAll__['P:Protocol, upTerm( cnbl )]
        ]
  { aStrat } [none] .
  )
     endsm
  )  
   if  m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ cnbl := read-cNameBoundList(IPDL, env, I1) 
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i)
 .   
 *** cong-family-r
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'on`reaction`of_`(_`) [I1, I2] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .
    )
    (SDEFS
       sd q[[ empty ]] := 
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    :  matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using  'CONG-COMP-RIGHT[
        'Q:Protocol  <- 'removeOne__['P:Protocol, upTerm(  fam (ns[blist]) )] ;
        'P1:Protocol <- 'keepOne__['P:Protocol, upTerm( fam (ns[blist]) )]
        ]
  {

 'CONG-FAMILY-R[none]{
         aStrat 
         or-else 
        'cong-nf[none]{aStrat}
       }
 } [none] .
 )
     endsm
  )    
 if  m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ fam (ns[blist]) := read-cNameBound(IPDL, I1) 
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ aStrat := reactionProofStep2Strategy(read-reactionProof(IPDL, I2)) 
 . 
 *** rewrite on a branch, reaction
  ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ){'on`branch_of_`(_`) [I, I1, I2] : 'StrictProof } =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .
    )
    (SDEFS
       sd q[[ empty ]] :=  
        match 'pConf:ProtocolConfig s.t. 
       ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
     ? 'CONG-NEW-NF[none]{ q [[ empty ]] } 
     :   
      'select-branch-family-r[ 
       'fns:NameWithScripts <- upTerm(ns) ;
       'blist:List`{Bounds`}  <- upTerm(blist) ;
       'bt:BoolTerm <- upTerm(bt)]
                 {
                  aStrat  
                  } 
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ bt := read-boolTerm(IPDL, I)
 /\ family (ns[blist]) := read-ruleTarget(IPDL, I1)
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i) .
 *** rewrite on a branch, protocol
  ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ){'on`branch_of_`(_`) [I, I1, I2] : 'StrictProof } =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .
    )
    (SDEFS
       sd q[[ empty ]] :=    
      'select-branch-family-p[ 
       'fns:NameWithScripts <- upTerm(ns) ;
       'blist:List`{Bounds`}  <- upTerm(blist) ;
       'bt:BoolTerm <- upTerm(bt)]
                 {
                  aStrat  
                  } 
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ bt := read-boolTerm(IPDL, I)
 /\ group (ns[blist]) := read-ruleTarget(IPDL, I1)
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i) .
 *** induction group
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5 ] : 'StrictProof}  =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] := 
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    :  matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using  'CONG-COMP-RIGHT[
        'Q:Protocol  <- 'removeAll__['P:Protocol, upTerm(cnbl ( fam (cn[blist]) ))] ;
        'P1:Protocol <- 'keepAll__['P:Protocol, upTerm(cnbl ( fam (cn[blist]) ))]
        ]
  {

 'SINGLE-INDUCTION-new[
  'idx:Qid <- upTerm(q1) ;
  'q:Qid <- upTerm(q2) ;
  'cn:ChannelName <- upTerm(cn) ;
  'blist:List`{Bounds`} <- upTerm(blist) ;
  'P2:Protocol <- upTerm(cases)
 ]{ aStrat
  }
 } [none]     
 
 . 
    
    )
     endsm
  )
 if qidAsTerm q1 := read-natTerm(IPDL, I4)
 /\ qidAsTerm q2 := read-natTerm(IPDL, I3)
 /\ m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )  
  /\ cnbl := read-cNameBoundList(IPDL, env, I)
  /\ cases := computeNF(read-cases(IPDL, env, I2))
  /\ ( group (cn[blist]) ) := read-ruleTarget(IPDL, I1)
  /\ i := getMaxUsedNumber m
  /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I5)) (2 + i) .
 *** induction family
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5 ] : 'StrictProof}  =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] := 
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    :  
      matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using  'CONG-COMP-RIGHT[
        'Q:Protocol  <- 'removeAll__['P:Protocol, upTerm(cnbl ( fam (ns[blist]) ))] ;
        'P1:Protocol <- 'keepAll__['P:Protocol, upTerm(cnbl ( fam (ns[blist]) ))]
        ]
  {
     'SINGLE-INDUCTION-new-R[
  'idx:Qid <- upTerm(q1) ;
  'q:Qid <- upTerm(q2) ;
  'cn:ChannelName <- upTerm(ns) ;
  'cases':Cases <- upTerm(cases)
   ]{ aStrat
    } 
  } [none] .   
      
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )  
  /\ qidAsTerm q1 := read-natTerm(IPDL, I4)
  /\ qidAsTerm q2 := read-natTerm(IPDL, I3) 
  /\ cnbl := read-cNameBoundList(IPDL, env, I)
  /\ cases := computeNF(read-cases(IPDL, env, I2))
  /\ ( family (ns[blist]) ) := read-ruleTarget(IPDL, I1)
  /\ i := getMaxUsedNumber m
  /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I5)) (2 + i) .
  *** induction group-no cong comp
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'rewrite_to_by`induction`on_bound_`(_`) 
                [I1, I2, I3, I4, I5 ] : 'StrictProof}  =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] := 
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    : 
 'SINGLE-INDUCTION-new[
  'idx:Qid <- upTerm(q1) ;
  'q:Qid <- upTerm(q2) ;
  'cn:ChannelName <- upTerm(cn) ;
  'blist:List`{Bounds`} <- upTerm(blist) ;
  'P2:Protocol <- upTerm(cases)
 ]{ aStrat
  }
 [none]     
 
 . 
    
    )
     endsm
  )
 if qidAsTerm q1 := read-natTerm(IPDL, I4)
 /\ qidAsTerm q2 := read-natTerm(IPDL, I3)
 /\ m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )  
  /\ cases := computeNF(read-cases(IPDL, env, I2))
  /\ ( group (cn[blist]) ) := read-ruleTarget(IPDL, I1)
  /\ i := getMaxUsedNumber m
  /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I5)) (2 + i) .
 *** induction family, no cong-comp
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'rewrite_to_by`induction`on_bound_`(_`) 
                [I1, I2, I3, I4, I5 ] : 'StrictProof}  =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] := 
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    :
     'SINGLE-INDUCTION-new-R[
  'idx:Qid <- upTerm(q1) ;
  'q:Qid <- upTerm(q2) ;
  'cn:ChannelName <- upTerm(ns) ;
  'cases':Cases <- upTerm(cases)
   ]{ aStrat
    } 
  [none] .   
      
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )  
  /\ qidAsTerm q1 := read-natTerm(IPDL, I4)
  /\ qidAsTerm q2 := read-natTerm(IPDL, I3) 
  /\ cases := computeNF(read-cases(IPDL, env, I2))
  /\ ( family (ns[blist]) ) := read-ruleTarget(IPDL, I1)
  /\ i := getMaxUsedNumber m
  /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I5)) (2 + i) .
 *** restructure
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'restructure_ [I1] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
   ***     match 'pConf:ProtocolConfig s.t. 
   ***    ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
   ***  ? 'CONG-NEW-NF[none]{q [[empty ]]} 
   ***  :   
    (matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using 'SYM[ 'Delta1:ChannelContext <- 'Delta:ChannelContext ; 
                 'O1:Set`{CNameBound`} <- 'Outs:Set`{CNameBound`} ; 
                 'P1:Protocol <- protocol2Term(env, I1)]
                 {'sugar-newNF[none]{empty};
                  *** 'moveNewToFront[[empty]] ; 
                  ( ('COMP-NEW-newNF-inside-new[none]{empty})! ) 
                   } 
    )          
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 .
  *** sym
  ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'sym`from_`(_`)[I1, I2] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
   ***     match 'pConf:ProtocolConfig s.t. 
   ***    ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
   ***  ? 'CONG-NEW-NF[none]{q [[empty ]]} 
   ***  :   
    (matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using 'SYM[ 'Delta1:ChannelContext <- 'Delta:ChannelContext ; 
                 'O1:Set`{CNameBound`} <- 'Outs:Set`{CNameBound`} ; 
                 'P1:Protocol <- protocol2Term(env, I1)]
                 {'sugar-newNF[none]{empty};
                  *** 'allNewToFront[[empty]] ; 
                  ( ('COMP-NEW-newNF-inside-new[none]{empty})! ) ;
                  aStrat  
                   } 
    ) ; 'sugar-newNF[none]{empty} 
       *** was ; 'allNewToFront[[empty]]
      ; ( ('COMP-NEW-newNF-inside-new[none]{empty})! )          
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i) .
 *** sym over delta
  ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'sym`from_over_`(_`)[I, I1, I2] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
   ***     match 'pConf:ProtocolConfig s.t. 
   ***    ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
   ***  ? 'CONG-NEW-NF[none]{q [[empty ]]} 
   ***  :   
     matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using 'SYM[ 'Delta1:ChannelContext <- upTerm(read-delta(IPDL, env, I1)) ; 
                 'O1:Set`{CNameBound`} <- upTerm(getOutputs(read-protocol(IPDL, env, I))) ; 
                 'P1:Protocol <- protocol2Term(env, I)]
                 {'sugar-newNF[none]{empty};
                  *** 'moveNewToFront[[empty]] ; 
                  ( ('COMP-NEW-newNF-inside-new[none]{empty})! ) ;
                  aStrat  
                   } 
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i) .
***(
  *** sym on change current protocol
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'sym`from_`(_`)[{'change_with_in_ [
    I1,
    I2,
    {'currentProtocol.IPDLProtocol : 'IPDLProtocol}
  ] : 'IPDLProtocol}, I3] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[empty ]]} 
    :   
     matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using 'SYM[ 'Delta1:ChannelContext <- 'Delta:ChannelContext ; 
                 'O1:Set`{CNameBound`} <- 'Outs:Set`{CNameBound`} ; 
                 'P1:Protocol <- 
                   'change_with_in_[ 
                      upTerm( read-cNameBound(IPDL, I1) ), 
                      upTerm(computeNF(read-cases(IPDL, env, I2))) ,
                    'P:Protocol
                   ]
               ]
                 {'sugar-newNF[none]{empty};
                  *** 'moveNewToFront[[empty]] ; 
                  (('COMP-NEW-newNF-inside-new[none]{empty})! ) ;
                  aStrat  
                   } 
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I3)) (2 + i) .  
 ***sym on a known protocol 
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'sym`from_`(_`)[I1, I2] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[empty ]]} 
    :   
     matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using 'SYM[ 'Delta1:ChannelContext <- 'Delta:ChannelContext ; 
                 'O1:Set`{CNameBound`} <- 'Outs:Set`{CNameBound`} ; 
                 'P1:Protocol <- upTerm(new2NF(computeNF(read-protocol(IPDL, env, I1))))]
                 {'sugar-newNF[none]{empty};
                  'allNewToFront[[empty]] ;
                  *** was ( ('COMP-NEW-newNF-inside-new[none]{empty})! ) ;
                  aStrat  
                   } 
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i) . )
 *** channel
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'case`distinction`on_`(_`) [I1, I2] : 'StrictProof}  =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    : 'CASE-DISTINCTION-channel[
          *** none
         'cn:ChannelName <- upTerm(cn)
         ]
       { sl1 }
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )  
  /\ pConfig(Sigma, Delta, P, Ins, Outs, A) := getPConfig env
  /\  (channel cn) := read-ruleTarget(IPDL, I1)
  /\ i := getMaxUsedNumber m
  /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  /\ slNatPair sl1 z := 
      proofCaseList2StrategyList 
        'CASE-DISTINCTION-channel 
        (chn cn)
        (read-proofCaseList(IPDL, env, I2))
        (i + 2)  .      
 *** family
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'case`distinction`on_`(_`) [I1, I2] : 'StrictProof}  =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    : 'CASE-DISTINCTION-one-R[
          *** none
          'fns:NameWithScripts <- upTerm(ns)
        ; 'blist:List`{Bounds`} <- upTerm(blist)
         ]
       { sl1 }
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )  
  /\ pConfig(Sigma, Delta, P, Ins, Outs, A) := getPConfig env
  /\  (family (ns[blist])) := read-ruleTarget(IPDL, I1)
  /\ i := getMaxUsedNumber m
  /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  /\ slNatPair sl1 z := 
      proofCaseList2StrategyList 
        'CASE-DISTINCTION-one-R 
        (fam (ns[blist]))
        (read-proofCaseList(IPDL, env, I2))
        (i + 2)  .
 *** group
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'case`distinction`on_`(_`) [I1, I2] : 'StrictProof}  =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    : 'CASE-DISTINCTION-one[
          *** none
         'fns:NameWithScripts <- upTerm(ns)
        ; 'blist:List`{Bounds`} <- upTerm(blist)
         ]
       { sl1 }
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )  
  /\ pConfig(Sigma, Delta, P, Ins, Outs, A) := getPConfig env
  /\  (group (ns[blist])) := read-ruleTarget(IPDL, I1)
  /\ i := getMaxUsedNumber m
  /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  /\ slNatPair sl1 z := 
      proofCaseList2StrategyList 
        'CASE-DISTINCTION-one 
        (fam (ns[blist]))
        (read-proofCaseList(IPDL, env, I2))
        (i + 2)  .
***  ceq addGenDecl env (smod H is
***     IL
***     sorts SS .
***     SSDS OPDS MAS EQS RLS SDCLS SDEFS
***      endsm
***   ) I =
***      (smod H is
***     IL
***     sorts SS .
***     SSDS OPDS MAS EQS RLS 
***     (SDCLS 
***        strat q : nil @ 'ProtocolConfig [none] .

***     )
***     (SDEFS
***        sd q[[ empty ]] := idle [none] .
***     )
***      endsm
***   )
***  if m := (smod H is
***     IL
***     sorts SS .
***     SSDS OPDS MAS EQS RLS SDCLS SDEFS
***      endsm
***   )
***  /\ q := qid('gn_ qid(1 + getMaxUsedNumber m) ) [owise] .
 *** for plain rules that don't generate strategies, leave unchanged
 *** for generalize approx
   ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'in`the`presence`of_rewrite_to_by`generalization`of_ [I1, I2, I3, I4] : 'ApproxProof}
  =
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS 
    RLS
    (SDCLS
    strat q : nil @ 'ApproxEqConfig [none] .
        ) 
    (SDEFS
    sd q[[ empty ]] := 
      match 'aConf:ApproxEqConfig 
       s.t. ('aConfStartsWithNew_['aConf:ApproxEqConfig] = 'true.Bool) 
       ? 'CONG-NEW-NF-EQ-APPROX[none]{q[[ empty ]]} 
       : matchrew 'aConf:ApproxEqConfig 
         s.t. 'aConfig['pConfig['Sigma:Signature,'Delta:ChannelContext,'P:Protocol,
    'Ins:Set`{CNameBound`},'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}],
    'countb:ComplexityBound, 'contextb:ComplexityBound] := 'aConf:ApproxEqConfig by
    'aConf:ApproxEqConfig
    using 
    ('CONG-COMP-EQ-APPROX[
       'P1:Protocol <- 'keepAll__['P:Protocol, upTerm(cnbl ( fam (cn[blist]) ))] ;
       'Q:Protocol <- 'removeAll__['P:Protocol, upTerm(cnbl ( fam (cn[blist]) )) ]]
    {
      'GEN-APPROX[none]{ q1 [[ empty ]]}
    }  
     ) [none]
     .
    )
     endsm
  ) 
  if
  m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )  
  /\ i := getMaxUsedNumber m
  /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  /\ cnbl := read-cNameBoundList(IPDL, env, I1)
  /\ cases := computeNF(read-cases(IPDL, env, I3))
  /\ ( family (cn[blist]) ) := read-ruleTarget(IPDL, I2)
  /\ q1 := read-qid(I4)
  .
 *** symSubstDiverge

 var ns1 ns2 : ChannelName .

***  *** symSubstDiverge
***   ceq addGenDecl env (smod H is
***     IL
***     sorts SS .
***     SSDS OPDS MAS EQS RLS SDCLS SDEFS
***      endsm
***   ) {'sym`var_terms_diverge_into_var_ [I, I1, I2, I3, I4] : 'StrictProof} =
***      (smod H is
***     IL
***     sorts SS .
***     SSDS OPDS MAS EQS RLS 
***     (SDCLS 
***        strat q : nil @ 'ProtocolConfig [none] .

***     )
***     (SDEFS
***        sd q[[ empty ]] := 
***        (matchrew 'pConf:ProtocolConfig s.t. 
***      'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
***                'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
***      := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
***      using 'SYM[ 'Delta1:ChannelContext <- 'Delta:ChannelContext ; 
***                  'O1:Set`{CNameBound`} <- 'Outs:Set`{CNameBound`} ; 
***                  'P1:Protocol <- 
***                  'change_with_in_[
***                  upTerm(fam (ns1[blist1])),
***                  upTerm(nf(q1 : bool <- read (ns2[tlist]), return ())),
***                  'P:Protocol
***                  ]
***                 ]
***                  { 
***            'applySubstDivergeFamily[[
***            upTerm(fam (ns2[blist2])), 
***            upTerm(fam (ns1[blist1])), 
***            upTerm(q2) ]]       
***                    } 
***     ) 
***        [none] .
***     )
***      endsm
***   )
***  if m := (smod H is
***     IL
***     sorts SS .
***     SSDS OPDS MAS EQS RLS SDCLS SDEFS
***      endsm
***   )
***  /\ q1 := read-qid(I)
***  /\ tlist := read-natTerms(IPDL, I1) 
***  /\ (fam (ns1[blist1])) := read-cNameBound(IPDL, I2)
***  /\ (fam (ns2[blist2])) := read-cNameBound(IPDL, I3)
***  /\ q2 := read-qid(I4)
***  /\ i :=  getMaxUsedNumber m
***  /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi 
***  . 

 *** use-family-p
  ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'using_`(_`) [I1, I2] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] := 
       'use-family-p[
           'fns1:NameWithScripts <- upTerm(ns) ;
           'blist1:List`{Bounds`} <- upTerm(blist)
           ]
           { 
            aStrat
           } [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\  (group (ns[blist])) := read-ruleTarget(IPDL, I1) 
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i) . 
 *** select-case-family-p
  ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'using`branch_of_`(_`) [I, I1, I2] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] := 
       'select-case-family-p[
             'fns1:NameWithScripts <- upTerm(ns) ;
             'blist1:List`{Bounds`} <- upTerm(blist) ;
             'bt:BoolTerm <- upTerm(bt)
           ]{
            aStrat
           } [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ (when bt) := read-whenCond(IPDL, I)
 /\  (group (ns[blist])) := read-ruleTarget(IPDL, I1) 
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i) .
 *** select-case-family-r
  ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'using`branch_of_`(_`) [I, I1, I2] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] := 
       'select-case-family-r[
             'fns1:NameWithScripts <- upTerm(ns) ;
             'blist1:List`{Bounds`} <- upTerm(blist) ;
             'bt:BoolTerm <- upTerm(bt)
           ]{
            aStrat
           } [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ (when bt) := read-whenCond(IPDL, I)
 /\  (family (ns[blist])) := read-ruleTarget(IPDL, I1) 
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i) .
  *** select-case-channel-r
  ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'using`branch_of_`(_`) [I, I1, I2] : 'StrictProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] := 
       'select-case-channel-r[
             'cn:ChannelName <- upTerm(cn) ;
             'bt:BoolTerm <- upTerm(bt)
           ]{
            aStrat
           } [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ (when bt) := read-whenCond(IPDL, I)
 /\  (channel cn) := read-ruleTarget(IPDL, I1) 
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i) .
 eq addGenDecl env m  I = m [owise] .
 
 *** helper, protocol2Term
 *** helper: generate a term from a protocol
 ***         but use 'P:Protocol and terms if currentProtocol is used
 
 op protocol2Term : Env ATerm -> Term .
 ceq protocol2Term(env, I)
   = upTerm(new2NF(computeNF(read-protocol(IPDL, env, I))))
  if not usesCrtProt(I) .
 ceq protocol2Term(env, {'savedProtocol.IPDLProtocol : 'IPDLProtocol})  
   = upTerm(P) 
 if aConfig(pConfig(Sigma, Delta, P:Protocol, Ins, Outs, A), 
            countb, contextb) := getCrtConf env .  
  eq protocol2Term(env, {'currentProtocol.IPDLProtocol : 'IPDLProtocol})  
   = 'P:Protocol .
 ceq protocol2Term(env, {'`(_`) [I] : 'IPDLProtocol} )  
   = protocol2Term(env, I ) 
   if usesCrtProt(I) .  
 ceq protocol2Term(env, {'change_with_in_ [ I1, I2, I3 ] : 'IPDLProtocol})   
   = 'change_with_in_[ 
                      upTerm( read-cNameBound(IPDL, I1) ), 
                      upTerm(computeNF(read-cases(IPDL, env, I2))) ,
                      protocol2Term(env, I3 ) 
                   ]  
  if usesCrtProt(I3) . 
 ceq protocol2Term(env, 
      {'gather_from_hiding_ [ I1, I2, I3 ] : 'IPDLProtocol } )   
   = 'gather_from_hiding_[ 
                      upTerm( read-cNameBoundList(IPDL, env, I1) ), 
                      protocol2Term(env, I2 ),
                      upTerm( read-cNameBoundList(IPDL, env, I3) )
                   ]  
  if usesCrtProt(I2) .  

 var phi : IPDLEmbedding .

 ceq protocol2Term(env, 
      {'embed`(_`,_`) [ I1, I2 ] : 'IPDLProtocol } )   
   = 'embed`(_`,_`)[    
                      protocol2Term(env, I1 ),
                      upTerm( phi ) *** TODO: this is wrong, I need phi here!!!!
                   ]  
  if usesCrtProt(I1) 
  /\ phi := (getEmbMap env)[read-qid(I2)] . 
 ceq protocol2Term(env, 
      {'extend_with`internal`channel_typed:_assigned:_ [ I, I1, I2, I3 ] : 'IPDLProtocol } )   
   = 'addInternalChannel_typed_assigned_in_[ 
                      upTerm( read-cNameIndex(IPDL, I1) ), 
                      upTerm( preToType(read-type(IPDL, I2)) ),
                      upTerm(computeNF(read-cases(IPDL, env, I3))) ,
                      protocol2Term(env, I ) 
                   ]  
  if usesCrtProt(I) .
  ceq protocol2Term(env, 
      {'extend_with`internal`family_indices:_bounds:_typed:_assigned:_ 
       [ I, I1, I2, I3, IT, I4 ] : 'IPDLProtocol })   
   = 'addInternalFamily_typed_params__assigned_in_[ 
                      upTerm( read-qid(I1) ), 
                      upTerm( preToType(read-type(IPDL, IT)) ),
                      upTerm( read-natTerms(IPDL, I2)),
                      upTerm( read-bounds(IPDL, I3)),
                      upTerm(computeNF(read-cases(IPDL, env, I4))) ,
                      protocol2Term(env, I ) 
                   ]  
  if usesCrtProt(I) 
  .
  ceq protocol2Term(env, 
    {'branch_of_change_with_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol} ) 
   = 'branch_of_change_with_in_[
      upTerm(read-whenCond(IPDL, I)),
      upTerm(read-cNameBound(IPDL, I1)),
      upTerm(read-cNameBound(IPDL, I2)),
      upTerm(computeNF(read-cases(IPDL, env, I3))),
      protocol2Term(env, I4)
   ]
  if usesCrtProt(I4) .      
  ceq protocol2Term(env, {'create`group_indices:_bounds:_from_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol})
   = 'group_named_params__in_[
       upTerm(cnbl),
       upTerm(q),
       upTerm(nlist),
       upTerm(blist),
       protocol2Term(env, I4)
   ]
  if usesCrtProt(I4) 
  /\ q := read-qid(I)
  /\ nlist := read-natTerms(IPDL, I1)
  /\ blist := read-bounds(IPDL, I2)
  /\ cnbl := read-cNameBoundList(IPDL, env, I3)
  .
   

 *** partial function
 op getWhenList : Protocol -> WhenList .
 eq getWhenList (cn ::= wList) = wList .
 eq getWhenList (family q[blist] ntlist blist ::= wList) = wList .

  op getMaxUsedNumber_ : Module -> Int .
  eq getMaxUsedNumber m = 
     maxSet (declsToInts getStrats(m)) .
  
  var AType : Type .
  var ATypeList : TypeList .
  var ASet : AttrSet .

  var s : String .

  op qidToCounter_ : Qid -> Int .
  ceq qidToCounter q = 
   if substr(s, 0, 3) == "gn_" 
    then  rat(substr(s, 3, length(s)), 10) 
    else -1
   fi 
   if s := string(q) .

   op declsToInts_ : StratDeclSet -> Set{Int} .
   eq declsToInts SDCLS = 
      declsToIntsAux SDCLS empty .

   op declsToIntsAux__ : StratDeclSet Set{Int} -> Set{Int} .  
   eq declsToIntsAux none ISet = ISet .
   eq declsToIntsAux ((strat q : ATypeList @ AType [ ASet ].) SDCLS) ISet
    = declsToIntsAux SDCLS (ISet, qidToCounter q) .

   op maxSet_ : Set{Int} -> Int .
   eq maxSet ISet = maxSetAux(ISet, -1) .
   
   op maxSetAux : Set{Int} Int -> Int .
   eq maxSetAux(empty, i) = i .
   eq maxSetAux((i, ISet), i') = 
     if i < i' then maxSetAux(ISet, i') else maxSetAux(ISet, i) fi .
 
 var cn : ChannelName .
 var ntlist : List{NatTerm} .

 *** helper: check whether currentProtocol is used in a protocol
 *** so far only in operations, not protocol constructors
 op usesCrtProt : ATerm -> Bool .
 eq usesCrtProt({'currentProtocol.IPDLProtocol : 'IPDLProtocol}) = true .
 eq usesCrtProt({'extend_with`internal`channel_typed:_assigned:_ [ I, I1, I2, I3 ] : 'IPDLProtocol })
  = usesCrtProt(I) .
 eq usesCrtProt({'extend_with`internal`family_indices:_bounds:_typed:_assigned:_ [ I, I1, I2, I3, IT, I4 ] : 'IPDLProtocol })
  = usesCrtProt(I) . 
 eq usesCrtProt({'create`group_indices:_bounds:_from_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol})
  = usesCrtProt(I4) . 
 eq usesCrtProt({'change_with_in_ [ I1, I2, I3 ] : 'IPDLProtocol})   
  = usesCrtProt(I3) .
 eq usesCrtProt({'gather_from_hiding_ [ I1, I2, I3 ] : 'IPDLProtocol})   
  = usesCrtProt(I2) . 
 eq usesCrtProt({'embed`(_`,_`)[ I1, I2 ] : 'IPDLProtocol})   
  = usesCrtProt(I1) . 
 eq usesCrtProt({'branch_of_change_with_in_[I, I1, I2, I3, I4 ] : 'IPDLProtocol})   
  = usesCrtProt(I4) .
 
 eq usesCrtProt( {'`(_`) [I] : 'IPDLProtocol} )  
  = usesCrtProt(I) .
 eq usesCrtProt(I) = false [owise] .

  *** helper addStratDecls
  *** helpers for generated strategies and generated envs

  var typeList : TypeList .
  var type : Type .
  var attrset : AttrSet .
  var SDS : StratDeclSet .
  var aMod : Module .
 
   op getAllStratNames_ : Module -> QidSet .
   eq getAllStratNames aMod 
    = getAllStratNamesAux (getStrats(aMod)) .
      
   op getAllStratNamesAux_ : StratDeclSet -> QidSet .
   eq getAllStratNamesAux none 
    = none .
   eq getAllStratNamesAux 
       ( (strat q : typeList @ type [attrset] .) SDS ) 
   = (q ; (getAllStratNamesAux SDS)) .

 
  op generatedStrategyCall_ : Env -> Strategy .
  ceq generatedStrategyCall env =
     q [[ empty ]]
  if q := qid('gn_ qid(1 + getMaxUsedNumber (getModule env)) )  .

 var atl : ATermList .  
 
 op addStratDecls__ : Env ATermList -> Env .
 eq addStratDecls env empty = env  [label asdEnd] .
 eq addStratDecls env ({'subst`branch_of_into_[I, I1, I2] : 'StrictProof}, atl) = 
    addStratDecls
     (setModule env (addGenDecl env (getModule env) {'subst`branch_of_into_[I, I1, I2] : 'StrictProof}))
     atl  [label asdSym] .
 eq addStratDecls env ({'subst`branch_of_into_at_[I, I1, I2, I3] : 'StrictProof}, atl) = 
    addStratDecls
     (setModule env 
       (addGenDecl env (getModule env) {'subst`branch_of_into_at_[I, I1, I2, I3] : 'StrictProof}))
     atl  [label asdSym] .    
 eq addStratDecls env ({'sym`from_`(_`)[I1, I2] : 'StrictProof}, atl) = 
    addStratDecls
     (setModule env (addGenDecl env (getModule env) {'sym`from_`(_`)[I1, I2] : 'StrictProof}))
     (I2, atl)  [label asdSym] .
 eq addStratDecls env ({'focus_`(_`)[I1, I2] : 'StrictProof}, atl) = 
    addStratDecls
     (setModule env (addGenDecl env (getModule env) {'focus_`(_`)[I1, I2] : 'StrictProof}))
     (I2, atl)  [label asdFocus] .       
 eq addStratDecls env ({'restructure_[I1] : 'StrictProof}, atl) = 
    addStratDecls
     (setModule env (addGenDecl env (getModule env) {'restructure_[I1] : 'StrictProof}))
     atl  [label asdRestructure] .    
 eq addStratDecls env ({'sym`from_over_`(_`)[I, I1, I2] : 'StrictProof}, atl) = 
    addStratDecls
     (setModule env (addGenDecl env (getModule env) {'sym`from_over_`(_`)[I, I1, I2] : 'StrictProof}))
     (I2, atl)  .         
 eq addStratDecls env ({'on`reaction`of_`(_`) [I1, I2] : 'StrictProof}, atl) 
  = addStratDecls
     (setModule env (addGenDecl env (getModule env) {'on`reaction`of_`(_`) [I1, I2] : 'StrictProof}))
     atl .   
 eq addStratDecls env ({'on`branch_of_`(_`) [I, I1, I2] : 'StrictProof }, atl) = 
    addStratDecls
     (setModule env (addGenDecl env (getModule env) {'on`branch_of_`(_`) [I, I1, I2] : 'StrictProof }))
     (I2, atl)   [label asdOnB] .
 eq addStratDecls  env ({'group_in_indices:_bounds:_[I, I1, I2, I3] : 'StrictProof}, atl) 
= addStratDecls 
   (setModule env (addGenDecl env (getModule env) {'group_in_indices:_bounds:_[I, I1, I2, I3] : 'StrictProof}))
   atl .        
 eq addStratDecls env ({'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5 ] : 'StrictProof}, atl) = 
    addStratDecls
     (setModule env 
      (addGenDecl env (getModule env) 
       {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5 ] : 'StrictProof}
      )
     )
     (I5, atl)  .    
 eq addStratDecls env ({'rewrite_to_by`induction`on_bound_`(_`) 
                [I1, I2, I3, I4, I5 ] : 'StrictProof}, atl) = 
    addStratDecls
     (setModule env 
      (addGenDecl env (getModule env) 
       {'rewrite_to_by`induction`on_bound_`(_`) 
                [I1, I2, I3, I4, I5 ] : 'StrictProof}
      )
     )
     (I5, atl)  .        
 eq addStratDecls env ({'case`distinction`on_`(_`) [I1, I2] : 'StrictProof}, atl) = 
    addStratDecls
     (setModule env (addGenDecl env (getModule env) {'case`distinction`on_`(_`) [I1, I2] : 'StrictProof}))
     (I2, atl)  [label asdCD] .    
 eq addStratDecls env ({'_then_[I1, I2] : 'StrictProof}, atl) = 
    addStratDecls (addStratDecls env (I1, I2)) atl . 
 eq addStratDecls env ({'case:`(_`) [I] : 'ProofCase}, atl )
  = addStratDecls env (I, atl) .
 eq addStratDecls env ({'__ [I1, I2] : 'ProofCaseList}, atl) =
    addStratDecls 
     (addStratDecls env I1)
     (I2, atl) .
 eq addStratDecls env 
  ({'in`the`presence`of_rewrite_to_by`generalization`of_ [I1, I2, I3, I4] : 'ApproxProof}, atl) = 
  addStratDecls
  (setModule env (addGenDecl env (getModule env) 
    {'in`the`presence`of_rewrite_to_by`generalization`of_ [I1, I2, I3, I4] : 'ApproxProof})
   ) atl .   
 eq addStratDecls env ({'using_`(_`) [I1, I2] : 'StrictProof}, atl) = 
    addStratDecls
     (setModule env (addGenDecl env (getModule env) {'using_`(_`) [I1, I2] : 'StrictProof}))
     (I2, atl)  .
 eq addStratDecls env ({'using`branch_of_`(_`) [I, I1, I2] : 'StrictProof}, atl) = 
    addStratDecls
     (setModule env 
      (addGenDecl env (getModule env) {'using`branch_of_`(_`) [I, I1, I2] : 'StrictProof}))
     (I2, atl)  .           
 eq addStratDecls env (I, atl) = addStratDecls env atl [owise] .  

 
  *** helper, proof2Strategy
  op proof2Strategy__ : Proof{IPDL} Nat -> SNatPair .
   eq proof2Strategy (Proof[IPDL]{on reaction of cnb (rp1)} ) x
    = sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1) .
   eq proof2Strategy(Proof[IPDL]{group cnbl in q indices: nlist bounds: blist}) x
    = sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1) . 
   eq proof2Strategy (Proof[IPDL]{sym from P (aProof)}) x 
    =  sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1 + countGenSubproofs(aProof))
   .
   eq proof2Strategy (Proof[IPDL]{subst branch whenCond of cnb1 into cnb2}) x 
    =  sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1)
   . 
   eq proof2Strategy (Proof[IPDL]{subst branch whenCond of cnb1 into cnb2 at q}) x 
    =  sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1)
   .
   eq proof2Strategy (Proof[IPDL]{focus cnbl (aProof)}) x 
    =  sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1 + countGenSubproofs(aProof))
   . 
   eq proof2Strategy (Proof[IPDL]{restructure P}) x 
    =  sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1)
   . 
   eq proof2Strategy (Proof[IPDL]{on branch bt of rt (aProof)}) x 
    =  sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1 + countGenSubproofs(aProof))
   . 
   eq proof2Strategy (Proof[IPDL]{case distinction on rt (pcl1)}) x
    = sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1 + countGenSubproofs(pcl1)) 
   .  
   eq proof2Strategy (Proof[IPDL]
      {in the presence of cnbl rewrite rt to cases by induction on nt1 bound nt2 (aProof)} ) x
    = sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1 + countGenSubproofs(aProof)) 
   .  
   eq proof2Strategy (Proof[IPDL]
      {rewrite rt to cases by induction on nt1 bound nt2 (aProof)} ) x
    = sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1 + countGenSubproofs(aProof)) 
   .  
   eq proof2Strategy
      (Proof[IPDL]{using rt ( aProof )}) x
    = sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1 + countGenSubproofs(aProof)) 
   .
   eq proof2Strategy
      (Proof[IPDL]{using branch whenCond of rt ( aProof )}) x
    = sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1 + countGenSubproofs(aProof)) 
   .  
   ceq proof2Strategy(Proof[IPDL]{pr1 then pr2}) x
    = sNatPair (aStrat ; aStrat') z
   if (sNatPair aStrat y) := proof2Strategy pr1 x 
   /\ (sNatPair aStrat' z) := proof2Strategy pr2 y .
   eq proof2Strategy aProof x = 
      sNatPair (proofStep2Strategy(aProof)) x
   [owise] .  

   

   op proofStep2Strategy : Proof{IPDL} -> Strategy .
   eq proofStep2Strategy(Proof[IPDL]{move family fn1 on each branch of group fn2})
    = 'metaMoveFamToGroup[[ upTerm(fam fn1), upTerm(fam fn2) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{move channel cn on each branch of group fn2})
    = 'applyAddChnToGroupSameCases[[ upTerm(fam fn2), upTerm(cn) ]] .     
   eq proofStep2Strategy(Proof[IPDL]{save current configuration}) = idle .
   eq proofStep2Strategy(Proof[IPDL]{split cnb inside group fn1})
    = 'applySplitInsideGroup[[upTerm(fam fn1), upTerm(cnb)]] .
   eq proofStep2Strategy(Proof[IPDL]{unsplit cnb1 and cnb2})
    = 'metaUnsplit2[[upTerm(cnb1), upTerm(cnb2)]] .
   eq proofStep2Strategy(Proof[IPDL]{unsplit cnb1 and cnb2 inside group fn1})
    = 'applyUnsplitGroup[[upTerm(fam fn1), upTerm(cnb1), upTerm(cnb2)]] .
   eq proofStep2Strategy(Proof[IPDL]{unit-ext on cnb at x})
    = 'applyUnitExt[[upTerm(cnb), upTerm(x)]] .
   eq proofStep2Strategy(Proof[IPDL]{rename indices to tlist in cnb})
    = 'metaRenameIndices[[ upTerm(cnb), upTerm(natTermsToQid(tlist)) ]] .
   eq proofStep2Strategy(Proof[IPDL]{remove cnb from group fn1})
    = 'applyRemoveFromGroupCases[[ upTerm(fam fn1), upTerm(cnb) ]] .
   eq proofStep2Strategy(Proof[IPDL]{use assumption q1 on cnbl})
    = qid('apply q1) [[upTerm(cnbl) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{change name cnb to q1})
    = 'applyRenameGroup[[ upTerm(cnb), upTerm(q1) ]] .  
   eq proofStep2Strategy(Proof[IPDL]{use expression assumption q1 on cnbl at n})
    = qid('apply q1) [[upTerm(cnbl), upTerm(n) ]] .   
   eq proofStep2Strategy(Proof[IPDL]{absorb cnb1}) 
    = 'absorb[[ upTerm(cnb1) ]] .
   eq proofStep2Strategy(Proof[IPDL]{group-absorb group fn1}) 
    = 'absorbGroup[[ upTerm(fam fn1) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{compose cnb1 with cnb2 in group})
    = ('applyGroupFamiliesNew[[upTerm(cnb1), upTerm(cnb2)]]) .
   eq proofStep2Strategy(Proof[IPDL]{decompose cnb1 with cnb2})
    = ('applyUngroupFamiliesNew[[upTerm(cnb1), upTerm(cnb2)]]) . 
   eq proofStep2Strategy(Proof[IPDL]{restructure P}) 
    = idle . *** TODO: for now!  
   eq proofStep2Strategy(Proof[IPDL]{bring declarations of hidden channels in front}) 
    = 'allNewToFront[[empty]] .
   eq proofStep2Strategy(Proof[IPDL]{unsplit cn}) 
    = 'topUnsplit[[ upTerm(cn) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{split cnb1 on first index}) 
    = 'topSplitFstIndex[[ upTerm(cnb1) ]] .
   eq proofStep2Strategy(Proof[IPDL]{split cnb1 on first index inside group fn1}) 
    = 'applySplitInsideGroup[[upTerm(fam fn1), upTerm(cnb1)]] .      
    *** wrong call: 'applySplitFstBranches[[upTerm(fam fn1), upTerm(cnb1)]] .  
   eq proofStep2Strategy(Proof[IPDL]{split cnb1 on second index}) 
    = 'topSplitSndIndex[[ upTerm(cnb1) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{turn neg into otherwise for cnb1}) 
    = 'applyNegToOtherwise[[ upTerm(cnb1) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{turn otherwise into neg for cnb1}) 
    = 'applyOtherwiseToNeg[[ upTerm(cnb1) ]] .  
   eq proofStep2Strategy(Proof[IPDL]{combine cnb1}) 
    = 'applyNewCombine[[ upTerm(cnb1) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{combine cnb1 into families}) 
    = 'applyNewCombineFam[[ upTerm(cnb1) ]] .  
   eq proofStep2Strategy(Proof[IPDL]{call q})
    = q[[empty]] . 
   eq proofStep2Strategy(Proof[IPDL]{use lemma q run})
    = q[[empty]] . 
   eq proofStep2Strategy(Proof[IPDL]{use lemma q trust})
    = qid(q '-trust)[[empty]] .   
   eq proofStep2Strategy(Proof[IPDL]{ungroup cnb}) 
    = 'applyDropName[[upTerm(cnb)]] .
   eq proofStep2Strategy(Proof[IPDL]{merge cases for cnb1}) 
    = 'mergeCases[[ upTerm(cnb1) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{merge case q = nt with otherwise for cnb})  
    = 'mergeCaseWithOtherwise[[upTerm(cnb), upTerm(nt) ]] .
   eq proofStep2Strategy(Proof[IPDL]{extract cnbl from group fn1 into group q})
    = 'applyExtractSubgroup[[ upTerm(fam fn1), upTerm(cnbl), upTerm(q) ]] .  
   eq proofStep2Strategy(Proof[IPDL]{discard branch (qidAsTerm q =T= nt) of cnb})
    = 'metaDropBranch[[ upTerm(cnb), upTerm(q), upTerm(nt) ]] .
   eq proofStep2Strategy(Proof[IPDL]{fix index for cnb}) 
    = 'applyFixIndex[[upTerm(cnb)]] .    
   eq proofStep2Strategy(Proof[IPDL]{rename qpl in cnb} )
    = 'applyAlphaNFPr[[upTerm(cnb), upTerm(qpl emptyQidPairList)  ]] .
    eq proofStep2Strategy(Proof[IPDL]{rename variables qpl of cnb} )
    = 'applyAlphaFamilyThree[[upTerm(cnb), upTerm(qpl emptyQidPairList)  ]] . 
   eq proofStep2Strategy(Proof[IPDL]{fold cnb1 into cnb2}) 
    = 'fold[[ upTerm(cnb1), upTerm(cnb2) ]] .
   eq proofStep2Strategy(Proof[IPDL]{drop read cnb1 from cnb2}) 
    = 'dropSubsume[[ upTerm(cnb1), upTerm(cnb2) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{drop read branch (when bt) of cnb1 from cnb2}) 
    = 'metaDropSubsumeCase[[ upTerm(cnb1), upTerm(cnb2), upTerm(bt) ]] .  
   eq proofStep2Strategy(Proof[IPDL]{subst cnb1 into cnb2}) 
    = 'subst[[ upTerm(cnb1), upTerm(cnb2) ]] .
   eq proofStep2Strategy(Proof[IPDL]{subst cnb1 into cnb2 at q}) 
    = 'substAt[[ upTerm(cnb1), upTerm(cnb2), upTerm(q) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{idle}) = idle .
   eq proofStep2Strategy(Proof[IPDL]{diverge on cnb1 with cnb2 var q})   
    =  'applySubstDivergeFamily[[
           upTerm(cnb1), upTerm(cnb2), upTerm(q) ]] .
   eq proofStep2Strategy(Proof[IPDL]{diverge on cnb1 with branch bt of cnb2 var q})           
    = ('metaCaseDiverge[[
           upTerm(cnb2),
           upTerm(cnb1),
           upTerm(bt), 
           upTerm(q) ]]) .    
   eq proofStep2Strategy(Proof[IPDL]{reverse subst cnb1 in cnb2 using cnb3 })
    = 'substNFReadRevFamilies[[
            upTerm(cnb3), 
            upTerm(cnb2), 
            upTerm(cnb1)
         ]] .   
   eq proofStep2Strategy(Proof[IPDL]{subst or diverge cnb1 into cnb2 var q})
    = ('applySubstOrDiverge[[
          upTerm(cnb1), 
          upTerm(cnb2), 
          upTerm(q)
       ]]) . 
   eq proofStep2Strategy(Proof[IPDL]{remove only branch of cnb}) 
    = 'applyRemoveBranch[[ upTerm(cnb) ]]
   .  
   eq  proofStep2Strategy(Proof[L]{on all branches of cnb1 split cnb2 on first index}) 
    = ('applySplitFstBranches[[ 
         upTerm(cnb1), upTerm(cnb2)
       ]])
   . 
   eq  proofStep2Strategy(Proof[L]{on all branches of cnb1 split cnb2 on second index}) 
    = ('applySplitSndBranches[[ 
         upTerm(cnb1), upTerm(cnb2)
       ]])
   . 
   eq proofStep2Strategy(Proof[L]
       {add internal family q indices: nlist bounds: blist typed: T1 assigned: cases}) 
    = ('addInternalFam[[
        upTerm(q), 
        upTerm(T1),
        upTerm(nlist), 
        upTerm(blist),
        upTerm(computeNF(cases)) ]]
      )
   .   
   eq proofStep2Strategy(Proof[L]
     {add internal channel cn typed: T1 assigned: cases}) 
    = ('applyAddInternalChannel[[
        upTerm(cn), 
        upTerm(T1),
        upTerm(computeNF(cases))   ]]
      ) .
   eq proofStep2Strategy(Proof[L]{use assumptions for q in chn cn}) 
    = 'applyAlphaAssumChn[[upTerm(cn), upTerm(q)]]  .
   eq proofStep2Strategy(Proof[L]{remove and merge cnb from group fn1 })
    = ('applyRemoveMergeFromGroupCases[[ upTerm(fam fn1), upTerm(cnb) ]]) .
   eq proofStep2Strategy(Proof[L]{merge cases for cnb1 and cnb2 into group q} )
    = ('metaMerge[[ upTerm(cnb1),
                           upTerm(cnb2),
                           upTerm(q) ]]) . 
   eq proofStep2Strategy(Proof[L]{sym var q1 terms tlist diverge cnb1 into cnb2 var q2})
    = ('symSubstDiverge[[ 
         upTerm(cnb2),
         upTerm(cnb1),
         upTerm(tlist),
         upTerm(q1),
         upTerm(q2)
       ]]) . 

   var cnbl : List{CNameBound} .
  var cases : Cases .
  var rt : RuleTarget .

  var p1 p2 : Proof{IPDL} .
  var tlist : List{NatTerm} .

  op countGenSubproofs : Proof{IPDL} -> Nat .
  eq countGenSubproofs(Proof[IPDL]{p1 then p2}) = 
     countGenSubproofs(p1) + countGenSubproofs(p2) .
  eq countGenSubproofs(Proof[IPDL]{on branch bt of rt (p1)} ) =
     1 + countGenSubproofs(p1) .   
  eq countGenSubproofs(Proof[IPDL]{sym from P (p1)})  = 
     1 + countGenSubproofs(p1) .  
  eq countGenSubproofs(Proof[IPDL]{focus cnbl (p1)})  = 
     1 + countGenSubproofs(p1) .   
  eq countGenSubproofs(Proof[IPDL]
      {in the presence of cnbl rewrite rt to cases by induction on nt1 bound nt2 (aProof)} ) 
   = 1 +  countGenSubproofs(aProof) .
  eq countGenSubproofs(Proof[IPDL]
      {rewrite rt to cases by induction on nt1 bound nt2 (aProof)} ) 
   = 1 +  countGenSubproofs(aProof) . 
  eq countGenSubproofs((Proof[IPDL]{case distinction on rt (pcl1)})) 
   = 1 + countGenSubproofs(pcl1) .  
  eq countGenSubproofs(Proof[IPDL]{on reaction of cnb (rp1)} )
   = 1 . 
  eq countGenSubproofs(Proof[IPDL]{using rt ( aProof )})
   = 1 + countGenSubproofs(aProof) .
  eq countGenSubproofs(Proof[IPDL]{using branch whenCond of rt ( aProof )})
   = 1 + countGenSubproofs(aProof) .  
  eq countGenSubproofs(Proof[IPDL]{subst branch whenCond of cnb1 into cnb2})
   = 1 .
  eq countGenSubproofs(Proof[IPDL]{subst branch whenCond of cnb1 into cnb2 at q})
   = 1 .   
  eq countGenSubproofs(p1) = 0 [owise] .   

  op countGenSubproofs : ProofCaseList -> Nat .
  eq countGenSubproofs(case p1) = countGenSubproofs(p1) .
  eq countGenSubproofs(pcl1 pcl2) = 
     countGenSubproofs(pcl1) + countGenSubproofs(pcl2) .

  op proofCaseList2StrategyList____ : Qid CNameBound  ProofCaseList Nat -> SLNatPair .
  *** channels  
 ceq proofCaseList2StrategyList
      cdRuleName
      (chn cn) 
      pc1 x = 
      slNatPair
       (qid(cdRuleName '-end ) ['cn:ChannelName <- upTerm(cn)] 
        {try('moveProtocolUnderNewNF[[empty]]) ; aStrat}) y
   if slNatPair aStrat y := proofCase2Strategy pc1 x    
   .
   ceq proofCaseList2StrategyList
      cdRuleName 
      (chn cn) 
      (pc1 pc2) x = 
      slNatPair
       ( try('moveProtocolUnderNewNF[[empty]]) ; aStrat,
         qid(cdRuleName '-end )  ['cn:ChannelName <- upTerm(cn)]  
        {try('moveProtocolUnderNewNF[[empty]]) ; aStrat'}) z
   if slNatPair aStrat  y := proofCase2Strategy pc1 x  
   /\ slNatPair aStrat' z := proofCase2Strategy pc2 y   
   .
   ceq proofCaseList2StrategyList
       cdRuleName
      (chn cn) 
      (pc1 pcl2) x = 
      slNatPair
       ( try('moveProtocolUnderNewNF[[empty]])  ; aStrat,
         cdRuleName  ['cn:ChannelName <- upTerm(cn)]  
        {sl1}) z
   if slNatPair aStrat  y := proofCase2Strategy pc1 x  
   /\ slNatPair sl1 z := 
       proofCaseList2StrategyList cdRuleName (chn cn) pcl2 y   
   [owise] .
   *** families
   ceq proofCaseList2StrategyList
      cdRuleName
      (fam (ns[blist])) 
      pc1 x = 
      slNatPair
       (qid(cdRuleName '-end ) ['fns:NameWithScripts <- upTerm(ns)] 
        {try('moveProtocolUnderNewNF[[empty]]) ; aStrat}) y
   if slNatPair aStrat y := proofCase2Strategy pc1 x    
   .
   ceq proofCaseList2StrategyList
      cdRuleName 
      (fam (ns[blist])) 
      (pc1 pc2) x = 
      slNatPair
       ( try('moveProtocolUnderNewNF[[empty]]) ; aStrat,
         qid(cdRuleName '-end ) ['fns:NameWithScripts <- upTerm(ns)] 
        {try('moveProtocolUnderNewNF[[empty]]) ; aStrat'}) z
   if slNatPair aStrat  y := proofCase2Strategy pc1 x  
   /\ slNatPair aStrat' z := proofCase2Strategy pc2 y   
   .
   ceq proofCaseList2StrategyList
       cdRuleName
      (fam (ns[blist])) 
      (pc1 pcl2) x = 
      slNatPair
       ( try('moveProtocolUnderNewNF[[empty]])  ; aStrat,
         cdRuleName ['fns:NameWithScripts <- upTerm(ns)] 
        {sl1}) z
   if slNatPair aStrat  y := proofCase2Strategy pc1 x  
   /\ slNatPair sl1 z := 
       proofCaseList2StrategyList cdRuleName (fam (ns[blist])) pcl2 y   
   [owise] .

   
   *** ceq proofCaseList2StrategyList cnb wList pcl1 x =
   ***     proofCase2Strategy pcl1 x
   *** if pcl1 : ProofCase .    
   *** ceq proofCaseList2StrategyList cnb wList (pcl1 pcl2) x =
   ***    slNatPair (sl1 , sl2) z
   *** if (slNatPair sl1 y) := proofCaseList2StrategyList cnb wList pcl1 x
   *** /\ (slNatPair sl2 z) := proofCaseList2StrategyList cnb wList pcl2 y .

   op proofCase2Strategy__ : ProofCase Nat -> SLNatPair .
   ceq proofCase2Strategy (case aProof) x =
       slNatPair aStrat y
   if (sNatPair aStrat y) := proof2Strategy aProof x .

   var rp1 rp2 : ReactionProof{IPDL} .

  op reactionProofStep2Strategy : ReactionProof{IPDL} -> Strategy . 
  eq reactionProofStep2Strategy(ReactionProof[IPDL]{ idle }) 
   = idle .
  eq reactionProofStep2Strategy(ReactionProof[IPDL]{ rp1 then rp2}) 
   = reactionProofStep2Strategy(rp1) ; reactionProofStep2Strategy(rp2) .
  eq reactionProofStep2Strategy(ReactionProof[IPDL]{if-ext on q}) 
   = 'if-intro-ext['q:Qid <- upTerm(q)]{empty} . 

  var genReactionStrat : Strategy .
  var Q : Protocol .
  var ltq : TypedCNameList .
  var whenCond : WhenCond .
  var whenList : WhenList .
  var nlist : List{NatTerm} .
  var bt : BoolTerm .
  var nt nt1 nt2 : NatTerm .
   


  *** approx proofs 

   
 vars apc1 apc2 : ApproxCongrProofCase .
 var apcl : ApproxCongrProofCaseList .
 var aCProof : ApproxCongrProof{IPDL} .
 
 op approxProofCaseList2StrategyList__ : Env ApproxCongrProofCaseList -> Strategy .
 ceq approxProofCaseList2StrategyList env apc1 = 
      'APPROX-CASE-DISTINCTION-one-end[none]{aStrat}    
   if aStrat := approxProofCase2Strategy env apc1   
   .
   ceq approxProofCaseList2StrategyList env
      (apc1 apcl) = 
       'APPROX-CASE-DISTINCTION-one[none]{ aStrat,
         aStrat'
       } 
   if aStrat := approxProofCase2Strategy env apc1   
   /\ aStrat' := approxProofCaseList2StrategyList env apcl
   [owise] .
   
   op approxProofCase2Strategy__ : Env ApproxCongrProofCase -> Strategy .
   eq approxProofCase2Strategy env (approxCase aCProof) =
       approxCProof2Strategy env aCProof .
   
   op approxCProof2Strategy__ : Env ApproxCongrProof{IPDL} -> Strategy .
   eq approxCProof2Strategy env (ApproxCongrProof[L]{use approx axiom q})
    = q[none]{empty} .   
   ceq approxCProof2Strategy env
      (ApproxCongrProof[L]{approx embed P along q with inputs Ins ( aCProof )}) 
    =  ('EMBED-APPROX[
        'phi:IPDLEmbedding <- upTerm((getEmbMap env)[q]) ;
        'I:Set`{CNameBound`} <- upTerm(Ins) ;
        'O:Set`{CNameBound`} <- upTerm(getOutputs(P)) ;
        'Delta2:ChannelContext <- upTerm(getEmbedTgt(phi)) ;
        'P1:Protocol <- upTerm(P)
        ]{approxCProof2Strategy env aCProof}
      ) 
   if phi := (getEmbMap env)[q]
   .  

   op approxCongrProof2Strategy__ : Env ATerm -> EnvStratPair .
   eq approxCongrProof2Strategy env {'use`approx`axiom_ [I] : 'ApproxCongrProof} 
    = env envStratPair (read-qid(I)[none]{empty}) .
   ceq approxCongrProof2Strategy env 
      {'approx`embed_along_with`inputs_`(_`) [I1, I2, I3, I4] : 'ApproxCongrProof}
    = env' envStratPair 
      ('EMBED-APPROX[
        'phi:IPDLEmbedding <- upTerm(phi) ;
        'I:Set`{CNameBound`} <- upTerm(read-cNameBoundList(IPDL, env, I3)) ;
        'O:Set`{CNameBound`} <- upTerm(Outs) ;
        'P1:Protocol <- upTerm(P1) ;
        'Delta2:ChannelContext <- upTerm(getEmbedTgt(phi))
        ]{aStrat}
      )  
   if env' envStratPair aStrat := approxCongrProof2Strategy env I4   
   /\ phi := (getEmbMap env)[read-qid(I2)]
   /\ P1 := read-protocol(IPDL, env, I1)
   /\ Outs := getOutputs(P1)
   .
   eq approxCongrProof2Strategy env {'approx`case`distinction`on_`(_`) [I1, I2] : 'ApproxCongrProof}
    = env envStratPair 
      (approxProofCaseList2StrategyList env read-approxProofCases(IPDL, env, I2)) .   


   op approxProof2Strategy__ : Env ATerm -> EnvStratPair .
   ceq approxProof2Strategy env I 
   = (addStratDecls env I) envStratPair ('STRICT[none]{aStrat})
   if I :: 'StrictProof  
   /\ i :=  getMaxUsedNumber (getModule env) 
   /\ sNatPair aStrat x := proof2Strategy (read-proof(IPDL, env, I)) 
        (if i == -1 then 0 else (i + 1) fi )  *** POINTER was i
   .  
   ceq approxProof2Strategy env {'_then-approx_ [I1, I2] : 'ApproxProof}
     = env2 envStratPair 'TRANS[none]{aStrat1, aStrat2} 
   if env1 envStratPair aStrat1 := approxProof2Strategy env I1
   /\ env2 envStratPair aStrat2 := approxProof2Strategy env1 I2  
   .
   ceq approxProof2Strategy env {'sym-approx`from_`(_`) [I1, I2] : 'ApproxProof}
    = (setModule env 
       (addGenDeclWithStrat env aStrat (getModule env')  
                            {'sym-approx`from_`(_`) [I1, I2] : 'ApproxProof}
       )
      )
      envStratPair
      q[[ empty ]]
   if env' envStratPair aStrat := approxProof2Strategy env I2
   /\ i :=  getMaxUsedNumber (getModule env')
   /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi *** TODO: maybe just i?
   .
   ceq approxProof2Strategy env {'use`approx`assumption_on_[I1, I2] : 'ApproxProof}
    = env envStratPair qid('apply q1) [[upTerm(cnbl) ]] 
   if q1 := read-qid(I1)
   /\ cnbl := read-cNameBoundList(IPDL, env, I2) .
  ceq approxProof2Strategy env {'use`approx`assumption_[I1] : 'ApproxProof}
    = env envStratPair qid('apply q1) [[ empty  ]] 
   if q1 := read-qid(I1)
  . 
  ceq approxProof2Strategy env {'call-approx_[I1] : 'ApproxProof} 
   = env envStratPair q [[ empty ]]
  if q := read-qid(I1) .
  ceq approxProof2Strategy env
    {'in`the`presence`of_rewrite_to_by`generalization`of_ [I1, I2, I3, I4] : 'ApproxProof}
    = env' envStratPair q[[ empty ]]
   if env' := addStratDecls env 
    {'in`the`presence`of_rewrite_to_by`generalization`of_ [I1, I2, I3, I4] : 'ApproxProof}
   /\ i :=  getMaxUsedNumber (getModule env')
   /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(i) ) fi
   . 
   ceq approxProof2Strategy env {'approx`generalize`for_`(_`)[I1, I2] : 'ApproxProof}
    = (setModule env 
       (addGenDeclWithStrat env aStrat (getModule env')  
                            {'approx`generalize`for_`(_`)[I1, I2] : 'ApproxProof}
       )
      )
      envStratPair
      q[[ empty ]]
   if env' envStratPair aStrat := approxCongrProof2Strategy env I2 
   /\ i :=  getMaxUsedNumber (getModule env')
   /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
   .
  
  *** sym-approx
  op addGenDeclWithStrat____ : Env Strategy Module ATerm -> Module .
  ceq addGenDeclWithStrat env aStrat (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'sym-approx`from_`(_`)[I1, I2] : 'ApproxProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ApproxEqConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=     
     (matchrew 'aConf:ApproxEqConfig s.t. 
     'aConfig[ 'pConfig['Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}],
               'countb:ComplexityBound, 'contextb:ComplexityBound] 
     := 'aConf:ApproxEqConfig by 'aConf:ApproxEqConfig
     using 'SYM-APPROX[ 'Delta1:ChannelContext <- 'Delta:ChannelContext ; 
                 'O1:Set`{CNameBound`} <- 'Outs:Set`{CNameBound`} ; 
                 'Q:Protocol <- protocol2Term(env, I1)]
                 {
                  'TRANS[none]{
                   'STRICT[none]{  
                  'sugar-newNF[none]{empty};
                  ( ('COMP-NEW-newNF-inside-new[none]{empty})! )} ,
                  aStrat  
                  }
                   } 
     ) ;  ( ('COMP-NEW-newNF-inside-new[none]{empty})! ) 
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  .
  ceq addGenDeclWithStrat env aStrat (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )  
  {'approx`generalize`for_`(_`)[I1, I2] : 'ApproxProof}
 = (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ApproxEqConfig [none] .
    )
     (SDEFS
     sd q[[ empty ]] := 
      match 'aConf:ApproxEqConfig 
      s.t.  ('aConfStartsWithNew_['aConf:ApproxEqConfig] = 'true.Bool) 
      ? 'CONG-NEW-NF-EQ-APPROX[none]{q[[ empty ]]}
      :
      (
      (matchrew 'aConf:ApproxEqConfig 
      s.t. 'aConfig[ 'pConfig['Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}],
               'countb:ComplexityBound, 'contextb:ComplexityBound] 
     := 'aConf:ApproxEqConfig by 'aConf:ApproxEqConfig using
      'CONG-COMP-EQ-APPROX[
         'P1:Protocol <- 'keepOne__['P:Protocol, upTerm(cnb)]
         ]{
      'GEN-APPROX-cases-3[none]{aStrat}
         }
      )
      or-else
      'GEN-APPROX-cases-3[none]{aStrat}
     )
     [none] .
     )
     endsm
  ) 
 if cnb := read-cNameBound(IPDL, I1) 
 /\ m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  .

  *** more helpers
  sort SNatPair .
   op sNatPair__ : Strategy Nat -> SNatPair [ctor]. 

   sort SLNatPair .
   op slNatPair__ : StrategyList Nat -> SLNatPair [ctor] .

   var x y z : Nat .
   var pcl1 pcl2 : ProofCaseList .
   var sl1 sl2 : StrategyList .
   var wList : WhenList .
   var pc1 pc2 : ProofCase .
   var cases1 cases2 : Cases .
   var cdRuleName : Qid .
   var P1 : Protocol .

   var w : Width .
   var l : Length .

  sort EnvStratPair .
  op _envStratPair_ : Env Strategy -> EnvStratPair [ctor] .

  *** helpers, addSubproof, add assumption

  *** add a lemma as strategy decls&defs

  op addLemma___ : Env Module ATerm -> Module .
  eq addLemma env m ({'lemma_=_=>_:_.[I, I1, I2, I3] : 'LemmaDecl}) = 
     addLemmaAux 
      env 
      (getModule (addStratDecls env I3)) 
      ({'lemma_=_=>_:_.[I, I1, I2, I3] : 'LemmaDecl} ) .
  
  var pmap : Map{Qid, Protocol} .

  op addLemmaAux___ : Env Module ATerm -> Module .
  op addLemmaAux___ : Env Module ATerm -> Module .
  ceq addLemmaAux env m ({'lemma_=_=>_:_.[I, I1, I2, I3] : 'LemmaDecl} ) = 
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS 
    (RLS
    rl 'pConfig[
      'Sigma:Signature, 
      'Delta:ChannelContext,
      showAS-protocol(none, P1), *** TODO: is this right here?
      'Ins:Set`{CNameBound`},
      'Out:Set`{CNameBound`},
      'A:Set`{BoolTerm`}]
      => 
      'pConfig[
      'Sigma:Signature, 
      'Delta:ChannelContext,
      showAS-protocol(none, P2),
      'Ins:Set`{CNameBound`},
      'Out:Set`{CNameBound`},
      'A:Set`{BoolTerm`}] 
      [label(qid(q '-rule))] .
    ) 
    (SDCLS
    strat q : nil @ 'ProtocolConfig [none] .
    strat qid(q '-trust) : nil @ 'ProtocolConfig [none] .
    strat qid('apply- q '-rule) : nil @ 'ProtocolConfig [none] .) 
    (SDEFS
    sd q[[ empty ]] := aStrat [none] .
    sd qid(q '-trust)[[ empty ]] :=
       if qid(q '-flag) in (getAllStratNames m)
       then qid('apply- q '-rule)[[ empty ]]
       else q[[ empty ]]
       fi
       [none]
    .   
    sd qid('apply- q '-rule)[[ empty ]] :=
    match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{qid('apply- q '-rule) [[ empty ]]} 
    :  matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`},'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using  ('CONG-COMP-RIGHT[
        'Q:Protocol  <- 'removeAll__['P:Protocol, upTerm(  getOutputs(P1) )] ;
        'P1:Protocol <- 'keepAll__['P:Protocol, upTerm( getOutputs(P1) )]
        ]
  { qid(q '-rule)[none]{empty} }
        )    [none] .
    )
     endsm
  )
  if x := if  (getMaxUsedNumber m) == -1 then 0 else getMaxUsedNumber m fi 
  /\ aProof := read-proof(IPDL, env, I3)
  /\ z := if countGenSubproofs(aProof) == 0 then x else (x + 1 + (- countGenSubproofs(aProof))) fi 
  /\ sNatPair aStrat y := proof2Strategy aProof z 
  /\ q := read-qid(I)
  /\ pmap := getPMap env
  /\ P1 := read-protocol(IPDL, env, I1)
  /\ P2 := read-protocol(IPDL, env, I2)
  /\ (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) := m .

    *** add a subproof as a strategy declaration and definition 
  
  op addSubproof___ : Env Module ATerm -> Module .
  eq addSubproof env m ({'strict`subproof_=_.[I, I1] : 'SubProofDecl}) = 
     addSubproofAux 
      env 
      (getModule (addStratDecls env I1)) 
      ({'strict`subproof_=_.[I, I1] : 'SubProofDecl}) .
  ceq addSubproof env m ({'approx`subproof_=_.[I, I1] : 'SubProofDecl}) = 
   addApproxSubproofAux (getModule env') read-qid(I) aStrat 
  if (env' envStratPair aStrat) := approxProof2Strategy env I1 .

  op addApproxSubproofAux___ : Module Qid Strategy -> Module .
  eq addApproxSubproofAux (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) q aStrat = 
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS
    strat q : nil @ 'ProtocolConfig [none] .) 
    (SDEFS
    sd q[[ empty ]] := 
       aStrat or-else
       'CONG-NEW-NF-EQ-APPROX[none]{
         'CONG-COMP-EQ-APPROX[none]{aStrat}
       }  
     [none] .
    )
     endsm
  )
 .   

  op addSubproofAux___ : Env Module ATerm -> Module .
  ceq addSubproofAux env m ({'strict`subproof_=_.[I, I1] : 'SubProofDecl}) = 
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS
    strat q : nil @ 'ProtocolConfig [none] .) 
    (SDEFS
    sd q[[ empty ]] := aStrat [none] .
    )
     endsm
  )
  if x := if  (getMaxUsedNumber m) == -1 then 0 else getMaxUsedNumber m fi 
  /\ aProof := read-proof(IPDL, env, I1)
  /\ z := if countGenSubproofs(aProof) == 0 then x else (x + 1 + (- countGenSubproofs(aProof))) fi 
  /\ sNatPair aStrat y := proof2Strategy aProof z 
  /\ q := read-qid(I) 
  /\ (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) := m .
  *** assumptions at protocol level
  op add-protocol-assumption  : Module Qid QidSet ChannelContext 
                           Set{CNameBound} Set{BoolTerm} Protocol Protocol -> Module .   
  ceq add-protocol-assumption(
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ), q, QIS, Delta, Ins, A, P1, P2 ) = 
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS 
    (RLS
    rl 'pConfig[
      'Sigma:Signature, 
      showAS-delta(Delta),
      showAS-protocol(QIS, P1),
      showAS-inputs(Ins),
      showAS-outputs(getOutputs(P1)),
      showAS-boolTerms(QIS, A)]
      => 
      'pConfig[
      'Sigma:Signature, 
      showAS-delta(Delta),
      showAS-protocol(QIS, P2),
      showAS-inputs(Ins),
      showAS-outputs(getOutputs(P1)),
      showAS-boolTerms(QIS, A)] 
      [label(q)] .
    ) 
    (SDCLS
    strat (qid('apply q)) : nil @ 'ProtocolConfig [none] .
        ) 
    (SDEFS
    sd (qid('apply q))[[ empty ]] := 
      match 'pConf:ProtocolConfig 
       s.t. ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
       ? 'CONG-NEW-NF[none]{(qid('apply q))[[ empty ]]} 
       : 'CONG-COMP-RIGHT[none]{q[none]{empty}} 
     [none]
     .
    )
     endsm
  ) 
   if assumChannels P1 == nil .
  eq add-protocol-assumption(
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ), q, QIS, Delta, Ins, A, P1, P2 ) = 
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS 
    (RLS
    rl 'pConfig[
      'Sigma:Signature, 
      showAS-delta(Delta),
      showAS-protocol(QIS, P1),
      showAS-inputs(Ins),
      showAS-outputs(getOutputs(P1)),
      showAS-boolTerms(QIS, A)]
      => 
      'pConfig[
      'Sigma:Signature, 
      showAS-delta(Delta),
      showAS-protocol(QIS, P2),
      showAS-inputs(Ins),
      showAS-outputs(getOutputs(P1)),
      showAS-boolTerms(QIS, A)] 
      [label(q)] .
    ) 
    (SDCLS
    strat (qid('apply q)) : 'List`{CNameBound`} @ 'ProtocolConfig [none] .
        ) 
    (SDEFS
    sd (qid('apply q))[[ 'cnbl:List`{CNameBound`} ]] := 
      match 'pConf:ProtocolConfig 
       s.t. ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
       ? 'CONG-NEW-NF[none]{(qid('apply q))[[ 'cnbl:List`{CNameBound`} ]]} 
       : matchrew 'pConf:ProtocolConfig 
       s.t. 'pConfig['Sigma:Signature,'Delta:ChannelContext,'P:Protocol,'Ins:Set`{CNameBound`},
                     'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] := 'pConf:ProtocolConfig 
       by 'pConf:ProtocolConfig using (('CONG-COMP-RIGHT[
          'Q:Protocol <- 'removeAll__['P:Protocol, 'cnbl:List`{CNameBound`}];
          'P1:Protocol <- 'keepAll__['P:Protocol, 'cnbl:List`{CNameBound`}]
       ]{q[none]{empty}}) or-else q[none]{empty} ) 
     [none]
     .
    )
     endsm
  ) 
   [owise] .


  *** add approx assumption to a smod
  op add-approx-assumption : Module Qid QidSet ChannelContext 
                           Set{CNameBound} Set{BoolTerm} Protocol Protocol -> Module .
  ceq add-approx-assumption(
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ), q, QIS, Delta, Ins, A, P1, P2 ) = 
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS 
    (RLS
    rl 'aCongrConfig['pConfig[
      'Sigma:Signature, 
      showAS-delta(Delta),
      showAS-protocol(QIS, new2NF(computeNF(P1))),
      showAS-inputs(Ins),
      showAS-outputs(getOutputs(P1)),
      showAS-boolTerms(QIS, A)],
      'cb:ProtocolBound
      ] 
      => 
      'aCongrConfig['pConfig[
      'Sigma:Signature, 
      showAS-delta(Delta),
      showAS-protocol(QIS, new2NF(computeNF(P2))),
      showAS-inputs(Ins),
      showAS-outputs(getOutputs(P1)),
      showAS-boolTerms(QIS, A)],
      'uncondBound_['_|->_[upTerm(q), '0.Zero]]
      ]
      [label(q)] .
    ) 
    (SDCLS
    strat (qid('apply q)) : nil @ 'ApproxEqConfig [none] .
        ) 
    (SDEFS
    sd (qid('apply q))[[ empty ]] := 
      match 'aConf:ApproxEqConfig 
       s.t. ('aConfStartsWithNew_['aConf:ApproxEqConfig] = 'true.Bool) 
       ? 'CONG-NEW-NF-EQ-APPROX[none]{(qid('apply q))[[ empty ]]} 
       : 'CONG-COMP-EQ-APPROX[none]{ 
           'APPROX-CONG[none]{q[none]{empty} } 
         }
     [none]
     .
    )
     endsm
  ) 
   if assumChannels P1 == nil .
   eq add-approx-assumption(
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ), q, QIS, Delta, Ins, A, P1, P2 ) = 
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS 
    (RLS
    rl 'aCongrConfig['pConfig[
      'Sigma:Signature, 
      showAS-delta(Delta),
      showAS-protocol(QIS, new2NF(computeNF(P1))),
      showAS-inputs(Ins),
      showAS-outputs(getOutputs(P1)),
      showAS-boolTerms(QIS, A)],
      'cb:ProtocolBound
      ] 
      => 
      'aCongrConfig['pConfig[
      'Sigma:Signature, 
      showAS-delta(Delta),
      showAS-protocol(QIS, new2NF(computeNF(P2))),
      showAS-inputs(Ins),
      showAS-outputs(getOutputs(P1)),
      showAS-boolTerms(QIS, A)],
      'uncondBound_['_|->_[upTerm(q), '0.Zero]]
      ] 

      [label(q)] .
    ) 
    (SDCLS
    strat (qid('apply q)) : 'List`{CNameBound`} @ 'ApproxEqConfig [none] .
        ) 
    (SDEFS
    sd (qid('apply q))[[ 'cnbl:List`{CNameBound`} ]] := 
      match 'aConf:ApproxEqConfig 
       s.t. ('aConfStartsWithNew_['aConf:ApproxEqConfig] = 'true.Bool) 
       ? 'CONG-NEW-NF-EQ-APPROX[none]{(qid('apply q))[['cnbl:List`{CNameBound`}]]} 
       : matchrew 'aConf:ApproxEqConfig 
         s.t. 'aConfig['pConfig['Sigma:Signature,'Delta:ChannelContext,'P:Protocol,
    'Ins:Set`{CNameBound`},'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}],
    'countb:ComplexityBound, 'contextb:ComplexityBound] := 'aConf:ApproxEqConfig by
    'aConf:ApproxEqConfig
    using 
    ('CONG-COMP-EQ-APPROX[
       'P1:Protocol <- 'keepAll__['P:Protocol, 'cnbl:List`{CNameBound`}] ;
       'Q:Protocol <- 'removeAll__['P:Protocol, 'cnbl:List`{CNameBound`}]]
    {
     'APPROX-CONG[none]{ q[none]{empty} }
    }  
     ) [none]
     .
    )
     endsm
  ) 
   [owise] .


  *** adds an assumption to a smod

  op add-assumption : Env Module Qid QidSet ChannelContext 
                      TypeContext Set{CNameBound} Reaction Reaction -> Module .
  ceq add-assumption(
   env, 
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ), q, QIS, Delta, Gamma, Ins, R1, R2 ) = 
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS 
    (RLS
    rl 'rConfig[
      'Sigma:Signature, 
      showAS-delta(Delta),
      showAS-gamma(Gamma),
      showAS-reaction(QIS, R1),
      showAS-inputs(Ins),
      'A:Set`{BoolTerm`},
      upTerm(typeOf(Sigma, Delta, Gamma, Ins, A, R1))] 
      => 
      'rConfig[
      'Sigma:Signature, 
      showAS-delta(Delta),
      showAS-gamma(Gamma),
      showAS-reaction(QIS, R2),
      showAS-inputs(Ins), 
      'A:Set`{BoolTerm`},
      upTerm(typeOf(Sigma, Delta, Gamma, Ins, A, R2))] 
      [label(q)] .
    ) 
    (SDCLS
    strat (qid('apply q)) : 'CNameBound @ 'ProtocolConfig [none] .
    strat (qid('apply q 'NF)) : 'CNameBound @ 'ProtocolConfig [none] .
    strat (qid('apply q 'Pre)) : 'CNameBound @ 'ProtocolConfig [none] .
    ) 
    (SDEFS
    sd (qid('apply q))[['cnb:CNameBound]] := (qid('apply q 'NF))[['cnb:CNameBound]] or-else
    (qid('apply q 'Pre))[['cnb:CNameBound]] [none] .
    
    sd (qid('apply q 'NF))[['chn_['cn:ChannelName]]] := match 'pConf:ProtocolConfig s.t. ('startsWithNew_[
    'pConf:ProtocolConfig] = 'true.Bool) ? 'CONG-NEW-NF[none]{(qid('apply q 'NF))[['chn_['cn:ChannelName]]]} :
    matchrew 'pConf:ProtocolConfig s.t. 'pConfig['Sigma:Signature,'Delta:ChannelContext,'P:Protocol,
    'Ins:Set`{CNameBound`},'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] := 'pConf:ProtocolConfig by
    'pConf:ProtocolConfig
    using (('CONG-COMP-RIGHT[
       'P1:Protocol <- 'keepOne__['P:Protocol,'chn_['cn:ChannelName]] ;
       'Q:Protocol <- 'removeOne__['P:Protocol,'chn_['cn:ChannelName]]]
    {
    'CONG-REACT[
       'o:ChannelName <- 'cn:ChannelName]{'cong-nf[none]{q[none]{empty}}}
       } )
       or-else
       'CONG-REACT[
       'o:ChannelName <- 'cn:ChannelName]{'cong-nf[none]{q[none]{empty}}} 
     ) [none]
     .

    sd (qid('apply q 'Pre))[['chn_['cn:ChannelName]]] := match 'pConf:ProtocolConfig s.t. ('startsWithNew_[
    'pConf:ProtocolConfig] = 'true.Bool) ? 'CONG-NEW-NF[none]{(qid('apply q 'Pre))[['chn_['cn:ChannelName]]]} :
    matchrew 'pConf:ProtocolConfig s.t. 'pConfig['Sigma:Signature,'Delta:ChannelContext,'P:Protocol,
    'Ins:Set`{CNameBound`},'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] := 'pConf:ProtocolConfig by
    'pConf:ProtocolConfig using ('CONG-COMP-RIGHT[
       'P1:Protocol <- 'keepOne__['P:Protocol,'chn_['cn:ChannelName]] ;
       'Q:Protocol <- 'removeOne__['P:Protocol,'chn_['cn:ChannelName]]]
    {
    'CONG-REACT[
       'o:ChannelName <- 'cn:ChannelName]{'cong-pre-nf[none]{q[none]{empty}}}
     ; try('pre2Nf[none]{empty})  
       }
       or-else
       'CONG-REACT[
       'o:ChannelName <- 'cn:ChannelName]{'cong-pre-nf[none]{q[none]{empty}}}
       ; try('pre2Nf[none]{empty})
    ) [none]
       .
       sd (qid('apply q 'NF))[[ 'fam_['_`[_`]['cn:ChannelName,'blist:List`{Bounds`}]] ]] := match 'pConf:ProtocolConfig s.t. ('startsWithNew_[
    'pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{(qid('apply q 'NF))[[ 'fam_['_`[_`]['cn:ChannelName,'blist:List`{Bounds`}]] ]]} :
    matchrew 'pConf:ProtocolConfig s.t. 'pConfig['Sigma:Signature,'Delta:ChannelContext,'P:Protocol,
    'Ins:Set`{CNameBound`},'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] := 'pConf:ProtocolConfig by
    'pConf:ProtocolConfig
    using (('CONG-COMP-RIGHT[
       'P1:Protocol <- 'keepOne__['P:Protocol, 'fam_['_`[_`]['cn:ChannelName,'blist:List`{Bounds`}]] ] ;
       'Q:Protocol <- 'removeOne__['P:Protocol, 'fam_['_`[_`]['cn:ChannelName,'blist:List`{Bounds`}]] ]]
    {
    'CONG-REACT-family[
       'fns:NameWithScripts <- 'cn:ChannelName]{'cong-nf[none]{q[none]{empty}}}
       } )
       or-else
        'CONG-REACT-family[
       'fns:NameWithScripts <- 'cn:ChannelName]{'cong-nf[none]{q[none]{empty}}} 
     ) [none]
     .

    sd (qid('apply q 'Pre))[[ 'fam_['_`[_`]['cn:ChannelName,'blist:List`{Bounds`}]] ]] := match 'pConf:ProtocolConfig s.t. ('startsWithNew_[
    'pConf:ProtocolConfig] = 'true.Bool) ? 'CONG-NEW-NF[none]{(qid('apply q 'Pre))[[ 'fam_['_`[_`]['cn:ChannelName,'blist:List`{Bounds`}]] ]]} :
    matchrew 'pConf:ProtocolConfig s.t. 'pConfig['Sigma:Signature,'Delta:ChannelContext,'P:Protocol,
    'Ins:Set`{CNameBound`},'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] := 'pConf:ProtocolConfig by
    'pConf:ProtocolConfig using ('CONG-COMP-RIGHT[
       'P1:Protocol <- 'keepOne__['P:Protocol,'fam_['_`[_`]['cn:ChannelName,'blist:List`{Bounds`}]] ] ;
       'Q:Protocol <- 'removeOne__['P:Protocol,'fam_['_`[_`]['cn:ChannelName,'blist:List`{Bounds`}]] ]]
    {
    'CONG-REACT-family[
       'fns:NameWithScripts <- 'cn:ChannelName]{'cong-pre-nf[none]{q[none]{empty}}}
     ; try('pre2Nf[none]{empty})  
       }
       or-else
       'CONG-REACT-family[
       'fns:NameWithScripts <- 'cn:ChannelName]{'cong-pre-nf[none]{q[none]{empty}}}
       ; try('pre2Nf[none]{empty})
    ) [none]
       .
    )
     endsm
  ) 
   if pConfig(Sigma, Delta', P, Ins', Outs, A) := getPConfig env 
     .

  var E1 E2 : IPDLExpression . 

  op add-assumption-as-eq : Module Qid QidSet TypeContext IPDLExpression IPDLExpression -> Module .
  eq add-assumption-as-eq(
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ), q, QIS, Gamma, E1, E2 ) = 
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS 
    (EQS 
    eq showAS-expressionIPDL(QIS, E1) = showAS-expressionIPDL(QIS, E2)[ label(q) ].
    )
    RLS
    SDCLS
    SDEFS
   
     endsm
      )
      . 
  **********************
  op add-assumption-as-rl : Module Qid QidSet TypeContext IPDLExpression IPDLExpression -> Module .
  eq add-assumption-as-rl(
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ), q, QIS, Gamma, E1, E2 ) = 
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS 
    EQS 
    (RLS
    rl showAS-expressionIPDL(QIS, E1) => showAS-expressionIPDL(QIS, E2)[ label(q) ] .
    )
    (SDCLS
    strat qid('apply q) : 'CNameBound 'Nat @ 'ProtocolConfig [none] .
    strat qid('reaction-apply q ) : 'Nat @ 'ReactionConfig [none] .
    strat qid('bind-apply q ) : 'Nat 'Nat @ 'ReactionConfig [none] .
    strat qid('if-apply q ) : 'Nat 'Nat 'Nat @ 'ReactionConfig [none] .
    strat qid('expression-apply q ) : 'Nat @ 'ExpConfig [none] .
    strat qid('pair-apply q ) : 'Nat 'Nat @ 'ExpConfig [none] .
    )
    (SDEFS
    sd (qid('apply q))[['chn_['cn:ChannelName], 'N:Nat ]] 
      := 
     match 'pConf:ProtocolConfig 
      s.t. ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
      ? 'CONG-NEW-NF[none]{ (qid('apply q))[['chn_['cn:ChannelName], 'N:Nat ]]  } :
    matchrew 'pConf:ProtocolConfig s.t. 'pConfig['Sigma:Signature,'Delta:ChannelContext,'P:Protocol,
    'Ins:Set`{CNameBound`},'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] := 'pConf:ProtocolConfig by
    'pConf:ProtocolConfig using ('CONG-COMP-RIGHT[
       'P1:Protocol <- 'keepOne__['P:Protocol,'chn_['cn:ChannelName]] ;
       'Q:Protocol <- 'removeOne__['P:Protocol,'chn_['cn:ChannelName]]]
    {
    'CONG-REACT[
       'o:ChannelName <- 'cn:ChannelName]{
        qid('reaction-apply q )[[ 'N:Nat ]]
        or-else
       ( 'cong-pre-nf[none]{(qid('reaction-apply q ))[[ 'N:Nat ]]}
     ; try('pre2Nf[none]{empty})  )
        or-else 
        'cong-nf[none]{(qid('reaction-apply q ))[[ 'N:Nat ]]}
      }  
    }  )
       or-else
       'CONG-REACT[
       'o:ChannelName <- 'cn:ChannelName]{
        qid('reaction-apply q )[[ 'N:Nat ]]
        or-else
       ( 'cong-pre-nf[none]{(qid('reaction-apply q ))[[ 'N:Nat ]]}
     ; try('pre2Nf[none]{empty})  )
        or-else 
        'cong-nf[none]{(qid('reaction-apply q ))[[ 'N:Nat ]]}
      }       
    [none] 
     .
     sd (qid('apply q))[[ 'fam_['_`[_`]['cn:ChannelName,'blist:List`{Bounds`}]], 'N:Nat ]]
      := 
     match 'pConf:ProtocolConfig 
      s.t. ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
      ? 'CONG-NEW-NF[none]{ (qid('apply q))[[ 
          'fam_['_`[_`]['cn:ChannelName,'blist:List`{Bounds`}]], 'N:Nat ]]  } :
    matchrew 'pConf:ProtocolConfig s.t. 'pConfig['Sigma:Signature,'Delta:ChannelContext,'P:Protocol,
    'Ins:Set`{CNameBound`},'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] := 'pConf:ProtocolConfig by
    'pConf:ProtocolConfig using ('CONG-COMP-RIGHT[
       'P1:Protocol <- 
        'keepOne__[
           'P:Protocol, 
           'fam_['_`[_`]['cn:ChannelName,'blist:List`{Bounds`}]]
           ]   ;
       'Q:Protocol <- 'removeOne__['P:Protocol, 'fam_['_`[_`]['cn:ChannelName,'blist:List`{Bounds`}]] 
        ]
      ]
    {
    'CONG-REACT-family[
       'o:ChannelName <- 'cn:ChannelName]{
        qid('reaction-apply q )[[ 'N:Nat ]]
        or-else
       ( 'cong-pre-nf[none]{(qid('reaction-apply q ))[[ 'N:Nat ]]}
     ; try('pre2Nf[none]{empty})  )
        or-else 
        'cong-nf[none]{(qid('reaction-apply q ))[[ 'N:Nat ]]}
      } 
    }  )
       or-else
       'CONG-REACT-family[
       'o:ChannelName <- 'cn:ChannelName]{
        qid('reaction-apply q )[[ 'N:Nat ]]
        or-else
       ( 'cong-pre-nf[none]{(qid('reaction-apply q ))[[ 'N:Nat ]]}
     ; try('pre2Nf[none]{empty})  )
        or-else 
        'cong-nf[none]{(qid('reaction-apply q ))[[ 'N:Nat ]]}
      }       
    [none]  
       .
     sd (qid('reaction-apply q ))[['N:Nat]] := 
      'cong-ret[none]{(qid('expression-apply q ))[['N:Nat]]} 
      or-else 
      (qid('bind-apply q ))[['N:Nat,'0.Zero]] 
      or-else 
      (qid('if-apply q ))[['N:Nat,'0.Zero, '0.Zero]] [none] .
      
     sd (qid('bind-apply q ))[['0.Zero,'N:Nat]] := 'cong-bind[none]{idle,(qid('reaction-apply q ))[[
    'N:Nat]]} [none] .
  sd (qid('bind-apply q ))[['s_['M:Nat],'0.Zero]] := 'cong-bind[none]{(qid('reaction-apply q ))[[
    's_['M:Nat]]],idle} or-else (qid('bind-apply q ))[['M:Nat,'s_['0.Zero]]] [none] .
  sd (qid('bind-apply q ))[['s_['M:Nat],'N:NzNat]] := 'cong-bind[none]{test(
    (qid('reaction-apply q ))[['s_['M:Nat]]]),(qid('reaction-apply q ))[['N:NzNat]]} or-else
    (qid('bind-apply q ))[['M:Nat,'s_['N:NzNat]]] [none] .

  sd (qid('if-apply q ))[['0.Zero,'0.Zero,'N2:Nat]] := 'cong-if-expConfig[none]{idle,idle,
    (qid('reaction-apply q ))[['N2:Nat]]} [none] .
  sd (qid('if-apply q ))[['M:Nat,'s_['N1:Nat],'0.Zero]] := 'cong-if-expConfig[none]{test(
    (qid('reaction-apply q ))[['M:Nat]]),(qid('reaction-apply q ))[['s_['N1:Nat]]],idle}
    or-else (qid('if-apply q ))[['M:Nat,'N1:Nat,'s_['0.Zero]]] [none] .
  sd (qid('if-apply q ))[['M:Nat,'s_['N1:Nat],'N2:NzNat]] := 'cong-if-expConfig[none]{test(
    (qid('reaction-apply q ))[['M:Nat]]),test((qid('reaction-apply q ))[['s_['N1:Nat]]]),
    (qid('reaction-apply q ))[['N2:NzNat]]} or-else 'cong-if-expConfig[none]{test(
    (qid('reaction-apply q ))[['M:Nat]]),test((qid('reaction-apply q ))[['N1:Nat]]),
    (qid('reaction-apply q ))[['s_['N2:NzNat]]]} [none] .
  sd (qid('if-apply q ))[['s_['M:Nat],'0.Zero,'0.Zero]] := 'cong-if-expConfig[none]{
    (qid('reaction-apply q ))[['s_['M:Nat]]],idle,idle} or-else (qid('if-apply q ))[['M:Nat,'s_[
    '0.Zero],'0.Zero]] [none] .
  sd (qid('if-apply q ))[['s_['M:Nat],'0.Zero,'N2:NzNat]] := 'cong-if-expConfig[none]{test(
    (qid('reaction-apply q ))[['s_['M:Nat]]]),idle,(qid('reaction-apply q ))[['N2:NzNat]]}
    or-else (qid('if-apply q ))[['M:Nat,'s_['N2:NzNat],'0.Zero]] [none] . 
 
  sd (qid('expression-apply q ))[['0.Zero]] := idle [none] .
  sd (qid('expression-apply q ))[['s_['0.Zero]]] := q[none]{empty} or-else 'app-cong[none]{
    (qid('expression-apply q ))[['s_['0.Zero]]]} or-else 'fst-cong[none]{(qid('expression-apply q ))[['s_[
    '0.Zero]]]} or-else 'snd-cong[none]{(qid('expression-apply q ))[['s_['0.Zero]]]} or-else
    (qid('pair-apply q ))[['s_['0.Zero],'0.Zero]] [none] .
  sd (qid('expression-apply q ))[['s_['N:NzNat]]] := 'app-cong[none]{(qid('expression-apply q ))[['s_['N:NzNat]]]}
    or-else 'fst-cong[none]{(qid('expression-apply q ))[['s_['N:NzNat]]]} or-else 'snd-cong[none]{
    (qid('expression-apply q ))[['s_['N:NzNat]]]} or-else (qid('pair-apply q ))[['s_['N:NzNat],'0.Zero]] [
    none] .
    
  sd (qid('pair-apply q ))[['0.Zero,'N:Nat]] := 'pair-cong[none]{idle,(qid('expression-apply q ))[['N:Nat]]}
    [none] .
  sd (qid('pair-apply q ))[['s_['M:Nat],'0.Zero]] := 'pair-cong[none]{(qid('expression-apply q ))[['s_[
    'M:Nat]]],idle} or-else (qid('pair-apply q ))[['M:Nat,'s_['0.Zero]]] [none] .
  sd (qid('pair-apply q ))[['s_['M:Nat],'N:NzNat]] := 'pair-cong[none]{test((qid('expression-apply q ))[[
    's_['M:Nat]]]),(qid('expression-apply q ))[['N:NzNat]]} or-else (qid('pair-apply q ))[['M:Nat,'s_[
    'N:NzNat]]] [none] .   

      
    )
    endsm
    ) .
  **********************
  *** generated strategies
  eq env >>= {'lemma_=_=>_:_.[I, I1, I2, I3] : 'LemmaDecl} 
   = setModule env
     (addLemma env (getModule env) ({'lemma_=_=>_:_.[I, I1, I2, I3] : 'LemmaDecl}))  .
  eq env >>= {'strict`subproof_=_.[I, I1] : 'SubProofDecl} 
   = setModule env
     (addSubproof env (getModule env) {'strict`subproof_=_.[I, I1] : 'SubProofDecl})
  .
  eq env >>= {'approx`subproof_=_.[I, I1] : 'SubProofDecl} 
   = setModule env
     (addSubproof env (getModule env) {'approx`subproof_=_.[I, I1] : 'SubProofDecl})
  .
  eq env >>= {'approx-assumption_using_:_;_;_|=_=_.[I, VS, DT, IT, I1, RP1, RP2] : 'ApproxAssumDecl}
   = setModule env 
   (add-approx-assumption(getModule env,
     read-qid(I),
     read-vars(IPDL, VS), 
     read-delta(IPDL, env, DT),
     makeSet(read-cNameBoundList(IPDL, env, IT)),
     read-boolTermList(IPDL, I1),
      computeNF(read-protocol(IPDL, env, RP1)),
      computeNF(read-protocol(IPDL, env, RP2))
   )
     )
  .  
  eq env >>= {'protocol-assumption_using_:_;_;_|=_=_.[I, VS, DT, IT, I1, RP1, RP2] : 'AssumDecl}
   = setModule env 
   (add-protocol-assumption(getModule env,
     read-qid(I),
     read-vars(IPDL, VS), 
     read-delta(IPDL, env, DT),
     makeSet(read-cNameBoundList(IPDL, env, IT)),
     read-boolTermList(IPDL, I1),
      computeNF(read-protocol(IPDL, env, RP1)),
      computeNF(read-protocol(IPDL, env, RP2))
   )
     )
  .                
  eq env >>= {'reaction-assumption_using_:_;_;_|=_=_.[I, VS, DT, CT, IT, RT1, RT2] : 'AssumDecl}
   = (setModule env
  (add-assumption(
    env, 
    getModule env, 
     read-qid(I), 
     read-vars(IPDL, VS), 
     read-delta(IPDL, env, DT), 
     read-gamma(IPDL, CT), 
     read-inputs(IPDL, IT), 
     read-reaction(IPDL, RT1), 
     read-reaction(IPDL, RT2) )
  ) ) >>= I 
  . 
  eq env >>= {'expression-assumption`%automatic_using_:_|=_=_.[I, VS, CT, I1, I2] : 'AssumDecl}
   = (setModule env
  (add-assumption-as-eq(
    getModule env, 
     read-qid(I), 
     read-vars(IPDL, VS), 
      
     read-gamma(IPDL, CT), 
 
     read-expression(IPDL, I1), 
     read-expression(IPDL, I2) )
  ) ) >>= I 
  .
  eq env >>= {'expression-assumption`%manual_using_:_|=_=_.[I, VS, CT, I1, I2] : 'AssumDecl}
   = (setModule env
  (add-assumption-as-rl(
    getModule env, 
     read-qid(I), 
     read-vars(IPDL, VS), 
      
     read-gamma(IPDL, CT), 
 
     read-expression(IPDL, I1), 
     read-expression(IPDL, I2) )
  ) ) >>= I 
  .
  
   ceq env >>= I
    = srewAConfig env'
       aStrat
   if  I :: 'ApproxProof 
   /\  (env' envStratPair aStrat) := approxProof2Strategy env I 
   .  

   
   eq env >>= {'on`reaction`of_`(_`) [I1, I2] : 'StrictProof}
    = srewPConfig
       (addStratDecls env {'on`reaction`of_`(_`) [I1, I2] : 'StrictProof})
       (generatedStrategyCall env) . 
   eq env >>= {'group_in_indices:_bounds:_[I, I1, I2, I3] : 'StrictProof} 
    = srewPConfig
       (addStratDecls env {'group_in_indices:_bounds:_[I, I1, I2, I3] : 'StrictProof})
       (generatedStrategyCall env) .     

    

   eq env >>= {'try`sym`from_:_done[I1, I2] : 'StrictProof}
    = env >>= {'sym`from_`(_`)[I1, I2] : 'StrictProof} .   
  ceq env >>= {'try`sym`from_:_[I1, I2] : 'StrictProof}
   = *** first we push in the stack the updated pConf 
     (srewPConfig
     (pushPConfig 
      env 
      ( pConfig(Sigma, Delta, computeNF (read-protocol(IPDL, env, I1)), Ins, Outs, A)
      ) 
     )
     (  'sugar-newNF[none]{empty} *** ; 'moveAllToFront[[empty]]
      ; ( ('COMP-NEW-newNF-inside-new[none]{empty})! )
     )
     )
     *** then we do the subproof
     >>= I2 
   if pConfig(Sigma, Delta, P, Ins, Outs, A) := getPConfig env .       
  ceq env >>= {'try`sym`from_over_:_[I, I1, I2] : 'StrictProof}
   = *** first we push in the stack the updated pConf 
     (srewPConfig
     (pushPConfig 
      env 
      ( pConfig(Sigma, read-delta(IPDL, env, I1), 
                       P2,
                       Ins, 
                       getOutputs(P2), A)
      ) 
     )
     (  'sugar-newNF[none]{empty} *** ; 'moveAllToFront[[empty]]
      ; ( ('COMP-NEW-newNF-inside-new[none]{empty})! )
     )
     )
     *** then we do the subproof
     >>= I2
   if pConfig(Sigma, Delta, P, Ins, Outs, A) := getPConfig env 
   /\ P2 := computeNF (read-protocol(IPDL, env, I)).      
  ceq env >>= {'try`in`the`presence`of_rewrite_to_by`induction`on_bound_:_
                [I, I1, I2, I3, I4, I5 ] : 'StrictProof}
   = *** first we push in the stack the updated pConf 
     (pushPConfig 
      env 
      (generateInductionConfig 
        pConfig(Sigma, addChannels getHiddenDecls(P) Delta, P1, 
                       union(Ins, getOutputs(Q)), getOutputs(P1), A)
        cn
        q1 
        q2
        computeNF(read-cases(IPDL, env, I2))
      )
     )
     *** then we do the subproof
     >>= I5
   if pConfig(Sigma, Delta, P, Ins, Outs, A) :=  getPConfig env 
   /\ family (cn[blist]) := read-ruleTarget(IPDL, I1)
   /\ cnbl := read-cNameBoundList(IPDL, env, I)
   /\ P1 := keepAll P (cnbl fam(cn[blist]))
   /\ Q := removeAll P (cnbl fam(cn[blist]))
   /\ (qidAsTerm q1) := read-natTerm(IPDL, I3) 
   /\ (qidAsTerm q2) := read-natTerm(IPDL, I4)
   . 
   ceq env >>= {'try`in`the`presence`of_rewrite_to_by`induction`on_bound_:_
                [I, I1, I2, I3, I4, I5 ] : 'StrictProof}
   = *** first we push in the stack the updated pConf 
     (pushPConfig 
      env 
      (generateInductionConfigP 
        pConfig(Sigma, addChannels getHiddenDecls(P) Delta, P1, 
                       union(Ins, getOutputs(Q)), getOutputs(P1), A)
        cn
        q1 
        q2
        computeNF(read-cases(IPDL, env, I2))
      )
     )
     *** then we do the subproof
     >>= I5
   if pConfig(Sigma, Delta, P, Ins, Outs, A) :=  getPConfig env 
   /\ group (cn[blist]) := read-ruleTarget(IPDL, I1)
   /\ cnbl := read-cNameBoundList(IPDL, env, I)
   /\ P1 := keepAll P (cnbl fam(cn[blist]))
   /\ Q := removeAll P (cnbl fam(cn[blist]))
   /\ (qidAsTerm q1) := read-natTerm(IPDL, I3) 
   /\ (qidAsTerm q2) := read-natTerm(IPDL, I4)
   .
   ceq env >>= {'try`rewrite_to_by`induction`on_bound_:_
                [I1, I2, I3, I4, I5 ] : 'StrictProof}
   = *** first we push in the stack the updated pConf 
     (pushPConfig 
      env 
      (generateInductionConfig
        pConfig(Sigma, addChannels ltq Delta, P, 
                       Ins, getOutputs(P), A)
        cn
        q1 
        q2
        computeNF(read-cases(IPDL, env, I2))
      )
     )
     *** then we do the subproof
     >>= I5
   if pConfig(Sigma, Delta, newNF(ltq, P), Ins, Outs, A) :=  getPConfig env 
   /\ family (cn[blist]) := read-ruleTarget(IPDL, I1)
   /\ (qidAsTerm q1) := read-natTerm(IPDL, I3) 
   /\ (qidAsTerm q2) := read-natTerm(IPDL, I4)
   .     
   ceq env >>= {'try`rewrite_to_by`induction`on_bound_:_
                [I1, I2, I3, I4, I5 ] : 'StrictProof}
   = *** first we push in the stack the updated pConf 
     (pushPConfig 
      env 
      (generateInductionConfigP 
        pConfig(Sigma, Delta, P, 
                       Ins, Outs, A)
        cn
        q1 
        q2
        computeNF(read-cases(IPDL, env, I2))
      )
     )
     *** then we do the subproof
     >>= I5
   if pConfig(Sigma, Delta, P, Ins, Outs, A) :=  getPConfig env 
   /\ group (cn[blist]) := read-ruleTarget(IPDL, I1)
   /\ (qidAsTerm q1) := read-natTerm(IPDL, I3) 
   /\ (qidAsTerm q2) := read-natTerm(IPDL, I4)
   .   
      ***( groups
   ceq env >>= {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'StrictProof}
   = (srewPConfig
     (pushPConfig 
       env
      pConfig(Sigma, addChannels ltq Delta, Q || P1, Ins, getOutputs(Q || P1), 
              (A, whenCondToBoolTerm whenCond) )
     )
     (try('moveProtocolUnderNewNF[[empty]]) ) 
    ) >>= I2
   if pConfig(Sigma, Delta, newNF(ltq,P), Ins, Outs, A) :=  getPConfig env 
   /\ family (cn[blist]) nlist blist ::= (whenCond --> P1) ;; whenList := 
        keepOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))
   /\ Q := removeOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))     
   .  
   ceq env >>= {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'StrictProof}
   = (srewPConfig
      (pushPConfig 
       env
      pConfig(Sigma, Delta, Q || P1, Ins, Outs, (A, whenCondToBoolTerm whenCond) )
     )
     (try('moveProtocolUnderNewNF[[empty]]) ) 
    ) >>= I2
   if pConfig(Sigma, Delta, P, Ins, Outs, A) :=  getPConfig env 
   /\ family (cn[blist]) nlist blist ::= (whenCond --> P1) ;; whenList := 
        keepOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))
   /\ Q := removeOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))     
   .  
   *** families
   ceq env >>= {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'StrictProof}
   = (pushPConfig 
       env
      pConfig(Sigma, addChannels ltq Delta, 
              Q || (family (cn[blist]) nlist blist ::= R1), 
              Ins, 
              getOutputs(Q || (family (cn[blist]) nlist blist ::= R1)), 
              (A, whenCondToBoolTerm whenCond) )
     ) >>= I2
   if pConfig(Sigma, Delta, newNF(ltq,P), Ins, Outs, A) :=  getPConfig env 
   /\ family (cn[blist]) nlist blist ::= (whenCond --> R1) ;; whenList := 
        keepOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))
   /\ Q := removeOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))     
   .        
        
   ceq env >>= {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'StrictProof}
   = (pushPConfig 
       env
      pConfig(Sigma, Delta, 
              Q || (family (cn[blist]) nlist blist ::= R1), 
              Ins, Outs, (A, whenCondToBoolTerm whenCond) )
     ) >>= I2
   if pConfig(Sigma, Delta, P, Ins, Outs, A) :=  getPConfig env 
   /\ family (cn[blist]) nlist blist ::= (whenCond --> R1) ;; whenList := 
        keepOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))
   /\ Q := removeOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))     
   . 
   *** channels
   ceq env >>= {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'StrictProof}
   = (pushPConfig 
       env
      pConfig(Sigma, addChannels ltq Delta, 
              Q || (cn ::= R1), 
              Ins, 
              getOutputs(Q || (cn ::= R1)), 
              (A, whenCondToBoolTerm whenCond) )
     ) >>= I2
   if pConfig(Sigma, Delta, newNF(ltq, P), Ins, Outs, A) :=  getPConfig env      
   /\ cn ::= (whenCond --> R1) ;; whenList := 
        keepOne P (chn ( cNameTarget(read-ruleTarget(IPDL, I1)) ) )
   /\ Q := removeOne P (chn ( cNameTarget(read-ruleTarget(IPDL, I1)) ) )   
   .              
   ceq env >>= {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'StrictProof}
   = (pushPConfig 
       env
      pConfig(Sigma, Delta, 
              Q || (cn ::= R1), 
              Ins, Outs, (A, whenCondToBoolTerm whenCond) )
     ) >>= I2
   if pConfig(Sigma, Delta, P, Ins, Outs, A) :=  getPConfig env 
   /\ cn ::= (whenCond --> R1) ;; whenList := 
        keepOne P (chn ( cNameTarget(read-ruleTarget(IPDL, I1)) ) )
   /\ Q := removeOne P (chn ( cNameTarget(read-ruleTarget(IPDL, I1)) ) ) 
   .  
    )
  
   var R : Reaction .
   vars whenList1 whenList2 : WhenList .

  *** try done
  eq env >>= {'try`on`branch_of_:_done [I, I1, I2] : 'StrictProof }
   = env >>= {'on`branch_of_`(_`) [I, I1, I2] : 'StrictProof } .
     *** try on branch of a channel with newNF
  ceq env >>= {'try`on`branch_of_:_ [I, I1, I2] : 'StrictProof }
   = *** first we push in the stack the updated pConf 
     (pushPConfig 
      env 
        pConfig(Sigma, Delta, newNF(ltq, P || (cn ::= R)),
                Ins, Outs, (A, bt))
     )
     *** then we do the subproof
     >>= I2
   if bt := read-boolTerm(IPDL, I)
   /\ channel cn := read-ruleTarget(IPDL, I1)
   /\ pConfig(Sigma, Delta, 
       newNF(
        ltq, 
        P || (cn ::= (whenList1 ;; (when bt --> R) ;; whenList2) )
      ), Ins, Outs, A) :=  getPConfig env 
   .   
  *** try on branch of a channel without newNF
  ceq env >>= {'try`on`branch_of_:_ [I, I1, I2] : 'StrictProof }
   = *** first we push in the stack the updated pConf 
     (pushPConfig 
      env 
        pConfig(Sigma, Delta, P || (cn ::= R),
                Ins, Outs, (A, bt))
     )
     *** then we do the subproof
     >>= I2
   if bt := read-boolTerm(IPDL, I)
   /\ channel cn := read-ruleTarget(IPDL, I1)
   /\ pConfig(Sigma, Delta, 
        P || (cn ::= (whenList1 ;; (when bt --> R) ;; whenList2) )
      , Ins, Outs, A) :=  getPConfig env 
   .
  *** try on branch of a family with newNF
  ceq env >>= {'try`on`branch_of_:_ [I, I1, I2] : 'StrictProof }
   = *** first we push in the stack the updated pConf 
     (pushPConfig 
      env 
        pConfig(Sigma, Delta, newNF(ltq, P || (family (ns[blist]) nlist blist ::= R)),
                Ins, Outs, (A, bt))
     )
     *** then we do the subproof
     >>= I2
   if bt := read-boolTerm(IPDL, I)
   /\ family (ns[blist]) := read-ruleTarget(IPDL, I1)
   /\ pConfig(Sigma, Delta, 
       newNF(
        ltq, 
        P || (family (ns[blist]) nlist blist ::= (whenList1 ;; (when bt --> R) ;; whenList2) )
      ), Ins, Outs, A) :=  getPConfig env 
   .   
  *** try on branch of a family without newNF
  ceq env >>= {'try`on`branch_of_:_ [I, I1, I2] : 'StrictProof }
   = *** first we push in the stack the updated pConf 
     (pushPConfig 
      env 
        pConfig(Sigma, Delta, P || (family (ns[blist]) nlist blist ::= R),
                Ins, Outs, (A, bt))
     )
     *** then we do the subproof
     >>= I2
   if bt := read-boolTerm(IPDL, I)
   /\ family (ns[blist]) := read-ruleTarget(IPDL, I1)
   /\ pConfig(Sigma, Delta, 
        P || (family (ns[blist]) nlist blist ::= (whenList1 ;; (when bt --> R) ;; whenList2) )
      , Ins, Outs, A) :=  getPConfig env 
   . 
  *** try on branch of a group with newNF
  ceq env >>= {'try`on`branch_of_:_ [I, I1, I2] : 'StrictProof }
   = *** first we push in the stack the updated pConf 
     (pushPConfig 
      env 
        pConfig(Sigma, Delta, newNF(ltq, P || P1),
                Ins, Outs, (A, bt))
     )
     *** then we do the subproof
     >>= I2
   if bt := read-boolTerm(IPDL, I)
   /\ group (ns[blist]) := read-ruleTarget(IPDL, I1)
   /\ pConfig(Sigma, Delta, 
       newNF(
        ltq, 
        P || (family (ns[blist]) nlist blist ::= (whenList1 ;; (when bt --> P1) ;; whenList2) )
      ), Ins, Outs, A) :=  getPConfig env 
   .   
  *** try on branch of a group without newNF  
  ceq env >>= {'try`on`branch_of_:_ [I, I1, I2] : 'StrictProof }
   = *** first we push in the stack the updated pConf 
     (pushPConfig 
      env 
        pConfig(Sigma, Delta, P || P1,
                Ins, Outs, (A, bt))
     )
     *** then we do the subproof
     >>= I2
   if bt := read-boolTerm(IPDL, I)
   /\ group (ns[blist]) := read-ruleTarget(IPDL, I1)
   /\ pConfig(Sigma, Delta, 
        P || (family (ns[blist]) nlist blist ::= (whenList1 ;; (when bt --> P1) ;; whenList2) )
      , Ins, Outs, A) :=  getPConfig env 
   .   
          
  *** apply a strategy given as argument and change the pConfig in env if successful

        *** TODO: Proof[_]{move_on each branch of_}
   *** TODO: diverge on!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   *** eq proofStep2Strategy(aProof) = idle [owise] .    

    eq env >>= I = env [owise label unchangedEnv] . 
endm

*** ----------------------------------------------------------------------------

view IPDL/AnalysisState from ANALYSIS-STATE to IPDL/ANALYSIS-STATE is
  sort State to Env .
endv

*** ----------------------------------------------------------------------------

mod IPDL/PARSING is
  including SYNTACTIC-ANALYSIS { IPDL, IPDL/AnalysisState } .
  including PROTOCOL-EQUALITY .
  protecting SET{TypeContextElem} .

  var L : IPDL .
  var QIL : QidList .
  var QIS QIS' : QidSet .
  vars $I I $I1 I1 $I2 I2 $I3 I3 I4 I5 T S DT IT CT R1 R2 VS P1 P2 IS AS : ATerm .
  vars $ QI QI1 QI2 QI3 QI4 q : Qid .
  var env : Env .
  var protMap : Map{Qid, Protocol} .
  var embMap embMap' : Map{Qid, IPDLEmbedding} .
  var pConf : ProtocolConfig .
  var aConf : ApproxEqConfig .
  var Sigma : Signature .
  var Delta : ChannelContext .
  var Gamma : TypeContext .
  var Ins Outs : Set{CNameBound} .
  var A : Set{BoolTerm} .
  var P : Protocol . 
  var m : Module .
  var TCS : Set{TypeContextElem} .
  var TL : ATermList .
  var WA : WarningArgs .
  var l : Length .
  var w : Width .
  var tc : Bool .

  *** parse input  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  eq parse L input (QIL) in env
   = parse L input [false] (QIL) in env .

  op parse_input`[_`]_in_ : IPDL Bool QidList Env ~> ParsingOutcome .
  eq parse L input [tc] (QIL) in env
   = (parse L command (QIL))
     or-else (parse L proof (QIL) in env)
     or-else (parse L declaration [tc] (QIL) in env)
     [label parse-IPDL-input] .

  op parse_command_ : IPDL QidList ~> ParsingOutcome .
  eq parse L command (QIL)
   = scan L input (QIL : 'Command) .
  
  op parse_declaration`[_`]_in_ : IPDL Bool QidList Env ~> ParsingOutcome .
  eq parse L declaration [tc] (QIL '.) in env
   = scan L input (QIL '. : 'TopDecl) then analyse L declaration [tc] in env .
  eq parse L declaration [tc] (QIL) in env
   = incomplete input [owise] .

  op parse_proof_in_ : IPDL QidList Env ~> ParsingOutcome .
  eq parse L proof (QIL) in env
   = (scan L input (QIL : 'ApproxProof)  then analyse L approxProof in env)
     or-else (scan L input (QIL : 'StrictProof)  then analyse L proof in env) .

  op analyse_approxProof : IPDL -> AnalysisAction{IPDL} .
  ceq analyse L approxProof I
    = analyse L proof I 
   if I :: 'StrictProof .
  eq analyse L approxProof {'_then-approx_ [I1, I2] : 'ApproxProof} 
   = try {'_then-approx_ [
           analyse L approxProof (I1), 
           analyse L approxProof (I2)] : 'ApproxProof}  .
  eq analyse L approxProof {'sym-approx`from_`(_`) [I1, I2] : 'ApproxProof}
   = try {'sym-approx`from_`(_`) [
         solve L protocol (I1), 
         analyse L approxProof (I2)
      ] : 'ApproxProof} .   
  eq analyse L approxProof {'use`approx`assumption_on_[I1, I2] : 'ApproxProof}
   = try {'use`approx`assumption_on_[
          check L aName (I1), 
          solve L cNameBoundList (I2)
      ] : 'ApproxProof} .
  eq analyse L approxProof {'use`approx`assumption_[I1] : 'ApproxProof}
   = try {'use`approx`assumption_[
         check L aName (I1)
      ] : 'ApproxProof} .
  eq analyse L approxProof {'call-approx_[I1] : 'ApproxProof}
   = try {'call-approx_[
         check L sname (I1)
      ] : 'ApproxProof} .
  eq analyse L approxProof 
   {'in`the`presence`of_rewrite_to_by`generalization`of_ [I1, I2, I3, I4] : 'ApproxProof}    
   = try {'in`the`presence`of_rewrite_to_by`generalization`of_ [
          solve L cNameBoundList (I1), 
          solve L ruleTarget (I2), 
          solve L cases (I3) , 
          check L sname (I4)
      ] : 'ApproxProof} .
  eq analyse L approxProof 
   {'approx`generalize`for_`(_`) [I1, I2] : 'ApproxProof}
  = try {'approx`generalize`for_`(_`) [
       solve L cNameBound (I1), 
       analyse L approxCongrProof (I2)
     ] : 'ApproxProof} .


  op analyse_approxCongrProof : IPDL -> AnalysisAction{IPDL} .
  eq analyse L approxCongrProof {'approx`embed_along_with`inputs_`(_`) [I1, I2, I3, I4] : 'ApproxCongrProof}
   = try 
      {'approx`embed_along_with`inputs_`(_`) [
           solve L protocol (I1), 
           solve L embName (I2), 
           solve L cNameBoundList (I3), 
           analyse L approxCongrProof (I4)
      ] : 'ApproxCongrProof} .
  eq analyse L approxCongrProof {'use`approx`axiom_ [I] : 'ApproxCongrProof}
   = try {'use`approx`axiom_ [
           solve L aName (I)
      ] : 'ApproxCongrProof} .
  eq analyse L approxCongrProof {'approx`case`distinction`on_`(_`) [I1, I2] : 'ApproxCongrProof}
   = try {'approx`case`distinction`on_`(_`) [
           solve L cNameBound (I1), 
           analyse L approxCongrProofCases (I2)
      ] : 'ApproxCongrProof} .

  op analyse_approxCongrProofCases : IPDL -> AnalysisAction{IPDL} .
  eq analyse L approxCongrProofCases {'case:`(_`) [ I ] : 'ApproxCongrProofCase }
   = try {'case:`(_`) [ analyse L approxCongrProof (I) ] : 'ApproxCongrProofCase } .
  eq analyse L approxCongrProofCases {'__ [I1, I2] : 'ApproxCongrProofCaseList} 
   = try {'__ [
       analyse L approxCongrProofCases (I1), 
       analyse L approxCongrProofCases (I2)] 
      : 'ApproxCongrProofCaseList} .

  op analyse_declaration`[_`] : IPDL Bool -> AnalysisAction{IPDL} .
  eq analyse L declaration [tc] {'type_.[I] : 'TypeDecl}
   = try {'type_. [
        check L tdid (I)
      ] : 'TypeDecl} .
  eq analyse L declaration [tc] {'embedding_from_to_=_. [I, I1, I2, I3] : 'EmbedDecl} 
   = try  {'embedding_from_to_=_. [
       check L embName (I), *** TODO: check new in env, 
       solve L dName (I1), *** TODO: check exists in env, 
       solve L dName (I2), *** TODO: check exists in env 
       solve L cNameMap (I3)
       ] : 'EmbedDecl} .   
  eq analyse L declaration [tc] {'hypothesis_.[I] : 'HypoDecl}
   = try {'hypothesis_. [
        solve L boolTerm (I)
        then
        check L emptyTypeContext boolTerm
      ] : 'HypoDecl} .    
  eq analyse L declaration [tc] {'function_:_->_.[I, I1, I2] : 'OpDecl}
   = try {'function_:_->_. [
        solve L fName (I) then
        check L fname,
        solve L preType (I1) then
        check L preType,
        solve L preType (I2) then
        check L preType
      ] : 'OpDecl} .  
  eq analyse L declaration [tc] {'distribution_:_->_.[I, I1, I2] : 'DistDecl}
   = try {'distribution_:_->_. [
        solve L dName (I) then
        check L dname,
        solve L preType (I1) then
        check L preType,
        solve L preType (I2) then
        check L preType
      ] : 'DistDecl} .  
  eq analyse L declaration [tc] {'channel`context_=_. [I1, I2] : 'DeltaDecl}
   = try {'channel`context_=_. [
         solve L dName (I1), 
         solve L channelDeclList (I2)
      ] : 'DeltaDecl}  
   .   
  ceq analyse L declaration [tc] {'input_:_.[I, I1] : 'InDecl}
   = try {'input_:_. [
        solve L cNameIndex (I), *** check L cname (I),
        solve L preType (I1) then
        check L preType
      ] : 'InDecl} 
   if I :: 'CName   .       
  ceq analyse L declaration [tc] {'input_:_.[I, I1] : 'InDecl}
   = try {'input_:_. [
        solve L cNameIndex (I), *** check L cname (I),
        solve L preType (I1) then
        check L preType
      ] : 'InDecl} 
   if I :: 'CNameIndex   .  
  ceq analyse L declaration [tc] {'input_:_.[I, I1] : 'InDecl}
   = try {'input_:_. [
        solve L familyName (I) then
        check L familyName, 
        solve L preType (I1) then
        check L preType
      ] : 'InDecl} 
   if I :: 'BasicFamilyName   .   
  eq analyse L declaration [tc] {'parameter_:_.[I, I1] : 'ParamDecl}
   = try {'parameter_:_. [
        solve L paramName (I), *** the name should be new!
        solve L preType (I1) then
        check L preType
      ] : 'ParamDecl} .              
  ceq analyse L declaration [tc] {'output_:_.[I, I1] : 'OutDecl}
   = try {'output_:_. [
        solve L cNameIndex (I),
        solve L preType (I1) then
        check L preType 
      ] : 'OutDecl} 
  if I :: 'CName .     
  ceq analyse L declaration [tc] {'output_:_.[I, I1] : 'OutDecl}
   = try {'output_:_. [
        solve L cNameIndex (I),
        solve L preType (I1) then
        check L preType 
      ] : 'OutDecl} 
  if I :: 'CNameIndex . 
  ceq analyse L declaration [tc] {'output_:_.[I, I1] : 'OutDecl}
   = try {'output_:_. [
        solve L familyName (I) then
        check L familyName, 
        solve L preType (I1) then
        check L preType
      ] : 'OutDecl} 
   if I :: 'BasicFamilyName   . 
  eq analyse L declaration [tc] {'strict`subproof_=_.[I, I1] : 'SubProofDecl}
   = try {'strict`subproof_=_. [
        check L sname (I),
         analyse L proof (I1)
      ] : 'SubProofDecl} . 
  eq analyse L declaration [tc] {'lemma_=_=>_:_. [I, I1, I2, I3]  : 'LemmaDecl}
   = try {'lemma_=_=>_:_. [
        check L sname (I),
        solve L protocol (I1),
        solve L protocol (I2),
         analyse L proof (I3)
      ] : 'LemmaDecl} .    
  eq analyse L declaration [tc] {'approx`subproof_=_.[I, I1] : 'SubProofDecl}
   = try {'approx`subproof_=_. [
        check L sname (I),
         analyse L approxProof (I1)
      ] : 'SubProofDecl} .             
  eq analyse L declaration [false] {'protocol_=_.[I, I1] : 'PDecl}
   = try {'protocol_=_. [
        check L pname (I),
              solve L protocol (I1)
      ] : 'PDecl} . 
  eq analyse L declaration [true] {'protocol_=_.[I, I1] : 'PDecl}
   = try {'protocol_=_. [
        check L pname (I),
              solve L protocol (I1) 
         then check L protocol
     *** then type check L protocol
      ] : 'PDecl} .          
  eq analyse L declaration [tc] {'protocol_.[I] : 'PDecl}
   = try {'protocol_. [
        check L pname (I)     
      ] : 'PDecl} .  
  eq analyse L declaration [tc] {'import_.[I] : 'Import}
   = try {'import_. [
        check L moduleName (I)
      ] : 'Import} .  
  eq analyse L declaration  [tc] 
     {'reaction-assumption_using_:_;_;_|=_=_.[I, VS, DT, CT, IT, R1, R2] : 'AssumDecl}
   = try  {'reaction-assumption_using_:_;_;_|=_=_.[
       check L aName (I),  *** should check that it's not used as assum name or as rule name!
       check L assumVars (VS),
       check L delta (DT), 
       check L gamma (CT), 
       check L inputs (IT), 
       solve L reaction (R1) then
       check L emptyTypeContext reaction , *** TODO: should be read-gamma(L, CT)?
       solve L reaction (R2) then
       check L emptyTypeContext reaction
        ] : 'AssumDecl} . 
   eq analyse L declaration [tc] 
       {'approx-assumption_using_:_;_;_|=_=_.[I, VS, DT, IS, AS, P1, P2] : 'ApproxAssumDecl}
   = try  {'approx-assumption_using_:_;_;_|=_=_.[
       check L aName (I),  *** should check that it's not used as assum name or as rule name!
       check L assumVars (VS),
       check L delta (DT), 
       solve L cNameBoundList (IS), 
       solve L boolTerms (AS), 
       solve L protocol (P1) ,
       solve L protocol (P2)
        ] : 'ApproxAssumDecl} .     
   eq analyse L declaration [tc]  
       {'protocol-assumption_using_:_;_;_|=_=_.[I, VS, DT, IS, AS, P1, P2] : 'AssumDecl}
   = try  {'protocol-assumption_using_:_;_;_|=_=_.[
       check L aName (I),  *** should check that it's not used as assum name or as rule name!
       check L assumVars (VS),
       check L delta (DT), 
       solve L cNameBoundList (IS), 
       solve L boolTerms (AS), 
       solve L protocol (P1) ,
       solve L protocol (P2)
        ] : 'AssumDecl} .      
   eq analyse L declaration [tc] 
      {'expression-assumption`%manual_using_:_|=_=_.[I, VS, CT, I1, I2] : 'AssumDecl}
   = try  {'expression-assumption`%manual_using_:_|=_=_.[
       check L aName (I),  *** should check that it's not used as assum name or as rule name!
       check L assumVars (VS),
       check L gamma (CT), 
       solve L expression (I1),
       solve L expression (I2)
       
       *** check L emptyTypeContext reaction , *** TODO: should be read-gamma(L, CT)?
       
       *** check L emptyTypeContext reaction
        ] : 'AssumDecl} .
   eq analyse L declaration [tc] 
      {'expression-assumption`%automatic_using_:_|=_=_.[I, VS, CT, I1, I2] : 'AssumDecl}
   = try  {'expression-assumption`%automatic_using_:_|=_=_.[
       check L aName (I),  *** should check that it's not used as assum name or as rule name!
       check L assumVars (VS),
       check L gamma (CT), 
       solve L expression (I1),
       solve L expression (I2)
       
       *** check L emptyTypeContext reaction , *** TODO: should be read-gamma(L, CT)?
       
       *** check L emptyTypeContext reaction
        ] : 'AssumDecl} .           
 
  op solve_cNameMap : IPDL -> AnalysisAction{IPDL} .
  eq solve L cNameMap {'emptyCNameMap.CNameMap : 'CNameMap}
   = return {'emptyCNameMap.CNameMap : 'CNameMap} .
  eq solve L cNameMap {'_|->_ [I1, I2] : 'CNameMap} 
   = try {'_|->_ [
           solve L cNameIndex (I1), 
           solve L cNameIndex (I2)
      ] : 'CNameMap} .
  eq solve L cNameMap {'_;_ [I1, I2] : 'CNameMap} 
   = try {'_;_ [
           solve L cNameMap (I1), 
           solve L cNameMap (I2)
      ] : 'CNameMap} .

  op solve_channelDeclList : IPDL -> AnalysisAction{IPDL} .
  ceq solve L channelDeclList {'input_:_ [I1, I2] : 'ChannelDecl}
   = try {'input_:_ [
           solve L cNameIndex (I1), 
           solve L preType (I2)
      ] : 'ChannelDecl} 
   if I1 :: 'CName .
  ceq solve L channelDeclList {'input_:_ [I1, I2] : 'ChannelDecl}
   = try {'input_:_ [
           solve L cNameIndex (I1), 
           solve L preType (I2)
      ] : 'ChannelDecl} 
   if I1 :: 'CNameIndex .
  ceq solve L channelDeclList {'input_:_ [I1, I2] : 'ChannelDecl}
   = try {'input_:_ [
           solve L familyName (I1), 
           solve L preType (I2)
      ] : 'ChannelDecl} 
   if I1 :: 'BasicFamilyName .   
  ceq solve L channelDeclList {'output_:_ [I1, I2] : 'ChannelDecl}
   = try {'output_:_ [
           solve L cNameIndex (I1), 
           solve L preType (I2)
      ] : 'ChannelDecl} 
   if I1 :: 'CName   .
  ceq solve L channelDeclList {'output_:_ [I1, I2] : 'ChannelDecl}
   = try {'output_:_ [
           solve L cNameIndex (I1), 
           solve L preType (I2)
      ] : 'ChannelDecl} 
   if I1 :: 'CNameIndex  .
   ceq solve L channelDeclList {'output_:_ [I1, I2] : 'ChannelDecl}
   = try {'output_:_ [
           solve L familyName (I1), 
           solve L preType (I2)
      ] : 'ChannelDecl} 
   if I1 :: 'BasicFamilyName   .  
  eq solve L channelDeclList {'_;_ [I1, I2] : 'ChannelDeclList}
   = try {'_;_ [
        solve L channelDeclList (I1), 
        solve L channelDeclList (I2)
      ] : 'ChannelDeclList} .
    
  op analyse_proof : IPDL -> AnalysisAction{IPDL} .        
  eq analyse L proof {'start`with_over_[I1, I2] : 'StrictProof} 
   = try {'start`with_over_[
           check L declaredPname (I1),
           solve L dName (I2) ***TODO : check that is in domain of deltaMap
      ] : 'StrictProof} .
  eq analyse L proof {'absorb_[I1] : 'StrictProof} 
   = try {'absorb_[
      solve L cNameBound (I1) 
      ] : 'StrictProof} .
  eq analyse L proof {'group-absorb_[I1] : 'StrictProof} 
   = try {'group-absorb_[
      solve L ruleTarget (I1) 
      ] : 'StrictProof} .    
  eq analyse L proof {'compose_with_in`group [I1, I2] : 'StrictProof }
   = try {'compose_with_in`group [
           solve L cNameBound (I1), 
           solve L cNameBound (I2)] : 'StrictProof } .  
  eq analyse L proof {'decompose_with_ [I1, I2] : 'StrictProof }
   = try {'decompose_with_ [
           solve L cNameBound (I1), 
           solve L cNameBound (I2)] : 'StrictProof } .            
  eq analyse L proof {'restructure_[I1] : 'StrictProof} 
   = try {'restructure_[
      solve L protocol (I1) 
      ] : 'StrictProof} .       
  eq analyse L proof {'turn`neg`into`otherwise`for_[I1] : 'StrictProof} 
   = try {'turn`neg`into`otherwise`for_[
      solve L cNameBound (I1) 
      ] : 'StrictProof} .
  eq analyse L proof {'turn`otherwise`into`neg`for_[I1] : 'StrictProof} 
   = try {'turn`otherwise`into`neg`for_[
      solve L cNameBound (I1) 
      ] : 'StrictProof} .     
  eq analyse L proof {'combine_[I1] : 'StrictProof} 
   = try {'combine_[
      solve L cNameBound (I1) 
      ] : 'StrictProof} .
  eq analyse L proof {'combine_into`families[I1] : 'StrictProof} 
   = try {'combine_into`families[
      solve L cNameBound (I1) 
      ] : 'StrictProof} .    
  eq analyse L proof {'call_[I1] : 'StrictProof} 
   = try {'call_[
      check L sname (I1) 
      ] : 'StrictProof} .
  eq analyse L proof {'use`lemma_run[I1] : 'StrictProof} 
   = try {'use`lemma_run[
      check L sname (I1) 
      ] : 'StrictProof} .
  eq analyse L proof {'use`lemma_trust[I1] : 'StrictProof} 
   = try {'use`lemma_trust[
      check L sname (I1) 
      ] : 'StrictProof} .         
  eq analyse L proof {'ungroup_[I1] : 'StrictProof} 
   = try {'ungroup_[
      solve L cNameBound (I1) 
      ] : 'StrictProof} .  
  eq analyse L proof {'save`current`configuration.StrictProof : 'StrictProof}
   = return {'save`current`configuration.StrictProof : 'StrictProof} .          
  eq analyse L proof {'unsplit_[I1] : 'StrictProof} 
   = try {'unsplit_[
      solve L cNameIndex (I1) 
      ] : 'StrictProof} .    
  eq analyse L proof {'split_on`first`index [ I ] : 'StrictProof } 
   = try {'split_on`first`index [
      solve L cNameBound (I) 
      ] : 'StrictProof} .
  eq analyse L proof {'split_on`first`index`inside_ [ I1, I2 ] : 'StrictProof } 
   = try {'split_on`first`index`inside_ [
      solve L cNameBound (I1),
      solve L ruleTarget (I2) 
      ] : 'StrictProof} .    
  eq analyse L proof {'split_on`second`index [ I ] : 'StrictProof } 
   = try {'split_on`second`index [
      solve L cNameBound (I) 
      ] : 'StrictProof} .  
  eq analyse L proof {'merge`cases`for_[I1] : 'StrictProof} 
   = try {'merge`cases`for_[
      solve L cNameBound (I1) 
      ] : 'StrictProof} .     
  eq analyse L proof {'merge`case_=_with`otherwise`for_[I, I1, I2] : 'StrictProof}
   = try {'merge`case_=_with`otherwise`for_[
      solve L cNameIndex (I), 
      solve L natTerm (I1), 
      solve L cNameBound (I2)] : 'StrictProof} .               
  eq analyse L proof {'fold_into_[
      I1, I2
      ] : 'StrictProof} 
   = try {'fold_into_[
      solve L cNameBound (I1), 
      solve L cNameBound (I2)
      ] : 'StrictProof} .
  eq analyse L proof {'rename_in_[I1, I2] : 'StrictProof} 
   = try {'rename_in_[
      solve L qidPairList (I1), 
      solve L cNameBound (I2)
      ] : 'StrictProof} .    
  eq analyse L proof {'rename`variables_of_[I1, I2] : 'StrictProof} 
   = try {'rename`variables_of_[
      solve L qidPairList (I1), 
      solve L cNameBound (I2)
      ] : 'StrictProof} .        
  eq analyse L proof {'subst_into_[
      I1, I2
      ] : 'StrictProof} 
   = try {'subst_into_[
      solve L cNameBound (I1), 
      solve L cNameBound (I2) 
      ] : 'StrictProof} .  
  eq analyse L proof {'subst_into_at_[
      I1, I2, I3
      ] : 'StrictProof} 
   = try {'subst_into_at_[
      solve L cNameBound (I1), 
      solve L cNameBound (I2),
      solve L expression (I3) 
      ] : 'StrictProof} .      
  eq analyse L proof {'subst`branch_of_into_[
      I, I1, I2
      ] : 'StrictProof} 
   = try {'subst`branch_of_into_[
      solve L whenCond (I),
      solve L cNameBound (I1), 
      solve L cNameBound (I2) 
      ] : 'StrictProof} .
  eq analyse L proof {'subst`branch_of_into_at_[
      I, I1, I2, I3
      ] : 'StrictProof} 
   = try {'subst`branch_of_into_at_[
      solve L whenCond (I),
      solve L cNameBound (I1), 
      solve L cNameBound (I2),
      solve L expression (I3)
      ] : 'StrictProof} .          
  eq analyse L proof {'drop`read_from_[
      I1, I2
      ] : 'StrictProof} 
   = try {'drop`read_from_[
      solve L cNameBound (I1), 
      solve L cNameBound (I2) 
      ] : 'StrictProof} .  
  eq analyse L proof {'drop`read`branch_of_from_[
      I, I1, I2
      ] : 'StrictProof} 
   = try {'drop`read`branch_of_from_[
      solve L whenCond (I),
      solve L cNameBound (I1), 
      solve L cNameBound (I2) 
      ] : 'StrictProof} .          
  eq analyse L proof {'use`assumption_on_[I1, I2] : 'StrictProof}     
   = try {'use`assumption_on_[
       solve L aName (I1), *** should check that it has been declared
       solve L cNameBoundList (I2) *** should check that it is in the current protocol
      ] : 'StrictProof} .    
  eq analyse L proof {'use`expression`assumption_on_at_[I1, I2, I3] : 'StrictProof}     
   = try {'use`expression`assumption_on_at_[
       solve L aName (I1), *** should check that it has been declared
       solve L cNameBoundList (I2), *** should check that it is in the current protocol
       solve L natTerm (I3)
      ] : 'StrictProof} .       
  eq analyse L proof {'_then_[I1, I2] : 'StrictProof} 
   = try {'_then_[
           analyse L proof (I1),
           analyse L proof (I2)
      ] : 'StrictProof} .  
  eq analyse L proof {'sym`from_`(_`)[I1, I2] : 'StrictProof} 
   = try {'sym`from_`(_`)[
           solve L protocol (I1), 
           analyse L proof (I2)
      ] : 'StrictProof} .
  eq analyse L proof {'sym`from_over_`(_`)[I, I1, I2] : 'StrictProof} 
   = try {'sym`from_over_`(_`)[
           solve L protocol (I),
           check L delta (I1), 
           analyse L proof (I2)
      ] : 'StrictProof} .      
  eq analyse L proof {'move_on`each`branch`of_ [I1, I2] : 'StrictProof }
   = try {'move_on`each`branch`of_ [
          solve L ruleTarget (I1), 
          solve L ruleTarget (I2)] : 'StrictProof } .
  eq analyse L proof {'on`branch_of_`(_`) [I, I1, I2] : 'StrictProof }
   = try {'on`branch_of_`(_`)[
           solve L boolTerm (I), 
           solve L ruleTarget (I1),
           analyse L proof (I2)
      ] : 'StrictProof} .    
  eq analyse L proof {'todo.StrictProof : 'StrictProof} 
   = return {'todo.StrictProof : 'StrictProof} .
  eq analyse L proof {'idle.StrictProof : 'StrictProof} 
   = return {'idle.StrictProof : 'StrictProof} .
  eq analyse L proof {'bring`declarations`of`hidden`channels`in`front.StrictProof : 'StrictProof}
   = return {'bring`declarations`of`hidden`channels`in`front.StrictProof : 'StrictProof} .
  eq analyse L proof {'try`on`branch_of_:_done [I, I1, I2] : 'StrictProof }   
   = try {'try`on`branch_of_:_done [
          solve L boolTerm (I), 
          solve L ruleTarget (I1), 
          analyse L proof (I2)
      ] : 'StrictProof } .
  eq analyse L proof {'try`on`branch_of_:_ [I, I1, I2] : 'StrictProof }   
   = try {'try`on`branch_of_:_ [
          solve L boolTerm (I), 
          solve L ruleTarget (I1), 
          analyse L proof (I2)
      ] : 'StrictProof } .    
  eq analyse L proof {'try`sym`from_:_done[I1, I2] : 'StrictProof} 
   = try {'try`sym`from_:_done[
          solve L protocol (I1), 
          analyse L proof (I2)
      ] : 'StrictProof} .    
  eq analyse L proof {'try`sym`from_:_[I1, I2] : 'StrictProof} 
   = try {'try`sym`from_:_[
          solve L protocol (I1), 
          analyse L proof (I2)
      ] : 'StrictProof} .  
  eq analyse L proof {'try`sym`from_over_:_[I, I1, I3] : 'StrictProof} 
   = try {'try`sym`from_over_:_[
          solve L protocol (I),
          check L delta (I1),
          analyse L proof (I3)
      ] : 'StrictProof} .          
  eq analyse L proof 
   {'add`internal`family_indices:_bounds:_typed:_assigned:_ [I, I1, I2, CT, I3] : 'StrictProof}      
   = try {'add`internal`family_indices:_bounds:_typed:_assigned:_ [
        solve L cNameIndex (I), 
        solve L natTerms (I1), 
        solve L bounds (I2), 
        solve L preType (CT), 
        solve L cases (I3)] : 'StrictProof} . 
  eq analyse L proof 
   {'add`internal`channel_typed:_assigned:_ [I, CT, I3] : 'StrictProof}      
   = try {'add`internal`channel_typed:_assigned:_ [
        solve L cNameIndex (I), 
        solve L preType (CT), 
        solve L cases (I3)] : 'StrictProof} .       
  eq analyse L proof       
    {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5 ] : 'StrictProof}
   = try {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`)
      [
      solve L cNameBoundList (I), 
      solve L ruleTarget (I1), 
      solve L cases (I2), 
      solve L natTerm (I3), 
      solve L natTerm (I4), 
      analyse L proof (I5) ] : 'StrictProof} .
  eq analyse L proof       
    {'rewrite_to_by`induction`on_bound_`(_`) 
                [I1, I2, I3, I4, I5 ] : 'StrictProof}
   = try {'rewrite_to_by`induction`on_bound_`(_`)
      [
      solve L ruleTarget (I1), 
      solve L cases (I2), 
      solve L natTerm (I3), 
      solve L natTerm (I4), 
      analyse L proof (I5) ] : 'StrictProof} .    
  eq analyse L proof       
    {'try`in`the`presence`of_rewrite_to_by`induction`on_bound_:_
                [I, I1, I2, I3, I4, I5 ] : 'StrictProof}
   = try {'try`in`the`presence`of_rewrite_to_by`induction`on_bound_:_
      [
      solve L cNameBoundList (I), 
      solve L ruleTarget (I1), 
      solve L cases (I2), 
      solve L natTerm (I3), 
      solve L natTerm (I4), 
      analyse L proof (I5) ] : 'StrictProof} .
  eq analyse L proof       
    {'try`rewrite_to_by`induction`on_bound_:_
                [I1, I2, I3, I4, I5 ] : 'StrictProof}
   = try {'try`rewrite_to_by`induction`on_bound_:_
      [
      solve L ruleTarget (I1), 
      solve L cases (I2), 
      solve L natTerm (I3), 
      solve L natTerm (I4), 
      analyse L proof (I5) ] : 'StrictProof} .        
  eq analyse L proof {'case`distinction`on_`(_`) [I1, I2] : 'StrictProof }
   = try {'case`distinction`on_`(_`) [
        solve L ruleTarget (I1), 
        solve L proofCaseList (I2)
      ] : 'StrictProof } .
  eq analyse L proof {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'StrictProof}
   = try {'try`case`distinction`on_:`(case:_`) [
        solve L ruleTarget (I1), 
        analyse L proof (I2)
      ] : 'StrictProof } .  
  eq analyse L proof {'try`case`distinction`on_:`(case:_done`)`(case:_`) [I, I1, I2] : 'StrictProof}
   = try {'try`case`distinction`on_:`(case:_done`)`(case:_`) [
        solve L ruleTarget (I), 
        analyse L proof (I1),
        analyse L proof (I2)
      ] : 'StrictProof } .  
  eq analyse L proof {'diverge`on_with_var_ [I, I1, I2] : 'StrictProof} 
   = try  {'diverge`on_with_var_ [
          solve L cNameBound (I), 
          solve L cNameBound (I1), 
          solve L expression (I2)
      ] : 'StrictProof} 
   .   
   eq analyse L proof {'diverge`on_with`branch_of_var_ [I, I1, I2, I3] : 'StrictProof} 
   = try  {'diverge`on_with`branch_of_var_ [
          solve L cNameBound (I), 
          solve L boolTerm (I1),
          solve L cNameBound (I2), 
          solve L expression (I3)
      ] : 'StrictProof} 
   .   
  eq analyse L proof {'reverse`subst_in_using_ [I1, I2, I3] : 'StrictProof}
   = try {'reverse`subst_in_using_ [
           solve L cNameBound (I1),  
           solve L cNameBound (I2), 
           solve L cNameBound (I3) 
      ] : 'StrictProof} .  
  eq analyse L proof {'subst`or`diverge_into_var_ [I1, I2, I3] : 'StrictProof}
   = try {'subst`or`diverge_into_var_ [
           solve L cNameBound (I1),  
           solve L cNameBound (I2), 
           solve L expression (I3)
      ] : 'StrictProof} .
   eq analyse L proof {'on`reaction`of_`(_`) [I1, I2] : 'StrictProof}
   = try {'on`reaction`of_`(_`) [
           solve L cNameBound (I1), 
           analyse L reactionProof (I2)
      ] : 'StrictProof} .
   eq analyse L proof {'remove`only`branch`of_ [I] : 'StrictProof} 
    = try {'remove`only`branch`of_ [
          solve L cNameBound (I)
      ] : 'StrictProof} .
   eq analyse L proof {'on`all`branches`of_split_on`first`index [I1, I2] : 'StrictProof}
    = try {'on`all`branches`of_split_on`first`index [
             solve L cNameBound (I1), 
             solve L cNameBound (I2)
      ] : 'StrictProof} .
   eq analyse L proof {'on`all`branches`of_split_on`second`index [I1, I2] : 'StrictProof}
    = try {'on`all`branches`of_split_on`second`index [
             solve L cNameBound (I1), 
             solve L cNameBound (I2)
      ] : 'StrictProof} .   
   eq analyse L proof {'group_in_indices:_bounds:_[I, I1, I2, I3] : 'StrictProof} 
    = try {'group_in_indices:_bounds:_[
       solve L cNameBoundList (I), 
       solve L pname (I1), 
       solve L natTerms (I2), 
       solve L bounds (I3) ] : 'StrictProof}  . 
   eq analyse L proof {'using_`(_`) [I1, I2] : 'StrictProof}
    = try {'using_`(_`) [
            solve L ruleTarget (I1), 
            analyse L proof (I2)] : 'StrictProof} .
   eq analyse L proof {'using`branch_of_`(_`) [I, I1, I2] : 'StrictProof}
    = try {'using`branch_of_`(_`) [
            solve L whenCond (I), 
            solve L ruleTarget (I1), 
            analyse L proof (I2)] : 'StrictProof} . 
   eq analyse L proof {'sym`var_terms_diverge_into_var_ [I, I1, I2, I3, I4] : 'StrictProof} 
    = try {'sym`var_terms_diverge_into_var_ [
            solve L expression (I), 
            solve L natTerms (I1), 
            solve L cNameBound (I2), 
            solve L cNameBound (I3), 
            solve L expression (I4)] : 'StrictProof}  . 
   eq analyse L proof {'split_inside_[I1, I2] : 'StrictProof}
    = try {'split_inside_[
           solve L cNameBound (I1), 
           solve L ruleTarget (I2)] : 'StrictProof} .
   eq analyse L proof {'unsplit_and_[I1, I2] : 'StrictProof}
    = try {'unsplit_and_[
            solve L cNameBound (I1), 
            solve L cNameBound (I2)] : 'StrictProof} .
   eq analyse L proof {'unsplit_and_inside_[I1, I2, I3] : 'StrictProof}
    = try {'unsplit_and_inside_[
            solve L cNameBound (I1), 
            solve L cNameBound (I2),
            solve L ruleTarget (I3)] : 'StrictProof} .
   eq analyse L proof {'unit-ext`on_at_[I1, I2] : 'StrictProof} 
    = try {'unit-ext`on_at_[
            solve L cNameBound (I1), 
            solve L natTerm(I2)] : 'StrictProof} .
   eq analyse L proof {'rename`indices`to_in_[I1, I2] : 'StrictProof}
    = try {'rename`indices`to_in_[
            solve L natTerms (I1), 
            solve L cNameBound (I2) ] : 'StrictProof} .
   eq analyse L proof {'remove_from_[I1, I2] : 'StrictProof} 
   = try {'remove_from_[
            solve L cNameBound (I1),
            solve L ruleTarget (I2) ] : 'StrictProof} .
   eq analyse L proof {'change`name_to_[I1, I2] : 'StrictProof}
    = try {'change`name_to_[
            solve L cNameBound (I1), 
            solve L cNameIndex (I2)] : 'StrictProof} .
   eq analyse L proof {'focus_`(_`)[I1, I2] : 'StrictProof} 
    = try {'focus_`(_`)[
            solve L cNameBoundList (I1), 
            analyse L proof (I2)] : 'StrictProof} .
   eq analyse L proof {'remove`and`merge_from_ [I1, I2] : 'StrictProof}  
    = try {'remove`and`merge_from_ [
            solve L cNameBound (I1), 
            solve L ruleTarget (I2)] : 'StrictProof} .
   eq analyse L proof {'use`assumptions`for_in_ [I1, I2] : 'StrictProof} 
    = try {'use`assumptions`for_in_ [
          solve L expression (I1), 
          solve L cNameBound(I2)] : 'StrictProof} . 
   eq analyse L proof {'merge`case`for_and_into`group_ [I1, I2, I3] : 'StrictProof} 
    = try {'merge`case`for_and_into`group_ [
           solve L cNameBound (I1), 
           solve L cNameBound (I2), 
           solve L cNameIndex (I3)] : 'StrictProof} .  
   eq analyse L proof {'extract_from_into`group_ [I1, I2, I3] : 'StrictProof}
   = try {'extract_from_into`group_ [
          solve L cNameBoundList (I1), 
          solve L ruleTarget (I2), 
          solve L cNameIndex (I3)] : 'StrictProof} .   
   eq analyse L proof {'discard`branch_of_ [I1, I2] : 'StrictProof}
   = try {'discard`branch_of_ [
         solve L boolTerm (I1),
         solve L cNameBound (I2)
      ] : 'StrictProof} . 
   eq analyse L proof {'fix`index`for_ [I] : 'StrictProof}
   = try {'fix`index`for_ [
         solve L cNameBound (I)
      ] : 'StrictProof} .          
                            
                        


  op analyse_reactionProof : IPDL -> AnalysisAction{IPDL} .
  eq analyse L reactionProof {'idle.ReactionProof : 'ReactionProof} 
   = return {'idle.ReactionProof : 'ReactionProof} .  
  eq analyse L reactionProof {'_then_[I1, I2] : 'ReactionProof} 
   = try {'_then_[
           analyse L reactionProof (I1),
           analyse L reactionProof (I2)
      ] : 'ReactionProof} .        
  eq analyse L reactionProof {'if-ext`on_ [I] : 'ReactionProof}
   = try {'if-ext`on_ [
            solve L expression (I)
      ] : 'ReactionProof} .

     
  op solve_ruleTarget : IPDL -> AnalysisAction{IPDL} .
  eq solve L ruleTarget {'channel_ [ I ] : 'RuleTarget }
   = try {'channel_ [ solve L cNameIndex I ] : 'RuleTarget } .
  eq solve L ruleTarget {'family_ [ I ] : 'RuleTarget }
   = try {'family_ [ solve L familyName I ] : 'RuleTarget } .
  eq solve L ruleTarget {'group_ [ I ] : 'RuleTarget }
   = try {'group_ [ solve L familyName I ] : 'RuleTarget } .  

  op solve_proofCase : IPDL -> AnalysisAction{IPDL} .
  eq solve L proofCase {'case:`(_`) [ I ] : 'ProofCase }
   = try {'case:`(_`) [ 
      analyse L proof (I) 
      ] : 'ProofCase } .

  op solve_proofCaseList : IPDL -> AnalysisAction{IPDL} .
  eq solve L proofCaseList {'__ [I1, I2] : 'ProofCaseList}
   = try {'__ [ 
       solve L proofCaseList (I1), 
       solve L proofCaseList (I2)
      ] : 'ProofCaseList} .
  ceq solve L proofCaseList I = 
      solve L proofCase I 
  if I :: 'ProofCase .        

  op check_assumVars : IPDL -> AnalysisAction{IPDL} .
   eq check L assumVars {'qlist[I] : 'QList}
   = return {'qlist[I] : 'QList} .
   eq check L assumVars  {'nil.QList : 'QList}
   = return  {'nil.QList : 'QList} .

  op check_delta : IPDL -> AnalysisAction{IPDL} .
  eq check L delta {'emptyCCtxt.ChnCtxt : 'ChnCtxt} = 
     return {'emptyCCtxt.ChnCtxt : 'ChnCtxt} .
  eq check L delta {'savedDelta.ChnCtxt : 'ChnCtxt} = 
     return {'savedDelta.ChnCtxt : 'ChnCtxt} .   
  eq check L delta {'`(_::_`)[I, T] : 'TypedChn} =
     try {'`(_::_`)[
           solve L cNameBound (I),
           solve L preType (T) then  
           check L preType
      ] : 'TypedChn} .
  eq check L delta {'__[I1, I2] : 'ChnCtxt} = 
     try {'__[
           check L delta (I1), 
           check L delta (I2)
      ] : 'ChnCtxt} .
  ceq check L delta I = 
    solve L dName I
   if I :: 'DName .
         

  op check_gamma : IPDL -> AnalysisAction{IPDL} .
  eq check L gamma {'emptyTCtxt.TypeCtxt : 'TypeCtxt} = 
     return {'emptyTCtxt.TypeCtxt : 'TypeCtxt} .
  eq check L gamma {'_:_[I, T] : 'TypedVar} =
     try {'_:_[
           check L varName (I), 
           solve L preType (T) then  
           check L preType 
      ] : 'TypedVar} .
  eq check L gamma {'__[I1, I2] : 'TypeCtxt} = 
     try {'__[
           check L gamma (I1), 
           check L gamma (I2)
      ] : 'TypeCtxt} .

  op check_inputs : IPDL -> AnalysisAction{IPDL} .
  eq check L inputs {'nil.QList : 'QList} 
   = return {'nil.QList : 'QList} .
  eq check L inputs {'qlist[I] : 'QList}
   = return {I : 'QList} . 


  

  *** Protocols are checked in three steps 
  *** 1. solve L protocol eliminates all token constructors
  *** 2. check L protocol checks identifiers
  *** 3. type check L protocol performs the type checking

  *** 1. elimination of token constructors

  op solve_qidPairList : IPDL -> AnalysisAction{IPDL} .
  ceq solve L qidPairList I =
      solve L qidPair I
   if I :: 'QidPair . 
   eq solve L qidPairList {'_`,_[I1, I2] : 'QidPairList}
   = try {'_`,_[
       solve L qidPairList (I1), 
       solve L qidPairList (I2)
      ] : 'QidPairList} .  

  op solve_qidPair : IPDL -> AnalysisAction{IPDL} .
  eq solve L qidPair {'_to_[ I1, I2] : 'QidPair}
   = try {'_to_[ 
        solve L vName (I1),  
        solve L vName (I2) ] : 'QidPair} . 

  op solve_paramName : IPDL -> AnalysisAction{IPDL} .
  eq solve L paramName {'paramName[I] : 'ParamName} 
   = return {I : 'ParamName} .

  op solve_cNameBound : IPDL -> AnalysisAction{IPDL} .
  eq solve L cNameBound {'fam_[I] : 'CNameBound} 
   = try {'fam_[solve L familyName (I)] : 'CNameBound} .
  eq solve L cNameBound {'chn_[I] : 'CNameBound} 
   = try {'chn_[solve L cNameIndex (I)] : 'CNameBound} . 

  op solve_cNameBoundList : IPDL  -> AnalysisAction{IPDL} .
  ceq solve L cNameBoundList I 
    =  solve L cNameBound I
   if I :: 'CNameBound .
  eq solve L cNameBoundList {'_`,_[I1, I2] : 'CNameBoundList}
   = try {'_`,_[
       solve L cNameBoundList (I1), 
       solve L cNameBoundList (I2)
      ] : 'CNameBoundList} . 
  eq solve L cNameBoundList {'no`inputs.CNameBoundList : 'CNameBoundList}
   = return {'no`inputs.CNameBoundList : 'CNameBoundList}  .
  eq solve L cNameBoundList {'savedOuts.CNameBoundList : 'CNameBoundList}
    = return {'savedOuts.CNameBoundList : 'CNameBoundList}  .
 


  op solve_cNameIndex : IPDL -> AnalysisAction{IPDL} .
  eq solve L cNameIndex {'cname[I] : 'CName} 
   = return {I : 'CName} .
  eq solve L cNameIndex {'_`[_`][ I1, I2] : 'CNameIndex} 
   = try {'_`[_`][ 
        adjust L cName (I1),
        solve L natTerms (I2)
      ] : 'CNameIndex} .

  op solve_natTerm : IPDL -> AnalysisAction{IPDL} .
  eq solve L natTerm {'nid[I] : 'NId}
   = check rat(string(read-qid(I)), 10) :: Nat
     and-then return {I : 'Nat}
     or-else return {I : 'CId} .
  eq solve L natTerm  {'`(_`) [I] : 'NatTerm}    
   = try {'`(_`) [solve L natTerm I] : 'NatTerm} .   
  eq solve L natTerm {'_+_[I1, I2] : 'NatTerm}
   = try {'_+_[solve L natTerm (I1), solve L natTerm (I2)] : 'NatTerm} .
  eq solve L natTerm {'_-_[I1, I2] : 'NatTerm}
   = try {'_-_[solve L natTerm (I1),solve L natTerm (I2)] : 'NatTerm} .
  eq solve L natTerm {'_*_[I1, I2] : 'NatTerm}
   = try {'_*_[solve L natTerm (I1),solve L natTerm (I2)] : 'NatTerm} .
  eq solve L natTerm {'_`(_`)[I1, I2] : 'NatTerm}
   = try {'_`(_`)[solve L fName (I1),solve L natTerm (I2)] : 'NatTerm} .

  op solve_natTerms : IPDL -> AnalysisAction{IPDL} . 
  eq solve L natTerms {I : 'NId}
   = solve L natTerm {I : 'NId} .
  eq solve L natTerms {I : 'NatTerm}
   = solve L natTerm {I : 'NatTerm} .
***   eq solve L natTerms {'qlist[I] : 'QList} 
***    = solve L natTerms {I : 'NatTerm} . 
  eq solve L natTerms {'_`,_[I1, I2] : 'NatTermList}
   = try {'_`,_[
       solve L natTerms (I1), 
       solve L natTerms (I2)
      ] : 'NatTermList} .

  op solve_boolTerms : IPDL -> AnalysisAction{IPDL} .
  ceq solve L boolTerms I 
   = solve L boolTerm I 
   if I :: 'BoolTerm .
   eq solve L boolTerms {'no`assumptions.BoolTermList : 'BoolTermList}
    = return {'no`assumptions.BoolTermList : 'BoolTermList} .
   eq solve L boolTerms {'_`,_[I1, I2] : 'BoolTermList} 
    = try {'_`,_[
        solve L boolTerms (I1), 
        solve L boolTerms (I2)] : 'BoolTermList} .

  op solve_boolTerm :  IPDL -> AnalysisAction{IPDL} .
  eq solve L boolTerm {'falseBT.BoolTerm : 'BoolTerm} = 
     return {'falseBT.BoolTerm : 'BoolTerm} .
  eq solve L boolTerm {'trueBT.BoolTerm : 'BoolTerm} = 
     return {'trueBT.BoolTerm : 'BoolTerm} . 
  eq solve L boolTerm {'_=_[I1, I2] : 'BoolTerm} =   
     try {'_=_ [
        solve L natTerm (I1),
        solve L natTerm (I2)
      ] : 'BoolTerm} .   
  eq solve L boolTerm {'_<_[I1, I2] : 'BoolTerm} =   
     try {'_<_ [
        solve L natTerm (I1),
        solve L natTerm (I2)
      ] : 'BoolTerm} .    
  eq solve L boolTerm {'_<=_[I1, I2] : 'BoolTerm} =   
     try {'_<=_ [
        solve L natTerm (I1),
        solve L natTerm (I2)
      ] : 'BoolTerm} .    
  eq solve L boolTerm {'_and_[I1, I2] : 'BoolTerm} =   
     try {'_and_ [
        solve L boolTerm (I1),
        solve L boolTerm (I2)
      ] : 'BoolTerm} .
  eq solve L boolTerm {'_or_[I1, I2] : 'BoolTerm} =   
     try {'_or_ [
        solve L boolTerm (I1),
        solve L boolTerm (I2)
      ] : 'BoolTerm} . 
  eq solve L boolTerm {'not_[I1] : 'BoolTerm} =   
     try {'not_ [
        solve L boolTerm (I1)
      ] : 'BoolTerm} .         
  eq solve L boolTerm  {'_`(_`)[I1, I2] : 'BoolTerm} =
   try {'_`(_`)[
       solve L predName (I1), 
       solve L natTerm (I2)
    ] : 'BoolTerm} .

  op solve_predName : IPDL -> AnalysisAction{IPDL} .
  eq solve L predName {'predId[I] : 'PredName} 
   = return {I : 'PredName} .

  op solve_basicFamilyName : IPDL -> AnalysisAction{IPDL} .
  eq solve L basicFamilyName {'_`[_`][I1, I2] : 'BasicFamilyName} 
   = try {'_`[_`][
       adjust L cName (I1), 
       solve L bounds (I2)
      ] : 'BasicFamilyName} . 

  op solve_familyName : IPDL -> AnalysisAction{IPDL} .
  ceq solve L familyName I = 
    solve L basicFamilyName (I)
   if I :: 'BasicFamilyName . 
  eq solve L familyName {'_and_[I1, I2] : 'FamilyName} = 
   try {'_and_[
        solve L basicFamilyName (I1), 
        solve L basicFamilyName (I2)
      ] : 'FamilyName}
  . 

  op solve_boundedIndex : IPDL -> AnalysisAction{IPDL} .
  eq solve L boundedIndex {'_<_[I1, I2] : 'BoundedIndex} 
   = try {'_<_[
      solve L vName (I1), 
      solve L natTerm (I2)
   ] : 'BoundedIndex} .
  eq solve L boundedIndex {'_=_[I1, I2] : 'BoundedIndex} 
   = try {'_=_[
      solve L vName (I1), 
      solve L natTerm (I2)
   ] : 'BoundedIndex} .

  op solve_boundedIndices : IPDL -> AnalysisAction{IPDL} .
  ceq solve L boundedIndices I 
    = solve L boundedIndex I 
   if I :: 'BoundedIndex .
   eq solve L boundedIndices {'_`,_[I1, I2] : 'BoundedIndexList}
   = try {'_`,_[
       solve L boundedIndices (I1), 
       solve L boundedIndices (I2)
      ] : 'BoundedIndexList} .  
  
  op solve_basicFamilyNameBound : IPDL -> AnalysisAction{IPDL} .
  eq solve L basicFamilyNameBound {'_`[_`][I1, I2] : 'BasicFamilyNameBound} 
   = try {'_`[_`][
       adjust L cName (I1), 
       solve L boundedIndices (I2)
      ] : 'BasicFamilyNameBound} . 

  op solve_familyNameBound : IPDL -> AnalysisAction{IPDL} .
  ceq solve L familyNameBound I = 
    solve L basicFamilyNameBound (I)
   if I :: 'BasicFamilyNameBound . 
  eq solve L familyNameBound {'_and_[I1, I2] : 'FamilyNameBound} = 
   try {'_and_[
        solve L basicFamilyNameBound (I1), 
        solve L basicFamilyNameBound (I2)
      ] : 'FamilyNameBound}
  . 


  op solve_bound : IPDL -> AnalysisAction{IPDL} .  
  eq solve L bound {'bound_[I] : 'Bound}
   = try {'bound_[
       solve L natTerm (I)]
       : 'Bound} .
  eq solve L bound {'fixedBound_[I] : 'Bound}
   = try {'fixedBound_[
       solve L natTerm (I)]
       : 'Bound} .
  eq solve L bound {'dependentBound_[I] : 'Bound}
   = try {'dependentBound_[
       solve L fName (I)]
       : 'Bound} .          

  op solve_bounds : IPDL -> AnalysisAction{IPDL} .
  ceq solve L bounds I
   = solve L bound I 
  if I :: 'Bound .
  eq solve L bounds {'__[I1, I2] : 'BoundList}
   = try {'__[
       solve L bounds (I1), 
       solve L bounds (I2)
      ] : 'BoundList} .

  op solve_whenCond : IPDL -> AnalysisAction{IPDL} .
  eq solve L whenCond {'otherwise.WhenCond : 'WhenCond} 
   = return {'otherwise.WhenCond : 'WhenCond} .
  eq solve L whenCond {'when_[I] : 'WhenCond}
   = try {'when_[
       solve L boolTerm (I)]
       : 'WhenCond} .

  op solve_when : IPDL -> AnalysisAction{IPDL} .
  eq solve L when {'_-->_[I1, I2] : 'When}
   = try {'_-->_[
       solve L whenCond (I1), 
       solve L cases (I2)
      ] : 'When} .

  op solve_whenList : IPDL -> AnalysisAction{IPDL} .
  eq solve L whenList {'emptyWhen.WhenList : 'WhenList} 
   = return {'emptyWhen.WhenList : 'WhenList} .
  eq solve L whenList {'`(_`) [I] : 'WhenList} 
   = try {'`(_`) [solve L whenList I] : 'WhenList} . 
  ceq solve L whenList I
   = solve L when I if I :: 'When  . 
  eq solve L whenList {'_;;_[I1, I2] : 'WhenList}
   = try {'_;;_[
       solve L whenList (I1), 
       solve L whenList (I2)
      ] : 'WhenList} . 

  op solve_cases : IPDL -> AnalysisAction{IPDL} . 
  ceq solve L cases I 
   = solve L reaction I if I :: 'IPDLReaction . 
  ceq solve L cases I
    = solve L protocol I if I :: 'IPDLProtocol .
  ceq solve L cases I 
   = solve L whenList I if I :: 'WhenList .  
  ceq solve L cases I 
   = solve L when I if I :: 'When .  

  op solve_localDecls : IPDL -> AnalysisAction{IPDL} .
  ceq solve L localDecls I = solve L localDecl I 
   if I :: 'LocalDecl .
  eq solve L localDecls {'_and_[I1, I2] : 'LocalDeclList} 
   = try {'_and_[
       solve L localDecls (I1), 
       solve L localDecls (I2)
      ] : 'LocalDeclList} .  

  op solve_localDecl : IPDL -> AnalysisAction{IPDL} .
  eq solve L localDecl {'_=_[I1, I2] : 'LocalDecl} 
   = try {'_=_[
           solve L pname (I1), 
           solve L protocol (I2)] : 'LocalDecl} .

  op solve_pname : IPDL ->  AnalysisAction{IPDL} .          
  eq solve L pname {'pname[I] : 'PName} = 
     return {I : 'PName} .

  op solve_protocol : IPDL ->  AnalysisAction{IPDL} .
  eq solve L protocol {'emptyProtocol.IPDLProtocol : 'IPDLProtocol} = 
     return {'emptyProtocol.IPDLProtocol : 'IPDLProtocol} .
  eq solve L protocol {'currentProtocol.IPDLProtocol : 'IPDLProtocol} = 
     return {'currentProtocol.IPDLProtocol : 'IPDLProtocol} .
   eq solve L protocol {'savedProtocol.IPDLProtocol : 'IPDLProtocol} = 
     return {'savedProtocol.IPDLProtocol : 'IPDLProtocol} .      
  eq solve L protocol {'`(_`) [I] : 'IPDLProtocol} =
     try {'`(_`) [solve L protocol I] : 'IPDLProtocol}  .
  eq solve L protocol {'pname[I] : 'PName} = 
     return {I : 'PName} .
  eq solve L protocol {'_where_[I1, I2] : 'IPDLProtocol} =      
     try {'_where_[
        solve L protocol (I1), 
        solve L localDecls (I2)
      ] : 'IPDLProtocol} .
  eq solve L protocol {'_::=_[I1, I2] : 'IPDLProtocol} =   
     try {'_::=_ [
        solve L cNameIndex (I1),
        solve L cases (I2)
      ] : 'IPDLProtocol} .
  eq solve L protocol {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} =   
     try {'family_indices:_bounds:_::=_ [
        solve L familyName (I),
        solve L natTerms (I1),
        solve L bounds (I2),
        solve L cases (I3)
      ] : 'IPDLProtocol} .    
  eq solve L protocol {'_||_[I1, I2] : 'IPDLProtocol} = 
     try {'_||_ [
        solve L protocol (I1),
        solve L protocol (I2)
      ] : 'IPDLProtocol} .      
  eq solve L protocol {'new_:_in_[I, I1, I2] : 'IPDLProtocol} =
     try   {'new_:_in_ [  
       solve L cNameIndex (I),
       solve L preType (I1),
       solve L protocol (I2)
      ] : 'IPDLProtocol} . 
  eq solve L protocol {'newfamily_indices:_bounds:_:_in_[I, I1, I2, T, I3]  : 'IPDLProtocol} =
     try   {'newfamily_indices:_bounds:_:_in_ [  
       solve L familyName (I),
        solve L natTerms (I1),
        solve L bounds (I2),
       solve L preType (T),
       solve L protocol (I3)
      ] : 'IPDLProtocol} .
  eq solve L protocol {'change_with_in_ [I, I1, I2] : 'IPDLProtocol } 
   = try {'change_with_in_ [
           solve L cNameBound (I), 
           solve L cases (I1), 
           solve L protocol (I2)
     ] : 'IPDLProtocol } .
  eq solve L protocol {'branch_of_change_with_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol } 
   = try {'branch_of_change_with_in_ [
           solve L whenCond (I), 
           solve L cNameBound (I1),
           solve L cNameBound (I2),
           solve L cases (I3), 
           solve L protocol (I4)
     ] : 'IPDLProtocol } . 
  eq solve L protocol {'gather_from_hiding_ [ I1, I2, I3 ] : 'IPDLProtocol }
   = try {'gather_from_hiding_ [ 
          solve L cNameBoundList (I1), 
          solve L protocol (I2),
          solve L cNameBoundList (I3) ] : 'IPDLProtocol } .
  eq solve L protocol {'embed`(_`,_`)[ I1, I2 ] : 'IPDLProtocol} 
   = try {'embed`(_`,_`)[ 
           solve L protocol (I1), 
           solve L embName (I2) 
      ] : 'IPDLProtocol} .
  eq solve L protocol {'extend_with`internal`channel_typed:_assigned:_ [ I, I1, T, I2 ] : 'IPDLProtocol }
   = try {'extend_with`internal`channel_typed:_assigned:_ [
           solve L protocol (I),
           solve L cNameIndex (I1), 
           solve L preType (T),
           solve L cases (I2)
     ] : 'IPDLProtocol } .   
  eq solve L protocol 
   {'extend_with`internal`family_indices:_bounds:_typed:_assigned:_ [ I, I1, I2, I3, T, I4 ] : 'IPDLProtocol }
   = try {'extend_with`internal`family_indices:_bounds:_typed:_assigned:_ [ 
           solve L protocol (I),
           adjust L cName (I1), 
           solve L natTerms (I2), 
           solve L bounds (I3), 
           solve L preType (T),
           solve L cases (I4)
      ] : 'IPDLProtocol } .   
  eq solve L protocol {'create`group_indices:_bounds:_from_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol}
   = try {'create`group_indices:_bounds:_from_in_ [ 
      solve L pname (I), 
      solve L natTerms (I1), 
      solve L bounds (I2), 
      solve L cNameBoundList (I3), 
      solve L protocol (I4)] : 'IPDLProtocol} .  

  eq solve L protocol {'newNF`(_`,_`) [I1, I2] : 'IPDLProtocol} 
   = try  {'newNF`(_`,_`) [
            solve L typedCNameList (I1), 
            solve L protocol (I2)] : 'IPDLProtocol} .    

   op solve_typedCNameList : IPDL -> AnalysisAction{IPDL} .
   ceq solve  L typedCNameList I =
       solve L typedCName I
    if I :: 'TypedCName .
    eq solve L typedCNameList {'__[I1, I2] : 'TypedCNameList}
     = try {'__[
        solve L typedCNameList (I1), 
        solve L typedCNameList (I2)] : 'TypedCNameList}  .

   op solve_typedCName : IPDL -> AnalysisAction{IPDL} .
   eq solve L typedCName {'`{__:_`}[I1, I2, T] : 'TypedCName}
    = try {'`{__:_`}[
            adjust L cName (I1), 
            solve L cNameBoundList (I2), 
            solve L preType (T)] : 'TypedCName} .
   eq solve L typedCName {'<_:_>[I1, T] : 'TypedCName }
    = try {'<_:_>[
         adjust L cName (I1), 
         solve L preType (T)] : 'TypedCName } .         


  op solve_reaction : IPDL -> AnalysisAction{IPDL} .
  eq solve L reaction  {'`(_`)[I] : 'IPDLReaction} =
     try {'`(_`)[
        solve L reaction (I)
      ] : 'IPDLReaction} .
  eq solve L reaction  {'return_[I] : 'IPDLReaction} =
     try {'return_ [
        solve L expression (I)
      ] : 'IPDLReaction} .
  eq solve L reaction  {'read_[I] : 'IPDLReaction} =
     try {'read_ [
        solve L cNameIndex (I)
      ] : 'IPDLReaction} .
  eq solve L reaction  {'read[I] : 'IPDLReaction} =
     try {'read [
        solve L cNameIndex (I)
      ] : 'IPDLReaction} .        
  eq solve L reaction {'if_then_else_[I, I1, I2] : 'IPDLReaction} =
     try {'if_then_else_ [
          solve L expression (I), 
          solve L reaction (I1), 
          solve L reaction (I2)
      ] : 'IPDLReaction} . 
  eq solve L reaction {'_:_<-_;_[I, T, I1, I2] : 'IPDLReaction} =
     try {'_:_<-_;_ [
          solve L vName (I), 
          solve L preType (T), 
          solve L reaction (I1), 
          solve L reaction (I2)
      ] : 'IPDLReaction} .
  eq solve L reaction {'samp_`(_`)[I1, I2] : 'IPDLReaction} =
     try {'samp_`(_`)[
           solve L dName (I1),
           solve L expression (I2) 
      ] : 'IPDLReaction} .
  eq solve L reaction {'nf`(_`,_`)[I1, I2] : 'IPDLReaction} =
     try {'nf`(_`,_`)[
           solve L bind-read-list (I1),
           solve L reaction (I2)
      ] : 'IPDLReaction} .    
  eq solve L reaction {'preNF`(_`,_`)[I1, I2] : 'IPDLReaction} =
     try {'preNF`(_`,_`)[
           solve L bind-list (I1),
           solve L reaction (I2)
      ] : 'IPDLReaction} .   

  op solve_expression : IPDL -> AnalysisAction{IPDL} .  
          
  eq solve L expression {'True.IPDLExpr : 'IPDLExpr} =
     return {'True.IPDLExpr : 'IPDLExpr} .
  eq solve L expression {'False.IPDLExpr : 'IPDLExpr} =
     return {'False.IPDLExpr : 'IPDLExpr} .
  eq solve L expression {'`(`).IPDLExpr : 'IPDLExpr} =
     return {'`(`).IPDLExpr : 'IPDLExpr} .
  eq solve L expression {'vid[I] : 'VId} =
     return {I : 'VId} .
  eq solve L expression {'fst_[I] : 'IPDLExpr} =
     try {'fst_ [ 
          solve L expression (I)
      ] : 'IPDLExpr} .
  eq solve L expression {'snd_[I] : 'IPDLExpr} =
     try {'snd_ [ 
          solve L expression (I)
      ] : 'IPDLExpr} .
  eq solve L expression {'`(_`,_`)[I1, I2] : 'IPDLExpr} =
     try {'`(_`,_`)[
          solve L expression (I1), 
          solve L expression (I2)
      ] : 'IPDLExpr} .
  eq solve L expression {'_`(_`)[I1, I2] : 'IPDLExpr} 
     = 
     try {'_`(_`)[
         solve L fName (I1), 
         solve L expression (I2) 
      ] : 'IPDLExpr} .
  
  op solve_fName : IPDL -> AnalysisAction{IPDL} .
  eq solve L fName {'fname[I] : 'FName} 
   = return {I : 'FName} .
   
  op solve_dName : IPDL -> AnalysisAction{IPDL} .
  eq solve L dName {'dname[I] : 'DName} 
   = return {I : 'DName} .

  op solve_vName : IPDL -> AnalysisAction{IPDL} . 
  eq solve L vName {'vid[I] : 'VId} 
   = return {I : 'VId} .   

  op solve_bind-read-list : IPDL -> AnalysisAction{IPDL} .  
 
  eq solve L bind-read-list {'nil.BindList : 'BindList} =
     return {'nil.BindList : 'BindList} .
  eq solve L bind-read-list {'_:_<-`read_[I, I1, I2] : 'BindReaction} =
     try {'_:_<-`read_[
          solve L vName (I),
          solve L preType (I1), 
          solve L cNameIndex (I2)
      ]: 'BindReaction} .
  eq solve L bind-read-list {'__[I1, I2] : 'BindList} =   
     try {'__[
        solve L bind-read-list (I1), 
        solve L bind-read-list (I2)
      ] : 'BindList} .  

  op solve_bind-list : IPDL -> AnalysisAction{IPDL} . 
 
  eq solve L bind-list {'nil.BindList : 'BindList} =
     return {'nil.BindList : 'BindList} .
  eq solve L bind-list {'_:_<~_[I, I1, I2] : 'BindReaction} =
     try {'_:_<~_[
          solve L vName (I), 
          solve L preType (I1), 
          solve L reaction (I2)
      ]: 'BindReaction} .
  eq solve L bind-list {'_:_<-`read_[I, I1, I2] : 'BindReaction} =
     try {'_:_<-`read_[
          solve L vName (I),
          solve L preType (I1), 
          solve L cNameIndex (I2)
      ]: 'BindReaction} .       
  eq solve L bind-list {'__[I1, I2] : 'BindList} =   
     try {'__[
        solve L bind-list (I1), 
        solve L bind-list (I2)
      ] : 'BindList} .
    

  op solve_preType : IPDL -> AnalysisAction{IPDL} .
  eq solve L preType {'`(_`) [I] : 'IPDLPreType}
   = try  {'`(_`) [solve L preType (I)] : 'IPDLPreType} . 
  eq solve L preType {'_*_[I1, I2] : 'IPDLPreType}
   = try {'_*_[solve L preType (I1), solve L preType (I2)] : 'IPDLPreType} .
  eq solve L preType {'tid[I] : 'TId} 
   = return {I : 'TId} .

  var PCL1 : List{ApproxEqConfig} .

  *** 2. check identifiers
  op check_localDecl : IPDL -> AnalysisAction{IPDL} .
  ceq check L localDecl {'_=_[I1, I2] : 'LocalDecl} 
      in env  
   = (check (not $hasMapping(protMap, read-qid(I1)))
     or-else fail('protocol 'already 'declared, (at term I1, include context))
     )
     and-then 
      try {'_=_[ 
         return I1, 
         check L protocol (I2)] : 'LocalDecl}     
     in env
  if protMap := getPMap env .     

  op check_localDecls : IPDL -> AnalysisAction{IPDL} .
  ceq check L localDecls I =
      check L localDecl I 
   if I :: 'LocalDecl .
  eq check L localDecls {'_and_[I1, I2] : 'LocalDeclList} = 
     try {'_and_ [
        check L localDecls (I1),
        check L localDecls (I2)
      ] : 'LocalDeclList} . 

  var countb contextb : ComplexityBound .    

  op check_protocol : IPDL -> AnalysisAction{IPDL} .
  eq check L protocol {'emptyProtocol.IPDLProtocol : 'IPDLProtocol} = 
     return {'emptyProtocol.IPDLProtocol : 'IPDLProtocol} .
  eq check L protocol {'currentProtocol.IPDLProtocol : 'IPDLProtocol} = 
     return {'currentProtocol.IPDLProtocol : 'IPDLProtocol} .   
  eq check L protocol {'savedProtocol.IPDLProtocol : 'IPDLProtocol} = 
     return {'savedProtocol.IPDLProtocol : 'IPDLProtocol} .     
  eq check L protocol   {'`(_`) [I] : 'IPDLProtocol}
   = try  {'`(_`) [check L protocol (I)] : 'IPDLProtocol} .
  ceq check L protocol {'_where_[I1, I2] : 'IPDLProtocol} in env =     
      try {'_where_[
         check L protocol (I1) 
           in (setPMap env (read-localDecls(L, env, I2), protMap)),
         check L localDecls (I2)    
         in env
      ] : 'IPDLProtocol
      }
   if protMap := getPMap env    
  .    
  eq check L protocol {I : 'PName} in env = 
    check ($hasMapping(getPMap env, read-qid(I)))
    and-then return {I : 'PName}
    or-else fail('unknown 'protocol, (at term I, include context))
    in env .   
  eq check L protocol {'_::=_[I1, I2] : 'IPDLProtocol} = 
     try {'_::=_ [
        check L emptyTypeContext declaredCNameIndex (I1),
        check L emptyTypeContext cases (I2)
      ] : 'IPDLProtocol} . 
  ceq check L protocol {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} 
      in env =   
     try {'family_indices:_bounds:_::=_ [
        check L familyName (I) in env,
        return I1 in env, *** check L emptyTypeContext natTerms (I1),
        check L emptyTypeContext bounds (I2) in env ,
        check L (indicesToTypeContext read-natTerms(L,I1)) cases (I3)
        in (pushAConfig (popAConfig env)
            (aConfig(pConfig(Sigma, Delta, P, (Ins, fam (read-familyName(L, I)) ), Outs, A), 
            countb, contextb) ) 
           )
      ] : 'IPDLProtocol} 
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .         
  ceq check L protocol {'_||_[I1, I2] : 'IPDLProtocol} in env = 
     try {'_||_ [
        check L protocol (I1)
        in (pushAConfig (popAConfig env)
            (aConfig(pConfig(Sigma, Delta, P, 
           union(Ins, getOutputs(read-protocol(L, env, I2))), 
           getOutputs(read-protocol(L, env, I1)), A), countb, contextb) )
           ),
        check L protocol (I2)
        in (pushAConfig
             (popAConfig env) 
             (aConfig(pConfig(Sigma, Delta, P, 
           union(Ins, getOutputs(read-protocol(L, env, I1))), 
                 getOutputs(read-protocol(L, env, I2)), A), countb, contextb) ) 
           )
      ] : 'IPDLProtocol} 
  if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .
  ceq check L protocol {'new_:_in_[I, I1, I2] : 'IPDLProtocol} in env = 
     try {'new_:_in_ [
        check L cname (I) in env,
        check L preType I1 in env,
        check L protocol I2
        in (pushAConfig
            (popAConfig env)
             (aConfig(pConfig(Sigma, Delta (chn q :: t), P, Ins, 
                       (Outs, chn q ), A), countb, contextb) )
           )
      ] : 'IPDLProtocol}  
  if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env 
  /\ q := read-qid(I) 
  /\ t := preToType(read-type(L, I1)) .
  eq check L protocol {'newfamily_indices:_bounds:_:_in_[I, I1, I2, T, I3]  : 'IPDLProtocol} =
     try   {'newfamily_indices:_bounds:_:_in_ [  
       check L familyName (I),
       return I1,  *** check L emptyTypeContext natTerms (I1),
        check L emptyTypeContext bounds (I2),
       check L preType (T),
       check L protocol (I3)
      ] : 'IPDLProtocol} .
  eq check L protocol {'newNF`(_`,_`)[I1, I2] : 'IPDLProtocol} =    
     try {'newNF`(_`,_`)[
          check L hidden (I1), 
          check L protocol (I2) 
           *** except here we will assign values to protocols
           *** that aren't in Delta, because Delta changes with the new channels!
      ] : 'IPDLProtocol} .
  eq check L protocol {'change_with_in_ [I, I1, I2] : 'IPDLProtocol }
   = try  {'change_with_in_ [
           return I, 
           return I1, 
           check L protocol (I2)
      ] : 'IPDLProtocol } .
  eq check L protocol {'branch_of_change_with_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol }
   = try  {'branch_of_change_with_in_ [
           return I, 
           return I1, 
           return I2, 
           return I3,
           check L protocol (I4)
      ] : 'IPDLProtocol } . 
  eq check L protocol {'gather_from_hiding_ [ I1, I2, I3 ] : 'IPDLProtocol }
   = try {'gather_from_hiding_ [ 
            return I1, 
            check L protocol (I2),
            return I3 ] : 'IPDLProtocol } .
  eq check L protocol {'embed`(_`,_`)[ I1, I2 ] : 'IPDLProtocol}
   = try {'embed`(_`,_`)[ 
            check L protocol (I1), 
            return I2 
      ] : 'IPDLProtocol} .
  eq check L protocol {'extend_with`internal`channel_typed:_assigned:_ [ I, I1, T, I2 ] : 'IPDLProtocol }
   = try  {'extend_with`internal`channel_typed:_assigned:_ [ 
         check L protocol (I), 
         return I1, 
         check L preType (T), 
         return I2 
      ] : 'IPDLProtocol } . 
  eq check L protocol
  {'extend_with`internal`family_indices:_bounds:_typed:_assigned:_ [ I, I1, I2, I3, T, I4 ] : 'IPDLProtocol } 
  = 
  try {'extend_with`internal`family_indices:_bounds:_typed:_assigned:_ [ 
      check L protocol (I), 
      return I1, 
      return I2, 
      return I3, 
      check L preType (T), 
      return I4 
   ] : 'IPDLProtocol } .
  eq check L protocol {'create`group_indices:_bounds:_from_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol}
   = try {'create`group_indices:_bounds:_from_in_ [
         return I, 
         return I1, 
         return I2, 
         return I3, 
         check L protocol (I4)] : 'IPDLProtocol}  .   

 op check_hidden : IPDL -> AnalysisAction{IPDL} .
  eq check L hidden {'empty.TypedCNameList : 'TypedCNameList} = 
     return {'empty.TypedCNameList : 'TypedCNameList} .
  eq check L hidden {'<_:_>[I1, I2] : 'TypedCName } =
     try {'<_:_>[
           check L cname (I1), 
           check L preType (I2)
      ] : 'TypedCName } .
  eq check L hidden {'`{__:_`}[I1, I2, T] : 'TypedCName} 
   = try {'`{__:_`}[
       check L familyName (I1), 
       return I2, 
       check L preType (I2)
      ] : 'TypedCName} .
  eq check L hidden {'__[I1, I2] : 'TypedCNameList} =   
     try {'__[
        check L hidden (I1), 
        check L hidden (I2)
      ] : 'TypedCNameList} .

  op check__reaction : IPDL TypeContext -> AnalysisAction{IPDL} .
  eq check L Gamma reaction  {'`(_`) [I] : 'IPDLReaction} =
     try {'`(_`) [
        check L Gamma reaction (I)
      ] : 'IPDLReaction} .
  eq check L Gamma reaction  {'return_[I] : 'IPDLReaction} =
     try {'return_ [
        check L Gamma expression (I)
      ] : 'IPDLReaction} .
  eq check L Gamma reaction  {'read_[I] : 'IPDLReaction} =
     try {'read_[
      check L Gamma declaredCNameIndex (I) 
      *** should check that the cname is in delta or matches a family from delta
      ] : 'IPDLReaction} 
  .
  eq check L Gamma reaction  {'read[I] : 'IPDLReaction} =
     try {'read[
      check L Gamma declaredCNameIndex (I) 
      *** should check that the cname is in delta or matches a family from delta
      ] : 'IPDLReaction} 
  .
  eq check L Gamma reaction {'if_then_else_[I, I1, I2] : 'IPDLReaction} =
     try {'if_then_else_ [
          check L Gamma expression (I), 
          check L Gamma reaction (I1), 
          check L Gamma reaction (I2)
      ] : 'IPDLReaction} . 
  ceq check L Gamma reaction {'_:_<-_;_[I, T, I1, I2] : 'IPDLReaction} =
     try {'_:_<-_;_ [
          return I, 
          check L preType (T), 
          check L Gamma reaction (I1), 
          check L (Gamma (q : t)) reaction (I2)
      ] : 'IPDLReaction} 
  if q := read-qid(I)
  /\ t := preToType(read-type(L, T))    .
  eq check L Gamma reaction {'samp_`(_`)[I1, I2] : 'IPDLReaction} =
     try {'samp_`(_`)[
           check L declaredDName (I1),
           check L emptyTypeContext expression (I2) 
      ] : 'IPDLReaction} .
  eq check L Gamma reaction {'nf`(_`,_`)[I1, I2] : 'IPDLReaction} =
     try {'nf`(_`,_`)[
           check L Gamma bind-read-list (I1),
           check L (addDeclarations (read-binds(L, I1)) Gamma)  reaction (I2)
      ] : 'IPDLReaction} .    
  eq check L Gamma reaction {'preNF`(_`,_`)[I1, I2] : 'IPDLReaction} =
     try {'preNF`(_`,_`)[
           check L Gamma bind-list (I1),
           check L (addDeclarations (read-binds(L, I1)) Gamma) reaction (I2)
      ] : 'IPDLReaction} . 

  op check__bind-list : IPDL TypeContext -> AnalysisAction{IPDL} . 
  eq check L Gamma bind-list {'nil.BindList : 'BindList} =
     return {'nil.BindList : 'BindList} .
  ceq check L Gamma bind-list {'_:_<~_[I, I1, I2] : 'BindReaction} =
     try {'_:_<~_[
          check L varName (I),  *** but the name should be new
          check L preType (I1), 
          check L (Gamma (q : t)) reaction (I2)
      ]: 'BindReaction} 
   if q := read-qid(I) /\
      t := preToType(read-type(L, I1)) .
  eq check L Gamma bind-list {'_:_<-`read_[I, I1, I2] : 'BindReaction} =
     try {'_:_<-`read_[
          check L varName (I),  *** but the name should be new
          check L preType (I1), 
          check L Gamma declaredCNameIndex (I2) *** but the name should be in the current Ins
      ]: 'BindReaction} .       
  eq check L Gamma bind-list {'__[I1, I2] : 'BindList} =   
     try {'__[
        check L Gamma bind-list (I1), 
        check L Gamma bind-list (I2)
      ] : 'BindList} .
 

  op check__bind-read-list : IPDL TypeContext -> AnalysisAction{IPDL} . 
  eq check L Gamma bind-read-list {'nil.BindList : 'BindList} =
     return {'nil.BindList : 'BindList} .
  eq check L Gamma bind-read-list {'_:_<-`read_[I, I1, I2] : 'BindReaction} =
     try {'_:_<-`read_[
          check L varName (I),  *** but the name should be new
          check L preType (I1), 
          check L Gamma declaredCNameIndex (I2) *** but the name should be in the current Ins
      ]: 'BindReaction} .
  eq check L Gamma bind-read-list {'__[I1, I2] : 'BindList} =   
     try {'__[
        check L Gamma bind-read-list (I1), 
        check L Gamma bind-read-list (I2)
      ] : 'BindList} .   

  op check__expression : IPDL TypeContext -> AnalysisAction{IPDL} .        
  eq check L Gamma expression {'True.IPDLExpr : 'IPDLExpr} =
     return {'True.IPDLExpr : 'IPDLExpr} .
  eq check L Gamma expression {'False.IPDLExpr : 'IPDLExpr} =
     return {'False.IPDLExpr : 'IPDLExpr} .
  eq check L Gamma expression {'`(`).IPDLExpr : 'IPDLExpr} =
     return {'`(`).IPDLExpr : 'IPDLExpr} .
  eq check L Gamma expression {I : 'VId} =
     return {I : 'VId} . *** TODO: I must be in Gamma
  eq check L Gamma expression {'fst_[I] : 'IPDLExpr} =
     try {'fst_ [ 
          check L Gamma expression (I)
      ] : 'IPDLExpr} .
  eq check L Gamma expression {'snd_[I] : 'IPDLExpr} =
     try {'snd_ [ 
          check L Gamma expression (I)
      ] : 'IPDLExpr} .
  eq check L Gamma expression {'`(_`,_`)[I1, I2] : 'IPDLExpr} =
     try {'`(_`,_`)[
          check L Gamma expression (I1), 
          check L Gamma expression (I2)
      ] : 'IPDLExpr} .
  eq check L Gamma expression {'_`(_`)[I1, I2] : 'IPDLExpr} 
     = 
     try {'_`(_`)[
         check L declaredFName (I1), 
         check L Gamma expression (I2) 
      ] : 'IPDLExpr} . 
 
 op check__natTerm : IPDL TypeContext -> AnalysisAction{IPDL} .
 ceq check L Gamma natTerm {I : 'CId} in env
  = check (read-qid(I) elem (Gamma PS))
     and-then return {I : 'CId}
     or-else fail('unknown 'term, (at term I, include context)) 
            in env 
  if PS := getEnvParams env .
 eq check L Gamma natTerm {I : 'Nat}
  = return {I : 'Nat} .
 eq check L Gamma natTerm  {'`(_`) [I] : 'NatTerm}
  = try  {'`(_`) [check L Gamma natTerm (I)] : 'NatTerm} .
 eq check L Gamma natTerm {'_+_[I1, I2] : 'NatTerm} 
  = try {'_+_[
      check L Gamma natTerm (I1), 
      check L Gamma natTerm (I2)] : 'NatTerm} .
 eq check L Gamma natTerm {'_-_[I1, I2] : 'NatTerm} 
  = try {'_-_[
      check L Gamma natTerm (I1), 
      check L Gamma natTerm (I2)] : 'NatTerm} .     
 eq check L Gamma natTerm {'_*_[I1, I2] : 'NatTerm} 
  = try {'_*_[
      check L Gamma natTerm (I1), 
      check L Gamma natTerm (I2)] : 'NatTerm} .   
 eq check L Gamma natTerm {'_`(_`)[I1, I2] : 'NatTerm}
   = try {'_`(_`)[
       return I1, *** should check that we have a function with this name in the module?
       check L Gamma natTerm (I2)] : 'NatTerm} .       

 op check__natTerms : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq check L Gamma natTerms {I : 'CId} 
  = check L Gamma natTerm {I : 'CId} .
 eq check L Gamma natTerms {I : 'Nat} 
  = check L Gamma natTerm {I : 'Nat} .
 eq check L Gamma natTerms {I : 'NatTerm} 
  = check L Gamma natTerm {I : 'NatTerm} .  
 eq check L Gamma natTerms {'_`,_[I1, I2] : 'NatTermList}
   = try {'_`,_[
       check L Gamma natTerms (I1), 
       check L Gamma natTerms (I2)
      ] : 'NatTermList} .

  op check__boolTerm : IPDL TypeContext -> AnalysisAction{IPDL} .
  eq check L Gamma boolTerm {'falseBT.BoolTerm : 'BoolTerm} = 
     return {'falseBT.BoolTerm : 'BoolTerm} .
  eq check L Gamma boolTerm {'trueBT.BoolTerm : 'BoolTerm} = 
     return {'trueBT.BoolTerm : 'BoolTerm} . 
  eq check L Gamma boolTerm {'_=_[I1, I2] : 'BoolTerm} =   
     try {'_=_ [
        check L Gamma natTerm (I1),
        check L Gamma natTerm (I2)
      ] : 'BoolTerm} .   
  eq check L Gamma boolTerm {'_<_[I1, I2] : 'BoolTerm} =   
     try {'_<_ [
        check L Gamma natTerm (I1),
        check L Gamma natTerm (I2)
      ] : 'BoolTerm} .    
  eq check L Gamma boolTerm {'_<=_[I1, I2] : 'BoolTerm} =   
     try {'_<=_ [
        check L Gamma natTerm (I1),
        check L Gamma natTerm (I2)
      ] : 'BoolTerm} .    
  eq check L Gamma boolTerm {'_and_[I1, I2] : 'BoolTerm} =   
     try {'_and_ [
        check L Gamma boolTerm (I1),
        check L Gamma boolTerm (I2)
      ] : 'BoolTerm} .
  eq check L Gamma boolTerm {'_or_[I1, I2] : 'BoolTerm} =   
     try {'_or_ [
        check L Gamma boolTerm (I1),
        check L Gamma boolTerm (I2)
      ] : 'BoolTerm} .
  eq check L Gamma boolTerm {'not_[I1] : 'BoolTerm} =   
     try {'not_ [
        check L Gamma boolTerm (I1)
      ] : 'BoolTerm} .         
  eq check L Gamma boolTerm  {'_`(_`)[I1, I2] : 'BoolTerm} =
   try {'_`(_`)[
       return I1, 
       check L Gamma natTerm (I2)
    ] : 'BoolTerm} .

 op check__boundedIndex : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq check L Gamma boundedIndex {'_<_[I1, I2] : 'BoundedIndex} 
  = try {'_<_[
      return I1, 
      check L Gamma natTerm (I2)
   ] : 'BoundedIndex} .
 eq check L Gamma boundedIndex {'_=_[I1, I2] : 'BoundedIndex} 
  = try {'_=_[
      return I1, 
      check L Gamma natTerm (I2)
   ] : 'BoundedIndex} . 

  op check__boundedIndexList : IPDL TypeContext -> AnalysisAction{IPDL} . 
  ceq check L Gamma boundedIndexList I 
    = check L Gamma boundedIndex I 
   if  I :: 'BoundedIndex .
  eq check L Gamma boundedIndexList {'_`,_[I1, I2] : 'BoundedIndexList}
   = try {'_`,_[
       check L Gamma boundedIndexList (I1), 
       check L Gamma boundedIndexList (I2)
      ] : 'BoundedIndexList} .  

 op check__bound : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq check L Gamma bound {'bound_[I] : 'Bound}
   = try {'bound_[
       check L Gamma natTerm (I)]
       : 'Bound} .
  eq check L Gamma bound {'fixedBound_[I] : 'Bound}
   = try {'fixedBound_[
       check L Gamma natTerm (I)]
       : 'Bound} .
  eq check L Gamma bound {'dependentBound_[I] : 'Bound}
   = try {'dependentBound_[
       return I]
       : 'Bound} . 

 op check__bounds : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq check L Gamma bounds {I : 'Bound}
   = check L Gamma bound {I : 'Bound} .
  eq check L Gamma bounds {'__[I1, I2] : 'BoundList}
   = try {'__[
       check L Gamma bounds (I1), 
       check L Gamma bounds (I2)
      ] : 'BoundList} .

 op check__whenCond : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq check L Gamma whenCond {'otherwise.WhenCond : 'WhenCond} 
   = return {'otherwise.WhenCond : 'WhenCond} .
  eq check L Gamma whenCond {'when_[I] : 'WhenCond}
   = try {'when_[
       check L Gamma boolTerm (I)]
       : 'WhenCond} .

 op check__when : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq check L Gamma when {'_-->_[I1, I2] : 'When}
   = try {'_-->_[
       check L Gamma whenCond (I1), 
       check L Gamma cases (I2)
      ] : 'When} .

 op check__whenList : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq check L Gamma whenList {'emptyWhen.WhenList : 'WhenList} 
   = return {'emptyWhen.WhenList : 'WhenList} .
 eq check L Gamma whenList {'`(_`) [I] : 'WhenList}
  = try {'`(_`) [check L Gamma whenList I] : 'WhenList} .  
  ceq check L Gamma whenList I
   = check L Gamma when I if I :: 'When . 
  eq check L Gamma whenList {'_;;_[I1, I2] : 'WhenList}
   = try {'_;;_[
       check L Gamma whenList (I1), 
       check L Gamma whenList (I2)
      ] : 'WhenList} .

 op check__cases : IPDL TypeContext -> AnalysisAction{IPDL} .
 ceq check L Gamma cases I
  = check L Gamma reaction I if I :: 'IPDLReaction . 
 ceq check L Gamma cases I
   = check L protocol I if I :: 'IPDLProtocol . *** TODO: add Gamma to check L protocol?
 ceq check L Gamma cases I
   = check L Gamma whenList I if I :: 'WhenList .  
 ceq check L Gamma cases I
   = check L Gamma when I if I :: 'When .

 op check_varName : IPDL -> AnalysisAction{IPDL} .
 eq check L varName {'vid[I] : 'VId}
     = return {I : 'VName} .
  eq check L varName {I : 'VId} =  *** incomplete for now, we should check that it's new
    return {I : 'VId}
   . 

  op check_isInputCName : IPDL -> AnalysisAction{IPDL} .
  ceq check L isInputCName {I : 'CName} in env 
  = 
   check ( 
      (metaOccurs env   ('occurs___[upTerm(chn read-qid(I)), upTerm(Delta), upTerm(A)] ))
      and 
      (chn read-qid(I) in Ins) 
   )  
   and-then return {I : 'CName}
   or-else fail('not 'an 'input 'channel, (at L term I, include context)) 
            in env      
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env . 

  op check_declaredFName : IPDL -> AnalysisAction{IPDL} .
  ceq check L declaredFName {I : 'FName} in env = 
   check (read-qid(I) elem Sigma) and-then return {I : 'FName}
   or-else fail('unknown 'function, (at L term I, include context)) 
            in env
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env . 

  op check_declaredDName : IPDL -> AnalysisAction{IPDL} .          
  ceq check L declaredDName {I : 'DName} 
     in env = 
   check (read-qid(I) elem Sigma)  and-then return {I : 'DName}
   or-else fail('unknown 'distribution, (at L term I, include context)) 
            in env
  if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .                       
  
  op check__declaredCNameIndex : IPDL TypeContext -> AnalysisAction{IPDL} .
  ceq check L Gamma declaredCNameIndex {'cname[I] : 'CName}
     in env
     = check ( (metaOccurs env   ('occurs___[upTerm(chn read-qid(I)), upTerm(Delta), upTerm(A)] )) )  
       and-then return {I : 'CName}
       or-else fail('unknown 'channel, (at L term 'cname[I], include context)) 
       in env 
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .
  ceq check L Gamma declaredCNameIndex {I : 'CName}
     in env
     = check ((metaOccurs env   ('occurs___[upTerm(chn read-qid(I)), upTerm(Delta), upTerm(A)] )) )  
       and-then return {I : 'CName}
       or-else fail('unknown 'channel, (at L term 'cname[I], include context)) 
       in env 
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .    
  ceq check L Gamma declaredCNameIndex {'_`[_`][ I1, I2] : 'CNameIndex} in env
     = 
     check ((metaOccurs env
            ('occurs___[upTerm(chn read-cNameIndex(L, {'_`[_`][I1, I2] : 'CNameIndex})), 
                        upTerm(Delta), upTerm(A)] )) )  
       and-then return {'_`[_`][ I1, I2] : 'CNameIndex}
       or-else try {'_`[_`][ 
        return I1, 
        check L Gamma natTerms (I2)] : 'CNameIndex} 
     in env
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .       
  
  op check_declaredCName : IPDL -> AnalysisAction{IPDL} .
  eq check L declaredCName {'cname[I] : 'CName}
     = return {I : 'CName} .
  eq check L declaredCName {I : 'CName} 
     *** in (buildEnv (aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) PCL1) 
     ***              deltaMap protMap embMap m TCS QIS PS) 
     = return {I : 'CName} .
  ***  check ( occurs ( chn read-qid(I) ) Delta A )  and-then return {I : 'CName}
  ***  or-else fail('unknown 'channel, (at L term 'cname[I], include context)) 
  ***           in (buildEnv aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) 
  ***     deltaMap protMap embMap m TCS QIS PS) .

  op check_moduleName : IPDL -> AnalysisAction{IPDL} .
  eq check L moduleName {'mName[I] : 'ModuleName} = 
   check ( upModule(read-qid(I), true) :: Module) and-then return {I : 'ModuleName}
   or-else fail('already 'declared, (at L term 'mName[I], include context)) 
  .

  op check_sname : IPDL -> AnalysisAction{IPDL} .
  eq check L sname {'sname[I] : 'SName} 
   = return {I : 'SName} .

  op check_embName :  IPDL -> AnalysisAction{IPDL} .
  eq check L embName {'embedName[I] : 'EmbedName} in env
   = check ($hasMapping(getEmbMap env, read-qid(I)) == false) and-then return {I : 'EmbedName} 
     or-else fail('embedding 'already 'declared) 
   in env 
  .    

  op solve_embName :  IPDL -> AnalysisAction{IPDL} .
  eq solve L embName {'embedName[I] : 'EmbedName}
   = return {I : 'EmbedName} 
  .

  op check_pname : IPDL -> AnalysisAction{IPDL} .
  ceq check L pname {'pname[I] : 'PName} in 
     env = 
   check ( $hasMapping(protMap, read-qid(I))  == false ) and-then return {I : 'PName}
   or-else fail('already 'declared, (at L term 'pname[I], include context)) 
            in env
   if protMap := getPMap env .

  op check_declaredPname : IPDL -> AnalysisAction{IPDL} .
  ceq check L declaredPname {'pname[I] : 'PName} in env = 
   check ( $hasMapping(protMap, read-qid(I)) ) and-then return {I : 'PName}
   or-else fail('unknown 'protocol, (at L term 'pname[I], include context)) 
            in env 
   if protMap := getPMap env .          

   op solve_aName : IPDL -> AnalysisAction{IPDL} . 
   eq solve L aName {'assumName[I] : 'AssumName} 
    = return {I : 'AssumName} .

  op check_aName : IPDL -> AnalysisAction{IPDL} .
  ceq check L aName {'assumName[I] : 'AssumName} in env = 
     check (read-qid(I) not-in QIS) and-then return {I : 'AssumName}
    or-else fail('already 'declared, (at L term 'tdid[I], include context)) 
            in 
            env
   if QIS := getAssums env                    
  .             

   op check_preType : IPDL -> AnalysisAction{IPDL} .
  eq check L preType {'`(_`) [I] : 'IPDLPreType}
   = try {'`(_`) [check L preType (I)] : 'IPDLPreType} .  
  eq check L preType {'_*_[I1, I2] : 'IPDLPreType} =
   try {'_*_[check L preType I1, check L preType I2] : 'IPDLPreType} .
  ceq check L preType {I : 'TId} in env =
   check (read-type(L, I) in QIS)  and-then return {I : 'TId}
   or-else fail('unknown 'types 'in, (at L term I, include context)) 
           in env
   if aConfig(pConfig((Sigma (typesOf QIS)), Delta, P, Ins, Outs, A), 
              countb, contextb) := getAConfig env .
  
  op check_cname : IPDL -> AnalysisAction{IPDL} .
  ceq check L cname {'cname[I] : 'CName} in env = 
   check ( ( (metaOccurs env   ('occurs___[upTerm(chn read-qid(I)), upTerm(Delta), upTerm(A)] )) ) == false )
   and-then return {I : 'CName}
   or-else fail('channel 'already 'declared, (at L term 'cname[I], include context)) 
            in env 
  if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .
  ceq check L cname {I : 'CName} in env = 
   check ( (metaOccurs env   ('occurs___[upTerm(chn read-qid(I)), upTerm(Delta), upTerm(A)] )) == false ) 
   and-then return {I : 'CName}
   or-else fail('channel 'already 'declared, (at L term I, include context)) 
            in env
  if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .

  ***( eq check L cname {'__[I, S] : 'CName}
  = try {'__[
        check L cname (I),
        check L cname-scripts(S)
      ] : 'CName} . )

 ***(  op check_cname-scripts : IPDL -> AnalysisAction{IPDL} .
  ceq check L cname-scripts {'cscripts[S] : 'CScripts}
  = (check (QI1 == '_) or-else fail ('expecting '_, (at QI1, include context)))
    and-then (check (not (rat(string(QI2), 10) :: Nat)) or-else fail ('expecting 'a 'word, (at (QI1 QI2), include context)))
    and-then (check (QI3 == '_) or-else fail ('expecting '_, (at (QI1 QI2 QI3), include context)))
    and-then (check (not (rat(string(QI4), 10) :: Nat)) or-else fail ('expecting 'a 'word, (at (QI1 QI2 QI3 QI4), include context)))
    and-then return {S : 'CScripts}
  if QI1 QI2 QI3 QI4 := read-qids(S) cn )

  op check_fname : IPDL -> AnalysisAction{IPDL} .
  ceq check L fname {I : 'FName} in 
     env = 
   check ((read-qid(I) elem Sigma) == false) and-then return {I : 'FName}
   or-else fail('function 'already 'declared, (at L term I, include context)) 
            in env
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .

  op check_dname : IPDL -> AnalysisAction{IPDL} .          
  ceq check L dname {I : 'DName} in 
     env = 
   check ((read-qid(I) elem Sigma) == false) and-then return {I : 'DName}
   or-else fail('distribution 'already 'declared, (at L term I, include context)) 
            in env          
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .         

  op check_tdid : IPDL -> AnalysisAction{IPDL} .
  ceq check L tdid {'tdid[I] : 'TDId} in 
      env
  = check (read-qid(I) not-in QIS) and-then return {I : 'TDId}
    or-else fail('type 'already 'declared, (at L term 'tdid[I], include context)) 
            in 
            env
   if aConfig(pConfig(Sigma (typesOf QIS), Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .         
  ceq check L tdid {I : 'TDId} in 
      env
  = check (read-qid(I) not-in QIS) and-then return {I : 'TDId}
    or-else fail('type 'already 'declared, (at L term I, include context)) 
            in 
            env
   if aConfig(pConfig(Sigma (typesOf QIS), Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .          
      

 *** 3. type checking
  op type`check_localDecl : IPDL -> AnalysisAction{IPDL} .
  eq type check L localDecl {'_=_[I1, I2] : 'LocalDecl}
   = try {'_=_[
        return I1, 
        type check L protocol(I2)
      ] : 'LocalDecl} .

  op type`check_localDecls : IPDL -> AnalysisAction{IPDL} .    
  ceq type check L localDecls I = 
      type check L localDecl  I
  if I :: 'LocalDecl .
  eq type check L localDecls {'_and_[I1, I2] : 'LocalDeclList} 
   = try   {'_and_[
       type check L localDecls (I1), 
       type check L localDecls (I2)
      ] : 'LocalDeclList} .   
   

  op type`check_protocol : IPDL -> AnalysisAction{IPDL} .
  eq type check L protocol I = type check L protocol [I] I .

  op type`check_protocol`[_`] : IPDL ATerm -> AnalysisAction{IPDL} .
  eq type check L protocol [{'emptyProtocol.IPDLProtocol : 'IPDLProtocol}]
     {'emptyProtocol.IPDLProtocol : 'IPDLProtocol}
   = return {'emptyProtocol.IPDLProtocol : 'IPDLProtocol} .
  eq type check L protocol [{'currentProtocol.IPDLProtocol : 'IPDLProtocol}]
     {'currentProtocol.IPDLProtocol : 'IPDLProtocol}
   = return {'currentProtocol.IPDLProtocol : 'IPDLProtocol} . 
  eq type check L protocol [{'savedProtocol.IPDLProtocol : 'IPDLProtocol}]
     {'savedProtocol.IPDLProtocol : 'IPDLProtocol}
   = return {'savedProtocol.IPDLProtocol : 'IPDLProtocol} .  
  eq type check L protocol[$I] { 'change_with_in_ [I, I1, I2] : 'IPDLProtocol }
   = return  { 'change_with_in_ [I, I1, I2] : 'IPDLProtocol } .
  eq type check L protocol[$I] { 'branch_of_change_with_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol }
   = return  { 'branch_of_change_with_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol } .  
  eq type check L protocol[$I] {'extend_with`internal`channel_typed:_assigned:_ [ I, I1, T, I2 ] : 'IPDLProtocol }
   = return {'extend_with`internal`channel_typed:_assigned:_ [ I, I1, T, I2 ] : 'IPDLProtocol } .
  eq type check L protocol[$I] {'gather_from_hiding_ [ I1, I2, I3 ] : 'IPDLProtocol }
   = return {'gather_from_hiding_  [ I1, I2, I3 ] : 'IPDLProtocol } . 
  eq type check L protocol[$I] {'embed`(_`,_`)[ I1, I2 ] : 'IPDLProtocol}
   = return {'embed`(_`,_`)[ I1, I2 ] : 'IPDLProtocol} .   
  eq type check L protocol[$I] 
      {'extend_with`internal`family_indices:_bounds:_typed:_assigned:_ [ I, I1, I2, I3, T, I4 ] : 'IPDLProtocol } 
   = return 
      {'extend_with`internal`family_indices:_bounds:_typed:_assigned:_ [ I, I1, I2, I3, T, I4 ] : 'IPDLProtocol }  .
  eq type check L protocol[$I] {'create`group_indices:_bounds:_from_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol}
   = return {'create`group_indices:_bounds:_from_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol} . 
  eq type check L protocol [{'`(_`) [I] : 'IPDLProtocol}]
     {'`(_`) [I] : 'IPDLProtocol}
   = try {'`(_`) [
       type check L protocol [I] I
       ] : 'IPDLProtocol} . 
  ceq type check L protocol [{$I : 'PName}] (I) in env
   = return {$I : 'PName} in env
   if {$I : 'PName} =/= I
      /\ successful-analysis(TL) := type check L protocol I in env .
  ceq type check L protocol [{$I : 'PName}] (I) in env
   = fail(QIL, (at term $I, include context)) in env
   if {$I : 'PName} =/= I
      /\ analysis-error(QIL, WA) := type check L protocol I in env .

  *** will this do?
  ceq type check L protocol [{$I : 'PName}] (I) in env
   = return {$I : 'PName} in env
   if {$I : 'PName} == I .

  eq type check L protocol [{'_where_[$I1, $I2] : 'IPDLProtocol}]
    {'_where_[I1, I2] : 'IPDLProtocol}
   = try { '_where_ [
        type check L protocol [$I1] (substitute(L, I2, I1)),
        return $I2
     ] : 'IPDLProtocol } .
  eq type check L protocol [{'`(_`) [$I] : 'IPDLProtocol}]
    {'`(_`) [I] : 'IPDLProtocol}
   = try {'`(_`) [
        type check L protocol [$I] (I)
      ] : 'IPDLProtocol} .    

  op find-protocol : IPDL ATerm ATerm ~> ATerm .
  ceq find-protocol(L, I, {'_and_[I1, I2] : 'LocalDeclList})
   = T if T := find-protocol(L, I, I1) .
  eq find-protocol(L, I, {'_and_[I1, I2] : 'LocalDeclList})
   = find-protocol(L, I, I2) [owise] .
  eq find-protocol(L, I, {'_=_[I, T] : 'LocalDecl}) = T .
  
  op substitute : IPDL ATerm ATerm ~> ATerm .
  eq substitute(L, I, {'emptyProtocol.IPDLProtocol : 'IPDLProtocol})
   = {'emptyProtocol.IPDLProtocol : 'IPDLProtocol} .
  eq substitute(L, I, {I1 : 'PName})
   = find-protocol(L, {I1 : 'PName}, I)  .
  eq substitute(L, I, {'_::=_ [I1, I2] : 'IPDLProtocol})
   = {'_::=_ [I1, I2] : 'IPDLProtocol}   .
  eq substitute(L, I, {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol})
   = {'family_indices:_bounds:_::=_[I, I1, I2, substitute(L, I, I3)]  : 'IPDLProtocol} .
  eq substitute(L, I, {'_||_[I1, I2]  : 'IPDLProtocol})
   = {'_||_[substitute(L, I, I1), substitute(L, I, I2)]  : 'IPDLProtocol} .
  eq substitute(L, I, {'new_:_in_[I1, I2, I3]  : 'IPDLProtocol})
   = {'new_:_in_[I1, I2, substitute(L, I, I3)]  : 'IPDLProtocol} .
  eq substitute(L, I, {'newfamily_indices:_bounds:_:_in_[I, I1, I2, T, I3]  : 'IPDLProtocol})
   = {'newfamily_indices:_bounds:_:_in_[I, I1, I2, T, substitute(L, I, I3)]  : 'IPDLProtocol} .
  eq substitute(L, I, {'newNF`(_`,_`)[I1, I2] : 'IPDLProtocol})
   = {'newNF`(_`,_`)[I1, substitute(L, I, I2)] : 'IPDLProtocol} .
  eq substitute(L, I, {'_where_[I1, I2] : 'IPDLProtocol})
   = {'_where_[substitute(L, I, I1), substitute(L, I, I2)] : 'IPDLProtocol} .
  eq substitute(L, I, {'_and_[I1, I2] : 'LocalDeclList})
   = {'_and_[substitute(L, I, I1), substitute(L, I, I2)] : 'LocalDeclList} .
  eq substitute(L, I, {'_=_[I1, I2] : 'LocalDecl})
   = {'_=_[I1, substitute(L, I, I2)] : 'LocalDecl} .
  eq substitute(L, I, {'`(_`) [I1] : 'IPDLProtocol})
   = {'`(_`) [substitute(L, I, I1)] : 'IPDLProtocol} . 
  
  eq type check L protocol [{'newNF`(_`,_`)[I1, $I2] : 'IPDLProtocol}]
      {'newNF`(_`,_`)[I1, I2] : 'IPDLProtocol}
   = return {'newNF`(_`,_`)[I1, $I2] : 'IPDLProtocol} .
  ceq type check L protocol [{'newfamily_indices:_bounds:_:_in_[I, I1, I2, T, $I3]  : 'IPDLProtocol}]
      {'newfamily_indices:_bounds:_:_in_[I, I1, I2, T, I3]  : 'IPDLProtocol}
      in env
     = try {'newfamily_indices:_bounds:_:_in_ [
        (check ((metaOccurs env   ('occurs___[upTerm(fam (q[blist])), upTerm(Delta), upTerm(A)] ))
                 == false
               )
         and-then return I
         or-else fail ('internal 'family 'already 'in 'use', (at term I, include context)))
         in env,
        return I1 in env,
        check (blist == blist')
        and-then return I2
        or-else fail('bounds 'mismatch 'for q, (at term I, include context)) 
        in env,
        return T in env, 
        type check L protocol [$I3] I3
        in (pushAConfig 
             (popAConfig env)
            (aConfig(pConfig(Sigma, Delta (( fam (q[blist]) ) :: t), P, 
                Ins, (Outs, fam (q[blist]) ), A), countb, contextb) )
            )
        ] : 'IPDLProtocol}
    if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env
        /\ q[blist] := read-familyName(L, I) 
        /\ blist' := read-bounds(L, I2)
        /\ t := preToType(read-type(L, T)) .
  ceq type check L protocol [{'new_:_in_[I, I1, $I2] : 'IPDLProtocol}]
      {'new_:_in_[I, I1, I2] : 'IPDLProtocol}
      in env
     = try {'new_:_in_ [
        (check ((metaOccurs env ('occurs___[upTerm(chn cn), upTerm(Delta), upTerm(A)] )) == false)
         and-then return I
         or-else fail ('internal 'channel 'already 'in 'use', (at term I, include context)))
         in env,
        return I1 in env,
        type check L protocol [$I2] I2
        in (pushAConfig
             (popAConfig env)
             (aConfig(pConfig(Sigma, Delta ((chn cn) :: t), P, 
                Ins, (Outs, chn cn), A), countb, contextb) )
           )
        ] : 'IPDLProtocol}
    if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env
        /\ cn := read-cNameIndex(L, I) 
        /\ t := preToType(read-type(L, I1)) . 
  ceq type check L protocol [{'_||_[$I1, $I2] : 'IPDLProtocol}]
    {'_||_[I1, I2] : 'IPDLProtocol}
     in env
     =
     try {'_||_[
       type check L protocol [$I1] I1
       in (pushAConfig 
            (popAConfig env)
            (aConfig(pConfig(Sigma, Delta, P, 
           union(Ins, metaGetOutputs env ('getOutputs[upTerm(read-protocol(L, env, I2))])
                ), 
           getOutputs(read-protocol(L, env, I1)), A), countb, contextb))
          ) ,
       type check L protocol [$I2] I2
       in (pushAConfig 
            (popAConfig env)
          (aConfig(pConfig(Sigma, Delta, P, 
           union(Ins, metaGetOutputs env ('getOutputs[upTerm(read-protocol(L, env, I1))])), 
                 getOutputs(read-protocol(L, env, I2)), A), countb, contextb))
          )
     ] : 'IPDLProtocol}
  if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env  .
  ceq type check L protocol [{'_::=_[I1, I2] : 'IPDLProtocol}]
      {'_::=_[I1, I2] : 'IPDLProtocol} in env
     =
    try {'_::=_[  
          return I1 in env, 
          type check L emptyTypeContext reaction (I2)
          in (pushAConfig
               (popAConfig env)
                (aConfig(pConfig(Sigma, Delta, P, (Ins, chn read-cNameIndex(L, I1)), Outs, A), 
                         countb, contextb) )
             )
      ] : 'IPDLProtocol}
    then postTypeCheck L protocol in env
   if I2 :: 'IPDLReaction 
   /\ aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env .
  ceq type check L protocol [{'_::=_[I1, I2] : 'IPDLProtocol}]
      {'_::=_[I1, I2] : 'IPDLProtocol} in env
     =
    try {'_::=_[  
          return I1 in env, 
          type check L emptyTypeContext whenList (I2)
          in (pushAConfig
              (popAConfig env) 
               (aConfig(pConfig(Sigma, Delta, P, (Ins, chn read-cNameIndex(L, I1)), Outs, A),
                        countb, contextb) )
             )
      ] : 'IPDLProtocol}
    then postTypeCheck L protocol in env
   if I2 :: 'WhenList 
   /\ aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env
    .   
  ceq type check L protocol [{'family_indices:_bounds:_::=_[I, I1, I2, $I3]  : 'IPDLProtocol}]
      {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} 
      in env
   =   
   try {'family_indices:_bounds:_::=_ [
        type check L familyName (I) in env,
        return I1 in env,
        type check L emptyTypeContext bounds (I2) in env,
        type check L (indicesToTypeContext nlist) reaction (I3)
        in
        (pushAConfig  
          (popAConfig env)
          (aConfig(pConfig(Sigma, Delta, P, 
                       (Ins, fam fn),
                       Outs, 
                       addAssumptions A nlist blist), countb, contextb
                     )
          )
        ) 
      ] : 'IPDLProtocol}
    then postTypeCheck L protocol in env
    if I3 :: 'IPDLReaction 
    /\ nlist := read-natTerms(L, I1)
    /\ blist := read-bounds(L, I2)
    /\ fn := read-familyName(L, I)
    /\ aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env
    [label typeCheckFamily]
    . 

   var fn : FamilyName .

    *** below we have groups
  ceq type check L protocol [{'family_indices:_bounds:_::=_[I, I1, I2, $I3]  : 'IPDLProtocol} ]
      {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} 
   =   
   try {'family_indices:_bounds:_::=_ [
        return I, *** NO: type check L familyName (I), groups aren't in Delta
        return I1,
        type check L emptyTypeContext bounds (I2),
        type check L protocol [$I3] (I3) *** indices can be used?
      ] : 'IPDLProtocol}
    then postTypeCheck L protocol
    if I3 :: 'IPDLProtocol 
    /\ nlist := read-natTerms(L, I1)
    .   
  ceq type check L protocol [{'family_indices:_bounds:_::=_[I, I1, I2, $I3]  : 'IPDLProtocol}]
      {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} 
        in env 
   =   
   try {'family_indices:_bounds:_::=_ [
        if hasReaction I3
        then type check L familyName (I) in env
        else return I in env
        fi,
        return I1 in env ,
        type check L emptyTypeContext bounds (I2) in env ,
        *** if hasReaction I3 then 
        type check L (indicesToTypeContext nlist) whenList (I3)
        in (pushAConfig
            (popAConfig env)
            (aConfig(pConfig(Sigma, Delta, P, 
                       (Ins, fam (q[blist])),
                       Outs, 
                       addAssumptions A nlist blist), countb, contextb
                       )
            )
           ) 
         *** else type check L (indicesToTypeContext nlist) whenList (I3) in env fi         
      ] : 'IPDLProtocol}
    then postTypeCheck L protocol in env
    if I3 :: 'WhenList 
    /\ q[blist] := read-familyName(L, I)
    /\ nlist := read-natTerms(L, I1)
    /\ aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env
    [label typeCheckFamilyWhenList] .   
  
  op hasReaction_ : ATerm -> Bool . 
  eq hasReaction {'`(_`) [I] : 'WhenList} = hasReaction I .
  eq hasReaction {'_;;_[I1, I2] : 'WhenList} = hasReaction I1 .
  eq hasReaction {'_-->_[I1, I2] : 'When} = I2 :: 'IPDLReaction .

  var nlist : List{NatTerm} .

  op indicesToTypeContext_ : List{NatTerm} -> TypeContext .
  eq indicesToTypeContext nlist = indicesToTypeContextAux nlist emptyTypeContext .

  op indicesToTypeContextAux__ : List{NatTerm} TypeContext -> TypeContext .
  eq indicesToTypeContextAux nil Gamma = Gamma .
  eq indicesToTypeContextAux (qidAsTerm(q)) Gamma = Gamma (q : typeName 'nat) .
  eq indicesToTypeContextAux (qidAsTerm(q) nlist) Gamma = 
     indicesToTypeContextAux nlist (Gamma (q : typeName 'nat)) .


  var de : TypeWithError .
  var blist blist' : List{Bounds} .

  op type`check_familyName : IPDL -> AnalysisAction{IPDL} .
  ceq type check L familyName {I : 'BasicFamilyName}
     in env =
  check (metaOccurs env ('occurs___[upTerm(fam (q[blist])), upTerm(Delta), upTerm(A)] ))
  and-then
   return {I : 'BasicFamilyName}
  or-else fail('unknown 'family q , 
        (at term I, include context))
   in env
  if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env  
  /\ q[blist] := read-familyName(L, {I : 'BasicFamilyName})    
  .

 var R : Reaction .
 var whenCond : WhenCond .
 var whenList : WhenList .
 var bdset : Set{CNameBound} .
 var Tm : Term .
 var TP : Type .

op allSameOutputs__ : Env WhenList -> Bool .
eq allSameOutputs env emptyWhen = true .
eq allSameOutputs env ((whenCond --> R) ;; whenList) = true .
ceq allSameOutputs env ((whenCond --> P) ;; whenList) = 
   allSameOutputsAux env (downTerm(Tm, (chn 'c, chn 'd))) whenList
if {Tm, TP} := metaReduce( getModule env, 'getOutputs[upTerm(P)]) .

***   op allSameOutputs_ : WhenList -> Bool .
*** eq allSameOutputs emptyWhen = true .
*** eq allSameOutputs ((whenCond --> R) ;; whenList) = true .
*** eq allSameOutputs ((whenCond --> P) ;; whenList) = 
***    allSameOutputsAux getOutputs(P) whenList .

   
*** op allSameOutputsAux__ : Set{CNameBound} WhenList -> Bool .
*** eq allSameOutputsAux bdset emptyWhen = true .
*** eq allSameOutputsAux bdset (whenCond --> P) = getOutputs(P) == bdset .
*** eq allSameOutputsAux bdset ((whenCond --> P) ;; whenList)
***  = (getOutputs(P) == bdset) and  allSameOutputsAux bdset whenList .  

op allSameOutputsAux___ : Env Set{CNameBound} WhenList -> Bool .
eq allSameOutputsAux env bdset emptyWhen = true .
ceq allSameOutputsAux env bdset (whenCond --> P) = (downTerm(Tm, (chn 'c, chn 'd))) == bdset 
if {Tm, TP} := metaReduce( getModule env, 'getOutputs[upTerm(P)]) .
ceq allSameOutputsAux env bdset ((whenCond --> P) ;; whenList)
 = ((downTerm(Tm, (chn 'c, chn 'd))) == bdset) and  allSameOutputsAux env bdset whenList 
if {Tm, TP} := metaReduce( getModule env, 'getOutputs[upTerm(P)]) .

  op postTypeCheck_protocol : IPDL -> AnalysisAction{IPDL} .
  ceq postTypeCheck L protocol {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} 
        in env
   =   
   (check (blist == blist')
    or-else fail('bounds 'mismatch 'for q, (at term I, include context))
   )
   and-then
   (check (allSameOutputs env (read-whenList(L, env, I3)))
    or-else fail('outputs 'mismatch 'for q, (at term I, include context))
   )
   and-then
     return {'family_indices:_bounds:_::=_ [I, I1, I2, I3]  : 'IPDLProtocol} 
     in env
  if q[blist] := read-familyName(L, I) 
  /\ blist' := read-bounds(L, I2)
  /\ I3 :: 'WhenList .
  ceq postTypeCheck L protocol {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} 
        in env
   =   
   (check ((fam (q[blist])) in Ins == false)
   or-else  fail ('cannot 'assign 'to 'an 'input 'family ': q
            , 
        (at term I1, include context))
   )
   and-then
   (check (blist == blist')
    or-else fail('bounds 'mismatch 'for q, (at term I, include context))
   )
   and-then
   (check (t == d)
    or-else fail('type 'mismatch 'for q *** ': '\n 
               *** 'expecting show-type(IPDL, typeToPre(t)) 
               *** 'and 'got show-type(IPDL, typeToPre(d))
               , (at term I, include context)))
   and-then
     return {'family_indices:_bounds:_::=_ [I, I1, I2, I3]  : 'IPDLProtocol} 
     in env
  if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env
  /\ q[blist] := read-familyName(L, I) 
  /\ blist' := read-bounds(L, I2)
  /\ nlist := read-natTerms(L, I1)
  /\ t := metaTypeInCtx env ('typeInCtx[upTerm(fam (q[blist])), upTerm(A), upTerm(Delta)])
       *** typeInCtx(fam (q[blist]), A, Delta)
  /\ d  := metaTypeOf env 
           ('typeOf[upTerm(Sigma), upTerm(Delta), upTerm(emptyTypeContext), 
                    upTerm((Ins, fam (q[blist]))), upTerm(addAssumptions A nlist blist), 
                    upTerm(read-reaction(L, I3)) 
                    ])
         ***   typeOf(Sigma, Delta, emptyTypeContext, (Ins, fam (q[blist])), 
         ***          addAssumptions A nlist blist, read-reaction(L, I3)) 
  /\ I3 :: 'IPDLReaction .        
  ceq postTypeCheck L protocol {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} 
        in env
   =   
   (check (blist == blist')
    or-else fail('bounds 'mismatch 'for q, (at term I, include context))
   )
   and-then
     return {'family_indices:_bounds:_::=_ [I, I1, I2, I3]  : 'IPDLProtocol} 
     in env
  if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env 
  /\ q[blist] := read-familyName(L, I) 
  /\ blist' := read-bounds(L, I2)
  /\ I3 :: 'IPDLProtocol .
  ceq postTypeCheck L protocol  {'_::=_[I1, I2] : 'IPDLProtocol}
   in env =   
         (check ((chn cn) in Ins == false)
     or-else 
     fail ('cannot 'assign 'to 'an 'input 'channel
            , 
        (at term I1, include context)))
     and-then 
     (check (d :: IPDLType)
     or-else fail('unexpected 'type 'error , 
        (at term I1, include context)))
     and-then
     (check (t == d)
     and-then
     return {'_::=_[I1, I2] : 'IPDLProtocol}
     or-else fail('type 'mismatch 'for 'assignment ':
                  'channel 'has 'type 
                  (print IPDL term show-type(IPDL, typeToPre(t)))
                  'and 'reaction 'has 'type
                  (print IPDL term show-type(IPDL, typeToPre(d))), (at term I2, include context))
     )
     in env
  if cn  := read-cNameIndex(L, I1) 
  /\ aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env 
  /\ t := metaTypeInCtx env ('typeInCtx[upTerm(chn cn), upTerm(A), upTerm(Delta)])
       *** typeInCtx(chn cn, A, Delta) 
  /\ d := metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Delta), upTerm(emptyTypeContext), 
        upTerm((Ins, chn cn)), upTerm(A), 
        upTerm(read-reaction(L, I2)) 
                                 ]) 
    *** typeOf(Sigma, Delta, emptyTypeContext, Ins, A, read-reaction(L, I2)) 
  /\ I2 :: 'IPDLReaction .

  ceq postTypeCheck L protocol  {'_::=_[I1, I2] : 'IPDLProtocol}
   in env =   
         (check ((chn cn) in Ins == false)
     or-else 
     fail ('cannot 'assign 'to 'an 'input 'channel
            , 
        (at term I1, include context)))
     and-then 
     (check (d :: IPDLType)
     or-else fail('unexpected 'type 'error , 
        (at term I1, include context)))
     and-then
     (check (t == d)
     and-then
     return {'_::=_[I1, I2] : 'IPDLProtocol}
     or-else fail('type 'mismatch 'for 'assignment ':
                  'channel 'has 'type 
                  (print IPDL term show-type(IPDL, typeToPre(t)))
                  'and 'reaction 'has 'type
                  (print IPDL term show-type(IPDL, typeToPre(d))), (at term I2, include context))
     )
     in env
  if cn  := read-cNameIndex(L, I1) 
  /\ aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env
  /\ t := metaTypeInCtx env ('typeInCtx[upTerm(chn cn), upTerm(A), upTerm(Delta)])
       *** typeInCtx(chn cn, A, Delta) 
  /\ (whenCond --> R) ;; whenList := read-cases(L, env, I2)
  /\ d  := metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Delta), upTerm(emptyTypeContext), 
        upTerm((Ins, chn cn)), upTerm((A, whenCondToBoolTerm whenCond)), 
        upTerm(R) 
       ])
    *** typeOf(Sigma, Delta, emptyTypeContext, Ins, (A, whenCondToBoolTerm whenCond), R) 
  *** TODO: check other branches as well!
  /\ I2 :: 'WhenList .

  op type`check__declaredCNameIndex : IPDL TypeContext -> AnalysisAction{IPDL} .
  eq type check L Gamma declaredCNameIndex {I : 'CName}
     = return {I : 'CName} . *** check already made 
  ceq type check L Gamma declaredCNameIndex {'_`[_`][ I1, I2] : 'CNameIndex}
      in env
     = check 
        (metaOccurs env ('occurs___[upTerm( chn (q[nlist]) ), upTerm(Delta),  upTerm(A) ])) 
       and-then return {'_`[_`][ I1, I2] : 'CNameIndex}
       or-else
       check (metaIsElemB env ('isElemB[upTerm(q[nlist]), upTerm(Ins), upTerm(A)]) ) 
        and-then 
        return {'_`[_`][ I1, I2] : 'CNameIndex} 
       or-else fail ('read 'error, (at term I1, include context))         
       in env
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env
   /\ q := read-qid(I1)
   /\ nlist := read-natTerms(L, I2) .

  op type`check__validRead : IPDL TypeContext -> AnalysisAction{IPDL} .
  ceq type check L Gamma validRead {'cname[I] : 'CName}
     in env
     = (check (metaOccurs env ('occurs___[upTerm( chn read-qid(I)  ), upTerm(Delta),  upTerm(A) ])) 
       or-else fail('unknown 'channel, (at L term 'cname[I], include context)) 
       )
       and-then 
       ( check ((chn read-qid(I)) in Ins)
       and-then
        return {I : 'CName}
       or-else  fail(read-qid(I) 'is 'not 'an 'input 'channel, (at L term 'cname[I], include context)) 
       ) 
       in env 
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env . 
  ceq type check L Gamma validRead {I : 'CName}
     in env
     = (check(metaOccurs env ('occurs___[upTerm( chn read-qid(I)  ), upTerm(Delta),  upTerm(A) ]))
       or-else fail('unknown 'channel, (at L term 'cname[I], include context)) 
       )
       and-then 
       ( check ((chn read-qid(I)) in Ins)
       and-then
        return {I : 'CName}
       or-else  fail(read-qid(I) 'is 'not 'an 'input 'channel, (at L term 'cname[I], include context)) 
       ) 
       in env 
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env . 
  ceq type check L Gamma validRead {'_`[_`][ I1, I2] : 'CNameIndex}
      in env
     = check 
        (metaOccurs env ('occurs___[upTerm( chn (q[nlist])  ), upTerm(Delta),  upTerm(A) ]))
       and-then 
        ( check ( ( chn (q[nlist]) ) in Ins )
          and-then
          return {'_`[_`][ I1, I2] : 'CNameIndex}
          or-else 
          fail ('is 'not 'an 'input 'channel, (at term I1, include context))
        )
       or-else
       check (metaIsElemB env ('isElemB[upTerm(q[nlist]), upTerm(Ins), upTerm(A)]) )
        and-then 
        return {'_`[_`][ I1, I2] : 'CNameIndex}    
       or-else fail ('read 'error, (at term I1, include context))         
       in env
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env
   /\ q := read-qid(I1)
   /\ nlist := read-natTerms(L, I2) .

  op type`check__reaction : IPDL TypeContext -> AnalysisAction{IPDL} .
  *** no type checks for normal forms, they are generated so they have been checked!
  eq type check L Gamma reaction {'nf`(_`,_`)[I1, I2] : 'IPDLReaction}
    = return {'nf`(_`,_`)[I1, I2] : 'IPDLReaction} .
  eq type check L Gamma reaction {'preNF`(_`,_`)[I1, I2] : 'IPDLReaction} 
    = return {'preNF`(_`,_`)[I1, I2] : 'IPDLReaction} .
  eq type check L Gamma reaction {'`(_`) [I]: 'IPDLReaction} 
   = try {'`(_`) [type check L Gamma reaction I]: 'IPDLReaction} 
  .
  eq type check L Gamma reaction {'read_[I] : 'IPDLReaction} 
   =  try {'read_[
        type check L Gamma validRead (I)] : 'IPDLReaction
        } .
  eq type check L Gamma reaction {'read[I] : 'IPDLReaction} 
   =  try {'read[
        type check L Gamma validRead (I)] : 'IPDLReaction} .      
  ceq type check L Gamma reaction {'_:_<-_;_[I, T, I1, I2] : 'IPDLReaction} 
     in 
       env
   =
     check ( t == preToType(read-type(L, T)) ) 
      and-then 
       try {'_:_<-_;_[
           return I, 
           return T, 
           type check L Gamma reaction (I1), 
           type check L (Gamma (QI : t)) reaction (I2) ] : 'IPDLReaction
       } 
      or-else 
      fail ('type 'mismatch 'for 'reaction 
            'expecting (print IPDL term show-type(IPDL, read-type(L, T)))
            'and 'got 
            (print IPDL term show-type(IPDL, typeToPre(t)))
            , 
        (at term I1, include context))
      in 
       env  
  if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env 
  /\ t := metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Delta), upTerm(Gamma), 
        upTerm(Ins), upTerm(A), 
        upTerm(read-reaction(IPDL, I1)) 
        ])
      ***  typeOf(Sigma, Delta, Gamma, Ins, A, read-reaction(IPDL, I1))
  /\ QI := read-qid(I) .

  eq type check L Gamma reaction {'return_[I] : 'IPDLReaction} =
    return {'return_[I] : 'IPDLReaction} .
  
 var t1 t2 : IPDLType .

  ceq type check L Gamma reaction {'samp_`(_`)[I1, I2] : 'IPDLReaction}
     in env       
   = check ( d == t)
     and-then try {'samp_`(_`)[return I1, type check L Gamma expression I2] : 'IPDLReaction}
     or-else 
      fail ('type 'mismatch 'in 'distribution 'application 
            'expected (print IPDL term show-type(IPDL, typeToPre(d)))
            'and 'got (print IPDL term show-type(IPDL, typeToPre(t)))
            ,  
            (at L term I2, include context))
      in env
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env
   /\   d :=  domain read-qid(I1) Sigma
   /\   t :=  metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Gamma), upTerm(read-expression(IPDL, I2))])
         *** typeOf(Sigma, Gamma, read-expression(IPDL, I2)) 
   .
   ceq type check L Gamma reaction  {'if_then_else_[I, I1, I2] : 'IPDLReaction}  
    in env
       
   = (check (t == bool)
      or-else 
       fail ('expecting 'an 'expression 'of 'type 'bool 
             'and 'got (print IPDL term show-type(IPDL, typeToPre(t))), 
        (at term I, include context)))
     and-then 
      (check (t1 == t2)
      and-then        
       try {'if_then_else_[
           check L Gamma expression I, 
           check L Gamma reaction I1, 
           check L Gamma reaction I2] : 'IPDLReaction}
      or-else 
       fail ('reaction 'types 'do 'not 'match 
             'first 'type 'is (print IPDL term show-type(IPDL, typeToPre(t1)))
             'second 'type 'is (print IPDL term show-type(IPDL, typeToPre(t2))), 
        (at term I2, include context))
      )
      in env
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env /\
      t1 := metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Delta), upTerm(Gamma), 
        upTerm(Ins), upTerm(A), 
        upTerm(read-reaction(IPDL, I1)) 
       ])
         *** typeOf(Sigma, Delta, Gamma, Ins, A, read-reaction(IPDL, I1)) 
   /\ t2 :=  metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Delta), upTerm(Gamma), 
        upTerm(Ins), upTerm(A), 
        upTerm(read-reaction(IPDL, I1)) 
       ])
        *** typeOf(Sigma, Delta, Gamma, Ins, A, read-reaction(IPDL, I2))
   /\   t := metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Gamma), upTerm(read-expression(IPDL, I))])
       *** typeOf(Sigma, Gamma, read-expression(IPDL, I)) 
   .

   eq type check L Gamma reaction I = return I [owise] .
  
op type`check__natTerm : IPDL TypeContext -> AnalysisAction{IPDL} .
eq type check L Gamma natTerm {I : 'CId} = 
   return {I : 'CId} .
eq type check L Gamma natTerm {I : 'Nat} = 
   return {I : 'Nat} .
eq type check L Gamma natTerm {I : 'NatTerm} = 
   return {I : 'NatTerm} .

op type`check__natTerms : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq type check L Gamma natTerms {I : 'CId} 
  = return {I : 'CId} .
 eq type check L Gamma natTerms {I : 'Nat} 
  = return {I : 'Nat} .
 eq type check L Gamma natTerms {I : 'NatTerm} 
  = return {I : 'NatTerm} . 
 eq type check L Gamma natTerms {I : 'NatTermList} 
  = return {I : 'NatTermList} .  

op type`check__boolTerm : IPDL TypeContext -> AnalysisAction{IPDL} .
eq type check L Gamma boolTerm {I : 'BoolTerm} 
  = return {I : 'BoolTerm} .

op type`check__bound : IPDL TypeContext -> AnalysisAction{IPDL} .
eq type check L Gamma bound {I : 'Bound} 
  = return {I : 'Bound} .

op type`check__bounds : IPDL TypeContext -> AnalysisAction{IPDL} .
eq type check L Gamma bounds {I : 'Bound}
 = return {I : 'Bound} .
eq type check L Gamma bounds {I : 'BoundList}
 = return {I : 'BoundList} .

op type`check__whenCond : IPDL TypeContext -> AnalysisAction{IPDL} .
eq type check L Gamma whenCond {'otherwise.WhenCond : 'WhenCond} 
   = return {'otherwise.WhenCond : 'WhenCond} .
eq type check L Gamma whenCond {I : 'WhenCond}
   = return {I : 'WhenCond} [owise] .

op type`check__when : IPDL TypeContext -> AnalysisAction{IPDL} .
ceq type check L Gamma when {'_-->_[I1, I2] : 'When} in env
   = try {'_-->_[
       type check L Gamma whenCond (I1) in env, 
       type check L Gamma cases (I2) 
       in (pushAConfig
            (popAConfig env)
            (aConfig(pConfig(Sigma, Delta, P, Ins, Outs, (A, bts)), countb, contextb))
          )
      ] : 'When} 
if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env 
/\ bts := whenCondToBoolTerm(read-whenCond(L, I1)) .

var bt : BoolTerm .
var bts : Set{BoolTerm} .

op type`check__whenList : IPDL TypeContext -> AnalysisAction{IPDL} .
eq type check L Gamma whenList {'emptyWhen.WhenList : 'WhenList} 
   = return {'emptyWhen.WhenList : 'WhenList} .
eq type check L Gamma whenList {'`(_`) [I] : 'WhenList}
 = try {'`(_`) [type check L Gamma whenList I] : 'WhenList} .   
  ceq type check L Gamma whenList I 
   = type check L Gamma when I if I :: 'When  . 
  ceq type check L Gamma whenList {'_;;_[I1, I2] : 'WhenList}
      in env
   = try {'_;;_[
       type check L Gamma whenList (I1) in env, 
       type check L Gamma whenList (I2) 
       in (pushAConfig 
            (popAConfig env)
            (aConfig(pConfig(Sigma, Delta, P, Ins, Outs, (A, neg bt)), countb, contextb))
          )
      ] : 'WhenList} 
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env 
   /\ bt := whenListToBoolTerm(read-whenList(L, env, I1)) .

op type`check__cases : IPDL TypeContext -> AnalysisAction{IPDL} .
 ceq type check L Gamma cases I  
   = type check L Gamma reaction I if I :: 'IPDLReaction . 
  ceq type check L Gamma cases I
    = type check L protocol I if I :: 'IPDLProtocol .
  ceq type check L Gamma cases I 
   = type check L Gamma whenList I if I :: 'WhenList .  
  ceq type check L Gamma cases I 
   = type check L Gamma when I if I :: 'When .


  var d t : IPDLType .
  var deltaMap : Map{Qid, PairSetIO} .

  op type`check__expression : IPDL TypeContext -> AnalysisAction{IPDL} .
  eq type check L Gamma expression {'`(`).IPDLExpr : 'IPDLExpr} 
   = return {'`(`).IPDLExpr : 'IPDLExpr} .
  eq type check L Gamma expression {'True.IPDLExpr : 'IPDLExpr} 
   = return {'True.IPDLExpr : 'IPDLExpr} .
  eq type check L Gamma expression {'False.IPDLExpr : 'IPDLExpr} 
   = return {'False.IPDLExpr : 'IPDLExpr} .  
  eq type check L Gamma expression {'`(_`,_`)[I1, I2] : 'IPDLExpr} 
   = try {'`(_`,_`)[
         type check L Gamma expression (I1), 
         type check L Gamma expression (I2) 
      ] : 'IPDLExpr} .
  eq type check L Gamma expression  {'fst_[I] : 'IPDLExpr} 
   = try  {'fst_[
      type check L Gamma expression (I)
      ] : 'IPDLExpr} .
  eq type check L Gamma expression  {'snd_[I] : 'IPDLExpr} 
   = try  {'snd_[
      type check L Gamma expression (I)
      ] : 'IPDLExpr} .    

  ceq type check L Gamma expression {'_`(_`)[I1, I2] : 'IPDLExpr}
     in env
   = check (d == t)
     and-then try {'_`(_`)[return I1, check L Gamma expression I2] : 'IPDLExpr}
     or-else
      fail ('type 'mismatch 'in 'function 'application 'for read-qid(I1)
            'expected (print IPDL term show-type(IPDL, typeToPre(d)))
            'and 'got (print IPDL term show-type(IPDL, typeToPre(t)))
            ,
            (at term I2, include context))
      in
       env
   if aConfig(pConfig(Sigma, Delta, P, Ins, Outs, A), countb, contextb) := getAConfig env
   /\ d := domain read-qid(I1) Sigma
   /\ t := metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Gamma), upTerm(read-expression(IPDL, I2))])
         *** typeOf(Sigma, Gamma, read-expression(IPDL, I2)) 
   . 
  ceq type check L Gamma expression {I : 'VId} = 
     check (q elem Gamma) 
      and-then return {I : 'VId}
      or-else fail ('unknown 'variable q, (at term I, include context))
   if q := read-qid(I)  
  .

  var PS : TypeContext .

  op check_familyNameBound : IPDL -> AnalysisAction{IPDL} .
  eq check L familyNameBound {'_`[_`][I1, I2] : 'BasicFamilyNameBound}
   = try {'_`[_`][
        return I1, 
        check L emptyTypeContext boundedIndexList (I2)] : 'BasicFamilyNameBound} .
  eq check L familyNameBound {'_and_[I1, I2] : 'FamilyNameBound} 
   = try  {'_and_[
      check L familyNameBound (I1), 
      check L familyNameBound (I2)] : 'FamilyNameBound} .    
 
  op check_familyName : IPDL -> AnalysisAction{IPDL} .
  eq check L familyName {'_`[_`][I1, I2] : 'BasicFamilyName} =
     try {'_`[_`][
        return I1, 
        check L emptyTypeContext bounds (I2)] : 'BasicFamilyName} .
  eq check L familyName {'_and_[I1, I2] : 'FamilyName} 
   = try  {'_and_[
      check L familyName (I1), 
      check L familyName (I2)] : 'FamilyName} .    
   
  op adjust_cName : IPDL -> AnalysisAction{IPDL} .
  eq adjust L cName {'cname[I] : 'CName} =
     return {I : 'CName} 
  .  
  eq adjust L cName I = return I [owise] .  

***(   eq adjust L cName  {'__[I, S] : 'CName}
  = try {'__[
        adjust L cName (I),
        check L cname-scripts(S)
      ] : 'CName} . )

  op adjust_pName : IPDL -> AnalysisAction{IPDL} .
  eq adjust L pName {'pname[I] : 'PName} =
     return {I : 'PName}
  .    
  
   var q1 q2 : Qid .
   var cnb1 cnb2 : CNameBound .
   var cnbl : List{CNameBound} .
   var nt : NatTerm .
   var qpl : QidPairList .
   var cn : ChannelName .
   var P' : Protocol .
   var fn1 : FamilyName .

  op proofProtocol__ : Protocol Proof{IPDL} -> Protocol .
  eq proofProtocol P (Proof[IPDL]{merge cases for cnb1})
   = keepOne P cnb1  .
   eq proofProtocol P (Proof[IPDL]{rename qpl in cnb1})
   = keepOne P cnb1  . 
  eq proofProtocol P (Proof[IPDL]{merge case q1 = nt with otherwise for cnb1})
   = keepOne P cnb1  . 
  eq proofProtocol P (Proof[IPDL]{turn neg into otherwise for cnb1})
   = keepOne P cnb1  . 
  eq proofProtocol P (Proof[IPDL]{turn otherwise into neg for cnb1})
   = keepOne P cnb1  .   
  eq proofProtocol P (Proof[L]{fold (chn q1) into (chn q2)}) =
     keepTwo P (chn q1) (chn q2) . 
  eq proofProtocol P (Proof[L]{subst cnb1 into cnb2}) =
     keepTwo P cnb1 cnb2 .
  eq proofProtocol P (Proof[L]{subst cnb1 into cnb2 at q}) =
     keepTwo P cnb1 cnb2 .    
  eq proofProtocol P (Proof[L]{subst branch whenCond of cnb1 into cnb2}) =
     keepTwo P cnb1 cnb2 .
  eq proofProtocol P (Proof[L]{subst branch whenCond of cnb1 into cnb2 at q}) =
     keepTwo P cnb1 cnb2 .       
  eq proofProtocol P (Proof[L]{drop read cnb1 from cnb2}) =
     keepTwo P cnb1 cnb2 .  
  eq proofProtocol P (Proof[L]{drop read branch whenCond of cnb1 from cnb2}) =
     keepTwo P cnb1 cnb2 .       
  eq proofProtocol P (Proof[L]{absorb cnb1}) =
     keepOne P cnb1  . 
   eq proofProtocol P (Proof[L]{group-absorb group fn1}) =
     keepOne P (fam fn1)  .     
  eq proofProtocol P Proof[L]{compose cnb1 with cnb2 in group}    
   = keepTwo P cnb1 cnb2 .
  eq proofProtocol P (Proof[L]{combine cnb1}) =
     keepOne P cnb1  .
  eq proofProtocol P (Proof[L]{combine cnb1 into families}) =
     keepOne P cnb1  .    
  eq proofProtocol P (Proof[L]{split cnb1 on first index}) =
     keepOne P cnb1  . 
  eq proofProtocol P (Proof[L]{split cnb1 on first index inside group fn1}) =
     keepOne P (fam fn1)  .               
  eq proofProtocol P (Proof[L]{split cnb1 on second index}) =
     keepOne P cnb1  .
  eq proofProtocol P (Proof[L]{call q}) =
     P .  
  eq proofProtocol P (Proof[L]{ungroup cnb1}) =
     keepOne P cnb1 .     
  eq proofProtocol P (Proof[L]{unsplit cn}) =
     P  .
  eq proofProtocol P (Proof[L]{rename variables qpl of cnb1}) = 
     P .  
  eq proofProtocol P (Proof[IPDL]{group cnbl in q indices: nlist bounds: blist}) =
     keepAll P cnbl .
  eq proofProtocol P (Proof[L]{restructure P'}) =
     P .      

  op proofLHS_ : Proof{IPDL} -> QidList .
  *** TODO: add for absorb
  *** TODO: add for combine
  *** TODO: add for dropSubsume
  *** TODO: add for otherwisetoneg, negtootherwise
  *** TODO: mergeCases, merge with otherwise
  *** TODO: add for alpha
  *** TODO: add for split!
  eq proofLHS(Proof[L]{absorb (chn q1)}) =
     tokenize("newNF(< c : T > ltq, P || (c ::= R))") .
  eq proofLHS (Proof[L]{fold (chn q1) into (chn q2)}) = 
     tokenize("(c ::= R) || (o ::= nf((x : T <- read c) ..., S))") .
  eq proofLHS (Proof[L]{subst (chn q1) into (chn q2)}) = *** TODO: case distinction and correct!
     tokenize("(c ::= R) || (o ::= nf((x : T <- read c) ..., S))") .   


  endm

********************************************************************************

fmod IPDL/PRINTING is
  protecting PRINTING { IPDL } .
  protecting IPDL/SHOW .
  protecting MAP{Qid, Int} .

  vars D E : Decl{IPDL} .
  var  DL : DeclList{IPDL} .
  var L : IPDL .
  var P P1 P2 : Protocol .
  var T : IPDLType .
  var R : Reaction .
  var QL : QidList .
  var Q : Qid .
  var flag : Bool .
  var ltq : TypedCNameList .
  var Sigma : Signature .
  var Delta : ChannelContext .
  var O : Set{CNameBound} .

  var cn : ChannelName .
  
  op print : DeclList{IPDL} -> QidList .
  eq print((nil).DeclList{IPDL}) = 'no 'declarations .
  eq print(D) = print IPDL term show-decl(D) .
  eq print(D E DL) = print(D) '\n print(E DL) .

  var ids : List{NatTerm} .
  var bds : List{Bounds} .
  var cases : Cases .
  var q : Qid .
  var f g : Map{Qid, Int} .

  var nw nl nl1 nl2 n1 n2 : Int .
  var A : Set{BoolTerm} .
  var nt : NatTerm .

  *** helpers

  op pointwisePlus : Map{Qid, Int} Map{Qid, Int} -> Map{Qid, Int} .
  eq pointwisePlus(empty, g) = g .
  eq pointwisePlus((f, q |-> n1), (g, q |-> n2)) 
   = (q |-> (n1 defPlus n2), pointwisePlus(f, g)) .
  eq pointwisePlus((f, q |-> n1), g) 
   = (q |-> n1, pointwisePlus(f, g)) .

  op pointwiseMax : Map{Qid, Int} Map{Qid, Int} -> Map{Qid, Int} .
  eq pointwiseMax(empty, g) = g .
  eq pointwiseMax((f, q |-> n1), (g, q |-> n2)) 
   = (q |-> defMax(n1, n2), pointwiseMax(f, g)) .
  eq pointwiseMax((f, q |-> n1), g) 
   = (q |-> n1, pointwiseMax(f, g)) . 

  op printBoundsOld : Int Int -> QidList .
  eq printBoundsOld(nw, nl) = 
     'width: printIntExp(nw) '\n 
     'length: printIntExp(nl) .

 var cb1 cb2 cb3 cb4 : ProtocolBound .
 var whenCond1 whenCond2 : WhenCond .
 var blist1 blist2 : List{Bounds} .

 op printBounds : ComplexityBound ComplexityBound -> QidList .
  eq printBounds(uncondBound f, uncondBound g)
   = printFuns(f, g) . 
  eq printBounds(singleBound whenCond1 cb1, 
                 singleBound whenCond2 cb3)
   = printBounds(cb1, cb3) . 
  eq printBounds((singleBound whenCond1 cb1) cb2, 
                 (singleBound whenCond2 cb3) cb4)
   = printBounds(cb1, cb3) printBounds(cb2, cb4) .
  eq printBounds(famBound blist1 cb1, famBound blist2 cb2 )
   = printBounds(cb1, cb2) .    
   
  op printFuns : Map{Qid, Int} Map{Qid, Int} -> QidList .
  eq printFuns(empty, g) = nil .
  eq printFuns( (f, q |-> nl), g ) =
     'indistinguishability 'assumption q ': '\n 
     'count: 
     printSortedIntList(sortTimes nl) '\n 
     'context:
     printSortedIntList(sortTimes (g[q])) '\n
     printFuns(f, g)  .  

  op printCommaSep : Int -> QidList .
  eq printCommaSep(max(nl2, nw)) = 
     printCommaSep(nl2) '\s '`, printCommaSep(nw) .
  eq printCommaSep(defMax(nl2, nw)) = 
     printCommaSep(nl2) '`, printCommaSep(nw) .   
  eq printCommaSep(nl1) = printIntExp(nl1) [owise] . 

  sort SortedIntList .
  subsort Int < SortedIntList .
  op emptySIL : -> SortedIntList [ctor] .
  op _::_ : SortedIntList SortedIntList -> SortedIntList [assoc ctor id: emptySIL] . 

  op printSortedIntList_ : SortedIntList -> QidList .
  eq printSortedIntList emptySIL = nil .
  eq printSortedIntList nl1 = printIntExp(nl1) .
  eq printSortedIntList (nl1 :: intL) =
     printIntExp(nl1) '+ printSortedIntList intL . 
  var intL : SortedIntList .

  op sortTimes_ : Int -> SortedIntList .
  eq sortTimes (nl1 + nl2) = 
     sortInsert nl2 (sortTimes nl1) .
  eq sortTimes nl1 = nl1 [owise] .

  op sortInsert__ : Int SortedIntList -> SortedIntList .
  eq sortInsert nl1 emptySIL  = nl1 .
  eq sortInsert (nl1 + nl2) intL =
     sortInsert nl1 (sortInsert nl2 intL) .
  eq sortInsert nl1 (nl2 :: intL) = 
   if hasMoreTimes nl1 nl2 
    then nl1 :: nl2 :: intL 
    else nl2 :: (sortInsert nl1 intL) 
   fi .

  op hasMoreTimes__ : Int Int -> Bool .
  ceq hasMoreTimes nl1 nl2 = 
   if n1 == n2 then
   countEvals(nl2) < countEvals(nl1) 
   else 
   n2 < n1 
   fi
   if n1 := countTimes(nl1)
   /\ n2 := countTimes(nl2) .   

  var n3 n4 : Int .
 
  op countTimes_ : Int -> Int .
  eq countTimes (nl1 * nl2) = 1 + countTimes nl1 + countTimes nl2 .
  ceq countTimes (nl1 + nl2) =
     if n1 < n2 then n2 else n1 fi 
  if n1 := countTimes(nl1) 
  /\ n2 := countTimes(nl2)
  .
  ceq countTimes (defMax(nl1, nl2)) =  
     if n1 < n2 then n2 else n1 fi 
  if n1 := countTimes(nl1) 
  /\ n2 := countTimes(nl2) .
  ceq countTimes (max(nl1, nl2)) =  
     if n1 < n2 then n2 else n1 fi 
  if n1 := countTimes(nl1) 
  /\ n2 := countTimes(nl2) .
  eq countTimes nl1 = 0 [owise] .  

  op countEvals_ : Int -> Int .
  eq countEvals (eval(A, q)) = 1 .
  ceq countEvals (max(nl1, nl2)) = 
    if n1 < n2 then n2 else n1 fi
  if n1 := countEvals(nl1) 
  /\ n2 := countTimes(nl2) .
  eq countEvals (nl1 + nl2) = countEvals(nl1) + countEvals(nl2) .
  eq countEvals (nl1 * nl2) = countEvals(nl1) + countEvals(nl2) . 
  eq countEvals nl1 = 0 [owise] . 

***     op printIntExp : Int -> QidList .
***   eq printIntExp(defMax(nl1, nl2)) = 
***      'max '`( printIntExp(nl1) '`, printIntExp(nl2) '`) .
***   eq printIntExp(max(nl1, nl2)) = 
***       'max '`( printCommaSep(nl1) '`, printCommaSep(nl2) '`) .
***   eq printIntExp(nl1 defDiff nl2 ) = 
***    '-
***    '\n '\s
***    printBracketed(false, nl1) 
***    '\n '\s 
***    printBracketed(false, nl2) . 
***   eq printIntExp(nl1 defTimes nl2 ) = 
***     '* '\n '\s printBracketed(true, nl1) '\n  '\s  printBracketed(true, nl2) . 
***   eq printIntExp(sizeIPDLT(typeName q)) = '| q '| .  
***   eq printIntExp(nl1 + nl2) = 
***      '+ '\n '\s printBracketed(true, nl1) '\n  '\s printBracketed(true, nl2) .
***   eq printIntExp(nw * nl) = 
***       '* '\n '\s  printBracketed(true, nw) '\n '\s   printBracketed(true, nl) .
***   eq printIntExp(eval(A, q)) = q .
***   eq printIntExp(sizeIPDLP(Sigma, Delta,  A, protocolRef(q))) = '| q '| .
***   eq printIntExp(maxValue(q, nt)) = 'maxValue '`( q '`, (print IPDL term show-natTerm(IPDL, nt)) '`) .
***   eq printIntExp(nw) = qid(nw) [owise] .

   var nlist : List{NatTerm} .

  op printWhenCond : WhenCond -> QidList . 
  eq printWhenCond(otherwise) = 'otherwise .
  eq printWhenCond(when bt) = 'when listBoolTerm(bt) . 

  var whenCond : WhenCond .
  var ntlist : List{NatTerm} .
  var blist : List{Bounds} .
  var q1 q2 q3 : Qid .
  var nt1 nt2 nt3 : NatTerm .
  var bt : BoolTerm . 

  op printIntExp : Int -> QidList .
  eq printIntExp(savedSetCard 
      (qidAsTerm q1 qidAsTerm q2 qidAsTerm q3)
      (bound nt1 bound nt2 bound nt3)
      whenCond) =
     '| '`{ 
      '`(  listNatTerm(qidAsTerm q1) '`, '\s
           listNatTerm(qidAsTerm q2) '`, '\s
           listNatTerm(qidAsTerm q3)  '`) '\s 's.t. 
      q1 '<  listNatTerm(nt1) '`, '\s
      q2 '<  listNatTerm(nt2) '`, '\s
      q3 '<  listNatTerm(nt3) '`, '\s
      printWhenCond(whenCond) '`} '|  .
  eq printIntExp(defMax(nl1, nl2)) =
   'max '`( printCommaSep(nl1) '`, '\s printCommaSep(nl2) '`) . 
   *** 'max '`( printIntExp(nl1) '`, printIntExp(nl2) '`) .
  eq printIntExp(max(nl1, nl2)) = 
   'max '`( printCommaSep(nl1) '`, '\s printCommaSep(nl2) '`) . 
  ***  'max '`( printIntExp(nl1) '`, printIntExp(nl2) '`) .
  eq printIntExp(nl1 defDiff nl2 ) = 
   printBracketed(false, nl1) '- printBracketed(false, nl2) . 
  eq printIntExp(nl1 defTimes nl2 ) = 
     printBracketed(true, nl1)  '*  printBracketed(true, nl2) . 
  eq printIntExp(sizeIPDLT(typeName q)) = '| q '| .  
  eq printIntExp(nw + nl) = printBracketed(false, nw) '+ printBracketed(false, nl) .
  *** eq printIntExp((nl1 + nl2) * nw) = printIntExp(nw * nl1) '+ printIntExp(nw * nl2) .
  *** eq printIntExp(nw * eval(A, q)) = printIntExp(nw) '* printIntExp(eval(A, q)) .
  eq printIntExp(nw * nl) =  printBracketed(true, nw)  '*  printBracketed(true, nl) .
  eq printIntExp(eval(A, q)) = q .
  eq printIntExp(sizeIPDLP(Sigma, Delta,  A, nlist,protocolRef(q))) = '| q '| .
  eq printIntExp(maxValue(q, nt)) = 'maxValue '`( q '`, (print IPDL term show-natTerm(IPDL, nt)) '`) .
  eq printIntExp(nw) = qid(nw) [owise] .

  var whichOp : Bool . *** True for * and defTimes , False for + and -, defDiff

  op printBracketed : Bool Int -> QidList .
  eq printBracketed(whichOp, nl1) =
   if isBasic(whichOp, nl1)
      then printIntExp(nl1) 
      else '`( printIntExp(nl1) '`)
   fi
  .  

  op isBasic : Bool Int -> Bool .
  eq isBasic(true, nl1 defDiff nl2) = false .
  eq isBasic(false, nl1 defDiff nl2) = true .
  eq isBasic(true, nl1 defTimes nl2) = false .
  eq isBasic(false, nl1 defTimes nl2) = true .
  eq isBasic(true, nl1 * nl2) = true .
  eq isBasic(false, nl1 * nl2) = true .
  eq isBasic(true, nl1 + nl2) = false .
  eq isBasic(false, nl1 + nl2) = true .
  eq isBasic(whichOp, nl) = true [owise] .
  
  op printCName_ : ChannelName -> QidList .
  eq printCName q = q .
  eq printCName (q[ids]) = q '`[ (print IPDL term show-natTerms(IPDL, ids)) '`] .

  var aQid : Qid .

  op printProtocol : Protocol Bool QidList -> QidList .
  eq printProtocol(protocolRef(aQid), flag, Q QL ) 
   = if flag then aQid '\o else Q aQid '\o fi .
  eq printProtocol(emptyProtocol, flag, Q QL) 
   = if flag then 'emptyProtocol '\o else Q 'emptyProtocol '\o fi .
  eq printProtocol(cn ::= cases, flag, Q QL) 
   = if flag 
     then (printCName cn) '::= (print IPDL term show-cases(IPDL, cases)) '\o 
     else Q (printCName cn) '::= (print IPDL term show-cases(IPDL, cases)) '\o 
     fi .
  eq printProtocol(family cn[bds] ids bds ::= cases, flag, Q QL) 
   = if flag 
     then 'family (print IPDL term show-familyName(IPDL, cn[bds])) 
          'indices: (print IPDL term show-natTerms(IPDL, ids)) 
          'bounds: (print IPDL term show-bounds(IPDL, bds))
          '::= (print IPDL term show-cases(IPDL, cases)) '\o 
     else Q 'family (print IPDL term show-familyName(IPDL, cn[bds])) 
          'indices: (print IPDL term show-natTerms(IPDL, ids)) 
          'bounds: (print IPDL term show-bounds(IPDL, bds))
          '::= (print IPDL term show-cases(IPDL, cases)) '\o
     fi .
  eq printProtocol(newfamily q[bds] ids bds : T in P, flag, Q QL) 
   = if flag 
     then 
      'newfamily (print IPDL term show-familyName(IPDL, q[bds])) 
          'indices: (print IPDL term show-natTerms(IPDL, ids)) 
          'bounds: (print IPDL term show-bounds(IPDL, bds))
           ': (print IPDL term show-type(IPDL, typeToPre(T))) 'in '\n 
      printProtocol(P, flag, Q QL) '\o 
     else  
      Q 'newfamily (print IPDL term show-familyName(IPDL, q[bds])) 
          'indices: (print IPDL term show-natTerms(IPDL, ids)) 
          'bounds: (print IPDL term show-bounds(IPDL, bds))
           ': (print IPDL term show-type(IPDL, typeToPre(T))) 'in '\n 
      printProtocol(P, flag, Q QL) '\o 
     fi 
       .   
  eq printProtocol(new cn : T in P, flag, Q QL) 
   = if flag 
     then 
      'new cn ': (print IPDL term show-type(IPDL, typeToPre(T))) 'in '\n 
      printProtocol(P, flag, Q QL) '\o 
     else  
      Q 'new cn ': (print IPDL term show-type(IPDL, typeToPre(T))) 'in '\n 
      printProtocol(P, flag, Q QL) '\o 
     fi 
       .
  eq printProtocol(P1 || P2, flag, QL) = colorPrintProtocol(P1 || P2, QL) .
  eq printProtocol(newNF(ltq, P), flag, Q QL) = 
     if flag 
     then 
     'newNF '`( (print IPDL term show-typedCNameList(IPDL, ltq)) '`, 
     '\n printProtocol(P, flag, Q QL) '`) '\o
     else 
     Q 'newNF '`( (print IPDL term show-typedCNameList(IPDL, ltq)) '`, 
     '\n printProtocol(P, flag, Q QL) '`) '\o
     fi 
     .

  op colorPrintProtocol : Protocol QidList -> QidList .
  eq colorPrintProtocol(P1 || P2, Q QL) = 
      '`( printProtocol(P2, false, Q QL) '\n '`) '|| '\n 
      printProtocol(P1, false, QL Q) 
  . 

endfm

********************************************************************************

mod IPDL/PARSING-&-PRINTING is
  protecting IPDL/PARSING .
  protecting IPDL/PRINTING .
endm

********************************************************************************

***(
smod EXECUTE is
 protecting STRATS .

 ops  xorF flipF : -> SigElem .
 eq xorF = 'xor : (bool * bool) ~> bool .
 
 eq flipF = 'flip : unit ~>> bool .
 
 op sig : -> Signature .
 eq sig = xorF flipF .
 
 op delta : -> ChannelContext .
 eq delta = 
    (chn 'In :: bool) 
    (chn ('LeakCtxt ^^ 'Alice .. 'adv) :: bool)
 .

  var x y z : Qid . 
 var Sigma : Signature .
 var Delta : ChannelContext .
 var Gamma : TypeContext .
 var Ins Outs : Set{CNameBound} .
 var A : Set{BoolTerm} .
 var cn f : ChannelName .
 var pConf : ProtocolConfig .
 var P : Protocol .
 var T : IPDLType .
  
  crl [test] :
    rConfig(Sigma, Delta, Gamma, return True , Ins, A, T)
     => 
    rConfig(Sigma, Delta, Gamma, return False, Ins, A, T)
  if T == bool  
  .  
 
  ***(

  when applyTest has no arguments

  red metaSrewrite(upModule('EXECUTE, false), upTerm(pConfig(emptySig, chn 'c :: bool , 
  'c ::= nf(emptyBRList, return True), empty, chn 'c, empty)), 'applyTest[[empty]], breadthFirst, 0) .

  )

  strat applyTest : ChannelName @ ProtocolConfig .
  
  sd applyTest(cn) :=
             applyTestNF(cn)
     or-else applyTestPre(cn)
  .

  strat applyTestPre : ChannelName @ ProtocolConfig .
  sd applyTestPre(cn) :=
   match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyTestPre(cn)}
    : matchrew pConf s.t. pConfig(Sigma, Delta, P, Ins, Outs, A) := pConf by pConf
       using (  
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                        P1:Protocol <- keepOne P (chn cn)]{ 
               CONG-REACT[o:ChannelName <- cn]
                { cong-pre-nf{test} ;
                  try (pre2Nf)}
                        }
        or-else  CONG-REACT[o:ChannelName <- cn]
                { cong-pre-nf{test} ;
                  try (pre2Nf)} )                 
  .

  strat applyTestNF : ChannelName @ ProtocolConfig .
  sd applyTestNF(cn) :=
   match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyTestNF(cn)}
    : matchrew pConf s.t. pConfig(Sigma, Delta, P, Ins, Outs, A) := pConf by pConf
       using (  
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                        P1:Protocol <- keepOne P (chn cn)]{ 
               CONG-REACT[o:ChannelName <- cn]
                { cong-nf{test}}
                        }
        or-else  CONG-REACT[o:ChannelName <- cn]
                { cong-nf{test} }
            )                 
  .

  strat symTest @ ProtocolConfig .
  sd symTest :=
     matchrew pConf s.t. pConfig(Sigma, Delta, P, Ins, Outs, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- Outs,
       P1:Protocol <- P
        ]
        { idle
        }                 
        
  .

  op real : -> Protocol .
  eq real = 
    new 'Key : bool in
    new 'Ctxt : bool in
    (
     ('Key ::= nf(emptyBRList, samp ('flip < () >)) ) 
     || 
     ('Ctxt ::= 
       nf( ('m : bool <- read 'In)
            'k : bool <- read 'Key,
            return (ap 'xor pair('m, 'k))
               )
     )
     ||
     ('LeakCtxt ^^ 'Alice .. 'adv ::= 
       nf( 'c : bool <- read 'Ctxt ,
           return 'c)  
     )
    ) 
         
  .

  crl [flipInvariantXorFixedNew]:
    rConfig(Sigma:Signature,
            Delta:ChannelContext,
            Gamma:TypeContext (x : typeName 'bool),
            y : typeName 'bool <- samp ('flip < () >) ; return (ap 'xor pair(x, y)),
            Ins:Set{CNameBound},
            A:Set{BoolTerm},
            T:IPDLType)
     =>
     rConfig(Sigma:Signature,
            Delta:ChannelContext,
            Gamma:TypeContext (x : typeName 'bool),
            samp ('flip < () >),
            Ins:Set{CNameBound},
            A:Set{BoolTerm},
            T:IPDLType)
     if T:IPDLType == bool .

endsm 
***
red metaSrewrite(upModule('EXECUTE, false), 
    upTerm( pConfig(
         ( 'xor : (bool * bool) ~> bool)('flip : unit ~>> bool), 
         (chn 'In :: bool) 
         (chn ('LeakCtxt ^^ 'Alice .. 'adv) :: bool), 
         new 'Key : bool in
    new 'Ctxt : bool in
    (
     ('Key ::= nf(emptyBRList, samp ('flip < () >)) ) 
     || 
     ('Ctxt ::= 
       nf( ('m : bool <- read 'In)
            'k : bool <- read 'Key,
            return (ap 'xor pair('m, 'k))
               )
     )
     ||
     ('LeakCtxt ^^ 'Alice .. 'adv ::= 
       nf( 'c : bool <- read 'Ctxt ,
           return 'c)  
     )
    ) , 
         chn 'In, 
         chn ('LeakCtxt ^^ 'Alice .. 'adv), 
         empty)), 
         'sugar-newNF[none]{empty} ; 'moveNewToFront[[empty]] ; 
         'subst[[upTerm(chn 'Key), upTerm(chn 'Ctxt) ]], breadthFirst, 0) .

)  

************

smod MYTEST is
 pr BASEGMWN .
 pr STRATS .
 pr IPDL/PARSING-&-PRINTING .
 pr IPDL/ENV .

endsm 


