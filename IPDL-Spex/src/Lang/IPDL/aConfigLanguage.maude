***( SpeX/Lang/IPDL

  This file is part of the SpeX-languages suite.

  Copyright : (C) 2021, 2022 Simion Stoilow Institute of Mathematics
              of the Romanian Academy (IMAR)
  License   : GNU General Public License v2.0 or later (GPL-2.0-or-later)
  Author    : Ionut Tutu <Ionut.Tutu@imar.ro>

)

sload ../../Language.maude
sload ./Data.maude
sload ./strategies.maude

sload ../../BaseGMWN.maude

********************************************************************************

fmod IPDL/ENV is
  protecting PROTOCOL-CONFIG .
  protecting MAP{Qid, Protocol} .
  protecting IPDL/DECL .
  protecting GRAMMAR .
  protecting SET{TypeContextElem} . 
  protecting LIST{ApproxEqConfig} .
  protecting ATERM/READ .
  protecting MAP{Qid, PairSetIO} .
  
  var L : IPDL .
  var QIS QIS' : QidSet .
  var QIL : QidList .
  var q : Qid .
  vars I I1 I2 VS DT CT IT RT1 RT2 : ATerm .
  var aConf aConf' : ApproxEqConfig .
  var Sigma : Signature .
  var Delta : ChannelContext .
  var Gamma Gamma' : TypeContext .
  var Ins Outs : Set{CNameBound} .
  var A : Set{BoolTerm} .
  var P P' : Protocol .
  var R1 R2 : Reaction .
  var T1 T2 : IPDLType . 
  var t1 t2 : IPDLPreType .
  var protMap protMap' : Map{Qid, Protocol} .
  var cnb : CNameBound .
  var deltaMap deltaMap' : Map{Qid, PairSetIO} .
  var nw : Width .
  var nl : Length .

  var PCL1 PCL2 : List{ApproxEqConfig} .

 sort Env .
  op buildEnv_______ : 
      List{ApproxEqConfig}  *** for applying the rules, will be built by declarations
      Map{Qid, PairSetIO}   *** save all declared Deltas, as pairs Ins, Delta
      Map{Qid, Protocol}    *** save declared protocols
      Module                *** for storing the assumptions and their generated strategies
      Set{TypeContextElem}  *** for variables occuring in reactions and/or gamma in rules
      QidSet                *** names of assumptions to avoid duplicates
      TypeContext           *** for parameters, e.g. N : Nat, C : Circuit etc.
      *** Set{Qid}          *** for variables occuring in Delta in rules
      -> Env [ctor frozen] .
 
  var env : Env .
  var m m' : Module .
  var TCS TCS'  : Set{TypeContextElem} .
  var PS PS' : TypeContext .

  op getDeltaMap_ : Env -> Map{Qid, PairSetIO} .
  eq getDeltaMap (buildEnv PCL1 deltaMap protMap m TCS QIS PS) = deltaMap .

  op setDeltaMap__ : Env Map{Qid, PairSetIO} -> Env .
  eq setDeltaMap (buildEnv PCL1 deltaMap protMap m TCS QIS PS) deltaMap' 
   = (buildEnv PCL1 deltaMap' protMap m TCS QIS PS) .
  
  op getEnvParams_ : Env -> TypeContext .
  eq getEnvParams (buildEnv PCL1 deltaMap protMap m TCS QIS PS) = PS .

  op setEnvParams__ : Env TypeContext -> Env .
  eq setEnvParams (buildEnv PCL1 deltaMap protMap m TCS QIS PS) PS' = 
                   buildEnv PCL1 deltaMap protMap m TCS QIS PS' .

  op getModule_ : Env -> Module .
  eq getModule (buildEnv PCL1 deltaMap protMap m TCS QIS PS) = m .

  op setModule__ : Env Module -> Env .
  eq setModule (buildEnv PCL1 deltaMap protMap m TCS QIS PS) m' = 
                buildEnv PCL1 deltaMap protMap m' TCS QIS PS .

  op getAConfig_ : Env -> ApproxEqConfig .
  eq getAConfig (buildEnv (aConf PCL1) deltaMap protMap m TCS QIS PS) = aConf .

  op setAConfig__ : Env ApproxEqConfig -> Env .
  eq setAConfig (buildEnv (aConf PCL1) deltaMap protMap m TCS QIS PS) aConf'
   = buildEnv (aConf' PCL1) deltaMap protMap m TCS QIS PS .

  op getPMap_ : Env -> Map{Qid, Protocol} .
  eq getPMap (buildEnv PCL1 deltaMap protMap m TCS QIS PS) = protMap .

  op setPMap__ : Env Map{Qid, Protocol} -> Env .
  eq setPMap (buildEnv PCL1 deltaMap protMap m TCS QIS PS) protMap' = 
              buildEnv PCL1 deltaMap protMap' m TCS QIS PS .

  op setAssums__ : Env QidSet -> Env .
  eq setAssums (buildEnv PCL1 deltaMap protMap m TCS QIS PS) QIS' = 
                buildEnv PCL1 deltaMap protMap m TCS QIS' PS .

  op getAssums_ : Env -> QidSet .
  eq getAssums (buildEnv PCL1 deltaMap protMap m TCS QIS PS) = QIS .

  op setEnvVars__ : Env Set{TypeContextElem} -> Env .
  eq setEnvVars (buildEnv PCL1 deltaMap protMap m TCS QIS PS) TCS' = 
                 buildEnv PCL1 deltaMap protMap m TCS' QIS PS .

  op getEnvVars_ : Env -> Set{TypeContextElem} .
  eq getEnvVars (buildEnv PCL1 deltaMap protMap m TCS QIS PS) = TCS .

  op findProtocolInEnv__ : Env Qid -> Protocol .
  eq findProtocolInEnv (buildEnv PCL1 deltaMap protMap m TCS QIS PS) q = 
     if $hasMapping(protMap, q) then protMap[q] else emptyProtocol fi .

  op findDeltaInEnv__ : Env Qid -> ChannelContext .
  eq findDeltaInEnv  (buildEnv PCL1 deltaMap protMap m TCS QIS PS) q = 
     if $hasMapping(deltaMap, q) then toChannelContext (deltaMap[q]) else emptyChannelCtx fi .   
     

  op emptyEnv : -> Env .
  eq emptyEnv = buildEnv emptyAConfig empty empty 
  (smod 'TEST is
    protecting 'STRATS .
    sorts none . 
    none none none none 
    *** rl strat sd
    none none none endsm
  ) empty none emptyTypeContext .
endfm

fmod IPDL/LANGUAGE is
  protecting IPDL/LID .
  protecting IPDL/ENV .
  protecting GRAMMAR .
  protecting PROTOCOL .

  op grammar : IPDL -> Grammar .
  eq grammar(IPDL)
   = grammar 'IPDL/Syntax is
      'TopProof 
         ::=
            "start with _ over _" : 'PName 'DName [none]
          | "merge cases for _" : 'CNameBound [none] 
          | "merge case _ = _ with otherwise for _ " : 'CName 'NatTerm 'CNameBound [none]  
          | "absorb _" : 'CNameBound [none]
          | "rename _ in _" : 'QidPairList 'CNameBound [none]
          | "rename variables _ of _" : 'QidPairList 'CNameBound [none]
          | "combine _" : 'CNameBound [none]
          | "turn neg into otherwise for_" : 'CNameBound [none] 
          | "turn otherwise into neg for_" : 'CNameBound [none]  
          | "drop read _ from _" : 'CNameBound 'CNameBound [none]
          | "fold _ into _" : 'CNameBound 'CNameBound [none]
          | "subst _ into _" : 'CNameBound 'CNameBound [none]
          | "use assumption _ on _" : 'AssumName 'CName [none]
          | "_then_" : 'TopProof 'TopProof  [prec(45) assoc]
          | "sym from _ ( _ )" : 'IPDLProtocol 'TopProof [none]
          | "sym from _ over _ ( _ )" : 'IPDLProtocol 'DName 'TopProof [none]
          | lit "todo"
          | lit "idle"
          | "case distinction on _ (_)" : 'RuleTarget 'ProofCaseList [none]
          | "try case distinction on _ : (case: _)" : 'RuleTarget 'TopProof [none]
          | "try case distinction on _ : (case: _ done) (case: _)" : 'RuleTarget 'TopProof 'TopProof [none]
          | "in the presence of _ rewrite _ to _ by induction on _ bound _ (_)" :
              'CNameBoundList 'RuleTarget 'Cases 'NatTerm 'NatTerm 'TopProof  [none]
          | "try in the presence of _ rewrite _ to _ by induction on _ bound _ :_" :
              'CNameBoundList 'RuleTarget 'Cases 'NatTerm 'NatTerm 'TopProof  
              [prec(46)]    
          | "try sym from _ : _ done "  : 'IPDLProtocol 'TopProof [none]
          | "try sym from _ : _ "  : 'IPDLProtocol 'TopProof [prec(46)]
          | "split _ on first index" : 'CNameBound [prec(31)]
          | "split _ on second index" : 'CNameBound [prec(31)]
          | "unsplit _" : 'CNameIndex [prec(31)]
          | "add internal family _ indices: _ bounds: _ typed: _ assigned: _" 
             : 'CName 'NatTermList 'BoundList 'IPDLPreType 'Cases
            [none]
          | "add internal channel _ typed: _ assigned: _" 
             : 'CNameIndex 'IPDLPreType 'Cases [none]
          | "on branch _ of _ (_)" : 'BoolTerm 'RuleTarget 'TopProof 
          | "remove only branch of _" : 'CNameBound 
            [none] 
          *** | "try on branch _ of _ : _" : 'BoolTerm 'RuleTarget 'TopProof  [none] 
          | "move _ on each branch of _" : 'RuleTarget 'RuleTarget [none]   
          | "diverge on _ with _ var _ " : 'CNameBound 'CNameBound 'VId [none]
          | "diverge on _ with branch _ of _ var _ " : 'CNameBound 'BoolTerm  'CNameBound 'VId [none]
          | "reverse subst _ in _ using _" : 'CNameBound 'CNameBound 'CNameBound [none]
          | "subst or diverge _ into _ var _" : 'CNameBound 'CNameBound 'VId [none]
          | "on reaction of _ ( _)" : 'CNameBound 'ReactionProof [none] 
          | "on all branches of _ split _ on first index" : 'CNameBound 'CNameBound [none]
          | "on all branches of _ split _ on second index" : 'CNameBound 'CNameBound [none]
          | "group _ in _ indices: _ bounds: _" : 'CNameBoundList 'PName 'NatTermList 'BoundList [none]
          | "call _" : 'SName 
          | "ungroup _" : 'CNameBound 
      'ReactionProof 
        ::= "if-ext on _" : 'VId 
          | lit "idle"
         | "_then_" : 'ReactionProof 'ReactionProof  [prec(45) assoc]  
      'TopDecl 
         ::=
            just 'Import
          | just 'TypeDecl
          | just 'OpDecl
          | just 'DistDecl
         *** | just 'InDecl
         *** | just 'OutDecl
          | just 'DeltaDecl
          | just 'PDecl
          | just 'AssumDecl
          | just 'ParamDecl
          | just 'HypoDecl
          | just 'SubProofDecl
          *** | just 'TopProof
       'Import 
         ::= "import _ ." : 'ModuleName
       'ModuleName
         ::= token "mName" 
        'SubProofDecl 
         ::= "subproof _ = _ ." : 'SName 'TopProof [none]
         'SName 
          ::= token "sname" 
        'AssumDecl 
         ::= "assumption _ using _ : _ ; _ ; _ |= _ = _ ." 
              : 'AssumName 'QList 'ChnCtxt 'TypeCtxt 'QList 
                'IPDLReaction 'IPDLReaction [none] 
              *** assumption A using vars : Delta ; Gamma ; Ins |= R1 = R2 . 
            | "assumption %manual _ using _ : _ |= _ = _ ." :
               'AssumName 'QList 'TypeCtxt 'IPDLExpr 'IPDLExpr [none]
            | "assumption %automatic _ using _ : _ |= _ = _ ." :
               'AssumName 'QList 'TypeCtxt 'IPDLExpr 'IPDLExpr [none]   
        'DeltaDecl 
         ::= "channel context _ = _ ." :
             'DName 'ChannelDeclList [none]
        'ChannelDecl 
         ::= 
            "input _ : _ " : 'CFName 'IPDLPreType [prec(10)]
          | "output _ : _ " : 'CFName 'IPDLPreType [prec(10)] 
         'ChannelDeclList 
         ::= just 'ChannelDecl 
          |  "_ ; _" : 'ChannelDeclList 'ChannelDeclList [assoc prec (20)]
        'AssumName 
         ::= token "assumName" [exclude("%manual" "%automatic")]
        'AssumOption 
         ::= lit "manual"
           | lit "automatic" 
        'ChnCtxt 
         ::= just 'TypedChn
          | "_ _" : 'ChnCtxt 'ChnCtxt [assoc]
          | lit "emptyCCtxt"
        'TypedChn 
         ::= "_ :: _ " : 'CName 'IPDLPreType [none]
        'TypeCtxt 
         ::= just 'TypedVar
          | "_ _" : 'TypeCtxt 'TypeCtxt [assoc]
          | lit "emptyTCtxt"
        'TypedVar 
         ::= "_ : _ " : 'VId 'IPDLPreType [none] 
        'ProofCase 
         ::= "case: (_)" : 'TopProof
        'ProofCaseList 
         ::= just 'ProofCase
          | "_ _" : 'ProofCaseList 'ProofCaseList [assoc]
        'QidPair 
         ::= "_to_" : 'VId 'VId  [prec(31)]
        'QidPairList 
         ::= just 'QidPair 
           | "_,_" : 'QidPairList 'QidPairList [assoc]
        'QList
         ::= bubble "qlist" [exclude(":" "|=" ")" "nil"
           "todo" "fixedBound" "dependentBound" "bound" "bounds:")]
          | lit "nil"       
       'ParamDecl 
         ::= "parameter _ : _ ." : 'ParamName 'IPDLPreType [none]   
       'TypeDecl
         ::= "type _ ." : 'TDId
       'HypoDecl
         ::= "hypothesis _ ." : 'BoolTerm  [prec(23)]
       'OpDecl
         ::= "function _ : _ -> _ ." : 'FName 'IPDLPreType 'IPDLPreType [none]  
       'IPDLPreType 
         ::= just 'TId
          | " _ * _ " : 'IPDLPreType 'IPDLPreType [none] 
       'FName 
         ::= token "fname"  [exclude ("bound" "dependentBound" "fixedBound" "not")] 
       'PName 
         ::= token "pname" 
         [exclude ("where" "not" "emptyProtocol" "currentProtocol" "(" ")" "[" "||" "new" "newfamily" "family")]
       'ParamName 
         ::= token "paramName"    
       'DName 
         ::= token "dname"    
       'TDId
         ::= token "tdid" 
       'TId
         ::= token "tid" [exclude(";")]
       'DistDecl
         ::= "distribution _ : _ -> _ ." : 'DName 'IPDLPreType 'IPDLPreType [none] 
       'VId
         ::= token "vid" [exclude("True" "False" "()" ",")]
       'IPDLExpr 
         ::= just 'VId     
          | lit "True" 
          | lit "False"
          | lit "()" 
          | "_ ( _ )" : 'FName 'IPDLExpr [prec(19)]
          | "(_ , _)"  : 'IPDLExpr 'IPDLExpr [none]
          | "fst _" : 'IPDLExpr 
          | "snd _" : 'IPDLExpr 
       'IPDLReaction  
         ::=  "return _" : 'IPDLExpr [prec(19)]
          *** | "samp _" : 'DName
          | "samp _ ( _  )" : 'DName 'IPDLExpr [none]
          | "read _" : 'CNameIndex [prec (19)]
          | "read" : 'CNameIndex [none]
          | "if _ then _ else _ " : 'IPDLExpr 'IPDLReaction 'IPDLReaction [prec (21)]
          | " _ : _ <- _ ; _" : 'VId 'IPDLPreType 'IPDLReaction 'IPDLReaction [prec(20)]
          | "nf(_, _)" : 'BindList 'IPDLReaction [none]
          | "preNF(_, _)" : 'BindList 'IPDLReaction [none] 
          | "( _ )" : 'IPDLReaction [none]
       'BindList
         ::= just 'BindReaction
          | "_ _" : 'BindList 'BindList [assoc]
          | lit "nil"
       'BindReaction
         ::= "_:_<- read _" : 'VId 'IPDLPreType 'CNameIndex [none]
          | "_:_<~ _" : 'VId 'IPDLPreType 'IPDLReaction [none] 
       'CName 
         ::= token "cname" [exclude("then" "todo")]
          *** |  "__" : 'CName 'CScripts [none]
        'RuleTarget ::=
            "channel _" : 'CNameIndex 
          | "family _" : 'FamilyName
          | "group _" : 'FamilyName
        'CNameIndex ::=   
            just 'CName
          | "_ [ _ ]" : 'CName 'NatTermList [prec(1)] 
       'CScripts
         ::= bubble "cscripts" [min-tokens(4) max-tokens(4) exclude("." ":" "then" "todo")]
       'IPDLProtocol 
         ::= lit "emptyProtocol"
          | lit "currentProtocol"
          | "( _ )" : 'IPDLProtocol [none]
          | just 'PName
          | "_ ::= _" : 'CNameIndex 'Cases [prec(23) format('d 'd 'd 'd)]
          | "family _ indices: _ bounds: _ ::= _" : 
              'FamilyName 'NatTermList 'BoundList 'Cases [prec(23)]
                *** the list of natterms should only contain qids
          | "_ || _" : 'IPDLProtocol 'IPDLProtocol [assoc prec(31) format('d 'd 'd 'd)]
          | "new _ : _ in _" : 'CName 'IPDLPreType 'IPDLProtocol 
             [prec(35) format('o 'b 'd 'r 'o 'n 'd)] 
          | "newfamily _ indices: _ bounds: _  : _ in _" 
            : 'FamilyName 'NatTermList 'BoundList 'IPDLPreType 'IPDLProtocol  
             [prec(35)]
          | "newNF(_, _)" : 'TypedCNameList 'IPDLProtocol [none]
          | "_where_" : 'IPDLProtocol 'LocalDeclList [prec(34)]
          | "change _ with _ in _" : 'CNameBound 'Cases 'IPDLProtocol [prec(36)]
          | "extend _ with internal channel _ typed: _ assigned: _" :
            'IPDLProtocol 'CNameIndex 'IPDLPreType 'Cases [prec(36)]
          | "create group _ indices: _ bounds: _ from _ in _"  : 
             'PName 'NatTermList 'BoundList 'CNameBoundList 'IPDLProtocol [prec(36)]
          | "branch _ of _ change _ with _ in _" :
             'WhenCond 'CNameBound 'CNameBound 'Cases 'IPDLProtocol [prec(36)]   
        'LocalDeclList ::= 
            just 'LocalDecl 
          | "_and_" : 'LocalDeclList 'LocalDeclList [assoc prec(33)]  
         'LocalDecl ::=
            "_=_" : 'PName 'IPDLProtocol [prec(32)]
        'TypedCName
         ::= "<_ : _>" : 'CName 'IPDLPreType [none]
           | "{ _ _ : _ }" : 'FamilyName 'NatTermList 'IPDLPreType [prec(10)]
        'TypedCNameList
         ::= just 'TypedCName
          | lit "empty"
          | "_ _" : 'TypedCNameList 'TypedCNameList [assoc] 
       'PDecl 
         ::= "protocol _ = _ ." : 'PName 'IPDLProtocol [none]
       'NatTerm 
         ::= just 'NId 
           | "_ + _" : 'NatTerm 'NatTerm [assoc prec(9)]
           | "_ - _" : 'NatTerm 'NatTerm [prec(9)]
           | "_ * _" : 'NatTerm 'NatTerm [assoc prec(7)]
           | "_ ( _ )" : 'FName 'NatTerm [prec(5)]
           | "( _ )" : 'NatTerm [none]
       'NId ::= 
           token "nid" [exclude("+" "-" "*" "(" ")" "[" "]" "bound" "fixedBound" "dependentBound"
                              "bounds:" )]      
       'NatTermList ::=
            just 'NatTerm
          | "_,_" : 'NatTermList 'NatTermList [assoc]    
       'ConstId ::=
           token "cid" [exclude("bound" "fixedBound" "dependentBound" "+" "-" "*")] 
        'BoolTerm ::=
             lit "falseBT"
           | lit "trueBT"
           | "_ = _" : 'NatTerm 'NatTerm [prec(11)]        
           | "_ < _" : 'NatTerm 'NatTerm [prec(11)]        
           | "_ <= _" : 'NatTerm 'NatTerm [prec(11)]        
           | "_ and _" : 'BoolTerm 'BoolTerm [prec(15)]        
           | "_ or _" : 'BoolTerm 'BoolTerm [prec(15)] 
           | "not _" : 'BoolTerm [prec(13)]        
           | "_ ( _ )" : 'PredName 'NatTerm [prec(11)]
       'PredName ::=
           token "predId"  [exclude("not" "when")]
       'Bound ::=
            "bound _" : 'NatTerm 
          | "fixedBound _" : 'NatTerm  
          | "dependentBound _" : 'FName    
       'BoundList ::=
            just 'Bound 
          | "_ _" : 'BoundList 'BoundList [assoc]    
       'FamilyName ::=
             "_ [ _ ]" : 'CName 'BoundList [prec(1)]    
       'CFName ::= 
            just 'CNameIndex
          | just 'FamilyName       
       'Command
         ::= lit "show-types" [format('b 'o)]
          |  lit "show-ops" [format('b 'o)]
          |  lit "show-dists" [format('b 'o)]
          |  lit "show-channels" [format('b 'o)]
          |  lit "show-parameters" [format('b 'o)]
          |  lit "show-assums" [format('b 'o)]
          |  lit "show-protocols" [format('b 'o)]
          |  lit "show-hypotheses" [format('b 'o)]
          |  lit "show all" [format('b 'd 'o)]
          | "show-protocol _" : 'PName
          | "check-proof _" : 'PName
          | "get-channel _" : 'CName
          | lit "current-protocol" [format('b 'o)]
       'CNameBound ::=
             "chn _" : 'CNameIndex [prec(3)]
            | "fam _" : 'FamilyName [prec(3)]
         'CNameBoundList ::=
              just 'CNameBound
            | "_,_" : 'CNameBoundList 'CNameBoundList [assoc] 
        'WhenCond ::= 
            lit "otherwise"
          | "when _" : 'BoolTerm [prec(19)]
         'When ::=
           "_ --> _ " : 'WhenCond 'Cases [prec(20)]
         'WhenList ::=
              lit "emptyWhen"
            | "( _ )" : 'WhenList [none]  
            | just 'When 
            | "_ ;; _" : 'WhenList 'WhenList [assoc prec(21)]
         'Cases ::=
              just 'IPDLReaction   
            | just 'IPDLProtocol
            | just 'WhenList 

     endgr .
endfm

*** ----------------------------------------------------------------------------

view IPDL from LANGUAGE to IPDL/LANGUAGE is
  sort Lid to IPDL .
  op Lid to IPDL .
endv

********************************************************************************

fmod IPDL/READ is
  protecting IPDL/ENV .
  protecting IPDL/DECL .
  protecting IPDL/CMD .
  protecting IPDL/PROOF .
  protecting ATERM/READ .

  var L : IPDL .
  var QIL : QidList .
  vars I T T1 T2 P I1 I2 I3 I4 I5 I6 DT CT IT R1 R2 VS : ATerm .
  var q : Qid .
  var env : Env .
  var Sigma : Signature .
  var Delta : ChannelContext .
  var Ins Outs : Set{CNameBound} .
  var A : Set{BoolTerm} .
  var protMap : Map{Qid, Protocol} .

  op read-decl : IPDL Env ATerm  ~> Decl{IPDL} .
  eq read-decl(L, env, {'hypothesis_.[I] : 'HypoDecl})
  = Decl[L]{hypothesis read-boolTerm(L, I) .} .
  eq read-decl(L, env, {'type_.[I] : 'TypeDecl})
  = Decl[L]{type read-qid(I) .} .
  eq read-decl(L, env, {'function_:_->_.[I, T1, T2] : 'OpDecl} )
   = Decl[L]{function read-qid(I) : read-type(L, T1) -> read-type(L, T2) .} . 
  eq read-decl(L, env, {'distribution_:_->_.[I, T1, T2] : 'DistDecl} )
   = Decl[L]{distribution read-qid(I) : read-type(L, T1) -> read-type(L, T2) .} . 
  eq read-decl(L, env, {'channel`context_=_. [I1, I2] : 'DeltaDecl})
   = Decl[L]{channel context read-qid(I1) = 
              read-channelDeclList(L, emptyChannelCtx pairSetIO emptyChannelCtx, I2) .} .
***   ceq read-decl(L, env, {'input_:_.[I, T1] : 'InDecl} )
***    = Decl[L]{input (chn read-cNameIndex(L, I)) : read-type(L, T1) .} 
***   if I :: 'CName . 
***   ceq read-decl(L, env, {'input_:_.[I, T1] : 'InDecl} )
***    = Decl[L]{input (chn read-cNameIndex(L, I)) : read-type(L, T1) .} 
***   if I :: 'CNameIndex .
***   ceq read-decl(L, env, {'input_:_.[I, T1] : 'InDecl} )
***    = Decl[L]{input (fam read-familyName(L, I)) : read-type(L, T1) .} 
***   if I :: 'FamilyName .
  eq read-decl(L, env, {'parameter_:_.[I, T1] : 'ParamDecl} )
   = Decl[L]{parameter read-qid(I) : read-type(L, T1) .} .  
***   ceq read-decl(L, env, {'output_:_.[I, T1] : 'OutDecl} )
***    = Decl[L]{output (chn read-cNameIndex(L, I)) : read-type(L, T1) .} 
***   if I :: 'CName . 
***   ceq read-decl(L, env, {'output_:_.[I, T1] : 'OutDecl} )
***    = Decl[L]{output (chn read-cNameIndex(L, I)) : read-type(L, T1) .} 
***   if I :: 'CNameIndex .   
***   ceq read-decl(L, env, {'output_:_.[I, T1] : 'OutDecl} )
***    = Decl[L]{output (fam read-familyName(L, I)) : read-type(L, T1) .} 
***   if I :: 'FamilyName .   
  eq read-decl(L, env, {'protocol_=_.[I, P] : 'PDecl} )
   = Decl[L]{protocol read-qid(I) = read-protocol(L, env, P) .} . 
  eq read-decl(L, env, {'import_.[I] : 'Import} )
   = Decl[L]{import read-qid(I) .} .   
  eq read-decl(L, env, {'assumption_using_:_;_;_|=_=_.[
     I, VS, DT, CT, IT, R1, R2] : 'AssumDecl} )
   = Decl[L]{assumption read-qid(I) using read-vars(L, VS) : read-delta(L, DT) ; read-gamma(L, CT) ; 
            read-inputs(L, IT) |= read-reaction(L, R1) = read-reaction(L, R2) . } .
   eq read-decl(L, env, {'assumption_%manual_using_:_|=_=_.[
     I, VS, DT, I1, I2] : 'AssumDecl} )
   = Decl[L]{assumption manual read-qid(I) using read-vars(L, VS) : read-gamma(L, DT)  
             |= read-expression(L, I1) = read-expression(L, I2) . } .
   eq read-decl(L, env, {'assumption`%automatic_using_:_|=_=_.[
     I, VS, DT, I1, I2] : 'AssumDecl} )
   = Decl[L]{assumption automatic read-qid(I) using read-vars(L, VS) : read-gamma(L, DT)  
             |= read-expression(L, I1) = read-expression(L, I2) . } .
   eq read-decl(L, env, {'subproof_=_.[I1, I2] : 'SubProofDecl})
    = Decl[L]{subproof read-qid(I1) = read-proof(L, env, I2) .} . 


          
  var deltaPair : PairSetIO .
  var dIns dOuts : ChannelContext .
  var nw : Width .
  var nl : Length .

  op read-channelDeclList : IPDL PairSetIO ATerm -> PairSetIO .
  ceq read-channelDeclList(L, deltaPair, I) 
   = read-channelDecl(L, deltaPair, I)
  if I :: 'ChannelDecl .
  eq read-channelDeclList(L, deltaPair, {'_;_ [I1, I2] : 'ChannelDeclList}) 
   = union read-channelDeclList(L, deltaPair, I1) read-channelDeclList(L, deltaPair, I2) . 

  op read-channelDecl : IPDL PairSetIO ATerm -> PairSetIO . 
  ceq read-channelDecl(L, dIns pairSetIO dOuts, {'input_:_ [I1, T] : 'ChannelDecl})
   = (dIns (chn read-cNameIndex(L, I1) :: preToType(read-type(L, T)))) pairSetIO dOuts 
  if I1 :: 'CName .
  ceq read-channelDecl(L,  dIns pairSetIO dOuts, {'input_:_ [I1, T] : 'ChannelDecl})
   =  (dIns (chn read-cNameIndex(L, I1) :: preToType(read-type(L, T)))) pairSetIO dOuts 
  if I1 :: 'CNameIndex .
  ceq read-channelDecl(L,  dIns pairSetIO dOuts, {'input_:_ [I1, T] : 'ChannelDecl})
   = (dIns (fam read-familyName(L, I1) :: preToType(read-type(L, T)))) pairSetIO dOuts 
  if I1 :: 'FamilyName .
  ceq read-channelDecl(L,  dIns pairSetIO dOuts, {'output_:_ [I1, T] : 'ChannelDecl})
   =  dIns pairSetIO ( (chn read-cNameIndex(L, I1) :: preToType(read-type(L, T))) dOuts) 
   if I1 :: 'CName .
  ceq read-channelDecl(L,  dIns pairSetIO dOuts, {'output_:_ [I1, T] : 'ChannelDecl})
   =  dIns pairSetIO ( (chn read-cNameIndex(L, I1) :: preToType(read-type(L, T))) dOuts) 
   if I1 :: 'CNameIndex .
  ceq read-channelDecl(L,  dIns pairSetIO dOuts, {'output_:_ [I1, T] : 'ChannelDecl})
   =  dIns pairSetIO ( (fam read-familyName(L, I1) :: preToType(read-type(L, T))) dOuts) 
   if I1 :: 'FamilyName .   

  op read-assumOption : IPDL ATerm -> AssumOption .           
  eq read-assumOption(L, {'manual.AssumOption : 'AssumOption}) 
   = manualIPDL .
  eq read-assumOption(L, {'automatic.AssumOption : 'AssumOption}) 
   = automaticIPDL . 
 
  op read-delta : IPDL ATerm -> ChannelContext .
  eq read-delta(L, {'emptyCCtxt.ChnCtxt : 'ChnCtxt}) = emptyChannelCtx .
  eq read-delta(L, {'_::_[I, T] : 'TypedChn} ) =
     chn read-qid(I) :: preToType(read-type(L, T)) .
   eq read-delta(L, {'__[I1, I2] : 'ChnCtxt}) 
   = read-delta(L, I1) read-delta(L, I2) .   

  op read-gamma : IPDL ATerm -> TypeContext .
  eq read-gamma(L, {'emptyTCtxt.TypeCtxt : 'TypeCtxt}) = emptyTypeContext .
  eq read-gamma(L, {'_:_[I, T] : 'TypedVar}) =
     read-qid(I) : preToType(read-type(L, T)) .
  eq read-gamma(L, {'__[I1, I2] : 'TypeCtxt}) 
   = read-gamma(L, I1) read-gamma(L, I2) .

  op read-vars : IPDL ATerm -> QidSet .
  ceq read-vars(L, {'qlist[I] : 'QList}) = 
      set(QIL) 
  if QIL := read-qids(I) . 

  op read-inputs : IPDL ATerm -> Set{CNameBound} .
  eq read-inputs(L, {'nil.QList : 'QList}) = empty .
  ceq read-inputs(L, {'qlist[I] : 'QList}) = 
      mkInputs(QIL) 
  if QIL := read-qids(I) .

  op mkInputs : QidList -> Set{CNameBound} .
  eq mkInputs(nil) = empty .
  eq mkInputs(q ; QIL) = (chn q) mkInputs(QIL) .
   
  op read-expression : IPDL ATerm -> IPDLExpression .
  eq read-expression(L, {'True.IPDLExpr : 'IPDLExpr}) = True .
  eq read-expression(L, {'False.IPDLExpr : 'IPDLExpr}) = False .
  eq read-expression(L, {'`(`).IPDLExpr : 'IPDLExpr}) = () .
  eq read-expression(L, {'fst_[I] : 'IPDLExpr}) 
   = fst (read-expression(L, I)) .
  eq read-expression(L, {'snd_[I] : 'IPDLExpr}) 
   = snd (read-expression(L, I)) . 
  eq read-expression(L, {'`(_`,_`)[I1, I2] : 'IPDLExpr}) 
  = pair(read-expression(L, I1), read-expression(L, I2)) .
  eq read-expression(L, {'_`(_`)[I1, I2] : 'IPDLExpr}) 
   = ap read-qid(I1) read-expression(L, I2) .
  eq read-expression(L, I) = read-qid(I) [owise] . *** for variables

  op read-reaction : IPDL ATerm -> Reaction .
  eq read-reaction(L, {'return_[I] : 'IPDLReaction}) 
   = return read-expression(L, I) .
  eq read-reaction(L, {'read_[I] : 'IPDLReaction}) 
   = read read-cNameIndex(L, I) .
  eq read-reaction(L, {'read[I] : 'IPDLReaction}) 
   = read read-cNameIndex(L, I) . 
  eq read-reaction(L, {'if_then_else_[I, I1, I2] : 'IPDLReaction}) 
   = if read-expression(L, I) then read-reaction(L, I1) else read-reaction(L, I2) .
  eq read-reaction(L, {'_:_<-_;_[I, T, I1, I2] : 'IPDLReaction}) 
   = read-qid(I) : preToType(read-type(L, T)) <- read-reaction(L, I1) ; read-reaction(L, I2) . 
  *** eq read-reaction(L, {'samp_[I1] : 'IPDLReaction}) 
  ***  = samp (read-qid(I1) < () > ) .  
  eq read-reaction(L, {'samp_`(_`)[I1, I2] : 'IPDLReaction}) 
   = samp (read-qid(I1) < read-expression(L, I2) > ) .
  eq read-reaction(L, {'nf`(_`,_`)[I1, I2] : 'IPDLReaction}) 
   = nf(read-binds(L, I1) , read-reaction(L, I2) ) .   
  eq read-reaction(L, {'preNF`(_`,_`)[I1, I2] : 'IPDLReaction}) 
   = preNF(read-binds(L, I1) , read-reaction(L, I2) ) . 
  eq read-reaction(L, {'`(_`) [I] : 'IPDLReaction})
   = read-reaction(L, I) . 

  op read-cNameIndex : IPDL ATerm -> ChannelName .
  eq read-cNameIndex(L, {I : 'CName}) 
   = read-qid(I) .
  eq read-cNameIndex(L, {'_`[_`][I1, I2] : 'CNameIndex}) 
   = read-qid(I1)[ read-natTerms(L, I2)] .

  op read-cNameBound : IPDL ATerm -> CNameBound .
  eq read-cNameBound(L, {'chn_[I] : 'CNameBound} ) =
     chn read-cNameIndex(L, I) .
  eq read-cNameBound(L, {'fam_[I] : 'CNameBound} ) =
     fam read-familyName(L, I) . 

  op read-cNameBoundList : IPDL ATerm -> List{CNameBound} .   
  ceq read-cNameBoundList(L, I) 
   =  read-cNameBound(L, I)
  if I :: 'CNameBound .
  eq read-cNameBoundList(L, {'_`,_[I1, I2] : 'CNameBoundList}) 
   = read-cNameBoundList(L, I1) read-cNameBoundList(L, I2) .  

  op read-binds : IPDL ATerm -> BindList . 
  eq read-binds(L, {'nil.BindList : 'BindList}) 
   = emptyBRList .
  eq read-binds(L, {'_:_<~_[I, T, I2] : 'BindReaction}) 
   = read-qid(I) : preToType(read-type(L, T)) <~ read-reaction(L, I2) .
  eq read-binds(L, {'_:_<-`read_[I, T, I2] : 'BindReaction}) 
   = read-qid(I) : preToType(read-type(L, T)) <- read read-cNameIndex(L, I2) . 
  eq read-binds(L, {'__[I1, I2] : 'BindList}) 
   = read-binds(L, I1) read-binds(L, I2) . 
 
  var bds : List{Bounds} .
  var nlist : List{NatTerm} .

  op read-protocol : IPDL Env ATerm -> Protocol .
  eq read-protocol(L, env, {'emptyProtocol.IPDLProtocol : 'IPDLProtocol}) 
   = emptyProtocol .
  eq read-protocol(L, env, {'`(_`) [I] : 'IPDLProtocol})
   = read-protocol(L, env, I) .
  ceq read-protocol(L, env, {I : 'PName}) 
   = if $hasMapping(protMap, q) then protMap[q] else emptyProtocol fi 
  if q := read-qid(I) /\
     protMap := getPMap env . 
  eq read-protocol(L, env, {'new_:_in_[I, I1, I2] : 'IPDLProtocol}) 
   = new read-qid(I) : preToType(read-type(L, I1)) in read-protocol(L, env, I2) .
  eq read-protocol(L, env, {'newfamily_indices:_bounds:_:_in_[I, I1, I2, T, I3]  : 'IPDLProtocol}) 
   = newfamily read-familyName(L,I) 
               read-natTerms(L, I1) 
               read-bounds(L, I2) 
             : preToType(read-type(L, T)) 
     in read-protocol(L, env, I3)
  .  
  eq read-protocol(L, env, {'_||_[I1, I2] : 'IPDLProtocol}) 
   = read-protocol(L, env, I1) || read-protocol(L, env, I2) .
  eq read-protocol(L, env, {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol}) 
   = family 
       read-familyName(L, I) 
       read-natTerms(L, I1) 
       read-bounds(L, I2) ::= read-cases(L, env, I3)
  . 
  eq read-protocol(L, env, {'_::=_[I1, I2] : 'IPDLProtocol}) 
   = read-cNameIndex(L, I1) ::= read-cases(L, env, I2) .
  eq read-protocol(L, env, {'emptyProtocol.IPDLProtocol : 'IPDLProtocol}) = emptyProtocol .
  ceq read-protocol(L, env, {'currentProtocol.IPDLProtocol : 'IPDLProtocol})
   = P:Protocol if aConfig(Sigma, Delta, P:Protocol, Ins, Outs, A, nw, nl) := getAConfig env . 
  eq read-protocol(L, env, {'newNF`(_`,_`)[I1, I2] : 'IPDLProtocol} ) =
     newNF(read-typedCNameList(L, I1), read-protocol(L, env, I2) ).
  eq read-protocol(L, env, {'_where_[I1, I2] : 'IPDLProtocol}) 
   = read-protocol(L, setPMap env (getPMap env, read-localDecls(L, env, I2)) ,I1) .
  eq read-protocol(L, env, {'change_with_in_ [ I, I1, I2 ] : 'IPDLProtocol }) 
   = change read-cNameBound(L, I) 
     with   read-cases(L, env, I1)
     in     read-protocol(L, env, I2) .
  eq read-protocol(L, env, {'extend_with`internal`channel_typed:_assigned:_ [ I, I1, T, I2 ] : 'IPDLProtocol }) 
   = addInternalChannel read-cNameIndex(L, I1) 
     typed preToType(read-type(L, T))  
     assigned read-cases(L, env, I2)
     in read-protocol(L, env, I) . 
  eq read-protocol(L, env, {'create`group_indices:_bounds:_from_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol}) 
    = group read-cNameBoundList(L, I3)
      named read-qid(I)
      params read-natTerms(L, I1) read-bounds(L, I2)
      in read-protocol(L, env, I4) 
  .      
  eq read-protocol(L, env,  
     {'branch_of_change_with_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol })
   = branch read-whenCond(L, I)
     of read-cNameBound(L, I1)
     change read-cNameBound(L, I2)
     with read-cases(L, env, I3)
     in read-protocol(L, env, I4) .

  op read-localDecls : IPDL Env ATerm -> Map{Qid, Protocol} . 
  ceq read-localDecls(L, env, I) 
   = read-localDecl(L, env, I) if I :: 'LocalDecl .
  eq read-localDecls(L, env, {'_and_[I1, I2] : 'LocalDeclList}) 
   = read-localDecls(L, env, I1), read-localDecls(L, env, I2) . 

  op read-localDecl : IPDL Env ATerm -> Map{Qid, Protocol} .
  eq read-localDecl(L, env, {'_=_[I1, I2] : 'LocalDecl}) 
   = read-qid(I1) |-> read-protocol(L, env, I2) .

  op read-typedCNameList : IPDL ATerm -> TypedCNameList .
  eq read-typedCNameList(L, {'empty.TypedCNameList : 'TypedCNameList}) 
   = emptyTypedCNameList .
  eq read-typedCNameList(L, {'<_:_>[I1, I2] : 'TypedCName})
   = < read-qid(I1) :  preToType(read-type(L, I2)) > .
  eq read-typedCNameList(L, {'`{__:_`}[I1, I2, T] : 'TypedCName'})
   = { read-familyName(L,I1) read-natTerms(L, I2) : preToType(read-type(L, T)) } .
  eq read-typedCNameList(L, {'__[I1, I2] : 'TypedCNameList}) 
   = read-typedCNameList(L, I1) read-typedCNameList(L, I2) .  

  op read-type : IPDL ATerm -> IPDLPreType .
  eq read-type(L, {'_*_[T1, T2] : 'IPDLPreType}) = read-type(L, T1) * read-type(L, T2) .
  eq read-type(L, I) = read-qid(I) [owise].  

  op read-natTerms : IPDL ATerm -> List{NatTerm} .
  eq read-natTerms(L, {I : 'Nat}) 
   = read-natTerm(L, {I : 'Nat}) .
  eq read-natTerms(L, {I : 'CId}) 
   = read-natTerm(L, {I : 'CId}) . 
  eq read-natTerms(L, {I : 'NatTerm})
   = read-natTerm(L, {I : 'NatTerm}) .
  eq read-natTerms(L, {'_`,_[I1, I2] : 'NatTermList}) 
   = read-natTerms(L, I1) read-natTerms(L, I2) . 

  op toNatTerms : QidList -> List{NatTerm} .
  eq toNatTerms(nil) = nil .
  eq toNatTerms(q QIL) = qidAsTerm(q) toNatTerms(QIL) .

  op read-bound : IPDL ATerm -> Bounds .
  eq read-bound(L, {'bound_[I] : 'Bound}) 
   = bound read-natTerm(L, I) .
  eq read-bound(L, {'fixedBound_[I] : 'Bound}) 
   = fixedBound read-natTerm(L, I) .
  eq read-bound(L, {'dependentBound_[I] : 'Bound}) 
   = dependentBound read-qid(I) .  

  op read-natTerm : IPDL ATerm -> NatTerm .
  eq read-natTerm(L, {'_+_[I1, I2] : 'NatTerm}) 
   = read-natTerm(L, I1) + read-natTerm(L, I2) .
  eq read-natTerm(L, {'_-_[I1, I2] : 'NatTerm}) 
   = read-natTerm(L, I1) - read-natTerm(L, I2) .
  eq read-natTerm(L, {'_*_[I1, I2] : 'NatTerm}) 
   = read-natTerm(L, I1) * read-natTerm(L, I2) .
  eq read-natTerm(L, {'_`(_`)[I1, I2] : 'NatTerm})
   = fun read-qid(I1) read-natTerm(L, I2) . 
  eq read-natTerm(L, {'`(_`)[I] : 'NatTerm})
   = read-natTerm(L, I) .     
  eq read-natTerm(L, {I : 'Nat}) = natAsTerm(rat(string(read-qid(I)), 10)) .
  eq read-natTerm(L, {I : 'CId}) = qidAsTerm(read-qid(I)) .

  op read-familyName : IPDL ATerm -> FamilyName .
  eq read-familyName(L, {'_`[_`][I1, I2] : 'FamilyName})
   = read-qid(I1)[read-bounds(L, I2)] .  

  op read-boolTerm : IPDL ATerm -> BoolTerm .
  eq read-boolTerm(L, {'falseBT.BoolTerm : 'BoolTerm}) 
   = falseBT .
  eq read-boolTerm(L, {'trueBT.BoolTerm : 'BoolTerm}) 
   = trueBT .
  eq read-boolTerm(L, {'_=_[I1, I2] : 'BoolTerm}) 
   = read-natTerm(L, I1) =T= read-natTerm(L, I2) .
  eq read-boolTerm(L, {'_<_[I1, I2] : 'BoolTerm}) 
   = read-natTerm(L, I1) <T read-natTerm(L, I2) .
  eq read-boolTerm(L, {'_<=_[I1, I2] : 'BoolTerm}) 
   = read-natTerm(L, I1) <=T read-natTerm(L, I2) .
  eq read-boolTerm(L, {'_and_[I1, I2] : 'BoolTerm}) 
   = read-boolTerm(L, I1) conj read-boolTerm(L, I2) . 
  eq read-boolTerm(L, {'_or_[I1, I2] : 'BoolTerm}) 
   = read-boolTerm(L, I1) disj read-boolTerm(L, I2) .
  eq read-boolTerm(L, {'not_[I1] : 'BoolTerm}) 
   = neg read-boolTerm(L, I1) .
  eq read-boolTerm(L, {'_`(_`)[I1, I2] : 'BoolTerm})
   = apply read-qid(I1) read-natTerm(L, I2) .    


  op read-bounds : IPDL ATerm -> List{Bounds} .
  eq read-bounds(L, {I : 'Bound})
   = read-bound(L, {I : 'Bound}) .
  eq read-bounds(L, {'__[I1, I2] : 'BoundList}) 
   = read-bounds(L, I1) read-bounds(L, I2) .

  op read-whenCond : IPDL ATerm -> WhenCond .
  eq read-whenCond(L, {'otherwise.WhenCond : 'WhenCond}) 
   = otherwise .
   eq read-whenCond(L, {'when_[I] : 'WhenCond}) 
   = when read-boolTerm(L, I) .

  op read-when : IPDL ATerm -> When .
  eq read-when(L, {'_-->_[I1, I2] : 'When}) 
   = read-whenCond(L, I1) --> read-cases(L, emptyEnv, I2) . 
    *** because we don't allow cases in where

  op read-whenList : IPDL ATerm -> WhenList .
  eq read-whenList(L, {'emptyWhen.WhenList : 'WhenList}) 
   = emptyWhen .
  eq read-whenList(L, {'`(_`) [I] : 'WhenList})
   = read-whenList(L, I) . 
  eq read-whenList(L, {I : 'When}) = read-when(L, {I : 'When}) .
  eq read-whenList(L, {'_;;_[I1, I2] : 'WhenList}) 
   = read-whenList(L, I1) ;; read-whenList(L, I2) .

  op read-cases : IPDL Env ATerm -> Cases .
  ceq read-cases(L, env, I) = read-reaction(L, I)
  if I :: 'IPDLReaction .
  ceq read-cases(L, env, I) = read-protocol(L, env, I) 
   if I :: 'IPDLProtocol .
  ceq read-cases(L, env, I) = read-whenList(L, I) 
  if I :: 'WhenList .

  
  *** read command  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op read-cmd : IPDL Env ATerm ~> Cmd{IPDL} .
  eq read-cmd(L, env, {'show-types.Command : 'Command})
   = Cmd[L]{show-types} .
  eq read-cmd(L, env, {'show-ops.Command : 'Command})
   = Cmd[L]{show-ops} .
  eq read-cmd(L, env, {'show-dists.Command : 'Command})
   = Cmd[L]{show-dists} . 
  eq read-cmd(L, env, {'show-channels.Command : 'Command})
   = Cmd[L]{show-channels} . 
  eq read-cmd(L, env, {'show-parameters.Command : 'Command})
   = Cmd[L]{show-parameters} .   
  eq read-cmd(L, env, {'show-protocols.Command : 'Command})
   = Cmd[L]{show-protocols} .
  eq read-cmd(L, env, {'show-hypotheses.Command : 'Command})
   = Cmd[L]{show-hypotheses} . 
  eq read-cmd(L, env, {'show-assums.Command : 'Command})
   = Cmd[L]{show-assums} .
  eq read-cmd(L, env, {'show-protocol_[{'pname[I] : 'PName}] : 'Command})
   = Cmd[L]{show-protocol read-qid(I)} .
  eq read-cmd(L, env, {'check-proof_[{'pname[I] : 'PName}] : 'Command})
   = Cmd[L]{check-proof read-qid(I)} . 
  eq read-cmd(L, env, {'current-protocol.Command : 'Command})
   = Cmd[L]{current-protocol} . 
  eq read-cmd(L, env, {'show`all.Command : 'Command})
   = Cmd[L]{show all} . 
  eq read-cmd(L, env, {'get-channel_[{'cname[I] : 'CName}] : 'Command})
   = Cmd[L]{get-channel chn (read-qid(I))} .  

  *** read proof  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op read-proof : IPDL Env ATerm -> Proof{IPDL} .
  eq read-proof(L, env, {'todo.TopProof : 'TopProof})
   = Proof[L]{todo} .
  eq read-proof(L, env, {'idle.TopProof : 'TopProof})
   = Proof[L]{idle} . 
  eq read-proof(L, env, {'start`with_over_[I1, I2] : 'TopProof})
   = Proof[L]{start with read-qid(I1) over read-qid(I2)} .   
  eq read-proof(L, env, {'absorb_[I] : 'TopProof}) 
   = Proof[L]{absorb read-cNameBound(L, I)} . 
  eq read-proof(L, env, {'combine_[I] : 'TopProof}) 
   = Proof[L]{combine read-cNameBound(L, I)} .
  eq read-proof(L, env, {'unsplit_[I] : 'TopProof}) 
   = Proof[L]{unsplit read-cNameIndex(L, I)} .  
  eq read-proof(L, env, {'split_on`first`index [ I ] : 'TopProof } ) 
   = Proof[L]{split read-cNameBound(L, I) on first index} .
  eq read-proof(L, env, {'split_on`second`index [ I ] : 'TopProof } ) 
   = Proof[L]{split read-cNameBound(L, I) on second index} .    
  eq read-proof(L, env, {'merge`cases`for_[I] : 'TopProof}) 
   = Proof[L]{merge cases for read-cNameBound(L, I)} .
  eq read-proof(L, env, {'merge`case_=_with`otherwise`for_[I, I1, I2] : 'TopProof}) 
   = Proof[L]{merge case read-qid(I) = read-natTerm(L, I1) with otherwise for read-cNameBound(L, I2)} .       
  eq read-proof(L, env, {'turn`neg`into`otherwise`for_[I] : 'TopProof}) 
   = Proof[L]{turn neg into otherwise for read-cNameBound(L, I)} .    
  eq read-proof(L, env, {'turn`otherwise`into`neg`for_[I] : 'TopProof}) 
   = Proof[L]{turn otherwise into neg for read-cNameBound(L, I)} .     
  eq read-proof(L, env, {'drop`read_from_[I1, I2] : 'TopProof}) 
   = Proof[L]{drop read read-cNameBound(L, I1) from read-cNameBound(L, I2)} . 
  eq read-proof(L, env, {'rename_in_[I1, I2] : 'TopProof}) 
   = Proof[L]{rename read-qidPairList(L, I1) in read-cNameBound(L, I2)} . 
   eq read-proof(L, env, {'rename`variables_of_[I1, I2] : 'TopProof}) 
   = Proof[L]{rename variables read-qidPairList(L, I1) of read-cNameBound(L, I2)} .  
  eq read-proof(L, env, {'fold_into_[I1, I2] : 'TopProof}) 
   = Proof[L]{fold read-cNameBound(L, I1) into read-cNameBound(L, I2)} .
  eq read-proof(L, env, {'subst_into_[I1, I2] : 'TopProof}) 
   = Proof[L]{subst read-cNameBound(L, I1) into read-cNameBound(L, I2)} .       
  eq read-proof(L, env, {'use`assumption_on_[{'assumName[I1] : 'AssumName}, {'cname[I2] : 'CName}] : 'TopProof}) 
   = Proof[L]{use assumption read-qid(I1) on read-qid(I2)} . 
  eq read-proof(L, env, {'use`assumption_on_[I1 , I2] : 'TopProof}) 
   = Proof[L]{use assumption read-qid(I1) on read-qid(I2)} [owise] .   
  eq read-proof(L, env, {'_then_[I1, I2] : 'TopProof}) 
   = Proof[L]{read-proof(L, env, I1) then read-proof(L, env, I2)} .
  eq read-proof(L, env, {'sym`from_`(_`)[I1, I2] : 'TopProof}) 
   = Proof[L]{sym from read-protocol(L, env, I1) ( read-proof(L, env, I2) ) } . 
  eq read-proof(L, env, {'sym`from_over_`(_`)[I, I1, I2] : 'TopProof}) 
   = Proof[L]{sym from read-protocol(L, env, I) over (findDeltaInEnv env read-qid(I1)) 
              ( read-proof(L, env, I2) ) } .  
  eq read-proof(L, env, {'try`sym`from_:_done[I1, I2] : 'TopProof}) 
   = Proof[L]{try sym from read-protocol(L, env, I1) : read-proof(L, env, I2) done } .
  eq read-proof(L, env, {'try`sym`from_:_[I1, I2] : 'TopProof}) 
   = Proof[L]{try sym from read-protocol(L, env, I1) : read-proof(L, env, I2) } . 
  eq read-proof(L, env, 
      {'add`internal`family_indices:_bounds:_typed:_assigned:_ [I, I1, I2, T, I3] : 'TopProof}) 
   = Proof[L]{add internal family read-qid(I) indices: read-natTerms(L, I1) 
              bounds: read-bounds(L, I2) typed: preToType(read-type(L, T)) 
              assigned: read-cases(L, env, I3)} .
  eq read-proof(L, env, 
      {'add`internal`channel_typed:_assigned:_ [I, T, I3] : 'TopProof}) 
   = Proof[L]{add internal channel read-cNameIndex(L, I) 
              typed: preToType(read-type(L, T)) 
              assigned: read-cases(L, env, I3)} .            
  eq read-proof(L, env, {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5] : 'TopProof}) 
   = Proof[L]
     {in the presence of read-cNameBoundList(L, I) 
      rewrite read-ruleTarget(L, I1) to read-cases(L, env, I2) 
      by induction on read-natTerm(L, I3) bound read-natTerm (L, I4) (read-proof(L, env, I5))}  . 
   eq read-proof(L, env, {'try`in`the`presence`of_rewrite_to_by`induction`on_bound_:_ 
                [I, I1, I2, I3, I4, I5] : 'TopProof}) 
   = Proof[L]
     {try in the presence of read-cNameBoundList(L, I) 
      rewrite read-ruleTarget(L, I1) to read-cases(L, env, I2) 
      by induction on read-natTerm(L, I3) bound read-natTerm (L, I4) : read-proof(L, env, I5) }  .    
   eq read-proof(L, env, {'case`distinction`on_`(_`) [I1, I2] : 'TopProof} ) 
   =  Proof[L]{case distinction on read-ruleTarget(L, I1) ( read-proofCaseList(L, env, I2) )} .
   eq read-proof(L, env, {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'TopProof} ) 
   =  Proof[L]{try case distinction on read-ruleTarget(L, I1) : (case: read-proof(L, env, I2) )} .
   eq read-proof(L, env, {'try`case`distinction`on_:`(case:_done`)`(case:_`) [I, I1, I2] : 'TopProof} ) 
   =  Proof[L]{try case distinction on read-ruleTarget(L, I) :
                (case: read-proof(L, env, I1) done)
                (case: read-proof(L, env, I2))
                } .   
   eq read-proof(L, env,  {'on`branch_of_`(_`) [I, I1, I2] : 'TopProof }) 
    = Proof[L]{on branch read-boolTerm(L, I) of read-ruleTarget(L, I1) ( read-proof(L, env, I2) )} .
   *** eq read-proof(L, env,  {'try`on`branch_of_:_ [I, I1, I2] : 'TopProof }) 
   ***  = Proof[L]{try on branch read-boolTerm(L, I) of read-ruleTarget(L, I1) : read-proof(L, env, I2) } .
 
   eq read-proof(L, env, {'move_on`each`branch`of_ [I1, I2] : 'TopProof }) 
    = Proof[L]{move read-ruleTarget(L, I1) on each branch of read-ruleTarget(L, I2) } . 
   eq read-proof(L, env, {'diverge`on_with_var_ [I, I1, I2] : 'TopProof}) 
    =  Proof[L]{diverge on read-cNameBound(L, I) 
                      with read-cNameBound(L, I1)
                      var read-qid(I2)} .
   eq read-proof(L, env, {'diverge`on_with`branch_of_var_ [I, I1, I2, I3] : 'TopProof}) 
    =  Proof[L]{diverge on read-cNameBound(L, I) 
                      with branch read-boolTerm(L, I1)
                      of read-cNameBound(L, I2)
                      var read-qid(I3)} .                   
   eq read-proof(L, env, {'reverse`subst_in_using_ [I1, I2, I3] : 'TopProof})
    = Proof[L]{reverse subst read-cNameBound(L, I1) 
                       in read-cNameBound(L, I2) 
                       using read-cNameBound(L, I3)} .
   eq read-proof(L, env, {'subst`or`diverge_into_var_ [I1, I2, I3] : 'TopProof}) 
    = Proof[L]{subst or diverge read-cNameBound(L, I1)  
               into read-cNameBound(L, I2)  var read-qid(I3)}  .
   eq read-proof(L, env, {'on`reaction`of_`(_`) [I1, I2] : 'TopProof})
    = Proof[L]{on reaction of read-cNameBound(L, I1) (read-reactionProof(L, I2))} .
   eq read-proof(L, env, {'remove`only`branch`of_ [I] : 'TopProof})
    = Proof[L]{remove only branch of read-cNameBound(L, I)} .
   eq read-proof(L, env, {'on`all`branches`of_split_on`first`index [I1, I2] : 'TopProof})
    = Proof[L]{on all branches of read-cNameBound(L, I1) 
               split read-cNameBound(L, I2) on first index} .
   eq read-proof(L, env, {'on`all`branches`of_split_on`second`index [I1, I2] : 'TopProof})
    = Proof[L]{on all branches of read-cNameBound(L, I1) 
               split read-cNameBound(L, I2) on second index} . 
   eq read-proof(L, env, {'group_in_indices:_bounds:_[I, I1, I2, I3] : 'TopProof})
    = Proof[L]{group read-cNameBoundList(L, I) 
               in read-qid(I1) 
               indices: read-natTerms(L, I2) 
               bounds: read-bounds(L, I3)} .
   eq read-proof(L, env, {'call_ [I] : 'TopProof})
   = Proof[L]{call read-qid(I)} .
   eq read-proof(L, env, {'ungroup_ [I] : 'TopProof})
   = Proof[L]{ungroup read-cNameBound(L, I)} .
      

   op read-reactionProof :  IPDL ATerm -> ReactionProof{IPDL} .
   eq read-reactionProof(L, {'idle.ReactionProof : 'ReactionProof})
   = ReactionProof[L]{idle} . 
   eq read-reactionProof(L, {'_then_[I1, I2] : 'ReactionProof}) 
   = ReactionProof[L]{read-reactionProof(L, I1) then read-reactionProof(L, I2)} .
   eq read-reactionProof(L, {'if-ext`on_ [I] : 'ReactionProof}) 
    = ReactionProof[L]{if-ext on read-qid(I)} .


   op read-ruleTarget : IPDL ATerm -> RuleTarget .
   eq read-ruleTarget(L, {'channel_[I] : 'RuleTarget})
    = channel read-cNameIndex(L, I) . 
   eq read-ruleTarget(L, {'family_[I] : 'RuleTarget})
    = family read-familyName(L, I) . 
   eq read-ruleTarget(L, {'group_[I] : 'RuleTarget})
    = group read-familyName(L, I) .  

   op read-proofCaseList : IPDL Env ATerm -> ProofCaseList . 
   ceq read-proofCaseList(L, env, I)          
     = read-proofCase(L, env, I) 
    if I :: 'ProofCase .
   eq read-proofCaseList(L, env, {'__[I1, I2] : 'ProofCaseList}) 
    = read-proofCaseList(L, env, I1) read-proofCaseList(L, env, I2) .

   op read-proofCase : IPDL Env ATerm -> ProofCase . 
   eq read-proofCase(L, env, {'case:`(_`) [I] : 'ProofCase})
    = case read-proof(L, env, I) . 

   op read-qidPairList : IPDL ATerm -> QidPairList . 
   ceq read-qidPairList(L, I)          
     = read-qidPair(L, I) 
    if I :: 'QidPair .
   eq read-qidPairList(L, {'_`,_[I1, I2] : 'QidPairList}) 
    = read-qidPairList(L, I1) read-qidPairList(L, I2) .

   op read-qidPair : IPDL ATerm -> QidPair .            
   eq read-qidPair(L,{'_to_[I1, I2] : 'QidPair}) 
    = << read-qid(I1), read-qid(I2)>> .  
endfm

********************************************************************************

fmod IPDL/SHOW is
  protecting IPDL/DECL .
  protecting PROTOCOL .

  var  L : IPDL .
  var cn : ChannelName .
  var  I q : Qid .
  var T : IPDLType .
  vars t1 t2 : IPDLPreType .
  var P P1 : Protocol .
  var Delta dIns dOuts : ChannelContext .
  var Gamma GammaVar : TypeContext .
  var Ins : Set{CNameBound} .
  var R R1 R2 : Reaction .
  var E E1 E2 : IPDLExpression .
  var QIS : QidSet .
  var QIL : QidList .
  
  op show-decl : Decl{IPDL} -> Term .
  eq show-decl(Decl[L]{type I .})
   = 'type_.[show-decl-type(L, I)] .
  eq show-decl(Decl[L]{hypothesis bt .})
   = 'hypothesis_.[show-boolTerm(L, bt)] . 
***   eq show-decl(Decl[L]{input (chn I) : t1 .})
***    = 'input_.[ 
***        show-cNameIndex(L, I) , 
***        show-type(L, t1)] .
***   eq show-decl(Decl[L]{input (fam (I[bdl])) : t1 .})
***    = 'input_.[ 
***        show-familyName(L, I[bdl]) , 
***        show-type(L, t1)] .     
  eq show-decl(Decl[L]{channel context q = dIns pairSetIO dOuts .})
   = 'channel`context_=_. [
       mk-bubble('dname, show-qid(q)),
       '_;_ [
         show-insDelta(L, dIns),
         show-outsDelta(L, dOuts)
       ]
   ] .
  eq show-decl(Decl[L]{parameter I : t1 .})
   = 'input_.[ 
       mk-bubble('paramName, show-qid(I)) , 
       show-type(L, t1)] .      
***    eq show-decl(Decl[L]{output (chn I) : t1 .})
***    = 'output_.[ 
***        show-cNameIndex(L, I) ,  
***        show-type(L, t1)] . 
***   eq show-decl(Decl[L]{output (fam (I[bdl])) : t1 .})
***    = 'output_.[ 
***        show-familyName(L, I[bdl]) , 
***        show-type(L, t1)] .          
  eq show-decl(Decl[L]{function I : t1 -> t2 .})
   = 'function_:_->_.[
       mk-bubble('fname, show-qid(I)),
       show-type(L, t1),
       show-type(L, t2)] .
  eq show-decl(Decl[L]{distribution I : t1 -> t2 .})
   = 'distribution_:_->_.[
       mk-bubble('dname, show-qid(I)),
       show-type(L, t1),
       show-type(L, t2)] .
  eq show-decl(Decl[L]{protocol I = P .}) =
     'protocol_=_.[
      mk-bubble('pname, show-qid(I)),
      show-protocol(L, P) 
     ] . 
  eq show-decl(Decl[L]{assumption I using QIS : Delta ; Gamma ; Ins |= R1 = R2 .}) =   
     'assumption_using_:_;_;_|=_=_.[
       mk-bubble('assumName, show-qid(I)), 
       show-qids(list(QIS)), 
       show-delta(L, Delta), 
       show-gamma(L, Gamma), 
       show-inputs(L, Ins), 
       show-reaction(L, R1), 
       show-reaction(L, R2)
       ] .
   eq show-decl(Decl[L]{assumption manual I using QIS : Gamma |= E1 = E2 .}) =   
     'assumption`%manual_using_:_|=_=_.[
       mk-bubble('assumName, show-qid(I)), 
       show-qids(list(QIS)), 
       show-gamma(L, Gamma), 
       show-expression(L, E1), 
       show-expression(L, E2)
       ] .   
   eq show-decl(Decl[L]{assumption automatic I using QIS : Gamma |= E1 = E2 .}) =   
     'assumption`%automatic_using_:_|=_=_.[
       mk-bubble('assumName, show-qid(I)), 
       show-qids(list(QIS)), 
       show-gamma(L, Gamma), 
       show-expression(L, E1), 
       show-expression(L, E2)
       ] .        

  op show-assumOption :   IPDL AssumOption -> Term .   
  eq show-assumOption(L, manualIPDL) = 'manual.AssumOption . 
  eq show-assumOption(L, automaticIPDL) = 'automatic.AssumOption . 

  var aO : AssumOption .
 
  op show-delta : IPDL ChannelContext -> Term .
  eq show-delta(L, emptyChannelCtx) = 'emptyCCtxt.ChnCtxt .
  eq show-delta(L, chn q :: T) = 
     '_::_[
        mk-bubble('cname, show-qid(q)), 
        show-type(L, typeToPre(T))] .
  eq show-delta(L, (chn q :: T) Delta) =
     '__[ 
        show-delta(L, chn q :: T),
        show-delta(L, Delta )
      ] .        

  op show-gamma : IPDL TypeContext -> Term .
  eq show-gamma(L, emptyTypeContext) = 'emptyTCtxt.TypeCtxt .
  eq show-gamma(L, q : T) = 
     '_:_[
        mk-bubble('vid, show-qid(q)), 
        show-type(L, typeToPre(T))] .
  eq show-gamma(L, (q : T) Gamma) =
     '__[ 
        show-gamma(L, q : T),
        show-gamma(L, Gamma )
      ] .  

   var cnb : CNameBound . 

  op show-cNameBound : IPDL CNameBound -> Term .  

  op show-insDelta : IPDL ChannelContext -> Term .
  eq show-insDelta(L, cnb :: T) =
     'input_:_ [
       show-cNameBound(L, cnb),
       show-type(L, typeToPre(T))
     ] .
   eq show-insDelta(L, (cnb :: T) Delta) =
     '_;_[
     show-insDelta(L, cnb :: T),
     show-insDelta(L, Delta)
     ] 
     .  

  op show-outsDelta : IPDL ChannelContext -> Term .
  eq show-outsDelta(L, cnb :: T) =
     'output_:_ [
       show-cNameBound(L, cnb),
       show-type(L, typeToPre(T))
     ] .
   eq show-outsDelta(L, (cnb :: T) Delta) =
     '_;_[
     show-outsDelta(L, cnb :: T),
     show-outsDelta(L, Delta)
     ] 
     .   

  op show-inputs : IPDL Set{CNameBound} -> Term .
  eq show-inputs(L, Ins) =
     show-qids(toQidList(Ins)) .    

  op toQidList : Set{CNameBound} -> QidList .
  eq toQidList(empty) = none .
  eq toQidList(((chn q), Ins)) = q ; toQidList(Ins) .
 
 var ntlist : List{NatTerm} .

  op show-protocol : IPDL Protocol -> Term .
  eq show-protocol(L, emptyProtocol) = 
     'emptyProtocol.IPDLProtocol .
  eq show-protocol(L, cn ::= cases ) = 
     '_::=_[ 
      show-cNameIndex(L, cn),
      show-cases(L, cases) ] .
  eq show-protocol(L, family q[bdl] ntlist bdl ::= cases) 
   =  'family_indices:_bounds:_::=_[
      show-familyName(L, q[bdl]), 
      show-natTerms(L, ntlist), 
      show-bounds(L, bdl), 
      show-cases(L, cases) ] .    
  eq show-protocol(L, P || P1 ) = 
     '_||_[ 
      show-protocol(L, P),
      show-protocol(L, P1) ] . 
  eq show-protocol(L, new q : T in P ) =           
     'new_:_in_[
      mk-bubble('cname, show-qid(q)),
      show-type(L, typeToPre(T)),
      show-protocol(L, P)
     ] .
  eq show-protocol(L, newfamily q[bdl] ntlist bdl : T in P)  
   = 'newfamily_indices:_bounds:_:_in_[
      show-familyName(L, q[bdl]), 
      show-natTerms(L, ntlist), 
      show-bounds(L, bdl), 
      show-type(L, typeToPre(T)),
      show-protocol(L, P) ] .  

  var ltq : TypedCNameList .
 
  eq show-protocol(L, newNF(ltq, P)) =
     'newNF`(_`,_`)[
       show-typedCNameList(L, ltq), 
       show-protocol(L, P)] .
 
  op show-cNameIndex : IPDL ChannelName -> Term .
  eq show-cNameIndex(L, q) 
   = mk-bubble('cname, show-qid(q)).
  eq show-cNameIndex(L, q[ntlist]) 
   = '_`[_`][ 
        mk-bubble('cname, show-qid(q)),
        show-natTerms(L, ntlist)
      ] .
  
   var fn : FamilyName .
   var nlist : List{NatTerm} .
   var tcn : TypedCName .

  op show-typedCNameList : IPDL TypedCNameList -> Term .
  eq show-typedCNameList(L, emptyTypedCNameList) =
     'empty.TypedCNameList .
  eq show-typedCNameList(L, < cn : T > ) =
     '<_:_>[ 
        show-cNameIndex(L, cn),
        show-type(L, typeToPre(T))
      ] .
  eq show-typedCNameList(L, {fn nlist : T}) =  
     '`{__:_`}[
        show-familyName(L, fn), 
        show-natTerms(L, nlist), 
        show-type(L, typeToPre(T))] .  
  ceq show-typedCNameList(L, tcn ltq) =
     '__[ 
        show-typedCNameList(L, tcn ),
        show-typedCNameList(L, ltq )
      ] 
   if ltq =/= emptyTypedCNameList .        

  var nt nt1 nt2 : NatTerm .
  var x : Nat .

  op show-natTerm : IPDL NatTerm -> Term .
  eq show-natTerm(L, nt1 + nt2) 
   = '_+_[
       show-natTerm(L, nt1), 
       show-natTerm(L, nt2)] .
  eq show-natTerm(L, nt1 - nt2) 
   = '_-_[
       show-natTerm(L, nt1), 
       show-natTerm(L, nt2)] .
  eq show-natTerm(L, nt1 * nt2) 
   = '_*_[
       show-natTerm(L, nt1), 
       show-natTerm(L, nt2)] .
  eq show-natTerm(L, fun q nt1) 
   = '_`(_`)[
       mk-bubble('fname, show-qid(q)), 
       show-natTerm(L, nt1)] . 
  eq show-natTerm(L, qidAsTerm(q)) 
   = mk-bubble('nid, show-qid(q)) .
  eq show-natTerm(L, natAsTerm(x)) 
   = mk-bubble('nid, show-qid(qid(x))) .  

  op show-natTerms : IPDL List{NatTerm} -> Term .
  eq show-natTerms(L, nt) = show-natTerm(L, nt) .
  eq show-natTerms(L, nt ntlist) 
   = '_`,_[ 
        show-natTerm(L, nt),
        show-natTerms(L, ntlist)
      ] .                

  var bt bt1 bt2 : BoolTerm .

  op show-boolTerm : IPDL BoolTerm -> Term .
  eq show-boolTerm(L, falseBT) 
   = 'falseBT.BoolTerm .
  eq show-boolTerm(L, trueBT) 
   = 'trueBT.BoolTerm . 
  eq show-boolTerm(L, nt1 =T= nt2) 
   = '_=_[show-natTerm(L, nt1), show-natTerm(L, nt2)] .
  eq show-boolTerm(L, nt1 <T nt2) 
   = '_<_[show-natTerm(L, nt1), show-natTerm(L, nt2)] .    
  eq show-boolTerm(L, nt1 <=T nt2) 
   = '_<=_[show-natTerm(L, nt1), show-natTerm(L, nt2)] .
  eq show-boolTerm(L, neg bt) 
   = 'not_[show-boolTerm(L, bt)] .
  eq show-boolTerm(L, bt1 conj bt2) 
   = '_and_[show-boolTerm(L, bt1), show-boolTerm(L, bt2)] .       
  eq show-boolTerm(L, bt1 disj bt2) 
   = '_or_[show-boolTerm(L, bt1), show-boolTerm(L, bt2)] .        
  eq show-boolTerm(L, apply q nt) 
   = '_`(_`)[mk-bubble('predId, show-qid(q)), show-natTerm(L, nt)] . 

  op show-bound : IPDL Bounds -> Term .
  eq show-bound(L, bound nt) 
   = 'bound_[show-natTerm(L, nt)] . 
  eq show-bound(L, fixedBound nt) 
   = 'fixedBound_[show-natTerm(L, nt)] . 
  eq show-bound(L, dependentBound q) 
   = 'dependentBound_[mk-bubble('fname, show-qid(q))] .  

  var bd : Bounds .
  var bdl : List{Bounds} .

  op show-bounds : IPDL List{Bounds} -> Term .
  eq show-bounds(L, bd) = show-bound(L, bd) .
  eq show-bounds(L, bd bdl) 
   = '__[ 
        show-bound(L, bd),
        show-bounds(L, bdl)
      ] .

   op show-familyName : IPDL FamilyName -> Term .
   eq show-familyName(L, q[bdl]) =     
      '_`[_`][
         mk-bubble('cname, show-qid(q)), 
         show-bounds(L, bdl)
         ] .  

  op show-whenCond : IPDL WhenCond -> Term .
  eq show-whenCond(L, otherwise) 
   = 'otherwise.WhenCond .       
  eq show-whenCond(L, when bt) 
   = 'when_[show-boolTerm(L, bt)] .

  var wCond : WhenCond .
  var cases : Cases .

  op show-when : IPDL When -> Term .
  eq show-when(L, wCond --> cases) 
   = '_-->_[ 
        show-whenCond(L, wCond),
        show-cases(L, cases)
      ] .

  var w : When .
  var wl : WhenList .

  op show-whenList : IPDL WhenList -> Term .
  eq show-whenList(L, emptyWhen) 
   = 'emptyWhen.WhenList .
  eq show-whenList(L, w) 
   = show-when(L, w) .
  eq show-whenList(L, w ;; wl) 
   = '_;;_[ 
        show-when(L, w),
        show-whenList(L, wl)
      ] .    

  op show-cases : IPDL Cases -> Term . 
  eq show-cases(L, R) = show-reaction(L, R) .
  eq show-cases(L, P) = show-protocol(L, P) .
  eq show-cases(L, wl) = show-whenList(L, wl) .

  op show-reaction : IPDL Reaction -> Term .
  eq show-reaction(L, samp (q < E >) ) =
     'samp_`(_`)[
       mk-bubble('dname, show-qid(q)),
       show-expression(L, E)
     ] .   
  eq show-reaction(L, return E) =
     'return_[
       show-expression(L, E)
     ] .
  eq show-reaction(L, read q) =
    'read_[
      show-cNameIndex(L, q)    
    ] .   
  eq show-reaction(L, read cn) =
    'read[
      show-cNameIndex(L, cn)    
    ] .
  eq show-reaction(L, if E then R1 else R2) =  
    'if_then_else_[
      show-expression(L, E),
      show-reaction(L, R1),
      show-reaction(L, R2)
    ] .
  eq show-reaction(L, q : T <- R1 ; R2) =  
    '_:_<-_;_[
      mk-bubble('vid, show-qid(q)),
      show-type(L, typeToPre(T)),
      show-reaction(L, R1),
      show-reaction(L, R2)
    ] .  
  eq show-reaction(L, nf(BL, R)) =  
    'nf`(_`,_`)[
       show-binds(L, BL), 
       show-reaction(L, R)] . 
  eq show-reaction(L, preNF(BL, R)) =  
    'preNF`(_`,_`)[
       show-binds(L, BL), 
       show-reaction(L, R)] .  

  var BL BL1 : BindList .
  op show-binds : IPDL BindList -> Term .
  eq show-binds(L, emptyBRList) = 
     'nil.BindList .
  eq show-binds(L, q : T <~ R) =
     '_:_<~_[
      mk-bubble('vid, show-qid(q)),
      show-type(L, typeToPre(T)),
      show-reaction(L, R)      
     ] .  
   eq show-binds(L, q : T <- read cn) =
     '_:_<-`read_[
      mk-bubble('vid, show-qid(q)),
      show-type(L, typeToPre(T)),
      show-cNameIndex(L, cn)
     ] .        
  eq show-binds(L, (q : T <~ R) BL1) =
     '__[
      show-binds(L, q : T <~ R),
      show-binds(L, BL1)
     ] .
  eq show-binds(L, (q : T <- read cn) BL1) =
     '__[
      show-binds(L, q : T <- read cn),
      show-binds(L, BL1)
     ] .   
  

  op show-expression : IPDL IPDLExpression -> Term .  
  eq show-expression(L, True) = 'True.IPDLExpr .
  eq show-expression(L, False) = 'False.IPDLExpr .
  eq show-expression(L, ()) = '`(`).IPDLExpr . 
  eq show-expression(L, q) = mk-bubble('vid, show-qid(q)) .
  eq show-expression(L, fst E) = 
     'fst_[
      show-expression(L, E)
     ] .
  eq show-expression(L, snd E) = 
     'snd_[
      show-expression(L, E)
     ] .   
  eq show-expression(L, ap q E) = 
     '_`(_`)[
      mk-bubble('fname, show-qid(q)),
      show-expression(L, E)
     ] .
  eq show-expression(L, pair(E1, E2)) =
    '`(_`,_`)[
      show-expression(L, E1),
      show-expression(L, E2)
    ] .
  
  op show-decl-type : IPDL IPDLPreType -> Term .
  eq show-decl-type(L, I)
   = mk-bubble('tdid, show-qid(I)) .

  op show-type : IPDL IPDLPreType -> Term .
  eq show-type(L, I)
   = mk-bubble('tid, show-qid(I)) . 
  eq show-type(L, t1 * t2)
   = '_*_[show-type(L, t1), show-type(L, t2)] .


  *** the methods below show terms in AS

   var whenList whenList1 whenList2 : WhenList .
   
  
   var ntlist1 ntlist2 : List{NatTerm} .
   var blist blist1 blist2 : List{Bounds} .
   var n : Nat .


  op showAS-cases : QidSet Cases -> Term .
  eq showAS-cases(QIS, R) 
   = showAS-reaction(QIS, R) .
  eq showAS-cases(QIS, P) 
   = showAS-protocol(QIS, P) .
  eq showAS-cases(QIS, whenList) 
   = showAS-whenList(QIS, whenList) .
 
  op showAS-whenList : QidSet WhenList -> Term .

  op showAS-when : QidSet When -> Term .

  op showAS-whenCond : QidSet WhenCond -> Term .

  op showAS-natTerm : QidSet NatTerm -> Term .
  eq showAS-natTerm(QIS, qidAsTerm(q)) = upTerm(qidAsTerm(q)) . *** TODO: smth else if q in QIS?
  eq showAS-natTerm(QIS, natAsTerm(n)) = upTerm(natAsTerm(n)) .
  eq showAS-natTerm(QIS, nt1 + nt2) 
   = '_+_[
       showAS-natTerm(QIS, nt1), 
       showAS-natTerm(QIS, nt2)] .
  eq showAS-natTerm(QIS, nt1 - nt2) 
   = '_-_[
       showAS-natTerm(QIS, nt1), 
       showAS-natTerm(QIS, nt2)] .     
  eq showAS-natTerm(QIS, nt1 * nt2) 
   = '_*_[
       showAS-natTerm(QIS, nt1), 
       showAS-natTerm(QIS, nt2)] .     
  eq showAS-natTerm(QIS, fun q nt) 
   = 'fun__[
       upTerm(q), 
       showAS-natTerm(QIS, nt)] .     

  op showAS-natTerms : QidSet List{NatTerm} -> Term . 
  eq showAS-natTerms(QIS, nt) = showAS-natTerm(QIS, nt) .
  eq showAS-natTerms(QIS, ntlist1 ntlist2) = 
     '__[ 
        showAS-natTerms(QIS, ntlist1),
        showAS-natTerms(QIS, ntlist2)
      ] .

  op showAS-boolTerm : QidSet BoolTerm -> Term .

  op showAS-bound : QidSet Bounds -> Term .
  
  op showAS-bound : QidSet List{Bounds} -> Term .

  op showAS-protocol : QidSet Protocol -> Term .

  op showAS-reaction : QidSet Reaction -> Term .
  eq showAS-reaction(QIS, samp (q < E >)) = 
     'samp_['_<_>[upTerm(q), showAS-expression(QIS, E)]].
  eq showAS-reaction(QIS, return E) =
     'return_[showAS-expression(QIS, E)] .
  eq showAS-reaction(QIS, read cn) = 
     'read_[upTerm(cn)] . *** cause we don't allow variables in Delta yet  
  eq showAS-reaction(QIS, if E then R1 else R2) = 
     'if_then_else_[
        showAS-expression(QIS, E), 
        showAS-reaction(QIS, R1),
        showAS-reaction(QIS, R2)] .
  eq showAS-reaction(QIS, q : T <- R1 ; R2) =  
      '_:_<-_;_[
      showAS-expression(QIS, q),
      upTerm(T),
      showAS-reaction(QIS, R1),
      showAS-reaction(QIS, R2)
      ] . 
  eq showAS-reaction(QIS, nf(BL, R)) =  
    'nf[
       showAS-binds(QIS, BL), 
       showAS-reaction(QIS, R)
       ] . 
  eq showAS-reaction(QIS, preNF(BL, R)) =  
    'preNF[
       showAS-binds(QIS, BL), 
       showAS-reaction(QIS, R)] .          

  op showAS-expression : QidSet Expression -> Term .
  eq showAS-expression(QIS, True) = 'True.IPDLExpression .
  eq showAS-expression(QIS, False) = 'False.IPDLExpression .
  eq showAS-expression(QIS, ()) = upTerm(()).
  eq showAS-expression((QIS ; q), q) = var(q, 'Qid) .
  eq showAS-expression(QIS, q) = var(q, 'Qid) [owise] .
  eq showAS-expression(QIS, fst E) = 
     'fst_[
      showAS-expression(QIS, E)
     ] .
  eq showAS-expression(QIS, snd E) = 
     'snd_[
      showAS-expression(QIS, E)
     ] .   
  eq showAS-expression(QIS, ap q E) = 
     'ap__[
      upTerm(q), *** no function variables
      showAS-expression(QIS, E)
     ] .
  eq showAS-expression(QIS, pair(E1, E2)) =
    'pair[
      showAS-expression(QIS, E1),
      showAS-expression(QIS, E2)
    ] .

  op showAS-binds : QidSet BindList -> Term .
  eq showAS-binds(QIS, emptyBRList) = 'emptyBRList.BRList .
  eq showAS-binds(QIS, q : T <~ R) = 
      '_:_<~_[ 
        showAS-expression(QIS, q),
        upTerm(T),
        showAS-reaction(QIS, R)
      ] .
  eq showAS-binds(QIS, q : T <- R) = 
      '_:_<-_[ 
        showAS-expression(QIS, q),
        upTerm(T),
        showAS-reaction(QIS, R)
      ] .  
  eq showAS-binds(QIS, (q : T <~ R) BL1) =
     '__[
      showAS-binds(QIS, q : T <~ R),
      showAS-binds(QIS, BL1)
     ] .
  eq showAS-binds(QIS, (q : T <- read cn) BL1) =
     '__[
      showAS-binds(QIS, q : T <- read cn),
      showAS-binds(QIS, BL1)
     ] .       

  op showAS-delta : ChannelContext -> Term .
  eq showAS-delta(emptyChannelCtx)  = 'Delta:ChannelContext .
  eq showAS-delta(Delta) = '__['Delta:ChannelContext, showAS-deltaAux(Delta)]  [owise] .  

  op showAS-deltaAux : ChannelContext -> NeGroundTermList .
  eq showAS-deltaAux(chn q :: T) =
    '_::_['chn_[upTerm(q)],upTerm(T)] .
  eq showAS-deltaAux((chn q :: T) Delta) =
     showAS-deltaAux(chn q :: T) , showAS-deltaAux(Delta) .  

  op showAS-gamma : TypeContext -> Term .
  eq showAS-gamma(emptyTypeContext)  = 'Gamma:TypeContext .
  eq showAS-gamma(Gamma) = '__['Gamma:TypeContext, showAS-gammaAux(Gamma)]  [owise] .  

  op showAS-gammaAux : TypeContext -> NeGroundTermList .
  eq showAS-gammaAux(q : T) =
    '_:_[var(q, 'Qid), 'typeName_[''bool.Sort]] . *** TODO: correct here!
  eq showAS-gammaAux((q : T) Gamma) =
     showAS-gammaAux(q : T) , showAS-gammaAux(Gamma) . 

  op showAS-inputs : Set{CNameBound} -> Term .
  eq showAS-inputs(empty)  = 'Ins:Set`{CNameBound`} .
  eq showAS-inputs(Ins) = '_`,_['Ins:Set`{CNameBound`}, showAS-inputsAux(Ins)]  [owise] .

  op showAS-inputsAux : Set{CNameBound} -> NeGroundTermList .
  eq showAS-inputsAux(chn q) = upTerm(chn q) .
  eq showAS-inputsAux(((chn q), Ins)) =
     showAS-inputsAux(chn q) , showAS-inputsAux(Ins) .   

endfm

********************************************************************************

mod IPDL/ANALYSIS-STATE is
  
  protecting IPDL/READ .
  protecting IPDL/SHOW .
  protecting NUM/SHOW .
  protecting IPDL/LANGUAGE .

  protecting PROTOCOL-EQ-HELPERS .

  protecting SET{Int} .
 
  var L : IPDL .
  var QIS QIS' : QidSet .
  var QIL : QidList .
  var q ns : Qid .
  vars I I1 I2 I3 I4 I5 VS DT CT IT RT1 RT2 : ATerm .
  var aConf aConf' : ApproxEqConfig .
  var pConf pConf' : ProtocolConfig .
  var Sigma : Signature .
  var Delta : ChannelContext .
  var Gamma Gamma' : TypeContext .
  var Ins Outs : Set{CNameBound} .
  var A : Set{BoolTerm} .
  var P P' : Protocol .
  var R1 R2 : Reaction .
  var T1 T2 : IPDLType . 
  var t1 t2 : IPDLPreType .
  var protMap protMap' : Map{Qid, Protocol} .
  var cnb : CNameBound .
  var blist blist1 blist2 : List{Bounds} .
  var fn1 fn2 : FamilyName .
  var deltaMap : Map{Qid, PairSetIO} .

  var ISet : Set{Int} .
  var i i' : Int .

  var PCL1 PCL2 : List{ApproxEqConfig} .
  
  *** sort AnalysisState{IPDL} .
  *** op AnalysisState[_]{_} : IPDL QidSet -> AnalysisState{IPDL} .

  var env env' : Env .
  var m m' : Module .
  var TCS TCS'  : Set{TypeContextElem} .
  var PS PS' : TypeContext .
  var nw : Width .
  var nl : Length .

  op _>>=_ : Env ATerm -> Env .
  ceq env >>= {'hypothesis_.[I] : 'HypoDecl}
   =  setAConfig env (aConfig (Sigma, Delta, P, Ins, Outs, (A, read-boolTerm(IPDL, I)), nw, nl)) 
  if aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) := getAConfig env .
  *** setDeltaMap to record the channel context 
  *** updatePConfig to change Delta, Ins, Outs in the current env
  eq env >>= {'channel`context_=_. [I1, I2] : 'DeltaDecl } 
    = updateAConfig 
         (setDeltaMap env (getDeltaMap env, 
            read-qid(I1) |-> 
            read-channelDeclList(IPDL, emptyChannelCtx pairSetIO emptyChannelCtx ,I2) )
         )
       'emptyProtocol read-qid(I1)
   .
  eq env >>= {'type_.[I] : 'TypeDecl}
   =  setAConfig env (addTypeToSig read-qid(I) (getAConfig env) ) .
  eq env >>= {'function_:_->_.[I, I1, I2] : 'OpDecl}
   = setAConfig env ( addOpToSig read-qid(I) read-type(IPDL, I1) read-type(IPDL, I2) (getAConfig env) ) .
  eq env >>= {'distribution_:_->_.[I, I1, I2] : 'DistDecl}
   = setAConfig env ( addDistToSig read-qid(I) read-type(IPDL, I1) read-type(IPDL, I2)  (getAConfig env) )  . 
***   ceq env >>= {'input_:_.[I, I1] : 'InDecl}
***    = setAConfig env (addInput (chn read-cNameIndex(IPDL, I)) preToType(read-type(IPDL, I1)) (getAConfig env)) 
***   if I :: 'CNameIndex .
***   ceq env >>= {'input_:_.[I, I1] : 'InDecl}
***    = setAConfig env (addInput (chn read-cNameIndex(IPDL, I)) preToType(read-type(IPDL, I1)) (getAConfig env)) 
***   if I :: 'CName .
***   ceq env >>= {'input_:_.[I, I1] : 'InDecl}
***    = setAConfig env (addInput (fam read-familyName(IPDL, I)) preToType(read-type(IPDL, I1)) (getAConfig env)) 
***   if I :: 'FamilyName .
  eq env >>= {'parameter_:_.[I, I1] : 'ParamDecl}
   = setEnvParams env 
       (getEnvParams env , read-qid(I) : preToType(read-type(IPDL, I1))) .
***   ceq env >>= {'output_:_.[I, I1] : 'OutDecl}
***    = setAConfig env (addOutput (chn read-cNameIndex(IPDL, I)) preToType(read-type(IPDL, I1)) (getAConfig env)) 
***   if I :: 'CName .       
***   ceq env >>= {'output_:_.[I, I1] : 'OutDecl}
***    = setAConfig env (addOutput (chn read-cNameIndex(IPDL, I)) preToType(read-type(IPDL, I1)) (getAConfig env)) 
***   if I :: 'CNameIndex . 
***   ceq env >>= {'output_:_.[I, I1] : 'OutDecl}
***    = setAConfig env (addOutput (fam read-familyName(IPDL, I)) preToType(read-type(IPDL, I1)) (getAConfig env)) 
***   if I :: 'FamilyName . 
  eq env >>= {'subproof_=_.[I, I1] : 'SubProofDecl} 
   = setModule env
     (addSubproof env (getModule env) {'subproof_=_.[I, I1] : 'SubProofDecl})
  .
  eq env >>= {'protocol_=_.[I, I1] : 'PDecl}
   = setPMap env 
             (addProtocol read-qid(I) read-protocol(IPDL, env, I1) (getPMap env)) .   
  eq env >>= {'assumption_using_:_;_;_|=_=_.[I, VS, DT, CT, IT, RT1, RT2] : 'AssumDecl}
   = (setModule env
  (add-assumption(
    getModule env, 
     read-qid(I), 
     read-vars(IPDL, VS), 
     read-delta(IPDL, DT), 
     read-gamma(IPDL, CT), 
     read-inputs(IPDL, IT), 
     read-reaction(IPDL, RT1), 
     read-reaction(IPDL, RT2) )
  ) ) >>= I 
  . 
  eq env >>= {'assumption`%automatic_using_:_|=_=_.[I, VS, CT, I1, I2] : 'AssumDecl}
   = (setModule env
  (add-assumption-as-eq(
    getModule env, 
     read-qid(I), 
     read-vars(IPDL, VS), 
      
     read-gamma(IPDL, CT), 
 
     read-expression(IPDL, I1), 
     read-expression(IPDL, I2) )
  ) ) >>= I 
  .
  eq env >>= {'import_.[I] : 'Import}
   = setModule env (addImport (getModule env) read-qid(I))
  .    
  eq env >>= {I : 'AssumName}
   = setAssums env (getAssums env ; read-qid(I)) . 
  eq env >>= {'start`with_over_[I1, I2] : 'TopProof}   
   = srewAConfig 
      ( updateAConfig env read-qid(I1) read-qid(I2) ) 
      ( 'sugar-newNF[none]{empty} 
      *** ; 'moveNewToFront[[empty]]
      ; ( ('COMP-NEW-newNF-inside-new[none]{empty})! )
      ) 
       . 
  ceq env >>= {'fold_into_[I1, I2] : 'TopProof}
   = srewAConfig env ('foldNF[[upTerm(cn1), upTerm(cn2) ]]) 
  if chn cn1 := read-cNameBound(IPDL, I1) 
  /\ chn cn2 := read-cNameBound(IPDL, I2) .
  eq env >>= {'rename_in_[I1, I2] : 'TopProof}
   = srewAConfig env ('applyAlphaNFPr[[upTerm(read-cNameBound(IPDL, I2)), 
                                       upTerm(read-qidPairList(IPDL, I1) emptyQidPairList) ]]) 
  .
  eq env >>= {'rename`variables_of_[I1, I2] : 'TopProof}
   = srewAConfig env ('applyAlphaFamilyThree[[upTerm(read-cNameBound(IPDL, I2)), 
                                       upTerm(read-qidPairList(IPDL, I1) emptyQidPairList) ]]) 
  .
  eq env >>= {'absorb_[I] : 'TopProof}
   = srewAConfig env ('absorb[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .
  eq env >>= {'split_on`first`index [ I ] : 'TopProof } 
   = srewAConfig env ('topSplitFstIndex[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .
  eq env >>= {'unsplit_ [ I ] : 'TopProof } 
   = srewAConfig env ('topUnsplit[[upTerm(read-cNameIndex(IPDL, I)) ]]) 
  .
  eq env >>= {'split_on`second`index [ I ] : 'TopProof } 
   = srewAConfig env ('topSplitSndIndex[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .
  eq env >>= {'turn`otherwise`into`neg`for_[I] : 'TopProof}
   = srewAConfig env ('applyOtherwiseToNeg[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .
  eq env >>= {'turn`neg`into`otherwise`for_[I] : 'TopProof}
   = srewAConfig env ('applyNegToOtherwise[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .
  eq env >>= {'combine_[I] : 'TopProof}
   = srewAConfig env ('applyNewCombine[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .
  ceq env >>= {'call_[I] : 'TopProof} 
   = srewAConfig env
     (q [[ empty ]]) 
   if q := read-qid(I)  .
  eq env >>= {'ungroup_[I] : 'TopProof} 
   = srewAConfig env
     ('applyDropName[[upTerm(read-cNameBound(IPDL, I)) ]])
  .   
  eq env >>= {'subst_into_[I1, I2] : 'TopProof}
   = srewAConfig env ('subst[[upTerm(read-cNameBound(IPDL, I1)), upTerm(read-cNameBound(IPDL, I2)) ]]) 
  .
  eq env >>= {'drop`read_from_[I1, I2] : 'TopProof}
   = srewAConfig env ('dropSubsume[[upTerm(read-cNameBound(IPDL, I1)), upTerm(read-cNameBound(IPDL, I2)) ]]) 
  .
  eq env >>= {'add`internal`family_indices:_bounds:_typed:_assigned:_ [I, I1, I2, CT, I3] : 'TopProof}
   = srewAConfig env 
     ('addInternalFam[[
        upTerm(read-qid(I)), 
        upTerm(preToType(read-type(IPDL, CT))),
        upTerm(read-natTerms(IPDL, I1)), 
        upTerm(read-bounds(IPDL, I2)),
        upTerm(computeNF(read-cases(IPDL, env, I3)))   ]]
      ) .  
  eq env >>= {'add`internal`channel_typed:_assigned:_ [I, CT, I3] : 'TopProof}
   = srewAConfig env 
     ('applyAddInternalChannel[[
        upTerm(read-cNameIndex(IPDL, I)), 
        upTerm(preToType(read-type(IPDL, CT))),
        upTerm(computeNF(read-cases(IPDL, env, I3)))   ]]
      ) .      
  eq env >>= {'merge`cases`for_[I] : 'TopProof}
   = srewAConfig env ('mergeCases[[upTerm(read-cNameBound(IPDL, I)) ]]) 
  .  
  ceq env >>= {'move_on`each`branch`of_ [I1, I2] : 'TopProof }
   = srewAConfig env ('applyAddToGroupCases[[ upTerm(fam fn1), upTerm(fam fn2) ]])
  if family fn1 := read-ruleTarget(IPDL, I1)
  /\ group fn2 := read-ruleTarget(IPDL, I2)
  . 
  eq env >>= {'merge`case_=_with`otherwise`for_[I, I1, I2] : 'TopProof}
   = srewAConfig env ('mergeCaseWithOtherwise[[upTerm(read-cNameBound(IPDL, I2)), upTerm(read-natTerm(IPDL, I1)) ]]) 
  . 
  eq env >>= {'use`assumption_on_[I1, I2] : 'TopProof} 
   = srewAConfig env ( qid('apply read-qid(I1)) [[upTerm(read-qid(I2)) ]] ) .
  eq env >>= {'todo.TopProof : 'TopProof} 
   = env . 
  eq env >>= {'idle.TopProof : 'TopProof} 
   = env .  
  ceq env >>= {'_then_[I1, I2] : 'TopProof} 
   = env' >>= I2 
  if env' := env >>= I1 . 
  eq env >>= {'sym`from_`(_`)[I1, I2] : 'TopProof}
   = srewAConfig
       (addStratDecls env {'sym`from_`(_`)[I1, I2] : 'TopProof})
       (generatedStrategyCall env) .    
  eq env >>= {'on`branch_of_`(_`) [I, I1, I2] : 'TopProof }
   = srewAConfig
       (addStratDecls env {'on`branch_of_`(_`) [I, I1, I2] : 'TopProof })
       (generatedStrategyCall env) .     
  eq env >>= {'case`distinction`on_`(_`) [I1, I2] : 'TopProof}
   = srewAConfig
       (addStratDecls env {'case`distinction`on_`(_`) [I1, I2] : 'TopProof})
       (generatedStrategyCall env) . 
  eq env >>= {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5 ] : 'TopProof}
   = srewAConfig
       (addStratDecls env {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5 ] : 'TopProof})
       (generatedStrategyCall env) . 
  eq env >>= {'try`sym`from_:_done[I1, I2] : 'TopProof}
   = env >>= {'sym`from_`(_`)[I1, I2] : 'TopProof} .
  ceq env >>= {'try`sym`from_:_[
               {'change_with_in_ [ 
                    I1, I2, 
                    {'currentProtocol.IPDLProtocol : 'IPDLProtocol}
                  ] : 'IPDLProtocol},
               I3
               ] : 'TopProof}
   = *** first we push in the stack the updated pConf 
     (srewAConfig
     (pushAConfig 
      env 
      ( aConfig(Sigma, Delta, 
         computeNF (change read-cNameBound(IPDL, I1) with read-cases(IPDL, env, I2) in P), 
         Ins, Outs, A, nw, nl)
      ) 
     )
     ('sugar-newNF[none]{empty} ; 
      ***   'moveNewToFront[[empty]]
      ( ('COMP-NEW-newNF-inside-new[none]{empty})! )
     )
     )
     *** then we do the subproof
     >>= I3 
   if aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) := getAConfig env .    
  ceq env >>= {'try`sym`from_:_[I1, I2] : 'TopProof}
   = *** first we push in the stack the updated pConf 
     (srewAConfig
     (pushAConfig 
      env 
      ( aConfig(Sigma, Delta, computeNF (read-protocol(IPDL, env, I1)), Ins, Outs, A, nw, nl)
      ) 
     )
     ('sugar-newNF[none]{empty} ; *** 'moveNewToFront[[empty]]
      ( ('COMP-NEW-newNF-inside-new[none]{empty})! )
     )
     )
     *** then we do the subproof
     >>= I2 
   if aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) := getAConfig env .      
  ceq env >>= {'try`in`the`presence`of_rewrite_to_by`induction`on_bound_:_
                [I, I1, I2, I3, I4, I5 ] : 'TopProof}
   = *** first we push in the stack the updated pConf 
     (pushAConfig 
      env 
      (pConf2aConf
       (generateInductionConfig 
        pConfig(Sigma, addChannels ltq Delta, P1, union(Ins, getOutputs(Q)), getOutputs(P1), A)
        cn
        q1 
        q2
        computeNF(read-cases(IPDL, env, I2))
       ) nw nl
      )
     )
     *** then we do the subproof
     >>= I5
   if aConfig(Sigma, Delta, newNF(ltq, P), Ins, Outs, A, nw, nl) :=  getAConfig env 
   /\ cn[blist] := fNameTarget(read-ruleTarget(IPDL, I1))
   /\ cnbl := read-cNameBoundList(IPDL, I)
   /\ P1 := keepAll P (cnbl fam(cn[blist]))
   /\ Q := removeAll P (cnbl fam(cn[blist]))
   /\ (qidAsTerm q1) := read-natTerm(IPDL, I3) 
   /\ (qidAsTerm q2) := read-natTerm(IPDL, I4)
   .   
   *** below, the case with now newNF in the protocol
   ceq env >>= {'try`in`the`presence`of_rewrite_to_by`induction`on_bound_:_
                [I, I1, I2, I3, I4, I5 ] : 'TopProof}
   = *** first we push in the stack the updated pConf 
     (pushAConfig 
      env 
      (pConf2aConf
      (generateInductionConfig 
        pConfig(Sigma, Delta, P1, union(Ins, getOutputs(Q)), getOutputs(P1), A)
        cn
        q1 
        q2
        read-cases(IPDL, env, I2)
      )
      nw nl
      )
     )
     *** then we do the subproof
     >>= I5
   if aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) :=  getAConfig env 
   /\ cn[blist] := fNameTarget(read-ruleTarget(IPDL, I1))
   /\ cnbl := read-cNameBoundList(IPDL, I)
   /\ P1 := keepAll P (cnbl fam(cn[blist]))
   /\ Q := removeAll P (cnbl fam(cn[blist]))
   /\ (qidAsTerm q1) := read-natTerm(IPDL, I3) 
   /\ (qidAsTerm q2) := read-natTerm(IPDL, I4)
   . 
   *** groups
   ceq env >>= {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'TopProof}
   = (srewAConfig
     (pushAConfig 
       env
      aConfig(Sigma, addChannels ltq Delta, Q || P1, Ins, getOutputs(Q || P1), 
              (A, whenCondToBoolTerm whenCond), nw, nl )
     )
     (try('moveProtocolUnderNewNF[[empty]]) ) 
    ) >>= I2
   if aConfig(Sigma, Delta, newNF(ltq,P), Ins, Outs, A, nw, nl) :=  getAConfig env 
   /\ family (cn[blist]) nlist blist ::= (whenCond --> P1) ;; whenList := 
        keepOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))
   /\ Q := removeOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))     
   .  
   ceq env >>= {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'TopProof}
   = (srewAConfig
      (pushAConfig 
       env
      aConfig(Sigma, Delta, Q || P1, Ins, Outs, (A, whenCondToBoolTerm whenCond), nw, nl )
     )
     (try('moveProtocolUnderNewNF[[empty]]) ) 
    ) >>= I2
   if aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) :=  getAConfig env 
   /\ family (cn[blist]) nlist blist ::= (whenCond --> P1) ;; whenList := 
        keepOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))
   /\ Q := removeOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))     
   .  
   *** families
   ceq env >>= {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'TopProof}
   = (pushAConfig 
       env
      aConfig(Sigma, addChannels ltq Delta, 
              Q || (family (cn[blist]) nlist blist ::= R1), 
              Ins, 
              getOutputs(Q || (family (cn[blist]) nlist blist ::= R1)), 
              (A, whenCondToBoolTerm whenCond), nw, nl )
     ) >>= I2
   if aConfig(Sigma, Delta, newNF(ltq,P), Ins, Outs, A, nw, nl) :=  getAConfig env 
   /\ family (cn[blist]) nlist blist ::= (whenCond --> R1) ;; whenList := 
        keepOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))
   /\ Q := removeOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))     
   .        
        
   ceq env >>= {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'TopProof}
   = (pushAConfig 
       env
      aConfig(Sigma, Delta, 
              Q || (family (cn[blist]) nlist blist ::= R1), 
              Ins, Outs, (A, whenCondToBoolTerm whenCond), nw, nl )
     ) >>= I2
   if aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) :=  getAConfig env 
   /\ family (cn[blist]) nlist blist ::= (whenCond --> R1) ;; whenList := 
        keepOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))
   /\ Q := removeOne P (fam fNameTarget(read-ruleTarget(IPDL, I1)))     
   . 
   *** channels
   ceq env >>= {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'TopProof}
   = (pushAConfig 
       env
      aConfig(Sigma, addChannels ltq Delta, 
              Q || (cn ::= R1), 
              Ins, 
              getOutputs(Q || (cn ::= R1)), 
              (A, whenCondToBoolTerm whenCond), nw, nl )
     ) >>= I2
   if aConfig(Sigma, Delta, newNF(ltq, P), Ins, Outs, A, nw, nl) :=  getAConfig env      
   /\ cn ::= (whenCond --> R1) ;; whenList := 
        keepOne P (chn ( cNameTarget(read-ruleTarget(IPDL, I1)) ) )
   /\ Q := removeOne P (chn ( cNameTarget(read-ruleTarget(IPDL, I1)) ) )   
   .              
   ceq env >>= {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'TopProof}
   = (pushAConfig 
       env
      aConfig(Sigma, Delta, 
              Q || (cn ::= R1), 
              Ins, Outs, (A, whenCondToBoolTerm whenCond), nw, nl )
     ) >>= I2
   if aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) :=  getAConfig env 
   /\ cn ::= (whenCond --> R1) ;; whenList := 
        keepOne P (chn ( cNameTarget(read-ruleTarget(IPDL, I1)) ) )
   /\ Q := removeOne P (chn ( cNameTarget(read-ruleTarget(IPDL, I1)) ) ) 
   . 
   eq env >>= {'diverge`on_with_var_ [I, I1, I2] : 'TopProof }
    = srewAConfig env 
       ('applySubstDivergeFamily[[
           upTerm(read-cNameBound(IPDL, I)),
           upTerm(read-cNameBound(IPDL, I1)), 
           upTerm(read-qid(I2)) ]]) .
   eq env >>= {'diverge`on_with`branch_of_var_ [I, I1, I2, I3] : 'TopProof }
    = srewAConfig env 
       ('applySelectCaseDiverge[[
           upTerm(read-cNameBound(IPDL, I2)),
           upTerm(read-cNameBound(IPDL, I)),
           upTerm(read-boolTerm(IPDL, I1)), 
           upTerm(read-qid(I3)) ]]) .        
   eq env >>= {'reverse`subst_in_using_ [I1, I2, I3] : 'TopProof }
    = srewAConfig env
       (
         'substNFReadRevFamilies[[
            upTerm(read-cNameBound(IPDL, I3)), 
            upTerm(read-cNameBound(IPDL, I2)), 
            upTerm(read-cNameBound(IPDL, I1))
         ]]
       ) .   
   eq env >>= {'subst`or`diverge_into_var_ [I1, I2, I3] : 'TopProof}
    = srewAConfig env
       ('applySubstOrDiverge[[
          upTerm(read-cNameBound(IPDL, I1)), 
          upTerm(read-cNameBound(IPDL, I2)), 
          upTerm(read-qid(I3))
       ]]) .
   eq env >>= {'on`reaction`of_`(_`) [I1, I2] : 'TopProof}
    = srewAConfig
       (addStratDecls env {'on`reaction`of_`(_`) [I1, I2] : 'TopProof})
       (generatedStrategyCall env) . 
   eq env >>= {'group_in_indices:_bounds:_[I, I1, I2, I3] : 'TopProof} 
    = srewAConfig
       (addStratDecls env {'group_in_indices:_bounds:_[I, I1, I2, I3] : 'TopProof})
       (generatedStrategyCall env) .     
   eq env >>= {'remove`only`branch`of_ [I] : 'TopProof}
    = srewAConfig env 
       ('applyRemoveBranch[[ upTerm(read-cNameBound(IPDL, I)) ]])
   .   
   eq env >>= {'on`all`branches`of_split_on`first`index [I1, I2] : 'TopProof}
    = srewAConfig env
      ('applySplitFstBranches[[ 
         upTerm(read-cNameBound(IPDL, I1)),
         upTerm(read-cNameBound(IPDL, I2))
       ]]) .
   eq env >>= {'on`all`branches`of_split_on`second`index [I1, I2] : 'TopProof}
    = srewAConfig env
      ('applySplitSndBranches[[ 
         upTerm(read-cNameBound(IPDL, I1)),
         upTerm(read-cNameBound(IPDL, I2))
       ]]) .    
  eq env >>= I = env [owise] .     

  var rp1 rp2 : ReactionProof{IPDL} .

  op reactionProofStep2Strategy : ReactionProof{IPDL} -> Strategy . 
  eq reactionProofStep2Strategy(ReactionProof[IPDL]{ idle }) 
   = idle .
  eq reactionProofStep2Strategy(ReactionProof[IPDL]{ rp1 then rp2}) 
   = reactionProofStep2Strategy(rp1) ; reactionProofStep2Strategy(rp2) .
  eq reactionProofStep2Strategy(ReactionProof[IPDL]{if-ext on q}) 
   = 'if-intro-ext['q:Qid <- upTerm(q)]{empty} . 

  var genReactionStrat : Strategy .
  var P1 P2 Q : Protocol .
  var ltq : TypedCNameList .
  var whenCond : WhenCond .
  var whenList : WhenList .
  var nlist : List{NatTerm} .

  op pushAConfig__ : Env ApproxEqConfig -> Env .
  eq pushAConfig (buildEnv PCL1 deltaMap protMap m TCS QIS PS) aConf 
   = (buildEnv (aConf PCL1) deltaMap protMap m TCS QIS PS) .

  op popAConfig_ : Env -> Env .
  eq popAConfig (buildEnv (aConf PCL1) deltaMap protMap m TCS QIS PS)
   = (buildEnv PCL1 deltaMap protMap m TCS QIS PS) . 

  op symBase__ : ApproxEqConfig Protocol -> ApproxEqConfig .
  eq symBase aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) P'  
   = aConfig(Sigma, Delta, P', Ins, Outs, A, nw, nl) .

 *** helpers for generated strategies and generated envs
 
  op generatedStrategyCall_ : Env -> Strategy .
  ceq generatedStrategyCall env =
     q [[ empty ]]
  if q := qid('gn_ qid(1 + getMaxUsedNumber (getModule env)) )  .

 var atl : ATermList .  

 op addImport__ : Module Qid -> Module .
 eq addImport (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) q =
  (smod H is
    (IL
    including q . 
    )
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) .  

 op addStratDecls__ : Env ATermList -> Env .
 eq addStratDecls env empty = env  [label asdEnd] .
 eq addStratDecls env ({'sym`from_`(_`)[I1, I2] : 'TopProof}, atl) = 
    addStratDecls
     (setModule env (addGenDecl env (getModule env) {'sym`from_`(_`)[I1, I2] : 'TopProof}))
     (I2, atl)  [label asdSym] .
 eq addStratDecls env ({'sym`from_over`(_`)[I, I1, I2] : 'TopProof}, atl) = 
    addStratDecls
     (setModule env (addGenDecl env (getModule env) {'sym`from_over_`(_`)[I, I1, I2] : 'TopProof}))
     (I2, atl)  .    
 eq addStratDecls env ({'on`reaction`of_`(_`) [I1, I2] : 'TopProof}, atl) 
  = addStratDecls
     (setModule env (addGenDecl env (getModule env) {'on`reaction`of_`(_`) [I1, I2] : 'TopProof}))
     atl .   
 eq addStratDecls env ({'on`branch_of_`(_`) [I, I1, I2] : 'TopProof }, atl) = 
    addStratDecls
     (setModule env (addGenDecl env (getModule env) {'on`branch_of_`(_`) [I, I1, I2] : 'TopProof }))
     (I2, atl)   [label asdOnB] .
 eq addStratDecls  env ({'group_in_indices:_bounds:_[I, I1, I2, I3] : 'TopProof}, atl) 
= addStratDecls 
   (setModule env (addGenDecl env (getModule env) {'group_in_indices:_bounds:_[I, I1, I2, I3] : 'TopProof}))
   atl .        
 eq addStratDecls env ({'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5 ] : 'TopProof}, atl) = 
    addStratDecls
     (setModule env 
      (addGenDecl env (getModule env) 
       {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5 ] : 'TopProof}
      )
     )
     (I5, atl)  .    
 eq addStratDecls env ({'case`distinction`on_`(_`) [I1, I2] : 'TopProof}, atl) = 
    addStratDecls
     (setModule env (addGenDecl env (getModule env) {'case`distinction`on_`(_`) [I1, I2] : 'TopProof}))
     (I2, atl)  [label asdCD] .    
 eq addStratDecls env ({'_then_[I1, I2] : 'TopProof}, atl) = 
    addStratDecls (addStratDecls env (I1, I2)) atl . 
 eq addStratDecls env ({'case:`(_`) [I] : 'ProofCase}, atl )
  = addStratDecls env (I, atl) .
 eq addStratDecls env ({'__ [I1, I2] : 'ProofCaseList}, atl) =
    addStratDecls 
     (addStratDecls env (I1, atl))
     I2 .
 eq addStratDecls env (I, atl) = addStratDecls env atl [owise] .  
 
 op addGenDecl___ : Env Module ATerm -> Module .
 eq addGenDecl env m {'_then_[I1, I2] : 'TopProof} 
  = addGenDecl env (
     addGenDecl env m I1
    ) I2 .
 *** create group
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ){'group_in_indices:_bounds:_[I, I1, I2, I3] : 'TopProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .
    )
    (SDEFS
       sd q[[ empty ]] := 
        matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using  'SYM[ 'Delta1:ChannelContext <- 'Delta:ChannelContext ; 
                 'O1:Set`{CNameBound`} <- 'Outs:Set`{CNameBound`} ; 
                 'P1:Protocol <- 'group_named_params__in_[
       upTerm(read-cNameBoundList(IPDL, I)),
       upTerm(read-qid(I1)),
       upTerm(read-natTerms(IPDL, I2)),
       upTerm(read-bounds(IPDL, I3)),
       'P:Protocol
   ]]
  {
    'applyDropName[[  upTerm(fam (read-qid(I1)[read-bounds(IPDL, I3)])) ]] 
  }
  [none] .
 )
     endsm
  )    
 if  m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 . 
 *** cong-family-r
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'on`reaction`of_`(_`) [I1, I2] : 'TopProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .
    )
    (SDEFS
       sd q[[ empty ]] := 
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    :  matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using  'CONG-COMP-RIGHT[
        'Q:Protocol  <- 'removeOne__['P:Protocol, upTerm(  fam (ns[blist]) )] ;
        'P1:Protocol <- 'keepOne__['P:Protocol, upTerm( fam (ns[blist]) )]
        ]
  {

 'CONG-FAMILY-R[none]{
         aStrat 
         or-else 
        'cong-nf[none]{aStrat}
       }
 } [none] .
 )
     endsm
  )    
 if  m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ fam (ns[blist]) := read-cNameBound(IPDL, I1) 
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ aStrat := reactionProofStep2Strategy(read-reactionProof(IPDL, I2)) 
 . 
 *** rewrite on a branch, reaction
  ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ){'on`branch_of_`(_`) [I, I1, I2] : 'TopProof } =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .
    )
    (SDEFS
       sd q[[ empty ]] :=  
        match 'pConf:ProtocolConfig s.t. 
       ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
     ? 'CONG-NEW-NF[none]{ q [[ empty ]] } 
     :   
      'select-branch-family-r[ 
       'fns:NameWithScripts <- upTerm(ns) ;
       'blist:List`{Bounds`}  <- upTerm(blist) ;
       'bt:BoolTerm <- upTerm(bt)]
                 {
                  aStrat  
                  } 
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ bt := read-boolTerm(IPDL, I)
 /\ family (ns[blist]) := read-ruleTarget(IPDL, I1)
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i) .
 *** rewrite on a branch, protocol
  ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ){'on`branch_of_`(_`) [I, I1, I2] : 'TopProof } =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .
    )
    (SDEFS
       sd q[[ empty ]] :=    
      'select-branch-family-p[ 
       'fns:NameWithScripts <- upTerm(ns) ;
       'blist:List`{Bounds`}  <- upTerm(blist) ;
       'bt:BoolTerm <- upTerm(bt)]
                 {
                  aStrat  
                  } 
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ bt := read-boolTerm(IPDL, I)
 /\ group (ns[blist]) := read-ruleTarget(IPDL, I1)
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i) .
 *** induction group
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5 ] : 'TopProof}  =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] := 
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    :  matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using  'CONG-COMP-RIGHT[
        'Q:Protocol  <- 'removeAll__['P:Protocol, upTerm(cnbl ( fam (ns[blist]) ))] ;
        'P1:Protocol <- 'keepAll__['P:Protocol, upTerm(cnbl ( fam (ns[blist]) ))]
        ]
  {

 'SINGLE-INDUCTION-new[
  'idx:Qid <- upTerm(q1) ;
  'q:Qid <- upTerm(q2) ;
  'cn:ChannelName <- upTerm(ns) ;
  'blist:List`{Bounds`} <- upTerm(blist) ;
  'P2:Protocol <- upTerm(cases)
 ]{ aStrat
  }
 } [none]     
 
 . 
    
    )
     endsm
  )
 if qidAsTerm q1 := read-natTerm(IPDL, I4)
 /\ qidAsTerm q2 := read-natTerm(IPDL, I3)
 /\ m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )  
  /\ cnbl := read-cNameBoundList(IPDL, I)
  /\ cases := computeNF(read-cases(IPDL, env, I2))
  /\ ( group (ns[blist]) ) := read-ruleTarget(IPDL, I1)
  /\ i := getMaxUsedNumber m
  /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I5)) (2 + i) .
 *** induction family
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5 ] : 'TopProof}  =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] := 
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    :  
      matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using  'CONG-COMP-RIGHT[
        'Q:Protocol  <- 'removeAll__['P:Protocol, upTerm(cnbl ( fam (ns[blist]) ))] ;
        'P1:Protocol <- 'keepAll__['P:Protocol, upTerm(cnbl ( fam (ns[blist]) ))]
        ]
  {
     'SINGLE-INDUCTION-new-R[
  'idx:Qid <- upTerm(q1) ;
  'q:Qid <- upTerm(q2) ;
  'cn:ChannelName <- upTerm(ns) ;
  'cases':Cases <- upTerm(cases)
   ]{ aStrat
    } 
  } [none] .   
      
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )  
  /\ qidAsTerm q1 := read-natTerm(IPDL, I4)
  /\ qidAsTerm q2 := read-natTerm(IPDL, I3) 
  /\ cnbl := read-cNameBoundList(IPDL, I)
  /\ cases := computeNF(read-cases(IPDL, env, I2))
  /\ ( family (ns[blist]) ) := read-ruleTarget(IPDL, I1)
  /\ i := getMaxUsedNumber m
  /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I5)) (2 + i) .
  *** sym
  ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'sym`from_`(_`)[I1, I2] : 'TopProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
   ***     match 'pConf:ProtocolConfig s.t. 
   ***    ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
   ***  ? 'CONG-NEW-NF[none]{q [[empty ]]} 
   ***  :   
     matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using 'SYM[ 'Delta1:ChannelContext <- 'Delta:ChannelContext ; 
                 'O1:Set`{CNameBound`} <- 'Outs:Set`{CNameBound`} ; 
                 'P1:Protocol <- protocol2Term(env, I1)]
                 {'sugar-newNF[none]{empty};
                  *** 'moveNewToFront[[empty]] ; 
                  ( ('COMP-NEW-newNF-inside-new[none]{empty})! ) ;
                  aStrat  
                   } 
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i) .
 *** sym over delta
  ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'sym`from_over_`(_`)[I, I1, I2] : 'TopProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
   ***     match 'pConf:ProtocolConfig s.t. 
   ***    ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
   ***  ? 'CONG-NEW-NF[none]{q [[empty ]]} 
   ***  :   
     matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using 'SYM[ 'Delta1:ChannelContext <- upTerm(findDeltaInEnv env read-qid(I1)) ; 
                 'O1:Set`{CNameBound`} <- upTerm(getOutputs(read-protocol(IPDL, env, I))) ; 
                 'P1:Protocol <- protocol2Term(env, I)]
                 {'sugar-newNF[none]{empty};
                  *** 'moveNewToFront[[empty]] ; 
                  ( ('COMP-NEW-newNF-inside-new[none]{empty})! ) ;
                  aStrat  
                   } 
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i) .
***(  *** sym on change current protocol
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'sym`from_`(_`)[{'change_with_in_ [
    I1,
    I2,
    {'currentProtocol.IPDLProtocol : 'IPDLProtocol}
  ] : 'IPDLProtocol}, I3] : 'TopProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[empty ]]} 
    :   
     matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using 'SYM[ 'Delta1:ChannelContext <- 'Delta:ChannelContext ; 
                 'O1:Set`{CNameBound`} <- 'Outs:Set`{CNameBound`} ; 
                 'P1:Protocol <- 
                   'change_with_in_[ 
                      upTerm( read-cNameBound(IPDL, I1) ), 
                      upTerm(computeNF(read-cases(IPDL, env, I2))) ,
                    'P:Protocol
                   ]
               ]
                 {'sugar-newNF[none]{empty};
                  *** 'moveNewToFront[[empty]] ; 
                  (('COMP-NEW-newNF-inside-new[none]{empty})! ) ;
                  aStrat  
                   } 
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I3)) (2 + i) .  
 ***sym on a known protocol 
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'sym`from_`(_`)[I1, I2] : 'TopProof} =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[empty ]]} 
    :   
     matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using 'SYM[ 'Delta1:ChannelContext <- 'Delta:ChannelContext ; 
                 'O1:Set`{CNameBound`} <- 'Outs:Set`{CNameBound`} ; 
                 'P1:Protocol <- upTerm(computeNF(read-protocol(IPDL, env, I1)))]
                 {'sugar-newNF[none]{empty};
                  *** 'moveNewToFront[[empty]] ; 
                  ( ('COMP-NEW-newNF-inside-new[none]{empty})! ) ;
                  aStrat  
                   } 
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )
 /\ i :=  getMaxUsedNumber m
 /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
 /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I2)) (2 + i) . )
 *** channel
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'case`distinction`on_`(_`) [I1, I2] : 'TopProof}  =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    : 'CASE-DISTINCTION-channel[
          *** none
         'cn:ChannelName <- upTerm(cn)
         ]
       { sl1 }
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )  
  /\ aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) := getAConfig env
  /\  (channel cn) := read-ruleTarget(IPDL, I1)
  /\ i := getMaxUsedNumber m
  /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  /\ slNatPair sl1 z := 
      proofCaseList2StrategyList 
        'CASE-DISTINCTION-channel 
        (chn cn)
        (read-proofCaseList(IPDL, env, I2))
        (i + 2)  .      
 *** family
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'case`distinction`on_`(_`) [I1, I2] : 'TopProof}  =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    : 'CASE-DISTINCTION-one-R[
          *** none
          'fns:NameWithScripts <- upTerm(ns)
        ; 'blist:List`{Bounds`} <- upTerm(blist)
         ]
       { sl1 }
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )  
  /\ aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) := getAConfig env
  /\  (family (ns[blist])) := read-ruleTarget(IPDL, I1)
  /\ i := getMaxUsedNumber m
  /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  /\ slNatPair sl1 z := 
      proofCaseList2StrategyList 
        'CASE-DISTINCTION-one-R 
        (fam (ns[blist]))
        (read-proofCaseList(IPDL, env, I2))
        (i + 2)  .
 *** group
 ceq addGenDecl env (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) {'case`distinction`on_`(_`) [I1, I2] : 'TopProof}  =
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS 
       strat q : nil @ 'ProtocolConfig [none] .

    )
    (SDEFS
       sd q[[ empty ]] :=  
       match 'pConf:ProtocolConfig s.t. 
      ('startsWithNew_['pConf:ProtocolConfig] = 'true.Bool) 
    ? 'CONG-NEW-NF[none]{q [[ empty ]]} 
    : 'CASE-DISTINCTION-one[
          *** none
         'fns:NameWithScripts <- upTerm(ns)
        ; 'blist:List`{Bounds`} <- upTerm(blist)
         ]
       { sl1 }
       [none] .
    )
     endsm
  )
 if m := (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  )  
  /\ aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) := getAConfig env
  /\  (group (ns[blist])) := read-ruleTarget(IPDL, I1)
  /\ i := getMaxUsedNumber m
  /\ q := if i == -1 then qid ('gn_0) else qid('gn_ qid(1 + i) ) fi
  /\ slNatPair sl1 z := 
      proofCaseList2StrategyList 
        'CASE-DISTINCTION-one 
        (fam (ns[blist]))
        (read-proofCaseList(IPDL, env, I2))
        (i + 2)  .
***  ceq addGenDecl env (smod H is
***     IL
***     sorts SS .
***     SSDS OPDS MAS EQS RLS SDCLS SDEFS
***      endsm
***   ) I =
***      (smod H is
***     IL
***     sorts SS .
***     SSDS OPDS MAS EQS RLS 
***     (SDCLS 
***        strat q : nil @ 'ProtocolConfig [none] .

***     )
***     (SDEFS
***        sd q[[ empty ]] := idle [none] .
***     )
***      endsm
***   )
***  if m := (smod H is
***     IL
***     sorts SS .
***     SSDS OPDS MAS EQS RLS SDCLS SDEFS
***      endsm
***   )
***  /\ q := qid('gn_ qid(1 + getMaxUsedNumber m) ) [owise] .
 *** for plain rules that don't generate strategies, leave unchanged
 eq addGenDecl env m  I = m [owise] .


 var cn : ChannelName .
 var ntlist : List{NatTerm} .

 *** helper: check whether currentProtocol is used in a protocol
 *** so far only in operations, not protocol constructors
 op usesCrtProt : ATerm -> Bool .
 eq usesCrtProt({'currentProtocol.IPDLProtocol : 'IPDLProtocol}) = true .
 eq usesCrtProt({'extend_with`internal`channel_typed:_assigned:_ [ I, I1, I2, I3 ] : 'IPDLProtocol })
  = usesCrtProt(I) .
 eq usesCrtProt({'create`group_indices:_bounds:_from_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol})
  = usesCrtProt(I4) . 
 eq usesCrtProt({'change_with_in_ [ I1, I2, I3 ] : 'IPDLProtocol})   
  = usesCrtProt(I3) .
 eq usesCrtProt({'branch_of_change_with_in_[I, I1, I2, I3, I4 ] : 'IPDLProtocol})   
  = usesCrtProt(I4) .
 
 eq usesCrtProt( {'`(_`) [I] : 'IPDLProtocol} )  
  = usesCrtProt(I) .
 eq usesCrtProt(I) = false [owise] .

 *** helper: generate a term from a protocol
 ***         but use 'P:Protocol and terms if currentProtocol is used
 op protocol2Term : Env ATerm -> Term .
 ceq protocol2Term(env, I)
   = upTerm(computeNF(read-protocol(IPDL, env, I)))
  if not usesCrtProt(I) .
  eq protocol2Term(env, {'currentProtocol.IPDLProtocol : 'IPDLProtocol})  
   = 'P:Protocol .
 ceq protocol2Term(env, {'`(_`) [I] : 'IPDLProtocol} )  
   = protocol2Term(env, I ) 
   if usesCrtProt(I) .  
 ceq protocol2Term(env, {'change_with_in_ [ I1, I2, I3 ] : 'IPDLProtocol})   
   = 'change_with_in_[ 
                      upTerm( read-cNameBound(IPDL, I1) ), 
                      upTerm(computeNF(read-cases(IPDL, env, I2))) ,
                      protocol2Term(env, I3 ) 
                   ]  
  if usesCrtProt(I3) .  
 ceq protocol2Term(env, 
      {'extend_with`internal`channel_typed:_assigned:_ [ I, I1, I2, I3 ] : 'IPDLProtocol } )   
   = 'addInternalChannel_typed_assigned_in_[ 
                      upTerm( read-cNameIndex(IPDL, I1) ), 
                      upTerm( preToType(read-type(IPDL, I2)) ),
                      upTerm(computeNF(read-cases(IPDL, env, I3))) ,
                      protocol2Term(env, I ) 
                   ]  
  if usesCrtProt(I) .
  ceq protocol2Term(env, 
    {'branch_of_change_with_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol} ) 
   = 'branch_of_change_with_in_[
      upTerm(read-whenCond(IPDL, I)),
      upTerm(read-cNameBound(IPDL, I1)),
      upTerm(read-cNameBound(IPDL, I2)),
      upTerm(read-cases(IPDL, env, I3)),
      upTerm(read-protocol(IPDL, env, I4))
   ]
  if usesCrtProt(I4) .      
  ceq protocol2Term(env, {'create`group_indices:_bounds:_from_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol})
   = 'group_named_params__in_[
       upTerm(cnbl),
       upTerm(q),
       upTerm(nlist),
       upTerm(blist),
       protocol2Term(env, I4)
   ]
  if usesCrtProt(I4) 
  /\ q := read-qid(I)
  /\ nlist := read-natTerms(IPDL, I1)
  /\ blist := read-bounds(IPDL, I2)
  /\ cnbl := read-cNameBoundList(IPDL, I3)
  .
   

 *** partial function
 op getWhenList : Protocol -> WhenList .
 eq getWhenList (cn ::= wList) = wList .
 eq getWhenList (family q[blist] ntlist blist ::= wList) = wList .

  op getMaxUsedNumber_ : Module -> Int .
  eq getMaxUsedNumber m = 
     maxSet (declsToInts getStrats(m)) .
  
  var AType : Type .
  var ATypeList : TypeList .
  var ASet : AttrSet .

  var s : String .

  op qidToCounter_ : Qid -> Int .
  ceq qidToCounter q = 
   if substr(s, 0, 3) == "gn_" 
    then  rat(substr(s, 3, length(s)), 10) 
    else -1
   fi 
   if s := string(q) .

   op declsToInts_ : StratDeclSet -> Set{Int} .
   eq declsToInts SDCLS = 
      declsToIntsAux SDCLS empty .

   op declsToIntsAux__ : StratDeclSet Set{Int} -> Set{Int} .  
   eq declsToIntsAux none ISet = ISet .
   eq declsToIntsAux ((strat q : ATypeList @ AType [ ASet ].) SDCLS) ISet
    = declsToIntsAux SDCLS (ISet, qidToCounter q) .

   op maxSet_ : Set{Int} -> Int .
   eq maxSet ISet = maxSetAux(ISet, -1) .
   
   op maxSetAux : Set{Int} Int -> Int .
   eq maxSetAux(empty, i) = i .
   eq maxSetAux((i, ISet), i') = 
     if i < i' then maxSetAux(ISet, i') else maxSetAux(ISet, i) fi .

  op addProtocol___ : Qid Protocol Map{Qid, Protocol} -> Map{Qid, Protocol} .
  eq addProtocol q P protMap = (protMap, q |-> P) .

  op addInput___ : CNameBound IPDLType ApproxEqConfig -> ApproxEqConfig .
  eq addInput cnb T1 
     aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) =
     aConfig(Sigma,
             Delta ( cnb :: T1),
             P,
             insert(cnb, Ins),
             Outs,
             A, nw, nl
            )     
  .           
 
  op addOutput___ : CNameBound IPDLType ApproxEqConfig -> ApproxEqConfig .
  eq addOutput cnb T1 aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) =
     aConfig(Sigma,
             Delta ( cnb :: T1),
             P,
             Ins,
             insert(cnb, Outs),
             A, nw, nl
            )    
  .          

  *** apply a strategy given as argument and change the pConfig in env if successful

  var aStrat aStrat' : Strategy .
  var Tm : Term .
  var TP : Type .

  op srewAConfig__ : Env Strategy -> Env .
  ceq srewAConfig env aStrat = setAConfig env (downTerm(Tm, emptyAConfig))
  if {Tm, TP} := 
      metaSrewrite(  
        (getModule env),
        upTerm(getAConfig env),
        aStrat,
        breadthFirst,
        0
      )  [label srewAConfig]  .
  eq srewAConfig env aStrat = env [owise] .   

  *** do typeOf in the module of the env
  *** send the typeOf as a term

  var someTerm : Term .

  op metaTypeInCtx__ : Env Term -> IPDLType .
  ceq metaTypeInCtx env someTerm = 
   downTerm(Tm, bool)
  if {Tm, TP} := metaReduce( getModule env, someTerm )
  .

  op metaOccurs__ : Env Term -> Bool .
  ceq metaOccurs env someTerm = 
   downTerm(Tm, true)
  if {Tm, TP} := metaReduce( getModule env, someTerm )
  .

  op metaIsElemB__ : Env Term -> Bool .
  ceq metaIsElemB env someTerm = 
   downTerm(Tm, true)
  if {Tm, TP} := metaReduce( getModule env, someTerm )
  .

  op metaTypeOf__ : Env Term -> TypeWithError .
  ceq metaTypeOf env someTerm = 
   downTerm(Tm, bool)
  if {Tm, TP} := metaReduce( getModule env, someTerm )
  .

   var aProof pr1 pr2 : Proof{IPDL} .
   var q1 q2 q' : Qid .
   var cnb1 cnb2 : CNameBound .
   var qpl : QidPairList .

   sort SNatPair .
   op sNatPair__ : Strategy Nat -> SNatPair [ctor]. 

   sort SLNatPair .
   op slNatPair__ : StrategyList Nat -> SLNatPair [ctor] .

   var x y z : Nat .
   var pcl1 pcl2 : ProofCaseList .
   var sl1 sl2 : StrategyList .
   var wList : WhenList .
   var w
   var pc1 pc2 : ProofCase .
   var cases1 cases2 : Cases .
   var cdRuleName : Qid .

  op proofCaseList2StrategyList____ : Qid CNameBound  ProofCaseList Nat -> SLNatPair .
  *** channels  
 ceq proofCaseList2StrategyList
      cdRuleName
      (chn cn) 
      pc1 x = 
      slNatPair
       (qid(cdRuleName '-end ) ['cn:ChannelName <- upTerm(cn)] 
        {try('moveProtocolUnderNewNF[[empty]]) ; aStrat}) y
   if slNatPair aStrat y := proofCase2Strategy pc1 x    
   .
   ceq proofCaseList2StrategyList
      cdRuleName 
      (chn cn) 
      (pc1 pc2) x = 
      slNatPair
       ( try('moveProtocolUnderNewNF[[empty]]) ; aStrat,
         qid(cdRuleName '-end )  ['cn:ChannelName <- upTerm(cn)]  
        {try('moveProtocolUnderNewNF[[empty]]) ; aStrat'}) z
   if slNatPair aStrat  y := proofCase2Strategy pc1 x  
   /\ slNatPair aStrat' z := proofCase2Strategy pc2 y   
   .
   ceq proofCaseList2StrategyList
       cdRuleName
      (chn cn) 
      (pc1 pcl2) x = 
      slNatPair
       ( try('moveProtocolUnderNewNF[[empty]])  ; aStrat,
         cdRuleName  ['cn:ChannelName <- upTerm(cn)]  
        {sl1}) z
   if slNatPair aStrat  y := proofCase2Strategy pc1 x  
   /\ slNatPair sl1 z := 
       proofCaseList2StrategyList cdRuleName (chn cn) pcl2 y   
   [owise] .
   *** families
   ceq proofCaseList2StrategyList
      cdRuleName
      (fam (ns[blist])) 
      pc1 x = 
      slNatPair
       (qid(cdRuleName '-end ) ['fns:NameWithScripts <- upTerm(ns)] 
        {try('moveProtocolUnderNewNF[[empty]]) ; aStrat}) y
   if slNatPair aStrat y := proofCase2Strategy pc1 x    
   .
   ceq proofCaseList2StrategyList
      cdRuleName 
      (fam (ns[blist])) 
      (pc1 pc2) x = 
      slNatPair
       ( try('moveProtocolUnderNewNF[[empty]]) ; aStrat,
         qid(cdRuleName '-end ) ['fns:NameWithScripts <- upTerm(ns)] 
        {try('moveProtocolUnderNewNF[[empty]]) ; aStrat'}) z
   if slNatPair aStrat  y := proofCase2Strategy pc1 x  
   /\ slNatPair aStrat' z := proofCase2Strategy pc2 y   
   .
   ceq proofCaseList2StrategyList
       cdRuleName
      (fam (ns[blist])) 
      (pc1 pcl2) x = 
      slNatPair
       ( try('moveProtocolUnderNewNF[[empty]])  ; aStrat,
         cdRuleName ['fns:NameWithScripts <- upTerm(ns)] 
        {sl1}) z
   if slNatPair aStrat  y := proofCase2Strategy pc1 x  
   /\ slNatPair sl1 z := 
       proofCaseList2StrategyList cdRuleName (fam (ns[blist])) pcl2 y   
   [owise] .

   
   *** ceq proofCaseList2StrategyList cnb wList pcl1 x =
   ***     proofCase2Strategy pcl1 x
   *** if pcl1 : ProofCase .    
   *** ceq proofCaseList2StrategyList cnb wList (pcl1 pcl2) x =
   ***    slNatPair (sl1 , sl2) z
   *** if (slNatPair sl1 y) := proofCaseList2StrategyList cnb wList pcl1 x
   *** /\ (slNatPair sl2 z) := proofCaseList2StrategyList cnb wList pcl2 y .

   op proofCase2Strategy__ : ProofCase Nat -> SLNatPair .
   ceq proofCase2Strategy (case aProof) x =
       slNatPair aStrat y
   if (sNatPair aStrat y) := proof2Strategy aProof x .

  var cnbl : List{CNameBound} .
  var cases : Cases .
  var rt : RuleTarget .

  var p1 p2 : Proof{IPDL} .

  op countGenSubproofs : Proof{IPDL} -> Nat .
  eq countGenSubproofs(Proof[IPDL]{p1 then p2}) = 
     countGenSubproofs(p1) + countGenSubproofs(p2) .
  eq countGenSubproofs(Proof[IPDL]{on branch bt of rt (p1)} ) =
     1 + countGenSubproofs(p1) .   
  eq countGenSubproofs(Proof[IPDL]{sym from P (p1)})  = 
     1 + countGenSubproofs(p1) .
  eq countGenSubproofs(Proof[IPDL]
      {in the presence of cnbl rewrite rt to cases by induction on nt1 bound nt2 (aProof)} ) 
   = 1 +  countGenSubproofs(aProof) .
  eq countGenSubproofs((Proof[IPDL]{case distinction on rt (pcl1)})) 
   = 1 + countGenSubproofs(pcl1) .  
  eq countGenSubproofs(Proof[IPDL]{on reaction of cnb (rp1)} )
   = 1 . 
  eq countGenSubproofs(p1) = 0 [owise] .   

  op countGenSubproofs : ProofCaseList -> Nat .
  eq countGenSubproofs(case p1) = countGenSubproofs(p1) .
  eq countGenSubproofs(pcl1 pcl2) = 
     countGenSubproofs(pcl1) + countGenSubproofs(pcl2) .


   op proof2Strategy__ : Proof{IPDL} Nat -> SNatPair .
   eq proof2Strategy (Proof[IPDL]{on reaction of cnb (rp1)} ) x
    = sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1) .
   eq proof2Strategy(Proof[IPDL]{group cnbl in q indices: nlist bounds: blist}) x
    = sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1) . 
   eq proof2Strategy (Proof[IPDL]{sym from P (aProof)}) x 
    =  sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1 + countGenSubproofs(aProof))
   . 
   eq proof2Strategy (Proof[IPDL]{on branch bt of rt (aProof)}) x 
    =  sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1 + countGenSubproofs(aProof))
   . 
   eq proof2Strategy (Proof[IPDL]{case distinction on rt (pcl1)}) x
    = sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1 + countGenSubproofs(pcl1)) 
   .  
   eq proof2Strategy (Proof[IPDL]
      {in the presence of cnbl rewrite rt to cases by induction on nt1 bound nt2 (aProof)} ) x
    = sNatPair (qid('gn_ qid(x)) [[ empty ]]) (x + 1 + countGenSubproofs(aProof)) 
   .  
   ceq proof2Strategy(Proof[IPDL]{pr1 then pr2}) x
    = sNatPair (aStrat ; aStrat') z
   if (sNatPair aStrat y) := proof2Strategy pr1 x 
   /\ (sNatPair aStrat' z) := proof2Strategy pr2 y .
   eq proof2Strategy aProof x = 
      sNatPair (proofStep2Strategy(aProof)) x
   [owise] .  

   var cn1 cn2 : ChannelName . 
   var cnb3 : CNameBound .

   op proofStep2Strategy : Proof{IPDL} -> Strategy .
   eq proofStep2Strategy(Proof[IPDL]{use assumption q1 on q2})
    = qid('apply q1) [[upTerm(q2) ]] .
   eq proofStep2Strategy(Proof[IPDL]{absorb cnb1}) 
    = 'absorb[[ upTerm(cnb1) ]] .
   eq proofStep2Strategy(Proof[IPDL]{unsplit cn}) 
    = 'topUnsplit[[ upTerm(cn) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{split cnb1 on first index}) 
    = 'topSplitFstIndex[[ upTerm(cnb1) ]] .
   eq proofStep2Strategy(Proof[IPDL]{split cnb1 on second index}) 
    = 'topSplitSndIndex[[ upTerm(cnb1) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{turn neg into otherwise for cnb1}) 
    = 'applyNegToOtherwise[[ upTerm(cnb1) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{turn otherwise into neg for cnb1}) 
    = 'applyOtherwiseToNeg[[ upTerm(cnb1) ]] .  
   eq proofStep2Strategy(Proof[IPDL]{combine cnb1}) 
    = 'applyNewCombine[[ upTerm(cnb1) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{call q})
    = q[[none]] . 
   eq proofStep2Strategy(Proof[IPDL]{ungroup cnb}) 
    = 'applyDropName[[upTerm(cnb)]] .
   eq proofStep2Strategy(Proof[IPDL]{merge cases for cnb1}) 
    = 'mergeCases[[ upTerm(cnb1) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{merge case q = nt with otherwise for cnb})  
    = 'mergeCaseWithOtherwise[[upTerm(cnb), upTerm(nt) ]] .
   eq proofStep2Strategy(Proof[IPDL]{rename qpl in cnb} )
    = 'applyAlphaNFPr[[upTerm(cnb), upTerm(qpl emptyQidPairList)  ]] .
    eq proofStep2Strategy(Proof[IPDL]{rename variables qpl of cnb} )
    = 'applyAlphaFamilyThree[[upTerm(cnb), upTerm(qpl emptyQidPairList)  ]] . 
   eq proofStep2Strategy(Proof[IPDL]{fold (chn cn1) into (chn cn2)}) 
    = 'foldNF[[ upTerm(cn1), upTerm(cn2) ]] .
   eq proofStep2Strategy(Proof[IPDL]{drop read cnb1 from cnb2}) 
    = 'dropSubsume[[ upTerm(cnb1), upTerm(cnb2) ]] . 
   eq proofStep2Strategy(Proof[IPDL]{subst cnb1 into cnb2}) 
    = 'subst[[ upTerm(cnb1), upTerm(cnb2) ]] .
   eq proofStep2Strategy(Proof[IPDL]{idle}) = idle .
   eq proofStep2Strategy(Proof[IPDL]{diverge on cnb1 with cnb2 var q})   
    =  'applySubstDivergeFamily[[
           upTerm(cnb1), upTerm(cnb2), upTerm(q) ]] .
   eq proofStep2Strategy(Proof[IPDL]{diverge on cnb1 with branch bt of cnb2 var q})           
    = ('applySelectCaseDiverge[[
           upTerm(cnb2),
           upTerm(cnb1),
           upTerm(bt), 
           upTerm(q) ]]) .    
   eq proofStep2Strategy(Proof[IPDL]{reverse subst cnb1 in cnb2 using cnb3 })
    = 'substNFReadRevFamilies[[
            upTerm(cnb3), 
            upTerm(cnb2), 
            upTerm(cnb1)
         ]] .   
   eq proofStep2Strategy(Proof[IPDL]{subst or diverge cnb1 into cnb2 var q})
    = ('applySubstOrDiverge[[
          upTerm(cnb1), 
          upTerm(cnb2), 
          upTerm(q)
       ]]) . 
   eq proofStep2Strategy(Proof[IPDL]{remove only branch of cnb}) 
    = 'applyRemoveBranch[[ upTerm(cnb) ]]
   .  
   eq  proofStep2Strategy(Proof[L]{on all branches of cnb1 split cnb2 on first index}) 
    = ('applySplitFstBranches[[ 
         upTerm(cnb1), upTerm(cnb2)
       ]])
   . 
   eq  proofStep2Strategy(Proof[L]{on all branches of cnb1 split cnb2 on second index}) 
    = ('applySplitSndBranches[[ 
         upTerm(cnb1), upTerm(cnb2)
       ]])
   . 
   *** TODO: Proof[_]{move_on each branch of_}
   *** TODO: diverge on!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   *** eq proofStep2Strategy(aProof) = idle [owise] . 

   op generateSymSubstBody : Protocol Proof{IPDL} -> Strategy .
   eq generateSymSubstBody(P, pr1) = 
     matchrew 'pConf:ProtocolConfig s.t. 
     'pConfig[ 'Sigma:Signature,'Delta:ChannelContext,
               'P:Protocol,'Ins:Set`{CNameBound`}, 'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] 
     := 'pConf:ProtocolConfig by 'pConf:ProtocolConfig 
     using 'SYM[ 'Delta1:ChannelContext <- 'Delta:ChannelContext ; 
                 'O1:Set`{CNameBound`} <- 'Outs:Set`{CNameBound`} ; 
                 'P1:Protocol <- upTerm(computeNF(P))]
                 {'sugar-newNF[none]{empty};
                 *** 'moveNewToFront[[empty]] ; 
                 ( ('COMP-NEW-newNF-inside-new[none]{empty})! ) ;
                   proofStep2Strategy(pr1)} . 
 
  var dIns dOuts : ChannelContext .

  ***  set the protocol in newNF
  *** also update Delta, Ins, Outs
  *** a default 'emptyProtocol for no update at protocol, used internal only.
  op updateAConfig___ : Env Qid Qid -> Env .
  ceq updateAConfig (buildEnv 
          ((aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) PCL1) 
        (deltaMap, q2 |-> dIns pairSetIO dOuts)  
        protMap m TCS QIS PS
        ) 
       q1 q2
       =
      (buildEnv 
        (aConfig(Sigma, dIns dOuts, P, toCNameBoundSet dIns, toCNameBoundSet dOuts, A, nw, nl) PCL1) 
               (deltaMap, q2 |-> dIns pairSetIO  dOuts) protMap m TCS QIS PS) 
  if q1 == 'emptyProtocol . 
  eq updateAConfig
       (buildEnv 
          ((aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) PCL1) 
        (deltaMap, q2 |-> dIns pairSetIO  dOuts)  
        (protMap, q1 |-> P') m TCS QIS PS
        ) 
       q1 q2
       =
      (buildEnv 
        (aConfig(Sigma, dIns dOuts, 
           computeNF(P'), 
           toCNameBoundSet dIns, toCNameBoundSet dOuts, A, nw, nl) PCL1) 
               (deltaMap, q2 |->  dIns pairSetIO dOuts) (protMap, q1 |-> P') m TCS QIS PS) 
           [owise]    .

  op addHypothesis__ : BoolTerm ApproxEqConfig -> ApproxEqConfig .
  eq addHypothesis bt 
      aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) = 
      aConfig(Sigma, Delta, P, Ins, Outs, (A, bt), nw, nl )
  .             

  op addTypeToSig__ : Qid ApproxEqConfig -> ApproxEqConfig .
  eq addTypeToSig q 
      aConfig(Sigma (typesOf QIS), Delta, P, Ins, Outs, A, nw, nl) = 
      aConfig(Sigma (typesOf(QIS ; q)), Delta, P, Ins, Outs, A, nw, nl )
  .

  op addOpToSig____ : Qid IPDLPreType IPDLPreType ApproxEqConfig -> ApproxEqConfig .
  eq addOpToSig q t1 t2
      aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) = 
      aConfig(Sigma (q : preToType(t1) ~> preToType(t2)), Delta, P, Ins, Outs, A, nw, nl )
  .  

  op addDistToSig____ : Qid IPDLPreType IPDLPreType ApproxEqConfig -> ApproxEqConfig .
  eq addDistToSig q t1 t2
      aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) = 
      aConfig(Sigma (q : preToType(t1) ~>> preToType(t2)), Delta, P, Ins, Outs, A, nw, nl )
      .

  op listTypes_ : Env -> QidList .
  eq listTypes 
     (buildEnv (aConfig(Sigma (typesOf QIS) , Delta, P, Ins, Outs, A, nw, nl) PCL1) deltaMap protMap m TCS QIS' PS) = 
     list(QIS) .

  op listOps_ : Env -> QidList .
  eq listOps (buildEnv ((aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) PCL1) deltaMap protMap m TCS QIS PS) = 
     list(listOpsAux Sigma) .   

  op listOpsAux_ : Signature -> QidSet .
  eq listOpsAux ((q : T1 ~> T2) Sigma) = q ; (listOpsAux Sigma) .
  eq listOpsAux Sigma = none [owise] .

  op listDists_ : Env -> QidList .
  eq listDists (buildEnv ((aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) PCL1) deltaMap protMap m TCS QIS PS) = 
     list(listDistsAux Sigma) .   

  op listDistsAux_ : Signature -> QidSet .
  eq listDistsAux ((q : T1 ~>> T2) Sigma) = q ; (listDistsAux Sigma) .
  eq listDistsAux Sigma = none [owise] .

  op listParameters_ : Env -> QidList .
  eq listParameters (buildEnv ((aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) PCL1) deltaMap protMap m TCS QIS PS)
   = listParametersAux PS .

  var bd : Bounds .
  var bdl bdl' : List{Bounds} .

  op listCNB : CNameBound -> QidList .
  eq listCNB(chn q) = q .
  eq listCNB(chn (q[ntlist1])) = q '`[ (listNatTerms(ntlist1)) '`] .
  eq listCNB(fam (q[bdl])) = q '`[ listBounds(bdl) '`] .

  op listBounds : List{Bounds} -> QidList .
  eq listBounds(nil) = none .
  eq listBounds(bound nt) = 'bound (listNatTerm nt) .
  eq listBounds(fixedBound nt) = 'fixedBound (listNatTerm nt) .
  eq listBounds(dependentBound q) = 'dependentBound q .
  eq listBounds(bd bdl') = listBounds(bd) listBounds(bdl') .


  op listParametersAux_ : TypeContext -> QidList .
  eq listParametersAux emptyTypeContext = none .
  eq listParametersAux (q : typeName q') = q ': q' .
  eq listParametersAux ((q : typeName q') PS) =
     q ': q' '\n (listParametersAux PS) . 

  op listHypos_ : Env -> QidList .
  eq listHypos (buildEnv ((aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) PCL1) deltaMap protMap m TCS QIS PS)
   = listHyposAux A .

  var bt bt1 bt2 : BoolTerm .
  var nt nt1 nt2 : NatTerm .

  op listHyposAux_ : Set{BoolTerm} -> QidList .
  eq listHyposAux empty = none .
  eq listHyposAux bt = listBoolTerm bt .
  eq listHyposAux (bt, A) = (listBoolTerm bt) '\n (listHyposAux A) .

  op listBoolTerm_ : BoolTerm -> QidList .
  eq listBoolTerm falseBT = 'false .
  eq listBoolTerm trueBT = 'true .
  eq listBoolTerm (neg bt) = 'not listBoolTerm bt .
  eq listBoolTerm (bt1 conj bt2) = listBoolTerm bt1 'and listBoolTerm bt2 .
  eq listBoolTerm (bt1 disj bt2) = listBoolTerm bt1 'or listBoolTerm bt2 .
  eq listBoolTerm (nt1 =T= nt2) = listNatTerm nt1 '= listNatTerm nt2 .
  eq listBoolTerm (nt1 <T nt2) = listNatTerm nt1 '< listNatTerm nt2 .
  eq listBoolTerm (nt1 <=T nt2) = listNatTerm nt1 '<= listNatTerm nt2 .
  eq listBoolTerm (apply q nt ) = q '`(  (listNatTerm nt)  '`) .

  var  n : Nat .
  var ntlist1 ntlist2 : List{NatTerm} .

  op listNatTerm_ : NatTerm -> QidList .
  eq listNatTerm qidAsTerm(q) = q .
  eq listNatTerm natAsTerm(n) = qid(n) .
  eq listNatTerm (nt1 + nt2) = (listNatTerm nt1) '+ (listNatTerm nt2) .
  eq listNatTerm (nt1 - nt2) = (listNatTerm nt1) '- (listNatTerm nt2) .
  eq listNatTerm (nt1 * nt2) = (listNatTerm nt1) '* (listNatTerm nt2) .
  eq listNatTerm (fun q nt) = q '`( (listNatTerm nt) '`) .

  op listNatTerms : List{NatTerm} -> QidList .
  eq listNatTerms(nt) = listNatTerm nt .
  eq listNatTerms(ntlist1 ntlist2) = listNatTerms(ntlist1) listNatTerms(ntlist2) .

  op listChannels_ : Env -> QidList .
  eq listChannels (buildEnv ((aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) PCL1) deltaMap protMap m TCS QIS PS) = 
     listChannelsAux Delta .

  op listChannelsAux_ : ChannelContext -> QidList .
  eq listChannelsAux emptyChannelCtx = nil .
  eq listChannelsAux (Delta (chn q :: T1)) = q '\n (listChannelsAux Delta) .  
  eq listChannelsAux (Delta (fam (q[bdl]) :: T1)) = 
     q '`[ listBounds(bdl) '`] '\n (listChannelsAux Delta) .

  op listProtocols_ : Env -> QidList .
  eq listProtocols (buildEnv ((aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) PCL1) deltaMap protMap m TCS QIS PS) = 
     list(listProtocolsAux protMap) .   

  op listProtocolsAux_ : Map{Qid, Protocol} -> QidSet .
  eq listProtocolsAux empty = none .
  eq listProtocolsAux (protMap, q |-> P) = q ; (listProtocolsAux protMap) . 

  op getCrtProtocol_ : Env -> Protocol .
  eq getCrtProtocol (buildEnv ((aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) PCL1) deltaMap protMap m TCS QIS PS) = 
     P .    

  op listAssums_ : Env -> QidList .    
  eq listAssums (buildEnv PCL1 deltaMap protMap m TCS QIS PS) = 
     show-qids(list(QIS)) .

  op getChannel__ : Env CNameBound -> Protocol .
  eq getChannel  
    (buildEnv 
      ((aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) PCL1) deltaMap protMap m TCS QIS PS) cnb =
     getChannel P cnb .  

  *** generate the decls from the config .
  op decls_ : Env -> DeclList{IPDL} .
  eq decls (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl) PCL1) deltaMap protMap m TCS QIS PS) =
    type-decls(Sigma) op-decls(Sigma) dist-decls(Sigma) prot-decls(protMap) .

  op prot-decls : Map{Qid, Protocol} -> DeclList{IPDL} .
  eq prot-decls(empty) = nil .
  eq prot-decls((q |-> P, protMap)) =
    Decl[IPDL]{protocol q = P .} prot-decls(protMap) .

  op type-decls : Signature -> DeclList{IPDL} .
  eq type-decls((typesOf (q ; QIS)) Sigma)
    = Decl[IPDL]{type q .} type-decls((typesOf QIS) Sigma) .
  eq type-decls((typesOf none) Sigma) = type-decls(Sigma) .
  eq type-decls(Sigma) = nil [owise] .

  op op-decls : Signature -> DeclList{IPDL} .
  eq op-decls((q : T1 ~> T2) Sigma)
   = Decl[IPDL]{function q : typeToPre(T1) -> typeToPre(T2) .} op-decls(Sigma) .
  eq op-decls(Sigma) = nil [owise] .

  op dist-decls : Signature -> DeclList{IPDL} .
  eq dist-decls((q : T1 ~>> T2) Sigma)
   = Decl[IPDL]{distribution q : typeToPre(T1) -> typeToPre(T2) .} dist-decls(Sigma) .
  eq dist-decls(Sigma) = nil [owise] .

  

  var H : Header .
  var IL : ImportList .
  var SS : SortSet .
  var SSDS : SubsortDeclSet .
  var OPDS : OpDeclSet .
  var MAS : MembAxSet .
  var EQS : EquationSet .
  var RLS : RuleSet .
  var SDCLS : StratDeclSet .
  var SDEFS : StratDefSet .
  *** add a subproof as a strategy declaration and definition 
  
  op addSubproof___ : Env Module ATerm -> Module .
  eq addSubproof env m ({'subproof_=_.[I, I1] : 'SubProofDecl}) = 
     addSubproofAux env (addGenDecl env m I1) ({'subproof_=_.[I, I1] : 'SubProofDecl}) .

  op addSubproofAux___ : Env Module ATerm -> Module .
  ceq addSubproofAux env m ({'subproof_=_.[I, I1] : 'SubProofDecl}) = 
     (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS 
    (SDCLS
    strat q : nil @ 'ProtocolConfig [none] .) 
    (SDEFS
    sd q[[ empty ]] := aStrat [none] .
    )
     endsm
  )
  if x := if  (getMaxUsedNumber m) == -1 then 0 else getMaxUsedNumber m fi 
  /\ sNatPair aStrat y := proof2Strategy (read-proof(IPDL, env, I1)) x 
  /\ q := read-qid(I) 
  /\ (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ) := m .
      
  


  *** adds an assumption to a smod

  op add-assumption : Module Qid QidSet ChannelContext TypeContext Set{CNameBound} Reaction Reaction -> Module .
  eq add-assumption(
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ), q, QIS, Delta, Gamma, Ins, R1, R2 ) = 
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS 
    (RLS
    crl 'rConfig[
      'Sigma:Signature, 
      showAS-delta(Delta),
      showAS-gamma(Gamma),
      showAS-reaction(QIS, R1),
      showAS-inputs(Ins),
      'A:Set`{BoolTerm`},
      'T:IPDLType] 
      => 
      'rConfig[
      'Sigma:Signature, 
      showAS-delta(Delta),
      showAS-gamma(Gamma),
      showAS-reaction(QIS, R2),
      showAS-inputs(Ins), 
      'A:Set`{BoolTerm`},
      'T:IPDLType] 
      if '_==_['T:IPDLType,'bool.IPDLType] = 'true.Bool
      [label(q)] .
    ) 
    (SDCLS
    strat (qid('apply q)) : 'ChannelName @ 'ProtocolConfig [none] .
    strat (qid('apply q 'NF)) : 'ChannelName @ 'ProtocolConfig [none] .
    strat (qid('apply q 'Pre)) : 'ChannelName @ 'ProtocolConfig [none] .
    ) 
    (SDEFS
    sd (qid('apply q))[['cn:ChannelName]] := (qid('apply q 'NF))[['cn:ChannelName]] or-else
    (qid('apply q 'Pre))[['cn:ChannelName]] [none] .
    
    sd (qid('apply q 'NF))[['cn:ChannelName]] := match 'pConf:ProtocolConfig s.t. ('startsWithNew_[
    'pConf:ProtocolConfig] = 'true.Bool) ? 'CONG-NEW-NF[none]{(qid('apply q 'NF))[['cn:ChannelName]]} :
    matchrew 'pConf:ProtocolConfig s.t. 'pConfig['Sigma:Signature,'Delta:ChannelContext,'P:Protocol,
    'Ins:Set`{CNameBound`},'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] := 'pConf:ProtocolConfig by
    'pConf:ProtocolConfig
    using (('CONG-COMP-RIGHT[
       'P1:Protocol <- 'keepOne__['P:Protocol,'chn_['cn:ChannelName]] ;
       'Q:Protocol <- 'removeOne__['P:Protocol,'chn_['cn:ChannelName]]]
    {
    'CONG-REACT[
       'o:ChannelName <- 'cn:ChannelName]{'cong-nf[none]{q[none]{empty}}}
       } )
       or-else
       'CONG-REACT[
       'o:ChannelName <- 'cn:ChannelName]{'cong-nf[none]{q[none]{empty}}} 
     ) [none]
     .

    sd (qid('apply q 'Pre))[['cn:ChannelName]] := match 'pConf:ProtocolConfig s.t. ('startsWithNew_[
    'pConf:ProtocolConfig] = 'true.Bool) ? 'CONG-NEW-NF[none]{(qid('apply q 'Pre))[['cn:ChannelName]]} :
    matchrew 'pConf:ProtocolConfig s.t. 'pConfig['Sigma:Signature,'Delta:ChannelContext,'P:Protocol,
    'Ins:Set`{CNameBound`},'Outs:Set`{CNameBound`},'A:Set`{BoolTerm`}] := 'pConf:ProtocolConfig by
    'pConf:ProtocolConfig using ('CONG-COMP-RIGHT[
       'P1:Protocol <- 'keepOne__['P:Protocol,'chn_['cn:ChannelName]] ;
       'Q:Protocol <- 'removeOne__['P:Protocol,'chn_['cn:ChannelName]]]
    {
    'CONG-REACT[
       'o:ChannelName <- 'cn:ChannelName]{'cong-pre-nf[none]{q[none]{empty}}}
     ; try('pre2Nf[none]{empty})  
       }
       or-else
       'CONG-REACT[
       'o:ChannelName <- 'cn:ChannelName]{'cong-pre-nf[none]{q[none]{empty}}}
       ; try('pre2Nf[none]{empty})
    ) [none]
       .
    )
     endsm
  ) 
     .

  var E1 E2 : IPDLExpression . 

  op add-assumption-as-eq : Module Qid QidSet TypeContext IPDLExpression IPDLExpression -> Module .
  eq add-assumption-as-eq(
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS EQS RLS SDCLS SDEFS
     endsm
  ), q, QIS, Gamma, E1, E2 ) = 
    (smod H is
    IL
    sorts SS .
    SSDS OPDS MAS 
    (EQS 
    eq showAS-expression(QIS, E1) = showAS-expression(QIS, E2)[ none ].
     *** TODO: add the name as label
    )
    RLS
    SDCLS
    SDEFS
   
     endsm
      )
      .   
    

endm

*** ----------------------------------------------------------------------------

view IPDL/AnalysisState from ANALYSIS-STATE to IPDL/ANALYSIS-STATE is
  sort State to Env .
endv

*** ----------------------------------------------------------------------------

mod IPDL/PARSING is
  including SYNTACTIC-ANALYSIS { IPDL, IPDL/AnalysisState } .
  including APPROX-EQUALITY .
  protecting SET{TypeContextElem} .

  var L : IPDL .
  var QIL : QidList .
  var QIS QIS' : QidSet .
  vars $I I $I1 I1 $I2 I2 $I3 I3 I4 I5 T S DT IT CT R1 R2 VS : ATerm .
  vars $ QI QI1 QI2 QI3 QI4 q : Qid .
  var env : Env .
  var protMap : Map{Qid, Protocol} .
  var aConf : ApproxEqConfig .
  var Sigma : Signature .
  var Delta : ChannelContext .
  var Gamma : TypeContext .
  var Ins Outs : Set{CNameBound} .
  var A : Set{BoolTerm} .
  var P : Protocol . 
  var m : Module .
  var TCS : Set{TypeContextElem} .
  var TL : ATermList .
  var WA : WarningArgs .
  var nw : Width .
  var nl : Length .

  *** parse input  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  eq parse L input (QIL) in env
   = (scan L input (QIL : 'Command))
     or-else (scan L input (QIL : 'TopDecl)  then analyse L declaration in env)  
     or-else (scan L input (QIL : 'TopProof)  then analyse L proof in env) 
     [label parse-IPDL-input]. 

  op analyse_declaration : IPDL -> AnalysisAction{IPDL} .
  eq analyse L declaration {'type_.[I] : 'TypeDecl}
   = try {'type_. [
        check L tdid (I)
      ] : 'TypeDecl} .
  eq analyse L declaration {'hypothesis_.[I] : 'HypoDecl}
   = try {'hypothesis_. [
        solve L boolTerm (I)
        then
        check L emptyTypeContext boolTerm
      ] : 'HypoDecl} .    
  eq analyse L declaration {'function_:_->_.[I, I1, I2] : 'OpDecl}
   = try {'function_:_->_. [
        solve L fName (I) then
        check L fname,
        solve L preType (I1) then
        check L preType,
        solve L preType (I2) then
        check L preType
      ] : 'OpDecl} .  
  eq analyse L declaration {'distribution_:_->_.[I, I1, I2] : 'DistDecl}
   = try {'distribution_:_->_. [
        solve L dName (I) then
        check L dname,
        solve L preType (I1) then
        check L preType,
        solve L preType (I2) then
        check L preType
      ] : 'DistDecl} .  
  eq analyse L declaration {'channel`context_=_. [I1, I2] : 'DeltaDecl}
   = try {'channel`context_=_. [
         solve L dName (I1), 
         solve L channelDeclList (I2)
      ] : 'DeltaDecl}  
   .   
  ceq analyse L declaration {'input_:_.[I, I1] : 'InDecl}
   = try {'input_:_. [
        solve L cNameIndex (I), *** check L cname (I),
        solve L preType (I1) then
        check L preType
      ] : 'InDecl} 
   if I :: 'CName   .       
  ceq analyse L declaration {'input_:_.[I, I1] : 'InDecl}
   = try {'input_:_. [
        solve L cNameIndex (I), *** check L cname (I),
        solve L preType (I1) then
        check L preType
      ] : 'InDecl} 
   if I :: 'CNameIndex   .  
  ceq analyse L declaration {'input_:_.[I, I1] : 'InDecl}
   = try {'input_:_. [
        solve L familyName (I) then
        check L familyName, 
        solve L preType (I1) then
        check L preType
      ] : 'InDecl} 
   if I :: 'FamilyName   .   
  eq analyse L declaration {'parameter_:_.[I, I1] : 'ParamDecl}
   = try {'parameter_:_. [
        solve L paramName (I), *** the name should be new!
        solve L preType (I1) then
        check L preType
      ] : 'ParamDecl} .              
  ceq analyse L declaration {'output_:_.[I, I1] : 'OutDecl}
   = try {'output_:_. [
        solve L cNameIndex (I),
        solve L preType (I1) then
        check L preType 
      ] : 'OutDecl} 
  if I :: 'CName .     
  ceq analyse L declaration {'output_:_.[I, I1] : 'OutDecl}
   = try {'output_:_. [
        solve L cNameIndex (I),
        solve L preType (I1) then
        check L preType 
      ] : 'OutDecl} 
  if I :: 'CNameIndex . 
  ceq analyse L declaration {'output_:_.[I, I1] : 'OutDecl}
   = try {'output_:_. [
        solve L familyName (I) then
        check L familyName, 
        solve L preType (I1) then
        check L preType
      ] : 'OutDecl} 
   if I :: 'FamilyName   . 
  eq analyse L declaration {'subproof_=_.[I, I1] : 'SubProofDecl}
   = try {'subproof_=_. [
        check L sname (I),
         analyse L proof (I1)
      ] : 'SubProofDecl} .         
  eq analyse L declaration {'protocol_=_.[I, I1] : 'PDecl}
   = try {'protocol_=_. [
        check L pname (I),
           solve L protocol (I1) 
      *** then check L protocol
      *** then type check L protocol
      ] : 'PDecl} .       
  eq analyse L declaration {'import_.[I] : 'Import}
   = try {'import_. [
        check L moduleName (I)
      ] : 'Import} .  
  eq analyse L declaration  {'assumption_using_:_;_;_|=_=_.[I, VS, DT, CT, IT, R1, R2] : 'AssumDecl}
   = try  {'assumption_using_:_;_;_|=_=_.[
       check L aName (I),  *** should check that it's not used as assum name or as rule name!
       check L assumVars (VS),
       check L delta (DT), 
       check L gamma (CT), 
       check L inputs (IT), 
       solve L reaction (R1) then
       check L emptyTypeContext reaction , *** TODO: should be read-gamma(L, CT)?
       solve L reaction (R2) then
       check L emptyTypeContext reaction
        ] : 'AssumDecl} . 
   eq analyse L declaration  {'assumption`%manual_using_:_|=_=_.[I, VS, CT, I1, I2] : 'AssumDecl}
   = try  {'assumption`%manual_using_:_|=_=_.[
       check L aName (I),  *** should check that it's not used as assum name or as rule name!
       check L assumVars (VS),
       check L gamma (CT), 
       solve L expression (I1),
       solve L expression (I2)
       
       *** check L emptyTypeContext reaction , *** TODO: should be read-gamma(L, CT)?
       
       *** check L emptyTypeContext reaction
        ] : 'AssumDecl} .
   eq analyse L declaration  {'assumption`%automatic_using_:_|=_=_.[I, VS, CT, I1, I2] : 'AssumDecl}
   = try  {'assumption`%automatic_using_:_|=_=_.[
       check L aName (I),  *** should check that it's not used as assum name or as rule name!
       check L assumVars (VS),
       check L gamma (CT), 
       solve L expression (I1),
       solve L expression (I2)
       
       *** check L emptyTypeContext reaction , *** TODO: should be read-gamma(L, CT)?
       
       *** check L emptyTypeContext reaction
        ] : 'AssumDecl} .           
 
  op solve_channelDeclList : IPDL -> AnalysisAction{IPDL} .
  ceq solve L channelDeclList {'input_:_ [I1, I2] : 'ChannelDecl}
   = try {'input_:_ [
           solve L cNameIndex (I1), 
           solve L preType (I2)
      ] : 'ChannelDecl} 
   if I1 :: 'CName .
  ceq solve L channelDeclList {'input_:_ [I1, I2] : 'ChannelDecl}
   = try {'input_:_ [
           solve L cNameIndex (I1), 
           solve L preType (I2)
      ] : 'ChannelDecl} 
   if I1 :: 'CNameIndex .
  ceq solve L channelDeclList {'input_:_ [I1, I2] : 'ChannelDecl}
   = try {'input_:_ [
           solve L familyName (I1), 
           solve L preType (I2)
      ] : 'ChannelDecl} 
   if I1 :: 'FamilyName .   
  ceq solve L channelDeclList {'output_:_ [I1, I2] : 'ChannelDecl}
   = try {'output_:_ [
           solve L cNameIndex (I1), 
           solve L preType (I2)
      ] : 'ChannelDecl} 
   if I1 :: 'CName   .
  ceq solve L channelDeclList {'output_:_ [I1, I2] : 'ChannelDecl}
   = try {'output_:_ [
           solve L cNameIndex (I1), 
           solve L preType (I2)
      ] : 'ChannelDecl} 
   if I1 :: 'CNameIndex  .
   ceq solve L channelDeclList {'output_:_ [I1, I2] : 'ChannelDecl}
   = try {'output_:_ [
           solve L familyName (I1), 
           solve L preType (I2)
      ] : 'ChannelDecl} 
   if I1 :: 'FamilyName   .  
  eq solve L channelDeclList {'_;_ [I1, I2] : 'ChannelDeclList}
   = try {'_;_ [
        solve L channelDeclList (I1), 
        solve L channelDeclList (I2)
      ] : 'ChannelDeclList} .
    

  op analyse_proof : IPDL -> AnalysisAction{IPDL} .        
  eq analyse L proof {'start`with_over_[I1, I2] : 'TopProof} 
   = try {'start`with_over_[
           check L declaredPname (I1),
           solve L dName (I2) ***TODO : check that is in domain of deltaMap
      ] : 'TopProof} .
  eq analyse L proof {'absorb_[I1] : 'TopProof} 
   = try {'absorb_[
      solve L cNameBound (I1) 
      ] : 'TopProof} .
  eq analyse L proof {'turn`neg`into`otherwise`for_[I1] : 'TopProof} 
   = try {'turn`neg`into`otherwise`for_[
      solve L cNameBound (I1) 
      ] : 'TopProof} .
  eq analyse L proof {'turn`otherwise`into`neg`for_[I1] : 'TopProof} 
   = try {'turn`otherwise`into`neg`for_[
      solve L cNameBound (I1) 
      ] : 'TopProof} .     
  eq analyse L proof {'combine_[I1] : 'TopProof} 
   = try {'combine_[
      solve L cNameBound (I1) 
      ] : 'TopProof} .
  eq analyse L proof {'call_[I1] : 'TopProof} 
   = try {'call_[
      check L sname (I1) 
      ] : 'TopProof} . 
  eq analyse L proof {'ungroup_[I1] : 'TopProof} 
   = try {'ungroup_[
      solve L cNameBound (I1) 
      ] : 'TopProof} .       
  eq analyse L proof {'unsplit_[I1] : 'TopProof} 
   = try {'unsplit_[
      solve L cNameIndex (I1) 
      ] : 'TopProof} .    
  eq analyse L proof {'split_on`first`index [ I ] : 'TopProof } 
   = try {'split_on`first`index [
      solve L cNameBound (I) 
      ] : 'TopProof} .
  eq analyse L proof {'split_on`second`index [ I ] : 'TopProof } 
   = try {'split_on`second`index [
      solve L cNameBound (I) 
      ] : 'TopProof} .  
  eq analyse L proof {'merge`cases`for_[I1] : 'TopProof} 
   = try {'merge`cases`for_[
      solve L cNameBound (I1) 
      ] : 'TopProof} .     
  eq analyse L proof {'merge`case_=_with`otherwise`for_[I, I1, I2] : 'TopProof}
   = try {'merge`case_=_with`otherwise`for_[
      solve L cNameIndex (I), 
      solve L natTerm (I1), 
      solve L cNameBound (I2)] : 'TopProof} .               
  eq analyse L proof {'fold_into_[
      I1, I2
      ] : 'TopProof} 
   = try {'fold_into_[
      solve L cNameBound (I1), 
      solve L cNameBound (I2)
      ] : 'TopProof} .
  eq analyse L proof {'rename_in_[I1, I2] : 'TopProof} 
   = try {'rename_in_[
      solve L qidPairList (I1), 
      solve L cNameBound (I2)
      ] : 'TopProof} .    
  eq analyse L proof {'rename`variables_of_[I1, I2] : 'TopProof} 
   = try {'rename`variables_of_[
      solve L qidPairList (I1), 
      solve L cNameBound (I2)
      ] : 'TopProof} .        
  eq analyse L proof {'subst_into_[
      I1, I2
      ] : 'TopProof} 
   = try {'subst_into_[
      solve L cNameBound (I1), 
      solve L cNameBound (I2) 
      ] : 'TopProof} .  
  eq analyse L proof {'drop`read_from_[
      I1, I2
      ] : 'TopProof} 
   = try {'drop`read_from_[
      solve L cNameBound (I1), 
      solve L cNameBound (I2) 
      ] : 'TopProof} .      
  eq analyse L proof {'use`assumption_on_[{'assumName[I1] : 'AssumName}, {'cname[I2] : 'CName}] : 'TopProof}     
   = try {'use`assumption_on_[
       return {I1 : 'AssumName}, *** should check that it has been declared
       return {I2 : 'CName} *** should check that it is in the current protocol
      ] : 'TopProof} .
  eq analyse L proof {'_then_[I1, I2] : 'TopProof} 
   = try {'_then_[
           analyse L proof (I1),
           analyse L proof (I2)
      ] : 'TopProof} .  
  eq analyse L proof {'sym`from_`(_`)[I1, I2] : 'TopProof} 
   = try {'sym`from_`(_`)[
           solve L protocol (I1), 
           analyse L proof (I2)
      ] : 'TopProof} .
  eq analyse L proof {'sym`from_over_`(_`)[I, I1, I2] : 'TopProof} 
   = try {'sym`from_`(_`)[
           solve L protocol (I),
           solve L dName (I1), 
           analyse L proof (I2)
      ] : 'TopProof} .    
  eq analyse L proof {'move_on`each`branch`of_ [I1, I2] : 'TopProof }
   = try {'move_on`each`branch`of_ [
          solve L ruleTarget (I1), 
          solve L ruleTarget (I2)] : 'TopProof } .
  eq analyse L proof {'on`branch_of_`(_`) [I, I1, I2] : 'TopProof }
   = try {'on`branch_of_`(_`)[
           solve L boolTerm (I), 
           solve L ruleTarget (I1),
           analyse L proof (I2)
      ] : 'TopProof} .    
  eq analyse L proof {'todo.TopProof : 'TopProof} 
   = return {'todo.TopProof : 'TopProof} .
  eq analyse L proof {'idle.TopProof : 'TopProof} 
   = return {'idle.TopProof : 'TopProof} . 
  eq analyse L proof {'try`sym`from_:_done[I1, I2] : 'TopProof} 
   = try {'try`sym`from_:_done[
          solve L protocol (I1), 
          analyse L proof (I2)
      ] : 'TopProof} .
  eq analyse L proof {'try`sym`from_:_[I1, I2] : 'TopProof} 
   = try {'try`sym`from_:_[
          solve L protocol (I1), 
          analyse L proof (I2)
      ] : 'TopProof} .  
  eq analyse L proof 
   {'add`internal`family_indices:_bounds:_typed:_assigned:_ [I, I1, I2, CT, I3] : 'TopProof}      
   = try {'add`internal`family_indices:_bounds:_typed:_assigned:_ [
        solve L cNameIndex (I), 
        solve L natTerms (I1), 
        solve L bounds (I2), 
        solve L preType (CT), 
        solve L cases (I3)] : 'TopProof} . 
  eq analyse L proof 
   {'add`internal`channel_typed:_assigned:_ [I, CT, I3] : 'TopProof}      
   = try {'add`internal`channel_typed:_assigned:_ [
        solve L cNameIndex (I), 
        solve L preType (CT), 
        solve L cases (I3)] : 'TopProof} .       
  eq analyse L proof       
    {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`) 
                [I, I1, I2, I3, I4, I5 ] : 'TopProof}
   = try {'in`the`presence`of_rewrite_to_by`induction`on_bound_`(_`)
      [
      solve L cNameBoundList (I), 
      solve L ruleTarget (I1), 
      solve L cases (I2), 
      solve L natTerm (I3), 
      solve L natTerm (I4), 
      analyse L proof (I5) ] : 'TopProof} .
  eq analyse L proof       
    {'try`in`the`presence`of_rewrite_to_by`induction`on_bound_:_
                [I, I1, I2, I3, I4, I5 ] : 'TopProof}
   = try {'try`in`the`presence`of_rewrite_to_by`induction`on_bound_:_
      [
      solve L cNameBoundList (I), 
      solve L ruleTarget (I1), 
      solve L cases (I2), 
      solve L natTerm (I3), 
      solve L natTerm (I4), 
      analyse L proof (I5) ] : 'TopProof} .    
  eq analyse L proof {'case`distinction`on_`(_`) [I1, I2] : 'TopProof }
   = try {'case`distinction`on_`(_`) [
        solve L ruleTarget (I1), 
        solve L proofCaseList (I2)
      ] : 'TopProof } .
  eq analyse L proof {'try`case`distinction`on_:`(case:_`) [I1, I2] : 'TopProof}
   = try {'try`case`distinction`on_:`(case:_`) [
        solve L ruleTarget (I1), 
        analyse L proof (I2)
      ] : 'TopProof } .  
  eq analyse L proof {'try`case`distinction`on_:`(case:_done`)`(case:_`) [I, I1, I2] : 'TopProof}
   = try {'try`case`distinction`on_:`(case:_done`)`(case:_`) [
        solve L ruleTarget (I), 
        analyse L proof (I1),
        analyse L proof (I2)
      ] : 'TopProof } .  
  eq analyse L proof {'diverge`on_with_var_ [I, I1, I2] : 'TopProof} 
   = try  {'diverge`on_with_var_ [
          solve L cNameBound (I), 
          solve L cNameBound (I1), 
          solve L expression (I2)
      ] : 'TopProof} 
   .   
   eq analyse L proof {'diverge`on_with`branch_of_var_ [I, I1, I2, I3] : 'TopProof} 
   = try  {'diverge`on_with`branch_of_var_ [
          solve L cNameBound (I), 
          solve L boolTerm (I1),
          solve L cNameBound (I2), 
          solve L expression (I3)
      ] : 'TopProof} 
   .   
  eq analyse L proof {'reverse`subst_in_using_ [I1, I2, I3] : 'TopProof}
   = try {'reverse`subst_in_using_ [
           solve L cNameBound (I1),  
           solve L cNameBound (I2), 
           solve L cNameBound (I3) 
      ] : 'TopProof} .  
  eq analyse L proof {'subst`or`diverge_into_var_ [I1, I2, I3] : 'TopProof}
   = try {'subst`or`diverge_into_var_ [
           solve L cNameBound (I1),  
           solve L cNameBound (I2), 
           solve L expression (I3)
      ] : 'TopProof} .
   eq analyse L proof {'on`reaction`of_`(_`) [I1, I2] : 'TopProof}
   = try {'on`reaction`of_`(_`) [
           solve L cNameBound (I1), 
           analyse L reactionProof (I2)
      ] : 'TopProof} .
   eq analyse L proof {'remove`only`branch`of_ [I] : 'TopProof} 
    = try {'remove`only`branch`of_ [
          solve L cNameBound (I)
      ] : 'TopProof} .
   eq analyse L proof {'on`all`branches`of_split_on`first`index [I1, I2] : 'TopProof}
    = try {'on`all`branches`of_split_on`first`index [
             solve L cNameBound (I1), 
             solve L cNameBound (I2)
      ] : 'TopProof} .
   eq analyse L proof {'on`all`branches`of_split_on`second`index [I1, I2] : 'TopProof}
    = try {'on`all`branches`of_split_on`second`index [
             solve L cNameBound (I1), 
             solve L cNameBound (I2)
      ] : 'TopProof} .   
   eq analyse L proof {'group_in_indices:_bounds:_[I, I1, I2, I3] : 'TopProof} 
    = try {'group_in_indices:_bounds:_[
       solve L cNameBoundList (I), 
       solve L pname (I1), 
       solve L natTerms (I2), 
       solve L bounds (I3) ] : 'TopProof}  . 

  op analyse_reactionProof : IPDL -> AnalysisAction{IPDL} .
  eq analyse L reactionProof {'idle.ReactionProof : 'ReactionProof} 
   = return {'idle.ReactionProof : 'ReactionProof} .  
  eq analyse L reactionProof {'_then_[I1, I2] : 'ReactionProof} 
   = try {'_then_[
           analyse L reactionProof (I1),
           analyse L reactionProof (I2)
      ] : 'ReactionProof} .        
  eq analyse L reactionProof {'if-ext`on_ [I] : 'ReactionProof}
   = try {'if-ext`on_ [
            solve L expression (I)
      ] : 'ReactionProof} .

     
  op solve_ruleTarget : IPDL -> AnalysisAction{IPDL} .
  eq solve L ruleTarget {'channel_ [ I ] : 'RuleTarget }
   = try {'channel_ [ solve L cNameIndex I ] : 'RuleTarget } .
  eq solve L ruleTarget {'family_ [ I ] : 'RuleTarget }
   = try {'family_ [ solve L familyName I ] : 'RuleTarget } .
  eq solve L ruleTarget {'group_ [ I ] : 'RuleTarget }
   = try {'group_ [ solve L familyName I ] : 'RuleTarget } .  

  op solve_proofCase : IPDL -> AnalysisAction{IPDL} .
  eq solve L proofCase {'case:`(_`) [ I ] : 'ProofCase }
   = try {'case:`(_`) [ 
      analyse L proof (I) 
      ] : 'ProofCase } .

  op solve_proofCaseList : IPDL -> AnalysisAction{IPDL} .
  eq solve L proofCaseList {'__ [I1, I2] : 'ProofCaseList}
   = try {'__ [ 
       solve L proofCaseList (I1), 
       solve L proofCaseList (I2)
      ] : 'ProofCaseList} .
  ceq solve L proofCaseList I = 
      solve L proofCase I 
  if I :: 'ProofCase .        

  op check_assumVars : IPDL -> AnalysisAction{IPDL} .
   eq check L assumVars {'qlist[I] : 'QList}
   = return {'qlist[I] : 'QList} .

  op check_delta : IPDL -> AnalysisAction{IPDL} .
  eq check L delta {'emptyCCtxt.ChnCtxt : 'ChnCtxt} = 
     return {'emptyCCtxt.ChnCtxt : 'ChnCtxt} .
  eq check L delta {'_::_[I, T] : 'TypedChn} =
     try {'_::_[
           adjust L cName (I),
           solve L preType (T) then  
           check L preType
      ] : 'TypedChn} .
  eq check L delta {'__[I1, I2] : 'ChnCtxt} = 
     try {'__[
           check L delta (I1), 
           check L delta (I2)
      ] : 'ChnCtxt} .

  op check_gamma : IPDL -> AnalysisAction{IPDL} .
  eq check L gamma {'emptyTCtxt.TypeCtxt : 'TypeCtxt} = 
     return {'emptyTCtxt.TypeCtxt : 'TypeCtxt} .
  eq check L gamma {'_:_[I, T] : 'TypedVar} =
     try {'_:_[
           check L varName (I), 
           solve L preType (T) then  
           check L preType 
      ] : 'TypedVar} .
  eq check L gamma {'__[I1, I2] : 'TypeCtxt} = 
     try {'__[
           check L gamma (I1), 
           check L gamma (I2)
      ] : 'TypeCtxt} .

  op check_inputs : IPDL -> AnalysisAction{IPDL} .
  eq check L inputs {'nil.QList : 'QList} 
   = return {'nil.QList : 'QList} .
  eq check L inputs {'qlist[I] : 'QList}
   = return {I : 'QList} . 


  

  *** Protocols are checked in three steps 
  *** 1. solve L protocol eliminates all token constructors
  *** 2. check L protocol checks identifiers
  *** 3. type check L protocol performs the type checking

  *** 1. elimination of token constructors

  op solve_qidPairList : IPDL -> AnalysisAction{IPDL} .
  ceq solve L qidPairList I =
      solve L qidPair I
   if I :: 'QidPair . 
   eq solve L qidPairList {'_`,_[I1, I2] : 'QidPairList}
   = try {'_`,_[
       solve L qidPairList (I1), 
       solve L qidPairList (I2)
      ] : 'QidPairList} .  

  op solve_qidPair : IPDL -> AnalysisAction{IPDL} .
  eq solve L qidPair {'_to_[ I1, I2] : 'QidPair}
   = try {'_to_[ 
        solve L vName (I1),  
        solve L vName (I2) ] : 'QidPair} . 

  op solve_paramName : IPDL -> AnalysisAction{IPDL} .
  eq solve L paramName {'paramName[I] : 'ParamName} 
   = return {I : 'ParamName} .

  op solve_cNameBound : IPDL -> AnalysisAction{IPDL} .
  eq solve L cNameBound {'fam_[I] : 'CNameBound} 
   = try {'fam_[solve L familyName (I)] : 'CNameBound} .
  eq solve L cNameBound {'chn_[I] : 'CNameBound} 
   = try {'chn_[solve L cNameIndex (I)] : 'CNameBound} . 

  op solve_cNameBoundList : IPDL  -> AnalysisAction{IPDL} .
  ceq solve L cNameBoundList I 
    =  solve L cNameBound I
   if I :: 'CNameBound .
  eq solve L cNameBoundList {'_`,_[I1, I2] : 'CNameBoundList}
   = try {'_`,_[
       solve L cNameBoundList (I1), 
       solve L cNameBoundList (I2)
      ] : 'CNameBoundList} . 



  op solve_cNameIndex : IPDL -> AnalysisAction{IPDL} .
  eq solve L cNameIndex {'cname[I] : 'CName} 
   = return {I : 'CName} .
  eq solve L cNameIndex {'_`[_`][ I1, I2] : 'CNameIndex} 
   = try {'_`[_`][ 
        adjust L cName (I1),
        solve L natTerms (I2)
      ] : 'CNameIndex} .

  op solve_natTerm : IPDL -> AnalysisAction{IPDL} .
  eq solve L natTerm {'nid[I] : 'NId}
   = check rat(string(read-qid(I)), 10) :: Nat
     and-then return {I : 'Nat}
     or-else return {I : 'CId} .
  eq solve L natTerm  {'`(_`) [I] : 'NatTerm}    
   = try {'`(_`) [solve L natTerm I] : 'NatTerm} .   
  eq solve L natTerm {'_+_[I1, I2] : 'NatTerm}
   = try {'_+_[solve L natTerm (I1), solve L natTerm (I2)] : 'NatTerm} .
  eq solve L natTerm {'_-_[I1, I2] : 'NatTerm}
   = try {'_-_[solve L natTerm (I1),solve L natTerm (I2)] : 'NatTerm} .
  eq solve L natTerm {'_*_[I1, I2] : 'NatTerm}
   = try {'_*_[solve L natTerm (I1),solve L natTerm (I2)] : 'NatTerm} .
  eq solve L natTerm {'_`(_`)[I1, I2] : 'NatTerm}
   = try {'_`(_`)[solve L fName (I1),solve L natTerm (I2)] : 'NatTerm} .

  op solve_natTerms : IPDL -> AnalysisAction{IPDL} . 
  eq solve L natTerms {I : 'NId}
   = solve L natTerm {I : 'NId} .
  eq solve L natTerms {I : 'NatTerm}
   = solve L natTerm {I : 'NatTerm} .
***   eq solve L natTerms {'qlist[I] : 'QList} 
***    = solve L natTerms {I : 'NatTerm} . 
  eq solve L natTerms {'_`,_[I1, I2] : 'NatTermList}
   = try {'_`,_[
       solve L natTerms (I1), 
       solve L natTerms (I2)
      ] : 'NatTermList} .

  op solve_boolTerm :  IPDL -> AnalysisAction{IPDL} .
  eq solve L boolTerm {'falseBT.BoolTerm : 'BoolTerm} = 
     return {'falseBT.BoolTerm : 'BoolTerm} .
  eq solve L boolTerm {'trueBT.BoolTerm : 'BoolTerm} = 
     return {'trueBT.BoolTerm : 'BoolTerm} . 
  eq solve L boolTerm {'_=_[I1, I2] : 'BoolTerm} =   
     try {'_=_ [
        solve L natTerm (I1),
        solve L natTerm (I2)
      ] : 'BoolTerm} .   
  eq solve L boolTerm {'_<_[I1, I2] : 'BoolTerm} =   
     try {'_<_ [
        solve L natTerm (I1),
        solve L natTerm (I2)
      ] : 'BoolTerm} .    
  eq solve L boolTerm {'_<=_[I1, I2] : 'BoolTerm} =   
     try {'_<=_ [
        solve L natTerm (I1),
        solve L natTerm (I2)
      ] : 'BoolTerm} .    
  eq solve L boolTerm {'_and_[I1, I2] : 'BoolTerm} =   
     try {'_and_ [
        solve L boolTerm (I1),
        solve L boolTerm (I2)
      ] : 'BoolTerm} .
  eq solve L boolTerm {'_or_[I1, I2] : 'BoolTerm} =   
     try {'_or_ [
        solve L boolTerm (I1),
        solve L boolTerm (I2)
      ] : 'BoolTerm} . 
  eq solve L boolTerm {'not_[I1] : 'BoolTerm} =   
     try {'not_ [
        solve L boolTerm (I1)
      ] : 'BoolTerm} .         
  eq solve L boolTerm  {'_`(_`)[I1, I2] : 'BoolTerm} =
   try {'_`(_`)[
       solve L predName (I1), 
       solve L natTerm (I2)
    ] : 'BoolTerm} .

  op solve_predName : IPDL -> AnalysisAction{IPDL} .
  eq solve L predName {'predId[I] : 'PredName} 
   = return {I : 'PredName} .

  op solve_familyName : IPDL -> AnalysisAction{IPDL} .
  eq solve L familyName {'_`[_`][I1, I2] : 'FamilyName} 
   = try {'_`[_`][
       adjust L cName (I1), 
       solve L bounds (I2)
      ] : 'FamilyName} . 

  op solve_bound : IPDL -> AnalysisAction{IPDL} .  
  eq solve L bound {'bound_[I] : 'Bound}
   = try {'bound_[
       solve L natTerm (I)]
       : 'Bound} .
  eq solve L bound {'fixedBound_[I] : 'Bound}
   = try {'fixedBound_[
       solve L natTerm (I)]
       : 'Bound} .
  eq solve L bound {'dependentBound_[I] : 'Bound}
   = try {'dependentBound_[
       solve L fName (I)]
       : 'Bound} .          

  op solve_bounds : IPDL -> AnalysisAction{IPDL} .
  ceq solve L bounds I
   = solve L bound I 
  if I :: 'Bound .
  eq solve L bounds {'__[I1, I2] : 'BoundList}
   = try {'__[
       solve L bounds (I1), 
       solve L bounds (I2)
      ] : 'BoundList} .

  op solve_whenCond : IPDL -> AnalysisAction{IPDL} .
  eq solve L whenCond {'otherwise.WhenCond : 'WhenCond} 
   = return {'otherwise.WhenCond : 'WhenCond} .
  eq solve L whenCond {'when_[I] : 'WhenCond}
   = try {'when_[
       solve L boolTerm (I)]
       : 'WhenCond} .

  op solve_when : IPDL -> AnalysisAction{IPDL} .
  eq solve L when {'_-->_[I1, I2] : 'When}
   = try {'_-->_[
       solve L whenCond (I1), 
       solve L cases (I2)
      ] : 'When} .

  op solve_whenList : IPDL -> AnalysisAction{IPDL} .
  eq solve L whenList {'emptyWhen.WhenList : 'WhenList} 
   = return {'emptyWhen.WhenList : 'WhenList} .
  eq solve L whenList {'`(_`) [I] : 'WhenList} 
   = try {'`(_`) [solve L whenList I] : 'WhenList} . 
  ceq solve L whenList I
   = solve L when I if I :: 'When  . 
  eq solve L whenList {'_;;_[I1, I2] : 'WhenList}
   = try {'_;;_[
       solve L whenList (I1), 
       solve L whenList (I2)
      ] : 'WhenList} . 

  op solve_cases : IPDL -> AnalysisAction{IPDL} . 
  ceq solve L cases I 
   = solve L reaction I if I :: 'IPDLReaction . 
  ceq solve L cases I
    = solve L protocol I if I :: 'IPDLProtocol .
  ceq solve L cases I 
   = solve L whenList I if I :: 'WhenList .  
  ceq solve L cases I 
   = solve L when I if I :: 'When .  

  op solve_localDecls : IPDL -> AnalysisAction{IPDL} .
  ceq solve L localDecls I = solve L localDecl I 
   if I :: 'LocalDecl .
  eq solve L localDecls {'_and_[I1, I2] : 'LocalDeclList} 
   = try {'_and_[
       solve L localDecls (I1), 
       solve L localDecls (I2)
      ] : 'LocalDeclList} .  

  op solve_localDecl : IPDL -> AnalysisAction{IPDL} .
  eq solve L localDecl {'_=_[I1, I2] : 'LocalDecl} 
   = try {'_=_[
           solve L pname (I1), 
           solve L protocol (I2)] : 'LocalDecl} .

  op solve_pname : IPDL ->  AnalysisAction{IPDL} .          
  eq solve L pname {'pname[I] : 'PName} = 
     return {I : 'PName} .

  op solve_protocol : IPDL ->  AnalysisAction{IPDL} .
  eq solve L protocol {'emptyProtocol.IPDLProtocol : 'IPDLProtocol} = 
     return {'emptyProtocol.IPDLProtocol : 'IPDLProtocol} .
  eq solve L protocol {'currentProtocol.IPDLProtocol : 'IPDLProtocol} = 
     return {'currentProtocol.IPDLProtocol : 'IPDLProtocol} .   
  eq solve L protocol {'`(_`) [I] : 'IPDLProtocol} =
     try {'`(_`) [solve L protocol I] : 'IPDLProtocol}  .
  eq solve L protocol {'pname[I] : 'PName} = 
     return {I : 'PName} .
  eq solve L protocol {'_where_[I1, I2] : 'IPDLProtocol} =      
     try {'_where_[
        solve L protocol (I1), 
        solve L localDecls (I2)
      ] : 'IPDLProtocol} .
  eq solve L protocol {'_::=_[I1, I2] : 'IPDLProtocol} =   
     try {'_::=_ [
        solve L cNameIndex (I1),
        solve L cases (I2)
      ] : 'IPDLProtocol} .
  eq solve L protocol {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} =   
     try {'family_indices:_bounds:_::=_ [
        solve L familyName (I),
        solve L natTerms (I1),
        solve L bounds (I2),
        solve L cases (I3)
      ] : 'IPDLProtocol} .    
  eq solve L protocol {'_||_[I1, I2] : 'IPDLProtocol} = 
     try {'_||_ [
        solve L protocol (I1),
        solve L protocol (I2)
      ] : 'IPDLProtocol} .      
  eq solve L protocol {'new_:_in_[I, I1, I2] : 'IPDLProtocol} =
     try   {'new_:_in_ [  
       adjust L cName (I),
       solve L preType (I1),
       solve L protocol (I2)
      ] : 'IPDLProtocol} . 
  eq solve L protocol {'newfamily_indices:_bounds:_:_in_[I, I1, I2, T, I3]  : 'IPDLProtocol} =
     try   {'newfamily_indices:_bounds:_:_in_ [  
       solve L familyName (I),
        solve L natTerms (I1),
        solve L bounds (I2),
       solve L preType (T),
       solve L protocol (I3)
      ] : 'IPDLProtocol} .
  eq solve L protocol {'change_with_in_ [I, I1, I2] : 'IPDLProtocol } 
   = try {'change_with_in_ [
           solve L cNameBound (I), 
           solve L cases (I1), 
           solve L protocol (I2)
     ] : 'IPDLProtocol } .
  eq solve L protocol {'branch_of_change_with_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol } 
   = try {'branch_of_change_with_in_ [
           solve L whenCond (I), 
           solve L cNameBound (I1),
           solve L cNameBound (I2),
           solve L cases (I3), 
           solve L protocol (I4)
     ] : 'IPDLProtocol } .   
  eq solve L protocol {'extend_with`internal`channel_typed:_assigned:_ [ I, I1, T, I2 ] : 'IPDLProtocol }
   = try {'extend_with`internal`channel_typed:_assigned:_ [
           solve L protocol (I),
           solve L cNameIndex (I1), 
           solve L preType (T),
           solve L cases (I2)
     ] : 'IPDLProtocol } .   
  eq solve L protocol {'create`group_indices:_bounds:_from_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol}
   = try {'create`group_indices:_bounds:_from_in_ [ 
      solve L pname (I), 
      solve L natTerms (I1), 
      solve L bounds (I2), 
      solve L cNameBoundList (I3), 
      solve L protocol (I4)] : 'IPDLProtocol} .   


  op solve_reaction : IPDL -> AnalysisAction{IPDL} .
  eq solve L reaction  {'`(_`)[I] : 'IPDLReaction} =
     try {'`(_`)[
        solve L reaction (I)
      ] : 'IPDLReaction} .
  eq solve L reaction  {'return_[I] : 'IPDLReaction} =
     try {'return_ [
        solve L expression (I)
      ] : 'IPDLReaction} .
  eq solve L reaction  {'read_[I] : 'IPDLReaction} =
     try {'read_ [
        solve L cNameIndex (I)
      ] : 'IPDLReaction} .
  eq solve L reaction  {'read[I] : 'IPDLReaction} =
     try {'read [
        solve L cNameIndex (I)
      ] : 'IPDLReaction} .        
  eq solve L reaction {'if_then_else_[I, I1, I2] : 'IPDLReaction} =
     try {'if_then_else_ [
          solve L expression (I), 
          solve L reaction (I1), 
          solve L reaction (I2)
      ] : 'IPDLReaction} . 
  eq solve L reaction {'_:_<-_;_[I, T, I1, I2] : 'IPDLReaction} =
     try {'_:_<-_;_ [
          solve L vName (I), 
          solve L preType (T), 
          solve L reaction (I1), 
          solve L reaction (I2)
      ] : 'IPDLReaction} .
  eq solve L reaction {'samp_`(_`)[I1, I2] : 'IPDLReaction} =
     try {'samp_`(_`)[
           solve L dName (I1),
           solve L expression (I2) 
      ] : 'IPDLReaction} .
  eq solve L reaction {'nf`(_`,_`)[I1, I2] : 'IPDLReaction} =
     try {'nf`(_`,_`)[
           solve L bind-read-list (I1),
           solve L reaction (I2)
      ] : 'IPDLReaction} .    
  eq solve L reaction {'preNF`(_`,_`)[I1, I2] : 'IPDLReaction} =
     try {'preNF`(_`,_`)[
           solve L bind-list (I1),
           solve L reaction (I2)
      ] : 'IPDLReaction} .   

  op solve_expression : IPDL -> AnalysisAction{IPDL} .  
          
  eq solve L expression {'True.IPDLExpr : 'IPDLExpr} =
     return {'True.IPDLExpr : 'IPDLExpr} .
  eq solve L expression {'False.IPDLExpr : 'IPDLExpr} =
     return {'False.IPDLExpr : 'IPDLExpr} .
  eq solve L expression {'`(`).IPDLExpr : 'IPDLExpr} =
     return {'`(`).IPDLExpr : 'IPDLExpr} .
  eq solve L expression {'vid[I] : 'VId} =
     return {I : 'VId} .
  eq solve L expression {'fst_[I] : 'IPDLExpr} =
     try {'fst_ [ 
          solve L expression (I)
      ] : 'IPDLExpr} .
  eq solve L expression {'snd_[I] : 'IPDLExpr} =
     try {'snd_ [ 
          solve L expression (I)
      ] : 'IPDLExpr} .
  eq solve L expression {'`(_`,_`)[I1, I2] : 'IPDLExpr} =
     try {'`(_`,_`)[
          solve L expression (I1), 
          solve L expression (I2)
      ] : 'IPDLExpr} .
  eq solve L expression {'_`(_`)[I1, I2] : 'IPDLExpr} 
     = 
     try {'_`(_`)[
         solve L fName (I1), 
         solve L expression (I2) 
      ] : 'IPDLExpr} .
  
  op solve_fName : IPDL -> AnalysisAction{IPDL} .
  eq solve L fName {'fname[I] : 'FName} 
   = return {I : 'FName} .
   
  op solve_dName : IPDL -> AnalysisAction{IPDL} .
  eq solve L dName {'dname[I] : 'DName} 
   = return {I : 'DName} .

  op solve_vName : IPDL -> AnalysisAction{IPDL} . 
  eq solve L vName {'vid[I] : 'VId} 
   = return {I : 'VId} .   

  op solve_bind-read-list : IPDL -> AnalysisAction{IPDL} .  
 
  eq solve L bind-read-list {'nil.BindList : 'BindList} =
     return {'nil.BindList : 'BindList} .
  eq solve L bind-read-list {'_:_<-`read_[I, I1, I2] : 'BindReaction} =
     try {'_:_<-`read_[
          solve L vName (I),
          solve L preType (I1), 
          solve L cNameIndex (I2)
      ]: 'BindReaction} .
  eq solve L bind-read-list {'__[I1, I2] : 'BindList} =   
     try {'__[
        solve L bind-read-list (I1), 
        solve L bind-read-list (I2)
      ] : 'BindList} .  

  op solve_bind-list : IPDL -> AnalysisAction{IPDL} . 
 
  eq solve L bind-list {'nil.BindList : 'BindList} =
     return {'nil.BindList : 'BindList} .
  eq solve L bind-list {'_:_<~_[I, I1, I2] : 'BindReaction} =
     try {'_:_<~_[
          solve L vName (I), 
          solve L preType (I1), 
          solve L reaction (I2)
      ]: 'BindReaction} .
  eq solve L bind-list {'_:_<-`read_[I, I1, I2] : 'BindReaction} =
     try {'_:_<-`read_[
          solve L vName (I),
          solve L preType (I1), 
          solve L cNameIndex (I2)
      ]: 'BindReaction} .       
  eq solve L bind-list {'__[I1, I2] : 'BindList} =   
     try {'__[
        solve L bind-list (I1), 
        solve L bind-list (I2)
      ] : 'BindList} .
    

  op solve_preType : IPDL -> AnalysisAction{IPDL} .
  eq solve L preType {'_*_[I1, I2] : 'IPDLPreType}
   = try {'_*_[solve L preType (I1), solve L preType (I2)] : 'IPDLPreType} .
  eq solve L preType {'tid[I] : 'TId} 
   = return {I : 'TId} .

  *** 2. check identifiers
  op check_localDecl : IPDL -> AnalysisAction{IPDL} .
  ceq check L localDecl {'_=_[I1, I2] : 'LocalDecl} 
      in env  
   = (check (not $hasMapping(protMap, read-qid(I1)))
     or-else fail('protocol 'already 'declared, (at term I1, include context))
     )
     and-then 
      try {'_=_[ 
         return I1, 
         check L protocol (I2)] : 'LocalDecl}     
     in env
  if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env .     

  op check_localDecls : IPDL -> AnalysisAction{IPDL} .
  ceq check L localDecls I =
      check L localDecl I 
   if I :: 'LocalDecl .
  eq check L localDecls {'_and_[I1, I2] : 'LocalDeclList} = 
     try {'_and_ [
        check L localDecls (I1),
        check L localDecls (I2)
      ] : 'LocalDeclList} . 

  op check_protocol : IPDL -> AnalysisAction{IPDL} .
  eq check L protocol {'emptyProtocol.IPDLProtocol : 'IPDLProtocol} = 
     return {'emptyProtocol.IPDLProtocol : 'IPDLProtocol} .
  eq check L protocol {'currentProtocol.IPDLProtocol : 'IPDLProtocol} = 
     return {'currentProtocol.IPDLProtocol : 'IPDLProtocol} .   
  eq check L protocol   {'`(_`) [I] : 'IPDLProtocol}
   = try  {'`(_`) [check L protocol (I)] : 'IPDLProtocol} .
  ceq check L protocol {'_where_[I1, I2] : 'IPDLProtocol} in env =     
      try {'_where_[
         check L protocol (I1) 
           in (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) 
                 deltaMap (read-localDecls(L, env, I2), protMap) m TCS QIS PS),
         check L localDecls (I2)    
         in env
      ] : 'IPDLProtocol
      }
   if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env    
  .    
  ceq check L protocol {I : 'PName} in env = 
    check ($hasMapping(protMap, read-qid(I)))
    and-then return {I : 'PName}
    or-else fail('unknown 'protocol, (at term I, include context))
    in env
  if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env .   
  eq check L protocol {'_::=_[I1, I2] : 'IPDLProtocol} = 
     try {'_::=_ [
        check L emptyTypeContext declaredCNameIndex (I1),
        check L emptyTypeContext cases (I2)
      ] : 'IPDLProtocol} . 
  ceq check L protocol {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} 
      in env =   
     try {'family_indices:_bounds:_::=_ [
        check L familyName (I) in env,
        return I1 in env, *** check L emptyTypeContext natTerms (I1),
        check L emptyTypeContext bounds (I2) in env ,
        check L (indicesToTypeContext read-natTerms(L,I1)) cases (I3)
        in (buildEnv (aConfig(Sigma, Delta, P, (Ins, fam (read-familyName(L, I)) ), Outs, A, nw, nl)) 
           deltaMap protMap m TCS QIS PS)
      ] : 'IPDLProtocol} 
   if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env .         
  ceq check L protocol {'_||_[I1, I2] : 'IPDLProtocol} in env = 
     try {'_||_ [
        check L protocol (I1)
        in (buildEnv (aConfig(Sigma, Delta, P, 
           union(Ins, getOutputs(read-protocol(L, env, I2))), 
           getOutputs(read-protocol(L, env, I1)), A, nw, nl)) deltaMap protMap m TCS QIS PS),
        check L protocol (I2)
        in (buildEnv (aConfig(Sigma, Delta, P, 
           union(Ins, getOutputs(read-protocol(L, env, I1))), 
                 getOutputs(read-protocol(L, env, I2)), A, nw, nl)) deltaMap protMap m TCS QIS PS)
      ] : 'IPDLProtocol} 
  if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env .
  ceq check L protocol {'new_:_in_[I, I1, I2] : 'IPDLProtocol} in env = 
     try {'new_:_in_ [
        check L cname I in env,
        check L preType I1 in env,
        check L protocol I2
        in (buildEnv (aConfig(Sigma, Delta (chn q :: t), P, Ins, 
            (Outs, chn q ), A, nw, nl)) deltaMap protMap m TCS QIS PS)
      ] : 'IPDLProtocol}  
  if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env 
  /\ q := read-qid(I) 
  /\ t := preToType(read-type(L, I1)) .
  eq check L protocol {'newfamily_indices:_bounds:_:_in_[I, I1, I2, T, I3]  : 'IPDLProtocol} =
     try   {'newfamily_indices:_bounds:_:_in_ [  
       check L familyName (I),
       return I1,  *** check L emptyTypeContext natTerms (I1),
        check L emptyTypeContext bounds (I2),
       check L preType (T),
       check L protocol (I3)
      ] : 'IPDLProtocol} .
  eq check L protocol {'newNF`(_`,_`)[I1, I2] : 'IPDLProtocol} =    
     try {'newNF`(_`,_`)[
          check L hidden (I1), 
          check L protocol (I2) 
           *** except here we will assign values to protocols
           *** that aren't in Delta, because Delta changes with the new channels!
      ] : 'IPDLProtocol} .
  eq check L protocol {'change_with_in_ [I, I1, I2] : 'IPDLProtocol }
   = try  {'change_with_in_ [
           return I, 
           return I1, 
           check L protocol (I2)
      ] : 'IPDLProtocol } .
  eq check L protocol {'branch_of_change_with_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol }
   = try  {'branch_of_change_with_in_ [
           return I, 
           return I1, 
           return I2, 
           return I3,
           check L protocol (I4)
      ] : 'IPDLProtocol } .    
  eq check L protocol {'extend_with`internal`channel_typed:_assigned:_ [ I, I1, T, I2 ] : 'IPDLProtocol }
   = try  {'extend_with`internal`channel_typed:_assigned:_ [ 
         check L protocol (I), 
         return I1, 
         check L preType (T), 
         return I2 
      ] : 'IPDLProtocol } .  
  eq check L protocol {'create`group_indices:_bounds:_from_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol}
   = try {'create`group_indices:_bounds:_from_in_ [
         return I, 
         return I1, 
         return I2, 
         return I3, 
         check L protocol (I4)] : 'IPDLProtocol}  .   

 op check_hidden : IPDL -> AnalysisAction{IPDL} .
  eq check L hidden {'empty.TypedCNameList : 'TypedCNameList} = 
     return {'empty.TypedCNameList : 'TypedCNameList} .
  eq check L hidden {'<_:_>[I1, I2] : 'TypedCName } =
     try {'<_:_>[
           check L cname (I1), 
           check L preType (I2)
      ] : 'TypedCName } .
  eq check L hidden {'`{__:_`}[I1, I2, T] : 'TypedCName} 
   = try {'`{__:_`}[
       check L familyName (I1), 
       return I2, 
       check L preType (I2)
      ] : 'TypedCName} .
  eq check L hidden {'__[I1, I2] : 'TypedCNameList} =   
     try {'__[
        check L hidden (I1), 
        check L hidden (I2)
      ] : 'TypedCNameList} .

  op check__reaction : IPDL TypeContext -> AnalysisAction{IPDL} .
  eq check L Gamma reaction  {'`(_`) [I] : 'IPDLReaction} =
     try {'`(_`) [
        check L Gamma reaction (I)
      ] : 'IPDLReaction} .
  eq check L Gamma reaction  {'return_[I] : 'IPDLReaction} =
     try {'return_ [
        check L Gamma expression (I)
      ] : 'IPDLReaction} .
  eq check L Gamma reaction  {'read_[I] : 'IPDLReaction} =
     try {'read_[
      check L Gamma declaredCNameIndex (I) 
      *** should check that the cname is in delta or matches a family from delta
      ] : 'IPDLReaction} 
  .
  eq check L Gamma reaction  {'read[I] : 'IPDLReaction} =
     try {'read[
      check L Gamma declaredCNameIndex (I) 
      *** should check that the cname is in delta or matches a family from delta
      ] : 'IPDLReaction} 
  .
  eq check L Gamma reaction {'if_then_else_[I, I1, I2] : 'IPDLReaction} =
     try {'if_then_else_ [
          check L Gamma expression (I), 
          check L Gamma reaction (I1), 
          check L Gamma reaction (I2)
      ] : 'IPDLReaction} . 
  ceq check L Gamma reaction {'_:_<-_;_[I, T, I1, I2] : 'IPDLReaction} =
     try {'_:_<-_;_ [
          return I, 
          check L preType (T), 
          check L Gamma reaction (I1), 
          check L (Gamma (q : t)) reaction (I2)
      ] : 'IPDLReaction} 
  if q := read-qid(I)
  /\ t := preToType(read-type(L, T))    .
  eq check L Gamma reaction {'samp_`(_`)[I1, I2] : 'IPDLReaction} =
     try {'samp_`(_`)[
           check L declaredDName (I1),
           check L emptyTypeContext expression (I2) 
      ] : 'IPDLReaction} .
  eq check L Gamma reaction {'nf`(_`,_`)[I1, I2] : 'IPDLReaction} =
     try {'nf`(_`,_`)[
           check L Gamma bind-read-list (I1),
           check L (addDeclarations (read-binds(L, I1)) Gamma)  reaction (I2)
      ] : 'IPDLReaction} .    
  eq check L Gamma reaction {'preNF`(_`,_`)[I1, I2] : 'IPDLReaction} =
     try {'preNF`(_`,_`)[
           check L Gamma bind-list (I1),
           check L (addDeclarations (read-binds(L, I1)) Gamma) reaction (I2)
      ] : 'IPDLReaction} . 

  op check__bind-list : IPDL TypeContext -> AnalysisAction{IPDL} . 
  eq check L Gamma bind-list {'nil.BindList : 'BindList} =
     return {'nil.BindList : 'BindList} .
  ceq check L Gamma bind-list {'_:_<~_[I, I1, I2] : 'BindReaction} =
     try {'_:_<~_[
          check L varName (I),  *** but the name should be new
          check L preType (I1), 
          check L (Gamma (q : t)) reaction (I2)
      ]: 'BindReaction} 
   if q := read-qid(I) /\
      t := preToType(read-type(L, I1)) .
  eq check L Gamma bind-list {'_:_<-`read_[I, I1, I2] : 'BindReaction} =
     try {'_:_<-`read_[
          check L varName (I),  *** but the name should be new
          check L preType (I1), 
          check L Gamma declaredCNameIndex (I2) *** but the name should be in the current Ins
      ]: 'BindReaction} .       
  eq check L Gamma bind-list {'__[I1, I2] : 'BindList} =   
     try {'__[
        check L Gamma bind-list (I1), 
        check L Gamma bind-list (I2)
      ] : 'BindList} .
 

  op check__bind-read-list : IPDL TypeContext -> AnalysisAction{IPDL} . 
  eq check L Gamma bind-read-list {'nil.BindList : 'BindList} =
     return {'nil.BindList : 'BindList} .
  eq check L Gamma bind-read-list {'_:_<-`read_[I, I1, I2] : 'BindReaction} =
     try {'_:_<-`read_[
          check L varName (I),  *** but the name should be new
          check L preType (I1), 
          check L Gamma declaredCNameIndex (I2) *** but the name should be in the current Ins
      ]: 'BindReaction} .
  eq check L Gamma bind-read-list {'__[I1, I2] : 'BindList} =   
     try {'__[
        check L Gamma bind-read-list (I1), 
        check L Gamma bind-read-list (I2)
      ] : 'BindList} .   

  op check__expression : IPDL TypeContext -> AnalysisAction{IPDL} .        
  eq check L Gamma expression {'True.IPDLExpr : 'IPDLExpr} =
     return {'True.IPDLExpr : 'IPDLExpr} .
  eq check L Gamma expression {'False.IPDLExpr : 'IPDLExpr} =
     return {'False.IPDLExpr : 'IPDLExpr} .
  eq check L Gamma expression {'`(`).IPDLExpr : 'IPDLExpr} =
     return {'`(`).IPDLExpr : 'IPDLExpr} .
  eq check L Gamma expression {I : 'VId} =
     return {I : 'VId} . *** TODO: I must be in Gamma
  eq check L Gamma expression {'fst_[I] : 'IPDLExpr} =
     try {'fst_ [ 
          check L Gamma expression (I)
      ] : 'IPDLExpr} .
  eq check L Gamma expression {'snd_[I] : 'IPDLExpr} =
     try {'snd_ [ 
          check L Gamma expression (I)
      ] : 'IPDLExpr} .
  eq check L Gamma expression {'`(_`,_`)[I1, I2] : 'IPDLExpr} =
     try {'`(_`,_`)[
          check L Gamma expression (I1), 
          check L Gamma expression (I2)
      ] : 'IPDLExpr} .
  eq check L Gamma expression {'_`(_`)[I1, I2] : 'IPDLExpr} 
     = 
     try {'_`(_`)[
         check L declaredFName (I1), 
         check L Gamma expression (I2) 
      ] : 'IPDLExpr} . 
 
 op check__natTerm : IPDL TypeContext -> AnalysisAction{IPDL} .
 ceq check L Gamma natTerm {I : 'CId} in env
  = check (read-qid(I) elem (Gamma PS))
     and-then return {I : 'CId}
     or-else fail('unknown 'term, (at term I, include context)) 
            in env 
  if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env .
 eq check L Gamma natTerm {I : 'Nat}
  = return {I : 'Nat} .
 eq check L Gamma natTerm  {'`(_`) [I] : 'NatTerm}
  = try  {'`(_`) [check L Gamma natTerm (I)] : 'NatTerm} .
 eq check L Gamma natTerm {'_+_[I1, I2] : 'NatTerm} 
  = try {'_+_[
      check L Gamma natTerm (I1), 
      check L Gamma natTerm (I2)] : 'NatTerm} .
 eq check L Gamma natTerm {'_-_[I1, I2] : 'NatTerm} 
  = try {'_-_[
      check L Gamma natTerm (I1), 
      check L Gamma natTerm (I2)] : 'NatTerm} .     
 eq check L Gamma natTerm {'_*_[I1, I2] : 'NatTerm} 
  = try {'_*_[
      check L Gamma natTerm (I1), 
      check L Gamma natTerm (I2)] : 'NatTerm} .   
 eq check L Gamma natTerm {'_`(_`)[I1, I2] : 'NatTerm}
   = try {'_`(_`)[
       return I1, *** should check that we have a function with this name in the module?
       check L Gamma natTerm (I2)] : 'NatTerm} .       

 op check__natTerms : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq check L Gamma natTerms {I : 'CId} 
  = check L Gamma natTerm {I : 'CId} .
 eq check L Gamma natTerms {I : 'Nat} 
  = check L Gamma natTerm {I : 'Nat} .
 eq check L Gamma natTerms {I : 'NatTerm} 
  = check L Gamma natTerm {I : 'NatTerm} .  
 eq check L Gamma natTerms {'_`,_[I1, I2] : 'NatTermList}
   = try {'_`,_[
       check L Gamma natTerms (I1), 
       check L Gamma natTerms (I2)
      ] : 'NatTermList} .

  op check__boolTerm : IPDL TypeContext -> AnalysisAction{IPDL} .
  eq check L Gamma boolTerm {'falseBT.BoolTerm : 'BoolTerm} = 
     return {'falseBT.BoolTerm : 'BoolTerm} .
  eq check L Gamma boolTerm {'trueBT.BoolTerm : 'BoolTerm} = 
     return {'trueBT.BoolTerm : 'BoolTerm} . 
  eq check L Gamma boolTerm {'_=_[I1, I2] : 'BoolTerm} =   
     try {'_=_ [
        check L Gamma natTerm (I1),
        check L Gamma natTerm (I2)
      ] : 'BoolTerm} .   
  eq check L Gamma boolTerm {'_<_[I1, I2] : 'BoolTerm} =   
     try {'_<_ [
        check L Gamma natTerm (I1),
        check L Gamma natTerm (I2)
      ] : 'BoolTerm} .    
  eq check L Gamma boolTerm {'_<=_[I1, I2] : 'BoolTerm} =   
     try {'_<=_ [
        check L Gamma natTerm (I1),
        check L Gamma natTerm (I2)
      ] : 'BoolTerm} .    
  eq check L Gamma boolTerm {'_and_[I1, I2] : 'BoolTerm} =   
     try {'_and_ [
        check L Gamma boolTerm (I1),
        check L Gamma boolTerm (I2)
      ] : 'BoolTerm} .
  eq check L Gamma boolTerm {'_or_[I1, I2] : 'BoolTerm} =   
     try {'_or_ [
        check L Gamma boolTerm (I1),
        check L Gamma boolTerm (I2)
      ] : 'BoolTerm} .
  eq check L Gamma boolTerm {'not_[I1] : 'BoolTerm} =   
     try {'not_ [
        check L Gamma boolTerm (I1)
      ] : 'BoolTerm} .         
  eq check L Gamma boolTerm  {'_`(_`)[I1, I2] : 'BoolTerm} =
   try {'_`(_`)[
       return I1, 
       check L Gamma natTerm (I2)
    ] : 'BoolTerm} .

 op check__bound : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq check L Gamma bound {'bound_[I] : 'Bound}
   = try {'bound_[
       check L Gamma natTerm (I)]
       : 'Bound} .
  eq check L Gamma bound {'fixedBound_[I] : 'Bound}
   = try {'fixedBound_[
       check L Gamma natTerm (I)]
       : 'Bound} .
  eq check L Gamma bound {'dependentBound_[I] : 'Bound}
   = try {'dependentBound_[
       return I]
       : 'Bound} . 

 op check__bounds : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq check L Gamma bounds {I : 'Bound}
   = check L Gamma bound {I : 'Bound} .
  eq check L Gamma bounds {'__[I1, I2] : 'BoundList}
   = try {'__[
       check L Gamma bounds (I1), 
       check L Gamma bounds (I2)
      ] : 'BoundList} .

 op check__whenCond : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq check L Gamma whenCond {'otherwise.WhenCond : 'WhenCond} 
   = return {'otherwise.WhenCond : 'WhenCond} .
  eq check L Gamma whenCond {'when_[I] : 'WhenCond}
   = try {'when_[
       check L Gamma boolTerm (I)]
       : 'WhenCond} .

 op check__when : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq check L Gamma when {'_-->_[I1, I2] : 'When}
   = try {'_-->_[
       check L Gamma whenCond (I1), 
       check L Gamma cases (I2)
      ] : 'When} .

 op check__whenList : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq check L Gamma whenList {'emptyWhen.WhenList : 'WhenList} 
   = return {'emptyWhen.WhenList : 'WhenList} .
 eq check L Gamma whenList {'`(_`) [I] : 'WhenList}
  = try {'`(_`) [check L Gamma whenList I] : 'WhenList} .  
  ceq check L Gamma whenList I
   = check L Gamma when I if I :: 'When . 
  eq check L Gamma whenList {'_;;_[I1, I2] : 'WhenList}
   = try {'_;;_[
       check L Gamma whenList (I1), 
       check L Gamma whenList (I2)
      ] : 'WhenList} .

 op check__cases : IPDL TypeContext -> AnalysisAction{IPDL} .
 ceq check L Gamma cases I
  = check L Gamma reaction I if I :: 'IPDLReaction . 
 ceq check L Gamma cases I
   = check L protocol I if I :: 'IPDLProtocol . *** TODO: add Gamma to check L protocol?
 ceq check L Gamma cases I
   = check L Gamma whenList I if I :: 'WhenList .  
 ceq check L Gamma cases I
   = check L Gamma when I if I :: 'When .

 op check_varName : IPDL -> AnalysisAction{IPDL} .
 eq check L varName {'vid[I] : 'VId}
     = return {I : 'VName} .
  eq check L varName {I : 'VId} =  *** incomplete for now, we should check that it's new
    return {I : 'VId}
   . 

  op check_isInputCName : IPDL -> AnalysisAction{IPDL} .
  ceq check L isInputCName {I : 'CName} in env 
  = 
   check ( 
      (metaOccurs env   ('occurs___[upTerm(chn read-qid(I)), upTerm(Delta), upTerm(A)] ))
      and 
      (chn read-qid(I) in Ins) 
   )  
   and-then return {I : 'CName}
   or-else fail('not 'an 'input 'channel, (at L term I, include context)) 
            in env 
   if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env . 

  op check_declaredFName : IPDL -> AnalysisAction{IPDL} .
  eq check L declaredFName {I : 'FName} in (
      buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) = 
   check (read-qid(I) elem Sigma) and-then return {I : 'FName}
   or-else fail('unknown 'function, (at L term I, include context)) 
            in (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) .

  op check_declaredDName : IPDL -> AnalysisAction{IPDL} .          
  eq check L declaredDName {I : 'DName} 
     in (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) = 
   check (read-qid(I) elem Sigma)  and-then return {I : 'DName}
   or-else fail('unknown 'distribution, (at L term I, include context)) 
            in (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) .
  
  op check__declaredCNameIndex : IPDL TypeContext -> AnalysisAction{IPDL} .
  ceq check L Gamma declaredCNameIndex {'cname[I] : 'CName}
     in env
     = check ( (metaOccurs env   ('occurs___[upTerm(chn read-qid(I)), upTerm(Delta), upTerm(A)] )) )  
       and-then return {I : 'CName}
       or-else fail('unknown 'channel, (at L term 'cname[I], include context)) 
       in env 
   if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env .
  ceq check L Gamma declaredCNameIndex {I : 'CName}
     in env
     = check ((metaOccurs env   ('occurs___[upTerm(chn read-qid(I)), upTerm(Delta), upTerm(A)] )) )  
       and-then return {I : 'CName}
       or-else fail('unknown 'channel, (at L term 'cname[I], include context)) 
       in env 
   if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env .     
  eq check L Gamma declaredCNameIndex {'_`[_`][ I1, I2] : 'CNameIndex}
     = try {'_`[_`][ 
        return I1, 
        check L Gamma natTerms (I2)] : 'CNameIndex} .

  
  op check_declaredCName : IPDL -> AnalysisAction{IPDL} .
  eq check L declaredCName {'cname[I] : 'CName}
     = return {I : 'CName} .
  eq check L declaredCName {I : 'CName} 
     *** in (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) 
     = return {I : 'CName} .
  ***  check ( occurs ( chn read-qid(I) ) Delta A )  and-then return {I : 'CName}
  ***  or-else fail('unknown 'channel, (at L term 'cname[I], include context)) 
  ***           in (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) .

  op check_moduleName : IPDL -> AnalysisAction{IPDL} .
  eq check L moduleName {'mName[I] : 'ModuleName} = 
   check ( upModule(read-qid(I), true) :: Module) and-then return {I : 'ModuleName}
   or-else fail('already 'declared, (at L term 'mName[I], include context)) 
  .

  op check_sname : IPDL -> AnalysisAction{IPDL} .
  eq check L sname {'sname[I] : 'SName} 
   = return {I : 'SName} .

  op check_pname : IPDL -> AnalysisAction{IPDL} .
  eq check L pname {'pname[I] : 'PName} in 
     (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) = 
   check ( $hasMapping(protMap, read-qid(I))  == false ) and-then return {I : 'PName}
   or-else fail('already 'declared, (at L term 'pname[I], include context)) 
            in (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) .

  op check_declaredPname : IPDL -> AnalysisAction{IPDL} .
  eq check L declaredPname {'pname[I] : 'PName} in 
     (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) = 
   check ( $hasMapping(protMap, read-qid(I)) ) and-then return {I : 'PName}
   or-else fail('unknown 'protocol, (at L term 'pname[I], include context)) 
            in (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) .          

  op check_aName : IPDL -> AnalysisAction{IPDL} .
  eq check L aName {'assumName[I] : 'AssumName} in 
     (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) = 
     check (read-qid(I) not-in QIS) and-then return {I : 'AssumName}
    or-else fail('already 'declared, (at L term 'tdid[I], include context)) 
            in 
            (buildEnv (aConfig(Sigma (typesOf QIS), Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS)
  .             

   op check_preType : IPDL -> AnalysisAction{IPDL} .
  eq check L preType {'_*_[I1, I2] : 'IPDLPreType} =
   try {'_*_[check L preType I1, check L preType I2] : 'IPDLPreType} .
  eq check L preType {I : 'TId} in 
     (buildEnv (aConfig(Sigma (typesOf QIS), Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS' PS) 
      =
   check (read-type(L, I) in QIS)  and-then return {I : 'TId}
   or-else fail('unknown 'types 'in, (at L term I, include context)) 
           in 
           (buildEnv (aConfig(Sigma (typesOf QIS), Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS' PS)
            .
  
  op check_cname : IPDL -> AnalysisAction{IPDL} .
  ceq check L cname {'cname[I] : 'CName} in env = 
   check ( ( (metaOccurs env   ('occurs___[upTerm(chn read-qid(I)), upTerm(Delta), upTerm(A)] )) ) == false )
   and-then return {I : 'CName}
   or-else fail('channel 'already 'declared, (at L term 'cname[I], include context)) 
            in env 
  if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env .
  ceq check L cname {I : 'CName} in env = 
   check ( (metaOccurs env   ('occurs___[upTerm(chn read-qid(I)), upTerm(Delta), upTerm(A)] )) == false ) 
   and-then return {I : 'CName}
   or-else fail('channel 'already 'declared, (at L term I, include context)) 
            in env
  if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env .

  ***( eq check L cname {'__[I, S] : 'CName}
  = try {'__[
        check L cname (I),
        check L cname-scripts(S)
      ] : 'CName} . )

 ***(  op check_cname-scripts : IPDL -> AnalysisAction{IPDL} .
  ceq check L cname-scripts {'cscripts[S] : 'CScripts}
  = (check (QI1 == '_) or-else fail ('expecting '_, (at QI1, include context)))
    and-then (check (not (rat(string(QI2), 10) :: Nat)) or-else fail ('expecting 'a 'word, (at (QI1 QI2), include context)))
    and-then (check (QI3 == '_) or-else fail ('expecting '_, (at (QI1 QI2 QI3), include context)))
    and-then (check (not (rat(string(QI4), 10) :: Nat)) or-else fail ('expecting 'a 'word, (at (QI1 QI2 QI3 QI4), include context)))
    and-then return {S : 'CScripts}
  if QI1 QI2 QI3 QI4 := read-qids(S) cn )

  op check_fname : IPDL -> AnalysisAction{IPDL} .
  eq check L fname {I : 'FName} in 
     (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) = 
   check ((read-qid(I) elem Sigma) == false) and-then return {I : 'FName}
   or-else fail('function 'already 'declared, (at L term I, include context)) 
            in (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) .

  op check_dname : IPDL -> AnalysisAction{IPDL} .          
  eq check L dname {I : 'DName} in 
     (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) = 
   check ((read-qid(I) elem Sigma) == false) and-then return {I : 'DName}
   or-else fail('distribution 'already 'declared, (at L term I, include context)) 
            in (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) .          

  op check_tdid : IPDL -> AnalysisAction{IPDL} .
  eq check L tdid {'tdid[I] : 'TDId} in 
      (buildEnv (aConfig(Sigma (typesOf QIS), Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS' PS) 
  = check (read-qid(I) not-in QIS) and-then return {I : 'TDId}
    or-else fail('type 'already 'declared, (at L term 'tdid[I], include context)) 
            in 
            (buildEnv (aConfig(Sigma (typesOf QIS), Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS' PS)
            .
  eq check L tdid {I : 'TDId} in 
      (buildEnv (aConfig(Sigma (typesOf QIS), Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS' PS)
  = check (read-qid(I) not-in QIS) and-then return {I : 'TDId}
    or-else fail('type 'already 'declared, (at L term I, include context)) 
            in 
            (buildEnv (aConfig(Sigma (typesOf QIS), Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS' PS)
            .
      

 *** 3. type checking
  op type`check_localDecl : IPDL -> AnalysisAction{IPDL} .
  eq type check L localDecl {'_=_[I1, I2] : 'LocalDecl}
   = try {'_=_[
        return I1, 
        type check L protocol(I2)
      ] : 'LocalDecl} .

  op type`check_localDecls : IPDL -> AnalysisAction{IPDL} .    
  ceq type check L localDecls I = 
      type check L localDecl  I
  if I :: 'LocalDecl .
  eq type check L localDecls {'_and_[I1, I2] : 'LocalDeclList} 
   = try   {'_and_[
       type check L localDecls (I1), 
       type check L localDecls (I2)
      ] : 'LocalDeclList} .   
   

  op type`check_protocol : IPDL -> AnalysisAction{IPDL} .
  eq type check L protocol I = type check L protocol [I] I .

  op type`check_protocol`[_`] : IPDL ATerm -> AnalysisAction{IPDL} .
  eq type check L protocol [{'emptyProtocol.IPDLProtocol : 'IPDLProtocol}]
     {'emptyProtocol.IPDLProtocol : 'IPDLProtocol}
   = return {'emptyProtocol.IPDLProtocol : 'IPDLProtocol} .
  eq type check L protocol [{'currentProtocol.IPDLProtocol : 'IPDLProtocol}]
     {'currentProtocol.IPDLProtocol : 'IPDLProtocol}
   = return {'emptyProtocol.IPDLProtocol : 'IPDLProtocol} . 
  eq type check L protocol[$I] { 'change_with_in_ [I, I1, I2] : 'IPDLProtocol }
   = return  { 'change_with_in_ [I, I1, I2] : 'IPDLProtocol } .
  eq type check L protocol[$I] { 'branch_of_change_with_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol }
   = return  { 'branch_of_change_with_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol } .  
  eq type check L protocol[$I] {'extend_with`internal`channel_typed:_assigned:_ [ I, I1, T, I2 ] : 'IPDLProtocol }
   = return {'extend_with`internal`channel_typed:_assigned:_ [ I, I1, T, I2 ] : 'IPDLProtocol } .  
  eq type check L protocol[$I] {'create`group_indices:_bounds:_from_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol}
   = return {'create`group_indices:_bounds:_from_in_ [I, I1, I2, I3, I4] : 'IPDLProtocol} . 
  eq type check L protocol [{'`(_`) [I] : 'IPDLProtocol}]
     {'`(_`) [I] : 'IPDLProtocol}
   = try {'`(_`) [
       type check L protocol [I] I
       ] : 'IPDLProtocol} . 
  ceq type check L protocol [{$I : 'PName}] (I) in env
   = return {$I : 'PName} in env
   if {$I : 'PName} =/= I
      /\ successful-analysis(TL) := type check L protocol I in env .
  ceq type check L protocol [{$I : 'PName}] (I) in env
   = fail(QIL, (at term $I, include context)) in env
   if {$I : 'PName} =/= I
      /\ analysis-error(QIL, WA) := type check L protocol I in env .

  eq type check L protocol [{'_where_[$I1, $I2] : 'IPDLProtocol}]
    {'_where_[I1, I2] : 'IPDLProtocol}
   = try { '_where_ [
        type check L protocol [$I1] (substitute(L, I2, I1)),
        return $I2
     ] : 'IPDLProtocol } .

  op find-protocol : IPDL ATerm ATerm ~> ATerm .
  ceq find-protocol(L, I, {'_and_[I1, I2] : 'LocalDeclList})
   = T if T := find-protocol(L, I, I1) .
  eq find-protocol(L, I, {'_and_[I1, I2] : 'LocalDeclList})
   = find-protocol(L, I, I2) [owise] .
  eq find-protocol(L, I, {'_=_[I, T] : 'LocalDecl}) = T .
  
  op substitute : IPDL ATerm ATerm ~> ATerm .
  eq substitute(L, I, {'emptyProtocol.IPDLProtocol : 'IPDLProtocol})
   = {'emptyProtocol.IPDLProtocol : 'IPDLProtocol} .
  eq substitute(L, I, {I1 : 'PName})
   = find-protocol(L, {I1 : 'PName}, I) .
  eq substitute(L, I, {'_::=_ [I1, I2] : 'IPDLProtocol})
   = {'_::=_ [I1, I2] : 'IPDLProtocol} .
  eq substitute(L, I, {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol})
   = {'family_indices:_bounds:_::=_[I, I1, I2, substitute(L, I, I3)]  : 'IPDLProtocol} .
  eq substitute(L, I, {'_||_[I1, I2]  : 'IPDLProtocol})
   = {'_||_[substitute(L, I, I1), substitute(L, I, I2)]  : 'IPDLProtocol} .
  eq substitute(L, I, {'new_:_in_[I1, I2, I3]  : 'IPDLProtocol})
   = {'new_:_in_[I1, I2, substitute(L, I, I3)]  : 'IPDLProtocol} .
  eq substitute(L, I, {'newfamily_indices:_bounds:_:_in_[I, I1, I2, T, I3]  : 'IPDLProtocol})
   = {'newfamily_indices:_bounds:_:_in_[I, I1, I2, T, substitute(L, I, I3)]  : 'IPDLProtocol} .
  eq substitute(L, I, {'newNF`(_`,_`)[I1, I2] : 'IPDLProtocol})
   = {'newNF`(_`,_`)[I1, substitute(L, I, I2)] : 'IPDLProtocol} .
  eq substitute(L, I, {'_where_[I1, I2] : 'IPDLProtocol})
   = {'_where_[substitute(L, I, I1), substitute(L, I, I2)] : 'IPDLProtocol} .
  eq substitute(L, I, {'_and_[I1, I2] : 'LocalDeclList})
   = {'_and_[substitute(L, I, I1), substitute(L, I, I2)] : 'LocalDeclList} .
  eq substitute(L, I, {'_=_[I1, I2] : 'LocalDecl})
   = {'_=_[I1, substitute(L, I, I2)] : 'LocalDecl} .
  
  eq type check L protocol [{'newNF`(_`,_`)[I1, $I2] : 'IPDLProtocol}]
      {'newNF`(_`,_`)[I1, I2] : 'IPDLProtocol}
   = return {'newNF`(_`,_`)[I1, $I2] : 'IPDLProtocol} .
  ceq type check L protocol [{'newfamily_indices:_bounds:_:_in_[I, I1, I2, T, $I3]  : 'IPDLProtocol}]
      {'newfamily_indices:_bounds:_:_in_[I, I1, I2, T, I3]  : 'IPDLProtocol}
      in env
     = try {'newfamily_indices:_bounds:_:_in_ [
        (check ((metaOccurs env   ('occurs___[upTerm(fam (q[blist])), upTerm(Delta), upTerm(A)] ))
                 == false
               )
         and-then return I
         or-else fail ('internal 'family 'already 'in 'use', (at term I, include context)))
         in env,
        return I1 in env,
        check (blist == blist')
        and-then return I2
        or-else fail('bounds 'mismatch 'for q, (at term I, include context)) 
        in env,
        return T in env, 
        (type check L protocol [$I3] I3
        in (buildEnv (aConfig(Sigma, Delta (( fam (q[blist]) ) :: t), P, 
                Ins, (Outs, fam (q[blist]) ), A, nw, nl)) deltaMap protMap m TCS QIS PS))
        ] : 'IPDLProtocol}
    if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env
        /\ q[blist] := read-familyName(L, I) 
        /\ blist' := read-bounds(L, I2)
        /\ t := preToType(read-type(L, T)) .
  ceq type check L protocol [{'new_:_in_[I, I1, $I2] : 'IPDLProtocol}]
      {'new_:_in_[I, I1, I2] : 'IPDLProtocol}
      in env
     = try {'new_:_in_ [
        (check ((metaOccurs env ('occurs___[upTerm(chn q), upTerm(Delta), upTerm(A)] )) == false)
         and-then return I
         or-else fail ('internal 'channel 'already 'in 'use', (at term I, include context)))
         in env,
        return I1 in env,
        (type check L protocol [$I2] I2
        in (buildEnv (aConfig(Sigma, Delta ((chn q) :: t), P, 
                Ins, (Outs, chn q), A, nw, nl)) deltaMap protMap m TCS QIS PS))
        ] : 'IPDLProtocol}
    if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env
        /\ q := read-qid(I) 
        /\ t := preToType(read-type(L, I1)) . 
  ceq type check L protocol [{'_||_[$I1, $I2] : 'IPDLProtocol}]
    {'_||_[I1, I2] : 'IPDLProtocol}
     in env
     =
     try {'_||_[
       (type check L protocol [$I1] I1
       in (buildEnv (aConfig(Sigma, Delta, P, 
           union(Ins, getOutputs(read-protocol(L, env, I2))), 
           getOutputs(read-protocol(L, env, I1)), A, nw, nl)) deltaMap protMap m TCS QIS PS)),
       (type check L protocol [$I2] I2
       in (buildEnv (aConfig(Sigma, Delta, P, 
           union(Ins, getOutputs(read-protocol(L, env, I1))), 
                 getOutputs(read-protocol(L, env, I2)), A, nw, nl)) deltaMap protMap m TCS QIS PS))
     ] : 'IPDLProtocol}
  if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env   .
  ceq type check L protocol [{'_::=_[I1, I2] : 'IPDLProtocol}]
      {'_::=_[I1, I2] : 'IPDLProtocol} 
     =
    try {'_::=_[  
          return I1, 
          type check L emptyTypeContext reaction (I2)
      ] : 'IPDLProtocol}
    then postTypeCheck L protocol 
   if I2 :: 'IPDLReaction .
  ceq type check L protocol [{'_::=_[I1, I2] : 'IPDLProtocol}]
      {'_::=_[I1, I2] : 'IPDLProtocol} 
     =
    try {'_::=_[  
          return I1, 
          type check L emptyTypeContext whenList (I2)
      ] : 'IPDLProtocol}
    then postTypeCheck L protocol 
   if I2 :: 'WhenList .   
  ceq type check L protocol [{'family_indices:_bounds:_::=_[I, I1, I2, $I3]  : 'IPDLProtocol}]
      {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} 
      in env
   =   
   try {'family_indices:_bounds:_::=_ [
        type check L familyName (I) in env,
        return I1 in env,
        type check L emptyTypeContext bounds (I2) in env,
        type check L (indicesToTypeContext nlist) reaction (I3)
        in
        (buildEnv (aConfig(Sigma, Delta, P, 
                       (Ins, fam fn),
                       Outs, 
                       addAssumptions A nlist blist, nw, nl)
                  ) deltaMap protMap m TCS QIS PS)
      ] : 'IPDLProtocol}
    then postTypeCheck L protocol in env
    if I3 :: 'IPDLReaction 
    /\ nlist := read-natTerms(L, I1)
    /\ blist := read-bounds(L, I2)
    /\ fn := read-familyName(L, I)
    /\ (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env
    . 
 *** TODO: what if we have other configs in the stack????
   var fn : FamilyName .

    *** below we have groups
  ceq type check L protocol [{'family_indices:_bounds:_::=_[I, I1, I2, $I3]  : 'IPDLProtocol} ]
      {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} 
   =   
   try {'family_indices:_bounds:_::=_ [
        return I, *** NO: type check L familyName (I), groups aren't in Delta
        return I1,
        type check L emptyTypeContext bounds (I2),
        type check L protocol [$I3] (I3) *** indices can be used?
      ] : 'IPDLProtocol}
    then postTypeCheck L protocol
    if I3 :: 'IPDLProtocol 
    /\ nlist := read-natTerms(L, I1)
    .   
  ceq type check L protocol [{'family_indices:_bounds:_::=_[I, I1, I2, $I3]  : 'IPDLProtocol}]
      {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} 
        in env 
   =   
   try {'family_indices:_bounds:_::=_ [
        if hasReaction I3
        then type check L familyName (I) in env
        else return I in env
        fi,
        return I1 in env ,
        type check L emptyTypeContext bounds (I2) in env ,
        *** if hasReaction I3 then 
        type check L (indicesToTypeContext nlist) whenList (I3)
        in (buildEnv (aConfig(Sigma, Delta, P, 
                       (Ins, fam (q[blist])),
                       Outs, 
                       addAssumptions A nlist blist, nw, nl)
                  ) deltaMap protMap m TCS QIS PS)
         *** else type check L (indicesToTypeContext nlist) whenList (I3) in env fi         
      ] : 'IPDLProtocol}
    then postTypeCheck L protocol in env
    if I3 :: 'WhenList 
    /\ q[blist] := read-familyName(L, I)
    /\ nlist := read-natTerms(L, I1)
    /\ (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env
    .   
  
  op hasReaction_ : ATerm -> Bool . 
  eq hasReaction {'`(_`) [I] : 'WhenList} = hasReaction I .
  eq hasReaction {'_;;_[I1, I2] : 'WhenList} = hasReaction I1 .
  eq hasReaction {'_-->_[I1, I2] : 'When} = I2 :: 'IPDLReaction .

  var nlist : List{NatTerm} .

  op indicesToTypeContext_ : List{NatTerm} -> TypeContext .
  eq indicesToTypeContext nlist = indicesToTypeContextAux nlist emptyTypeContext .

  op indicesToTypeContextAux__ : List{NatTerm} TypeContext -> TypeContext .
  eq indicesToTypeContextAux nil Gamma = Gamma .
  eq indicesToTypeContextAux (qidAsTerm(q)) Gamma = Gamma (q : typeName 'nat) .
  eq indicesToTypeContextAux (qidAsTerm(q) nlist) Gamma = 
     indicesToTypeContextAux nlist (Gamma (q : typeName 'nat)) .


  var de : TypeWithError .
  var blist blist' : List{Bounds} .

  op type`check_familyName : IPDL -> AnalysisAction{IPDL} .
  ceq type check L familyName {I : 'FamilyName}
     in env =
  check (metaOccurs env ('occurs___[upTerm(fam (q[blist])), upTerm(Delta), upTerm(A)] ))
  and-then
   return {I : 'FamilyName}
  or-else fail('unknown 'family q , 
        (at term I, include context))
   in env
  if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env 
  /\ q[blist] := read-familyName(L, {I : 'FamilyName})    
  .

 var R : Reaction .
 var whenCond : WhenCond .
 var whenList : WhenList .
 var bdset : Set{CNameBound} .

  op allSameOutputs_ : WhenList -> Bool .
eq allSameOutputs emptyWhen = true .
eq allSameOutputs ((whenCond --> R) ;; whenList) = true .
eq allSameOutputs ((whenCond --> P) ;; whenList) = 
   allSameOutputsAux getOutputs(P) whenList .
   
op allSameOutputsAux__ : Set{CNameBound} WhenList -> Bool .
eq allSameOutputsAux bdset emptyWhen = true .
eq allSameOutputsAux bdset (whenCond --> P) = getOutputs(P) == bdset .
eq allSameOutputsAux bdset ((whenCond --> P) ;; whenList)
 = (getOutputs(P) == bdset) and  allSameOutputsAux bdset whenList .

  op postTypeCheck_protocol : IPDL -> AnalysisAction{IPDL} .
  ceq postTypeCheck L protocol {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} 
        in env
   =   
   (check (blist == blist')
    or-else fail('bounds 'mismatch 'for q, (at term I, include context))
   )
   and-then
   (check (allSameOutputs (read-whenList(L, I3)))
    or-else fail('outputs 'mismatch 'for q, (at term I, include context))
   )
   and-then
     return {'family_indices:_bounds:_::=_ [I, I1, I2, I3]  : 'IPDLProtocol} 
     in env
  if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env 
  /\ q[blist] := read-familyName(L, I) 
  /\ blist' := read-bounds(L, I2)
  /\ I3 :: 'WhenList .
  ceq postTypeCheck L protocol {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} 
        in env
   =   
   (check ((fam (q[blist])) in Ins == false)
   or-else  fail ('cannot 'assign 'to 'an 'input 'family
            , 
        (at term I1, include context))
   )
   and-then
   (check (blist == blist')
    or-else fail('bounds 'mismatch 'for q, (at term I, include context))
   )
   and-then
   (check (t == d)
    or-else fail('type 'mismatch 'for q *** ': '\n 
               *** 'expecting show-type(IPDL, typeToPre(t)) 
               *** 'and 'got show-type(IPDL, typeToPre(d))
               , (at term I, include context)))
   and-then
     return {'family_indices:_bounds:_::=_ [I, I1, I2, I3]  : 'IPDLProtocol} 
     in env
  if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env 
  /\ q[blist] := read-familyName(L, I) 
  /\ blist' := read-bounds(L, I2)
  /\ nlist := read-natTerms(L, I1)
  /\ t := metaTypeInCtx env ('typeInCtx[upTerm(fam (q[blist])), upTerm(A), upTerm(Delta)])
       *** typeInCtx(fam (q[blist]), A, Delta)
  /\ d  := metaTypeOf env 
           ('typeOf[upTerm(Sigma), upTerm(Delta), upTerm(emptyTypeContext), 
                    upTerm((Ins, fam (q[blist]))), upTerm(addAssumptions A nlist blist), 
                    upTerm(read-reaction(L, I3)) 
                    ])
         ***   typeOf(Sigma, Delta, emptyTypeContext, (Ins, fam (q[blist])), 
         ***          addAssumptions A nlist blist, read-reaction(L, I3)) 
  /\ I3 :: 'IPDLReaction .        
  ceq postTypeCheck L protocol {'family_indices:_bounds:_::=_[I, I1, I2, I3]  : 'IPDLProtocol} 
        in env
   =   
   (check (blist == blist')
    or-else fail('bounds 'mismatch 'for q, (at term I, include context))
   )
   and-then
     return {'family_indices:_bounds:_::=_ [I, I1, I2, I3]  : 'IPDLProtocol} 
     in env
  if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env 
  /\ q[blist] := read-familyName(L, I) 
  /\ blist' := read-bounds(L, I2)
  /\ I3 :: 'IPDLProtocol .
  ceq postTypeCheck L protocol  {'_::=_[I1, I2] : 'IPDLProtocol}
   in env =   
         (check ((chn cn) in Ins == false)
     or-else 
     fail ('cannot 'assign 'to 'an 'input 'channel
            , 
        (at term I1, include context)))
     and-then 
     (check (d :: IPDLType)
     or-else fail('unexpected 'type 'error , 
        (at term I1, include context)))
     and-then
     (check (t == d)
     and-then
     return {'_::=_[I1, I2] : 'IPDLProtocol}
     or-else fail('type 'mismatch 'for 'assignment ':
                  'channel 'has 'type 
                  (print IPDL term show-type(IPDL, typeToPre(t)))
                  'and 'reaction 'has 'type
                  (print IPDL term show-type(IPDL, typeToPre(d))), (at term I2, include context))
     )
     in env
  if cn  := read-cNameIndex(L, I1) 
  /\ (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env
  /\ t := metaTypeInCtx env ('typeInCtx[upTerm(chn cn), upTerm(A), upTerm(Delta)])
       *** typeInCtx(chn cn, A, Delta) 
  /\ d := metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Delta), upTerm(emptyTypeContext), 
        upTerm(Ins), upTerm(A), 
        upTerm(read-reaction(L, I2)) 
                                 ]) 
    *** typeOf(Sigma, Delta, emptyTypeContext, Ins, A, read-reaction(L, I2)) 
  /\ I2 :: 'IPDLReaction .

  ceq postTypeCheck L protocol  {'_::=_[I1, I2] : 'IPDLProtocol}
   in env =   
         (check ((chn cn) in Ins == false)
     or-else 
     fail ('cannot 'assign 'to 'an 'input 'channel
            , 
        (at term I1, include context)))
     and-then 
     (check (d :: IPDLType)
     or-else fail('unexpected 'type 'error , 
        (at term I1, include context)))
     and-then
     (check (t == d)
     and-then
     return {'_::=_[I1, I2] : 'IPDLProtocol}
     or-else fail('type 'mismatch 'for 'assignment ':
                  'channel 'has 'type 
                  (print IPDL term show-type(IPDL, typeToPre(t)))
                  'and 'reaction 'has 'type
                  (print IPDL term show-type(IPDL, typeToPre(d))), (at term I2, include context))
     )
     in (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS)
  if cn  := read-cNameIndex(L, I1) 
  /\ (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env
  /\ t := metaTypeInCtx env ('typeInCtx[upTerm(chn cn), upTerm(A), upTerm(Delta)])
       *** typeInCtx(chn cn, A, Delta) 
  /\ (whenCond --> R) ;; whenList := read-cases(L, env, I2)
  /\ d  := metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Delta), upTerm(emptyTypeContext), 
        upTerm(Ins), upTerm((A, whenCondToBoolTerm whenCond)), 
        upTerm(R) 
       ])
    *** typeOf(Sigma, Delta, emptyTypeContext, Ins, (A, whenCondToBoolTerm whenCond), R) 
  *** TODO: check other branches as well!
  /\ I2 :: 'WhenList .

  op type`check__declaredCNameIndex : IPDL TypeContext -> AnalysisAction{IPDL} .
  eq type check L Gamma declaredCNameIndex {I : 'CName}
     = return {I : 'CName} . *** check already made 
  ceq type check L Gamma declaredCNameIndex {'_`[_`][ I1, I2] : 'CNameIndex}
      in env
     = check 
        (metaOccurs env ('occurs___[upTerm( chn (q[nlist]) ), upTerm(Delta),  upTerm(A) ])) 
       and-then return {'_`[_`][ I1, I2] : 'CNameIndex}
       or-else
       check (metaIsElemB env ('isElemB[upTerm(q[nlist]), upTerm(Ins), upTerm(A)]) ) 
        and-then 
        return {'_`[_`][ I1, I2] : 'CNameIndex} 
       or-else fail ('read 'error, (at term I1, include context))         
       in env
   if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env 
   /\ q := read-qid(I1)
   /\ nlist := read-natTerms(L, I2) .

  op type`check__validRead : IPDL TypeContext -> AnalysisAction{IPDL} .
  ceq type check L Gamma validRead {'cname[I] : 'CName}
     in env
     = (check (metaOccurs env ('occurs___[upTerm( chn read-qid(I)  ), upTerm(Delta),  upTerm(A) ])) 
       or-else fail('unknown 'channel, (at L term 'cname[I], include context)) 
       )
       and-then 
       ( check ((chn read-qid(I)) in Ins)
       and-then
        return {I : 'CName}
       or-else  fail(read-qid(I) 'is 'not 'an 'input 'channel, (at L term 'cname[I], include context)) 
       ) 
       in env 
   if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl))  deltaMap protMap m TCS QIS PS) := env .
  ceq type check L Gamma validRead {I : 'CName}
     in env
     = (check(metaOccurs env ('occurs___[upTerm( chn read-qid(I)  ), upTerm(Delta),  upTerm(A) ]))
       or-else fail('unknown 'channel, (at L term 'cname[I], include context)) 
       )
       and-then 
       ( check ((chn read-qid(I)) in Ins)
       and-then
        return {I : 'CName}
       or-else  fail(read-qid(I) 'is 'not 'an 'input 'channel, (at L term 'cname[I], include context)) 
       ) 
       in env 
   if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env . 
  ceq type check L Gamma validRead {'_`[_`][ I1, I2] : 'CNameIndex}
      in env
     = check 
        (metaOccurs env ('occurs___[upTerm( chn (q[nlist])  ), upTerm(Delta),  upTerm(A) ]))
       and-then 
        ( check ( ( chn (q[nlist]) ) in Ins )
          and-then
          return {'_`[_`][ I1, I2] : 'CNameIndex}
          or-else 
          fail ('is 'not 'an 'input 'channel, (at term I1, include context))
        )
       or-else
       check (metaIsElemB env ('isElemB[upTerm(q[nlist]), upTerm(Ins), upTerm(A)]) )
        and-then 
        return {'_`[_`][ I1, I2] : 'CNameIndex}    
       or-else fail ('read 'error, (at term I1, include context))         
       in env
   if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env 
   /\ q := read-qid(I1)
   /\ nlist := read-natTerms(L, I2) .

  op type`check__reaction : IPDL TypeContext -> AnalysisAction{IPDL} .
  *** no type checks for normal forms, they are generated so they have been checked!
  eq type check L Gamma reaction {'nf`(_`,_`)[I1, I2] : 'IPDLReaction}
    = return {'nf`(_`,_`)[I1, I2] : 'IPDLReaction} .
  eq type check L Gamma reaction {'preNF`(_`,_`)[I1, I2] : 'IPDLReaction} 
    = return {'preNF`(_`,_`)[I1, I2] : 'IPDLReaction} .
  eq type check L Gamma reaction {'`(_`) [I]: 'IPDLReaction} 
   = try {'`(_`) [type check L Gamma reaction I]: 'IPDLReaction} 
  .
  eq type check L Gamma reaction {'read_[I] : 'IPDLReaction} 
   =  try {'read_[
        type check L Gamma validRead (I)] : 'IPDLReaction
        } .
  eq type check L Gamma reaction {'read[I] : 'IPDLReaction} 
   =  try {'read[
        type check L Gamma validRead (I)] : 'IPDLReaction} .      
  ceq type check L Gamma reaction {'_:_<-_;_[I, T, I1, I2] : 'IPDLReaction} 
     in 
       env
   =
     check ( t == preToType(read-type(L, T)) ) 
      and-then 
       try {'_:_<-_;_[
           return I, 
           return T, 
           type check L Gamma reaction (I1), 
           type check L (Gamma (QI : t)) reaction (I2) ] : 'IPDLReaction
       } 
      or-else 
      fail ('type 'mismatch 'for 'reaction 
            'expecting (print IPDL term show-type(IPDL, read-type(L, T)))
            'and 'got 
            (print IPDL term show-type(IPDL, typeToPre(t)))
            , 
        (at term I1, include context))
      in 
       env  
  if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env
  /\ t := metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Delta), upTerm(Gamma), 
        upTerm(Ins), upTerm(A), 
        upTerm(read-reaction(IPDL, I1)) 
        ])
      ***  typeOf(Sigma, Delta, Gamma, Ins, A, read-reaction(IPDL, I1))
  /\ QI := read-qid(I) .

  eq type check L Gamma reaction {'return_[I] : 'IPDLReaction} =
    return {'return_[I] : 'IPDLReaction} .
  
 var t1 t2 : IPDLType .

  ceq type check L Gamma reaction {'samp_`(_`)[I1, I2] : 'IPDLReaction}
     in env       
   = check ( d == t)
     and-then try {'samp_`(_`)[return I1, type check L Gamma expression I2] : 'IPDLReaction}
     or-else 
      fail ('type 'mismatch 'in 'distribution 'application 
            'expected (print IPDL term show-type(IPDL, typeToPre(d)))
            'and 'got (print IPDL term show-type(IPDL, typeToPre(t)))
            ,  
            (at L term I2, include context))
      in env
   if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS)  := env
   /\   d :=  domain read-qid(I1) Sigma
   /\   t :=  metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Gamma), upTerm(read-expression(IPDL, I2))])
         *** typeOf(Sigma, Gamma, read-expression(IPDL, I2)) 
   .
   ceq type check L Gamma reaction  {'if_then_else_[I, I1, I2] : 'IPDLReaction}  
    in env
       
   = (check (t == bool)
      or-else 
       fail ('expecting 'an 'expression 'of 'type 'bool 
             'and 'got (print IPDL term show-type(IPDL, typeToPre(t))), 
        (at term I, include context)))
     and-then 
      (check (t1 == t2)
      and-then        
       try {'if_then_else_[
           check L Gamma expression I, 
           check L Gamma reaction I1, 
           check L Gamma reaction I2] : 'IPDLReaction}
      or-else 
       fail ('reaction 'types 'do 'not 'match 
             'first 'type 'is (print IPDL term show-type(IPDL, typeToPre(t1)))
             'second 'type 'is (print IPDL term show-type(IPDL, typeToPre(t2))), 
        (at term I2, include context))
      )
      in env
   if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env /\
      t1 := metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Delta), upTerm(Gamma), 
        upTerm(Ins), upTerm(A), 
        upTerm(read-reaction(IPDL, I1)) 
       ])
         *** typeOf(Sigma, Delta, Gamma, Ins, A, read-reaction(IPDL, I1)) 
   /\ t2 :=  metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Delta), upTerm(Gamma), 
        upTerm(Ins), upTerm(A), 
        upTerm(read-reaction(IPDL, I1)) 
       ])
        *** typeOf(Sigma, Delta, Gamma, Ins, A, read-reaction(IPDL, I2))
   /\   t := metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Gamma), upTerm(read-expression(IPDL, I))])
       *** typeOf(Sigma, Gamma, read-expression(IPDL, I)) 
   .
  
op type`check__natTerm : IPDL TypeContext -> AnalysisAction{IPDL} .
eq type check L Gamma natTerm {I : 'CId} = 
   return {I : 'CId} .
eq type check L Gamma natTerm {I : 'Nat} = 
   return {I : 'Nat} .
eq type check L Gamma natTerm {I : 'NatTerm} = 
   return {I : 'NatTerm} .

op type`check__natTerms : IPDL TypeContext -> AnalysisAction{IPDL} .
 eq type check L Gamma natTerms {I : 'CId} 
  = return {I : 'CId} .
 eq type check L Gamma natTerms {I : 'Nat} 
  = return {I : 'Nat} .
 eq type check L Gamma natTerms {I : 'NatTerm} 
  = return {I : 'NatTerm} . 
 eq type check L Gamma natTerms {I : 'NatTermList} 
  = return {I : 'NatTermList} .  

op type`check__boolTerm : IPDL TypeContext -> AnalysisAction{IPDL} .
eq type check L Gamma boolTerm {I : 'BoolTerm} 
  = return {I : 'BoolTerm} .

op type`check__bound : IPDL TypeContext -> AnalysisAction{IPDL} .
eq type check L Gamma bound {I : 'Bound} 
  = return {I : 'Bound} .

op type`check__bounds : IPDL TypeContext -> AnalysisAction{IPDL} .
eq type check L Gamma bounds {I : 'Bound}
 = return {I : 'Bound} .
eq type check L Gamma bounds {I : 'BoundList}
 = return {I : 'BoundList} .

op type`check__whenCond : IPDL TypeContext -> AnalysisAction{IPDL} .
eq type check L Gamma whenCond {'otherwise.WhenCond : 'WhenCond} 
   = return {'otherwise.WhenCond : 'WhenCond} .
eq type check L Gamma whenCond {I : 'WhenCond}
   = return {I : 'WhenCond} [owise] .

op type`check__when : IPDL TypeContext -> AnalysisAction{IPDL} .
ceq type check L Gamma when {'_-->_[I1, I2] : 'When} in env
   = try {'_-->_[
       type check L Gamma whenCond (I1) in env, 
       type check L Gamma cases (I2) 
       in (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, (A, bts), nw, nl)) deltaMap protMap m TCS QIS PS)
      ] : 'When} 
if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env 
/\ bts := whenCondToBoolTerm(read-whenCond(L, I1)) .

var bt : BoolTerm .
var bts : Set{BoolTerm} .

op type`check__whenList : IPDL TypeContext -> AnalysisAction{IPDL} .
eq type check L Gamma whenList {'emptyWhen.WhenList : 'WhenList} 
   = return {'emptyWhen.WhenList : 'WhenList} .
eq type check L Gamma whenList {'`(_`) [I] : 'WhenList}
 = try {'`(_`) [type check L Gamma whenList I] : 'WhenList} .   
  ceq type check L Gamma whenList I 
   = type check L Gamma when I if I :: 'When  . 
  ceq type check L Gamma whenList {'_;;_[I1, I2] : 'WhenList}
      in env
   = try {'_;;_[
       type check L Gamma whenList (I1) in env, 
       type check L Gamma whenList (I2) 
       in (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, (A, neg bt), nw, nl)) deltaMap protMap m TCS QIS PS)
      ] : 'WhenList} 
   if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env 
   /\ bt := whenListToBoolTerm(read-whenList(L, I1)) .

op type`check__cases : IPDL TypeContext -> AnalysisAction{IPDL} .
 ceq type check L Gamma cases I  
   = type check L Gamma reaction I if I :: 'IPDLReaction . 
  ceq type check L Gamma cases I
    = type check L protocol I if I :: 'IPDLProtocol .
  ceq type check L Gamma cases I 
   = type check L Gamma whenList I if I :: 'WhenList .  
  ceq type check L Gamma cases I 
   = type check L Gamma when I if I :: 'When .


  var d t : IPDLType .
  var deltaMap : Map{Qid, PairSetIO} .

  op type`check__expression : IPDL TypeContext -> AnalysisAction{IPDL} .
  eq type check L Gamma expression {'`(`).IPDLExpr : 'IPDLExpr} 
   = return {'`(`).IPDLExpr : 'IPDLExpr} .
   
  ceq type check L Gamma expression {'_`(_`)[I1, I2] : 'IPDLExpr}
     in env
   = check (d == t)
     and-then try {'_`(_`)[return I1, check L Gamma expression I2] : 'IPDLExpr}
     or-else
      fail ('type 'mismatch 'in 'function 'application 'for read-qid(I1)
            'expected (print IPDL term show-type(IPDL, typeToPre(d)))
            'and 'got (print IPDL term show-type(IPDL, typeToPre(t)))
            ,
            (at term I2, include context))
      in
       env
   if (buildEnv (aConfig(Sigma, Delta, P, Ins, Outs, A, nw, nl)) deltaMap protMap m TCS QIS PS) := env
   /\ d := domain read-qid(I1) Sigma
   /\ t := metaTypeOf env ('typeOf[upTerm(Sigma), upTerm(Gamma), upTerm(read-expression(IPDL, I2))])
         *** typeOf(Sigma, Gamma, read-expression(IPDL, I2)) 
   . 
  
  var PS : TypeContext .

  op check_familyName : IPDL -> AnalysisAction{IPDL} .
  eq check L familyName {'_`[_`][I1, I2] : 'FamilyName} =
     try {'_`[_`][
        return I1, 
        check L emptyTypeContext bounds (I2)] : 'FamilyName} .
   
  op adjust_cName : IPDL -> AnalysisAction{IPDL} .
  eq adjust L cName {'cname[I] : 'CName} =
     return {I : 'CName} 
  .  
  eq adjust L cName I = return I [owise] .  

***(   eq adjust L cName  {'__[I, S] : 'CName}
  = try {'__[
        adjust L cName (I),
        check L cname-scripts(S)
      ] : 'CName} . )

  op adjust_pName : IPDL -> AnalysisAction{IPDL} .
  eq adjust L pName {'pname[I] : 'PName} =
     return {I : 'PName}
  .    
  
   var q1 q2 : Qid .
   var cnb1 cnb2 : CNameBound .
   var cnbl : List{CNameBound} .
   var nt : NatTerm .
   var qpl : QidPairList .
   var cn : ChannelName .

  op proofProtocol__ : Protocol Proof{IPDL} -> Protocol .
  eq proofProtocol P (Proof[IPDL]{merge cases for cnb1})
   = keepOne P cnb1  .
   eq proofProtocol P (Proof[IPDL]{rename qpl in cnb1})
   = keepOne P cnb1  . 
  eq proofProtocol P (Proof[IPDL]{merge case q1 = nt with otherwise for cnb1})
   = keepOne P cnb1  . 
  eq proofProtocol P (Proof[IPDL]{turn neg into otherwise for cnb1})
   = keepOne P cnb1  . 
  eq proofProtocol P (Proof[IPDL]{turn otherwise into neg for cnb1})
   = keepOne P cnb1  .   
  eq proofProtocol P (Proof[L]{fold (chn q1) into (chn q2)}) =
     keepTwo P (chn q1) (chn q2) . 
  eq proofProtocol P (Proof[L]{subst cnb1 into cnb2}) =
     keepTwo P cnb1 cnb2 . 
  eq proofProtocol P (Proof[L]{drop read cnb1 from cnb2}) =
     keepTwo P cnb1 cnb2 .    
  eq proofProtocol P (Proof[L]{absorb cnb1}) =
     keepOne P cnb1  .   
  eq proofProtocol P (Proof[L]{combine cnb1}) =
     keepOne P cnb1  .
  eq proofProtocol P (Proof[L]{split cnb1 on first index}) =
     keepOne P cnb1  .            
  eq proofProtocol P (Proof[L]{split cnb1 on second index}) =
     keepOne P cnb1  .
  eq proofProtocol P (Proof[L]{call q}) =
     P .  
  eq proofProtocol P (Proof[L]{ungroup cnb1}) =
     keepOne P cnb1 .     
  eq proofProtocol P (Proof[L]{unsplit cn}) =
     P  .
  eq proofProtocol P (Proof[L]{rename variables qpl of cnb1}) = 
     P .  
  eq proofProtocol P (Proof[IPDL]{group cnbl in q indices: nlist bounds: blist}) =
     keepAll P cnbl .

  op proofLHS_ : Proof{IPDL} -> QidList .
  *** TODO: add for absorb
  *** TODO: add for combine
  *** TODO: add for dropSubsume
  *** TODO: add for otherwisetoneg, negtootherwise
  *** TODO: mergeCases, merge with otherwise
  *** TODO: add for alpha
  *** TODO: add for split!
  eq proofLHS(Proof[L]{absorb (chn q1)}) =
     tokenize("newNF(< c : T > ltq, P || (c ::= R))") .
  eq proofLHS (Proof[L]{fold (chn q1) into (chn q2)}) = 
     tokenize("(c ::= R) || (o ::= nf((x : T <- read c) ..., S))") .
  eq proofLHS (Proof[L]{subst (chn q1) into (chn q2)}) = *** TODO: case distinction and correct!
     tokenize("(c ::= R) || (o ::= nf((x : T <- read c) ..., S))") .   


  endm

********************************************************************************

fmod IPDL/PRINTING is
  protecting PRINTING { IPDL } .
  protecting IPDL/SHOW .

  vars D E : Decl{IPDL} .
  var  DL : DeclList{IPDL} .
  var L : IPDL .
  var P P1 P2 : Protocol .
  var T : IPDLType .
  var R : Reaction .
  var QL : QidList .
  var Q : Qid .
  var flag : Bool .
  var ltq : TypedCNameList .

  var cn : ChannelName .
  
  op print : DeclList{IPDL} -> QidList .
  eq print((nil).DeclList{IPDL}) = 'no 'declarations .
  eq print(D) = print IPDL term show-decl(D) .
  eq print(D E DL) = print(D) '\n print(E DL) .

  var ids : List{NatTerm} .
  var bds : List{Bounds} .
  var cases : Cases .
  var q : Qid .

  op printCName_ : ChannelName -> QidList .
  eq printCName q = q .
  eq printCName (q[ids]) = q '`[ (print IPDL term show-natTerms(IPDL, ids)) '`] .

  op printProtocol : Protocol Bool QidList -> QidList .
  eq printProtocol(emptyProtocol, flag, Q QL) 
   = if flag then 'emptyProtocol '\o else Q 'emptyProtocol '\o fi .
  eq printProtocol(cn ::= cases, flag, Q QL) 
   = if flag 
     then (printCName cn) '::= (print IPDL term show-cases(IPDL, cases)) '\o 
     else Q (printCName cn) '::= (print IPDL term show-cases(IPDL, cases)) '\o 
     fi .
  eq printProtocol(family q[bds] ids bds ::= cases, flag, Q QL) 
   = if flag 
     then 'family (print IPDL term show-familyName(IPDL, q[bds])) 
          'indices: (print IPDL term show-natTerms(IPDL, ids)) 
          'bounds: (print IPDL term show-bounds(IPDL, bds))
          '::= (print IPDL term show-cases(IPDL, cases)) '\o 
     else Q 'family (print IPDL term show-familyName(IPDL, q[bds])) 
          'indices: (print IPDL term show-natTerms(IPDL, ids)) 
          'bounds: (print IPDL term show-bounds(IPDL, bds))
          '::= (print IPDL term show-cases(IPDL, cases)) '\o
     fi .
  eq printProtocol(newfamily q[bds] ids bds : T in P, flag, Q QL) 
   = if flag 
     then 
      'newfamily (print IPDL term show-familyName(IPDL, q[bds])) 
          'indices: (print IPDL term show-natTerms(IPDL, ids)) 
          'bounds: (print IPDL term show-bounds(IPDL, bds))
           ': (print IPDL term show-type(IPDL, typeToPre(T))) 'in '\n 
      printProtocol(P, flag, Q QL) '\o 
     else  
      Q 'newfamily (print IPDL term show-familyName(IPDL, q[bds])) 
          'indices: (print IPDL term show-natTerms(IPDL, ids)) 
          'bounds: (print IPDL term show-bounds(IPDL, bds))
           ': (print IPDL term show-type(IPDL, typeToPre(T))) 'in '\n 
      printProtocol(P, flag, Q QL) '\o 
     fi 
       .   
  eq printProtocol(new cn : T in P, flag, Q QL) 
   = if flag 
     then 
      'new cn ': (print IPDL term show-type(IPDL, typeToPre(T))) 'in '\n 
      printProtocol(P, flag, Q QL) '\o 
     else  
      Q 'new cn ': (print IPDL term show-type(IPDL, typeToPre(T))) 'in '\n 
      printProtocol(P, flag, Q QL) '\o 
     fi 
       .
  eq printProtocol(P1 || P2, flag, QL) = colorPrintProtocol(P1 || P2, QL) .
  eq printProtocol(newNF(ltq, P), flag, Q QL) = 
     if flag 
     then 
     'newNF '`( (print IPDL term show-typedCNameList(IPDL, ltq)) '`, 
     '\n printProtocol(P, flag, Q QL) '`) '\o
     else 
     Q 'newNF '`( (print IPDL term show-typedCNameList(IPDL, ltq)) '`, 
     '\n printProtocol(P, flag, Q QL) '`) '\o
     fi 
     .

  op colorPrintProtocol : Protocol QidList -> QidList .
  eq colorPrintProtocol(P1 || P2, Q QL) = 
     printProtocol(P2, false, Q QL) '\n '|| '\n printProtocol(P1, false, QL Q) 
     . 

endfm

********************************************************************************

mod IPDL/PARSING-&-PRINTING is
  protecting IPDL/PARSING .
  protecting IPDL/PRINTING .
endm

********************************************************************************

***(
smod EXECUTE is
 protecting STRATS .

 ops  xorF flipF : -> SigElem .
 eq xorF = 'xor : (bool * bool) ~> bool .
 
 eq flipF = 'flip : unit ~>> bool .
 
 op sig : -> Signature .
 eq sig = xorF flipF .
 
 op delta : -> ChannelContext .
 eq delta = 
    (chn 'In :: bool) 
    (chn ('LeakCtxt ^^ 'Alice .. 'adv) :: bool)
 .

  var x y z : Qid . 
 var Sigma : Signature .
 var Delta : ChannelContext .
 var Gamma : TypeContext .
 var Ins Outs : Set{CNameBound} .
 var A : Set{BoolTerm} .
 var cn f : ChannelName .
 var pConf : ProtocolConfig .
 var P : Protocol .
 var T : IPDLType .
  
  crl [test] :
    rConfig(Sigma, Delta, Gamma, return True , Ins, A, T)
     => 
    rConfig(Sigma, Delta, Gamma, return False, Ins, A, T)
  if T == bool  
  .  
 
  ***(

  when applyTest has no arguments

  red metaSrewrite(upModule('EXECUTE, false), upTerm(pConfig(emptySig, chn 'c :: bool , 
  'c ::= nf(emptyBRList, return True), empty, chn 'c, empty)), 'applyTest[[empty]], breadthFirst, 0) .

  )

  strat applyTest : ChannelName @ ProtocolConfig .
  
  sd applyTest(cn) :=
             applyTestNF(cn)
     or-else applyTestPre(cn)
  .

  strat applyTestPre : ChannelName @ ProtocolConfig .
  sd applyTestPre(cn) :=
   match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyTestPre(cn)}
    : matchrew pConf s.t. pConfig(Sigma, Delta, P, Ins, Outs, A) := pConf by pConf
       using (  
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                        P1:Protocol <- keepOne P (chn cn)]{ 
               CONG-REACT[o:ChannelName <- cn]
                { cong-pre-nf{test} ;
                  try (pre2Nf)}
                        }
        or-else  CONG-REACT[o:ChannelName <- cn]
                { cong-pre-nf{test} ;
                  try (pre2Nf)} )                 
  .

  strat applyTestNF : ChannelName @ ProtocolConfig .
  sd applyTestNF(cn) :=
   match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyTestNF(cn)}
    : matchrew pConf s.t. pConfig(Sigma, Delta, P, Ins, Outs, A) := pConf by pConf
       using (  
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                        P1:Protocol <- keepOne P (chn cn)]{ 
               CONG-REACT[o:ChannelName <- cn]
                { cong-nf{test}}
                        }
        or-else  CONG-REACT[o:ChannelName <- cn]
                { cong-nf{test} }
            )                 
  .

  strat symTest @ ProtocolConfig .
  sd symTest :=
     matchrew pConf s.t. pConfig(Sigma, Delta, P, Ins, Outs, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- Outs,
       P1:Protocol <- P
        ]
        { idle
        }                 
        
  .

  op real : -> Protocol .
  eq real = 
    new 'Key : bool in
    new 'Ctxt : bool in
    (
     ('Key ::= nf(emptyBRList, samp ('flip < () >)) ) 
     || 
     ('Ctxt ::= 
       nf( ('m : bool <- read 'In)
            'k : bool <- read 'Key,
            return (ap 'xor pair('m, 'k))
               )
     )
     ||
     ('LeakCtxt ^^ 'Alice .. 'adv ::= 
       nf( 'c : bool <- read 'Ctxt ,
           return 'c)  
     )
    ) 
         
  .

  crl [flipInvariantXorFixedNew]:
    rConfig(Sigma:Signature,
            Delta:ChannelContext,
            Gamma:TypeContext (x : typeName 'bool),
            y : typeName 'bool <- samp ('flip < () >) ; return (ap 'xor pair(x, y)),
            Ins:Set{CNameBound},
            A:Set{BoolTerm},
            T:IPDLType)
     =>
     rConfig(Sigma:Signature,
            Delta:ChannelContext,
            Gamma:TypeContext (x : typeName 'bool),
            samp ('flip < () >),
            Ins:Set{CNameBound},
            A:Set{BoolTerm},
            T:IPDLType)
     if T:IPDLType == bool .

endsm 
***
red metaSrewrite(upModule('EXECUTE, false), 
    upTerm( pConfig(
         ( 'xor : (bool * bool) ~> bool)('flip : unit ~>> bool), 
         (chn 'In :: bool) 
         (chn ('LeakCtxt ^^ 'Alice .. 'adv) :: bool), 
         new 'Key : bool in
    new 'Ctxt : bool in
    (
     ('Key ::= nf(emptyBRList, samp ('flip < () >)) ) 
     || 
     ('Ctxt ::= 
       nf( ('m : bool <- read 'In)
            'k : bool <- read 'Key,
            return (ap 'xor pair('m, 'k))
               )
     )
     ||
     ('LeakCtxt ^^ 'Alice .. 'adv ::= 
       nf( 'c : bool <- read 'Ctxt ,
           return 'c)  
     )
    ) , 
         chn 'In, 
         chn ('LeakCtxt ^^ 'Alice .. 'adv), 
         empty)), 
         'sugar-newNF[none]{empty} ; 'moveNewToFront[[empty]] ; 
         'subst[[upTerm(chn 'Key), upTerm(chn 'Ctxt) ]], breadthFirst, 0) .

)  

************

smod MYTEST is
 pr BASEGMWN .
 pr STRATS .
 pr IPDL/PARSING-&-PRINTING .
 pr IPDL/ENV .


endsm 
***(
set trace off .
srew [1] pConfig(typesOf ('bool ; 'nat ; 'unit)
('** : typeName 'bool * typeName 'bool ~> typeName 'bool)
('neg : typeName 'bool ~> typeName 'bool)
('xor : typeName 'bool * typeName 'bool ~> typeName 'bool)
'flip : typeName 'unit ~>> typeName 'bool, (fam ('OTChcRcvd-1OtAdv[bound (natAsTerm 2 + qidAsTerm 'N) fixedBound (natAsTerm 1 + qidAsTerm 'N) bound
    qidAsTerm 'K]) :: typeName 'unit)
(fam ('Share[bound (natAsTerm 2 + qidAsTerm 'N) bound qidAsTerm 'K]) :: typeName 'bool)
fam ('ShareOK[bound (natAsTerm 2 + qidAsTerm 'N) bound qidAsTerm 'K]) :: typeName 'unit, newNF(< 'd : typeName 'bool >, family 'Adv[bound qidAsTerm 'K]
    qidAsTerm 'k
bound qidAsTerm 'K
::=
(when (apply 'isInputGate qidAsTerm 'k) -->
('d ::= nf(emptyBRList, return True)

||
family 'OTChcRcvd-1OtAdv[bound (natAsTerm 2 + qidAsTerm 'N) fixedBound (natAsTerm 1 + qidAsTerm 'N) bound qidAsTerm 'K] qidAsTerm 'n qidAsTerm 'm
    qidAsTerm 'k
bound (natAsTerm 2 + qidAsTerm 'N) fixedBound (natAsTerm 1 + qidAsTerm 'N) bound qidAsTerm 'K
::=
nf('oc : typeName 'unit <- read ('OTChcRcvd-1OtAdv[qidAsTerm 'n (natAsTerm 1 + qidAsTerm 'N) qidAsTerm 'k]), return 'oc)
))
;;
when (apply 'isAndGate qidAsTerm 'k) -->
('d ::= nf(emptyBRList, return False)

||
family 'OTChcRcvd-1OtAdv[bound (natAsTerm 2 + qidAsTerm 'N) fixedBound (natAsTerm 1 + qidAsTerm 'N) bound qidAsTerm 'K] qidAsTerm 'n qidAsTerm 'm
    qidAsTerm 'k
bound (natAsTerm 2 + qidAsTerm 'N) fixedBound (natAsTerm 1 + qidAsTerm 'N) bound qidAsTerm 'K
::=
(when (qidAsTerm 'n <T natAsTerm 1 + qidAsTerm 'N) -->
nf('x : typeName 'unit <- read ('ShareOK[(natAsTerm 1 + qidAsTerm 'N) (fun 'wire1 qidAsTerm 'k)]), return ()))
;;
when (qidAsTerm 'n =T= natAsTerm 1 + qidAsTerm 'N) -->
nf('oc : typeName 'unit <- read ('OTChcRcvd-1OtAdv[qidAsTerm 'n (natAsTerm 1 + qidAsTerm 'N) qidAsTerm 'k]), return 'oc)
)

||
family 'ShareOK[bound (natAsTerm 2 + qidAsTerm 'N) bound qidAsTerm 'K] qidAsTerm 'n qidAsTerm 'k
bound (natAsTerm 2 + qidAsTerm 'N) bound qidAsTerm 'K
::=
nf('x : typeName 'bool <- read ('Share[qidAsTerm 'n qidAsTerm 'k]), return ())
), fam ('Share[bound (natAsTerm 2 + qidAsTerm 'N) bound qidAsTerm 'K]), (fam ('OTChcRcvd-1OtAdv[bound (natAsTerm 2 + qidAsTerm 'N) fixedBound (
    natAsTerm 1 + qidAsTerm 'N) bound qidAsTerm 'K]), fam ('ShareOK[bound (natAsTerm 2 + qidAsTerm 'N) bound qidAsTerm 'K])), (neg (apply 'isAndGate
    natAsTerm 0), neg (apply 'isNotGate natAsTerm 0), neg (apply 'isXorGate natAsTerm 0), apply 'isHonest natAsTerm 1 + qidAsTerm 'N))
  using 
 select-branch-family-p[fns:NameWithScripts <- 'Adv,
 bt:BoolTerm <- (apply 'isAndGate qidAsTerm 'k) ]{
   CONG-NEW-NF{
      select-branch-family-r[fns:NameWithScripts <- 'OTChcRcvd-1OtAdv,
      bt:BoolTerm <- (qidAsTerm 'n <T natAsTerm 1 + qidAsTerm 'N) ]{
         subst(
            fam ('ShareOK[bound (natAsTerm 2 + qidAsTerm 'N) bound qidAsTerm 'K]),
            fam ('OTChcRcvd-1OtAdv[bound (natAsTerm 2 + qidAsTerm 'N) fixedBound (natAsTerm 1 + qidAsTerm 'N) bound qidAsTerm 'K])
         )
      }
   }
 }
 .
)

