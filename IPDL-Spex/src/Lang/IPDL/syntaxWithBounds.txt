***( IPDL

  Copyright : (C) 2022-23, IPDLMaude
  License   : GNU General Public License v3.0 or later (GPL-3.0-or-later)
  Authors   : ipdlmaude@gmail.com

)

sload ../../Language.maude

fmod NAT/VARS is
 including NAT .
 
 *** extend NAT with some axioms about inequalities involving constants
 
 var N x y : Nat .
 
 eq 0 <= N = true .
 eq 0 < N = 0 =/= N .
 eq N < N + x = x =/= 0 .
 eq N + x < N + y = x < y .
 
endfm

fmod TYPES is
 protecting NAT/VARS .
 protecting QID .

 sort IPDLType . 

 op typeName_ : Qid -> IPDLType [ctor] .

 op unit : -> IPDLType . 
 eq unit = typeName 'unit .

 op bool : -> IPDLType .
 eq bool = typeName 'bool .

 op nat : -> IPDLType .
 eq nat = typeName 'nat .

 op _*_ : IPDLType IPDLType -> IPDLType .
 
 var A B : IPDLType .

 op prj1 : IPDLType -> IPDLType .
 op prj2 : IPDLType -> IPDLType .
 eq prj1(A * B) = A .
 eq prj2(A * B) = B .

endfm

fmod TYPE-CONTEXT is
 protecting QID . 
 protecting TYPES .

 sort TypeContextElem .

 op _:_ : Qid IPDLType -> TypeContextElem [ctor] .

 var q : Qid . 
 var t : IPDLType .

 op qidOf_ : TypeContextElem -> Qid . 
 eq qidOf (q : t) = q . 

 op typeOf_ : TypeContextElem -> IPDLType . 
 eq typeOf (q : t) = t .

 sort TypeContext . 
 op emptyTypeContext : -> TypeContext [ctor] .
 subsort TypeContextElem < TypeContext . 
 op __ : TypeContext TypeContext -> TypeContext [ctor assoc comm id: emptyTypeContext] .

 vars Q1 Q2 : Qid .
 vars T T1 T2 : IPDLType . 
 vars Gamma1 Gamma2 : TypeContext .
 
 *** check whether a variable with the name Q1 occurs in a var context
 *** with any type
 op _elem_ : Qid TypeContext -> Bool .
 eq Q1 elem emptyTypeContext = false . 
 ceq Q1 elem ((Q2 : T) Gamma1) = true if Q1 == Q2 .
 ceq Q1 elem ((Q2 : T) Gamma1) = Q1 elem Gamma1 if Q1 =/= Q2 .


 *** for a variable that we know occurs in a var context, retrieve the type
 op varType : Qid TypeContext -> IPDLType .
 ceq varType(Q1, (Q2 : T) Gamma1) = T if Q1 == Q2 .
 ceq varType(Q1, (Q2 : T) Gamma1) = varType(Q1, Gamma1) if Q1 =/= Q2 .

 *** a context is valid if a variable doesn't occur twice with different names
 op validContext_ : TypeContext -> Bool .
 eq validContext emptyTypeContext = true .
 eq validContext ((Q1 : T1) Gamma1) = not (Q1 elem Gamma1) and validContext Gamma1 .  

endfm


view TypeContextElem  from TRIV to TYPE-CONTEXT is
 sort Elt to TypeContextElem .
endv


fmod SIGNATURE is 
 protecting QID-SET/OPS . 
 protecting TYPES .

 sort SigElem .

 op _:_~>_  : Qid IPDLType IPDLType -> SigElem [ctor format(b o r o r o)]  . *** function symbol
 op _:_~>>_ : Qid IPDLType IPDLType -> SigElem [ctor format(b o r o r o)] . *** distribution
 op typesOf_ : QidSet -> SigElem [ctor] .

 var QIS : QidSet .
 vars Q1 Q2 : Qid .
 vars T T1 T2 : IPDLType . 

 op dom_ : SigElem -> IPDLType .
 op cod_ : SigElem -> IPDLType .
  
 eq dom(Q1 : T1 ~> T2)  = T1 .
 eq dom(Q1 : T1 ~>> T2) = T1 .
  
 eq cod(Q1 : T1 ~> T2) = T2 . 
 eq cod(Q1 : T1 ~>> T2) = T2 .

 sort Signature . 
 op emptySig : -> Signature [ctor] .
 subsort SigElem < Signature . 
 op __ : Signature Signature -> Signature [ctor assoc comm id: emptySig format(d n d)] .

 vars Sig1 Sig2 : Signature .

 *** check that a symbol occurs in a signature
 *** independent of its type
 *** and whether if it is a function or distribution name
 op _elem_ : Qid Signature -> Bool .
 eq Q1 elem emptySig = false .
 eq Q1 elem typesOf(QIS) = false .
 ceq Q1 elem ((Q2 : T1 ~> T2) Sig1) = true if Q1 == Q2 .
 ceq Q1 elem ((Q2 : T1 ~> T2) Sig1) = Q1 elem Sig1 if Q1 =/= Q2 .
 ceq Q1 elem ((Q2 : T1 ~>> T2) Sig1) = true if Q1 == Q2 .
 ceq Q1 elem ((Q2 : T1 ~>> T2) Sig1) = Q1 elem Sig1 if Q1 =/= Q2 .

 op find__ : Qid Signature -> SigElem . 
 *** only find symbols that appear in signature!
 ceq find Q1 ((Q2 : T1 ~> T2) Sig1)  = Q1 : T1 ~> T2 if Q1 == Q2 .
 ceq find Q1 ((Q2 : T1 ~> T2) Sig1)  = find Q1 Sig1 if Q1 =/= Q2 .
 ceq find Q1 ((Q2 : T1 ~>> T2) Sig1) = Q1 : T1 ~>> T2 if Q1 == Q2 .
 ceq find Q1 ((Q2 : T1 ~>> T2) Sig1) = find Q1 Sig1 if Q1 =/= Q2 .

 *** the function must appear in the signature!
 op domain__ : Qid Signature -> IPDLType .
 eq domain Q1 ((Q1 : T1 ~> T2) Sig1) = T1 .
 eq domain Q1 ((Q1 : T1 ~>> T2) Sig1) = T1 .
 
 *** a sig is valid if a symbol name doesn't appear twice
 op validSig_ : Signature -> Bool .
 eq validSig emptySig = true .
 eq validSig ((Q1 : T1 ~> T2) Sig1) = not (Q1 elem Sig1) and validSig Sig1 .
 eq validSig ((Q1 : T1 ~>> T2) Sig1) = not (Q1 elem Sig1) and validSig Sig1 .

endfm

 
fmod EXPRESSION is
 protecting QID .
 protecting TYPES .

 sort IPDLExpression  . 
 
 subsort Qid < IPDLExpression  . *** variables

 ops True False : -> IPDLExpression  [ctor] . 

 op () : -> IPDLExpression  [ctor] .

 op ap__ : Qid IPDLExpression  -> IPDLExpression  [ctor] . *** function application

 op pair : IPDLExpression  IPDLExpression  -> IPDLExpression  [ctor] . *** (_,_)

 op fst_ : IPDLExpression  -> IPDLExpression  [ctor] .
 op snd_ : IPDLExpression  -> IPDLExpression  [ctor] .

 op fst : IPDLType IPDLType IPDLExpression -> IPDLExpression [ctor] .
 op snd : IPDLType IPDLType IPDLExpression -> IPDLExpression [ctor] .
 
endfm

fmod IPDL-SUBST is
 protecting EXPRESSION .

 sort IPDLSubst .
   
 var w i f q : Qid .
 var V M M1 M2 : IPDLExpression .
 var theta : IPDLSubst .

 op _.>_ : Qid IPDLExpression -> IPDLSubst [ctor] .
 op emptyIPDLSubst : -> IPDLSubst [ctor] .
 op _;_ : IPDLSubst IPDLSubst -> IPDLSubst [assoc comm id: emptyIPDLSubst] . 

 *** subst a var with an expression in an expression
 op _[_:=_] : IPDLExpression Qid IPDLExpression -> IPDLExpression .

 eq w [w := V] = V . 
 eq ()[w := V] = () .
 ceq i [w := V] = i if i =/= w .
 eq True [w := V] = True .
 eq False [w := V] = False .
 eq (ap f M) [w := V] = ap f (M [w := V]) .
 eq (pair(M1, M2)) [w := V] = pair(M1 [w := V] , M2 [w := V]) .
 eq (fst M) [w := V] = fst (M [w := V]) .
 eq (snd M) [w := V] = snd (M [w := V]) .  

 op applySubst__ : IPDLExpression IPDLSubst -> IPDLExpression .
 eq applySubst M emptyIPDLSubst = M .
 eq applySubst M (q .> V) = M [q := V] .
 eq applySubst M ( (q .> V) ; theta) = applySubst (M [q := V]) theta .
 
endfm 

fmod EXPRESSION-TYPING is 
 protecting EXPRESSION .
 protecting SIGNATURE .
 protecting TYPE-CONTEXT .

 op typeOf : Signature TypeContext IPDLExpression  -> IPDLType .

 var Sigma : Signature .
 var Gamma : TypeContext .
 var x f : Qid .
 var M M1 M2 : IPDLExpression  .
 var T T1 T2 : IPDLType .

 eq typeOf(Sigma, Gamma (x : T), x) = T .
 eq typeOf(Sigma, Gamma, ()) = unit .
 eq typeOf(Sigma, Gamma, True) = bool .
 eq typeOf(Sigma, Gamma, False) = bool .
 ceq typeOf(Sigma (f : T1 ~> T2), Gamma, ap f M) = T2 
     if typeOf(Sigma (f : T1 ~> T2), Gamma, M) == T1 .
 eq typeOf(Sigma, Gamma, pair(M1, M2)) = typeOf(Sigma, Gamma, M1) * typeOf(Sigma, Gamma, M2) .

 eq typeOf(Sigma, Gamma, fst M) = prj1(typeOf(Sigma, Gamma, M)) .
 eq typeOf(Sigma, Gamma, snd M) = prj2(typeOf(Sigma, Gamma, M)) .

endfm

mod EXPRESSION-EQUALITY is
 protecting EXPRESSION-TYPING . 
 protecting IPDL-SUBST .
 
 var Sigma : Signature .
 var Gamma Gamma1 Gamma2 : TypeContext . 
 vars M M1 M2 M3 M4 M1' M2' : IPDLExpression  .
 vars T T1 T2 T3 T4 : IPDLType . 
 var f c : Qid .
 var theta : IPDLSubst .
 
 sort ExpConfig . 
 op expConfig : Signature TypeContext IPDLType IPDLExpression -> ExpConfig [ctor] .
 
 crl [exp-sym] : 
 expConfig(Sigma, Gamma, T, M1) 
 => 
 expConfig(Sigma, Gamma, T, M2) 
 if
  expConfig(Sigma, Gamma, T, M2) 
 => 
 expConfig(Sigma, Gamma, T, M1) [nonexec] .
 crl [exp-subst] :
 expConfig(Sigma, Gamma1, T, M1')
 =>
 expConfig(Sigma, Gamma1, T, applySubst M2 theta)
 if
 expConfig(Sigma, Gamma2, T, M1)
 =>
 expConfig(Sigma, Gamma2, T, M2) 
 /\ 
 M1' == applySubst M1 theta
 [nonexec]
 .

 crl [app-cong] : 
 expConfig(Sigma (f : T1 ~> T2), Gamma, T2, ap f M1)
 => 
 expConfig(Sigma (f : T1 ~> T2), Gamma, T2, ap f M2)
 if 
 expConfig(Sigma (f : T1 ~> T2), Gamma, T1, M1)
 => 
 expConfig(Sigma (f : T1 ~> T2), Gamma, T1, M2) .
 
 crl [pair-cong] :
 expConfig(Sigma, Gamma, T1 * T2, pair(M1, M2))
 => 
 expConfig(Sigma, Gamma, T1 * T2, pair(M3, M4))
 if 
 expConfig(Sigma, Gamma, T1, M1)
 => 
 expConfig(Sigma, Gamma, T1, M3)
 /\ 
 expConfig(Sigma, Gamma, T2, M2)
 => 
 expConfig(Sigma, Gamma, T2, M4) .
 
 crl [fst-cong] :
 expConfig(Sigma, Gamma, T1, fst(T1, T2, M1))
 => 
 expConfig(Sigma, Gamma, T1, fst(T1, T2, M2)) 
 if
 expConfig(Sigma, Gamma, T1 * T2, M1)
 => 
 expConfig(Sigma, Gamma, T1 * T2, M2)
 .
 
 crl [snd-cong] :
 expConfig(Sigma, Gamma, T2, snd(T1, T2, M1))
 => 
 expConfig(Sigma, Gamma, T2, snd(T1, T2, M2)) 
 if
 expConfig(Sigma, Gamma, T1 * T2, M1)
 => 
 expConfig(Sigma, Gamma, T1 * T2, M2)
 .
 
 crl [unit-ext] : 
 expConfig(Sigma, Gamma, typeName 'unit, M1)
 =>
 expConfig(Sigma, Gamma, typeName 'unit, ())
 if typeOf(Sigma, Gamma, M1) == typeName 'unit . 

 eq fst pair(M1, M2) = M1 .
 eq snd pair(M1, M2) = M2 .
 eq pair(fst M, snd M) = M [label pair-ext] .

endm

fmod DISTRIBUTION is
 protecting EXPRESSION .
 protecting TYPES . 

 sort Distribution . 
 *** op flip : -> Distribution [ctor] .
 op _<_> : Qid IPDLExpression  -> Distribution [ctor] .
endfm 

fmod DISTRIBUTION-TYPING is
 protecting DISTRIBUTION .
 protecting EXPRESSION-TYPING .

 op typeOf : Signature TypeContext Distribution -> IPDLType .

 vars T T1 T2 : IPDLType .
 var M : IPDLExpression  .
 var Sigma : Signature .
 var Gamma : TypeContext .
 var d : Qid .

 *** eq typeOf(Sigma, Gamma, flip) = bool .
 ceq typeOf(Sigma (d : T1 ~>> T2), Gamma, d < M >) = T2 
     if typeOf(Sigma, Gamma, M) == T1 .  

endfm

fmod NAT-TERM is
 protecting QID .
 
 *** we need these for indices and their assumptions
 
 sort NatTerm .
 *** explicit subsort injections
 op natAsTerm_ : Nat -> NatTerm [ctor] .
 op qidAsTerm_ : Qid -> NatTerm [ctor] .
 
 op _+_ : NatTerm NatTerm -> NatTerm [assoc comm] .
 op _-_ : NatTerm NatTerm -> NatTerm .
 op _*_ : NatTerm NatTerm -> NatTerm [assoc comm] .
 op fun__ : Qid NatTerm -> NatTerm [ctor] . *** unary function application
 *** more if needed. 
 
 sort BoolTerm .
 
 *** we need these for conditions in cases
 
 op falseBT : -> BoolTerm [ctor] .
 op trueBT : -> BoolTerm [ctor] .
 op apply__ : Qid NatTerm -> BoolTerm [ctor] . *** predicates over natterms
 op neg_ : BoolTerm -> BoolTerm [ctor] .
 op _=T=_ : NatTerm NatTerm -> BoolTerm [ctor comm] .
 op _<T_ : NatTerm NatTerm -> BoolTerm [ctor] .
 op _<=T_ : NatTerm NatTerm -> BoolTerm [ctor] .
 op _conj_ : BoolTerm BoolTerm -> BoolTerm [ctor assoc comm] .
 op _disj_ : BoolTerm BoolTerm -> BoolTerm [ctor assoc comm] .
 
 var b1 b2 b3 : BoolTerm .
 *** eq (b1 conj b2) disj b3 = (b1 disj b3) conj (b2 disj b3) .
 *** eq (b1 disj b2) conj b3 = (b1 conj b3) disj (b2 conj b3) .
 eq (b1 conj neg b1) = falseBT .
 eq (b1 disj neg b1) = trueBT .
 eq neg (neg b1) = b1 .
 eq neg falseBT = trueBT .
 eq neg trueBT = falseBT .
 *** if problems arise, comment these out
 eq b1 conj trueBT = b1 .
 eq b1 disj trueBT = trueBT .
 eq b1 conj falseBT = falseBT .
 eq b1 disj falseBT = b1 .
 
endfm

view NatTerm from TRIV to NAT-TERM is
 sort Elt to NatTerm .
endv

view BoolTerm from TRIV to NAT-TERM is
 sort Elt to BoolTerm .
endv

fmod NAT-TERM-EVAL is
 pr NAT-TERM .
 pr MAP{Qid, NatTerm} .
 pr SET{BoolTerm} .
 pr INT .
 
  var n n1 n2 n3 x y : Nat .
  var t t1 t2 t3 t4 nt nt1 nt2 : NatTerm .
  var A A' : Set{BoolTerm} .
  var bt bt' : BoolTerm .
  var q q' : Qid .
  var f : Map{Qid, NatTerm} .
 
 op diff : Nat Nat -> Nat . *** unsafe difference on naturals
 eq diff(n1 + x, x) = n1 .
 eq diff(n1, n2) = n1 - n2 .
 
  
 op subst : NatTerm Map{Qid, NatTerm} -> NatTerm .
 *** substitute in a nat term a qid with another nat term
 eq subst(nt, empty) = nt .
 eq subst(natAsTerm n, f) = natAsTerm n .
 eq subst(qidAsTerm q, f) = if f[q] == undefined then qidAsTerm q else f[q] fi  .
 eq subst(nt1 + nt2, f) = subst(nt1, f) + subst(nt2, f) .
 eq subst(nt1 - nt2, f) = subst(nt1, f) - subst(nt2, f) .
 eq subst(fun q' nt1, f) = fun q' subst(nt1, f) .
 
 *** properties of the ops on nat terms, the expected ones
 eq (nt + natAsTerm x) + (natAsTerm y) = nt + (natAsTerm (x + y)) .
 ceq (nt + natAsTerm x) - (natAsTerm y) = nt + natAsTerm (x - y) if y <= x .
 ceq (nt + natAsTerm x) - natAsTerm y = nt - natAsTerm  (y - x) if x < y .
 eq nt + natAsTerm 0 = nt .
 eq (nt - natAsTerm x) - natAsTerm y = nt - natAsTerm (x + y) .
 ceq (nt - natAsTerm  x) + natAsTerm  y = nt - natAsTerm  (x - y) if y <= x .
 ceq (nt - natAsTerm x) + natAsTerm y = nt -  natAsTerm (y - x) if x < y .

 eq (nt + natAsTerm 1) - natAsTerm 1 = nt .
 
 op subst : BoolTerm Map{Qid, NatTerm} -> BoolTerm .
 *** substitute a var with a nat term in a bool term
 eq subst(bt, empty) = bt .
 eq subst(nt1 =T= nt2, f) = subst(nt1, f) =T= subst(nt2, f) .
 eq subst(nt1 <T nt2, f) = subst(nt1, f) <T subst(nt2, f) .
 eq subst(nt1 <=T nt2, f) = subst(nt1, f) <=T subst(nt2, f) .
 eq subst(neg bt, f) = neg subst(bt, f) .
 eq subst(apply q' nt1, f) = apply q' subst(nt1, f) .
 eq subst(bt conj bt', f) = (subst(bt, f)) conj (subst(bt', f)) .
 eq subst(bt disj bt', f) = (subst(bt, f)) disj (subst(bt', f)) .
 
 op extendWithAssums__ : Set{BoolTerm} Map{Qid, NatTerm} -> Map{Qid, NatTerm} .
 *** TODO: check if this is the best way to deal with these things
 *** perhaps values instead of identifiers when doing induction?
 *** TODO: comment back in, find a different solution?
 *** eq extendWithAssums (A, (qidAsTerm q =T= t), (t =T= natAsTerm n)) f = 
 ***   extendWithAssums A insert(q, natAsTerm n, f) .
 eq extendWithAssums (A, (qidAsTerm q =T= t)) f = 
    extendWithAssums A insert(q, t, f) .
 eq extendWithAssums A f = f [owise] .
 
 op evalBoolTerm : BoolTerm Set{BoolTerm} Map{Qid, NatTerm} -> Bool . 
 *** evaluation w.r.t. a set of assumptions 
 *** and a valuation function
 eq evalBoolTerm(bt, A, f) = evalBoolTermAux(bt, expandIneq A empty, f) .
 
 op expandIneq__ : Set{BoolTerm} Set{BoolTerm} -> Set{BoolTerm} .
 eq expandIneq (A, nt <T t + natAsTerm 2) A' = 
    expandIneq A (A', nt <T t + natAsTerm 2, nt <=T t + natAsTerm 1) .
 eq expandIneq (A, nt <T t + natAsTerm 3) A' = 
    expandIneq A (A', nt <T t + natAsTerm 3, nt <=T t + natAsTerm 2) .
 eq expandIneq A A' = union(A, A') [owise] .
  
 op evalBoolTermAux : BoolTerm Set{BoolTerm} Map{Qid, NatTerm} -> Bool .  
   
 ceq evalBoolTermAux(bt, A, f) = true if bt in A .
 ceq evalBoolTermAux(bt, A, f) = false if (neg bt) in A .
 
 eq evalBoolTermAux(bt conj bt', A, f) =
    evalBoolTermAux(bt, A, f) and evalBoolTermAux(bt', A, f) .
 eq evalBoolTermAux(bt disj bt', A, f) =
    evalBoolTermAux(bt, A, f) or evalBoolTermAux(bt', A, f) .   
 
 ceq evalBoolTermAux(neg bt, A, f) = false if bt in A .
 ceq evalBoolTermAux(neg bt, A, f) = true if neg bt in A .
 ceq evalBoolTermAux(neg (t =T= natAsTerm 0), A, f) = true if evalBoolTermAux(natAsTerm 0 <T evalTerm t f, A, f) .
 ceq evalBoolTermAux(neg (t1 =T= t2), A, f) = false 
     if evalTerm t1 f == evalTerm t2 f .
 ceq evalBoolTermAux(neg (t1 =T= t2), A, f) = true 
     if diffEvalValues (evalTerm t1 f) (evalTerm t2 f) .
 eq evalBoolTermAux(neg (t1 =T= t2), (A, t1 <T t2), f) = true .  
 eq evalBoolTermAux(neg (t1 =T= t2), (A, t3 <T t2, t3 =T= t1), f) = true .
 eq evalBoolTermAux(neg (t1 =T= t2), (A, neg (t3 =T= t2), t3 =T= t1), f) = true .
   
op diffEvalValues__ : NatTerm NatTerm -> Bool .
eq diffEvalValues (natAsTerm n1) (natAsTerm n2) = n1 =/= n2 .
eq diffEvalValues nt1 nt2 = false [owise] .

 ceq evalBoolTermAux(natAsTerm 0 =T= t + natAsTerm n1, A, f) = false if n1 =/= 0 .
 eq evalBoolTermAux(t1 =T= t2, A, f) = evalTerm t1 f == evalTerm t2 f .
 *** eq evalBoolTermAux(n1 =T= n2, A, f) = n1 == n2 .
 ceq evalBoolTermAux(t1 =T= t2, ((t1 =T= t3), (t4 =T= t2), A), f ) = true 
  if evalBoolTermAux(evalTerm t3 f =T= evalTerm t4 f, A, f) .  
 
 eq evalBoolTerm(t1 <T t2, (A, t1 <T t3, t3 <T t2), f) = true .
 eq evalBoolTermAux(natAsTerm n1 <T natAsTerm n2, A, f) = n1 < n2 .
 eq evalBoolTermAux(t + natAsTerm n1 <T t + natAsTerm n2, A, f) = n1 < n2 .
 *** TODO: these two axioms seem wrong i < 4 if i <= 5 is definitely not true!
 *** are they in use? 
 *** ceq evalBoolTermAux(t <T t1, A, f) = true if (t <=T t1 + natAsTerm 1) in A .
 *** ceq evalBoolTermAux(t <T t1, A, f) = true if (t <=T t1 + natAsTerm 2) in A .
 eq evalBoolTermAux(t - natAsTerm n <T t, A, f) = true .
 ceq evalBoolTermAux(t - natAsTerm n <T t2, A, f) = true if evalBoolTermAux( t <=T t2, A, f) .
 eq evalBoolTermAux(natAsTerm n1 <T natAsTerm n2, A, f) = n1 < n2 . 
 ceq evalBoolTermAux(t1 <T t2 + natAsTerm n1, A, f) = true 
   if n1 =/= 0 /\ evalBoolTermAux(t1 <T t2, A, f) .
 ceq evalBoolTermAux(t1 <T t4, (t1 <T t2, t3 <T t4, A), f) = true 
     if evalBoolTermAux(evalTerm t2 f <=T evalTerm t3 f, A, f) .
 eq evalBoolTermAux(t <T t, A, f) = false .
 ceq evalBoolTermAux(natAsTerm 0 <T t + natAsTerm n1, A, f) = true if n1 > 0 .
 eq evalBoolTermAux(t <T t + natAsTerm n1, A, f) = true .
 eq evalBoolTermAux(t1 <T t2, (A, t1 <=T t3, t3 + natAsTerm 1 <=T t2), f) = true .
 
  ceq evalBoolTermAux(t1 <T t2, (A, t1 <T t3), f) = true
     if evalBoolTermAux(t3 <T t2, (A, t1 <T t3), f) .

 eq evalBoolTermAux(t <T t + natAsTerm n, A, f) = n > 0 . 
 
 *** TODO: these things should be generalized
 eq evalBoolTermAux(t <T t1 + natAsTerm 1, 
                     (A, t <T t1 + natAsTerm 2, neg (t =T= t1 + natAsTerm 1)), f ) = true .
 eq evalBoolTermAux(t - natAsTerm 1 <T t1 + natAsTerm 1, 
                    (A, t <T t1 + natAsTerm 3, neg (t =T= t1 + natAsTerm 2)), f ) = true .

 *** new 
***  ceq evalBoolTermAux(t <T t1 + natAsTerm 1, 
***                      bla (A, t <T t1 + natAsTerm 2, 
***                      apply q1 t, apply q2 (t1 + natAsTerm 1) ), f ) = true 
***   if ((apply q1 (t1 + natAsTerm 1)) conj (apply q2 (t1 + natAsTerm 1))) == falseBT .                   .

 eq evalBoolTermAux(t - natAsTerm n <T t1, (A, t <T t1), f) = true .
                    
 eq (t + natAsTerm 1) - natAsTerm 1 = t .
 eq (t + natAsTerm 2) - natAsTerm 1 = t + natAsTerm 1 .
 ceq (t - natAsTerm n1) + natAsTerm n2 =  t + natAsTerm (diff(n2, n1)) if n1 <= n2 .
 
 
 eq evalBoolTermAux(natAsTerm 0 <=T t, A, f) = true .
 eq evalBoolTermAux(t <=T t, A, f) = true . 
 eq evalBoolTermAux(natAsTerm n1 <=T natAsTerm (n1 + n2), A, f) = true . *** this is new!
 ceq evalBoolTermAux(t1 <=T t2 + natAsTerm n2, A, f) = true if t1 <=T natAsTerm n2 in A .
 eq evalBoolTermAux(t + natAsTerm n1 <=T t + natAsTerm n2, A, f) = n1 <= n2 .
 eq evalBoolTermAux(natAsTerm n1 <=T natAsTerm n2, A, f) = n1 <= n2 .
 ceq evalBoolTermAux(t1 - t2 <=T t, A, f) = true if evalBoolTermAux(t1 <=T t, A, f) .
 ceq evalBoolTermAux(t1 <=T t2, A, f) = true if evalBoolTermAux(t1 <T t2, A, f) .
 ceq evalBoolTermAux(t1 <=T t2, A, f) = true if evalBoolTermAux(t1 =T= t2, A, f) .
 ceq evalBoolTermAux(t1 <=T t4, (t1 <=T t2, t3 <=T t4, A), f) = true 
     if evalBoolTermAux(evalTerm t2 f <=T evalTerm t3 f, A, f) .
 ceq evalBoolTermAux(t1 <=T t2, A, f) = true if t1 + natAsTerm 1 <=T t2 in A .    
      
 op evalTerm__ : NatTerm Map{Qid, NatTerm} -> NatTerm .
 eq evalTerm natAsTerm n1 f = natAsTerm n1 .
 eq evalTerm qidAsTerm q f = if f[q] == undefined then qidAsTerm q else f[q] fi .
 eq evalTerm (t1 + natAsTerm 0) f = evalTerm t1 f .
 *** ceq evalTerm (t1 + t2) f = (evalTerm t1 f) + (evalTerm t2 f) 
 *** if (evalTerm t1 f) : Nat /\ (evalTerm t2 f) : Nat . 
 eq evalTerm (t1 + t2) f = (evalTerm t1 f) + (evalTerm t2 f) [owise] .
 *** ceq evalTerm (t1 - t2) f = (evalTerm t1 f) - (evalTerm t2 f) 
 *** if (evalTerm t1 f) : Nat /\ (evalTerm t2 f) : Nat .
 eq evalTerm (t1 - t2) f = (evalTerm t1 f) - (evalTerm t2 f) [owise] . 
 *** evaluation is not defined for fun
 *** we will define that for each function symbol
 
 *** make sure that nats are added/diffed
 eq (natAsTerm n1) + (natAsTerm n2) = natAsTerm (n1 + n2) .
 ceq (natAsTerm n1) - (natAsTerm n2) = natAsTerm (n1 - n2) if n2 <= n1 .
 
endfm

fmod BOOL-TERM-ENTAILS is
 pr NAT-TERM-EVAL .
 
 *** entails as much as possible from a bool term
 op simplify___ : Set{BoolTerm} BoolTerm Map{Qid,NatTerm} -> BoolTerm .
 eq simplify  A bt f = addConj (evalBoolSet (simplifyAux A bt f)) .
 
 op evalBoolSet_ : Set{BoolTerm} -> Set{BoolTerm} .
 eq evalBoolSet (A, falseBT) = falseBT .
 eq evalBoolSet (A, trueBT) = evalBoolSet A .
 eq evalBoolSet A = A [owise] .
 
 op addConj_ : Set{BoolTerm} -> BoolTerm .
 eq addConj bt = bt .
 eq addConj (A, bt) = bt conj (addConj A) .

 op simplifyAux___ : Set{BoolTerm} BoolTerm Map{Qid,NatTerm} -> Set{BoolTerm} .
 ceq simplifyAux A bt f = trueBT if A |= bt with f .
 ceq simplifyAux A bt f = falseBT if A |= neg bt with f .
 eq simplifyAux (A, bt) (bt disj bt') f = trueBT .
 ceq simplifyAux (A, bt) (bt' disj bt'') f =
     simplifyAux (A, bt) bt'' f
 if simplifyAux (A, bt) bt' f == falseBT .
 eq simplifyAux (A, bt) (bt conj bt') f = 
    simplifyAux (A, bt) bt' f .
 eq simplifyAux (A, nt1 <=T nt2) (nt2 <=T nt1) f =
    nt1 =T= nt2 . 
 eq simplifyAux A ((bt conj bt') disj (bt conj bt'')) f 
  = bt conj (bt' disj bt'') .        
 eq simplifyAux A bt f = bt [owise] .   
 *** TODO: more rules?
  
 op _|=_with_ : Set{BoolTerm} BoolTerm Map{Qid,NatTerm} -> Bool .
 *** check whether a set of assumptions 
 *** entails a predication with a valuation map
 
 var A : Set{BoolTerm} .
 var nt1 nt2 nt3 : NatTerm .
 var n1 n2 : Nat . 
 var q1 q2 : Qid .
 var f : Map{Qid,NatTerm} .
 var bt bt' bt'' : BoolTerm .
 
 eq (A, bt) |= bt with f = true .
 eq (A, falseBT) |= bt with f = true .

 ceq A |= apply q1 nt1 with f = true 
  if (apply q1 (evalTerm nt1 (extendWithAssums A f))) in A .
  
 eq A |= nt1 =T= nt1 with f = true . 
  
 ceq A |= nt1 =T= nt2 with f = true 
   if evalBoolTerm(evalTerm nt1 (extendWithAssums A f) =T= evalTerm nt2 (extendWithAssums A f),
                   A , f) .                  
 eq (A, nt1 =T= nt3, nt3 =T= nt2) |= nt1 =T= nt2 with f = true .                   
 eq A |= nt1 =T= nt2 with f = false [owise] .
 
  eq (A, nt1 =T= nt3, nt3 <T nt2) |= nt1 <T nt2 with f = true . 
   ceq (A, apply q1 nt1, apply q2 (nt2 + natAsTerm 1), 
        nt1 <T nt2 + natAsTerm 2 ) |= (nt1 <T nt2 + natAsTerm 1) with f = true
  if ((apply q1 (nt2 + natAsTerm 1)) conj (apply q2 (nt2 + natAsTerm 1))) == falseBT .
 ceq A |= nt1 <T nt2 with f = true 
  if evalBoolTerm(evalTerm nt1 (extendWithAssums A f) <T evalTerm nt2 (extendWithAssums A f),
                  A, f) .                                                  
 eq A |= nt1 <T nt2 with f = false [owise] .
 
 eq A |= nt1 <=T nt1 with f = true .
 
 ceq A |= nt1 <=T nt2 with f = true 
  if evalBoolTerm(evalTerm nt1 (extendWithAssums A f) <=T evalTerm nt2 (extendWithAssums A f),
                  A, f) .
 eq A |= nt1 <=T nt2 with f = false [owise] .
 
 *** actually we also want to check f(bt)!
 ceq A |= neg bt with f = true 
  if evalBoolTerm(subst(neg bt, extendWithAssums A f), A, f) .
 eq A |= neg bt with f = false [owise] . 
 
 eq A |= bt conj bt' with f = 
    A |= bt with f and A |= bt' with f .
    
 eq (A, bt conj bt') |= bt with f = true .
 eq (A, bt' conj bt'') |= bt with f =
    (A, bt', bt'') |= bt with f .
 
 eq A |= bt disj bt' with f = 
    A |= bt with f or A |= bt' with f . 
    
 eq (A, bt' disj bt'') |= bt with f = 
    (A, bt') |= bt with f
    or
    (A, bt'') |= bt with f .
 
endfm

fmod BOUNDS is
 protecting BOOL-TERM-ENTAILS .
 
 *** bounds for families

 sort Bounds .
 op bound_ : NatTerm -> Bounds [ctor] .       *** all values from 0 to bound-1
 op fixedBound_ : NatTerm -> Bounds [ctor] .  *** always the specified value
 op dependentBound_ : Qid -> Bounds [ctor] .  *** name F of a function
                                              *** ranges from 0 to F(x)-1 
                                              *** where x is the argument provided 
                                              *** for the previous bound
  *** takes as argument the name of the function giving the bound for each value#
  
 var F : Qid .
 var bd : Bounds .
 var nt : NatTerm .
 
 op isDepBound_ : Bounds -> Bool .
 eq isDepBound (dependentBound F) = true .
 eq isDepBound bd = false [owise] . 
 
endfm

view Bounds from TRIV to BOUNDS is
 sort Elt to Bounds .
endv

fmod CHANNEL-NAME is
*** protecting QID .
 protecting LIST{NatTerm} .
 protecting LIST{Bounds} .
 
 sort NameWithScripts .
 subsort Qid < NameWithScripts .
 op _^^_.._ : Qid Qid Qid -> NameWithScripts [ctor prec 3] .  
   

 var ns : NameWithScripts .
 var aQid sup1 sub1 sup2 sub2 : Qid .

 sort ChannelName .
 subsort NameWithScripts < ChannelName .
 op _[_] : NameWithScripts List{NatTerm} -> ChannelName [ctor] .
 
 sort FamilyName .
 op _[_] : ChannelName List{Bounds} -> FamilyName [ctor] .
  
 var q q1 q2 : Qid .
 var ns2 : NameWithScripts .
 var x : Nat .
 var cn : ChannelName .
 var nlist : List{NatTerm} .
 
 op length : ChannelName -> Nat .
 *** how many indices are in a name
 eq length(ns) = 0 .
 eq length(ns[nlist]) = size(nlist) .
 
 op qidOfName : ChannelName -> NameWithScripts .
 eq qidOfName(ns) = ns .
 eq qidOfName(ns[nlist]) = ns .
 
 op matchesQid__ : ChannelName NameWithScripts -> Bool .
 *** a channel name matches a name
 *** if it is does not have indices and they are equal
 *** or it is a name with indices and the name without indices is equal to it
 eq matchesQid cn ns2 = qidOfName(cn) == ns2 .
 
 *** helper: replicate a name n times, and get a list of nat terms
  
 op replicate__ : Nat Qid -> List{NatTerm} .
 eq replicate 0 q = nil .
 eq replicate s(x) q = (qidAsTerm q) (replicate x q) . 
 
endfm

fmod CNAME-BOUND is
 
 protecting CHANNEL-NAME .
 
 *** we need these to accomodate families
 
 sort CNameBound .
 op fam_ : FamilyName -> CNameBound [ctor] .
 op chn_ : ChannelName -> CNameBound [ctor] .

endfm

view CName from TRIV to CHANNEL-NAME is
 sort Elt to ChannelName .
endv

view CNameBound from TRIV to CNAME-BOUND is
 sort Elt to CNameBound .
endv

fmod CNAMEBOUND-SET is
 protecting SET{CNameBound} .
 protecting SET{BoolTerm} .
 pr SET{NatTerm} .
 pr BOOL-TERM-ENTAILS .
 
 *** custom membership test
 *** check whether the index is within bounds
 op isElemB : ChannelName Set{CNameBound} Set{BoolTerm} -> Bool .
 eq isElemB(cn, S, A) =
    isElemBAux(cn, mergeSplitFams S, A) .
 
 var q : NameWithScripts .
 var nt nt1 nt2 nt3 b1 b2 b3 : NatTerm .
 var S S1 S2 : Set{CNameBound} .
 var A : Set{BoolTerm} .
 var B : Set{NatTerm} .
 var F : Qid .
 var bd1 bd2 bd3 : Bounds .
 var bdlist : List{Bounds} .
 var cn : ChannelName .
 var fn : FamilyName .
 var n : Nat .
 
 *** individual check, we may need previous term for dependent bounds 
 *** so we send it in a set
 op inBounds____ : NatTerm Bounds Set{BoolTerm} Set{NatTerm} -> Bool .
 eq inBounds nt1 (bound b1) A B =  A |= nt1 <T b1 with empty .
 eq inBounds nt1 (fixedBound b1) A B =  A |= nt1 =T= b1 with empty .
 eq inBounds nt1 (dependentBound F) A nt2 =  A |= nt1 <T fun F nt2 with empty .
 
 *** helper to avoid case distinctions
 op getBound_ : Bounds -> Set{NatTerm} .
 eq getBound (bound nt) = nt .
 eq getBound (fixedBound nt) = nt .
 eq getBound (dependentBound F) = empty .
 
 op mergeSplitFams_ : Set{CNameBound} -> Set {CNameBound} .
 *** for splits
 *** !!! also merge C[N+1 'B] with fixedBound N+1 bound B
 eq mergeSplitFams
    ( S, fam (q [bound (nt + natAsTerm 1)]), chn (q[nt + natAsTerm 1]) )
    = mergeSplitFams(S, fam (q [bound (nt + natAsTerm 2)]))
 .
 eq mergeSplitFams 
     (S, fam ( q[(bound (nt + natAsTerm 1)) bd2]), 
         fam ( q[(fixedBound (nt + natAsTerm 1)) bd2]) 
     ) = mergeSplitFams
     (S, fam ( q[(bound (nt + natAsTerm 2)) bd2]))
 .
 eq mergeSplitFams 
     (S, fam ( q[(bound (nt + natAsTerm 1)) (fixedBound nt2)]), 
         chn ( q[(nt + natAsTerm 1) nt2]) 
     ) = mergeSplitFams
     (S, fam ( q[(bound (nt + natAsTerm 2)) (fixedBound nt2)]))
 .    
 eq mergeSplitFams 
     (S, fam ( q[bd1 (bound (nt + natAsTerm 1)) bd2]), 
         fam ( q[bd1 (fixedBound (nt + natAsTerm 1)) bd2]) 
     ) = mergeSplitFams
     (S, fam ( q[bd1 (bound (nt + natAsTerm 2)) bd2]))
 .
 *** new
 eq mergeSplitFams 
     (S, fam ( q[(bound (nt + natAsTerm 1)) bd1 bd2 ]), 
         fam ( q[(fixedBound (nt + natAsTerm 1)) bd1 bd2]) 
     ) = mergeSplitFams
     (S, fam ( q[(bound (nt + natAsTerm 2)) bd1 bd2]))
 .  

 eq mergeSplitFams S = S [owise] .       

 op isElemBAux : ChannelName Set{CNameBound} Set{BoolTerm} -> Bool .
 
 eq isElemBAux(q, S, A) = (chn q) in S .
 
 eq isElemBAux(q[nt1], (S, chn (q[nt1]) ), A) = true .
 eq isElemBAux(q[nt1], (S, fam (q[bound b1]) ), A) = inBounds nt1 (bound b1) A empty . 
 eq isElemBAux(q[nt1], S, A) = false [owise] .
 
 eq isElemBAux(q[nt1 nt2], (S, chn (q[nt1 nt2]) ), A) = true .
 ceq isElemBAux(q[nt1 nt2], (S, fam (q[bd1 bd2])), A) = true
 if (inBounds nt1 bd1 A empty
     and
     inBounds nt2 bd2 A nt1
    )
 . 
 
 ceq isElemBAux(q[nt1 nt2], (S, fam (q[bd1 bd2])), A) =  
     isElemBAux(q[nt1 nt2], S, A)
 if not 
    (inBounds nt1 bd1 A empty
     and
     inBounds nt2 bd2 A nt1
    )    
 .
   
 eq isElemBAux(q[nt1 nt2], S, A) = false [owise] .
 
 eq isElemBAux(q[nt1 nt2 nt3], (S, chn (q[nt1 nt2 nt3])), A) = true . 
 
 ceq isElemBAux(q[nt1 nt2 nt3], (S, fam (q[bd1 bd2 bd3])), A) = true
 if (inBounds nt1 bd1 A empty
     and
     inBounds nt2 bd2 A nt1
     and
     inBounds nt3 bd3 A nt2
    )
 . 
 
 ceq isElemBAux(q[nt1 nt2 nt3], (S, fam (q[bd1 bd2 bd3])), A) =  
     isElemBAux(q[nt1 nt2 nt3], S, A)
 if not 
    (inBounds nt1 bd1 A empty
     and
     inBounds nt2 bd2 A nt1
     and
     inBounds nt3 bd3 A nt2
    )  
 .
   
 eq isElemBAux(q[nt1 nt2 nt3], S, A) = false [owise] .
  
 op _equiv_ : Set{CNameBound} Set{CNameBound} -> Bool [comm] .
 eq S equiv S = true .
 eq empty equiv empty = true .
 eq (chn cn, S1) equiv (chn cn, S2) = S1 equiv S2 .
 eq (fam (cn[bdlist]), S1) equiv 
    (fam (cn[bdlist]), S2) =
    S1 equiv S2 .
 eq (fam (cn[(bound (nt + natAsTerm 2)) bd2]), S1) equiv 
    (fam (cn[(bound (nt + natAsTerm 1)) bd2]),
     fam (cn[(fixedBound (nt + natAsTerm 1)) bd2]),
     S2) =
    S1 equiv S2 .   
 eq (fam (cn[bd1 (bound (nt + natAsTerm 2)) bd2]), S1) equiv 
    (fam (cn[bd1 (bound (nt + natAsTerm 1)) bd2]),
     fam (cn[bd1 (fixedBound (nt + natAsTerm 1)) bd2]),
     S2) =
    S1 equiv S2 . 
 eq (fam (cn[(bound (nt + natAsTerm 2)) bd1 bd2]), S1) equiv 
    (fam (cn[(bound (nt + natAsTerm 1)) bd1 bd2]),
     fam (cn[(fixedBound (nt + natAsTerm 1)) bd1 bd2]),
     S2) =
    S1 equiv S2 .   
 eq S1 equiv S2 = false [owise] .
 
 
endfm


fmod CHANNEL is
 protecting QID .
 protecting TYPES .
 protecting CNAMEBOUND-SET .

 *** an embedding is an injective type-preserving mapping between channel contexts
 *** phi : Delta1 to Delta2 means Delta2 is the smaller context
 *** and Delta1 the one that embeds Delta2
 
 sort CNameMap .
 op emptyCNameMap : -> CNameMap [ctor] .
 op _to_ : ChannelName ChannelName -> CNameMap [ctor] .
 op _;_ : CNameMap CNameMap -> CNameMap [assoc comm id: emptyCNameMap] .
 
 sort IPDLEmbedding .
 op _from_to_is_ : Qid ChannelContext ChannelContext CNameMap -> IPDLEmbedding [ctor] .

 op getEmbedName  : IPDLEmbedding -> Qid .
 eq getEmbedName (f from Delta1 to Delta2 is cnmap) = f .

 op getEmbedTgt : IPDLEmbedding -> ChannelContext .
 eq getEmbedTgt (f from Delta1 to Delta2 is cnmap) = Delta2 .
 
 *** application
 
 var cnmap : CNameMap .
 
 *** find with default unchanged
 op _@@_ : IPDLEmbedding ChannelName -> ChannelName . 
 eq (f from Delta1 to Delta2 is (cnmap ; cn1 to cn2)) @@ cn1 = cn2 .
 eq (f from Delta1 to Delta2 is cnmap) @@ cn1 = cn1 [owise] .
 
 op _inEmb_ : ChannelName IPDLEmbedding -> Bool .  
 eq cn1 inEmb (f from Delta1 to Delta2 is (cnmap ; cn1 to cn2)) = true .
 eq cn1 inEmb (f from Delta1 to Delta2 is cnmap) = false [owise] . 

 
 *** typed bounded channel names
 
 sort TypedChannel .
 op _::_ : CNameBound IPDLType -> TypedChannel [ctor format(b o r o)] .

 
 *** a channel context is a commutative list of them
 sort ChannelContext .
 subsort TypedChannel < ChannelContext .
 op emptyChannelCtx : -> ChannelContext [ctor].
 op __ : ChannelContext ChannelContext -> ChannelContext 
         [ctor assoc comm id: emptyChannelCtx format(d n d)] .

 vars ns ns1 ns2 : NameWithScripts .
 vars q Q Q1 Q2 f : Qid .
 var T T1 T2 : IPDLType .
 vars Delta1 Delta2 Delta : ChannelContext .
 var I : Set{CNameBound} .
 var A : Set{BoolTerm} .
 var cn cn1 cn2 : ChannelName .
 var nlist nlist1 nlist2 : List{NatTerm} .
 var nt nt1 nt2 nt3 nt' nt'' : NatTerm .
 var x y n : Nat .
 var bn : CNameBound .
 var b b1 b2 b3 : NatTerm .
 var bd bd1 bd2 bd3 bd4 bd5 bd6 : Bounds .
 var bdlist bdlist1 : List{Bounds} .
 var tc : TypedChannel . 
  
 *** this function checks whether a bounded name fits the context and the assumptions
 *** no type, we will use it for inputs/outputs
 op occurs___ : CNameBound ChannelContext Set{BoolTerm} -> Bool .
 eq occurs bn emptyChannelCtx A = false .


 eq occurs (chn ns ) ( ((chn ns) :: T)  Delta) A = true .
 eq occurs (chn ns) Delta A = false [owise] .

 eq occurs (chn (ns[nt])) ( ((chn (ns[nt])) :: T)  Delta) A = true .
 eq occurs (chn (ns[nt])) ( ((fam (ns[bd])) :: T) Delta) A = 
    (inBounds nt bd A empty)
    or
    occurs (chn (ns[nt])) Delta A .
 eq occurs (chn (ns[nt])) Delta A = false [owise] .
 
 eq occurs (chn (ns[nt1 nt2])) ( (chn (ns[nt1 nt2]):: T) Delta ) A = true .
 eq occurs (chn (ns[nt1 nt2])) ( (fam (ns[bd1 bd2]):: T) Delta ) A =
    (inBounds nt1 bd1 A empty and inBounds nt2 bd2 A nt1)
    or 
    occurs (chn (ns[nt1 nt2])) Delta A .
 eq occurs (chn (ns[nt1 nt2])) Delta  A = false [owise] .
 
 eq occurs (chn (ns[nt1 nt2 nt3])) ( (chn (ns[nt1 nt2 nt3]):: T) Delta ) A = true .
 eq occurs (chn (ns[nt1 nt2 nt3])) ( (fam (ns[bd1 bd2 bd3]):: T) Delta ) A =
    (inBounds nt1 bd1 A empty and 
     inBounds nt2 bd2 A empty and
     inBounds nt3 bd3 A nt2
     )
    or 
    occurs (chn (ns[nt1 nt2 nt3])) Delta A .
 eq occurs (chn (ns[nt1 nt2 nt3])) Delta  A = false [owise] .
   
 eq occurs (fam (ns[bdlist])) ( ((fam (ns[bdlist])) :: T) Delta ) A = true .  
 eq occurs (fam (ns[bdlist])) Delta A = false [owise] . 
 *** should we add compatibility between bounds, if we don't change Delta?
    
 

 ***( similars need to be added if we want to allow splitting but working with original Delta!

 ceq occurs (ns @ nt) ( (ns @ bd :: T) Delta) A = true
     if inBounds nt bd A empty .
 ceq occurs (ns @ (nt1 nt2)) ( (ns @ (bd1 bd2) :: T) Delta) A = true
     if inBounds nt1 bd1 A empty /\ inBounds nt2 bd2 A nt1 .
 ceq occurs (ns @ (nt1 nt2 nt3)) ( (ns @ (bd1 bd2 bd3) :: T) Delta) A = true
     if inBounds nt1 bd1 A empty /\ inBounds nt2 bd2 A empty /\ inBounds nt3 bd3 A nt2 .    
 
 )   
 
 *** checks that all cnamebounds in a set occur in Delta
 op validChanSet___ : Set{CNameBound} ChannelContext Set{BoolTerm} -> Bool .
 eq validChanSet empty Delta A = true .
 ceq validChanSet (bn, I) Delta A = false if not occurs bn Delta A .
 ceq validChanSet (bn, I) Delta A = validChanSet I Delta A if occurs bn Delta A .
 
 op validChannelCtx__ : ChannelContext Set{BoolTerm} -> Bool .
 eq validChannelCtx emptyChannelCtx A = true .
 ceq validChannelCtx ((chn cn :: T) Delta1) A = false 
  if occurs (chn cn) Delta1 A .
 ceq validChannelCtx ((chn cn :: T) Delta1) A = validChannelCtx Delta1 A 
  if not occurs (chn cn) Delta1 A . 
 ceq validChannelCtx ((fam (cn[bdlist]) :: T) Delta1) A = false 
  if occurs (fam (cn[bdlist]) ) Delta1 A . 
 ceq validChannelCtx ((fam (cn[bdlist]) :: T) Delta1) A = validChannelCtx Delta1 A 
  if not occurs (fam (cn[bdlist]) ) Delta1 A .  


         
 *** unsafe type lookup function!    
 op typeInCtx : CNameBound Set{BoolTerm} ChannelContext -> IPDLType .
 eq typeInCtx(chn ns , A, Delta (chn ns  :: T)) = T . 
 eq typeInCtx(chn (ns[nlist]) , A, Delta (chn (ns[nlist])   :: T)) = T . 
 eq typeInCtx(chn (ns[nlist]) , A, Delta (fam (ns[bdlist])  :: T)) = T .
 eq typeInCtx(fam (ns[bdlist]), A, Delta (fam (ns[bdlist1])  :: T)) = T .
 *** since we assume that Delta does not have two occurences of ns with different types
 *** any match will do

 *** this is the typed version of occurs, we will need it for Delta
 *** occurs checks for bounds, elem does not
 *** should we change?
 *** or should we allow the check to go through without knowing the bounds?
 op elem____ : CNameBound IPDLType ChannelContext Set{BoolTerm} -> Bool .
 eq elem (chn cn) T emptyChannelCtx A = false .
 eq elem (chn cn) T ((chn cn :: T) Delta) A = true .
 eq elem (chn (ns[nt])) T ((fam (ns[bd]) :: T) Delta) A = true .
 eq elem (chn (ns[nt1 nt2])) T ((fam (ns[bd1 bd2]) :: T) Delta) A = true .
 eq elem (chn (ns[nt1 nt2 nt3])) T ((fam (ns[bd1 bd2 bd3]) :: T) Delta) A = true .
 eq elem (chn cn) T Delta A = false [owise] .
 
 eq elem (fam (ns[bdlist])) T emptyChannelCtx A = false .
 eq elem (fam (ns[bdlist])) T ((fam (ns[bdlist]) :: T) Delta) A = true .
 eq elem (fam (ns[bdlist])) T Delta A = false [owise] .
 
 
 op removeEntry__ : TypedChannel ChannelContext -> ChannelContext .
 eq removeEntry tc (Delta tc) = Delta .
 eq removeEntry tc Delta = Delta [owise] .
 
 op union__ : ChannelContext ChannelContext -> ChannelContext [comm] .
 eq union Delta1 emptyChannelCtx = Delta1 .
 eq union (Delta1 tc) (Delta2 tc) = (union Delta1 Delta2) tc .
 eq union Delta1 Delta2 = Delta1 Delta2 [owise] .
   
 op diff__ : ChannelContext ChannelContext -> ChannelContext .
 eq diff emptyChannelCtx Delta1 = emptyChannelCtx .
 eq diff Delta1 emptyChannelCtx = Delta1 .
 eq diff (Delta1 tc) (Delta2 tc) = diff Delta1 Delta2 .
 eq diff (Delta1 tc) Delta2 = tc (diff Delta1 Delta2) [owise] . 
 
 op _equiv_ : ChannelContext ChannelContext -> Bool [comm] .
 eq Delta1 equiv Delta1 = true .
 eq emptyChannelCtx equiv emptyChannelCtx = true .
 eq ((chn cn :: T) Delta1) equiv ((chn cn :: T) Delta2) =
    Delta1 equiv Delta2 .
 eq ((fam (ns[bdlist]) :: T) Delta1) equiv ((fam (ns[bdlist]) :: T) Delta2) =
    Delta1 equiv Delta2 .
 eq (( ( fam (ns[bound (nt + natAsTerm 2)]) ) :: T ) Delta1) 
    equiv
    (( ( fam (ns[bound (nt + natAsTerm 1)]) ) :: T ) 
      (chn (ns[nt + natAsTerm 1]) :: T) Delta2)  =
    Delta1 equiv Delta2 . 
 eq ((fam (ns[(bound (nt + natAsTerm 2)) bd2]) :: T) Delta1) equiv 
    ((fam (ns[(bound (nt + natAsTerm 1)) bd2]) :: T) 
    (fam (ns[(fixedBound (nt + natAsTerm 1)) bd2]) :: T) Delta2) =
    Delta1 equiv Delta2 .   
 eq ((fam (ns[bd1 (bound (nt + natAsTerm 2)) bd2]) :: T) Delta1) equiv 
    ((fam (ns[bd1 (bound (nt + natAsTerm 1)) bd2]) :: T) 
     (fam (ns[bd1 (fixedBound (nt + natAsTerm 1)) bd2]) :: T) Delta2) =
    Delta1 equiv Delta2 . 
 eq ((fam (ns[(bound (nt + natAsTerm 2)) bd1 bd2]) :: T) Delta1) equiv 
    ((fam (ns[(bound (nt + natAsTerm 1)) bd1 bd2]) :: T) 
     (fam (ns[(fixedBound (nt + natAsTerm 1)) bd1 bd2]) :: T) Delta2) =
    Delta1 equiv Delta2 .    
 eq Delta1 equiv Delta2 = false [owise] .


 *** this only gives a result if we have a unique entry for the identifier we are looking for
 op unsafeLookup__ : ChannelContext Qid -> CNameBound .
 eq unsafeLookup (Delta (chn q :: T)) q = chn q .
 eq unsafeLookup ( Delta (fam (q[bdlist]) :: T) ) q = fam (q[bdlist]) .
 
endfm 

view IPDLEmbedding from TRIV to CHANNEL is
  sort Elt to IPDLEmbedding .
endv


fmod REACTION is
 protecting EXPRESSION .
 protecting IPDL-SUBST .
 protecting DISTRIBUTION .
 protecting CHANNEL-NAME .
 protecting BOOL-TERM-ENTAILS .
 protecting LIST{CNameBound} .

 sort Reaction .

 sort ReadReaction . 
 op read_ : ChannelName -> ReadReaction [ctor prec 15] .
 
 sort BindReaction . 
 
 *** bind-read reactions appear on first component of normal forms
 sort BindReadReaction .
 subsort BindReadReaction < BindReaction .
 op _:_<-_ : Qid IPDLType ReadReaction -> BindReadReaction [ctor prec 23] .
 op _<-_ : Qid ReadReaction -> BindReadReaction [ctor] . *** abbreviation notation
 op ~<-_ : ReadReaction -> BindReadReaction [ctor] . *** name not important 
 
 *** while these are in pre-normal forms
 sort UnrestrictedBindReaction . *** everything allowed
 subsort UnrestrictedBindReaction < BindReaction .
 op _:_<~_ : Qid IPDLType Reaction -> UnrestrictedBindReaction [ctor prec 23] .
 
 sort BRList .
 subsort BindReadReaction < BRList .
 op emptyBRList : -> BRList [ctor] .
 op __ : BRList BRList -> BRList [ctor assoc comm id: emptyBRList] .
  
 sort BindList .
 subsort BindReaction < BindList .
 subsort BRList < BindList .
 op __ : BindList BindList -> BindList [ctor assoc comm id: emptyBRList] .
 
 
 var br : BindReaction .
 var bl : BindList .
 var E : IPDLExpression .
 var cn : ChannelName .
 var v : Qid .

 *** normal form computation, partial for now
 op computeNF : Reaction -> Reaction .
 eq computeNF(R) = adjustNF(computeNFAux(R)) .

 op computeNFAux : Reaction -> Reaction .
 eq computeNFAux(return E) = nf(emptyBRList, return E) .
 eq computeNFAux(samp D) = nf(emptyBRList, samp D) . 
 eq computeNFAux(v : T <- read cn ; R2) = addReadToNF (v : T <- read cn) computeNFAux(R2) .
 eq computeNFAux(nf(bl, R)) = nf(bl, R) .
 eq computeNFAux(preNF(bl, R)) = preNF(bl, R) .
 eq computeNFAux(R) = R [owise] .
 
 op addReadToNF__ : ReadReaction Reaction -> Reaction .
 eq addReadToNF (v : T <- read cn) nf(BL, R) =
    nf ( (v : T <- read cn) BL, R) .
 eq addReadToNF (v : T <- read cn) R =
    nf ( (v : T <- read cn) , R) [owise] .   

 op adjustNF_ : Reaction -> Reaction .
 ceq adjustNF nf(BL, R) = nf(BL, R) 
     if R : BindFreeReaction . 
 eq adjustNF nf(BL, R) = preNF(BL, R) [owise] .
 eq adjustNF preNF(BL, R) = preNF(BL, R) .
 eq adjustNF R = preNF(emptyBRList, R) .
 
 op size : BindList -> Nat .
 eq size(emptyBRList) = 0 .
 eq size(br bl) = 1 + size(bl) .
 
 sort BindFreeReaction .
 subsort ReadReaction < BindFreeReaction .
 op return_ : IPDLExpression -> BindFreeReaction [ctor prec 15] .
 op samp_ : Distribution -> BindFreeReaction [ctor prec 15] .
 op if_then_else_ : IPDLExpression BindFreeReaction BindFreeReaction -> BindFreeReaction [ctor prec 21] .
  
 *** helpers: operations on lists
 vars ql ql' : List{NatTerm} .
 var q q' x y : NatTerm .

 op replace___ : NatTerm NatTerm List{NatTerm} -> List{NatTerm} .
 eq replace q q' nil = nil .
 eq replace q q' (x ql) = if x == q then q' ql
                                    else x (replace q q' ql) 
                          fi . 
 
 op del__ : NatTerm List{NatTerm} -> List{NatTerm} .
 eq del q ql = delAux q ql nil .
 
 op delAux___ : NatTerm NatTerm List{NatTerm} -> List{NatTerm} .
 eq delAux q nil ql' = reverse(ql') .
 eq delAux q (q ql) ql' = reverse(ql') ql .
 eq delAux q (q' ql) ql' = delAux q ql (q' ql') [owise] .
 
 var cnbl cnbl' : List{CNameBound} .
 var cnb cnb' : CNameBound .
 
 op del__ : CNameBound List{CNameBound} -> List{CNameBound} .
 eq del cnb cnbl = delAux cnb cnbl nil .
 
 op delAux___ : CNameBound CNameBound List{CNameBound} -> List{CNameBound} .
 eq delAux cnb nil cnbl' = reverse(cnbl') .
 eq delAux cnb (cnb cnbl) cnbl' = reverse(cnbl') cnbl .
 eq delAux cnb (cnb' cnbl) cnbl' = delAux cnb cnbl (cnb' cnbl') [owise] .
 
 op addBefore___ : NatTerm NatTerm List{NatTerm} -> List{NatTerm} .
 eq addBefore x y nil = x .
 eq addBefore x y (y ql) = x y ql .
 eq addBefore x y (q ql) = q (addBefore x y ql) [owise] .
 
 op addListBefore___ : List{NatTerm} NatTerm List{NatTerm} -> List{NatTerm} .
 eq addListBefore nil y ql = ql .
 eq addListBefore (x ql) y ql' = addListBefore ql y (addBefore x y ql') .
 
 sort NFReaction .
 op nf : BRList BindFreeReaction -> NFReaction [ctor] .
 
 sort PreNFReaction .
 op preNF : BindList Reaction -> PreNFReaction [ctor] .


 subsort ReadReaction < Reaction .
 *** subsort BindReaction < Reaction .
 subsort BindFreeReaction < Reaction .
 subsort NFReaction < Reaction .
 subsort PreNFReaction < Reaction .
 subsort UnrestrictedBindReaction < Reaction .
 op if_then_else_ : IPDLExpression Reaction Reaction -> Reaction [ctor prec 21] . 
 op _:_<-_;_ : Qid IPDLType Reaction Reaction -> Reaction [ctor prec 25] .
 op _<-_;_ : Qid Reaction Reaction -> Reaction [ctor] . *** abbreviation notation
     
 vars M M1 M2 V : IPDLExpression .
 var c : ChannelName .
 var w f d i : Qid .
 vars R R1 R2 : Reaction .
 var T : IPDLType .
 var n : Nat .
 var QL : List{NatTerm} . *** but we only want qids
 var BL : BRList .
 var D : Distribution .
 
 *** change representation, from normal form to core reaction
 op convertNF : NFReaction -> Reaction .
 eq convertNF(nf(emptyBRList, R)) = R .
 eq convertNF(nf((i : T <- R1 ) BL, R2)) = 
     i : T <- R1 ; convertNF(nf(BL, R2)) .
 
 *** check recursively whether samp occurs
 op isSampFree : Reaction -> Bool .
 eq isSampFree(return M) = true .
 eq isSampFree(samp D) = false .
 eq isSampFree(read c) = true .
 eq isSampFree(if M then R1 else R2) = isSampFree(R1) and isSampFree(R2) .
 eq isSampFree(i : T <- R1 ; R2) = isSampFree(R1) and isSampFree(R2) .
 eq isSampFree(nf(BL, R)) = isSampFree(R) .
 eq isSampFree(preNF(BL, R)) = isSampFree(R) .
 
 *** subst a variable with an expression in a reaction
 op _[_/_] : Reaction Qid IPDLExpression -> Reaction . 
 eq (return M) [w / V] = return (M [w := V]) .
 eq (samp (d < M >)) [w / V] = samp (d < M [w := V] >) .
 eq (read c) [w / V] = read c .
 eq (if M then R1 else R2) [w / V] = if M [w := V] then (R1 [w / V]) else (R2 [w / V]) .
 eq (i : T <- R1 ; R2) [w / V] = i : T <- (R1 [w / V]) ; (R2 [w / V]) .
 eq (nf(BL, R)) [w / V] = nf(BL, R [w / V]) .
 eq (preNF(BL, R)) [w / V] = preNF(BL, R [w / V]) . *** subst in BL too?

 var theta : IPDLSubst .

 op applySubst__ : Reaction IPDLSubst -> Reaction .
 eq applySubst R (i .> V) = R [i / V] .
 eq applySubst R emptyIPDLSubst = R .
 eq applySubst R ((i .> V) ; theta) = applySubst (R [i / V]) theta . 
 
 var lq : List{NatTerm} .
 var val : Map{Qid,NatTerm} .
 
 vars nt1 nt2 : NatTerm .
 var m n1 n2 : Nat .
 var ns : NameWithScripts .
 
 *** evaluate the vars in a channel name
 *** by a valuation map
 op evalCName__ : ChannelName Map{Qid,NatTerm} -> ChannelName .
 eq evalCName (ns [ lq ]) val = ns [ evalList(lq, val) ] .
 eq evalCName ns val = ns .
 
 *** same for lists of nat terms
 op evalList : List{NatTerm} Map{Qid,NatTerm} -> List{NatTerm} .
 eq evalList(nil, val) = nil .
 eq evalList(nt1 lq, val) = (eval(nt1, val)) (evalList(lq, val)) . 
 
 *** and for nat terms
 op eval : NatTerm Map{Qid,NatTerm} -> NatTerm .
 eq eval(natAsTerm n, val) = natAsTerm n .
 eq eval(fun i nt1, val) = fun i eval(nt1, val) .
 eq eval(qidAsTerm i, val) = if val[i] == undefined then qidAsTerm i else val[i] fi . *** eval with default
 eq eval(nt1 + nt2, val) = addEval eval(nt1, val) eval(nt2, val) . 

 op addEval__ : NatTerm NatTerm -> NatTerm .
 eq addEval (natAsTerm n1) (natAsTerm n2) = natAsTerm (n1 + n2) .
 eq addEval nt1 nt2 = nt1 + nt2 [owise] .

 eq eval(nt1 - nt2, val) = diffEval eval(nt1, val) eval(nt2, val)  .  
  
 op diffEval__ : NatTerm NatTerm -> NatTerm .
 eq diffEval (natAsTerm n1) (natAsTerm n2) = natAsTerm (diff(n1, n2)) .
 eq diffEval nt1 nt2 = nt1 - nt2 [owise] .

 *** replace vars in a reaction using a valuation
 op replaceVars : Reaction Map{Qid,NatTerm}  -> Reaction .
 eq replaceVars(return M, val) = return M .
 *** eq replaceVars(samp flip, val) = samp flip .
 eq replaceVars(samp (d < M >), val) = samp (d < M >) .
 eq replaceVars(read c, val) = read (evalCName c val) . 
 eq replaceVars(if M then R1 else R2, val) = 
      if M then replaceVars(R1, val) else replaceVars(R2, val) .
 eq replaceVars(i : T <- R1 ; R2, val) = 
      i : T <- replaceVars(R1, val); replaceVars(R2, val) .
 eq replaceVars(nf(BL, R), val) = nf(replaceVarsB(BL, val), replaceVars(R, val)) .
 
 var brr : BindReadReaction .
 
 *** same for bind list
 op replaceVarsB : BindList Map{Qid, NatTerm} -> Reaction .
 eq replaceVarsB(i : T <- R, val) = i : T <- replaceVars(R, val) .
 eq replaceVarsB(i : T <~ R, val) = i : T <~ replaceVars(R, val) .
 eq replaceVarsB(brr BL, val) = replaceVarsB(brr, val) replaceVarsB(BL, val) .
 eq replaceVarsB(emptyBRList, val) = emptyBRList .    
      
endfm

fmod REACTION-TYPING is
 protecting REACTION .
 protecting CHANNEL .
 protecting EXPRESSION-TYPING .
 protecting DISTRIBUTION-TYPING .
 protecting CNAMEBOUND-SET .
 
sort BoolWithError .
 subsort Bool < BoolWithError .
 op err_ : String -> BoolWithError [ctor] .
 
 sort TypeWithError .
 subsort IPDLType < TypeWithError .
 op typeErr_ : String -> TypeWithError [ctor] .
 
 *** the type of a reaction in the context given by
 *** a signature, a channel context, a variable context
 *** a set of inputs and a set of index assumptions
 op typeOf : Signature ChannelContext TypeContext 
             Set{CNameBound} Set{BoolTerm} Reaction -> TypeWithError .
 *** TODO: add error handling, if we fail we should know why!            

 var Sigma : Signature .
 var Gamma : TypeContext .
 var Delta : ChannelContext .
 vars R R1 R2 R3 : Reaction .
 vars T T1 T2 T3 : IPDLType .
 var M M1 M2 : IPDLExpression .
 var I : Set{CNameBound} . 
 var d i x q f : Qid .
 var ns : NameWithScripts .
 var c : ChannelName .
 var D : Distribution .
 var QL : List{NatTerm} .
 var BRL : BRList .
 var BL : BindList .
 var nlist nlist' : List{NatTerm} .
 var nt b nt1 nt2 nt3 b1 b2 b3 : NatTerm .
 var n : Nat .
 var A : Set{BoolTerm} .
 var bd bd1 bd2 bd3 : Bounds .
 var bdList : List{Bounds} .
 
 *** extend a var context with the vars in a bind list
 op addDeclarations__ : BindList TypeContext -> TypeContext .
 eq addDeclarations emptyBRList Gamma = Gamma .
 eq addDeclarations ((x : T <- R) BL) Gamma = addDeclarations BL (Gamma (x : T)) .
 eq addDeclarations ((x : T <~ R) BL) Gamma = addDeclarations BL (Gamma (x : T)) .
 
 *** a bind-read list is valid for a context 
 *** if the context contains the channels that are being read from
 *** with the right type
 op validForCtx : BRList ChannelContext Set{CNameBound} Set{BoolTerm} -> BoolWithError .
 eq validForCtx(emptyBRList, Delta, I, A) = true .
 
 eq validForCtx((x : T <- read ns) BRL, Delta (chn ns :: T), I, A) = 
    validForCtx(BRL, Delta, I, A) .

 
 eq validForCtx((x : T <- read (ns[nlist])) BRL, Delta (chn (ns[nlist]) :: T), I, A) =
    validForCtx(BRL, Delta, I, A) .
    
 eq validForCtx((x : T <- read (ns[nlist])) BRL, Delta (fam (ns[bdList]) :: T), I, A) =
    validForCtx(BRL, Delta (fam (ns[bdList]) :: T), I, A) 
    and 
    isElemB(ns[nlist], I, A) . 
    
 ceq validForCtx((x : T <- read (ns[nlist])) BRL, Delta (fam (ns[bdList]) :: T), I, A) =
    err ("invalid read for:" + string(x) + "in read:" + string(ns) )   
    if not isElemB(ns[nlist], I, A)
 .
     
 eq validForCtx(BRL, Delta, I, A) = false [owise] .       
  
 eq typeOf(Sigma, Delta, Gamma, I, A, return M) = typeOf(Sigma, Gamma, M) .
 eq typeOf(Sigma, Delta, Gamma, I, A, samp D) = typeOf(Sigma, Gamma, D) .
 ceq typeOf(Sigma, Delta (chn ns :: T), Gamma, I, A, read ns) = T 
  if isElemB(ns, I, A) .

 ceq typeOf(Sigma, Delta (chn (ns[nlist]) :: T), Gamma, I, A, read (ns[nlist])) = T 
     if isElemB(ns[nlist], I, A) . 

 ceq typeOf(Sigma, Delta (fam (ns[bdList]) :: T), Gamma, I, A, read (ns[nlist])) = T 
     if isElemB(ns[nlist], I, A) .
     
 ceq typeOf(Sigma, Delta (fam (ns[bdList]) :: T), Gamma, I, A, read (ns[nlist])) = 
     typeOf(Sigma, Delta, Gamma, I, A, read (ns[nlist]))
     if not isElemB(ns[nlist], I, A) .          
 *** Should we check that nlist respects the bounds here?
 *** No, isElemB does that for us
 *** Again any match would do, since the type does not change!
   
 ceq typeOf(Sigma, Delta, Gamma, I, A, if M then R1 else R2) = 
     typeOf(Sigma, Delta, Gamma, I, A, R1)
     if typeOf(Sigma, Gamma, M) == bool
     /\ typeOf(Sigma, Delta, Gamma, I, A, R1) == typeOf(Sigma, Delta, Gamma, I, A, R2) .
 ceq typeOf(Sigma, Delta, Gamma, I, A, x : T1 <- R1 ; R2) = 
     typeOf(Sigma, Delta, Gamma (x : T1), I, A, R2)
     if typeOf(Sigma, Delta, Gamma, I, A, R1) == T1 .
 ceq typeOf(Sigma, Delta, Gamma, I, A, x : T1 <- R1 ; R2) = 
     typeErr "type assignment error"
     if typeOf(Sigma, Delta, Gamma, I, A, R1) =/= T1 .     
 ceq typeOf(Sigma, Delta, Gamma, I, A, nf(BRL, R)) = 
       typeOf(Sigma, Delta, addDeclarations BRL Gamma, I, A, R) 
     if validForCtx(BRL, Delta, I, A) .
  ceq typeOf(Sigma, Delta, Gamma, I, A, nf(BRL, R)) = 
       typeErr ("invalid list of reads")
     if not validForCtx(BRL, Delta, I, A) .    
 eq typeOf(Sigma, Delta, Gamma, I, A, preNF(BL, R)) =
       typeOf(Sigma, Delta, addDeclarations BL Gamma, I, A, R) .    
 
endfm

mod REACTION-EQUALITY is
 protecting EXPRESSION-TYPING .
 protecting EXPRESSION-EQUALITY .
 protecting REACTION-TYPING .

 *** two reactions R1 R2 are equal w.r.t. Sigma, Delta, Gamma, I, A, T
 *** if 
 *** rConfig(Sigma, Delta, Gamma, R1, I, A, T)
 ***  =>
 *** rConfig(Sigma, Delta, Gamma, R2, I, A, T)

 sort ReactionConfig . 
  
 op rConfig : Signature ChannelContext TypeContext Reaction Set{CNameBound} Set{BoolTerm} IPDLType 
                     -> ReactionConfig [ctor] .

 var A : Set{BoolTerm} .
 var Sigma : Signature .
 var Gamma Gamma' Gamma1 Gamma2 : TypeContext .
 var Delta : ChannelContext .
 vars R R1 R2 R3 R4 S S1 S2 S3 S4 : Reaction .
 vars T T1 T2 T3 : IPDLType .
 var M M1 M2 : IPDLExpression .
 var I I' : Set{CNameBound} . 
 var x x1 x2 y b z c : ChannelName .
 var i o1 o2 : ChannelName .
 var D D' : Distribution .
 var QL QL' : List{NatTerm} .
 var BL : BindList .
 var BRL : BRList .
 var n : Nat .
 var d : Qid .
 var theta : IPDLSubst .
 
 var q : Qid .
 var ns : NameWithScripts .
 var R1' : Reaction .

***( 
 sort CNameTuple .
 op mkTuple : ChannelName ChannelName CNameList -> CNameTuple [ctor] .
  
 op keepFirstAux____ : ChannelName ChannelName CNameList CNameList -> CNameTuple .
 eq keepFirstAux x y emptyCNameList QL' = mkTuple(x, y, emptyCNameList) .
 ceq keepFirstAux x y (z :: QL) QL' = mkTuple(x, y, (reverse QL') ++ (del y (z :: QL))) 
       if x == z .
 ceq keepFirstAux x y (z :: QL) QL' = mkTuple(y, x, (reverse QL') ++ (del x (z :: QL))) 
       if y == z .  
 eq keepFirstAux x y (z :: QL) QL' = keepFirstAux x y QL (z :: QL') [owise] .     
           
 op keepFirst : ChannelName ChannelName CNameList -> CNameTuple .
 eq keepFirst(x, y, QL) = keepFirstAux x y QL emptyCNameList .
)

 *** deal with abbreviations
 rl [expand-type-bind] :
    rConfig(Sigma, Delta, Gamma, x <- R1 ; R2, I, A, T)
    =>
    rConfig(Sigma, Delta, Gamma, x : typeOf(Sigma, Delta, Gamma, I, A, R1) <- R1 ; R2, I, A, T)
 .   
 
 rl [expand-type-nf] :
    rConfig(Sigma, Delta, Gamma, nf((x <- read c) BRL, R), I, A, T)
    => 
    rConfig(Sigma, Delta, Gamma, 
             nf((x : typeOf(Sigma, Delta, Gamma, I, A, read c) <- read c) BRL, R), 
            I, A, T)
 .   

 *** core rules

 crl [cong-ret] : 
 rConfig(Sigma, Delta, Gamma, return M1, I, A, T) 
 => 
 rConfig(Sigma, Delta, Gamma, return M2, I, A, T)
 if
 expConfig(Sigma, Gamma, T, M1) 
 => 
 expConfig(Sigma, Gamma, T, M2) 
 .       
 
  crl [cong-if] : 
     rConfig(Sigma, Delta, Gamma, if M1 then R1 else R2, I, A, T)
     => 
     rConfig(Sigma, Delta, Gamma, if M2 then R3 else R4, I, A, T)
     if
     rConfig(Sigma, Delta, Gamma, R1, I, A, T) => 
     rConfig(Sigma, Delta, Gamma, R3, I, A, T)
     /\
     rConfig(Sigma, Delta, Gamma, R2, I, A, T) => 
     rConfig(Sigma, Delta, Gamma, R4, I, A, T) 
     /\
     expConfig(Sigma, Gamma, bool, M1) => 
     expConfig(Sigma, Gamma, typeName 'bool, M2) . 

  crl [react-subst] :
    rConfig(Sigma, Delta, Gamma1, R1', I, A, T)
    => 
    rConfig(Sigma, Delta, Gamma1, applySubst R2 theta, I, A, T)
    if
    rConfig(Sigma, Delta, Gamma2, R1, I, A, T)
    => 
    rConfig(Sigma, Delta, Gamma2, R2, I, A, T)
    /\ 
    R1' == applySubst R1 theta 
    [nonexec]
  .   
 
  crl [cong-samp] :
  rConfig(Sigma (d : T1 ~>> T2), Delta, Gamma, samp (d < M1 >), I, A, T) 
  => 
  rConfig(Sigma (d : T1 ~>> T2), Delta, Gamma, samp (d < M2 >), I, A, T) 
  if 
  expConfig(Sigma (d : T1 ~>> T2), Gamma, T, M1) 
 => 
 expConfig(Sigma (d : T1 ~>> T2), Gamma, T, M2) 
  .     


 crl [sym] : rConfig(Sigma, Delta, Gamma, R2, I, A, T) 
             => 
             rConfig(Sigma, Delta, Gamma, R1, I, A, T)
     if rConfig(Sigma, Delta, Gamma, R1, I, A, T) 
        =>
        rConfig(Sigma, Delta, Gamma, R2, I, A, T) [nonexec] .
 
 *** refl and trans are properties of => anyways.

 crl [cong-branch] : 
     rConfig(Sigma, Delta, Gamma, if M1 then R1 else R2, I, A, T)
     => 
     rConfig(Sigma, Delta, Gamma, if M2 then R3 else R4, I, A, T)
     if
     rConfig(Sigma, Delta, Gamma, R1, I, A, T) => 
     rConfig(Sigma, Delta, Gamma, R3, I, A, T)
     /\
     rConfig(Sigma, Delta, Gamma, R2, I, A, T) => 
     rConfig(Sigma, Delta, Gamma, R4, I, A, T) 
     /\
     M1 == M2 [nonexec] .
                  
          
 crl [cong-bind] :
     rConfig(Sigma, Delta, Gamma, x : T1 <- R1 ; R2, I , A, T2) 
     => 
     rConfig(Sigma, Delta, Gamma, x : T1 <- R3 ; R4, I, A, T2) 
     if
     rConfig(Sigma, Delta, Gamma, R1, I, A, T1)  
     => 
     rConfig(Sigma, Delta, Gamma, R3, I, A, T1) 
     /\
     rConfig(Sigma, Delta, Gamma (x : T1), R2, I, A, T2)
     => 
     rConfig(Sigma, Delta, Gamma (x : T1), R4, I, A, T2) .
     *** /\ ((R1 =/= R3) or (R2 =/= R4)) .

 crl [samp-pure] : 
     rConfig(Sigma, Delta, Gamma, x : T1 <- samp D ; R, I, A, T2)
     => 
     rConfig(Sigma, Delta, Gamma, R, I, A, T2)
 if typeOf(Sigma, Gamma, D) == T1 /\ typeOf(Sigma, Delta, Gamma, I, A, R) == T2 
 . 

 crl [read-det] : 
     rConfig(Sigma, Delta, Gamma, 
                    x : T1 <- read i ; y : T1 <- read i ; R , I, A, T2) 
     => 
     rConfig(Sigma, Delta, Gamma, 
                    x : T1 <- read i ; (R [y / x]), I, A, T2)
 if  isElemB(i, I, A)  /\ elem (chn i) T1 Delta A
 /\  typeOf(Sigma, Delta, Gamma (x : T1) (y : T1), I, A, R) == T2 
 .
                             
 crl [if-left] : 
     rConfig(Sigma, Delta, Gamma, if True then R1 else R2, I, A, T) 
     =>  
     rConfig(Sigma, Delta, Gamma, R1, I, A, T)
 if
     typeOf(Sigma, Delta, Gamma, I, A, R1) == T
     /\
     typeOf(Sigma, Delta, Gamma, I, A, R2) == T 
 .

 crl [if-right] : 
     rConfig(Sigma, Delta, Gamma, if False then R1 else R2, I, A, T) 
     =>  
     rConfig(Sigma, Delta, Gamma, R2, I, A, T)
 if
     typeOf(Sigma, Delta, Gamma, I, A, R1) == T 
     /\
     typeOf(Sigma, Delta, Gamma, I, A, R2) ==  T 
 . 

***( this rule can't be applied by Maude so we replaced it with derived rules
  crl [if-ext] : 
     rConfig(Sigma, Delta, Gamma, R [b / M], I, T)
     => 
     rConfig(Sigma, Delta, Gamma, if M then (R [b / True]) else (R [b / False]), I, T)
     if
     typeOf(Sigma, Gamma, M) == bool
     /\
     typeOf(Sigma, Delta, Gamma (b : bool), I, R) == T . 
)

   *** what we can write is the version where M is a variable

   rl [if-intro-ext] :
     rConfig(Sigma, Delta, Gamma (q : typeName 'bool), R, I, A, T) 
     => 
     rConfig(Sigma, Delta, Gamma (q : bool),
             if q then (R[q / True]) else (R[q / False]), I, A, T)          
  .           

 crl [ret-bind] : 
     rConfig(Sigma, Delta, Gamma, x : T1 <- return M ; R , I , A, T2) 
     => 
     rConfig(Sigma, Delta, Gamma, R [x / M], I, A, T2) 
     if
     typeOf(Sigma, Gamma, M) == T1
     /\
     typeOf(Sigma, Delta, Gamma (x : T1), I, A, R) == T2 .
     
      
 crl [ret-bind-2] :
     rConfig(Sigma, Delta, Gamma, R, I, A, T2) 
     =>
     rConfig(Sigma, Delta, Gamma, x : T1 <- return M1 ; R2, I, A, T2)
     if  
     typeOf(Sigma, Gamma, M1) == T1  /\
     typeOf(Sigma, Delta, Gamma, I, A, R) == T2 /\
     typeOf(Sigma, Delta, Gamma (x : T1), I, A, R2) == T2 /\
     R == R2[x / M1] [nonexec] .

 crl [bind-ret] : 
     rConfig(Sigma, Delta, Gamma, x : T <- R ; return x, I , A, T) 
     => 
     rConfig(Sigma, Delta, Gamma, R, I, A, T)
     if 
     typeOf(Sigma, Delta, Gamma, I, A, R) == T . 

 crl [bind-ret-2] : 
     rConfig(Sigma, Delta, Gamma, R, I, A, T) 
     => 
     rConfig(Sigma, Delta, Gamma, x : T <- R ; return x, I, A, T)
     if 
     typeOf(Sigma, Delta, Gamma, I, A, R) == T [nonexec] .

 crl [bind-bind] : 
     rConfig(Sigma, Delta, Gamma, x2 : T2 <- (x1 : T1 <- R1 ; R2) ; R3, I, A, T3)
     => 
     rConfig(Sigma, Delta, Gamma, x1 : T1 <- R1 ; (x2 : T2 <- R2 ; R3), I, A, T3)
 if
     typeOf(Sigma, Delta, Gamma, I, A, R1) == T1
     /\
     typeOf(Sigma, Delta, Gamma (x1 : T1), I, A, R2) == T2
     /\ 
     typeOf(Sigma, Delta, Gamma (x2 : T2), I, A, R3) == T3 
 .              

 crl [exchange] : 
     rConfig(Sigma, Delta, Gamma, x1 : T1 <- R1 ; x2 : T2 <- R2 ; R, I, A, T3)
     => 
     rConfig(Sigma, Delta, Gamma, x2 : T2 <- R2 ; x1 : T1 <- R1 ; R, I, A, T3)
 if
     typeOf(Sigma, Delta, Gamma, I, A, R1) == T1
     /\
     typeOf(Sigma, Delta, Gamma, I, A, R2) == T2
     /\
     typeOf(Sigma, Delta, Gamma (x1 : T1) (x2 : T2), I, A, R) == T3 
 .
 
 *** rules for normal forms: 
 
 
 crl [cong-pre-nf] :
     rConfig(Sigma, Delta, Gamma, preNF(BL , R1), I, A, T)
     => 
     rConfig(Sigma, Delta, Gamma, preNF(BL , R2), I, A, T)
     if 
     rConfig(Sigma, Delta, addDeclarations BL Gamma, R1, I, A, T) 
     => 
     rConfig(Sigma, Delta, Gamma', R2, I, A, T) 
     /\
     Gamma' == addDeclarations BL Gamma [nonexec] .
     
  crl [cong-nf] :
     rConfig(Sigma, Delta, Gamma, nf(BL , R1), I, A, T)
     => 
     rConfig(Sigma, Delta, Gamma, nf(BL , R2), I, A, T)
     if 
     rConfig(Sigma, Delta, addDeclarations BL Gamma, R1, I, A, T) 
     => 
     rConfig(Sigma, Delta, Gamma', R2, I, A, T) 
     *** /\  Gamma' == addDeclarations BL Gamma 
     . 
     
  var someCN : ChannelName .

 crl [read-det-pre] :
     rConfig(Sigma, Delta, Gamma, 
               preNF( (x : T1 <- read someCN) (y : T1 <- read someCN) BL , R ), I, A, T2) 
     =>
     rConfig(Sigma, Delta, Gamma, 
               preNF( (x : T1 <- read someCN) BL , R [y / x] ), I, A, T2) 
 if *** isElemB(someCN, I, A)  /\ 
    *** elem (toBound someCN) T1 Delta A /\
    typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1) (y : T1)), I, A, R) == T2        
 .
 
  crl [read-det-nf] :
     rConfig(Sigma, Delta, Gamma, 
               nf( (x : T1 <- read i) (y : T1 <- read i) BL , R), I, A, T2) 
     =>
     rConfig(Sigma, Delta, Gamma, 
               nf( (x : T1 <- read i) BL , R [y / x]), I, A, T2) 
 if *** isElemB(i, I, A)  /\ 
    *** elem (toBound i) T1 Delta A /\
    typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1) (y : T1)), I, A, R) == T2        
 .
                
 crl [bind-ret-2-pre] : 
     rConfig(Sigma, Delta, Gamma, 
               preNF( (x : T1 <~ R1) BL , return x ), I, A, T1) 
     =>
     rConfig(Sigma, Delta, Gamma, 
               preNF( BL , R1 ), I, A, T1) 
 if typeOf(Sigma, Delta, addDeclarations BL Gamma, I, A, R1) == T1 
  .         
     
 crl [read2Binds] : 
    rConfig(Sigma, Delta, Gamma, preNF(BL (x : T1 <~ read i), R ), I, A, T) 
    =>
    rConfig(Sigma, Delta, Gamma, preNF(BL (x : T1 <- read i), R ), I, A, T) 
    if isElemB(i, I, A) and elem (chn i) T1 Delta A 
 .
    
 crl [pre2Nf] : preNF(BRL, R ) => nf(BRL, R) if R : BindFreeReaction .
 
 rl [nf2Pre] : nf(BL, R) => preNF(BL, R) .
      
 crl [merge-pre] :
     rConfig(Sigma, Delta, Gamma, preNF(BL (x : T1 <~ R1) , R2 ), I, A, T2)
     =>
     rConfig(Sigma, Delta, Gamma, preNF(BL , x : T1 <- R1 ; R2 ), I, A, T2) 
   if typeOf(Sigma, Delta, addDeclarations BL Gamma, I, A, R1) == T1
     /\ typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1)), I, A, R2) == T2
 .
    
 crl [bind2R-nf] :   
 rConfig(Sigma, Delta, Gamma, nf(BRL (x : T1 <- R1) , R2), I, A, T2)
     =>
     rConfig(Sigma, Delta, Gamma, preNF(BRL , x : T1 <- R1 ; R2 ), I, A, T2) 
 if typeOf(Sigma, Delta, addDeclarations BRL Gamma, I, A, R1) == T1
 /\ typeOf(Sigma, Delta, addDeclarations BRL (Gamma (x : T1)), I, A, R2) == T2 
     .
    
 crl [bind2R-pre] :
     rConfig(Sigma, Delta, Gamma, preNF(BL (x : T1 <- R1) , R2 ), I, A, T2)
     =>
     rConfig(Sigma, Delta, Gamma, preNF(BL , x : T1 <- R1 ; R2 ), I, A, T2) 
 if typeOf(Sigma, Delta, addDeclarations BL Gamma, I, A, R1) == T1
 /\ typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1)), I, A, R2) == T2 
     .
  
 crl [bind2R-pre-reverse] :
     rConfig(Sigma, Delta, Gamma, 
             preNF(BL , x : T1 <- read i ; R2 ), 
             I, A, T2)
     =>
     rConfig(Sigma, Delta, Gamma, 
             preNF(BL (x : T1 <- read i) , R2 ),
             I, A, T2) 
 if 
 isElemB(i, I, A)  /\ elem (chn i) T1 Delta A /\
 typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1)), I, A, R2) == T2
 .  
 
 crl [ret-bind-pre] :
     rConfig(Sigma, Delta, Gamma, preNF((x : T1 <~ (return M)) BL, R ), I, A, T2) 
     =>
     rConfig(Sigma, Delta, Gamma, preNF(BL, R [x / M] ), I, A, T2) 
 if
     typeOf(Sigma, Gamma, M) == T1 
     /\  typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1)), I, A, R) == T2 
 .   
     *** could be a nf already, but the strategy tries to take care of this 

 
 crl [bind-bind-pre] :
     rConfig(Sigma, Delta, Gamma, 
              preNF((x2 : T2 <~ nf(BRL, R2)) BL, R1), I, A, T1)
     =>  
     rConfig(Sigma, Delta, Gamma, 
              preNF(BRL (x2 : T2 <~ R2) BL, 
                    R1), I, A, T1) 
 if  
     typeOf(Sigma, Delta, 
            addDeclarations BRL (addDeclarations BL Gamma), I, A, R2) == T2
     /\          
     typeOf(Sigma, Delta, 
            addDeclarations BL (Gamma (x2 : T2)), I, A, R1) == T1
 .  
 
  crl [bind-bind-pre-pre] :
     rConfig(Sigma, Delta, Gamma, 
              preNF((x2 : T2 <~ preNF(BRL, R2)) BL, R1), I, A, T1)
     =>  
     rConfig(Sigma, Delta, Gamma, 
              preNF(BRL (x2 : T2 <~ R2) BL, 
                    R1), I, A, T1) 
 if  
     typeOf(Sigma, Delta, 
            addDeclarations BRL (addDeclarations BL Gamma), I, A, R2) == T2
     /\          
     typeOf(Sigma, Delta, 
            addDeclarations BL (Gamma (x2 : T2)), I, A, R1) == T1
 . 
            
 *** derived rules:  

  crl [same-reaction-if] : 
     rConfig(Sigma, Delta, Gamma, if M then R else R, I, A, T)
     => 
     rConfig(Sigma, Delta, Gamma, R, I, A, T) 
  if typeOf(Sigma, Delta, Gamma, I, A, R) == T  
  /\ typeOf(Sigma, Gamma, M) == bool 
  . 
      
***  crl [read-inside-if] : 
***     rConfig(Sigma, Delta, Gamma, x : T1 <- read i ; if M then R1 else R2, I, A, T) 
***     => 
***     rConfig(Sigma, Delta, Gamma, 
***              if M then (x : T1 <- read i ; R1) 
***                   else (x : T1 <- read i ; R2), I, A, T) 
***     if isElemB(i, I, A)  /\ elem (chn i) T1 Delta A .
   
***  crl [read-outside-if] : 
***     rConfig(Sigma, Delta, Gamma, if M then (x : T1 <- read i ; R1) 
***                                       else (x : T1 <- read i ; R2)
***             , I, A, T) 
***     => 
***     rConfig(Sigma, Delta, Gamma, 
***              x : T1 <- read i ; if M then R1 else R2, I, A, T) 
***     if isElemB(i, I, A)  /\ elem (chn i) T1 Delta A
***     .
                    
***  rl [if-over-bind-same-2] :
***      rConfig(Sigma, Delta, Gamma, x : T1 <- if M1 
***                                              then if M2 then R1 else R2
***                                              else if M2 then R3 else R4 ;
***                                   if M1 
***                                      then if M2 then S1 else S2
***                                      else if M2 then S3 else S4,
***                                  I, A, T)
***     => 
***     rConfig(Sigma, Delta, Gamma, if M1 
***                                     then if M2 then (x : T1 <- R1 ; S1) 
***                                                else (x : T1 <- R2 ; S2)
***                                     else if M2 then (x : T1 <- R3 ; S3) 
***                                                else (x : T1 <- R4 ; S4),          
***                                  I, A, T) .                             
           
 crl [if-over-bind-same] :
    rConfig(Sigma, Delta, Gamma, x : T1 <- if M then R1 else R2 ; 
                                 if M then R3 else R4, I, A, T)
    =>
    rConfig(Sigma, Delta, Gamma, if M then (x : T1 <- R1 ; R3) else (x : T1 <- R2 ; R4) , 
                                 I, A, T)                   
 if typeOf(Sigma, Delta, Gamma, I, A, R1) == T1  /\
       typeOf(Sigma, Delta, Gamma, I, A, R2) == T1  /\
       typeOf(Sigma, Delta, Gamma (x : T1), I, A, R3) == T /\
       typeOf(Sigma, Delta, Gamma (x : T1), I, A, R4) == T /\
       typeOf(Sigma, Gamma, M) == bool 
 .
 
 crl [if-over-bind] : 
    rConfig(Sigma, Delta, Gamma, x : T1 <- if M then R1 else R2 ; R , I, A, T) 
    =>
    rConfig(Sigma, Delta, Gamma, if M then (x : T1 <- R1 ; R) else (x : T1 <- R2 ; R) , 
            I, A, T) 
 if typeOf(Sigma, Delta, Gamma, I, A, R1) == T1  /\
       typeOf(Sigma, Delta, Gamma, I, A, R2) == T1  /\
       typeOf(Sigma, Delta, Gamma (x : T1), I, A, R) == T /\
       typeOf(Sigma, Gamma, M) == bool
   .
      
 crl [bind-over-if] :  *** if-over-read
     rConfig(Sigma, Delta, Gamma, if M then (x : T1 <- R1 ; R) else (x : T1 <- R1 ; S), I, A, T)
     =>        
     rConfig(Sigma, Delta, Gamma, x : T1 <- R1 ; if M then R else S, I, A, T)
 if
     typeOf(Sigma, Delta, Gamma, I, A, R1) == T1 /\
     typeOf(Sigma, Delta, Gamma (x : T1), I, A, R) == T /\
     typeOf(Sigma, Delta, Gamma (x : T1), I, A, S) == T /\
     typeOf(Sigma, Gamma, M) == bool 
 .

   var Dist : Distribution .   

 rl [samp-over-if] :
    rConfig(Sigma, Delta, Gamma, 
            preNF((x : T1 <~ samp Dist) BL, if M then R1 else R2), I, A, T) 
    => 
    rConfig(Sigma, Delta, Gamma, 
            preNF(BL, if M then (x : T1 <- samp Dist ; R1) 
                           else (x : T1 <- samp Dist ; R2)
                           ), 
            I, A, T) 
    .
 
 var vx vy : Qid . 
        
 crl [alpha] :
     rConfig(Sigma, Delta, Gamma, vx : T1 <- R1 ; R2 , I, A, T2 )
     =>
     rConfig(Sigma, Delta, Gamma, vy : T1 <- R1 ; (R2 [vx / vy]), I, A, T2)
     if typeOf(Sigma, Delta, Gamma, I, A, R1) == T1 /\
        typeOf(Sigma, Delta, Gamma (vx : T1), I, A, R2) == T2 [nonexec] .
        
 rl [alpha-nf] : 
    rConfig(Sigma, Delta, Gamma, 
            nf((vx : T1 <- R1) BRL,
               R2
              ),
            I, A, T2    
           )
     => 
     rConfig(Sigma, Delta, Gamma, 
            nf((vy : T1 <- R1) BRL,
               R2 [vx / vy] 
              ),
            I, A, T2    
           )   
      [nonexec]        
 .       
endm

fmod TYPEDCNAME is
 protecting TYPES .
 protecting CHANNEL-NAME .
 
 *** typed declarations for new normal form
 
 sort TypedCName .
 op <_:_> : ChannelName IPDLType -> TypedCName [ctor] .
 op {__:_} : FamilyName List{NatTerm} IPDLType -> TypedCName [ctor] .
 
 sort TypedCNameList .
 subsort TypedCName < TypedCNameList .
 op emptyTypedCNameList : -> TypedCNameList [ctor] .
 op __ : TypedCNameList TypedCNameList -> TypedCNameList 
       [comm assoc ctor id: emptyTypedCNameList] .

endfm 

view TypedCName from TRIV to TYPEDCNAME is
 sort Elt to TypedCName .
endv

fmod NAT-PAIRS is
 protecting NAT .

 sort NatPairs .
 op (_;;_) : Nat Nat -> NatPairs [ctor] .

endfm

view NatPairs from TRIV to NAT-PAIRS is
 sort Elt to NatPairs .
endv

fmod PROTOCOL is
 protecting REACTION .
  protecting CHANNEL .
 protecting LIST{Bounds} .
 protecting LIST{CNameBound} .
 protecting LIST{NatPairs} .
 protecting CNAME-BOUND .
 protecting TYPEDCNAME .
 protecting SET{BoolTerm} .

 *** helper

 var q1 q2 : Qid .

  sort QidPair .
 op <<_,_>> : Qid Qid -> QidPair [ctor] .
 op getFst : QidPair -> Qid .
 op getSnd : QidPair -> Qid .
 eq getFst(<< q1, q2 >>) = q1 .
 eq getSnd(<< q1, q2 >>) = q2 .
 
 sort QidPairList .
 subsort QidPair < QidPairList .
 op emptyQidPairList : -> QidPairList [ctor] .
 op __ : QidPairList QidPairList -> QidPairList [ctor assoc] . 
 
 sort Protocol .

 op emptyProtocol : -> Protocol [ctor] .
 op _::=_ : ChannelName Cases -> Protocol [ctor format(b o g oni) prec 43] .
 op _||_ : Protocol Protocol -> Protocol [ctor assoc comm format(d ni ni o) prec 45] .
 op new_:_in_ : ChannelName IPDLType Protocol -> Protocol 
    [ctor format(o b o r nio n+i o) prec 47] .
 op newfamily___:_in_ : FamilyName List{NatTerm} List{Bounds} IPDLType Protocol -> Protocol 
     [ctor format(o b r nib o b nio ni o) prec 47] . 
 op newNF : TypedCNameList Protocol -> Protocol [ctor] .
 op family___::=_ : FamilyName List{NatTerm} List{Bounds} Cases -> Protocol 
   [ctor format(o b r nb no ng oni) prec 43] .
    *** put channelname here only to deal with Comp[A B]
    *** now also for slices of families

   *** helper for modeling Maude constants 

  op protocolRef : Qid -> Protocol .
  var phi : IPDLEmbedding .   
 
  *** turn reactions in a protocol to nf   
 op computeNF : Protocol -> Protocol .
 eq computeNF(emptyProtocol) = emptyProtocol .
 eq computeNF(protocolRef(q)) = protocolRef(q) .
 eq computeNF(cn ::= cases) = cn ::= computeNF(cases) .
 eq computeNF(P1 || P2) = computeNF(P1) || computeNF(P2) .
 eq computeNF(new cn : T in P) = new cn : T in computeNF(P) .
 eq computeNF(newfamily (cn'[blist']) nlist blist' : T in P) =
    newfamily (cn'[blist']) nlist blist' : T in computeNF(P) .
 eq computeNF(newNF(ltq, P)) = newNF(ltq, computeNF(P)) . 
 eq computeNF(family (cn[blist]) nlist blist ::= cases) =
    family (cn[blist]) nlist blist ::= computeNF(cases) .
 eq computeNF(embedProtocol(P, phi)) = embedProtocol(computeNF(P), phi) .
  
 op computeNF : Cases -> Cases .
 eq computeNF(whenCond --> R) = whenCond --> computeNF(R) .
 eq computeNF((whenCond --> R) ;; whenList) = (whenCond --> computeNF(R)) ;; computeNF(whenList) .
 eq computeNF(whenCond --> P) = whenCond --> computeNF(P) .
 eq computeNF((whenCond --> P) ;; whenList) = (whenCond --> computeNF(P)) ;; computeNF(whenList) .

 sort When .
 sort WhenCond .

 op when_ : BoolTerm -> WhenCond [ctor format(o r d)] .
 op otherwise : -> WhenCond [ctor format(o d)] .
 op _-->_ : WhenCond Cases -> When [ctor format(d o nb d)] .
 
 sort WhenList .
 subsort When < WhenList .
 op emptyWhen : -> WhenList [ctor] .
 op _;;_ : WhenList WhenList -> WhenList 
    [ctor assoc id: emptyWhen format(d no ni d)] .
 
 sort Cases .
 subsort Reaction < Cases . *** for C[i] ::= R(i)
 subsort Protocol < Cases . *** for Party[i] ::= some parallel composition, no cases
 subsort WhenList < Cases .

 var q i q' idx f : Qid .
 var n x y n1 n2 m : Nat .
 var R R' : Reaction .
 var T : IPDLType .
 var ql ql' : List{CNameBound} .
 var P P' P1 P2 : Protocol .
 var cn cn' C D cn1 cn2 : ChannelName .
 var ltq : TypedCNameList .
 var cases : Cases .
 var whenList : WhenList .
 var whenCond : WhenCond .
 var nlist nlist' : List{NatTerm} .
 var cnb cnb3 cnb4 : CNameBound .
 var Delta1 Delta2 : ChannelContext .
 
 var blist blist' : List{Bounds} .
 var evalMap : Map{Qid, NatTerm} .
 var A : Set{BoolTerm} .
 var bt : BoolTerm .

  *** embeddings
 
 var emb : IPDLEmbedding .
 var cnmap : CNameMap .
 var I O : Set{CNameBound} .
 
 op embedProtocol : Protocol IPDLEmbedding -> Protocol .
 eq embedProtocol(emptyProtocol, emb) = emptyProtocol .
 eq embedProtocol(cn ::= cases, emb) = emb @@ cn ::= embedCases(cases, emb) .
 eq embedProtocol(family cn[blist] nlist blist ::= cases, emb) 
  = family cn[blist] nlist blist ::= embedProtocol(cases, emb) .
 eq embedProtocol(P1 || P2, emb) = 
    embedProtocol(P1, emb) || embedProtocol(P2, emb) .
 eq embedProtocol(new cn : T in P, emb) = 
    new cn : T in embedProtocol(P, emb) . 
 eq embedProtocol(newfamily cn[blist] nlist blist : T in P, emb) 
  = newfamily cn[blist] nlist blist : T in embedProtocol(P, emb) .
 eq embedProtocol(newNF(ltq, P), emb) =
    newNF(ltq, embedProtocol(P, emb)) .  
  
 op embedCases : Cases IPDLEmbedding -> Cases .
 eq embedCases(P, emb) = embedProtocol(P, emb) .
 eq embedCases(R, emb) = embedReaction(R, emb) .
 eq embedCases(whenList, emb) = embedWhenList(whenList, emb) .
 
 var BL : BindList .
 var M : IPDLExpression .
 
 op embedReaction : Reaction IPDLEmbedding -> Reaction .
 eq embedReaction(read cn, emb) = read (emb @@ cn) .
 eq embedReaction(i : T <- R1 ; R2, emb) =
    i : T <- embedReaction(R1, emb) ; embedReaction(R2, emb) .
 eq embedReaction(nf(BL, R), emb) 
  = nf(embedBRL(BL, emb), embedReaction(R, emb)) .    
 eq embedReaction(preNF(BL, R), emb) 
  = nf(embedBRL(BL, emb), embedReaction(R, emb)) .    
  eq embedReaction(if M then R1 else R2, emb) = 
    if M then embedReaction(R1, emb) else embedReaction(R2, emb) .
  eq embedReaction(R, emb) = R [owise] .

 op embedBRL : BindList IPDLEmbedding -> BindList .
 eq embedBRL(q : T <- read cn, emb) = q : T <- embedReaction(read cn, emb) .
 eq embedBRL(q : T <~ R, emb) = q : T <~ embedReaction(R, emb) .
 eq embedBRL((q : T <- R) BL, emb) = 
    (q : T <- embedReaction(R, emb)) embedBRL(BL, emb) .
  eq embedBRL((q : T <~ R) BL, emb) = 
    (q : T <~ embedReaction(R, emb)) embedBRL(BL, emb) .
 
 op embedWhenList : WhenList IPDLEmbedding -> WhenList .
 eq embedWhenList(whenCond --> R, emb) = 
    whenCond --> embedReaction(R, emb) .
 eq embedWhenList(whenCond --> P, emb) =
    whenCond --> embedProtocol(P, emb) . 
 eq embedWhenList(whenCond --> P ;; whenList , emb) = 
    whenCond --> embedProtocol(P, emb) ;; embedWhenList(whenList, emb) .
 eq embedWhenList(whenCond --> R ;; whenList , emb) = 
    whenCond --> embedReaction(R, emb) ;; embedWhenList(whenList, emb) .   
       
  
 op embedIO : Set{CNameBound} IPDLEmbedding -> Set{CNameBound} .
 eq embedIO(I, emb) = embedIOAux empty I emb .
 
 op embedIOAux___ : Set{CNameBound} Set{CNameBound} IPDLEmbedding -> Set{CNameBound} .
 eq embedIOAux O empty emb = O .
 eq embedIOAux O (I, chn cn) (f from Delta1 to Delta2 is (cnmap ; cn to cn1))
  = embedIOAux (O, chn cn1) I (f from Delta1 to Delta2 is cnmap) .
 eq embedIOAux O (I, chn cn) (f from Delta1 to Delta2 is cnmap)
  = embedIOAux (O, chn cn) I (f from Delta1 to Delta2 is cnmap) [owise] . 

 *** some helpers
op whenCondToBoolTerm_ : WhenCond -> Set{BoolTerm} .
eq whenCondToBoolTerm (when bt) = bt .
eq whenCondToBoolTerm otherwise = empty .

op whenToBoolTerm_ : When -> Set{BoolTerm} .
eq whenToBoolTerm (when bt --> cases) = bt .
eq whenToBoolTerm (otherwise --> cases) = empty .

op whenListToBoolTerm_ : WhenList -> Set{BoolTerm} .
eq whenListToBoolTerm (when bt --> cases) = bt .
eq whenListToBoolTerm (otherwise --> cases) = empty .

     ***
 
 *** helper: the reaction assigned to a channel
 op getReaction__ : Protocol CNameBound -> Reaction .
 eq getReaction (cn ::= R) (chn cn) = R .
 eq getReaction ((cn ::= R) || P) (chn cn) = R .
 eq getReaction (family (cn[blist]) nlist blist ::= R) (fam (cn[blist])) = R .
 eq getReaction (P || (family (cn[blist]) nlist blist ::= R)) (fam (cn[blist])) = R .
 *** partial function
 
 *** lookup cn ::= cases in P by cn
 
 op getChannel__ : Protocol CNameBound -> Protocol .
 eq getChannel emptyProtocol (chn cn) = emptyProtocol .
 eq getChannel emptyProtocol (fam (cn[blist])) = emptyProtocol . 
 eq getChannel (cn ::= cases) (chn cn) = cn ::= cases .
 eq getChannel (family (cn[blist]) nlist blist ::= cases) 
               (fam (cn[blist])) = 
    family (cn[blist]) nlist blist ::= cases .
 ceq getChannel (cn' ::= cases) (chn cn) = emptyProtocol if cn' =/= cn .
 ceq getChannel (family (cn'[blist']) nlist blist ::= cases) 
                (fam (cn[blist])) = emptyProtocol if cn' =/= cn .
 eq getChannel ((cn ::= cases) || P) (chn cn) = cn ::= cases .
 eq getChannel ((family (cn[blist]) nlist blist ::= cases) || P) (fam (cn[blist])) = 
                 family (cn[blist]) nlist blist ::= cases .
 eq getChannel (newNF(ltq < cn : T >, P1) || P) (chn cn) = getChannel P1 (chn cn) .

 eq getChannel (newNF(ltq { (cn[blist]) nlist : T }, P1) || P) 
               (fam (cn[blist])) = getChannel P1 (fam (cn[blist])) .
 eq getChannel (P1 || P2) cnb = 
    if getChannel P1 cnb == emptyProtocol 
     then getChannel P2 cnb
     else getChannel P1 cnb
    fi [owise] . 
   *** this will not find cn hidden in a list of new/newfamily, works with normal forms only!
 eq getChannel (new cn' : T in P ) (chn cn) = getChannel P (chn cn) .
 eq getChannel (newfamily (cn'[blist']) nlist blist' : T in P) 
               (fam (cn[blist])) = 
    getChannel P (fam (cn[blist])) .
 eq getChannel newNF(ltq, P) cnb = getChannel P cnb .
 
 sort ProtocolStructure .
 subsort CNameBound < ProtocolStructure .   *** for ::=
 op emptyS : -> ProtocolStructure [ctor] .   *** for emptyProtocol
 op _||_ : ProtocolStructure ProtocolStructure -> ProtocolStructure [ctor assoc comm] .  
    *** for ||
 op new_in_ : ChannelName ProtocolStructure -> ProtocolStructure [ctor] . *** for new
 op newfamily_in_ : FamilyName ProtocolStructure -> ProtocolStructure [ctor] . 
    *** for newfamily
 op newNFS : ProtocolStructure -> ProtocolStructure [ctor] . *** for newNF
 op _:=_ : Qid ProtocolStructure -> ProtocolStructure [ctor] . *** for groups
  
 op pStructure_ : Protocol -> ProtocolStructure .
 eq pStructure emptyProtocol = emptyS .
 eq pStructure (cn ::= cases) = chn cn .
 eq pStructure (P1 || P2) = (pStructure P1) || (pStructure P2) .
 eq pStructure (new cn : T in P) = new cn in (pStructure P) .
 eq pStructure (newfamily cn[blist] nlist blist : T in P) = 
                newfamily cn[blist] in (pStructure P) .
 eq pStructure (newNF(ltq, P)) = newNFS(pStructure P) .
 eq pStructure (family cn[blist] nlist blist ::= P) = cn := (pStructure P) .
 eq pStructure (family cn[blist] nlist blist ::= cases) = (fam (cn[blist])) [owise] .


 *** functions on protocols, for sym proofs
 *** to explicitly build the protocols we do induction on, remove a family F
 *** and add the family F with new bound 'B and a channel F['B]
 
 op removeFamily__ : CNameBound Protocol -> Protocol .
 eq removeFamily (fam (cn[blist])) 
      newNF( {(cn[blist]) nlist : T} ltq, 
             P || family (cn[blist]) nlist blist ::= cases) =
      newNF( ltq, P) .
 eq removeFamily cnb P = P [owise] .   
 
 *** create a group by adding several families to it
 op group_named_params__in_ : 
      List{CNameBound} ChannelName List{NatTerm} List{Bounds} Protocol -> Protocol .
 eq group ql named cn params nlist blist in (newNF(ltq, P)) = 
    newNF(ltq, group ql named cn params nlist blist in P) .
 eq group ql named cn params nlist blist in P =
    extendGroup ql cn blist (P || family (cn[blist]) nlist blist ::= emptyProtocol) [owise] .
 
 op extendGroup____ : List{CNameBound} ChannelName List{Bounds} Protocol -> Protocol .
 eq extendGroup (fam (fns[blist']) ) cn blist 
    (P || 
    (family (cn[blist]) nlist blist ::= emptyProtocol) || 
    (family (fns[blist']) nlist' blist' ::= cases)
    ) =
    P || 
    (family (cn[blist]) nlist blist ::= 
      (family (fns[blist']) nlist' blist' ::= cases)
    )
 . 
 eq extendGroup (fam (fns[blist']) ) cn blist
    (P || 
    (family (cn[blist]) nlist blist ::= P1) || 
    (family (fns[blist']) nlist' blist' ::= cases)
    ) =
    P || 
    (family (cn[blist]) nlist blist ::= 
      (P1 || (family (fns[blist']) nlist' blist' ::= cases))
    )
 . 
 eq extendGroup ((fam (fns[blist']) ) ql) cn blist
    (P || 
    (family (cn[blist]) nlist blist ::= P1) || 
    (family (fns[blist']) nlist' blist' ::= cases)
    ) = 
    if P1 == emptyProtocol then 
    extendGroup ql cn blist
    (P || 
    (family (cn[blist]) nlist blist ::= 
      (family (fns[blist']) nlist' blist' ::= cases)
    )
    )
    else 
    extendGroup ql cn blist
    (P || 
    (family (cn[blist]) nlist blist ::= 
      (P1 || (family (fns[blist']) nlist' blist' ::= cases))
    )
    )
    fi
 .  
 
 op addInternalChannel_typed_assigned_in_ : ChannelName IPDLType Cases Protocol -> Protocol .
 eq addInternalChannel cn typed T assigned cases in newNF(ltq, P) = 
    newNF(< cn : T > ltq, P || cn ::= cases) .
 eq addInternalChannel cn typed T assigned cases in P =  
    newNF(< cn : T > , P || cn ::= cases) [owise] .
    
 op addInternalFamily_typed_params__assigned_in_ : 
      ChannelName IPDLType List{NatTerm} List{Bounds} Cases Protocol -> Protocol .   
 eq addInternalFamily cn typed T params nlist blist assigned cases in newNF(ltq, P) =
    newNF({ (cn[blist]) nlist : T } ltq, 
          P || family (cn[blist]) nlist blist ::= cases) .
 eq addInternalFamily cn typed T params nlist blist assigned cases in P =
    newNF({ (cn[blist]) nlist : T } , 
          P || family (cn[blist]) nlist blist ::= cases
          ) [owise] .
  
 var cases' : Cases .
    
 op change_with_in_ : CNameBound Cases Protocol -> Protocol .
 eq change (chn cn) with cases in (cn ::= cases') = cn ::= cases .
 eq change (fam (cn[blist])) with cases in (family (cn[blist]) nlist blist ::= cases') = 
      family (cn[blist]) nlist blist ::= cases .
      
 eq change (chn cn) with cases in (P || cn ::= cases') = P || cn ::= cases .
 eq change (fam (cn[blist])) with cases in (P || family (cn[blist]) nlist blist ::= cases') = 
      P || family (cn[blist]) nlist blist ::= cases .     
 eq change cnb with cases in (newNF(ltq, P) || P2) = 
    (change cnb with cases in newNF(ltq, P)) || (change cnb with cases in P2) .
 eq change cnb with cases in newNF(ltq, P) =
    newNF(ltq, change cnb with cases in P) .
           
 eq change cnb with cases in (family (cn[blist]) nlist blist ::= P) =   
    family (cn[blist]) nlist blist ::= change cnb with cases in P .
 eq change cnb with cases in ((family (cn[blist]) nlist blist ::= P) || P2) =   
    (family (cn[blist]) nlist blist ::= change cnb with cases in P) 
    ||
    change cnb with cases in P2 .
 eq change cnb with cases in P = P [owise] . 

 var whenList1 whenList2 : WhenList . 
 
 op branch_of_change_with_in_ : WhenCond CNameBound CNameBound Cases Protocol -> Protocol .
 eq branch whenCond of (fam (C[blist])) change cnb with cases in  
    (family (C[blist]) nlist blist ::= 
      whenList1 ;;
      (whenCond --> P) ;;
      whenList2
    )      
    =
    family (C[blist]) nlist blist ::=
       whenList1 ;;
       (whenCond --> change cnb with cases in P) ;;
       whenList2 
 .
 eq branch whenCond of (fam (C[blist])) change cnb with cases in
    newNF(ltq, P) =
    newNF(ltq, branch whenCond of (fam (C[blist])) change cnb with cases in P) .
 eq branch whenCond of (fam (C[blist])) change cnb with cases in
    (newNF(ltq, P1) || P2)  =
    newNF(ltq, branch whenCond of (fam (C[blist])) change cnb with cases in P1)
    ||
    (branch whenCond of (fam (C[blist])) change cnb with cases in P2) .    
 eq branch whenCond of (fam (C[blist])) change cnb with cases in  
    ( P1 ||
    (family (C[blist]) nlist blist ::= 
      whenList1 ;;
      (whenCond --> P) ;;
      whenList2
    )
    )      
    =  
    P1 || branch whenCond of (fam (C[blist])) change cnb with cases in  
    (family (C[blist]) nlist blist ::= 
      whenList1 ;;
      (whenCond --> P) ;;
      whenList2
    )      
    .   
 eq branch whenCond of (fam (C[blist])) change cnb with cases in P = P [owise] .

 op overall_with_in_ : CNameBound Cases Protocol -> Protocol .
 eq overall cnb with cases in (family (C[blist]) nlist blist ::= (whenCond --> P)) =
    family (C[blist])  nlist blist ::= (whenCond --> change cnb with cases in P) .
 eq overall cnb with cases in 
    (family (C[blist])  nlist blist ::= (whenCond --> P) ;; whenList ) =
    addBranch(whenCond, 
              change cnb with cases in P,
              overall cnb with cases in (family (C[blist])  nlist blist ::= whenList) 
             ) 
 .  
 eq overall cnb with cases in P = P [owise] .
 
 var cnbl1 cnbl2 : List{CNameBound} .

 op gather_from_hiding_ : List{CNameBound} Protocol List{CNameBound} -> Protocol .
 eq gather cnbl1 from newNF(ltq, P) hiding cnbl2 = 
    newNF(removeFromCNBL ltq cnbl2, 
      removeAll P cnbl1 || newNF( keepFromCNBL ltq cnbl2 , keepAll P cnbl1) 
    ) .

 op keepFromCNBL__ : TypedCNameList List{CNameBound} -> TypedCNameList .   
 eq keepFromCNBL emptyTypedCNameList nil = emptyTypedCNameList .
 eq keepFromCNBL (< cn : T > ltq) ((chn cn) cnbl) 
  = < cn : T > (keepFromCNBL ltq cnbl) .
 eq keepFromCNBL (< cn : T > ltq) cnbl
  = keepFromCNBL ltq cnbl [owise] . 
 eq keepFromCNBL ({ (cn[blist]) nlist : T } ltq) (( fam (cn[blist]) ) cnbl)
  = { (cn[blist]) nlist : T } (keepFromCNBL ltq cnbl) .
 eq keepFromCNBL ({ (cn[blist]) nlist : T } ltq)  cnbl
  = keepFromCNBL ltq cnbl [owise].

 op removeFromCNBL__ : TypedCNameList List{CNameBound} -> TypedCNameList .
 eq removeFromCNBL emptyTypedCNameList nil = emptyTypedCNameList .
 eq removeFromCNBL (< cn : T > ltq) ((chn cn) cnbl)
  = removeFromCNBL ltq cnbl .
 eq removeFromCNBL (< cn : T > ltq) cnbl
  = < cn : T > removeFromCNBL ltq cnbl . 
 eq removeFromCNBL ({ (cn[blist]) nlist : T } ltq) (( fam (cn[blist]) ) cnbl)
  = removeFromCNBL ltq cnbl .
 eq removeFromCNBL ({ (cn[blist]) nlist : T } ltq) cnbl
  = { (cn[blist]) nlist : T } removeFromCNBL ltq cnbl .     

 *** add a branch in front of a when list in a family
 op addBranch : WhenCond Cases Protocol -> Protocol .
 eq addBranch(whenCond, cases, family (C[blist]) nlist blist ::= whenList1) =
    family (C[blist]) nlist blist ::=
     (whenCond --> cases) ;; whenList1 . 
     
 *** add a branch at the end of a when list in a family
 op addBranchEnd___ : WhenCond Cases Protocol -> Protocol .
 eq addBranchEnd whenCond cases (family (C[blist]) nlist blist ::= whenList1) =
    family (C[blist]) nlist blist ::=
    whenList1 ;; (whenCond --> cases) .    
 eq addBranchEnd whenCond cases (cn ::= whenList1) =
    cn ::= whenList1 ;; (whenCond --> cases) .      
      
 op removeFromGroupCases___ : CNameBound CNameBound Protocol -> Protocol .
 eq removeFromGroupCases (fam (C[blist])) (fam (cn[blist'])) 
    (family (C[blist]) nlist blist ::=
      (whenCond --> (P || family (cn[blist']) nlist' blist' ::= cases) )
      ;; whenList
    )
    = removeFromGroupCasesAux (fam (C[blist])) (fam (cn[blist'])) 
    (family (C[blist]) nlist blist ::=
       whenList
    ) (family (C[blist]) nlist blist ::= whenCond --> P) 
      (family (cn[blist']) nlist' blist' ::= whenCond --> cases) .
 eq removeFromGroupCases (fam (C[blist])) (chn cn) 
    (family (C[blist]) nlist blist ::=
      (whenCond --> (P || cn ::= cases) )
      ;; whenList
    )
    = removeFromGroupCasesAux (fam (C[blist])) (chn cn)
    (family (C[blist]) nlist blist ::=
       whenList
    ) (family (C[blist]) nlist blist ::= whenCond --> P) 
      (cn ::= whenCond --> cases) .     
    
 op removeFromGroupCasesAux_____ : 
     CNameBound CNameBound Protocol Protocol Protocol -> Protocol .
 *** end
 eq removeFromGroupCasesAux (fam (C[blist])) (fam (cn[blist'])) 
    (family (C[blist]) nlist blist ::=
       (whenCond --> (P || family (cn[blist']) nlist' blist' ::= cases) )
    ) P1 P2 
    =
    (addBranchEnd whenCond P P1)
    ||     
    (addBranchEnd whenCond cases P2)
 .
 eq removeFromGroupCasesAux (fam (C[blist])) (chn cn) 
    (family (C[blist]) nlist blist ::=
       (whenCond --> (P || cn ::= cases) )
    ) P1 P2 
    =
    (addBranchEnd whenCond P P1)
    ||     
    (addBranchEnd whenCond cases P2)
 .
 ***  loop
 eq removeFromGroupCasesAux (fam (C[blist])) (fam (cn[blist'])) 
    (family (C[blist]) nlist blist ::=
       (whenCond --> (P || family (cn[blist']) nlist' blist' ::= cases) )
       ;; whenList
    ) P1 P2  
    =  
    removeFromGroupCasesAux (fam (C[blist])) (fam (cn[blist'])) 
    (family (C[blist]) nlist blist ::=
       whenList
    ) (addBranchEnd whenCond P P1)
      (addBranchEnd whenCond cases P2) .
 eq removeFromGroupCasesAux (fam (C[blist])) (chn cn)
    (family (C[blist]) nlist blist ::=
       (whenCond --> (P || cn ::= cases) )
       ;; whenList
    ) P1 P2  
    =  
    removeFromGroupCasesAux (fam (C[blist])) (chn cn) 
    (family (C[blist]) nlist blist ::=
       whenList
    ) (addBranchEnd whenCond P P1)
      (addBranchEnd whenCond cases P2) .     
      

 *** the bare structure of a protocol
 op getStructure_ : Protocol -> Protocol .
 eq getStructure emptyProtocol = emptyProtocol .
 eq getStructure (cn ::= cases) = (cn ::= emptyProtocol) .
 eq getStructure (family (cn[blist]) nlist blist ::= 
                   (newfamily (cn'[blist']) nlist' blist' : T in P))
    = family (cn[blist]) nlist blist ::= 
        (newfamily (cn'[blist']) nlist' blist' : T in (getStructure P)) .
 eq getStructure (family (cn[blist]) nlist blist ::= newNF(ltq, P)) 
    = (family (cn[blist]) nlist blist ::= newNF(ltq, getStructure P)) .
 eq getStructure (family (cn[blist]) nlist blist ::= P) =
                 (family (cn[blist]) nlist blist ::= getStructure P) .
 eq getStructure (family (cn[blist]) nlist blist ::= (whenCond --> P) ;; whenList) =   
      family (cn[blist]) nlist blist ::= emptyProtocol .              
 eq getStructure (family (cn[blist]) nlist blist ::= cases) = 
      family (cn[blist]) nlist blist ::= emptyProtocol [owise] .
 eq getStructure newNF(ltq, P) = newNF(ltq, getStructure P) .
 eq getStructure (new cn : T in P) = new cn : T in (getStructure P) .
 eq getStructure (newfamily (cn[blist]) nlist blist : T in P) = 
                  newfamily (cn[blist]) nlist blist : T in (getStructure P) .
 eq getStructure (P1 || P2) = (getStructure P1) || (getStructure P2) .
 
    
 *** turn a new normal form into a protocol with new/newfamily 
 op newNF2New : Protocol -> Protocol .
 eq newNF2New(newNF(emptyTypedCNameList, P)) = P .
 eq newNF2New(newNF({ (cn[blist]) nlist : T } ltq, P)) = 
                  newfamily (cn[blist]) nlist blist : T in (newNF2New(newNF(ltq, P))) .
 eq newNF2New(newNF(< cn : T > ltq, P)) = 
                  new cn : T in (newNF2New(newNF(ltq, P))) .
 eq newNF2New(P) = P [owise] .

 *** compute the new normal form of a protocol
 op new2NF : Protocol -> Protocol .
 eq new2NF(P) = 
    dropEmpty(new2NFAux P newNF(emptyTypedCNameList, emptyProtocol)) 
 .

 op dropEmpty : Protocol -> Protocol .
 eq dropEmpty(newNF(emptyTypedCNameList, P)) = P .
 eq dropEmpty(P) = P [owise] .
 
 var fns : ChannelName .

 op new2NFAux__ : Protocol Protocol -> Protocol .
 eq new2NFAux (new cn : T in P) newNF(ltq, P') = 
      new2NFAux P newNF( < cn : T > ltq, P') .    
 eq new2NFAux (newfamily (cn[blist]) nlist blist : T in P) newNF(ltq, P') = 
      new2NFAux P newNF( {(cn[blist]) nlist : T } ltq, P') .
 eq new2NFAux (P1 || P2)  newNF(ltq, P') = newNF(ltq, new2NF(P1) || new2NF(P2)) .
 eq new2NFAux (family (fns[blist]) nlist blist ::= P) newNF(ltq, P') = 
     newNF(ltq, family (fns[blist]) nlist blist ::= new2NF(P)) .
 eq new2NFAux (family (fns[blist]) nlist blist ::= (whenCond --> P) ) newNF(ltq, P') = 
      newNF(ltq, family (fns[blist]) nlist blist ::= (whenCond --> new2NF(P) )) . 
 eq new2NFAux (family (fns[blist]) nlist blist ::= 
                (whenCond --> P) ;; whenList ) 
               newNF(ltq, P') = 
      newNF(ltq, family (fns[blist]) nlist blist ::= 
                 (whenCond --> new2NF(P)) ;; whenList ) .      
        *** TODO: this is wrong! do the same on whenList!
 eq new2NFAux P newNF(ltq, P') = newNF(ltq, P) [owise] .
  
 var plist : List{NatPairs} .  
 
 vars C1 C2 C3 C4 : ChannelName .
 vars R1 R2 R3 R4 : Reaction .     
 var blist2 blist3 : List{Bounds} .
 var nlist2 nlist3 : List{NatTerm} .
 var cases1 cases2 cases3 cases4 : Cases .
 
 *** next methods are needed to speed-up matching
 
 op keepFour_____ : Protocol CNameBound CNameBound CNameBound CNameBound -> Protocol .
 eq keepFour 
     (P || (C1 ::= cases) || (C2 ::= cases1) || (C3 ::= cases2) || (C4 ::= cases3)) 
              (chn C1) (chn C2) (chn C3) (chn C4) = 
    (C1 ::= cases) || (C2 ::= cases1 ) || (C3 ::= cases2) || (C4 ::= cases3)
 .

 eq keepFour (P   || (family (C1[blist]) nlist blist ::= cases1)
                   || (family (C2[blist']) nlist' blist' ::= cases2)
                   || (family (C3[blist2]) nlist2 blist2 ::= cases3) 
                   || (family (C4[blist3]) nlist3 blist3 ::= cases4) )
                       (fam (C1[blist])) 
                       (fam (C2[blist'])) 
                       (fam (C3[blist2]))
                       (fam (C4[blist3]))
                         = 
                      (family (C1[blist]) nlist blist ::= cases1)
                   || (family (C2[blist']) nlist' blist' ::= cases2)
                   || (family (C3[blist2]) nlist2 blist2 ::= cases3)
                   || (family (C4[blist3]) nlist3 blist3 ::= cases4)
 . 
 
 op removeFour_____ :  Protocol CNameBound CNameBound CNameBound CNameBound -> Protocol .
 eq removeFour (P || (C1 ::= cases) || (C2 ::= cases1) || (C3 ::= cases2) || (C4 ::= cases3)) 
              (chn C1) (chn C2) (chn C3) (chn C4) = P .              
 eq removeFour  (P   || (family (C1[blist]) nlist blist ::= cases1)
                   || (family (C2[blist']) nlist' blist' ::= cases2)
                   || (family (C3[blist2]) nlist2 blist2 ::= cases3) 
                   || (family (C4[blist3]) nlist3 blist3 ::= cases4) )
                       (fam (C1[blist])) 
                       (fam (C2[blist'])) 
                       (fam (C3[blist2]))
                       (fam (C4[blist3]))  = P . 
 
 op keepThree____ : Protocol CNameBound CNameBound CNameBound -> Protocol .
 eq keepThree emptyProtocol cnb1 cnb2 cnb3 = emptyProtocol .
 eq keepThree (P || (C1 ::= cases) || (C2 ::= cases1) || (C3 ::= cases2)) 
              (chn C1) (chn C2) (chn C3)  = 
    (C1 ::= cases) || (C2 ::= cases1 ) || (C3 ::= cases2)
 .

 eq keepThree (P   || (family (C1[blist]) nlist blist ::= cases1)
                   || (family (C2[blist']) nlist' blist' ::= cases2)
                   || (family (C3[blist2]) nlist2 blist2 ::= cases3) ) 
                       (fam (C1[blist])) 
                       (fam (C2[blist'])) 
                       (fam (C3[blist2]))  = 
                      (family (C1[blist]) nlist blist ::= cases1)
                   || (family (C2[blist']) nlist' blist' ::= cases2)
                   || (family (C3[blist2]) nlist2 blist2 ::= cases3)
 . 
 
 op removeThree____ :  Protocol CNameBound CNameBound CNameBound -> Protocol .
 eq removeThree (P || (C1 ::= cases) || (C2 ::= cases1) || (C3 ::= cases2)) 
                (chn C1) (chn C2) (chn C3)  = P .              
 eq removeThree (P   || (family (C1[blist]) nlist blist ::= cases1)
                   || (family (C2[blist']) nlist' blist' ::= cases2)
                   || (family (C3[blist2]) nlist2 blist2 ::= cases3) ) 
                       (fam (C1[blist])) 
                       (fam (C2[blist'])) 
                       (fam (C3[blist2]))  = P . 
   
 var cnb1 cnb2 : CNameBound .  
   
 op keepTwo___ : Protocol CNameBound CNameBound -> Protocol .
 eq keepTwo emptyProtocol cnb1 cnb2  = emptyProtocol .
 eq keepTwo newNF(ltq, P) cnb1 cnb2 = 
    keepTwo P cnb1 cnb2 . *** new equation, keep?
 eq keepTwo ((C1 ::= cases1) || (C2 ::= cases2)) (chn C1) (chn C2) =  
     (C1 ::= cases1) || (C2 ::= cases2) .   
 eq keepTwo ((C1 ::= cases1) || (C2 ::= cases2) || P) (chn C1) (chn C2) =  
     (C1 ::= cases1) || (C2 ::= cases2) .
 eq keepTwo ((C1 ::= cases1) || (family (C2[blist]) nlist blist ::= cases2) || P) 
    (chn C1) (fam (C2[blist]))  =  
    (C1 ::= cases1) || (family (C2[blist]) nlist blist ::= cases2) . 
 eq keepTwo ((family (C1[blist]) nlist blist ::= cases1) || (C2 ::= cases2) || P) 
             (fam (C1[blist])) (chn C2) =  
    (family (C1[blist]) nlist blist ::= cases1) || (C2 ::= cases2) . 
 eq keepTwo ((family (C1[blist]) nlist blist ::= cases1)   ||   
             (family (C2[blist']) nlist' blist' ::= cases2) || 
              P)
             (fam (C1[blist])) (fam (C2[blist'])) =  
    (family (C1[blist]) nlist blist ::= cases1) || 
    (family (C2[blist']) nlist' blist' ::= cases2) .   
 eq keepTwo (new C : T in P) cnb1 cnb2  = keepTwo P cnb1 cnb2 .
 eq keepTwo (newfamily (C[blist]) nlist blist : T in P) cnb1 cnb2 = keepTwo P cnb1 cnb2 .
 
 op removeTwo___ : Protocol CNameBound CNameBound -> Protocol .
 eq removeTwo emptyProtocol cnb1 cnb2  = emptyProtocol .
 eq removeTwo newNF(ltq, P) cnb1 cnb2 = 
    removeTwo P cnb1 cnb2 . 
 *** new equation, keep? needed it for generating the inputs for the induction protocol
 eq removeTwo ((C1 ::= cases1) || (C2 ::= cases2) || P) (chn C1) (chn C2) =  P .
 eq removeTwo ((C1 ::= cases1) || (family (C2[blist]) nlist blist ::= cases2) || P) 
    (chn C1) (fam (C2[blist])) =  P .  
 eq removeTwo ((family (C1[blist]) nlist blist ::= cases1) || (C2 ::= cases2) || P) 
             (fam (C1[blist])) (chn C2) =  P .
 eq removeTwo ((family (C1[blist]) nlist blist ::= cases1)   ||   
             (family (C2[blist']) nlist' blist' ::= cases2) || 
              P)
             (fam (C1[blist])) (fam (C2[blist'])) =  P .
 eq removeTwo (new C : T in P)  cnb1 cnb2 = removeTwo P  cnb1 cnb2 .
 eq removeTwo (newfamily (C[blist]) nlist blist : T in P)  cnb1 cnb2 = removeTwo P  cnb1 cnb2 .
 
 ***TODO: important keepX for exactly X, removeX for exactly X

var cnbl : List{CNameBound} .

op removeAll__ : Protocol List{CNameBound} -> Protocol .
eq removeAll P empty = P .
eq removeAll P cnb = removeOne P cnb .
eq removeAll P (cnb cnbl) = removeAll (removeOne P cnb) cnbl .

op keepAll__ : Protocol List{CNameBound} -> Protocol .
eq keepAll P empty = P .
eq keepAll P cnb = keepOne P cnb .
eq keepAll P (cnb cnbl) = (keepOne P cnb)  || (keepAll P cnbl) .

 op keepOne__ : Protocol CNameBound -> Protocol .
 eq keepOne emptyProtocol cnb = emptyProtocol .
 eq keepOne newNF(ltq, P) cnb = keepOne P cnb .
 eq keepOne ((C1 ::= cases) || P) (chn C1) =  (C1 ::= cases) .  
 eq keepOne (C1 ::= cases) (chn C1) =  (C1 ::= cases) .  
 eq keepOne (new C : T in P) cnb = keepOne P cnb .
 eq keepOne (family (C1[blist]) nlist blist ::= cases)  
            (fam (C1[blist])) = family (C1[blist]) nlist blist ::= cases .
 eq keepOne ((family (C1[blist]) nlist blist ::= cases) || P) 
            (fam (C1[blist])) = family (C1[blist]) nlist blist ::= cases .
 eq keepOne (newfamily (C2[blist']) nlist blist' : T in P) 
            cnb = keepOne P cnb .
 
 op removeOne__ : Protocol CNameBound -> Protocol .
 eq removeOne emptyProtocol cnb = emptyProtocol .
 eq removeOne newNF(ltq, P) cnb = removeOne P cnb .
 eq removeOne ((C1 ::= cases) || P) (chn C1) =  P . 
 eq removeOne (new C : T in P) cnb = removeOne P cnb  .
 eq removeOne ((family (C1[blist]) nlist blist ::= cases) || P) (fam (C1[blist])) = P .
 eq removeOne (newfamily (C2[blist']) nlist blist' : T in P) cnb = removeOne P cnb .
             
 *** json-like representation
 sort JSON .
 *** TODO: the value should be JSON
 *** 1. cn ::= R                value: {reaction: R}
 *** 2. cn ::= P                value: (toJSON P Delta)
 *** 3. cn ::= when bt -> R     value: {cond: bt, reaction: R}
 *** 4. cn ::= when bt -> P     value: {cond: bt, protocol: (toJSON P Delta)}
 
 op {} : -> JSON [ctor] .
 op {cname:_,value:_,hasType:_,isInternal:_, extras:_} : 
     ChannelName JSON JSON Bool JSON -> JSON 
     [ctor format(d n d d n d d n d d n d d n d n d)] .
 
 op {type:_} : IPDLType -> JSON [ctor] .
 op {reaction:_} : Reaction -> JSON [ctor] .
 op {cond:_,reaction:_} : WhenCond Reaction -> JSON [ctor] .
 op {cond:_,protocol:_} : WhenCond JSON -> JSON [ctor] .
 
 sort JSONList .
 subsort JSON < JSONList .
 op emptyJSONList : -> JSONList [ctor] .
 op __ : JSONList JSONList -> JSONList 
     [ctor comm assoc id: emptyJSONList format(d n d)] .
 
 op {_} : JSONList -> JSON [ctor format(d n n d)] .
 op {indices:_,bounds:_} : List{NatTerm} List{Bounds} -> JSON [ctor] . 
 
 var j j' e v t : JSON .
 var js : JSONList .
 var internal : Bool .
 
 op insertJSON__ : JSON JSON -> JSON .
 eq insertJSON j {js} = {j js} .
 eq insertJSON j j' = {j j'} [owise] .
 
 op updateInternal : JSON ChannelName -> JSON .
 eq updateInternal(
     {cname: cn, value: v, hasType: t, isInternal: internal, extras: e},
      cn
    ) = {cname: cn, value: v, hasType: t, isInternal: true, extras: e} .
 eq updateInternal({j js}, cn) = 
      insertJSON (updateInternal(j, cn)) (updateInternal({js}, cn)) .
 eq updateInternal(j, cn) = j [owise] .  
 
 *** sets the value to emptyProtocol, the typing is no longer correct
 op updateValue : JSON -> JSON .
 eq updateValue (
     {cname: cn, value: {{cond: whenCond, protocol: j} js}, 
      hasType: t, isInternal: internal, extras: e}
    ) = {cname: cn, value: updateValue({{cond: whenCond, protocol: j} js}), 
         hasType: t, isInternal: internal, extras: e} .
 eq updateValue (
     {cname: cn, value: v, hasType: t, isInternal: internal, extras: e}
    ) = {cname: cn, value: {}, hasType: t, isInternal: internal, extras: e} .
 eq updateValue({j js}) = 
      insertJSON (updateValue(j)) (updateValue({js})) .
 eq updateValue({cond: whenCond, protocol: j}) = 
    {cond: whenCond, protocol: updateValue(j)} .     
 eq updateValue(j) = j [owise] .     
 
endfm

view Protocol from TRIV to PROTOCOL is
 sort Elt to Protocol .
endv

fmod PROTOCOL-IO is
 protecting PROTOCOL .
 protecting CHANNEL .

 op getOutputs : Protocol -> Set{CNameBound} .
 
 var c cn : ChannelName .
 var P P1 P2 : Protocol .
 var T : IPDLType .
 vars R : Reaction .
 var cases : Cases . 
 var ltq : TypedCNameList .
 var ql : List{CNameBound} .
  var nlist : List{NatTerm} .
 var blist : List{Bounds} .
 var whenList : WhenList .
 var whenCond : WhenCond .
 var q q1 q2 : NameWithScripts .
 var b1 b2 : NatTerm . 
 var b : Qid .
  var emb : IPDLEmbedding .
 var I O : Set{CNameBound} .

*** convert the channels in a typed list to a set of bounded names
op chansInList_ : TypedCNameList -> Set{CNameBound} .
eq chansInList emptyTypedCNameList = empty .
eq chansInList (< c : T > ltq) = insert(chn c, chansInList ltq) .
*** the one below is covered
*** eq chansInList (< q[nlist] : T > ltq) = insert(q[nlist] @ nil, chansInList ltq) . 

eq chansInList ({(c[blist]) nlist : T} ltq) = 
   insert(fam (c[blist]), chansInList ltq) .

 *** the outputs of a protocol can be computed
 eq getOutputs(emptyProtocol) = empty [label outputs:empty] .
 eq getOutputs(family (('Comp[(qidAsTerm q1) (qidAsTerm q2)])[blist]) nlist blist ::= P) = getOutputs(P) [label outputs:Comp] .
 eq getOutputs(cn ::= R) = chn cn [label outputs:assign] .
 eq getOutputs(cn ::= (whenCond --> P) ;; whenList) = getOutputs(P) [label outputs:whenPchannel] .
 eq getOutputs(cn ::= cases) = chn cn [label outputs:cnAssign] .
 eq getOutputs((cn ::= R) || P2) = insert(chn cn, getOutputs(P2)) [label outputs:compBasic] .
 *** eq getOutputs((q[nlist] ::= R) || P2) = insert(chn (q[nlist]), getOutputs(P2)) .
 eq getOutputs(P1 || P2) = union(getOutputs(P1), getOutputs(P2)) [owise label outputs:comp] .
 eq getOutputs(new c : T in P) = getOutputs(P) \ (chn c) [label outputs:new] .
 eq getOutputs(newfamily (c[blist]) nlist blist : T in P) = 
  getOutputs(P) \ (fam (c[blist])) [label outputs:newfamily].
 eq getOutputs(newNF(ltq, P)) = 
  getOutputs(P) \ (chansInList ltq) [label outputs:newNF] .
 eq getOutputs(family (c[blist]) nlist blist ::= R) = fam (c[blist]) [label outputs:familyR] .
 eq getOutputs(
    family (c[blist]) nlist blist ::= 
     (whenCond --> R) ;; whenList) = fam (c[blist]) [label outputs:whenCondR] .
 eq getOutputs(family (c[blist]) nlist blist ::= (whenCond --> P) ;; whenList) = 
    toFamily getOutputs(P) nlist blist [label outputs:whenCondP]  .
 *** we assume that for each case we have same set of outputs
 eq getOutputs(family (c[blist]) nlist blist ::= P) = 
    toFamily getOutputs(P) nlist blist [label outputs:familyP]  .
 eq getOutputs(embedProtocol(P, emb)) = embedIO(getOutputs(P), emb) [label outputs:embed] . 

  op toFamily___ : Set{CNameBound} List{NatTerm} List{Bounds} -> Set{CNameBound} .
   eq toFamily (O, chn (q[nlist])) nlist blist 
    = toFamily (O, fam (q[blist])) nlist blist .
   eq toFamily O nlist blist = O [owise] . 
   
   var Delta : ChannelContext .
   
   op toChannelCCtx__ : ChannelContext Set{CNameBound} -> ChannelContext .
   eq toChannelCCtx (Delta (fam (q[blist]) :: T)) (O, chn (q[nlist])) 
    = toChannelCCtx (Delta (chn (q[nlist]) :: T) ) O .
   eq toChannelCCtx Delta O  = Delta [owise] . 
   
   op toChannel__ : Set{CNameBound} List{NatTerm} -> Set{CNameBound} .
   eq toChannel (I, fam (q[blist]) ) nlist
    = toChannel (I, chn (q[nlist]) ) nlist .
   eq toChannel I nlist = I [owise] . 
   
endfm

fmod PROTOCOL-TYPING is 
 protecting PROTOCOL-IO .
 *** protecting PROTOCOL-INDEP .
 protecting REACTION-TYPING .

 var Sigma : Signature .
 var Delta : ChannelContext .
 var I : Set{CNameBound} .
 var A : Set{BoolTerm} .
 var Q o cn c : ChannelName .
 var q q1 q2 : NameWithScripts .
 var T : IPDLType .
 var R : Reaction .
 var P1 P2 P : Protocol .
 var n n0 : Nat .
 var nlist : List{NatTerm} .
 var blist blist' : List{Bounds} .
 var ind1 ind2 ind3 : Qid .
 var nt1 nt2 nt3 : NatTerm .
  
 *** add to a set the condition that the variables of a family
 *** are within bounds
 op addAssumptions___ : Set{BoolTerm} List{NatTerm} List{Bounds} -> Set{BoolTerm} .
 eq addAssumptions A qidAsTerm ind1 (bound nt1) = insert(qidAsTerm ind1 <T nt1, A) .
 eq addAssumptions A ((qidAsTerm ind1) qidAsTerm ind2) ((bound nt1)(bound nt2)) =
     insert(qidAsTerm ind2 <T nt2, insert(qidAsTerm ind1 <T nt1, A)) .
 eq addAssumptions A ((qidAsTerm ind1) qidAsTerm ind2) ((bound nt1)(fixedBound nt2)) =
     insert(qidAsTerm ind2 =T= nt2, insert(qidAsTerm ind1 <T nt1, A)) .
 eq addAssumptions A ((qidAsTerm ind1) qidAsTerm ind2) ((fixedBound nt1)(bound nt2)) =
     insert(qidAsTerm ind2 <T nt2, insert(qidAsTerm ind1 =T= nt1, A)) .          
 eq addAssumptions A ((qidAsTerm ind1) qidAsTerm ind2) ((bound nt1)(dependentBound q)) =
     insert(qidAsTerm ind1 <T nt1, insert(qidAsTerm ind2 <T fun q (qidAsTerm ind1), A)) .
 eq addAssumptions A ((qidAsTerm ind1) qidAsTerm ind2) ((fixedBound nt1)(dependentBound q)) =
     insert(qidAsTerm ind1 =T= nt1, insert(qidAsTerm ind2 <T fun q (qidAsTerm ind1), A)) .    
 eq addAssumptions A 
      ((qidAsTerm ind1) (qidAsTerm ind2) qidAsTerm ind3) ((bound nt1)(bound nt2) (bound nt3)) =
     insert(qidAsTerm ind3 <T nt3,
     insert(qidAsTerm ind2 <T nt2, insert(qidAsTerm ind1 <T nt1, A))
     ) . 
 eq addAssumptions A 
     ((qidAsTerm ind1) (qidAsTerm ind2) qidAsTerm ind3) 
     ((fixedBound nt1)(bound nt2) (bound nt3)) =
     insert(qidAsTerm ind3 <T nt3,
     insert(qidAsTerm ind2 <T nt2, insert(qidAsTerm ind1 =T= nt1, A))
     ) .   
 eq addAssumptions A 
     ((qidAsTerm ind1) (qidAsTerm ind2) qidAsTerm ind3)
     ((bound nt1)(fixedBound nt2) (bound nt3)) =
     insert(qidAsTerm ind3 <T nt3,
     insert(qidAsTerm ind2 =T= nt2, insert(qidAsTerm ind1 <T nt1, A))
     ) .  
 eq addAssumptions A 
     ((qidAsTerm ind1) (qidAsTerm ind2) qidAsTerm ind3) 
     ((bound nt1)(bound nt2) (fixedBound nt3)) =
     insert(qidAsTerm ind3 =T= nt3,
     insert(qidAsTerm ind2 <T nt2, insert(qidAsTerm ind1 <T nt1, A))
     ) .            
 eq addAssumptions A 
     ((qidAsTerm ind1) (qidAsTerm ind2) qidAsTerm ind3) ((bound nt1)(bound nt2) (dependentBound q)) =
     insert(qidAsTerm ind3 <T fun q (qidAsTerm ind2),
     insert(qidAsTerm ind2 <T nt2, insert(qidAsTerm ind1 <T nt1, A))
     ) .  
 eq addAssumptions A 
     ((qidAsTerm ind1) (qidAsTerm ind2) qidAsTerm ind3) ((fixedBound nt1)(bound nt2) (dependentBound q)) =
     insert(qidAsTerm ind3 <T fun q (qidAsTerm ind2),
     insert(qidAsTerm ind2 <T nt2, insert(qidAsTerm ind1 =T= nt1, A))
     ) . 
 eq addAssumptions A 
     ((qidAsTerm ind1) (qidAsTerm ind2) qidAsTerm ind3) ((bound nt1)(fixedBound nt2) (dependentBound q)) =
     insert(qidAsTerm ind3 <T fun q (qidAsTerm ind2),
     insert(qidAsTerm ind2 =T= nt2, insert(qidAsTerm ind1 <T nt1, A))
     ) .   
 *** we are missing cases here?  
 eq addAssumptions A 
     ((qidAsTerm ind1) (qidAsTerm ind2) qidAsTerm ind3)
     ((bound nt1)(fixedBound nt2) (fixedBound nt3)) =
     insert(qidAsTerm ind3 =T= nt3,
     insert(qidAsTerm ind2 =T= nt2, insert(qidAsTerm ind1 <T nt1, A))
     ) .  
 eq addAssumptions A 
      ((qidAsTerm ind1) (qidAsTerm ind2) qidAsTerm ind3) 
      ((fixedBound nt1)(fixedBound nt2) (fixedBound nt3)) =
     insert(qidAsTerm ind3 =T= nt3,
     insert(qidAsTerm ind2 =T= nt2, insert(qidAsTerm ind1 =T= nt1, A))
     ) .                         
 
 *** a helper for turning a list of terms in a list of fixed bounds
 op toFixedBounds_ : List{NatTerm} -> List{Bounds} .
 eq toFixedBounds nlist = toFixedBoundsAux nlist nil .
 
 op toFixedBoundsAux__ : List{NatTerm} List{Bounds} -> List{Bounds} .
 eq toFixedBoundsAux nil blist = blist .
 eq toFixedBoundsAux (nt1 nlist) blist =
    toFixedBoundsAux nlist (blist (fixedBound nt1)) .
 
 *** a predicate to check that a protocol typechecks
 op typeOf : Signature ChannelContext Set{CNameBound} Set{BoolTerm} Protocol -> BoolWithError .

 
 ceq typeOf(Sigma, Delta, I, A, P) = 
     err ("I invalid for Delta")
 if not (validChanSet I Delta A) .
  
 eq typeOf(Sigma, Delta, I, A, P) = 
    *** validChanSet I Delta A 
    *** and 
    typeOfAux(Sigma, Delta, I, A, P)
    [owise]
 .
  
 op typeOfAux : Signature ChannelContext Set{CNameBound} 
                Set{BoolTerm} Protocol 
             -> BoolWithError .
 
 eq typeOfAux(Sigma, Delta, I, A, emptyProtocol) = true .

 ceq typeOfAux(Sigma, Delta, I, A, cn ::= R) = 
     err ("can't assign to an input:" + string(cn))
 if  isElemB(cn, I, A) .
 
 ceq typeOfAux(Sigma, Delta, I, A, cn ::= R) = 
     err ("type mismatch:" + string(cn))
 if  not(
     typeOf(Sigma, Delta, emptyTypeContext, I, A, R) 
     == 
     typeInCtx(chn cn, A, Delta)    
     )
 .  

 eq typeOfAux(Sigma, Delta, I, A, cn ::= R) = 
    typeOf(Sigma, Delta, emptyTypeContext, I, A, R) 
     == 
    typeInCtx(chn cn, A, Delta)
    and
    not isElemB(cn, I, A) [owise].
  
 eq typeOfAux(Sigma, Delta, I, A, P1 || P2) =
     typeOfAux(Sigma, Delta, union(I, getOutputs(P2)), A, P1) 
     and 
     typeOfAux(Sigma, Delta, union(I,  getOutputs(P1)), A, P2)
     .

 ceq typeOfAux(Sigma, Delta, I, A, new o : T in P) =
     err (string(o) + " already present in Delta")
     if occurs (chn o) Delta A .
  
 eq typeOfAux(Sigma, Delta, I, A, new o : T in P) =
     not occurs (chn o) Delta A
     and
     typeOfAux(Sigma, Delta ((chn o) :: T), I, A, P)
     [owise] . 

 ceq typeOfAux(Sigma, Delta, I, A, newfamily (c[blist]) nlist blist : T in P) =
     err ("family already occurs in Delta:" + string(c))
 if  occurs (fam (c[blist])) Delta A .

   
 eq typeOfAux(Sigma, Delta, I, A, newfamily c[blist] nlist blist : T in P) =
    not occurs (fam (c[blist])) Delta A
    and
    typeOfAux(Sigma, Delta ((fam (c[blist])) :: T), I, A, P) 
    [owise]
  .

 var cases : Cases . 
 var whenCond : WhenCond .
 var whenList : WhenList .
 
 var bt : BoolTerm .
 
 var ltq : TypedCNameList .   
 var ql : List{CNameBound} . 
 
 ceq typeOfAux(Sigma, Delta, I, A, family (c[blist]) nlist blist ::= R) = 
     err ("not occurs in Delta" + string(c))
 if not occurs (fam (c[blist])) Delta A
 . 
 
 ceq typeOfAux(Sigma, Delta, I, A, family (c[blist]) nlist blist ::= R) = 
     err ("type error for " + string(c))
 if not(    
     typeOf(Sigma, Delta, emptyTypeContext, insert((fam (c[blist])), I), 
            addAssumptions A nlist blist, R) == 
     typeInCtx((fam (c[blist])), addAssumptions A nlist blist, Delta) 
    ) 
 .

 eq typeOfAux(Sigma, Delta, I, A, family (c[blist]) nlist blist ::= R) = 
     occurs (fam (c[blist])) Delta A
     and *** here is where we add the assumptions about the vars in nlist for R!
     typeOf(Sigma, Delta, emptyTypeContext, insert((fam (c[blist])), I), 
            addAssumptions A nlist blist, R) == 
     typeInCtx((fam (c[blist])), addAssumptions A nlist blist, Delta) [owise]
 .


     
 eq typeOfAux(Sigma, Delta, I, A, family (c[blist]) nlist blist ::= P) = 
    typeOfAux(Sigma, Delta, I, A, P) . 
    
 eq typeOfAux(Sigma, Delta, I, A, family (('Comp[qidAsTerm q1 qidAsTerm q2])[blist]) nlist blist ::= P) = 
    typeOfAux(Sigma, Delta, I, A, P) .    
   
 eq typeOfAux(Sigma, Delta, I, A, family (c[blist]) nlist blist ::= (when bt --> R)) = 
     occurs (fam (c[blist]))  Delta A
     and
     typeOf(Sigma, Delta, emptyTypeContext, insert((fam (c[blist])), I), 
            insert(bt, addAssumptions A nlist blist), R) == 
      typeInCtx((fam (c[blist])), addAssumptions A nlist blist, Delta) 
 . 

 *** a helper
 op turnChannelsToFamilies___ : Protocol List{NatTerm} List{Bounds}-> Protocol .
eq turnChannelsToFamilies (cn[nlist] ::= cases) nlist blist = 
   family cn[blist] nlist blist ::= cases .
eq turnChannelsToFamilies (P1 || P2) nlist blist = 
   (turnChannelsToFamilies P1 nlist blist)
   || 
   (turnChannelsToFamilies P2 nlist blist) .   
eq turnChannelsToFamilies P nlist blist = P [owise] .

eq typeOfAux(Sigma, Delta, I, A, 
   family (c[blist]) nlist blist ::= 
     (whenCond --> (cn[nlist] ::= cases || P)) ) = 
    typeOfAux(Sigma, Delta, I, (whenCondToBoolTerm whenCond, A), 
               family (c[blist]) nlist blist ::= 
                (turnChannelsToFamilies
                  (cn[nlist] ::= cases || P)
                  nlist blist
                )
               )
 . 
eq typeOfAux(Sigma, Delta, I, A, 
   family (c[blist]) nlist blist ::= 
     (when bt --> (cn[nlist] ::= cases || P)) ;; whenList) = 
    typeOfAux(Sigma, Delta, I, insert(bt, A), 
               family (c[blist]) nlist blist ::= 
                (turnChannelsToFamilies
                  (cn[nlist] ::= cases || P)
                  nlist blist
                )
               )
    and
    typeOfAux(Sigma, Delta, I, insert(neg bt, A), family (c[blist]) nlist blist ::= whenList)  
 . *** TODO: same sets of outputs for each case

 
  eq typeOfAux(Sigma, Delta, I, A, family (c[blist]) nlist blist ::= (otherwise --> R)) = 
     occurs (fam (c[blist]))  Delta A
     and
     typeOf(Sigma, Delta, emptyTypeContext, 
            insert((fam (c[blist])), I), addAssumptions A nlist blist, R)
      == 
      typeInCtx((fam (c[blist])), addAssumptions A nlist blist, Delta) 
  .    

   eq typeOfAux(Sigma, Delta , I, A, family (c[blist]) nlist blist ::= (otherwise --> P)) = 
      typeOfAux(Sigma, Delta , I, A, P) .
     
   eq typeOfAux(Sigma, Delta , I, A, family (c[blist]) nlist blist ::= (when bt --> P)) = 
      typeOfAux(Sigma, Delta , I, insert(bt, A), P) .       
    
 eq typeOfAux(Sigma, Delta, I, A, 
               family (c[blist]) nlist blist ::= (when bt --> R) ;; whenList) = 
    typeOfAux(Sigma, Delta, I, addAssumptions A nlist blist , 
              family (c[blist]) nlist blist ::= (when bt --> R))
    and
    typeOfAux(Sigma, Delta, I, insert(neg bt, addAssumptions A nlist blist), 
              family (c[blist]) nlist blist ::= whenList) 
    .
 
 eq typeOfAux(Sigma, Delta, I, A, family (c[blist]) nlist blist ::= 
                                    (when bt --> P) ;; whenList) = 
    typeOfAux(Sigma, Delta, I, insert(bt, A), family (c[blist]) nlist blist ::= P)
    and
    typeOfAux(Sigma, Delta, I, insert(neg bt, A), family (c[blist]) nlist blist ::= whenList)  
 . *** TODO: same sets of outputs for each case

 *** same for channels with cases
 eq typeOfAux(Sigma, Delta, I, A, cn ::= (when bt --> R)) = 
     occurs (chn cn)  Delta A
     and
     typeOf(Sigma, Delta, emptyTypeContext, insert(chn cn, I), 
            insert(bt, A), R) == 
      typeInCtx(chn cn, A, Delta) 
 . 
 
  eq typeOfAux(Sigma, Delta, I, A, cn ::= (otherwise --> R)) = 
     occurs (chn cn)  Delta A
     and
     typeOf(Sigma, Delta, emptyTypeContext, 
            insert(chn cn, I), A, R)
      == 
      typeInCtx(chn cn, A, Delta) 
  .  

   eq typeOfAux(Sigma, Delta, I, A, 
               cn ::= (when bt --> R) ;; whenList) = 
    typeOfAux(Sigma, Delta, I, A , 
              cn ::= (when bt --> R))
    and
    typeOfAux(Sigma, Delta, I, insert(neg bt, A), 
              cn ::= whenList) 
    .  

  
 eq typeOfAux(Sigma, Delta, I, A, newNF(ltq, P)) = 
    typeOfAux(Sigma, Delta, I, A, newNF2New(newNF(ltq, P)))
    .  
  
 *** check that the names in a typed list
 *** are new for a channel context
 op allNew___ : TypedCNameList ChannelContext Set{BoolTerm} -> Bool .
 eq allNew emptyTypedCNameList Delta A = true .
 eq allNew (< cn : T > ltq) Delta A = not (occurs (chn cn) Delta A) and allNew ltq Delta A .
 eq allNew ({(c[blist]) nlist : T } ltq) Delta A = 
     not (occurs (fam (c[blist])) Delta A) 
     and allNew ltq Delta A .
 
 *** extend a channel context with the names in a typed list
 *** we will do this for new normal forms
 op addChannels__ : TypedCNameList ChannelContext -> ChannelContext .
 eq addChannels emptyTypedCNameList Delta = Delta .   
 eq addChannels (< cn : T > ltq) Delta = addChannels ltq (Delta (chn cn :: T) ) .
 eq addChannels ({(c[blist]) nlist : T } ltq) Delta = 
    addChannels ltq (Delta (fam (c[blist]) :: T) ) .
    
 op chansToCtx_ : TypedCNameList -> ChannelContext .
 eq chansToCtx  emptyTypedCNameList = emptyChannelCtx .
 eq chansToCtx (< cn : T > ltq) = (chn cn :: T) (chansToCtx ltq) .
 eq chansToCtx ({(c[blist]) nlist : T } ltq) = (fam (c[blist]) :: T) (chansToCtx ltq) .  
 
endfm

fmod PROTOCOL-CONFIG is
 protecting PROTOCOL .
 protecting SIGNATURE .
 protecting CHANNEL .
 protecting SET{CNameBound} .
 protecting TYPE-CONTEXT .

 var fns fns1 fns2 cns cns1 cns2 : NameWithScripts . 

 var Sigma : Signature .
 vars Delta D Delta' Delta1 Delta2 : ChannelContext .
 vars R R' R1 R2 R3 R4 S1 S2 S : Reaction .
 vars T T0 T1 T2 T3 : IPDLType .
 vars M M1 M2 : IPDLExpression .
 vars I I' I'' I1 O O' O'' O1 O2 O3 : Set{CNameBound} . 
 var l r c i o o1 o2 o3 : ChannelName .
 var b x x0 x1 x2 y y0 y1 y2 z : ChannelName . *** was Qid 
 vars P P1 P2 P3 P4 Q : Protocol .
 var n : Nat .
 var lq : List{NatTerm} .
 var ltq ltq1 ltq2 : TypedCNameList .
 var Dist : Distribution .
 var q : Qid .
 var ql ql1 ql2 : List{NatTerm} .
     var bt : BoolTerm .  
    var C C' q' : Qid .
    var m : Nat .
  var nt nt1 nt2 : NatTerm .
  var nlist nlist' : List{NatTerm} .
 var cases : Cases .
 var blist blist' : List{Bounds} .
 var cn : ChannelName .
 var bn : CNameBound .   

 
  var BRL : BRList .
 var QL : List{NatTerm} .
 var A A' : Set{BoolTerm} .
 var nlist1 nlist2 : List{NatTerm} . 
  var qid1 qid2 : Qid .
    var q1 q2 idx : Qid .
  var cn1 cn2 : ChannelName .  
     var T' : IPDLType .
     
      var nj nt' : NatTerm .
     var ntl qlist : List{NatTerm} .
     var bounds : List{Bounds} .
     var cases' : Cases .
     
     

 *** similar to reactions, we write configurations

 sort ProtocolConfig . 
 op pConfig : 
              Signature ChannelContext Protocol 
              Set{CNameBound} Set{CNameBound} Set{BoolTerm} -> 
              ProtocolConfig [ctor] .

 op eConfig : -> ProtocolConfig .             
 eq eConfig = 
    pConfig(typesOf('unit ; ('bool ; 'nat)), emptyChannelCtx, 
      emptyProtocol
    , empty, empty, empty) . 

 

endfm


mod PROTOCOL-EQ-HELPERS is 
 protecting PROTOCOL-TYPING .
 protecting REACTION-EQUALITY .
 protecting SET{BoolTerm} .
 protecting PROTOCOL-CONFIG .
 
  var fns fns1 fns2 cns cns1 cns2 : NameWithScripts . 

 var Sigma : Signature .
 vars Delta D Delta' : ChannelContext .
 vars R R' R1 R2 R3 R4 S1 S2 S : Reaction .
 vars T T0 T1 T2 T3 : IPDLType .
 vars M M1 M2 : IPDLExpression .
 vars I I' I'' I1 O O' O'' O1 O2 O3 : Set{CNameBound} . 
 var l r c i o o1 o2 o3 : ChannelName .
 var b x x0 x1 x2 y y0 y1 y2 z : ChannelName . *** was Qid 
 vars P P1 P2 P3 P4 Q : Protocol .
 var n : Nat .
 var lq : List{NatTerm} .
 var ltq ltq1 ltq2 : TypedCNameList .
 var Dist : Distribution .
 var q : Qid .
 var ql ql1 ql2 : List{CNameBound} .
      var bt bt1 : BoolTerm .  
    var C C' q' q'' : Qid .
    var m : Nat .
  var nt nt1 nt2 : NatTerm .
  var nlist nlist' : List{NatTerm} .
 var cases : Cases .
 var blist blist' : List{Bounds} .
 var cn : ChannelName .
 var bn cnb : CNameBound .   

 
  var BRL : BRList .
 var QL : List{NatTerm} .
 var A : Set{BoolTerm} .
 var nlist1 nlist2 qlist : List{NatTerm} . 
  var qid1 qid2 : Qid .
    var q1 q2 : Qid .
  var cn1 cn2 : ChannelName .  
     var T' : IPDLType .
     
      var nj nt' : NatTerm .
     var ntl : List{NatTerm} .
     var bounds : List{Bounds} .
     var cases' : Cases .

    var f : Map{Qid, NatTerm} .
    var F idx : Qid .
    var whenList whenList1 whenList2 : WhenList .
    var whenCond : WhenCond .
    var bd1 bd2 bd3 bd : Bounds .
    
     var BL : BRList .
    
 *** given a channel/family and a protocol, checks whether the protocol reads from it
 
 op readsFromSet__ : Protocol Set{CNameBound} -> Bool .
 eq readsFromSet P empty = false .
 eq readsFromSet P (cnb, O) = (readsFrom P cnb) or (readsFromSet P O) .
 
 op readsFrom__ : Protocol CNameBound -> Bool .
 eq readsFrom emptyProtocol cnb = false .
 eq readsFrom (P1 || P2) cnb = 
    (readsFrom P1 cnb) or (readsFrom P2 cnb) . 
 eq readsFrom (new cn : T in P) cnb =  readsFrom P cnb . 
 eq readsFrom (newfamily cn[blist] nlist blist : T in P) cnb =  readsFrom P cnb .  
 eq readsFrom (newNF(ltq, P)) cnb =  readsFrom P cnb .
 eq readsFrom (family cn[blist] nlist blist ::= cases) cnb = 
    readsFrom cases cnb .
 eq readsFrom (cn ::= cases) cnb = 
    readsFrom cases cnb .
 
 op readsFrom__ : Reaction CNameBound -> Bool .
 eq readsFrom (return M) cnb = false .
 eq readsFrom (samp Dist) cnb = false .
 eq readsFrom (if M then R1 else R2) cnb =
    readsFrom R1 cnb or readsFrom R2 cnb .   
  eq readsFrom (i : T <- R1 ; R2) cnb = 
    readsFrom R1 cnb or readsFrom R2 cnb .
 eq readsFrom (nf(BL, R)) cnb = readsFrom R cnb .
 eq readsFrom (preNF(BL, R)) cnb = readsFrom R cnb .
 eq readsFrom (read cn) (chn cn) = true .
 eq readsFrom (read (fns[ntl])) (fam (fns[blist])) = true .
    *** this is wrong, ntl must be in bounds!
 eq readsFrom (read cn1) cnb = false [owise] .
 
 op readsFrom__ : WhenList CNameBound -> Bool .
 eq readsFrom (whenCond --> R) cnb = readsFrom R cnb .
 eq readsFrom ((whenCond --> R) ;; whenList) cnb = 
    (readsFrom R cnb) or (readsFrom whenList cnb) . 
 eq readsFrom (whenCond --> P) cnb = readsFrom P cnb .
 eq readsFrom ((whenCond --> P) ;; whenList) cnb = 
    (readsFrom P cnb) or (readsFrom whenList cnb) . 

  *** extend a given Delta with the internal channels of a protocol
 op addInternalChannels__ : ChannelContext Protocol -> ChannelContext .
 eq addInternalChannels Delta newNF(ltq, P) = addChannels ltq Delta .
 eq addInternalChannels Delta P = Delta [owise] .
   
  ***  op toBounds__ : ChannelName List{Bounds} -> CNameBound .
  ***  eq toBounds cn bounds = cn @ bounds .
  
  op toBound_ : ChannelName -> CNameBound .
  eq toBound cn = chn cn .
    
    *** rename variable in cases
 op alphaCases___ : Cases Qid Qid -> Cases .
 eq alphaCases R q q' = replaceVars(R, q |-> qidAsTerm q') .
 eq alphaCases (when bt --> R) q q' = 
    when (subst(bt, q |-> qidAsTerm q')) --> replaceVars(R, q |-> qidAsTerm q') .
 eq alphaCases (otherwise --> R) q q' = otherwise --> replaceVars(R, q |-> qidAsTerm q') .
 eq alphaCases ((whenCond --> R) ;; whenList) q q' =
    (alphaCases (whenCond --> R) q q') 
    ;;
    (alphaCases whenList q q')
 .   
    
   op getFamilyNames_ : Protocol -> List{CNameBound} .
   eq getFamilyNames (family (fns[blist]) nlist blist ::= (whenCond --> P) ;; whenList) = 
      getFamilyNamesAux P .
      
   
   op getFamilyNamesAux_ : Protocol -> List{CNameBound} .
   eq getFamilyNamesAux (family (cn[blist]) nlist blist ::= cases) = 
       (fam (cn[blist])) .
   eq getFamilyNamesAux (cn ::= cases) = chn cn .   
   eq getFamilyNamesAux (P || (family (cn[blist]) nlist blist ::= cases)) = 
      (fam (cn[blist])) (getFamilyNamesAux P) .
   eq getFamilyNamesAux (P || (cn ::= cases)) = 
      (chn cn) (getFamilyNamesAux P) .   
 
   op addCondToCases__ : WhenCond Cases -> Cases .
   eq addCondToCases otherwise R = otherwise --> R .
   eq addCondToCases otherwise whenList = whenList .
   eq addCondToCases (when bt) R = when bt --> R .
   eq addCondToCases (when bt) (when bt1 --> R) = when (bt conj bt1) --> R .
   eq addCondToCases (when bt) (otherwise --> R) = when bt --> R .
   eq addCondToCases (when bt) ((when bt1 --> R) ;; whenList) = 
     (when (bt conj bt1) --> R) ;; addCondToCases (when bt) whenList .  
  
  op combineOneFamTop___ : List{Bounds} Protocol WhenList -> Protocol .    
   eq combineOneFamTop blist P whenList = 
      chnToFam blist 
       (tryDivergeLast (tryGatherCases (tryAllSameReaction (combineOne P whenList)))) .
       
   op chnToFam__ : List{Bounds} Protocol -> Protocol .
   eq chnToFam blist (fns[nlist] ::= cases) 
    = family fns[blist] nlist blist ::= cases .

   var whenList3 : WhenList .   
       
   op combineOneTop__ : Protocol WhenList -> Protocol .
   eq combineOneTop P whenList = 
      tryDivergeLast (tryGatherCases (tryAllSameReaction (combineOne P whenList))) .
      
   op tryAllSameReaction_ : Protocol -> Protocol .   
   ceq tryAllSameReaction (cn ::= (whenCond --> R) ;; whenList) 
      = cn ::= R 
    if allSameReaction whenList R .
    eq tryAllSameReaction P = P [owise] . 
    
   op tryGatherCases_ : Protocol -> Protocol . 
   eq tryGatherCases 
      (cn ::= whenList1 ;; 
             (when bt --> R1) ;; 
             whenList2 ;; 
             (when bt1 --> R1) ;;
             whenList3
             ) =
       tryGatherCases (cn ::= whenList1 ;; 
             (when (simplify empty (bt disj bt1) empty) --> R1) ;; 
             whenList2 ;; 
             whenList3
             ) .     
   eq tryGatherCases P = P [owise] .
   
   op tryDivergeLast_ : Protocol -> Protocol .
   eq tryDivergeLast 
     (cn ::= whenList1 ;; 
             (whenCond --> nf(x : T <- read cn , return x)) ;;
             whenList2 
             )
   = cn ::= whenList1 ;; whenList2 ;; (whenCond --> nf(x : T <- read cn , return x)) .
   eq tryDivergeLast P = P [owise] .         
     
   op combineOne__ : Protocol WhenList -> Protocol .
   eq combineOne (family (fns[blist]) nlist blist ::= whenList1) 
                 (whenCond --> (P || family (fns[blist]) nlist blist ::= cases)) =
      family (fns[blist]) nlist blist ::= whenList1 ;; (addCondToCases whenCond cases) .  
   eq combineOne (family (fns[blist]) nlist blist ::= whenList1) 
                 ((whenCond --> (P || family (fns[blist]) nlist blist ::= cases)) ;; whenList2) =
      combineOne (family (fns[blist]) nlist blist ::= 
                   whenList1 ;; (addCondToCases whenCond cases))
                 whenList2 .
   eq combineOne (cn ::= whenList1) 
                 (whenCond --> (P || cn ::= cases)) =
      cn ::= whenList1 ;; (addCondToCases whenCond cases) .  
   eq combineOne (cn ::= whenList1) 
                 ((whenCond --> (P || cn ::= cases)) ;; whenList2) =
      combineOne (cn ::= 
                   whenList1 ;; (addCondToCases whenCond cases))
                 whenList2 .              
   *** also cover case with only one family on the branch
   eq combineOne (family (fns[blist]) nlist blist ::= whenList1) 
                 (whenCond --> (family (fns[blist]) nlist blist ::= cases)) =
      family (fns[blist]) nlist blist ::= whenList1 ;; (addCondToCases whenCond cases) .  
   eq combineOne (family (fns[blist]) nlist blist ::= whenList1) 
                 ((whenCond --> (family (fns[blist]) nlist blist ::= cases)) ;; whenList2) =
      combineOne (family (fns[blist]) nlist blist ::= 
                   whenList1 ;; (addCondToCases whenCond cases))
                 whenList2 .               
                    
   var cNameList : List{CNameBound} . 
   op combineAux___ : List{CNameBound} Protocol WhenList -> Protocol .              
   eq combineAux nil P whenList = P .
   eq combineAux ((fam (fns[blist])) cNameList) emptyProtocol 
       ((whenCond --> ((family (fns[blist]) nlist blist ::= cases) || P1) ) ;; whenList) =
      combineAux cNameList 
     
      (combineOne (family (fns[blist]) nlist blist ::= emptyWhen)
                  ((whenCond --> ((family (fns[blist]) nlist blist ::= cases) || P1)) ;; whenList)
      )
     
     ((whenCond --> ((family (fns[blist]) nlist blist ::= cases) || P1)) ;; whenList)
   .
   eq combineAux ((chn cn) cNameList) emptyProtocol 
       ((whenCond --> ((cn ::= cases) || P1) ) ;; whenList) =
      combineAux cNameList 
     
      (combineOne (cn ::= emptyWhen)
                  ((whenCond --> ((cn ::= cases) || P1)) ;; whenList)
      )
     
     ((whenCond --> ((cn ::= cases) || P1)) ;; whenList)
   .
   eq combineAux ((fam (fns[blist])) cNameList) P 
       ((whenCond --> ((family (fns[blist]) nlist blist ::= cases) || P1) ) ;; whenList) =
      combineAux cNameList 
     (P || 
      (combineOne (family (fns[blist]) nlist blist ::= emptyWhen)
                  ((whenCond --> ((family (fns[blist]) nlist blist ::= cases) || P1)) ;; whenList)
      )
     )
     ((whenCond --> ((family (fns[blist]) nlist blist ::= cases) || P1)) ;; whenList)
   . 
    eq combineAux ((chn cn) cNameList) P 
       ((whenCond --> ((cn ::= cases) || P1) ) ;; whenList) =
      combineAux cNameList 
     (P || 
      (combineOne (cn ::= emptyWhen)
                  ((whenCond --> ((cn ::= cases) || P1)) ;; whenList)
      )
     )
     ((whenCond --> ((cn ::= cases) || P1)) ;; whenList)
   . 
    
   *** also cover one family on each branch
   eq combineAux ((fam (fns[blist])) cNameList) emptyProtocol 
       ((whenCond --> (family (fns[blist]) nlist blist ::= cases) ) ;; whenList) =
      combineAux cNameList 
     
      (combineOne (family (fns[blist]) nlist blist ::= emptyWhen)
                  ((whenCond --> (family (fns[blist]) nlist blist ::= cases)) ;; whenList)
      )
     
     ((whenCond --> (family (fns[blist]) nlist blist ::= cases) ) ;; whenList)
   .
   eq combineAux ((fam (fns[blist])) cNameList) P 
       ((whenCond --> (family (fns[blist]) nlist blist ::= cases)  ) ;; whenList) =
      combineAux cNameList 
     (P || 
      (combineOne (family (fns[blist]) nlist blist ::= emptyWhen)
                  ((whenCond --> (family (fns[blist]) nlist blist ::= cases) ) ;; whenList)
      )
     )
     ((whenCond --> (family (fns[blist]) nlist blist ::= cases)) ;; whenList)
   . 

  *** turn channel into family
   
    op combineAuxFam____ : List{CNameBound} Protocol List{Bounds} WhenList -> Protocol .     
    eq combineAuxFam nil P blist whenList = P .
   eq combineAuxFam ((fam (fns[blist])) cNameList) emptyProtocol blist
       ((whenCond --> ((family (fns[blist]) nlist blist ::= cases) || P1) ) ;; whenList) =
      combineAuxFam cNameList 
     
      (combineOneFamTop blist (family (fns[blist]) nlist blist ::= emptyWhen)
                  ((whenCond --> ((family (fns[blist]) nlist blist ::= cases) || P1)) ;; whenList)
      )
     blist
     ((whenCond --> ((family (fns[blist]) nlist blist ::= cases) || P1)) ;; whenList)
   .
   eq combineAuxFam ((chn cn) cNameList) emptyProtocol blist
       ((whenCond --> ((cn ::= cases) || P1) ) ;; whenList) =
      combineAuxFam cNameList 
     
      (combineOneFamTop blist (cn ::= emptyWhen)
                  ((whenCond --> ((cn ::= cases) || P1)) ;; whenList)
      )
     blist
     ((whenCond --> ((cn ::= cases) || P1)) ;; whenList)
   .
   eq combineAuxFam ((fam (fns[blist])) cNameList) P blist
       ((whenCond --> ((family (fns[blist]) nlist blist ::= cases) || P1) ) ;; whenList) =
      combineAuxFam cNameList 
     (P || 
      (combineOneFamTop blist (family (fns[blist]) nlist blist ::= emptyWhen)
                  ((whenCond --> ((family (fns[blist]) nlist blist ::= cases) || P1)) ;; whenList)
      )
     ) blist
     ((whenCond --> ((family (fns[blist]) nlist blist ::= cases) || P1)) ;; whenList)
   . 
    eq combineAuxFam ((chn cn) cNameList) P blist
       ((whenCond --> ((cn ::= cases) || P1) ) ;; whenList) =
      combineAuxFam cNameList 
     (P || 
      (combineOneFamTop blist (cn ::= emptyWhen)
                  ((whenCond --> ((cn ::= cases) || P1)) ;; whenList)
      )
     ) blist
     ((whenCond --> ((cn ::= cases) || P1)) ;; whenList)
   . 
    
   *** also cover one family on each branch
   eq combineAuxFam ((fam (fns[blist])) cNameList) emptyProtocol blist
       ((whenCond --> (family (fns[blist]) nlist blist ::= cases) ) ;; whenList) =
      combineAuxFam cNameList 
     
      (combineOneFamTop blist (family (fns[blist]) nlist blist ::= emptyWhen)
                  ((whenCond --> (family (fns[blist]) nlist blist ::= cases)) ;; whenList)
      )
     blist
     ((whenCond --> (family (fns[blist]) nlist blist ::= cases) ) ;; whenList)
   .
   eq combineAuxFam ((fam (fns[blist])) cNameList) P blist
       ((whenCond --> (family (fns[blist]) nlist blist ::= cases)  ) ;; whenList) =
      combineAuxFam cNameList 
     (P || 
      (combineOneFamTop blist (family (fns[blist]) nlist blist ::= emptyWhen)
                  ((whenCond --> (family (fns[blist]) nlist blist ::= cases) ) ;; whenList)
      )
     ) blist
     ((whenCond --> (family (fns[blist]) nlist blist ::= cases)) ;; whenList)
   .

   
    *** switch to combined notation
   *** family 'Group i n ::= 
   ***   when bt -->    C[i] ::= R1
   ***   otherwise -->  C[i] ::= R2
   *** gets rephrased to
   *** family C i n ::= 
   ***  when bt --> R1
   ***  otherwise --> R2
   
   op newCombine : Protocol -> Protocol .
   eq newCombine(newfamily (fns[blist]) nlist blist : T in P) = 
      newfamily (fns[blist]) nlist blist : T in (newCombine(P)) .
   eq newCombine(newNF(ltq, P)) = newNF(ltq, newCombine(P)) .
   eq newCombine 
       (family (fns[blist]) nlist blist ::= (whenCond --> P) ;; whenList) =
      combineAux 
        (getFamilyNames (family (fns[blist]) nlist blist ::= (whenCond --> P) ;; whenList)) 
        emptyProtocol 
        ((whenCond --> P) ;; whenList) .   
   
   *** same but turn C[n m k] into a family
   op newCombineFam : Protocol -> Protocol .
   eq newCombineFam(newfamily (fns[blist]) nlist blist : T in P) = 
      newfamily (fns[blist]) nlist blist : T in (newCombineFam(P)) .
   eq newCombineFam(newNF(ltq, P)) = newNF(ltq, newCombineFam(P)) .
   eq newCombineFam 
       (family (fns[blist]) nlist blist ::= (whenCond --> P) ;; whenList) =
      combineAuxFam 
        (getFamilyNames (family (fns[blist]) nlist blist ::= (whenCond --> P) ;; whenList)) 
        emptyProtocol 
        blist
        ((whenCond --> P) ;; whenList) .       

   ***(        
   op combine_____ : Qid NatTerm BoolTerm Protocol Protocol -> Protocol .
   eq combine q n bt (fns[q] ::= R1) (fns[q] ::= R2) = 
      family fns q (bound n) ::= ((when bt --> R1) ;; (otherwise --> R2)) .
   eq combine q n bt (family fns q' (bound m) ::= R1) (family fns q' (bound m) ::= R2) = 
      family fns (q q') ((bound n) (bound m)) ::= ((when bt --> R1) ;; (otherwise --> R2)) .
   eq combine q n bt (family fns q (bound m) ::= R1) (family fns q (bound m) ::= R2) = 
      family fns q (bound m) ::= ((when bt --> R1) ;; (otherwise --> R2)) .   
   eq combine q n bt (P1 || fns[q] ::= R1) (P2 || fns[q] ::= R2) = 
      (family fns q (bound n) ::= ((when bt --> R1) ;; (otherwise --> R2)))
      ||
      combine q n bt P1 P2 . 
   eq combine q n bt (P1 || family fns q' (bound m) ::= R1) 
                     (P2 || family fns q' (bound m) ::= R2) = 
      (family fns (q q') ((bound n) (bound m)) ::= ((when bt --> R1) ;; (otherwise --> R2)) )
      ||
      combine q n bt P1 P2 .
    eq combine q n bt (P1 || family fns q (bound m) ::= R1) 
                      (P2 || family fns q (bound m) ::= R2) = 
      (family fns q (bound m) ::= ((when bt --> R1) ;; (otherwise --> R2)) )
      ||
      combine q n bt P1 P2 .   
  ***( eq combine q n bt (P1 || (cn ::= R1)) (P2 || (cn ::= R2)) = 
      (cn ::= ((when bt --> R1) ;; (otherwise --> R2)) ) ||
      combine q n bt P1 P2 . )
   eq combine q n bt P1 P2 = emptyProtocol [owise] .     
 )  
 
 op updateAt____ : Qid Qid List{NatTerm} List{Bounds} -> List{Bounds} .
 eq updateAt q idx (qidAsTerm q') bd1 = 
      if q == q' then bound (qidAsTerm idx) else bd1 fi .
 eq updateAt q idx ((qidAsTerm q') nlist) (bd1 bounds) = 
    ((updateAt q idx (qidAsTerm q') bd1) (updateAt q idx nlist bounds))
 . 
 
 op fixedAt____ : Qid Qid List{NatTerm} List{Bounds} -> List{Bounds} .
 eq fixedAt q idx (qidAsTerm q') bd1 = 
      if q == q' then fixedBound (qidAsTerm idx) else bd1 fi .
 eq fixedAt q idx ((qidAsTerm q') nlist) (bd1 bounds) = 
    ((fixedAt q idx (qidAsTerm q') bd1) (fixedAt q idx nlist bounds))
 . 
 
 ***
 var f1 f2 : Qid .
 op adjustIndexP___ : Qid Qid Protocol -> Protocol .
 eq adjustIndexP q idx (family ('Comp[(qidAsTerm f1) qidAsTerm f2][blist]) nlist blist ::=
    ((family (f1[blist]) nlist blist ::= cases) || 
     (family (f2[blist]) nlist blist ::= cases')
    )
   ) =
   (adjustIndexP q idx (family (f1[blist]) nlist blist ::= cases))
   ||
   (adjustIndexP q idx (family (f2[blist]) nlist blist ::= cases'))
 .  
 eq adjustIndexP q idx (family (fns[blist]) qlist blist ::= P) =
     family (fns[(updateAt q idx qlist blist)]) qlist (updateAt q idx qlist blist) ::=  
        adjustIndexP q idx P .
 eq adjustIndexP q idx 
    (family (fns[blist]) qlist blist ::= 
       (whenCond --> P)
    ) =
    family (fns[(updateAt q idx qlist blist)]) qlist (updateAt q idx qlist blist) ::=
     whenCond --> adjustIndexP q idx P 
    .
 eq adjustIndexP q idx 
    (family (fns[blist]) qlist blist ::= 
       ((whenCond --> P) ;; whenList)
    ) =
     addBranch(whenCond, adjustIndexP q idx P , 
     adjustIndexP q idx 
    (family (fns[blist]) qlist blist ::= 
        whenList 
    )
    ) 
    .   
          
 eq adjustIndexP q idx (family (fns[blist]) qlist blist ::= cases) =  
     family (fns[(updateAt q idx qlist blist)]) qlist (updateAt q idx qlist blist) ::= cases 
 [owise]    
     . 
 eq adjustIndexP q idx ((family (fns[blist]) qlist blist ::= cases) || P) =  
     (family (fns[(updateAt q idx qlist blist)]) qlist (updateAt q idx qlist blist) ::= cases)
     ||
     adjustIndexP q idx P .
 *** wrong for now but make it go through
 eq adjustIndexP q idx (cn ::= cases) = cn ::= cases .
 eq adjustIndexP q idx ( (cn ::= cases) || P) =  
      (cn ::= cases)
     ||
     adjustIndexP q idx P .
 
 var blist1 : List{Bounds} .
 
  *** delete a family from each branch of a whenList
 op removeFromEachBranch__ : CNameBound WhenList -> WhenList .
 eq removeFromEachBranch 
     (fam (fns1[blist1]))
     (whenCond --> (P || family (fns1[blist1]) nlist1 blist1 ::= cases)) = 
     whenCond --> P .
 eq removeFromEachBranch  (fam (fns1[blist1])) emptyWhen = emptyWhen .
 eq removeFromEachBranch 
     (fam (fns1[blist1]))  
     (
     (whenCond --> (P || family (fns1[blist1]) nlist1 blist1 ::= cases))
     ;;
     whenList
     ) =
     (whenCond --> P)
     ;;
     (removeFromEachBranch (fam (fns1[blist1])) whenList) .
     
 *** check that a family is assigned same thing on each branch of a when list
 op sameOnEachBranch___ : CNameBound Cases WhenList -> Bool .
 eq sameOnEachBranch (fam (fns1[blist1])) cases emptyWhen = true .
 eq sameOnEachBranch 
     (fam (fns1[blist1])) cases 
     (
     (whenCond --> (P || family (fns1[blist1]) nlist1 blist1 ::= cases))
     ;;
     whenList
     ) = sameOnEachBranch (fam (fns1[blist1])) cases whenList .
 eq sameOnEachBranch 
     (fam (fns1[blist1])) cases 
     whenList = false [owise] .  
   
   *** checks that we have the same reaction on every case in a list       
   op allSameReaction__ : WhenList Reaction -> Bool .
   eq allSameReaction emptyWhen R = true .
   eq allSameReaction ((whenCond --> R1) ;; whenList)  R2 = 
      (R1 == R2) and allSameReaction whenList R2 .  
      
      *** checks that we have the same protocol on every case in a list       
   op allSameProtocol__ : WhenList Protocol -> Bool .
   eq allSameProtocol emptyWhen P = true .
   eq allSameProtocol ((whenCond --> P1) ;; whenList)  P2 = 
      (P1 == P2) and allSameProtocol whenList P2 .          
     
     *** only interested in C[idx], so no families
     op isSubprotocolOf__ : Protocol Protocol -> Bool .
     eq isSubprotocolOf (cn ::= cases) P = 
        (cn ::= cases) == keepOne P (chn cn) .
     eq isSubprotocolOf (family (fns[blist]) nlist blist ::= cases) P =
        (family (fns[blist]) nlist blist ::= cases) == keepOne P (fam (fns[blist])) .    
     eq isSubprotocolOf ((cn ::= cases) || P1) P = 
        (cn ::= cases) == keepOne P (chn cn) 
        and
        isSubprotocolOf P1 P .
     eq isSubprotocolOf ((family (fns[blist]) nlist blist ::= cases)|| P1) P =
        (family (fns[blist]) nlist blist ::= cases) == keepOne P (fam (fns[blist]))
        and
        isSubprotocolOf P1 P .    
               
     *** auxiliary for induction 
     op adjustIndex__ : Protocol NatTerm -> Protocol .
     eq adjustIndex (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= cases) (qidAsTerm idx) = 
                     family (fns[bound (qidAsTerm idx)]) (qidAsTerm q) (bound (qidAsTerm idx)) ::= cases .   
     eq adjustIndex ((family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= cases) || P) 
                    (qidAsTerm idx) = 
                    (family (fns[bound (qidAsTerm idx)]) (qidAsTerm q) (bound (qidAsTerm idx)) ::= cases) 
                    || 
                    adjustIndex P (qidAsTerm idx) .
                                         
     *** for families with two indices
     op adjustIndex1__ : Protocol NatTerm -> Protocol .
     eq adjustIndex1 (family (fns[bd1 bd2]) ((qidAsTerm q) qidAsTerm q') (bd1 bd2) ::= cases) 
                     (qidAsTerm idx) = 
                     family (fns[(bound (qidAsTerm idx)) bd2]) ((qidAsTerm q) qidAsTerm q') 
                      ((bound (qidAsTerm idx)) bd2) ::= cases .
     eq adjustIndex1 ((family (fns[bd1 bd2]) ((qidAsTerm q) qidAsTerm q') (bd1 bd2) ::= cases) || P) 
                     (qidAsTerm idx) = 
                     (family (fns[(bound (qidAsTerm idx)) bd2]) ((qidAsTerm q) qidAsTerm q') ((bound (qidAsTerm idx)) bd2) ::= cases)
                     || adjustIndex1 P (qidAsTerm idx) .
        
     op adjustIndex2__ : Protocol NatTerm -> Protocol .
     eq adjustIndex2 (family (fns[bd1 bd2]) ((qidAsTerm q) qidAsTerm q') (bd1 bd2) ::= cases) 
                     (qidAsTerm idx) = 
                     family (fns[bd1 (bound (qidAsTerm idx))]) ((qidAsTerm q) qidAsTerm q') 
                      (bd1 (bound (qidAsTerm idx))) ::= cases .
     eq adjustIndex2 ((family (fns[bd1 bd2]) ((qidAsTerm q) qidAsTerm q') (bd1 bd2) ::= cases) || P) 
                     (qidAsTerm idx) = 
                     (family (fns[bd1 (bound (qidAsTerm idx))]) ((qidAsTerm q) qidAsTerm q') 
                             (bd1 (bound (qidAsTerm idx))) ::= cases) 
                     || adjustIndex2 P (qidAsTerm idx) .
           
     op getInductionBase____ : Protocol Protocol Qid Set{BoolTerm} -> Protocol .
     eq getInductionBase (newfamily (fns[bound nt]) (qidAsTerm q) (bound nt) : T in P) P2 idx A =
        getInductionBase P P2 idx A .
     eq getInductionBase ( P || family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= P1) P2 idx A =
        P || (family (fns[bound nt]) (qidAsTerm q) (bound (qidAsTerm idx)) ::= 
        (adjustIndex P2 (qidAsTerm idx))) 
                 || substIndex P1 q (qidAsTerm idx) A .
     
 op mapFromLists__ : List{NatTerm} List{NatTerm} -> Map{Qid, NatTerm} .
 eq mapFromLists (qidAsTerm q) nt = q |-> nt .
 eq mapFromLists ((qidAsTerm q) qlist) (nt nlist) = (q |-> nt, mapFromLists qlist nlist) .
 
 op substIndex____ : Protocol Qid NatTerm Set{BoolTerm} -> Protocol .
 eq substIndex (family (cn[blist]) qlist blist ::= cases) q (qidAsTerm idx) A = 
   ***( was
      projectIndex (family (cn[blist]) qlist blist ::= cases) 
                   (genPrjIdxTerms q idx qlist blist)
                   A 
                   (mapFromLists qlist (genPrjIdxTerms q idx qlist blist)) 
   )
   project2Index (family (cn[blist]) qlist blist ::= cases)  
                 (qidAsTerm q) (qidAsTerm idx) A empty               
                   .
 eq substIndex ((family (cn[blist]) qlist blist ::= cases) || P1) q (qidAsTerm idx) A =
    (substIndex (family (cn[blist]) qlist blist ::= cases) q (qidAsTerm idx) A)
    ||
    (substIndex P1 q (qidAsTerm idx) A)
 .   
 
 op getInductionBase______ : Protocol ChannelName Qid Qid Set{BoolTerm} Protocol -> Protocol .
 eq getInductionBase newNF(ltq, P) cn q idx A P2 = 
    getInductionBase P cn q idx A P2 .
 eq getInductionBase 
    (P || family (cn[blist]) nlist blist ::= P1) cn q idx A P2 =
   P 
   || (adjustIndexP q idx (family (cn[blist]) nlist blist ::= P2))
   || (substIndex P1 q (qidAsTerm idx) A) .
 eq getInductionBase 
    (P || family (cn[blist]) nlist blist ::= cases) cn q idx A P2 =
   P 
   || (adjustIndexP q idx P2)
   || (substIndex (family (cn[blist]) nlist blist ::= cases) q (qidAsTerm idx) A) [owise] .  
   
   
 *** same thing for a sym proof
 op getInductionBaseSym______ : Protocol ChannelName Qid Qid Set{BoolTerm} Protocol -> Protocol .
 eq getInductionBaseSym newNF(ltq, P) cn q idx A P2 = 
    getInductionBaseSym P cn q idx A P2 .
 eq getInductionBaseSym 
    (P || family (cn[blist]) nlist blist ::= P1) cn q idx A P2 =
   P 
   || (adjustIndexP q idx (family (cn[blist]) nlist blist ::= P1))
   || (substIndex P2 q (qidAsTerm idx) A) .  
   
 *** same thing for a sym proof
 op getInductionEndSym______ : Protocol ChannelName Qid Qid Set{BoolTerm} Protocol -> Protocol .
 eq getInductionEndSym newNF(ltq, P) cn q idx A P2 = 
    getInductionEndSym P cn q idx A P2 .
 eq getInductionEndSym 
    (P || family (cn[blist]) nlist blist ::= P1) cn q idx A P2 =
   P 
   || (adjustIndexP q idx (family (cn[blist]) nlist blist ::= P1))
   || (substIndex P1 q (qidAsTerm idx) A) .    
   
 op unsplitDelta__ : ChannelContext Set{CNameBound} -> ChannelContext .  
 eq unsplitDelta Delta empty = Delta .
 eq unsplitDelta (Delta (fam (fns[(bound (nt + natAsTerm 1)) bd2]) :: T) 
                      (fam (fns[(fixedBound (nt + natAsTerm 1)) bd2]) :: T)
                 )
                 (O, fam (fns[(bound (nt + natAsTerm 2)) bd2])) = 
    unsplitDelta  (Delta (fam (fns[(bound (nt + natAsTerm 2)) bd2]) :: T) ) O .  
 eq unsplitDelta (Delta (fam (fns[bd1 (bound (nt + natAsTerm 1)) bd2]) :: T) 
                      (fam (fns[bd1 (fixedBound (nt + natAsTerm 1)) bd2]) :: T)
                 )
                 (O, fam (fns[bd1 (bound (nt + natAsTerm 2)) bd2])) = 
    unsplitDelta  (Delta (fam (fns[bd1 (bound (nt + natAsTerm 2)) bd2]) :: T) ) O .               
   
 op splitDelta__ : ChannelContext Set{CNameBound} -> ChannelContext .
 eq splitDelta Delta empty = Delta .
 eq splitDelta (Delta (fam (fns[(bound (nt + natAsTerm 2)) bd2]) :: T) )  
               (O, fam (fns[(bound (nt + natAsTerm 2)) bd2])) 
    =
    splitDelta (Delta (fam (fns[(bound (nt + natAsTerm 1)) bd2]) :: T) 
                      (fam (fns[(fixedBound (nt + natAsTerm 1)) bd2]) :: T)
               )  
               O . 
 eq splitDelta (Delta (fam (fns[bd1 (bound (nt + natAsTerm 2)) bd2]) :: T) )  
               (O, fam (fns[bd1 (bound (nt + natAsTerm 2)) bd2])) 
    =
    splitDelta (Delta (fam (fns[bd1 (bound (nt + natAsTerm 1)) bd2]) :: T) 
                      (fam (fns[bd1 (fixedBound (nt + natAsTerm 1)) bd2]) :: T)
               )  
               O .  
                              
 op splitOutputs__ : Set{CNameBound} Set{CNameBound} -> Set{CNameBound} .
 eq splitOutputs I empty = I .
 eq splitOutputs (I, fam (fns[(bound (nt + natAsTerm 2)) bd2]) )  
               (O, fam (fns[(bound (nt + natAsTerm 2)) bd2])) 
    =
    splitOutputs (I, fam (fns[(bound (nt + natAsTerm 1)) bd2]), 
                     fam (fns[(fixedBound (nt + natAsTerm 1)) bd2]))
               O . 
 eq splitOutputs (I, fam (fns[bd1 (bound (nt + natAsTerm 2)) bd2]) )  
                 (O, fam (fns[bd1 (bound (nt + natAsTerm 2)) bd2]) ) 
    =
    splitOutputs (I, fam (fns[bd1 (bound (nt + natAsTerm 1)) bd2]), 
                     fam (fns[bd1 (fixedBound (nt + natAsTerm 1)) bd2]) )
               O .   
               
 op unsplitOutputs__ : Set{CNameBound} Set{CNameBound} -> Set{CNameBound} .
 eq unsplitOutputs I empty = I .
 eq unsplitOutputs (I, fam (fns[(bound (nt + natAsTerm 1)) bd2]), 
                     fam (fns[(fixedBound (nt + natAsTerm 1)) bd2]))
                   (O, fam (fns[(bound (nt + natAsTerm 1)) bd2]), 
                     fam (fns[(fixedBound (nt + natAsTerm 1)) bd2])) = 
    unsplitOutputs (I, fam (fns[(bound (nt + natAsTerm 2)) bd2]) ) O .                 
 eq unsplitOutputs (I, fam (fns[bd1 (bound (nt + natAsTerm 1)) bd2]), 
                     fam (fns[bd1 (fixedBound (nt + natAsTerm 1)) bd2]))
                   (O, fam (fns[bd1 (bound (nt + natAsTerm 1)) bd2]), 
                     fam (fns[bd1 (fixedBound (nt + natAsTerm 1)) bd2])) = 
    unsplitOutputs (I, fam (fns[bd1 (bound (nt + natAsTerm 2)) bd2]) ) O .

 op getHiddenDecls : Protocol -> TypedCNameList .
 eq getHiddenDecls(newNF(ltq, P)) = ltq .
 eq getHiddenDecls(P) = emptyTypedCNameList [owise] .

 op generateInductionConfigP_____
   : ProtocolConfig ChannelName Qid Qid Cases 
   -> ProtocolConfig .
 eq generateInductionConfigP 
    pConfig(Sigma, Delta, 
               P || family (cn[blist]) qlist blist ::= P1, 
               I, O, A) cn q idx P2 
    =
    pConfig(Sigma, 
               deltaInd Delta P2 q idx,
               getInductionBase (P || family (cn[blist])qlist blist ::= P1) cn q idx A P2, 
               I, 
               getOutputs(
                  getInductionBase (P || family (cn[blist])qlist blist ::= P1) cn q idx A P2
               ), 
               insert(genBoundCond q (qidAsTerm idx) qlist blist, A))  
  .                

 op generateInductionConfig_____ 
   : ProtocolConfig ChannelName Qid Qid Cases
   -> ProtocolConfig .
 eq generateInductionConfig  
     pConfig(Sigma, Delta, 
               P || family (cn[blist]) qlist blist ::= cases, 
               I, O, A) cn q idx cases'
   =   pConfig(Sigma, 
               deltaInd Delta (family (cn[blist])qlist blist ::= cases') q idx, 
               P || (adjustIndexP q idx (family (cn[blist])qlist blist ::= cases'))
                 || (substIndex (family (cn[blist])qlist blist ::= cases) q (qidAsTerm idx) A), 
               I, 
               getOutputs(
                 P || 
                 (adjustIndexP q idx (family (cn[blist])qlist blist ::= cases'))
                 || (substIndex (family (cn[blist])qlist blist ::= cases) q (qidAsTerm idx) A)),
               insert(genBoundCond q (qidAsTerm idx) qlist blist, A))       .               
  
 op deltaInd____ : ChannelContext Protocol Qid Qid -> ChannelContext .
 eq deltaInd Delta 
    (family (cn[blist]) nlist blist ::= ((whenCond --> P) ;; whenList))
    q idx = 
    deltaInd Delta P q idx .
 eq deltaInd Delta (family (cn[blist]) nlist blist ::= P)
    q idx = 
    deltaInd Delta P q idx .
 eq deltaInd Delta (P1 || P2) q idx =
    deltaInd (deltaInd Delta P1 q idx) P2 q idx .    
 eq deltaInd 
     (Delta (fam (fns[blist]) :: T) ) 
     (family (fns[blist]) nlist blist ::= cases)
     q idx
     =
     if allFixed q nlist blist
     then 
     Delta (fam (fns[updateAt q idx nlist blist]) :: T) 
           (chn (fns[getBoundValues q (qidAsTerm idx) nlist blist]) :: T) 
     else
     Delta (fam (fns[updateAt q idx nlist blist]) :: T) 
           (fam (fns[fixedAt q idx nlist blist]) :: T) 
     fi .
     
 eq deltaInd 
     (Delta (fam (fns[blist]) :: T) ) 
     (P || family (fns[blist]) nlist blist ::= cases)
     q idx
     =
     if allFixed q nlist blist
     then deltaInd
     (Delta (fam (fns[updateAt q idx nlist blist]) :: T) 
            (chn (fns[getBoundValues q (qidAsTerm idx) nlist blist]) :: T)  
     ) P q idx      
     else
     deltaInd
     (Delta (fam (fns[updateAt q idx nlist blist]) :: T) 
            (fam (fns[fixedAt q idx nlist blist]) :: T) 
     )
     P q idx 
     fi
 .                      
   
 op getInductionDelta____ : ChannelContext Protocol Qid Qid -> ChannelContext .
 eq getInductionDelta Delta 
    (family (cn[blist]) nlist blist ::= (whenCond --> P) ;; whenList)
    q idx = 
    getInductionDelta Delta P q idx .
 eq getInductionDelta Delta (family (cn[blist]) nlist blist ::= P)
    q idx = 
    getInductionDelta Delta P q idx .
 eq getInductionDelta Delta (P1 || P2) q idx =
    getInductionDelta (getInductionDelta Delta P1 q idx) P2 q idx .    
 eq getInductionDelta 
     (Delta (fam (fns[blist (bound nt)]) :: T) ) 
     (family (fns[blist (bound nt)]) nlist (blist (bound nt)) ::= cases)
     q idx
     =
     if allFixed q nlist (blist (bound nt))
     then 
     Delta (fam (fns[blist (bound (qidAsTerm idx))]) :: T) 
           (chn (fns[getBoundValues q (qidAsTerm idx) nlist (blist (bound nt))]) :: T) 
     else
     Delta (fam (fns[blist (bound (qidAsTerm idx))]) :: T) 
           (fam (fns[blist (fixedBound (qidAsTerm idx))]) :: T) 
     fi .
     
 eq getInductionDelta 
     (Delta (fam (fns[blist (bound nt)]) :: T) ) 
     (P || family (fns[blist (bound nt)]) nlist (blist (bound nt)) ::= cases)
     q idx
     =
     if allFixed q nlist (blist (bound nt))
     then getInductionDelta
     (Delta (fam (fns[blist (bound (qidAsTerm idx)) ]) :: T) 
           (chn (fns[getBoundValues q (qidAsTerm idx) nlist (blist (bound nt))]) :: T) 
     ) P q idx      
     else
     getInductionDelta
     (Delta (fam (fns[blist (bound (qidAsTerm idx))]) :: T) 
            (fam (fns[blist (fixedBound (qidAsTerm idx))]) :: T))
     P q idx 
     fi .    
   
 op getInductionEnd______ : Protocol ChannelName Qid Qid Set{BoolTerm} Protocol -> Protocol .
 eq getInductionEnd newNF(ltq, P) cn q idx A P2 = 
    getInductionEnd P cn q idx A P2 .
 eq getInductionEnd
    (P || family (cn[blist]) nlist blist ::= P1) cn q idx A P2 =
   P 
   || (adjustIndexP q idx (family (cn[blist]) nlist blist ::= P2))
   || (substIndex P2 q (qidAsTerm idx) A) .   
 eq getInductionEnd
    (P || family (cn[blist]) nlist blist ::= cases) cn q idx A P2 =
   P 
   || (adjustIndexP q idx P2)
   || (substIndex P2 q (qidAsTerm idx) A) [owise] .     
 
 op genPrjIdxTerms____ : Qid NatTerm List{NatTerm} List{Bounds} -> List{NatTerm} .
 eq genPrjIdxTerms q nj nil nil = nil .
 eq genPrjIdxTerms q nj (qidAsTerm q) (bound nt) = nj .
 eq genPrjIdxTerms q nj (qidAsTerm q) (dependentBound q') = nj .
 ceq genPrjIdxTerms q nj (qidAsTerm q') (fixedBound nt) = nt if q =/= q' .
 ceq genPrjIdxTerms q nj (qidAsTerm q') (bound nt) = qidAsTerm q' if q =/= q' .
 eq genPrjIdxTerms q (qidAsTerm idx) ((qidAsTerm q') nlist) (bd1 blist) =
    ((genPrjIdxTerms q (qidAsTerm idx) (qidAsTerm q') bd1)
     (genPrjIdxTerms q (qidAsTerm idx) nlist blist) 
    )
 .     
     
 op genBoundCond____ : Qid NatTerm List{NatTerm} List{Bounds} -> Set{BoolTerm} .       
 eq genBoundCond q (qidAsTerm idx) (qidAsTerm q) (bound nt) = qidAsTerm idx <T nt .
 eq genBoundCond q (qidAsTerm idx) ((qidAsTerm q) qidAsTerm q') ((bound nt) bd1) = qidAsTerm idx <T nt .
 eq genBoundCond q (qidAsTerm idx) ((qidAsTerm q') qidAsTerm q) (bd1 (bound nt)) = qidAsTerm idx <T nt .
 eq genBoundCond q (qidAsTerm idx) ((qidAsTerm q') qidAsTerm q) ((fixedBound nt) (dependentBound F)) = qidAsTerm idx <T fun F nt .
 eq genBoundCond q (qidAsTerm idx) ((qidAsTerm q) (qidAsTerm q') qidAsTerm q'') ((bound nt) bd1 bd2) = qidAsTerm idx <T nt .
 eq genBoundCond q (qidAsTerm idx) ((qidAsTerm q') (qidAsTerm q) qidAsTerm q'') (bd1 (bound nt) bd2) = qidAsTerm idx <T nt .
 eq genBoundCond q (qidAsTerm idx) ((qidAsTerm q') (qidAsTerm q'') qidAsTerm q) (bd1 bd2 (bound nt)) = qidAsTerm idx <T nt .
 eq genBoundCond q (qidAsTerm idx) ((qidAsTerm q') (qidAsTerm q'') qidAsTerm q) (bd1 (fixedBound nt) (dependentBound F)) = qidAsTerm idx <T fun F nt . 
    
 op  allFixed___ : Qid List{NatTerm} List{Bounds} -> Bool .
 eq  allFixed q nil nil = true .
 eq  allFixed q ((qidAsTerm q) nlist) (bd1 blist) = allFixed q nlist blist .
 ceq allFixed q ((qidAsTerm q') nlist) ((fixedBound nt) blist) = allFixed q nlist blist 
     if not (q == q').   
 eq  allFixed q nlist blist = false [owise] .  
 
 *** set the bound for q to nt  
 op setBound____ : List{NatTerm} List{Bounds} Qid NatTerm -> List{Bounds} .
 eq setBound (qidAsTerm q) (bound nt1) q nt = fixedBound nt .

 eq setBound ((qidAsTerm q) qidAsTerm q1) ((bound nt1) bd2) q nt = (fixedBound nt) bd2 .
 eq setBound ((qidAsTerm q) qidAsTerm q1) ((fixedBound nt) bd2) q nt1 = (fixedBound nt1) bd2 .
*** unsafe, we need A, same as below

 eq setBound ((qidAsTerm q1) qidAsTerm q) (bd1 (bound nt1)) q nt = bd1 (fixedBound nt) .
 eq setBound ((qidAsTerm q1) qidAsTerm q) (bd1 (fixedBound nt)) q nt = bd1 (fixedBound nt) .
 eq setBound ((qidAsTerm q1) qidAsTerm q) (bd1 (dependentBound F)) q nt = bd1 (fixedBound nt) .

 eq setBound ((qidAsTerm q) (qidAsTerm q1) qidAsTerm q2) ((bound nt1) bd1 bd2) q nt = (fixedBound nt) bd1 bd2 .
 eq setBound ((qidAsTerm q) (qidAsTerm q1) qidAsTerm q2) ((fixedBound nt) bd1 bd2) q nt = (fixedBound nt) bd1 bd2 . 
 *** TODO: cheat for now, but we should prove that nt1 = nt with A!
 eq setBound ((qidAsTerm q) (qidAsTerm q1) qidAsTerm q2) ((fixedBound nt) bd1 bd2) q nt1 = (fixedBound nt1) bd1 bd2 .
 
 eq setBound ((qidAsTerm q1) (qidAsTerm q) qidAsTerm q2) (bd1 (bound nt1) bd2) q nt = 
    bd1 (fixedBound nt) bd2 .
 
 eq setBound ((qidAsTerm q1) (qidAsTerm q2) qidAsTerm q) (bd1 bd2 (bound nt1)) q nt = 
     bd1 bd2 (fixedBound nt) .
 eq setBound ((qidAsTerm q1) (qidAsTerm q2) qidAsTerm q) (bd1 bd2 (dependentBound F)) q nt = 
     bd1 bd2 (fixedBound nt) .
 
 *** from a list of fixed bounds except on position q
 *** get all bound values and set the one for q to nj
 op  getBoundValues____ : Qid NatTerm List{NatTerm} List{Bounds} -> List{NatTerm} .
 eq  getBoundValues q nj nil nil = nil .
 eq  getBoundValues q nj ((qidAsTerm q) nlist) (bd1 blist) = nj (getBoundValues q nj nlist blist) .
 eq  getBoundValues q nj ((qidAsTerm q') nlist) ((fixedBound nt) blist) = 
       nt (getBoundValues q nj nlist blist) .
       
 op  getBoundValues2_____ : 
    Qid NatTerm List{NatTerm} List{Bounds} Set{BoolTerm} -> List{NatTerm} .
 eq  getBoundValues2 q nj nil nil A = nil .
 eq  getBoundValues2 q nj ((qidAsTerm q) nlist) (bd1 blist) A = nj (getBoundValues2 q nj nlist blist A) .
 eq  getBoundValues2 q nj ((qidAsTerm q') nlist) ((fixedBound (qidAsTerm q1)) blist) (A, qidAsTerm q1 =T= nt) = 
       nt (getBoundValues2 q nj nlist blist (A, qidAsTerm q1 =T= nt)) .  
 eq  getBoundValues2 q nj ((qidAsTerm q') nlist) ((fixedBound nt) blist) A = 
       nt (getBoundValues2 q nj nlist blist A) .          
 
 *** partial projection for families  
 op project2Index_____ :       
     Protocol 
       List{NatTerm} *** several indices
       List{NatTerm} *** each with their values
       Set{BoolTerm} Map{Qid, NatTerm} -> Protocol .
 eq project2Index P nil nil A f = P .
 eq project2Index P ((qidAsTerm q) nlist1) (nj nlist2) A f =
    project2Index 
     (project2IndexAux P q nj (expandIneq A empty) f emptyWhen)
     nlist1
     nlist2
     A f [label project2IndexTop] .     
       
  op project2IndexAux______ : 
     Protocol Qid NatTerm Set{BoolTerm} Map{Qid, NatTerm} Cases -> Protocol .
  op project2IndexAuxP______ : 
     Protocol Qid NatTerm Set{BoolTerm} Map{Qid, NatTerm} Cases -> Protocol .   
  *** structural part   
  eq project2IndexAux (cn ::= cases) q nj A f emptyWhen = cn ::= cases [label projectCN] .   
  eq project2IndexAux (family ('Comp[qidAsTerm fns1 qidAsTerm fns2][blist]) nlist blist ::=
    ((family (fns1[blist]) nlist (blist) ::= cases) || 
     (family (fns2[blist]) nlist (blist) ::= cases')
    )
   )  q nj A f emptyWhen 
   = (project2IndexAuxP (family (fns1[blist]) nlist (blist) ::= cases) 
       q nj A f emptyWhen
     ) 
     ||
     (project2IndexAuxP (family (fns2[blist]) nlist (blist) ::= cases') 
       q nj A f emptyWhen)
  .     
   eq project2IndexAux (family (fns[blist]) nlist blist ::= P)
      q nj A f emptyWhen =
      family (fns[(setBound nlist blist q nj)]) nlist (setBound nlist blist q nj) ::=
      project2IndexAuxP P q nj A f emptyWhen .
      
   eq project2IndexAuxP (P1 || P2)
      q nj A f emptyWhen =
      (project2IndexAuxP P1 q nj A f emptyWhen)
      ||
      (project2IndexAuxP P2 q nj A f emptyWhen) .   
   
   eq project2IndexAux (P1 || P2)
      q nj A f emptyWhen =
      (project2IndexAux P1 q nj A f emptyWhen)
      ||
      (project2IndexAux P2 q nj A f emptyWhen) .      
   
   *** for reactions
      
   eq project2IndexAux (family (fns[blist]) nlist blist ::= R) 
       q nj A f cases =
      project2IndexAux (family (fns[blist]) nlist blist ::= (otherwise --> R)) 
       q nj A f cases .
   ceq project2IndexAux
       (family (fns[blist]) nlist blist ::= emptyWhen)
       q nj A f cases = 
      fns[getBoundValues q nj nlist blist] ::= cases   
      if allFixed q nlist blist .
   ceq project2IndexAux
       (family (fns[blist]) nlist blist ::= emptyWhen)
       q nj A f cases =    
       family (fns[(setBound nlist blist q nj)]) nlist (setBound nlist blist q nj) ::= cases 
      if not (allFixed q nlist blist) [label notAllFixed]
   .      
   ceq project2IndexAux 
        (family (fns[blist]) nlist blist ::= (when bt --> R) ;; whenList) 
       q nj A f cases = 
       fns[getBoundValues q nj nlist blist] ::= 
        replaceVars(R, insert(q, nj, f)) 
    if (A |= bt with (insert(q, nj, f))) /\ (allFixed q nlist blist) [label caseHoldsChn].   
     ceq project2IndexAux 
        (family (fns[blist]) nlist blist ::= (when bt --> R) ;; whenList) 
       q nj A f cases = 
       family (fns[(setBound nlist blist q nj)]) nlist (setBound nlist blist q nj) ::= 
        replaceVars(R, insert(q, nj, f)) 
    if (A |= bt with (insert(q, nj, f))) /\ (not (allFixed q nlist blist)) [label caseHoldsFam].  
   ceq project2IndexAux 
        (family (fns[blist]) nlist blist ::= (when bt --> R) ;; whenList) 
        q nj A f cases = 
        project2IndexAux 
        (family (fns[blist]) nlist blist ::= whenList) 
        q nj A f cases
    if A |= neg bt with (insert(q, nj, f)) [label skipCase].
    eq project2IndexAux 
        (family (fns[blist]) nlist blist ::= (when bt --> R) ;; whenList) 
        q nj A f cases = 
        project2IndexAux 
        (family (fns[blist]) nlist blist ::= whenList) 
        q nj A f
        (cases ;; 
         when (simplify A subst(bt, q |-> nj) f) --> 
          replaceVars(R, insert(q, nj, f)))
    [owise label withSimplify] .
    eq project2IndexAux 
        (family (fns[blist]) nlist blist ::= (otherwise --> R)) 
        q nj A f emptyWhen = 
        if allFixed q nlist blist 
       then fns[getBoundValues q nj nlist blist] ::= replaceVars(R, insert(q, nj, f)) 
       else family (fns[setBound nlist blist q nj]) 
                   nlist (setBound nlist blist q nj) ::= replaceVars(R, insert(q, nj, f)) 
      fi .
    eq project2IndexAux 
        (family (fns[blist]) nlist blist ::= (otherwise --> R)) 
        q nj A f cases = 
        if allFixed q nlist blist 
       then fns[getBoundValues q nj nlist blist] ::= 
         cases ;; (otherwise --> replaceVars(R, insert(q, nj, f)))
       else  family (fns[setBound nlist blist q nj])  nlist (setBound nlist blist q nj) ::=  
         cases ;; (otherwise --> replaceVars(R, insert(q, nj, f)))
       fi  
    [owise] .
    
   *** for protocols   

   *** connect
   
   eq project2IndexAux 
        (family (fns[blist]) nlist blist ::= (when bt --> P) ;; whenList) 
       q nj A f cases = 
      project2IndexAuxP 
        (family (fns[blist]) nlist blist ::= (when bt --> P) ;; whenList) 
       q nj A f cases . 
       
  eq project2IndexAuxP (family (fns[blist]) nlist blist ::= R) 
       q nj A f cases =
      project2IndexAux (family (fns[blist]) nlist blist ::= (otherwise --> R)) 
       q nj A f cases .   
       
  eq project2IndexAuxP (family (fns[blist]) nlist blist ::= (whenCond --> R) ;; whenList) 
       q nj A f cases =
      project2IndexAux (family (fns[blist]) nlist blist ::= ((whenCond --> R) ;; whenList)) 
       q nj A f cases .        
    
    *** end with when
    
    eq project2IndexAuxP
       (family (fns[blist]) nlist blist ::= emptyWhen)
       q nj A f cases =    
       family (fns[(setBound nlist blist q nj)]) nlist (setBound nlist blist q nj) ::= cases 
   .      
    
    *** found a condition that holds 
     ceq project2IndexAuxP 
        (family (fns[blist]) nlist blist ::= (when bt --> P) ;; whenList) 
       q nj A f cases = 
       family (fns[(setBound nlist blist q nj)]) nlist (setBound nlist blist q nj) ::= 
        (project2IndexAux P q nj A f emptyWhen) 
    if (A |= bt with (insert(q, nj, f))) .
      
    *** found a condition that we can disprove
   ceq project2IndexAuxP 
        (family (fns[blist]) nlist blist ::= (when bt --> P) ;; whenList) 
        q nj A f cases = 
        project2IndexAuxP 
        (family (fns[blist]) nlist blist ::= whenList) 
        q nj A f cases
    if A |= neg bt with (insert(q, nj, f)) .
    
    *** can't do either, so store as a possible case
    eq project2IndexAuxP 
        (family (fns[blist]) nlist blist ::= (when bt --> P) ;; whenList) 
        q nj A f cases = 
        project2IndexAuxP 
        (family (fns[blist]) nlist blist ::= whenList) 
        q nj A f
        (cases ;; 
         when (simplify A subst(bt, q |-> nj) f) --> 
          (project2IndexAux P q nj A f emptyWhen) 
          )
    [owise] .
    *** got to the end and didn't find anything yet
    eq project2IndexAuxP 
        (family (fns[blist]) nlist blist ::= (otherwise --> P)) 
        q nj A f emptyWhen = 
        
       family (fns[setBound nlist blist q nj]) 
              nlist (setBound nlist blist q nj) ::= (project2IndexAux P q nj A f emptyWhen) 
       .
    *** got to the end and we have some possible cases   
    eq project2IndexAuxP 
        (family (fns[blist]) nlist blist ::= (otherwise --> P)) 
        q nj A f cases =      
       family (fns[setBound nlist blist q nj])  nlist (setBound nlist blist q nj) ::=  
         cases ;; (otherwise --> (project2IndexAux P q nj A f emptyWhen))    
    [owise] .    
   
   var t1 t2 t3 : NatTerm .
   
   *** given a family C and an index i, return C[i] ::= the correspoding case
   *** we might get more than one case, but often we get just a reaction or a protocol
   op projectIndex____ : Protocol List{NatTerm} Set{BoolTerm} Map{Qid, NatTerm} -> Protocol .
   *** projectIndex (family C i n ::= cases) nj A f = C[nj] ::= cases(nj)
   eq projectIndex (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= cases) nj A f = 
       projectIndexAux (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= cases) nj A f emptyWhen .
   eq projectIndex (family (fns[bd1 bd2]) ((qidAsTerm q) (qidAsTerm q')) (bd1 bd2) ::= cases) (t1 t2) A f = 
       projectIndexAux2 (family (fns[bd1 bd2]) ((qidAsTerm q) (qidAsTerm q')) (bd1 bd2) ::= cases) 
                        (t1 t2) A f emptyWhen .
   eq projectIndex (family (fns[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q') qidAsTerm q'') (bd1 bd2 bd3) ::= cases) 
                   (t1 t2 t3) A f =
      projectIndexAux3 (family (fns[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q') qidAsTerm q'')  (bd1 bd2 bd3) ::= cases) 
                       (t1 t2 t3) A f emptyWhen .    
   
   eq projectIndex (family ('Comp[fns1 fns2][bound nt]) (qidAsTerm q) (bound nt) ::= 
                      ( (fns1[q] ::= R1) || (fns2[q] ::= R2) )
                   ) nj A f = 
      (fns1[nj] ::= replaceVars(R1, ((q |-> nj), f)) )
      ||             
      (fns2[nj] ::= replaceVars(R2, ((q |-> nj), f)) )
   .       
          
   eq projectIndex P nj A f = P [owise] .
   
   op projectIndexAux_____ : Protocol NatTerm Set{BoolTerm} Map{Qid, NatTerm} Cases -> Protocol .
   eq projectIndexAux (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= R) 
        nj A f cases =
      projectIndexAux (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= (otherwise --> R)) 
        nj A f cases .
   eq projectIndexAux
       (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= emptyWhen)
       nj A f cases = fns[nj] ::= cases .      
   ceq projectIndexAux 
        (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= (when bt --> R) ;; whenList) 
        nj A f cases = 
        fns[nj] ::= replaceVars(R, insert(q, nj, f)) 
    if A |= bt with (insert(q, nj, f)) .
   ceq projectIndexAux 
        (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= (when bt --> R) ;; whenList) 
        nj A f cases = 
        projectIndexAux 
        (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= whenList) 
        nj A f cases
    if A |= neg bt with (insert(q, nj, f)) .
    eq projectIndexAux 
        (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= (when bt --> R) ;; whenList) 
        nj A f cases = 
        projectIndexAux 
        (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= whenList) 
        nj A f
        (cases ;; 
         when (simplify A subst(bt, q |-> nj) f) --> 
          replaceVars(R, insert(q, nj, f)))
    [owise] .
    ceq projectIndexAux 
        (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= (otherwise --> R)) 
        nj A f cases = 
        fns[nj] ::= replaceVars(R, insert(q, nj, f)) 
    if cases == emptyWhen .
    eq projectIndexAux 
        (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= (otherwise --> R)) 
        nj A f cases = 
        fns[nj] ::= cases ;; (otherwise --> replaceVars(R, insert(q, nj, f)))
    [owise] .  
    
    op projectIndexAux2_____ : 
         Protocol List{NatTerm} Set{BoolTerm} Map{Qid, NatTerm} Cases -> Protocol .   

    eq projectIndexAux2 (family (fns[bd1 bd2]) ((qidAsTerm q) (qidAsTerm q')) (bd1 bd2)  ::= R ) 
        (t1 t2) A f cases =
      projectIndexAux2  
         (family (fns[bd1 bd2]) ((qidAsTerm q) (qidAsTerm q')) (bd1 bd2) ::= otherwise --> R ) 
        (t1 t2) A f cases .
    ceq projectIndexAux2 
        (family (fns[bd1 bd2]) ((qidAsTerm q) (qidAsTerm q')) (bd1 bd2) ::= (when bt --> R) ;; whenList) 
        (t1 t2) A f cases = 
        fns[t1 t2] ::= replaceVars(R, ((q |-> t1), (q' |-> t2), f)) 
    if A |= bt with (f, q |-> t1, q' |-> t2) .
   ceq projectIndexAux2 
        (family (fns[bd1 bd2]) ((qidAsTerm q) (qidAsTerm q')) (bd1 bd2)  ::= (when bt --> R) ;; whenList) 
        (t1 t2) A f cases = 
        projectIndexAux2 
        (family (fns[bd1 bd2]) ((qidAsTerm q) (qidAsTerm q')) (bd1 bd2)  ::= whenList) 
        (t1 t2) A f cases
    if A |= neg bt with (f, q |-> t1, q' |-> t2) .
    eq projectIndexAux2 
        (family (fns[bd1 bd2]) ((qidAsTerm q) (qidAsTerm q')) (bd1 bd2) ::= (when bt --> R) ;; whenList) 
        (t1 t2) A f cases = 
        projectIndexAux2 
        (family (fns[bd1 bd2]) ((qidAsTerm q) (qidAsTerm q')) (bd1 bd2)  ::= whenList) 
        (t1 t2) A f 
         (cases ;; 
           when subst(bt, (q |-> t1, q' |-> t2)) --> 
             replaceVars(R, ((q |-> t1), (q' |-> t2), f)) 
         )
    [owise] .
    ceq projectIndexAux2 
        (family (fns[bd1 bd2]) ((qidAsTerm q) (qidAsTerm q')) (bd1 bd2) ::= (otherwise --> R)) 
        (t1 t2) A f cases = 
        fns[t1 t2] ::= replaceVars(R, ((q |-> t1), (q' |-> t2), f)) 
    if cases == emptyWhen .
    eq projectIndexAux2 
        (family (fns[bd1 bd2]) ((qidAsTerm q) (qidAsTerm q')) (bd1 bd2)  ::= (otherwise --> R)) 
        (t1 t2) A f cases = 
        fns[t1 t2] ::= cases ;; (otherwise --> replaceVars(R, ((q |-> t1), (q' |-> t2), f)) )
    [owise] .
    eq projectIndexAux2 
        (family (fns[bd1 bd2]) ((qidAsTerm q) (qidAsTerm q')) (bd1 bd2)  ::= emptyWhen) 
        (t1 t2) A f cases = 
        fns[t1 t2] ::= cases .
      
    
    *** var nt3 t1 t2 t3 : NatTerm .
    
    op projectIndexAux3_____ 
         : Protocol List{NatTerm} Set{BoolTerm} 
           Map{Qid, NatTerm} Cases -> Protocol .        
    eq projectIndexAux3 (family (fns[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q') qidAsTerm q'') (bd1 bd2 bd3)  ::= R ) 
        (t1 t2 t3) A f cases' =
      projectIndexAux3  
         (family (fns[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q') qidAsTerm q'') (bd1 bd2 bd3)   ::= otherwise --> R ) 
        (t1 t2 t3) A f cases' .
    ceq projectIndexAux3 
        (family (fns[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q') qidAsTerm q'') (bd1 bd2 bd3)   ::= (when bt --> R) ;; whenList) 
        (t1 t2 t3) A f cases' = 
        fns[t1 t2 t3] ::= replaceVars(R, ((q |-> t1),(q' |-> t2),(q'' |-> t3), f)) 
    if A |= bt with (f, q |-> t1, q' |-> t2, q'' |-> t3)  .
   ceq projectIndexAux3 
        (family (fns[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q') qidAsTerm q'') (bd1 bd2 bd3)  ::= (when bt --> R) ;; whenList) 
        (t1 t2 t3) A f cases' = 
        projectIndexAux3 
        (family (fns[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q') qidAsTerm q'') (bd1 bd2 bd3)  ::= whenList) 
        (t1 t2 t3) A f cases'
    if A |= neg bt with (f, q |-> t1, q' |-> t2, q'' |-> t3) .
    eq projectIndexAux3 
        (family (fns[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q') qidAsTerm q'') (bd1 bd2 bd3)  ::= (when bt --> R) ;; whenList) 
        (t1 t2 t3) A f cases' = 
        projectIndexAux3
        (family (fns[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q') qidAsTerm q'') (bd1 bd2 bd3)   ::= whenList) 
        (t1 t2 t3) A f 
        (cases' ;; when subst(
                         bt, 
                         (q |-> t1, q' |-> t2, q'' |-> t3)
                        )  --> 
                         replaceVars(R, ((q |-> t1),(q' |-> t2),(q'' |-> t3), f)) 
        )
    [owise] .
    ceq projectIndexAux3 
        (family (fns[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q') qidAsTerm q'') (bd1 bd2 bd3)   ::= (otherwise --> R)) 
        (t1 t2 t3) A f cases' = 
        fns[t1 t2 t3] ::= replaceVars(R, ((q |-> t1),(q' |-> t2),(q'' |-> t3), f)) 
    if cases' == emptyWhen .
    eq projectIndexAux3 
        (family (fns[bd1 bd2 bd3]) 
         ((qidAsTerm q) (qidAsTerm q') qidAsTerm q'') (bd1 bd2 bd3)  ::= (otherwise --> R)) 
        (t1 t2 t3) A f cases' = 
        fns[t1 t2 t3] ::= 
          cases' ;; 
          (otherwise --> 
            replaceVars(R, ((q |-> t1),(q' |-> t2),(q'' |-> t3), f)) 
          )
    [owise] .
    eq projectIndexAux3 
        (family (fns[bd1 bd2 bd3]) 
        ((qidAsTerm q) (qidAsTerm q') qidAsTerm q'') (bd1 bd2 bd3)  ::= emptyWhen) 
        (t1 t2 t3) A f cases' = 
         fns[t1 t2 t3] ::= cases' . 

endm

view ProtocolConfig  from TRIV to PROTOCOL-CONFIG is
 sort Elt to ProtocolConfig .
endv

mod PROTOCOL-EQ-CORE is
 protecting PROTOCOL-EQ-HELPERS .
 protecting PROTOCOL-CONFIG .
 
 var fns fns1 fns2 cns cns1 cns2 : NameWithScripts . 

 var Sigma : Signature .
 vars Delta D Delta' Delta1 Delta2 : ChannelContext .
 vars R R' R1 R2 R3 R4 S1 S2 S : Reaction .
 vars T T0 T1 T2 T3 : IPDLType .
 vars M M1 M2 : IPDLExpression .
 vars I I' I'' I1 O O' O'' O1 O2 O3 : Set{CNameBound} . 
 var l r c i o o1 o2 o3 : ChannelName .
 var b x x0 x1 x2 y y0 y1 y2 z : ChannelName . *** was Qid 
 vars P P1 P2 P3 P4 Q : Protocol .
 var n : Nat .
 var lq : List{NatTerm} .
 var ltq ltq1 ltq2 : TypedCNameList .
 var Dist : Distribution .
 var q : Qid .
 var ql ql1 ql2 : List{NatTerm} .
     var bt : BoolTerm .  
    var C C' q' : Qid .
    var m : Nat .
  var nt nt1 nt2 : NatTerm .
  var nlist nlist' : List{NatTerm} .
 var cases : Cases .
 var blist blist' : List{Bounds} .
 var cn : ChannelName .
 var bn : CNameBound .   

 
  var BRL : BRList .
 var QL : List{NatTerm} .
 var A A' : Set{BoolTerm} .
 var nlist1 nlist2 : List{NatTerm} . 
  var qid1 qid2 : Qid .
    var q1 q2 : Qid .
  var cn1 cn2 : ChannelName .  
     var T' : IPDLType .
     
      var nj nt' : NatTerm .
     var ntl : List{NatTerm} .
     var bounds : List{Bounds} .
     var cases' : Cases .
                 
  ****************
 *** core rules
 ****************
 
 rl [UNSAFE] : 
    pConfig(Sigma, Delta, P2, I, O, A) 
     => 
    pConfig(Sigma, Delta', P1, I', O', A')
 [nonexec] 
 .   
 
 
 crl [SYM] :
     pConfig(Sigma, Delta2, P2, I, O2, A) 
     => 
     pConfig(Sigma, Delta1, P1, I, O1, A)
     if
     pConfig(Sigma, Delta1, P1, I, O1, A)
     => 
     pConfig(Sigma, Delta2, P2, I, O2, A) 
     /\ Delta1 equiv Delta2 
     /\ O1 equiv O2     
     [nonexec] .
     
 crl [CONG-REACT] : 
     pConfig(Sigma, Delta, cn ::= R, I, bn, A) 
     =>
     pConfig(Sigma, Delta, cn ::= R', I, bn, A)
     if
     rConfig(Sigma, Delta, emptyTypeContext, R, 
             (I, chn cn), A, typeInCtx(chn cn, A, Delta))
     =>
     rConfig(Sigma, Delta, emptyTypeContext, R', I', A, T) 
     /\ I' == insert(bn, I)
     /\ T == typeInCtx(bn, A, Delta)
     /\ occurs (chn cn) Delta A
     /\ bn == chn cn
     . *** TODO: cn shouldn't be in I!

 crl [CONG-COMP-LEFT] :
     pConfig(Sigma, Delta1, P1 || Q, I, O, A) 
     => 
     pConfig(Sigma, Delta2, P2 || Q, I, union(getOutputs(P2), getOutputs(Q)), A)
     if
     pConfig(Sigma, Delta1, P1, union(I, getOutputs(Q)), getOutputs(P1), A)
     => 
     pConfig(Sigma, Delta2, P2, I1, O2, A)
     /\ O2 == getOutputs(P2) 
     /\ I1 == union(I, getOutputs(Q))
     /\ typeOf(Sigma, Delta2, union(I, getOutputs(P2)), A, Q)
     /\ Delta1 equiv Delta2
     /\ O equiv (union(getOutputs(P2), getOutputs(Q)))
 .

  crl [CONG-COMP-RIGHT] :
     pConfig(Sigma, Delta1, Q || P1, I, O, A) 
     => 
     pConfig(Sigma, Delta2, Q || P2, I, union(getOutputs(P2), getOutputs(Q)), A)
     if
     pConfig(Sigma, Delta1, P1, union(I, getOutputs(Q)), getOutputs(P1), A)
     => 
     pConfig(Sigma, Delta2, P2, I1, O2, A)
     *** TODO: do these fail for gmwN?
     *** the condition below made problems for multiparty too
     *** with induction rule, because there we may read from AC(i N+2)
     *** and we set the bound to B
     *** solution is to get these under focus, so use a comp!
     *** /\ typeOf(Sigma, Delta1, union(I, getOutputs(P1)), A, Q)
     /\ I1 == union(I, getOutputs(Q)) 
     /\ O == union(getOutputs(P1), getOutputs(Q))
     
     .
   
 crl [CONG-NEW] : 
     pConfig(Sigma, Delta1, new cn : T in P1, I, O1, A)
     => 
     pConfig(Sigma, removeEntry ((chn cn) :: T) Delta2, new cn : T in P2, I, getOutputs(P2), A)
     if
     pConfig(Sigma, ((chn cn) :: T) Delta1,  P1, I, insert(chn cn, O1), A)
     => 
     pConfig(Sigma, Delta2,  P2, I, O2, A) 
     /\ O2 == insert(chn cn, getOutputs(P2))
     /\ Delta2 equiv (((chn cn) :: T) Delta1)
     /\ insert(chn cn, O1) equiv O2
     *** [nonexec] 
     .
     *** /\ P1 =/= P2 .   
     
  *** COMP-COMM and COMP-ASSOC are out, || has these attributes
  *** AXIOM don't requires a new rule, axioms are either equations or have own strategies
  *** SUBST is just application of rules to terms.
  
  crl [NEW-EXCH] :
     pConfig(Sigma, Delta, new cn1 : T1 in new cn2 : T2 in P, I, O, A) 
     => 
     pConfig(Sigma, Delta, new cn2 : T2 in new cn1 : T1 in P, I, O, A)
     if
     typeOf(Sigma, Delta (chn cn1 :: T1) 
                         (chn cn2 :: T2), I, A, P) /\
     getOutputs(P) == insert(chn cn1, insert(chn cn2, O)) .

 crl [COMP-NEW] :
     pConfig(Sigma, Delta, P || (new cn : T in Q), I, O, A)
     =>  
     pConfig(Sigma, Delta, new cn : T in (P || Q), I, O, A)
     if
     typeOf(Sigma, Delta (chn cn :: T), union(I, getOutputs(P)), A, Q)
     /\
     typeOf(Sigma, Delta, union(I ,(getOutputs(Q) \ (chn cn))), A, P) 
 .
 
   crl [COMP-NEW-2] :
     pConfig(Sigma, Delta, new cn : T in (P || Q), I, O, A)
     =>  
     pConfig(Sigma, Delta, P || (new cn : T in Q), I, O, A)
     if
     typeOf(Sigma, Delta (chn cn :: T), union(I, getOutputs(P)), A, Q)
     /\
     typeOf(Sigma, Delta, union(I ,(getOutputs(Q) \ (chn cn))), A, P) .

  crl [ABSORB-LEFT] : 
     pConfig(Sigma, Delta, P1 || P2, I, O, A) =>
     pConfig(Sigma, Delta, P1, I, O, A) 
     if
     typeOf(Sigma, Delta, I, A, P1) 
     /\
     typeOf(Sigma, Delta, union(I, O), A, P2) 
     /\
     getOutputs(P1) == O
     /\ 
     getOutputs(P2) == empty
     .
        
 crl [ABSORB-LEFT-2] : 
     pConfig(Sigma, Delta, P1 , I, O, A) =>
     pConfig(Sigma, Delta, P1 || P2, I, O, A) 
     if
     typeOf(Sigma, Delta, I, A, P1) 
     /\
     typeOf(Sigma, Delta, union(I, O), A, P2) 
     /\
     getOutputs(P1) == O
     /\ 
     getOutputs(P2) == empty 
     [nonexec] .    
 
 crl [ABSORB-RIGHT] : 
     pConfig(Sigma, Delta, P1 || P2, I, O, A) =>
     pConfig(Sigma, Delta, P2, I, O, A) 
     if
     typeOf(Sigma, Delta, I, A, P2) 
     /\
     typeOf(Sigma, Delta, union(I, O), A, P1) 
     /\
     getOutputs(P2) == O
     /\ 
     getOutputs(P1) == empty 
 .
 
 crl [DIVERGE] :
     pConfig(Sigma, Delta, cn ::= x : T <- read cn ; R, I, bn, A)
     =>
     pConfig(Sigma, Delta, cn ::= read cn, I, bn, A)
     if
     typeOf(Sigma, Delta, emptyTypeContext, insert(chn cn, I), A, R) == 
     typeInCtx(chn cn, A, Delta)
     /\ occurs (chn cn) Delta A
     /\ bn == chn cn
      .

 ***(
    crl [FLIP-UNIF] : 
      pConfig(Sigma, Delta,
              cn ::= x : bool <- samp flip ;
                     if x then return True else read cn, I, O, A)
      => 
      pConfig(Sigma, Delta,
              cn ::= x : bool <- samp flip ;
                     if x then read cn else return False , I, O, A)
    if O == toBound cn /\ not isElemB(cn, I, A) /\ elem (toBound cn) bool Delta A .
 )   

 crl [FOLD-IF-RIGHT] :
     pConfig(Sigma, Delta,
             new cn1 : T in ((cn2 ::= b : bool <- R ;
                                if b then S1 else read cn1)
                          ||
                           (cn1 ::= S2))
            ,I, O, A)
     => 
     pConfig(Sigma, Delta,
             cn2 ::= b : bool <- R ;
                   if b then S1 else S2
             , I, O, A)
     if
     typeOf(Sigma, Delta, emptyTypeContext, I, A, R) == bool
     /\
     typeOf(Sigma, Delta, emptyTypeContext, insert(chn cn2, I), A, S1) == T
     /\
     typeOf(Sigma, Delta, emptyTypeContext, insert(chn cn2, I), A, S2) == T
     /\
     O == chn cn2 
     /\
     elem (chn cn2) T Delta A .
    
  crl [FOLD-IF-LEFT] :
     pConfig(Sigma, Delta,
             new cn2 : T in ((cn1 ::= b : bool <- R ;
                                if b then read cn2 else S2)
                          ||
                           (cn2 ::= S1))
            ,I, O, A)
     => 
     pConfig(Sigma, Delta,
             cn1 ::= b : bool <- R ;
                   if b then S1 else S2
             , I, O, A)
     if
     typeOf(Sigma, Delta, emptyTypeContext, I, A, R) == bool
     /\
     typeOf(Sigma, Delta, emptyTypeContext, insert(chn cn1, I), A, S1) == T
     /\
     typeOf(Sigma, Delta, emptyTypeContext, insert(chn cn1, I), A, S2) == T
     /\
     O == chn cn1 
     /\
     elem (chn cn1) T Delta A .

  crl [FOLD-BIND] :
     pConfig(Sigma, Delta, 
             new c : T in ((o ::= x : T <- read c ; S)
                           ||
                           (c ::= R)),
             I, O, A)
     =>
     pConfig(Sigma, Delta,
             o ::= x : T <- R ; S,
             I, O, A)
    if O == chn o .
   
  crl [FOLD-BIND-2] :
     pConfig(Sigma, Delta, 
             o ::= x : T <- R ; S,
             I, O, A)
     =>
     pConfig(Sigma, Delta,
             new c : T in ((o ::= x : T <- read c ; S)
                           ||
                           (c ::= R)),
             I, O, A)
    if O == chn o [nonexec] . 
    
 crl [SUBSUME] :
    pConfig(Sigma, Delta, 
            (cn1 ::= x0 : T0 <- read i ; R1) || 
            (cn2 ::= x0 : T0 <- read i ; x1 : T1 <- read cn1 ; R2) 
           , I, O, A)
    => 
    pConfig(Sigma, Delta,
            (cn1 ::= x0 : T0 <- read i ; R1) || 
            (cn2 ::= x1 : T1 <- read cn1 ; R2)  
           , I, O, A)
   if typeOf(Sigma, Delta, x1 : T1, insert(chn cn1, insert(chn cn2, I)), A, R2) == 
      typeInCtx(chn cn2, A, Delta) 
   /\ O == insert(chn cn1, insert(chn cn2, empty)) /\ cn1 =/= cn2 /\
   elem (chn cn1) T1 Delta A . 
   
 crl [DROP] : 
   pConfig(Sigma, Delta,
           (cn1 ::= R1) || (cn2 ::= x1 : T1 <- read cn1 ; R2)
          ,I, O, A)
   => 
   pConfig(Sigma, Delta,
           (cn1 ::= R1) || (cn2 ::= R2)
          ,I, O, A)
   if rConfig(Sigma, Delta, emptyTypeContext, 
              x1 : T1 <- R1 ; R2
             , insert(chn cn1, insert(chn cn2, I)), A, typeInCtx(chn cn2, A, Delta)) 
      => 
      rConfig(Sigma, Delta, emptyTypeContext, 
              R2
             ,I', A, T2) /\
      T2 == typeInCtx(chn cn2, A, Delta) /\    
      I' == insert(chn cn1, insert(chn cn2, I)) /\
      O == insert(chn cn1, insert(chn cn2, empty)) /\
      typeOf(Sigma, Delta, emptyTypeContext, 
             insert(chn cn1, insert(chn cn2, I)), A, R2) 
      == 
      typeInCtx(chn cn2, A, Delta) /\ 
      cn1 =/= cn2 /\
      elem (chn cn1) T1 Delta A
      [nonexec] .
  
   crl [SUBST] : 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= x1 : T1 <- read cn1 ; R2),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= x1 : T1 <- R1 ; R2),
             I, O, A) 
     if
     rConfig(Sigma, Delta, emptyTypeContext,
             x1 : T1 <- R1 ; x2 : T1 <- R1 ; return pair(x1, x2),
             insert(chn cn1, insert(chn cn2, I)), A, 
             T1 * typeInCtx(chn cn2, A, Delta) )
     => 
     rConfig(Sigma, Delta, emptyTypeContext,
             x1 : T1 <- R1 ;  return pair(x1, x1),
             I', A, T' ) /\
     T' ==  T1 * typeInCtx(chn cn2, A, Delta) /\       
     O == insert(chn cn1, chn cn2) /\ 
     I' == insert(chn cn1, insert(chn cn2, I)) /\
     cn1 =/= cn2 /\
     elem (chn cn1) T1 Delta A
     [nonexec] .
 
     
   crl [SUBST-2] : 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= x1 : T1 <- R1 ; R2),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= x1 : T1 <- read cn1 ; R2),
             I, O, A) 
     if
     rConfig(Sigma, Delta, emptyTypeContext,
             x1 : T1 <- R1 ; x2 : T1 <- R1 ; return pair(x1, x2),
             insert(chn cn1, insert(chn cn2, I)), A, T1 * typeInCtx(chn cn2, A, Delta))
     => 
     rConfig(Sigma, Delta , emptyTypeContext,
             x1 : T1 <- R1 ;  return pair(x1, x1),
             I', A, T') /\
     T' ==  T1 * typeInCtx(chn cn2, A, Delta) /\         
     O == insert(chn cn1, insert(chn cn2, empty)) /\ 
     I' == insert(chn cn1, insert(chn cn2, I)) /\
     cn1 =/= cn2 /\
     elem (chn cn1) T1 Delta A
       [nonexec] .     
             
 
endm 

mod PROTOCOL-EQ-DERIVED-NF is
 protecting PROTOCOL-EQ-CORE .
 
 var fns fns1 fns2 cns cns1 cns2 : NameWithScripts . 

 var Sigma : Signature .
 vars Delta D Delta' Delta1 Delta2 : ChannelContext .
 vars R R' R1 R2 R3 R4 S1 S2 S : Reaction .
 vars T T0 T1 T2 T3 : IPDLType .
 vars M M1 M2 : IPDLExpression .
 vars I I' I'' I1 O O' O'' O1 O2 O3 : Set{CNameBound} . 
 var l r c i o o1 o2 o3 : ChannelName .
 var b x x0 x1 x2 x3 y y0 y1 y2 z : ChannelName . *** was Qid 
 vars P P1 P2 P3 P4 Q : Protocol .
 var n : Nat .
 var lq : List{NatTerm} .
 var ltq ltq1 ltq2 : TypedCNameList .
 var Dist : Distribution .
 var q : Qid .
 var ql ql1 ql2 : List{CNameBound} .
     var bt : BoolTerm .  
    var C C' q' : Qid .
    var m : Nat .
  var nt nt1 nt2 : NatTerm .
  var nlist nlist' : List{NatTerm} .
 var cases : Cases .
 var blist blist' : List{Bounds} .
 var cn : ChannelName .
 var bn : CNameBound .   

 
  var BRL BRL' : BRList .
 var QL QL' : List{NatTerm} .
 var A : Set{BoolTerm} .
 var nlist1 nlist2 : List{NatTerm} . 
  var qid1 qid2 : Qid .
    var q1 q2 : Qid .
  var cn1 cn2 : ChannelName .  
     var T' : IPDLType .
     
      var nj nt' : NatTerm .
     var ntl : List{NatTerm} .
     var bounds : List{Bounds} .
     var cases' : Cases .
     var cnb : CNameBound .
     

 *** helper rules
 rl [get-channel] :
 pConfig(Sigma, Delta, P, I, O, A)
 => 
 pConfig(Sigma, Delta, getChannel P cnb, I, O, A)
 [nonexec]
 .
 
 rl [get-structure] :
 pConfig(Sigma, Delta, P, I, O, A)
 => 
 pConfig(Sigma, Delta, getStructure P, I, O, A)  
 .
     
 
 ********************************************
 *** derived rules and rules for normal forms
 ********************************************
 
  
 rl [desugar-newNF] :
     pConfig(Sigma, Delta, newNF(ltq, P1), I, O, A)
     =>
     pConfig(Sigma, Delta, newNF2New(newNF(ltq, P1)), I, O, A) 
 .
     
 rl [sugar-newNF] :
    pConfig(Sigma, Delta, P, I, O, A)
    => 
    pConfig(Sigma, Delta, new2NF(P), I, O, A) 
 .
 
 rl [delete] : *** TODO: just for testing purposes
    pConfig(Sigma, Delta, P || family (fns[blist]) nlist blist ::= return True, I, O, A)
    =>
    pConfig(Sigma, Delta, P || family (fns[blist]) nlist blist ::= cases, I, O, A)
 [nonexec]
 .   
    
 rl [delete-empty-newNF] :
     pConfig(Sigma, Delta, newNF(emptyTypedCNameList, P), I, O, A)
     => 
     pConfig(Sigma, Delta, P, I, O, A) 
 . 
     
 ***( rl [reorder-newNF] :
     pConfig(Sigma, Delta, newNF(ltq, P, ql1), I, O, A)
     =>
     pConfig(Sigma, Delta, newNF(ltq, P, ql2), I, O, A)
    [nonexec]
 . *** check that same names occur in ql1 and ql2 )
        
 crl [CONG-NEW-NF] : 
    pConfig(Sigma, Delta1, newNF(ltq, P1), I, O1, A) 
    => 
    pConfig(Sigma, diff Delta2 (addChannels ltq emptyChannelCtx), 
            newNF(ltq, P2), I, O2 \ (chansInList ltq), A)
    if
    pConfig(Sigma, addChannels ltq Delta1, P1, I, union(chansInList ltq, O1), A)
    =>
    pConfig(Sigma, Delta2, P2, I, O2, A) 
    ***( FOR NOW
    /\ *** the channels in ltq have not changed
    diff (addChannels ltq emptyChannelCtx) Delta2 == emptyChannelCtx
    
    /\
    O2 == getOutputs(P2)
    /\ 
    (addChannels ltq Delta1) equiv Delta2 
    /\ 
    O2 equiv (union(chansInList ltq, O1))
    )
  .
 
 var cnbl cnbl' : List{CNameBound} .
  
 crl [absorb-new-nf] :
     pConfig(Sigma, Delta, newNF(< c : T > ltq, P || (c ::= R)), I, O, A) 
     => 
     pConfig(Sigma, Delta, newNF(ltq, P), I, O, A) 
 if
     typeOf(Sigma, addChannels ltq (Delta (chn c :: T)), emptyTypeContext, 
            insert(chn c, union(I, getOutputs(P))), A, R) == T 
     /\
     typeOf(Sigma, addChannels ltq Delta, I, A, P)       
     /\ 
     getOutputs(newNF2New(newNF(ltq, P))) == O 
   .
   
 crl [comp-new-nf-left] : 
     pConfig(Sigma, Delta, newNF(< c : T > ltq, P || (c ::= R)), I, O, A) 
    => 
     pConfig(Sigma, Delta, newNF(ltq, P || (new c : T in (c ::= R))), I, O, A) 
    if
     typeOf(Sigma, addChannels ltq Delta, I, A, P) 
     /\
     typeOf(Sigma, addChannels ltq (Delta ((chn c) :: T)), emptyTypeContext, 
            insert(chn c, union(I, getOutputs(P))), A, R) == T 
 . 
      
 crl [comp-new-nf-right] :   *** TODO! where we add c
    pConfig(Sigma, Delta, newNF(ltq, P || (new c : T in Q)), I, O, A)
    =>
    pConfig(Sigma, Delta, newNF(< c : T > ltq, P || Q), I, O, A) 
    if
     typeOf(Sigma, addChannels ltq Delta, union(I, getOutputs(Q)), A, P) 
     /\
     typeOf(Sigma, addChannels ltq (Delta ((chn c) :: T)), union(I, getOutputs(P)), A, Q) 
 .
 
  crl [fold-bind-new] :
    pConfig(Sigma, Delta, 
             newNF(< c : T > ltq, P || (c ::= R) || (o ::= x : T <- read c ; S)),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, P || (o ::= x : T <- R ; S)),
            I, O, A) 
    if 
    typeOf(Sigma, addChannels ltq (Delta ((toBound c) :: T)), emptyTypeContext, 
            insert(toBound o, insert(toBound c, union(I, getOutputs(P)))), A, R) == T . 
           
  crl [fold-bind-new-nf] :
    pConfig(Sigma, Delta, 
             newNF(< c : T > ltq, P || ( c ::= R ) || 
                                 ( o ::= nf((x : T <- read c) BRL, S) )
                  ),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, P || (o ::= preNF((x : T <~ R) BRL, S))),
            I, O, A) 
    if typeOf(Sigma, addChannels ltq (Delta ((toBound c):: T)), 
             addDeclarations BRL emptyTypeContext, 
            insert(toBound o, insert(toBound c, union(I, getOutputs(P)))), A, R) == T 
  .  *** TODO: here and below, S matches type of o in Delta! 
  
  crl [fold-bind-new-nf-0] :
    pConfig(Sigma, Delta, 
             newNF(< c : T > ltq, (c ::= R) || 
                                 (o ::= nf((x : T <- read c) BRL, S))),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, (o ::= preNF((x : T <~ R) BRL, S))),
            I, O, A) 
    if typeOf(Sigma, addChannels ltq (Delta ((toBound c):: T)), addDeclarations BRL emptyTypeContext, 
            insert(toBound o, insert(toBound c, I )), A, R) == T 
  .  *** TODO: here and below, S matches type of o in Delta! 
            
  crl [fold-bind-new-prenf] :
    pConfig(Sigma, Delta, 
             newNF(< c : T > ltq, P || (c ::= R) || 
                                 (o ::= preNF((x : T <- read c) BRL, S))),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, P || (o ::= preNF((x : T <~ R) BRL, S))),
            I, O, A) 
    if        
    typeOf(Sigma, addChannels ltq (Delta ((toBound c) :: T)), emptyTypeContext, 
            insert(toBound o, insert(toBound c, union(I, getOutputs(P)))), A, R) == T .
            
 crl [COMP-NEW-newNF] :
     pConfig(Sigma, Delta, P || newNF(ltq, Q), I, O, A)
     =>   
     pConfig(Sigma, Delta, newNF(ltq, P || Q), I, O, A)
 if
     typeOf(Sigma, addChannels ltq Delta, union(I, getOutputs(P)), A, Q)
     *** /\
     *** typeOf(Sigma, Delta, I, *** was  union(I, getOutputs(newNF(ltq, Q, QL))), 
     ***       A, P)     
 .
 
 rl [COMP-NEW-newNF-inside-new] : 
     pConfig(Sigma, Delta, newNF(ltq1, P || newNF(ltq, Q)), I, O, A)
     =>   
     pConfig(Sigma, Delta, newNF(ltq1 ltq, P || Q), I, O, A)
 *** if
 ***    typeOf(Sigma, addChannels ltq Delta, union(I, getOutputs(P)), A, Q)
     *** /\
     *** typeOf(Sigma, Delta, I, *** was  union(I, getOutputs(newNF(ltq, Q, QL))), 
     ***       A, P)     
 .
   
   rl [lift-inner-new-nf] :
     pConfig(Sigma, Delta, newNF(ltq1, newNF(ltq2, P)), I, O, A)
     => 
     pConfig(Sigma, Delta, newNF(ltq1 ltq2, P), I, O, A)
   .
   
  *** this rule is actually derived from drop and samp-pure!    
  crl [DROP-nf] :
    pConfig(Sigma, Delta,
            (cn1 ::= samp Dist) || (cn2 ::= nf( (x : T1 <- read cn1) BRL , R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (cn1 ::= samp Dist) || (cn2 ::= nf( BRL , R2) ),
            I, O, A) 
    if
     typeOf(Sigma, Delta, addDeclarations BRL (x : T1), 
             insert(toBound cn1, insert(toBound cn2, I)), A, R2) == typeInCtx(toBound cn2, A, Delta)
     /\
     elem (toBound cn1) T1 Delta A        
    . 
    
   crl [DROP-nf-copy] :
    pConfig(Sigma, Delta,
            (cn1 ::= nf(emptyBRList, samp Dist)) || 
            (cn2 ::= nf( (x : T1 <- read cn1) BRL , R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (cn1 ::= nf(emptyBRList, samp Dist)) || 
            (cn2 ::= nf( BRL , R2) ),
            I, O, A) 
    if 
     typeOf(Sigma, Delta, addDeclarations BRL (x : T1), 
             insert(toBound cn1, insert(toBound cn2, I)), A, R2) == typeInCtx(toBound cn2, A, Delta)
     /\
     elem (toBound cn1) T1 Delta A
    .  
    
   crl [DROP-nf-channels] :
    pConfig(Sigma, Delta,
            (cn1 ::= nf(BRL, samp Dist)) || 
            (cn2 ::= nf( (x : T1 <- read cn1) BRL' , R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (cn1 ::= nf(BRL, samp Dist)) || 
            (cn2 ::= nf( BRL' , R2) ),
            I, O, A) 
    if 
     typeOf(Sigma, Delta, addDeclarations BRL (x : T1), 
             insert(toBound cn1, insert(toBound cn2, I)), A, R2) == typeInCtx(toBound cn2, A, Delta)
     /\
     elem (toBound cn1) T1 Delta A
    .    
        
    crl [DROP-SUBSUME-channels] :
    pConfig(Sigma, Delta,
            (cn1 ::= nf(BRL, samp Dist)) || 
            (cn2 ::= nf( (x : T1 <- read cn1) BRL' , R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (cn1 ::= nf(BRL, samp Dist)) || 
            (cn2 ::= nf(BRL BRL' , R2) ),
            I, O, A) 
    if 
     typeOf(Sigma, Delta, addDeclarations BRL' (x : T1), 
             insert(toBound cn1, insert(toBound cn2, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta)
     /\
     elem (toBound cn1) T1 Delta A
    .  

    crl [DROP-SUBSUME-channels-pre] :
    pConfig(Sigma, Delta,
            (cn1 ::= nf(BRL, samp Dist)) || 
            (cn2 ::= preNF( (x : T1 <- read cn1) BRL' , R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (cn1 ::= nf(BRL, samp Dist)) || 
            (cn2 ::= preNF(BRL BRL' , R2) ),
            I, O, A) 
    if 
     typeOf(Sigma, Delta, addDeclarations BRL' (x : T1), 
             insert(toBound cn1, insert(toBound cn2, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta)
     /\
     elem (toBound cn1) T1 Delta A
    .  
                   
  crl [DROP-pre-nf] :
    pConfig(Sigma, Delta,
            (cn1 ::= samp Dist) || (cn2 ::= preNF( (x : T1 <- read cn1) BRL , R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (cn1 ::= samp Dist) || (cn2 ::= preNF( BRL , R2) ),
            I, O, A) 
     if
     typeOf(Sigma, Delta, addDeclarations BRL (x : T1), 
             insert(toBound cn1, insert(toBound cn2, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta)
             /\
     elem (toBound cn1) T1 Delta A 
     .    
     
  crl [subst-diverge] : 
    pConfig(Sigma, Delta, 
              (cn1 ::= nf(x1 : T1 <- read cn1, return x1))
              || 
              (cn2 ::= nf( (x2 : T1 <- read cn1) BRL , R2)),
              I, O, A
           )    
    =>
    pConfig(Sigma, Delta, 
              (cn1 ::= nf(x1 : T1 <- read cn1, return x1))
              || 
              (cn2 ::= nf(x3 : T2 <- read cn2, return x3)),
              I, O, A
           ) 
   if        
    O == insert(toBound cn1, toBound cn2)
    /\
    elem (toBound cn1) T1 Delta A
    /\
    elem (toBound cn2) T2 Delta A
    /\
    typeOf(Sigma, Delta, addDeclarations BRL (x2 : T1), 
            insert(toBound cn1, insert(toBound cn2, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta)   
           [nonexec] *** because x3 is new and T2 must be specified as well!
  .                 
   
  crl [SUBST-nf] : 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= nf( (x1 : T1 <- read cn1) BRL , R2) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= preNF((x1 : T1 <~ R1) BRL , R2)),
             I, O, A) 
     if isSampFree(R1) /\
        O == insert(toBound cn1, toBound cn2) /\ 
     typeOf(Sigma, Delta, emptyTypeContext, 
            insert(toBound cn1, insert(toBound cn2, I)), A, R1) == T1 /\
     typeOf(Sigma, Delta, addDeclarations BRL (x1 : T1), 
            insert(toBound cn1, insert(toBound cn2, I)), A, R2) == typeInCtx(toBound cn2, A, Delta)
     /\
     elem (toBound cn1) T1 Delta A 
     . 
     
     
  crl [moveReadInnerNf] :
    pConfig(Sigma, Delta,
             cn1 ::= nf((x : T <- read cn2) BRL , R1) ,
             I, O, A)  
     => 
       pConfig(Sigma, Delta,
             cn1 ::= preNF(BRL , x : T <- read cn2 ; R1) ,
             I, O, A)    
  if elem (toBound cn2) T Delta A 
  /\ typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(toBound cn1, I), A, R1) == typeInCtx(toBound cn1, A, Delta)
  .  
  
    crl [moveReadInnerPreNf] :
    pConfig(Sigma, Delta,
             cn1 ::= preNF((x : T <- read cn2) BRL , R1) ,
             I, O, A)  
     => 
       pConfig(Sigma, Delta,
             cn1 ::= preNF(BRL , x : T <- read cn2 ; R1) ,
             I, O, A)  
    if elem (toBound cn2) T Delta A 
     /\ typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(toBound cn1, I), A, R1) == typeInCtx(toBound cn1, A, Delta)          
  .   
  
  *** TODO : validate this rule!   
  rl [SUBST-nf-rev] : 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= preNF( BRL , R1) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= preNF((x1 : T1 <- read cn1) BRL , return x1 )),
             I, O, A)   
  [nonexec] .  
  
  crl [SUBST-nf-read] : 
     pConfig(Sigma, Delta,
             (cn1 ::= nf((x2 : T1 <- read cn), return x2)) || 
             (cn2 ::= nf( (x1 : T1 <- read cn1) BRL , R2) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (cn1 ::= nf((x2 : T1 <- read cn), return x2)) || 
             (cn2 ::= nf((x2 : T1 <- read cn) BRL , R2 [x1 / x2])),
             I, O, A) 
     if
     isElemB(cn, I, A) /\
     O == insert(toBound cn1, toBound cn2) /\ 
     typeOf(Sigma, Delta, addDeclarations BRL (x1 : T1), 
             insert(toBound cn1, insert(toBound cn2, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta)
             /\
     elem (toBound cn1) T1 Delta A 
             /\
     elem (toBound cn) T1 Delta A           
     .   
 
endm

mod PROTOCOL-JSON is
 pr PROTOCOL-TYPING .
 
 var fns fns1 fns2 cns cns1 cns2 : ChannelName . 

 var Sigma : Signature .
 vars Delta D Delta' : ChannelContext .
 vars R R' R1 R2 R3 R4 S1 S2 S : Reaction .
 vars T T0 T1 T2 T3 : IPDLType .
 vars M M1 M2 : IPDLExpression .
 vars I I' I'' I1 O O' O'' O1 O2 O3 : Set{CNameBound} . 
 var l r c i o o1 o2 o3 : ChannelName .
 var b x x0 x1 x2 y y0 y1 y2 z : ChannelName . *** was Qid 
 vars P P1 P2 P3 P4 Q : Protocol .
 var n : Nat .
 var lq : List{NatTerm} .
 var ltq ltq1 ltq2 : TypedCNameList .
 var Dist : Distribution .
 var q : Qid .
 var ql ql1 ql2 : List{CNameBound} .
     var bt : BoolTerm .  
    var C C' q' : Qid .
    var m : Nat .
  var nt nt1 nt2 : NatTerm .
  var nlist nlist' : List{NatTerm} .
 var cases : Cases .
 var blist blist' : List{Bounds} .
 var cn : ChannelName .
 var bn : CNameBound .   

 
  var BRL : BRList .
 var QL : List{NatTerm} .
 var A : Set{BoolTerm} .
 var nlist1 nlist2 : List{NatTerm} . 
  var qid1 qid2 : Qid .
    var q1 q2 : Qid .
  var cn1 cn2 : ChannelName .  
     var T' : IPDLType .
     
      var nj nt' : NatTerm .
     var ntl : List{NatTerm} .
     var bounds : List{Bounds} .
     var cases' : Cases .
     var whenList : WhenList .
     var whenCond : WhenCond .
 
  *** TODO: move elsewhere
 op toJSON__ : Protocol ChannelContext -> JSON .
 eq toJSON emptyProtocol Delta = {} .
  *** eq toJSON (P1 || P2) Delta = {(toJSON P1 Delta) (toJSON P2 Delta)} .
  ***    toJSON(P1 || P2 || P3) 
  *** =  {{P1} {P2 || P3}}
  *** =  {{P1} {{P2} {P3}}}
  *** when I want it to be
  *** = {{P1}{P2}{P3}}      
  *** so I have to do a case distinction for protocols without compositions
  
 eq toJSON (emptyProtocol || P2) Delta = {{} (toJSON P2 Delta)} .
 
 eq toJSON ((cn ::= cases) || P2) Delta =
    insertJSON (toJSON (cn ::= cases) Delta) (toJSON P2 Delta) .
 eq toJSON ((family (fns[blist]) nlist blist ::= cases) || P2) Delta =
    insertJSON (toJSON (family (fns[blist]) nlist blist ::= cases) Delta) (toJSON P2 Delta) . 
 eq toJSON ((new cn : T in P) || P2) Delta =
    insertJSON (toJSON (new cn : T in P) Delta) (toJSON P2 Delta) .
 eq toJSON ((newfamily (cn[blist]) nlist blist : T in P) || P2) Delta =
    insertJSON (toJSON (newfamily (cn[blist]) nlist blist : T in P) Delta) (toJSON P2 Delta) .  
       
 eq toJSON (cn ::= R) (Delta (chn cn :: T)) =
           {cname: cn, value: {reaction: R}, hasType: {type: T}, 
            isInternal: false, extras: {}} .
 eq toJSON (cn ::= P) Delta =
           {cname: cn, value: (toJSON P Delta), 
            hasType: {}, isInternal: false, extras: {}} .
 eq toJSON (cn ::= whenList) (Delta (chn cn :: T)) =
           {cname: cn, value: (toJSON whenList (Delta (chn cn :: T))), 
            hasType: {type: T}, isInternal: false, extras: {}} . 
            
 op toJSON : WhenList ChannelContext -> JSON .
 eq toJSON (whenCond --> R) Delta = {cond: whenCond, reaction: R} .
 eq toJSON (whenCond --> P) Delta = {cond: whenCond, protocol: toJSON P Delta} .
 eq toJSON ((whenCond --> R) ;; whenList) Delta = 
    insertJSON ({cond: whenCond, reaction: R}) (toJSON whenList Delta) . 
 eq toJSON ((whenCond --> P) ;; whenList) Delta = 
    insertJSON ({cond: whenCond, protocol: (toJSON P Delta)}) 
               (toJSON whenList Delta) 
 .
 
 eq toJSON (family (fns[blist]) nlist blist ::= R) (Delta (fam (fns[blist]) :: T)) =
           {cname: fns, value: {reaction: R}, hasType: {type: T}, isInternal: false,
            extras: {indices: nlist, bounds: blist}
           } .
 eq toJSON (family (fns[blist]) nlist blist ::= P) Delta =
           {cname: fns, value: (toJSON P Delta), 
            hasType: {}, isInternal: false,
            extras: {indices: nlist, bounds: blist}
           } .
 eq toJSON (family (fns[blist]) nlist blist ::= ((whenCond --> R) ;; whenList)
           ) 
           (Delta (fam (fns[blist]) :: T)) =
           {cname: fns, 
            value: (toJSON 
                     ((whenCond --> R) ;; whenList)
                     (Delta (fam (fns[blist]) :: T))
                   ), 
            hasType: {type: T}, isInternal: false,
            extras: {indices: nlist, bounds: blist}} .
 eq toJSON (family (fns[blist]) nlist blist ::= ((whenCond --> P) ;; whenList)
           ) 
           Delta =
           {cname: fns, 
            value: (toJSON 
                     ((whenCond --> P) ;; whenList)
                     Delta
                   ), 
            hasType: {}, isInternal: false,
            extras: {indices: nlist, bounds: blist}} .                                      
                      
 eq toJSON (new cn : T in P) Delta = 
      updateInternal(toJSON P (Delta (chn cn :: T)), cn) .     
 eq toJSON (newfamily (cn[blist]) nlist blist : T in P) Delta = 
      updateInternal(toJSON P (Delta (fam (cn[blist]) :: T)), cn) .
                            
endm 
 
mod PROTOCOL-EQ-FAMILY is
 

 protecting PROTOCOL-EQ-DERIVED-NF .
 
 var fns fns1 fns2 cns cns1 cns2 : NameWithScripts . 

 var Sigma : Signature .
 vars Delta D Delta' Delta1 Delta2 : ChannelContext .
 vars R R' R1 R2 R3 R4 S1 S2 S : Reaction .
 vars T T0 T1 T2 T3 : IPDLType .
 vars M M1 M2 : IPDLExpression .
 vars I I' I'' I1 O O' O'' O1 O2 O3 : Set{CNameBound} . 
 var l r c i o o1 o2 o3 : ChannelName .
 var b x x0 x1 x2 x3 y y0 y1 y2 z : ChannelName . *** was Qid 
 vars P P1 P2 P3 P4 Q : Protocol .
 var n : Nat .
 var lq : List{NatTerm} .
 var ltq ltq1 ltq2 : TypedCNameList .
 var Dist : Distribution .
 var q : Qid .
 var ql ql1 ql2 : List{CNameBound} .
 var bt : BoolTerm .  
 var C C' q' q'' : Qid .
 var m : Nat .
 var nt nt1 nt2 : NatTerm .
 var nlist nlist' : List{NatTerm} .
 var cases : Cases .
 var blist blist' : List{Bounds} .
 var cn : ChannelName .
 var bn : CNameBound .   

 
  var BRL BRL' : BRList .
 var QL QL' : List{NatTerm} .
 var A A' : Set{BoolTerm} .
 var nlist1 nlist2 : List{NatTerm} . 
 var qid1 qid2 : Qid .
 var q1 q2 q3 : Qid .
 var cn1 cn2 : ChannelName .  
 var T' : IPDLType .
     
 var nj nt' nt3 : NatTerm .
 var ntl : List{NatTerm} .
 var bounds : List{Bounds} .
 var cases' : Cases .
 var bd1 bd2 bd3 bd4 bd5 bd6 : Bounds .
             
 var bt1 bt2 bt3 bt4 : BoolTerm .
 var tlist : List{NatTerm} .
 var blist1 : List{Bounds} .
  
 var cnbl cnbl' : List{CNameBound} .
  
 var q4 q5 q6 : Qid .
 var whenList whenList' whenList1 whenList2 : WhenList .
 var whenCond : WhenCond .

 *** remove branching
 rl [REMOVE-BRANCH] :
 pConfig(Sigma, Delta, family (fns[blist]) nlist blist ::= when bt --> R, I, O, A)
 => 
 pConfig(Sigma, Delta, family (fns[blist]) nlist blist ::= R, I, O, A)
 *** if addAssumptions A nlist blist |= bt with empty 
 .
 
 rl [REMOVE-OTHERWISE] :
 pConfig(Sigma, Delta, family (fns[blist]) nlist blist ::= otherwise --> R, I, O, A)
 => 
 pConfig(Sigma, Delta, family (fns[blist]) nlist blist ::= R, I, O, A)
 .

 rl [fix-index] : 
 pConfig(Sigma, Delta, 
  family (fns[bd1 (fixedBound nt) bd3]) 
         (nt1 nt2 nt3) 
         (bd1 (fixedBound nt) bd3) ::= 
          nf( (x : T <- read (fns[nt1 nt2 nt3])) BRL, R), I, O, A)
  =>
  pConfig(Sigma, Delta, 
  family (fns[bd1 (fixedBound nt) bd3]) 
         (nt1 nt2 nt3) 
         (bd1 (fixedBound nt) bd3) ::= 
          nf( (x : T <- read (fns[nt1 nt nt3])) BRL, R), I, O, A)
  .        


  *** split a family
 rl [SPLIT-family-2] : 
  pConfig(Sigma, Delta (fam (fns[(bound (nt + natAsTerm(2))) bd2]) :: T), 
     family (fns[(bound (nt + natAsTerm(2))) bd2]) 
            ((qidAsTerm q1)(qidAsTerm q2)) ((bound (nt + natAsTerm(2))) bd2) ::= cases, 
     I, fam (fns[(bound (nt + natAsTerm(2))) bd2]), A)
  => 
   pConfig(Sigma, 
      Delta (fam (fns[(bound (nt + natAsTerm(1))) bd2]) :: T) 
            (fam (fns[(fixedBound (nt + natAsTerm(1))) bd2]) :: T), 
      (family (fns[(bound (nt + natAsTerm(1))) bd2]) 
              ((qidAsTerm q1)(qidAsTerm q2)) ((bound (nt + natAsTerm(1))) bd2) ::= cases)
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd2]) 
                ((qidAsTerm q1)(qidAsTerm q2)) ((bound (nt + natAsTerm(2))) bd2) ::= cases) 
        (qidAsTerm q1) (nt + natAsTerm(1)) 
        (addAssumptions A ((qidAsTerm q1)(qidAsTerm q2)) ((bound (nt + natAsTerm(2))) bd2)) empty), I, 
      (fam (fns[(bound (nt + natAsTerm(1))) bd2]), fam (fns[(fixedBound (nt + natAsTerm(1))) bd2])), 
      A) 
 . 

  *** split on second index
 
 rl [SPLIT-family-3] : 
  pConfig(Sigma, Delta (fam (fns[bd1 (bound (nt + natAsTerm(2))) bd3]) :: T), 
     family (fns[bd1 (bound (nt + natAsTerm(2))) bd3]) 
            ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
            (bd1 (bound (nt + natAsTerm(2))) bd3) ::= cases, 
     I, fam (fns[bd1 (bound (nt + natAsTerm(2))) bd3]), A) 
  => 
   pConfig(Sigma, 
      Delta (fam (fns[bd1 (bound (nt + natAsTerm(1))) bd3]) :: T) 
            (fam (fns[bd1 (fixedBound (nt + natAsTerm(1))) bd3]) :: T), 
      (family (fns[bd1 (bound (nt + natAsTerm(1))) bd3]) 
              ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
              (bd1 (bound (nt + natAsTerm(1))) bd3) ::= cases)
      ||
      (project2Index 
        (family (fns[bd1 (bound (nt + natAsTerm(2))) bd3]) 
                ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3)
                (bd1 (bound (nt + natAsTerm(2))) bd3) ::= cases) 
        (qidAsTerm q2) (nt + natAsTerm(1)) 
        (addAssumptions A ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
                          (bd1 (bound (nt + natAsTerm(2))) bd3)) empty), I, 
      (fam (fns[bd1 (bound (nt + natAsTerm(1))) bd3]), 
       fam (fns[bd1 (fixedBound (nt + natAsTerm(1))) bd3])), 
      A) 
 . 

  rl [SPLIT-fst-family-3] : 
  pConfig(Sigma, Delta (fam (fns[(bound (nt + natAsTerm(2))) bd2 bd3]) :: T), 
     family (fns[(bound (nt + natAsTerm(2))) bd2 bd3]) 
              ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3)  
              ((bound (nt + natAsTerm(2))) bd2 bd3) ::= cases, 
     I, fam (fns[(bound (nt + natAsTerm(2))) bd2 bd3]), A) 
  => 
   pConfig(Sigma, 
      Delta (fam (fns[(bound (nt + natAsTerm(1))) bd2 bd3]) :: T) 
            (fam (fns[(fixedBound (nt + natAsTerm(1))) bd2 bd3]) :: T), 
      (family (fns[(bound (nt + natAsTerm(1))) bd2 bd3]) 
              ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
              ((bound (nt + natAsTerm(1))) bd2 bd3) ::= cases)
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd2 bd3]) 
              ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3)  
              ((bound (nt + natAsTerm(2))) bd2 bd3) ::= cases) 
        (qidAsTerm q1) 
        (nt + natAsTerm(1)) 
        (addAssumptions A 
            ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
            ((bound (nt + natAsTerm(2))) bd2 bd3)) empty), I, 
      (fam (fns[(bound (nt + natAsTerm(1))) bd2 bd3]), 
       fam (fns[(fixedBound (nt + natAsTerm(1))) bd2 bd3])), 
      A) 
 . 

 *** split on first index
  var vNat : Nat .
  var vQid : Qid .
 
   rl [SPLIT-fst-family-1] : 
  pConfig(Sigma, Delta (fam ( q[(bound (nt + natAsTerm(2)) ) ]) :: T), 
     family (q[(bound (nt + natAsTerm(2)))]) 
              (qidAsTerm q1)  
              (bound (nt + natAsTerm(2))) ::= cases, 
     I, fam (q[(bound (nt + natAsTerm(2)))]), A) 
  => 
   pConfig(Sigma, 
      Delta (fam (q[(bound (nt + natAsTerm(1)))]) :: T) 
            (chn (q[nt + natAsTerm(1)]) :: T), 
      (family (q[(bound (nt + natAsTerm(1))) ]) 
              (qidAsTerm q1)
              (bound (nt + natAsTerm(1))) ::= cases)
      ||
      (project2Index 
        (family (q[(bound (nt + natAsTerm(2)))]) 
              (qidAsTerm q1)
              (bound (nt + natAsTerm(2)))  ::= cases) 
        (qidAsTerm q1) 
        (nt + natAsTerm(1)) 
        (addAssumptions A 
            (qidAsTerm q1)
            (bound (nt + natAsTerm(2)))) 
        empty), I, 
      ( fam (q[bound (nt + natAsTerm(1)) ]), 
        chn (q[nt + natAsTerm(1)]) ), 
      A) 
 . 


 *** split a one-index family inside a nf
 rl [SPLIT-family-1-newnf] : 
  pConfig(Sigma, Delta, 
     newNF(ltq { (fns[bound (nt + natAsTerm vNat) ]) (qidAsTerm q1)  : T },
     P || family (fns[bound (nt + natAsTerm vNat) ]) 
           (qidAsTerm q1) 
           (bound (nt + natAsTerm vNat)) ::= cases),
     I, O, A) 
  => 
   pConfig(Sigma, 
      Delta, 
      newNF(ltq { (fns[bound (nt + natAsTerm (diff(vNat, 1)))]) (qidAsTerm q1) : T } 
                < fns[(nt + natAsTerm (diff(vNat, 1)))] : T > , 
      P ||
      (family (fns[bound (nt + natAsTerm (diff(vNat, 1)))]) 
              (qidAsTerm q1) (bound (nt + natAsTerm (diff(vNat, 1)))) ::= cases)
      ||
      (project2Index 
        (family (fns[bound (nt + natAsTerm vNat) ]) 
           (qidAsTerm q1) 
           (bound (nt + natAsTerm vNat)) ::= cases) 
        (qidAsTerm q1) (nt + natAsTerm (diff(vNat, 1))) A  empty)
      )        
        , I, O, A)
      
 . 

  *** split a family inside a normal form, store the splits in order
 rl [SPLIT-family-2-newnf] : 
  pConfig(Sigma, Delta, 
     newNF(ltq { (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) : T },
     P || family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases
     ),
     I, O, A) 
  => 
   pConfig(Sigma, 
      Delta, 
      newNF(ltq { (fns[(bound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) : T } 
                { (fns[(fixedBound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) : T }, 
      P ||
      (family (fns[(bound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(1))) bd2) ::= cases)
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases) 
        (qidAsTerm q1) (nt + natAsTerm(1))  (addAssumptions A ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2))  empty)
      )        
        , I, O, A)
      
 .  
 
 rl [SPLIT-family-2-newnf] : 
  pConfig(Sigma, Delta, 
     newNF(ltq { (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) : T },
     P || family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases
     ),
     I, O, A) 
  => 
   pConfig(Sigma, 
      Delta, 
      newNF(ltq { (fns[(bound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) : T } 
                { (fns[(fixedBound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) : T }, 
      P ||
      (family (fns[(bound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(1))) bd2) ::= cases)
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases) 
        (qidAsTerm q1) (nt + natAsTerm(1))  (addAssumptions A ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2))  empty)
      )      
        , I, O, A)
      
 .  

  *** same for 3 indices, second position
 rl [SPLIT-family-3-newnf] : 
  pConfig(Sigma, Delta, 
     newNF(ltq { (fns[bd1 (bound (nt + natAsTerm(2))) bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) : T },
     P || family (fns[bd1 (bound (nt + natAsTerm(2))) bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
                     (bd1 (bound (nt + natAsTerm(2))) bd3) ::= cases
          ),
     I, O, A) 
  => 
   pConfig(Sigma, 
      Delta, 
      newNF(ltq { (fns[bd1 (bound (nt + natAsTerm(1))) bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) : T } 
                { (fns[bd1 (fixedBound (nt + natAsTerm(1))) bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) : T }, 
      P ||
      (family (fns[bd1 (bound (nt + natAsTerm(1))) bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
                  (bd1 (bound (nt + natAsTerm(1))) bd3) ::= cases)
      ||
      (project2Index 
        (family (fns[bd1 (bound (nt + natAsTerm(2))) bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
                    (bd1 (bound (nt + natAsTerm(2))) bd3) ::= cases) 
        (qidAsTerm q2) 
        (nt + natAsTerm(1)) (addAssumptions A ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 (bound (nt + natAsTerm(2))) bd3)) empty)
      ),       
      I, O, A)
 .  

 *** same for 3 indices, first position
 rl [SPLIT-fst-family-3-newnf] : 
  pConfig(Sigma, Delta, 
     newNF(ltq { (fns[(bound (nt + natAsTerm(2))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) : T },
     P || family (fns[(bound (nt + natAsTerm(2))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
                     ((bound (nt + natAsTerm(2))) bd2 bd3) ::= cases),
     I, O, A) 
  => 
   pConfig(Sigma, 
      Delta, 
      newNF(ltq { (fns[(bound (nt + natAsTerm(1))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) : T } 
                { (fns[(fixedBound (nt + natAsTerm(1))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) : T }, 
      P ||
      (family (fns[(bound (nt + natAsTerm(1))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
                  ((bound (nt + natAsTerm(1))) bd2 bd3) ::= cases)
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
                    ((bound (nt + natAsTerm(2))) bd2 bd3) ::= cases) 
        (qidAsTerm q1) (nt + natAsTerm(1))  (addAssumptions A ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) ((bound (nt + natAsTerm(2))) bd2 bd3)) empty)
      )        
        , I, O, A)
 .

 *** split a family inside a group and a normal form
 *** store the splits in order
 rl [SPLIT-family-2-newnf-group] : 
  pConfig(Sigma, Delta, 
     newNF(ltq { (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) : T },
     P || 
      (family (fns1[blist]) nlist blist ::= 
      (P1 ||
      family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases
      )
      )
    ),
     I, O, A) 
  => 
   pConfig(Sigma, 
      Delta, 
      newNF(ltq { (fns[(bound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) : T } 
                { (fns[(fixedBound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) : T }, 
      P || (family (fns1[blist]) nlist blist ::= 
      (P1 ||
      (family (fns[(bound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(1))) bd2) ::= cases)
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases) 
        (qidAsTerm q1) (nt + natAsTerm(1))  (addAssumptions A ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2))  empty)
      ))
      )        
        , I, O, A)     
 .  

 *** same for 3 indices second position
 rl [SPLIT-family-3-newnf-group] : 
  pConfig(Sigma, Delta, 
     newNF(ltq { (fns[bd1 (bound (nt + natAsTerm(2))) bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) : T },
     P || 
     (family (fns1[blist]) nlist blist ::= 
      (P1 ||
     family (fns[bd1 (bound (nt + natAsTerm(2))) bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
                     (bd1 (bound (nt + natAsTerm(2))) bd3) ::= cases))),
     I, O, A) 
  => 
   pConfig(Sigma, 
      Delta, 
      newNF(ltq { (fns[bd1 (bound (nt + natAsTerm(1))) bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) : T } 
                { (fns[bd1 (fixedBound (nt + natAsTerm(1))) bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) : T }, 
      P ||
      (family (fns1[blist]) nlist blist ::= 
      (P1 ||
      (family (fns[bd1 (bound (nt + natAsTerm(1))) bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
                  (bd1 (bound (nt + natAsTerm(1))) bd3) ::= cases)
      ||
      (project2Index 
        (family (fns[bd1 (bound (nt + natAsTerm(2))) bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
                    (bd1 (bound (nt + natAsTerm(2))) bd3) ::= cases) 
        (qidAsTerm q2) 
        (nt + natAsTerm(1)) (addAssumptions A ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 (bound (nt + natAsTerm(2))) bd3)) empty)
      ))
      )        
        , I, O, A)
 . 

 *** same for 3 indices, first position
 rl [SPLIT-fst-family-3-newnf-group] : 
  pConfig(Sigma, Delta, 
     newNF(ltq { (fns[(bound (nt + natAsTerm(2))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) : T },
     P || 
     (family (fns1[blist]) nlist blist ::= 
      (P1 ||
     family (fns[(bound (nt + natAsTerm(2))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
                     ((bound (nt + natAsTerm(2))) bd2 bd3) ::= cases))),
     I, O, A) 
  => 
   pConfig(Sigma, 
      Delta, 
      newNF(ltq { (fns[(bound (nt + natAsTerm(1))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) : T } 
                { (fns[(fixedBound (nt + natAsTerm(1))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) : T }, 
      P ||
      (family (fns1[blist]) nlist blist ::= 
      (P1 ||
      (family (fns[(bound (nt + natAsTerm(1))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
                  ((bound (nt + natAsTerm(1))) bd2 bd3) ::= cases)
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
                    ((bound (nt + natAsTerm(2))) bd2 bd3) ::= cases) 
        (qidAsTerm q1) (nt + natAsTerm(1))  (addAssumptions A ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) ((bound (nt + natAsTerm(2))) bd2 bd3)) empty)
      )) 
      )        
        , I, O, A)
 .

  *** unsplit a family

 rl [UNSPLIT-family-2] : 
 pConfig(Sigma, 
      Delta (fam (fns[(bound (nt + natAsTerm(1))) bd2]) :: T) (fam (fns[(fixedBound (nt + natAsTerm(1))) bd2]) :: T), 
     (family (fns[(bound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(1))) bd2) ::= cases)
     ||
     (family (fns[(fixedBound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((fixedBound (nt + natAsTerm(1))) bd2) ::= cases'), 
     I, (fam (fns[(bound (nt + natAsTerm(1))) bd2]), fam (fns[(fixedBound (nt + natAsTerm(1))) bd2])) , A)
  => 
   pConfig(Sigma, 
      Delta (fam (fns[(bound (nt + natAsTerm(2))) bd2]) :: T), 
      (family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases), 
      I, 
      fam (fns[(bound (nt + natAsTerm(2))) bd2]), 
      A) 
 .  
 

  rl [UNSPLIT-fst-family-3] : 
 pConfig(Sigma, 
      Delta (fam (fns[(bound (nt + natAsTerm(1))) bd2 bd3]) :: T)  
            (fam (fns[(fixedBound (nt + natAsTerm(1))) bd2 bd3]) :: T), 
     (family (fns[(bound (nt + natAsTerm(1))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) ((bound (nt + natAsTerm(1))) bd2 bd3) ::= cases)
     ||
     (family (fns[(fixedBound (nt + natAsTerm(1))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) ((fixedBound (nt + natAsTerm(1))) bd2 bd3) ::= cases'), 
     I, (fam (fns[(bound (nt + natAsTerm(1))) bd2 bd3]), fam (fns[(fixedBound (nt + natAsTerm(1))) bd2 bd3])) , A)
  => 
   pConfig(Sigma, 
      Delta (fam (fns[(bound (nt + natAsTerm(2))) bd2 bd3]) :: T), 
      (family (fns[(bound (nt + natAsTerm(2))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) ((bound (nt + natAsTerm(2))) bd2 bd3) ::= 
        (when (qidAsTerm q1 =T= nt + natAsTerm(1)) --> cases') ;;
        (when (neg (qidAsTerm q1 =T= nt + natAsTerm(1))) --> cases)
      )  , 
      I, 
      fam (fns[(bound (nt + natAsTerm(2))) bd2 bd3]), 
      A) 
 .

 rl [UNSPLIT-fst-family-1-nf] : 
 pConfig(Sigma, 
      Delta, 
      newNF(ltq { (fns[bound (natAsTerm vNat + qidAsTerm q) ]) (qidAsTerm q1) : T } 
                < fns[natAsTerm vNat + qidAsTerm q] : T > , 
      P ||
      (family (fns[bound (natAsTerm vNat + qidAsTerm q) ]) 
              (qidAsTerm q1) 
              (bound (natAsTerm vNat + qidAsTerm q)) ::= cases)
      ||
      (fns[natAsTerm vNat + qidAsTerm q] ::= cases')
      ) 
     ,
     I, O, A)
  => 
   pConfig(Sigma, 
      Delta, 
      newNF(ltq { (fns[bound (natAsTerm (vNat + 1) + qidAsTerm q)]) (qidAsTerm q1) : T }, 
      P ||
      (family (fns[bound (natAsTerm (vNat + 1) + qidAsTerm q) ]) 
            (qidAsTerm q1) (bound (natAsTerm (vNat + 1) + qidAsTerm q) ) ::= 
        (when (qidAsTerm q1 =T= (natAsTerm vNat + qidAsTerm q)) --> cases') ;;
        (when (neg (qidAsTerm q1 =T= (natAsTerm vNat + qidAsTerm q) )) --> cases)
      )
      ),
     I, O, A)
 . 

 rl [UNSPLIT-fst-family-1-nf-old] : 
 pConfig(Sigma, 
      Delta, 
      newNF(ltq { (fns[bound (natAsTerm (n + vNat))]) (qidAsTerm q1) : T } 
                < fns[natAsTerm ( n + vNat)] : T > , 
      P ||
      (family (fns[bound (natAsTerm (n + vNat)) ]) (qidAsTerm q1) (bound (natAsTerm (n + vNat))) ::= cases)
      ||
      (fns[natAsTerm (n + vNat)] ::= cases')
     ),
     I, O, A)
  => 
   pConfig(Sigma, 
      Delta, 
      newNF(ltq { (fns[bound (natAsTerm (n + vNat + 1))]) (qidAsTerm q1) : T }, 
      P ||
      (family (fns[bound (natAsTerm (n + vNat + 1)) ]) 
            (qidAsTerm q1) (bound (natAsTerm (n + vNat + 1))) ::= 
        (when (qidAsTerm q1 =T= (natAsTerm (n + vNat))) --> cases') ;;
        (when (neg (qidAsTerm q1 =T= (natAsTerm (n + vNat)))) --> cases)
      )
      ),
     I, O, A)
 . 
 
  rl [UNSPLIT-fst-family-3-nf] : 
 pConfig(Sigma, 
      Delta,
      newNF(ltq {(fns[(bound (nt + natAsTerm(1))) bd2 bd3]) nlist : T }  
             {(fns[(fixedBound (nt + natAsTerm(1))) bd2 bd3]) nlist : T },
      P ||
     (family (fns[(bound (nt + natAsTerm(1))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) ((bound (nt + natAsTerm(1))) bd2 bd3) ::= cases)
     ||
     (family (fns[(fixedBound (nt + natAsTerm(1))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) ((fixedBound (nt + natAsTerm(1))) bd2 bd3) ::= cases') 
     ),
     I, O, A)
  => 
    pConfig(Sigma, 
      Delta,
      newNF(ltq {(fns[(bound (nt + natAsTerm(2))) bd2 bd3]) nlist : T }  
             , 
      P ||
     (family (fns[(bound (nt + natAsTerm(2))) bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) ((bound (nt + natAsTerm(2))) bd2 bd3) ::= 
        (when (qidAsTerm q1 =T= nt + natAsTerm(1)) --> cases') ;;
        (when (neg (qidAsTerm q1 =T= nt + natAsTerm(1))) --> cases)
      )
     ) ,
     I, O, A)
 .
 
 *** split a family on every branch of a protocol  
 
 var fn : FamilyName .
 
 rl [SPLIT-family-2-all-branches-end] : 
  pConfig(Sigma, Delta (fam (fns[(bound (nt + natAsTerm(2))) bd2]) :: T), 
    family fn nlist blist ::= 
     whenCond --> 
     ((family (fns[(bound (nt + natAsTerm(2))) bd2]) 
              ( (qidAsTerm q1)(qidAsTerm q2) ) 
              ((bound (nt + natAsTerm(2))) bd2) ::= cases) || P), 
     I, (fam (fns[(bound (nt + natAsTerm(2))) bd2]), O), A)
  => 
   pConfig(Sigma, 
      Delta (fam (fns[(bound (nt + natAsTerm(1))) bd2]) :: T) (fam (fns[(fixedBound (nt + natAsTerm(1))) bd2]) :: T), 
      family fn nlist blist ::= 
      whenCond --> 
      (P ||
      (family (fns[(bound (nt + natAsTerm(1))) bd2]) 
              ( (qidAsTerm q1)(qidAsTerm q2) ) 
              ((bound (nt + natAsTerm(1))) bd2) ::= cases)
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd2]) 
                ( (qidAsTerm q1)(qidAsTerm q2) ) 
                ((bound (nt + natAsTerm(2))) bd2) ::= cases) 
        (qidAsTerm q1) (nt + natAsTerm(1))  
        (addAssumptions A ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2)) empty)
       ), 
       I, (fam (fns[(bound (nt + natAsTerm(1))) bd2]), fam (fns[(fixedBound (nt + natAsTerm(1))) bd2]), O), 
      A) 
 . 

  rl [SPLIT-all-branches-nf-2] :
 pConfig(Sigma, Delta, newNF(ltq {(fns[(bound (nt + natAsTerm(2))) bd2]) nlist : T}, 
   P || family fn nlist' blist' ::= cases), I, O, A)
 => 
 pConfig(Sigma, Delta, 
   newNF(ltq {(fns[(bound (nt + natAsTerm(1))) bd2]) nlist : T}
             {(fns[(fixedBound (nt + natAsTerm(1))) bd2]) nlist : T}, 
             P || splitFamilyOnAllBranches (family fn nlist' blist' ::= cases) fns A
        ), 
   I, O, A) 
 .

  rl [SPLIT-all-branches-nf-3] :
 pConfig(Sigma, Delta, newNF(ltq {(fns[bd1 (bound (nt + natAsTerm(2))) bd2]) nlist : T}, 
   P || family fn nlist' blist' ::= cases), I, O, A)
 => 
 pConfig(Sigma, Delta, 
   newNF(ltq {(fns[bd1 (bound (nt + natAsTerm(1))) bd2]) nlist : T}
             {(fns[bd1 (fixedBound (nt + natAsTerm(1))) bd2]) nlist : T}, 
             P || splitFamilyOnAllBranches (family fn nlist' blist' ::= cases) fns A
        ), 
   I, O, A) 
 .
 
 rl [SPLIT-all-branches-top-2] :
 pConfig(Sigma, Delta (fam (fns[(bound (nt + natAsTerm(2))) bd2]) :: T) , 
  P || family fn nlist' blist' ::= cases, I, 
  (fam (fns[(bound (nt + natAsTerm(2))) bd2]), O), A)
 => 
 pConfig(Sigma, 
      Delta (fam (fns[(bound (nt + natAsTerm(1))) bd2]) :: T) (fam (fns[(fixedBound (nt + natAsTerm(1))) bd2]) :: T), 
      P || splitFamilyOnAllBranches (family fn nlist' blist' ::= cases) fns A,
      I,
      (fam (fns[(bound (nt + natAsTerm(1))) bd2]), fam (fns[(fixedBound (nt + natAsTerm(1))) bd2]), O), 
      A)
 .  
 
 rl [SPLIT-all-branches-top-3] :
 pConfig(Sigma, Delta (fam (fns[bd1 (bound (nt + natAsTerm(2))) bd2]) :: T) , 
  P || family fn nlist' blist' ::= cases, I, 
  (fam (fns[bd1 (bound (nt + natAsTerm(2))) bd2]), O), A)
 => 
 pConfig(Sigma, 
      Delta (fam (fns[bd1 (bound (nt + natAsTerm(1))) bd2]) :: T) 
            (fam (fns[bd1 (fixedBound (nt + natAsTerm(1))) bd2]) :: T), 
      P || splitFamilyOnAllBranches (family fn nlist' blist' ::= cases) fns A,
      I,
      (fam (fns[bd1 (bound (nt + natAsTerm(1))) bd2]), fam (fns[bd1 (fixedBound (nt + natAsTerm(1))) bd2]), O), 
      A)
 . 

 op mergeCases__ : Protocol Protocol -> Protocol .
 eq mergeCases (family (fns[blist]) nlist blist ::= whenList1)   
               (family (fns[blist]) nlist blist ::= whenList2) =
    (family (fns[blist]) nlist blist ::= whenList1 ;; whenList2) 
 . 
 
 op dropBranch___ : Protocol Qid NatTerm -> Protocol .
 eq dropBranch   
     (family (fns[blist]) nlist blist ::= 
        whenList1 ;; 
        (when (qidAsTerm q =T= nt) --> cases) ;; 
        whenList2)
     q nt =   
     (family (fns[blist]) nlist blist ::= whenList1 ;; whenList2) 
 .
 eq dropBranch P q nt = P [owise] .

 op splitFamilyOnAllBranches___ : Protocol NameWithScripts Set{BoolTerm} -> Protocol .
 eq splitFamilyOnAllBranches 
    (family fn nlist blist ::= 
     whenCond --> 
     ((family (fns[(bound (nt + natAsTerm(2))) bd2]) 
              ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases) || P)
    )
    fns
    A =
    family fn nlist blist ::= 
      whenCond --> 
      (P ||
      (dropBranch
      (family (fns[(bound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(1))) bd2) ::= cases)
      q1 (nt + natAsTerm(1)) 
      )
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd2]) 
                ( (qidAsTerm q1)(qidAsTerm q2) ) 
                ((bound (nt + natAsTerm(2))) bd2) ::= cases
        ) 
        (qidAsTerm q1) (nt + natAsTerm(1))  
        (addAssumptions A ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2)) empty
      )
      )
 .  
 eq splitFamilyOnAllBranches 
    (family fn nlist blist ::= 
     whenCond --> 
     ((family (fns[bd1 (bound (nt + natAsTerm(2))) bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3)  
              (bd1 (bound (nt + natAsTerm(2))) bd2) ::= cases) || P)
     )          
    fns
    A =
    family fn nlist blist ::= 
      whenCond --> 
      (P ||
      (
      dropBranch
      (family (fns[bd1 (bound (nt + natAsTerm(1))) bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 (bound (nt + natAsTerm(1))) bd2) ::= cases)
      q2 (nt + natAsTerm(1))
      )
      ||
      (project2Index 
        (family (fns[bd1 (bound (nt + natAsTerm(2))) bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 (bound (nt + natAsTerm(2))) bd2) ::= cases) 
        (qidAsTerm q2) 
        (nt + natAsTerm(1)) (addAssumptions A ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 (bound (nt + natAsTerm(2))) bd2)) empty))
 . 
  eq splitFamilyOnAllBranches 
    (family fn nlist blist ::= 
     (whenCond --> 
     ((family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) )  
              ((bound (nt + natAsTerm(2))) bd2) ::= cases) || P)
     )
     ;; whenList
    )
    fns A =
    mergeCases 
     (family fn nlist blist ::= 
      whenCond --> 
      (P ||
      (
      dropBranch
      (family (fns[(bound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(1))) bd2) ::= cases)
      q1 (nt + natAsTerm(1)) 
      )
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases) 
        (qidAsTerm q1) (nt + natAsTerm(1))  (addAssumptions A ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2)) empty))
    )
    (splitFamilyOnAllBranches 
    (family fn nlist blist ::= 
      whenList
    )
    fns A)
     .
 eq splitFamilyOnAllBranches 
    (family fn nlist blist ::= 
     (whenCond --> 
     ((family (fns[bd1 (bound (nt + natAsTerm(2))) bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3)  
              (bd1 (bound (nt + natAsTerm(2))) bd2) ::= cases) || P)
     )
     ;; whenList
    )
    fns A =
    mergeCases 
     (family fn nlist blist ::= 
      whenCond --> 
      (P ||
      (dropBranch 
      (family (fns[bd1 (bound (nt + natAsTerm(1))) bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 (bound (nt + natAsTerm(1))) bd2) ::= cases)
      q2 (nt + natAsTerm(1))
      )
      ||
      (project2Index 
        (family (fns[bd1 (bound (nt + natAsTerm(2))) bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 (bound (nt + natAsTerm(2))) bd2) ::= cases) 
        (qidAsTerm q2) (nt + natAsTerm(1)) 
        (addAssumptions A ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 (bound (nt + natAsTerm(2))) bd2)) empty))
    )
    (splitFamilyOnAllBranches 
    (family fn nlist blist ::= 
      whenList
    )
    fns A)
     .

     
 *** same thing for splitFst
 rl [SPLIT-fst-all-branches-nf-3] :
 pConfig(Sigma, Delta, newNF(ltq {(fns[(bound (nt + natAsTerm(2))) bd1 bd2]) nlist : T}, 
   P || family fn nlist' blist' ::= cases), I, O, A)
 => 
 pConfig(Sigma, Delta, 
   newNF(ltq {(fns[(bound (nt + natAsTerm(1))) bd1 bd2]) nlist : T}
             {(fns[(fixedBound (nt + natAsTerm(1))) bd1 bd2]) nlist : T}, 
             P || splitFamilyFstOnAllBranches (family fn nlist' blist' ::= cases) fns A
        ), 
   I, O, A) 
 .

 rl [SPLIT-fst-all-branches-top-3] :
 pConfig(Sigma, Delta (fam (fns[(bound (nt + natAsTerm(2))) bd1 bd2]) :: T) , 
  P || family fn nlist' blist' ::= cases, I, 
  (fam (fns[(bound (nt + natAsTerm(2))) bd1 bd2]), O), A)
 => 
 pConfig(Sigma, 
      Delta (fam (fns[(bound (nt + natAsTerm(1))) bd1 bd2]) :: T) 
            (fam (fns[(fixedBound (nt + natAsTerm(1))) bd1 bd2]) :: T), 
      P || splitFamilyFstOnAllBranches (family fn nlist' blist' ::= cases) fns A,
      I,
      (fam (fns[(bound (nt + natAsTerm(1))) bd1 bd2]), fam (fns[(fixedBound (nt + natAsTerm(1))) bd1 bd2]), O), 
      A)
 . 
 
 op splitFamilyFstOnAllBranches___ : Protocol NameWithScripts Set{BoolTerm} -> Protocol .
 eq splitFamilyFstOnAllBranches 
    (family fn nlist blist ::= 
     whenCond --> 
     ((family (fns[(bound (nt + natAsTerm(2))) bd1 bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3)  
              ((bound (nt + natAsTerm(2))) bd1 bd2) ::= cases) || P)
     )          
    fns
    A =
    family fn nlist blist ::= 
      whenCond --> 
      (P ||
      (
      dropBranch
      (family (fns[(bound (nt + natAsTerm(1))) bd1 bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) ((bound (nt + natAsTerm(1))) bd1 bd2) ::= cases)
      q1 (nt + natAsTerm(1)) 
      )
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd1 bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) ((bound (nt + natAsTerm(2))) bd1 bd2) ::= cases) 
        (qidAsTerm q1) (nt + natAsTerm(1))  (addAssumptions A ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) ((bound (nt + natAsTerm(2))) bd1 bd2)) empty))
 . 
 eq splitFamilyFstOnAllBranches 
    (family fn nlist blist ::= 
     (whenCond --> 
     ((family (fns[(bound (nt + natAsTerm(2))) bd1 bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3)  
              ((bound (nt + natAsTerm(2))) bd1 bd2) ::= cases) || P)
     )
     ;; whenList
    )
    fns A =
    mergeCases 
     (family fn nlist blist ::= 
      whenCond --> 
      (P ||
      (dropBranch 
      (family (fns[(bound (nt + natAsTerm(1))) bd1 bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) ((bound (nt + natAsTerm(1))) bd1 bd2) ::= cases)
      q1 (nt + natAsTerm(1)) 
      )
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd1 bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) ((bound (nt + natAsTerm(2))) bd1 bd2) ::= cases) 
        (qidAsTerm q1) (nt + natAsTerm(1))  (addAssumptions A ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) ((bound (nt + natAsTerm(2))) bd1 bd2)) empty))
    )
    (splitFamilyFstOnAllBranches 
    (family fn nlist blist ::= 
      whenList
    )
    fns A)
    .   

    
 *** TODO: condition that we can prove not q =T= nt
 rl [drop-branch] : 
 pConfig(Sigma, Delta, P, I, O, A)
 =>
 pConfig(Sigma, Delta, dropBranch P q nt, I, O, A) 
 [nonexec]
 .

 *** TODO: P should change. Is this rule used?
 rl [SPLIT-all-branches-nf-3] :
 pConfig(Sigma, Delta, newNF(ltq {(fns[bd1 (bound (nt + natAsTerm(2))) bd2]) nlist : T}, P), I, O, A)
 => 
 pConfig(Sigma, Delta, 
   newNF(ltq {(fns[bd1 (bound (nt + natAsTerm(1))) bd2]) nlist : T}
             {(fns[bd1 (fixedBound (nt + natAsTerm(1))) bd2]) nlist : T}, P
        ), 
   I, O, A) 
 .  

  rl [SPLIT-all-branches-end-2] :
 pConfig(Sigma, Delta, 
 family fn nlist blist ::= 
     whenCond --> 
     ((family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases) || P),
 I, O, A    
 ) 
 => 
 pConfig(Sigma, Delta, 
 family fn nlist blist ::= 
      whenCond --> 
      (P ||
      (family (fns[(bound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(1))) bd2) ::= cases)
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases) 
        (qidAsTerm q1) (nt + natAsTerm(1))  (addAssumptions A ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2)) empty)),
 I, O, A    
 ) 
 .

 crl [SPLIT-all-branches-loop-2] :
 pConfig(Sigma, Delta, 
    family fn nlist blist ::= 
     (whenCond --> 
     ((family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases) || P)
     )
     ;; whenList, 
     I, O, A)
  => 
   pConfig(Sigma, 
      Delta, 
      family fn nlist blist ::= 
      (whenCond --> 
      (P ||
      (family (fns[(bound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(1))) bd2) ::= cases)
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases) 
        (qidAsTerm q1) (nt + natAsTerm(1))  (addAssumptions A ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2)) empty))
      )
      ;; whenList'  , I, 
      O, 
      A) 
  if 
  pConfig(Sigma, Delta, 
    family fn nlist blist ::= 
     whenList, 
     I, O, A)
  => 
   pConfig(Sigma, 
      Delta, 
      family fn nlist blist ::= 
      whenList', I, 
      O, 
      A)    
 . 

 crl [SPLIT-family-2-all-branches-loop] : 
  pConfig(Sigma, Delta (fam (fns[(bound (nt + natAsTerm(2))) bd2]) :: T), 
    family fn nlist blist ::= 
     (whenCond --> 
     ((family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases) || P)
     )
     ;; whenList, 
     I, (fam (fns[(bound (nt + natAsTerm(2))) bd2]), O), A)
  => 
   pConfig(Sigma, 
      Delta (fam (fns[(bound (nt + natAsTerm(1))) bd2]) :: T) (fam (fns[(fixedBound (nt + natAsTerm(1))) bd2]) :: T), 
      family fn nlist blist ::= 
      (whenCond --> 
      (P ||
      (family (fns[(bound (nt + natAsTerm(1))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(1))) bd2) ::= cases)
      ||
      (project2Index 
        (family (fns[(bound (nt + natAsTerm(2))) bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2) ::= cases) 
        (qidAsTerm q1) (nt + natAsTerm(1))  (addAssumptions A ( (qidAsTerm q1)(qidAsTerm q2) ) ((bound (nt + natAsTerm(2))) bd2)) empty))
      )
      ;; whenList'  , I, 
      (fam (fns[(bound (nt + natAsTerm(1))) bd2]), fam (fns[(fixedBound (nt + natAsTerm(1))) bd2]), O), 
      A) 
  if 
  pConfig(Sigma, Delta (fam (fns[(bound (nt + natAsTerm(2))) bd2]) :: T), 
    family fn nlist blist ::= 
     whenList, 
     I, (fam (fns[(bound (nt + natAsTerm(2))) bd2]), O), A)
  => 
   pConfig(Sigma, 
      Delta (fam (fns[(bound (nt + natAsTerm(1))) bd2]) :: T) (fam (fns[(fixedBound (nt + natAsTerm(1))) bd2]) :: T), 
      family fn nlist blist ::= 
      whenList', I, 
      (fam (fns[(bound (nt + natAsTerm(1))) bd2]), fam (fns[(fixedBound (nt + natAsTerm(1))) bd2]), O), 
      A)    
 .

 rl [SPLIT-family-3-all-branches-end] : 
  pConfig(Sigma, Delta (fam (fns[bd1 (bound (nt + natAsTerm(2))) bd2]) :: T), 
    family fn nlist blist ::= 
     whenCond --> 
     ((family (fns[bd1 (bound (nt + natAsTerm(2))) bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3)  
              (bd1 (bound (nt + natAsTerm(2))) bd2) ::= cases) || P), 
     I, (fam (fns[bd1 (bound (nt + natAsTerm(2))) bd2]), O), A)
  => 
   pConfig(Sigma, 
      Delta (fam (fns[bd1 (bound (nt + natAsTerm(1))) bd2]) :: T) 
            (fam (fns[bd1 (fixedBound (nt + natAsTerm(1))) bd2]) :: T), 
      family fn nlist blist ::= 
      whenCond --> 
      (P ||
      (family (fns[bd1 (bound (nt + natAsTerm(1))) bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 (bound (nt + natAsTerm(1))) bd2) ::= cases)
      ||
      (project2Index 
        (family (fns[bd1 (bound (nt + natAsTerm(2))) bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 (bound (nt + natAsTerm(2))) bd2) ::= cases) 
        (qidAsTerm q2)
        (nt + natAsTerm(1)) (addAssumptions A ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 (bound (nt + natAsTerm(2))) bd2)) empty)), I, 
      (fam (fns[bd1 (bound (nt + natAsTerm(1))) bd2]), fam (fns[bd1 (fixedBound (nt + natAsTerm(1))) bd2]), O), 
      A) 
 . 

 crl [SPLIT-family-3-all-branches-loop] : 
  pConfig(Sigma, Delta (fam (fns[bd1 (bound (nt + natAsTerm(2))) bd2]) :: T), 
    family fn nlist blist ::= 
     (whenCond --> 
     ((family (fns[bd1 (bound (nt + natAsTerm(2))) bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
               (bd1 (bound (nt + natAsTerm(2))) bd2) ::= cases) || P)
     )
     ;; whenList, 
     I, (fam (fns[bd1 (bound (nt + natAsTerm(2))) bd2]), O), A)
  => 
   pConfig(Sigma, 
      Delta (fam (fns[bd1 (bound (nt + natAsTerm(1))) bd2]) :: T) 
            (fam (fns[bd1 (fixedBound (nt + natAsTerm(1))) bd2]) :: T), 
      family fn nlist blist ::= 
      (whenCond --> 
      (P ||
      (family (fns[bd1 (bound (nt + natAsTerm(1))) bd2]) 
              ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) 
              (bd1 (bound (nt + natAsTerm(1))) bd2) ::= cases)
      ||
      (project2Index 
        (family (fns[bd1 (bound (nt + natAsTerm(2))) bd2]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 (bound (nt + natAsTerm(2))) bd2) ::= cases) 
        (qidAsTerm q2) 
        (nt + natAsTerm(1)) (addAssumptions A ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 (bound (nt + natAsTerm(2))) bd2)) empty))
      )
      ;; whenList'  , I, 
      (fam (fns[bd1 (bound (nt + natAsTerm(1))) bd2]), fam (fns[bd1 (fixedBound (nt + natAsTerm(1))) bd2]), O), 
      A) 
  if 
  pConfig(Sigma, Delta (fam (fns[bd1 (bound (nt + natAsTerm(2))) bd2]) :: T), 
    family fn nlist blist ::= 
     whenList, 
     I, (fam (fns[bd1 (bound (nt + natAsTerm(2))) bd2]), O), A)
  => 
   pConfig(Sigma, 
      Delta (fam (fns[bd1 (bound (nt + natAsTerm(1))) bd2]) :: T) 
            (fam (fns[bd1 (fixedBound (nt + natAsTerm(1))) bd2]) :: T), 
      family fn nlist blist ::= 
      whenList', I, 
      (fam (fns[bd1 (bound (nt + natAsTerm(1))) bd2]), fam (fns[bd1 (fixedBound (nt + natAsTerm(1))) bd2]), O), 
      A)    
 .

 *********************
 *** rules for families
 *********************
  *** TODO: remove, duplicates cong-family-R
  crl [CONG-REACT-family] : 
     pConfig(Sigma, Delta, family (fns[blist]) nlist blist ::= R, I, O, A) 
     =>
     pConfig(Sigma, Delta, family (fns[blist]) nlist blist ::= R', I, O, A)
     if
     rConfig(Sigma, Delta, emptyTypeContext, R, insert(fam (fns[blist]), I), A, 
             typeInCtx(fam (fns[blist]), A, Delta))
     =>
     rConfig(Sigma, Delta, emptyTypeContext, R', I', A, T) 
     /\ I' == insert(fam (fns[blist]), I)
     /\ T == typeInCtx(fam (fns[blist]), A, Delta)
     /\ occurs (fam (fns[blist])) Delta A
     /\ O == fam (fns[blist])
     . *** TODO: fns @ n shouldn't be in I!

  rl [alpha-assums-chn] :
   pConfig(Sigma, Delta, 
           cn ::= R, I, O, (A, qidAsTerm q =T= nt))
   =>         
   pConfig(Sigma, Delta, 
           cn ::= replaceVars(R, insert(q, nt, empty)), I, O, (A, qidAsTerm q =T= nt))
  .   

  *** TODO: remove
  rl [alpha-family] :
   pConfig(Sigma, Delta, 
            newNF(ltq { (fns[bound nt]) (qidAsTerm q) : T }, 
                  P || family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= cases), 
           I, O, A)
   => 
   pConfig(Sigma, Delta, 
            newNF(ltq { (fns[bound nt]) (qidAsTerm q') : T }, 
                  P || (family (fns[bound nt]) (qidAsTerm q') (bound nt) ::= (alphaCases cases q q'))
            ), 
           I, O, A)
 [nonexec]
 .

 *** TODO: fns must be renamed as well - not anymore, we store just the bounds!
   
   rl [alpha-family-three-top] : 
   pConfig(Sigma, Delta, 
           P || family (fns[bd1 bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 bd2 bd3) ::= cases, I, O, A)
   => 
   pConfig(Sigma, Delta,
            P || (family (fns[bd1 bd2 bd3]) 
                    ((qidAsTerm q4)(qidAsTerm q5) qidAsTerm q6) (bd1 bd2 bd3) ::= 
                    (alphaCases (alphaCases (alphaCases (alphaCases (alphaCases 
                      (alphaCases cases q1 '1) 
                      q2 '2) q3 '3) '1 q4) '2 q5) '3 q6)                
                 ), I, O, A)
 [nonexec]
 .

 rl [alpha-family-two-top] : 
   pConfig(Sigma, Delta, 
           P || family (fns[bd1 bd2]) ( (qidAsTerm q1)(qidAsTerm q2) ) (bd1 bd2) ::= cases, I, O, A)
   => 
   pConfig(Sigma, Delta,
            P || (family (fns[bd1 bd2]) ( (qidAsTerm q3)(qidAsTerm q4) ) (bd1 bd2) ::= 
                    (alphaCases (alphaCases (alphaCases 
                      (alphaCases cases q1 '1) 
                      q2 '2) '1 q3) '2 q4)                
                 ), I, O, A)
 [nonexec]
 .

 rl [alpha-family-three] : 
   pConfig(Sigma, Delta, newNF(ltq {(fns[bd1 bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) : T}, 
           P || family (fns[bd1 bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 bd2 bd3) ::= cases), I, O, A)
   => 
   pConfig(Sigma, Delta, 
           newNF(ltq {(fns[bd1 bd2 bd3]) ((qidAsTerm q4)(qidAsTerm q5) qidAsTerm q6) : T}, 
            P || (family (fns[bd1 bd2 bd3]) 
                          ((qidAsTerm q4)(qidAsTerm q5) qidAsTerm q6) (bd1 bd2 bd3) ::= 
                    (alphaCases (alphaCases (alphaCases (alphaCases (alphaCases 
                      (alphaCases cases q1 '1) 
                      q2 '2) q3 '3) '1 q4) '2 q5) '3 q6)                
                 )), I, O, A)
 [nonexec]
 .

*** TODO: these two can be removed, equivalent with "on branch whenCond of cnb do alpha"
   rl [alpha-branch] :
   pConfig(Sigma, Delta,     
              P || family (fns[blist]) nlist blist ::= 
                (whenList1 ;; 
                 (whenCond --> nf((q1 : T1 <- R1) BRL, R2)) ;;
                  whenList2), 
              I, O, A)
   => 
   pConfig(Sigma, Delta, 
        
              P || family (fns[blist]) nlist blist ::= 
                 (whenList1 ;; 
                 (whenCond --> nf((q2 : T1 <- R1) BRL, R2 [q1 / q2])) ;;
                  whenList2), 
              I, O, A)
 [nonexec]
 .

 rl [alpha-branch-channel] :
   pConfig(Sigma, Delta,  
              P || cn ::= 
                (whenList1 ;; 
                 (whenCond --> nf((q1 : T1 <- R1) BRL, R2)) ;;
                  whenList2), 
              I, O, A)
   => 
   pConfig(Sigma, Delta,  
              P || cn ::= 
                 (whenList1 ;; 
                 (whenCond --> nf((q2 : T1 <- R1) BRL, R2 [q1 / q2])
                 ) ;;
                  whenList2), 
              I, O, A)
 [nonexec]
 .

  var cnb : CNameBound .

*** when a family has same cases as a group, add it to each branch of the group
*** with corresponding value
op addToGroupSameCases__ : Protocol Protocol -> Protocol .
eq addToGroupSameCases
   (family (fns[blist]) nlist blist ::= whenList1)
   (cn ::= whenList2)
   =
   family (fns[blist]) nlist blist ::= 
     (addToGroupSameCasesAux whenList1 (cn ::= whenList2)) .
eq addToGroupSameCases
   (family (fns[blist]) nlist blist ::= whenList1)
   (family (fns1[blist1]) nlist1 blist1 ::= whenList2)
   =
   family (fns[blist]) nlist blist ::= 
     (addToGroupSameCasesAux whenList1 
     (family (fns1[blist1]) nlist1 blist1 ::= whenList2)) .  

 op addToGroupSameCasesAux__ : WhenList Protocol -> WhenList .
eq addToGroupSameCasesAux (whenCond --> P) (cn ::= whenCond --> R) 
   = whenCond --> (P || (cn ::= R)) .
eq addToGroupSameCasesAux ((whenCond --> P) ;; whenList1) 
                          (cn ::= ((whenCond --> R) ;; whenList2)) 
   = 
   (whenCond --> (P || cn ::= R)) 
   ;;
   (addToGroupSameCasesAux whenList1 (cn ::= whenList2)) .
   
eq addToGroupSameCasesAux (whenCond --> P) 
   (family (fns1[blist1]) nlist1 blist1 ::= whenCond --> R) 
   = whenCond --> (P || family (fns1[blist1]) nlist1 blist1 ::= R) .
eq addToGroupSameCasesAux ((whenCond --> P) ;; whenList1) 
   (family (fns1[blist1]) nlist1 blist1 ::= ((whenCond --> R) ;; whenList2)) 
   = 
   (whenCond --> (P || family (fns1[blist1]) nlist1 blist1 ::= R)) 
   ;;
   (addToGroupSameCasesAux whenList1 
    (family (fns1[blist1]) nlist1 blist1 ::= whenList2)
   ) .

 rl [add-chn-to-group-same-cases] :
  pConfig(Sigma, Delta,
  (family (fns[blist]) nlist blist ::= whenList1) 
  ||
  (cn ::= whenList2)
  , I, O, A) 
  => 
  pConfig(Sigma, Delta,
  addToGroupSameCases
   (family (fns[blist]) nlist blist ::= whenList1)
   (cn ::= whenList2)
  , I, O, A) 
  .

  crl [add-fam-to-group-same-cases] :
  pConfig(Sigma, Delta,
  (family (fns[blist]) nlist blist ::= whenList1) 
  ||
  (family (fns1[blist1]) nlist1 blist1 ::= whenList2)
  , I, O, A) 
  => 
  pConfig(Sigma, Delta,
  addToGroupSameCases
   (family (fns[blist]) nlist blist ::= whenList1)
   (family (fns1[blist1]) nlist1 blist1 ::= whenList2)
  , I, O, A) 
  if sameConditions whenList1 whenList2
  .

  op sameConditions__ : WhenList WhenList -> Bool .
  eq sameConditions emptyWhen emptyWhen = true .
  eq sameConditions 
     ((whenCond1 --> cases1) ;; whenList1)
     ((whenCond2 --> cases2) ;; whenList2) =
      (whenCond1 == whenCond2) and sameConditions whenList1 whenList2 . 

  *** if a family is assigned same thing on each branch
*** take it out without having to merge afterwards
crl [remove-merge-from-group-cases] :
 pConfig(Sigma, Delta,
family (fns[blist]) nlist blist ::= 
 ( (whenCond --> (P || family (fns1[blist1]) nlist1 blist1 ::= cases))
  ;;
  whenList 
 ), I, O, A) 
=> pConfig(Sigma, Delta,
  (family (fns1[blist1]) nlist1 blist1 ::= cases)
  ||
  (family (fns[blist]) nlist blist ::= 
  (
    (whenCond --> P)
  ;;
  removeFromEachBranch (fam (fns1[blist1])) whenList
  )
  )
  , I, O, A)
if 
 sameOnEachBranch (fam (fns1[blist1])) cases whenList  
. 

  
  rl [remove-from-group-cases] :
  pConfig(Sigma, Delta, 
            (family (fns1[blist]) nlist blist ::= cases),
             I, O, A)
  =>            
  pConfig(Sigma, Delta, 
            removeFromGroupCases (fam (fns1[blist])) cnb
            (family (fns1[blist]) nlist blist ::= cases),
             I, O, A)
  [nonexec] .

  rl [rename-group] :
     pConfig(Sigma, Delta, 
            (family (fns1[bound nt]) (qidAsTerm q) (bound nt) ::= cases),
            I, O, A)
     => 
     pConfig(Sigma, Delta, 
            (family (fns2[bound nt]) (qidAsTerm q) (bound nt) ::= cases),
            I, O, A)     
     [nonexec] .        
 
  rl [addToGroup] :
   pConfig(Sigma, Delta, 
            (family (fns1[bound nt]) (qidAsTerm q) (bound nt) ::= P) || 
            family (fns2[bound nt1]) (qidAsTerm q') (bound nt1) ::= cases, 
           I, O, A)
   => 
   pConfig(Sigma, Delta, 
             family (fns1[bound nt]) (qidAsTerm q) (bound nt) ::= 
               (P || family (fns2[bound nt1]) (qidAsTerm q') (bound nt1) ::= cases), 
           I, O, A)
 .  

 rl [addToGroupCases-end] : 
   pConfig(Sigma, Delta, 
           (family (fns1[blist]) nlist blist ::= (whenCond --> P)) 
           ||
           (family (fns2[blist']) nlist' blist' ::= cases), I, O, A)
   =>
   pConfig(Sigma, Delta, 
           (family (fns1[blist]) nlist blist ::= 
             (whenCond --> (P || (family (fns2[blist']) nlist' blist' ::= cases) )
             )
           ) 
           ,
           I, O, A 
           ) 
 . 
 
 crl [addToGroupCases] :
   pConfig(Sigma, Delta, 
           (family (fns1[blist]) nlist blist ::= (whenCond --> P) ;; whenList) 
           ||
           (family (fns2[blist']) nlist' blist' ::= cases), I, O, A)
   =>
   pConfig(Sigma, Delta, 
           (family (fns1[blist]) nlist blist ::= 
             (whenCond --> (P || (family (fns2[blist']) nlist' blist' ::= cases) )) ;; 
             whenList'
           ) 
           ,
           I, O, A 
           )
   if 
   pConfig(Sigma, Delta, 
           (family (fns1[blist]) nlist blist ::= whenList) 
           ||
           (family (fns2[blist']) nlist' blist' ::= cases), I, O, A)
   =>
   pConfig(Sigma, Delta, 
           (family (fns1[blist]) nlist blist ::= 
             whenList'
           ) 
           ,
           I, O, A 
           )       
 . 

 *******************************************
 *** merge two groups if they have same conditions on branches
 
 rl [merge-groups] :
 pConfig(Sigma, Delta, (family (fns1[blist1]) nlist1 blist1 ::= whenList1) ||
    (family (fns2[blist1]) nlist1 blist1 ::= whenList2), I, O, A)
 =>
 pConfig(Sigma, Delta, mergeGroupsSameConds 
    (family (fns1[blist1]) nlist1 blist1 ::= whenList1)
    (family (fns2[blist1]) nlist1 blist1 ::= whenList2)
    fns, I, O, A)
 [nonexec]
 .
 
op mergeGroupsSameConds___ : Protocol Protocol NameWithScripts -> Protocol .
eq mergeGroupsSameConds 
    (family (fns1[blist1]) nlist1 blist1 ::= whenList1)
    (family (fns2[blist1]) nlist1 blist1 ::= whenList2)
    fns =
    family (fns[blist1]) nlist1 blist1 ::= mergeCasesSameConds whenList1 whenList2
  .
    
op mergeCasesSameConds__ : WhenList WhenList -> WhenList .
eq mergeCasesSameConds
   (whenCond --> P1) (whenCond --> P2)  = whenCond --> (P1 || P2) .
eq mergeCasesSameConds
   ((whenCond --> P1) ;; whenList1) 
   ((whenCond --> P2) ;; whenList2)  = 
    (whenCond --> (P1 || P2)) 
    ;; mergeCasesSameConds whenList1 whenList2 .

*********************************************
 *** extract a subgroup
 
 rl [extract-subgroup] :
 pConfig(Sigma, Delta, P, I, O, A)
 =>
 pConfig(Sigma, Delta, extractSubgroup P cnbl fns, I, O, A)
 [nonexec]
 .
 
 op extractSubgroup___ : Protocol List{CNameBound} NameWithScripts -> Protocol .
eq extractSubgroup 
   (family (fns[blist]) nlist blist ::= whenList1)
   cnbl
   fns1
 = esAux (family (fns[blist]) nlist blist ::= whenList1)
   cnbl
   fns1 emptyWhen emptyWhen .
 
op esAux_____ : Protocol List{CNameBound} NameWithScripts WhenList WhenList -> Protocol .   
eq esAux (family (fns[blist]) nlist blist ::= whenCond --> P)
   cnbl
   fns1 whenList1 whenList2 = 
   (family (fns[blist]) nlist blist ::= (whenList1 ;; (whenCond --> removeAll P cnbl)) )
   ||
   (family (fns1[blist]) nlist blist ::= (whenList2 ;; (whenCond --> keepAll P cnbl)) )
.
eq esAux (family (fns[blist]) nlist blist ::= ((whenCond --> P) ;; whenList) )
   cnbl
   fns1 whenList1 whenList2 = 
   esAux (family (fns[blist]) nlist blist ::= whenList)
   cnbl
   fns1
   (whenList1 ;; (whenCond --> removeAll P cnbl))
   (whenList2 ;; (whenCond --> keepAll P cnbl))
.
 
 *********************************************
 ***( TODO: old idea, perhaps remove it
  crl [proof-composition] :
    pConfig(Sigma, Delta, P1, I, O, A) 
    => 
    pConfig(Sigma, Delta, P2, I, O, A)
    if
    isIndepComp 'any P1 *** the qid does not matter here!
    /\
    pConfig(Sigma, Delta, projZero P1, I, O, A)
    => 
    pConfig(Sigma, Delta, P3, I, O, A)
    /\
    P3 == projZero P2 [nonexec] .
   
  
  *** these rules are subsumed by the one below, 
  ***     leave them here until we check that all still works as before!
    
  crl [absorb-new-nf-family-one] : 
     pConfig(Sigma, Delta, 
             newNF({C q (bound n) : T }  ltq, P || (family C q (bound n) ::= cases)), 
             I, O, A) 
     => 
     pConfig(Sigma, Delta, newNF(ltq, P), I, O, A) 
  if
     typeOf(Sigma, addChannels ({C q (bound n) : T }  ltq) Delta, 
            insert(C @ n, union(I, getOutputs(P))), A, family C q (bound n) ::= cases)
     /\
     typeOf(Sigma, addChannels ltq Delta, I, A, P)       
     /\ 
     getOutputs(newNF2New(newNF(ltq, P))) == O 
 .
 
 crl [absorb-new-nf-family-two] : 
     pConfig(Sigma, Delta, 
             newNF({C (q q')((bound n) (bound nt)) : T }  ltq, 
                   P || (family C (q q')((bound n) (bound nt)) ::= cases)), 
             I, O, A) 
     => 
     pConfig(Sigma, Delta, newNF(ltq, P), I, O, A) 
 if typeOf(Sigma, 
           addChannels ({C (q q')((bound n) (bound nt)) : T } ltq) Delta, 
           insert(C @ (n nt), union(I, getOutputs(P))), 
           A, 
           family C (q q')((bound n) (bound nt)) ::= cases
          )
     /\
     typeOf(Sigma, addChannels ltq Delta, I, A, P)       
     /\ 
     getOutputs(newNF2New(newNF(ltq, P))) == O     
 .  
 )

 *****************************************************************         
  crl [absorb-new-nf-family] : 
     pConfig(Sigma, Delta, 
             newNF({(fns[blist]) nlist : T} ltq, 
                   P || (family (fns[blist]) nlist blist ::= cases)), 
             I, O, A) 
     => 
     pConfig(Sigma, Delta, newNF(ltq, P), I, O, A) 
 if ***( TODO: where it fails for gmwN?
     typeOf(Sigma, 
          addChannels ({(fns[blist]) nlist : T} ltq) Delta, 
          insert(fam (fns[blist]), union(I, getOutputs(P))), 
           A, 
           family (fns[blist]) nlist blist ::= cases
          )
     /\ 
     )
     *** typeOf(Sigma, addChannels ltq Delta, I, A, P)  
      not readsFrom P (fam (fns[blist]))
     /\ 
     getOutputs(newNF2New(newNF(ltq, P))) == O        
 .

 crl [absorb-new-nf-group] : 
     pConfig(Sigma, Delta, 
             newNF(ltq, 
                   P || (family (fns[blist]) nlist blist ::= cases)), 
             I, O, A) 
     => 
     pConfig(Sigma, Delta, 
       newNF(remGroupTList ltq (getOutputs (family (fns[blist]) nlist blist ::= cases)), 
             P), 
             I, O, A) 
 if 
 ***    typeOf(Sigma, 
 ***         addChannels ({(fns[blist]) nlist : T} ltq) Delta, 
 ***         insert(fam (fns[blist]), union(I, getOutputs(P))), 
 ***          A, 
 ***          family (fns[blist]) nlist blist ::= cases
 ***         )
     *** /\ 
     *** typeOf(Sigma, addChannels ltq Delta, I, A, P)  
      not readsFromSet P (getOutputs (family (fns[blist]) nlist blist ::= cases))
     *** /\ 
     *** getOutputs(newNF2New(newNF(ltq, P, cnbl))) == O        
 .  
 
op remGroupTList__ : TypedCNameList Set{CNameBound} -> TypedCNameList .
eq remGroupTList ltq empty = ltq . 
ceq remGroupTList ({(fns[blist]) nlist : T} ltq) O =
   remGroupTList ltq (O \ (fam (fns[blist]))) 
 if (fam (fns[blist])) in O .  
   
op remGroupCNBs__ : List{CNameBound} Set{CNameBound} -> List{CNameBound} .
eq remGroupCNBs cnbl empty = cnbl .
eq remGroupCNBs cnbl ( (fam (fns[blist])), O) = 
   remGroupCNBs (del (fam (fns[blist])) cnbl) O .

crl [absorb-reverse-new-nf-family] : 
     pConfig(Sigma, Delta, newNF(ltq, P), I, O, A)
     =>
     pConfig(Sigma, Delta, 
             newNF({(fns[blist]) nlist : T}ltq, 
                   P || (family (fns[blist]) nlist blist ::= cases)
                  ), 
             I, O, A) 
 if   
     typeOf(Sigma, addChannels ltq Delta, I, A, P) 
     /\
     typeOf(Sigma, addChannels ({(fns[blist]) nlist : T} ltq) Delta, 
             insert(fam (fns[blist]), union(I, O)), A,
             (family (fns[blist]) nlist blist ::= cases)) 
     /\
     getOutputs(newNF2New(newNF(ltq, P))) == O 
 [nonexec] 
 .
 
 crl [comp-new-nf-right-family] :   *** TODO! where we add fns
    pConfig(Sigma, Delta, 
            newNF(ltq, P || (newfamily (fns[blist]) nlist blist : T in Q)), I, O, A)
    =>
    pConfig(Sigma, Delta, 
           newNF({(fns[blist]) nlist : T} ltq, 
                 P || Q), 
           I, O, A) 
    if
     typeOf(Sigma, addChannels ltq Delta, union(I, getOutputs(Q)), A, P) 
     /\
     typeOf(Sigma, addChannels ltq (Delta ((fam (fns[blist])) :: T)), 
            union(I, getOutputs(P)), A, Q) 
    .

  rl [COMP-NEW-newNF-newfamily] :
     pConfig(Sigma, Delta, P || (newfamily (fns[blist]) nlist blist : T in Q), I, O, A)
     =>  
     pConfig(Sigma, Delta, 
              newNF( {(fns[blist]) nlist : T}, P || Q ), I, O, A)
     ***( if 
     typeOf(Sigma, Delta ((fam (fns[blist])) :: T), union(I, getOutputs(P)), A, Q)
     /\
     typeOf(Sigma, Delta, union(I ,(getOutputs(Q) \ (fam (fns[blist])))), A, P) 
     ) .
  
  crl [moveReadInnerNfFamily] :
    pConfig(Sigma, Delta,
             family (fns[blist]) lq blist ::= nf((x : T <- read cn2) BRL , R1) ,
             I, O, A)  
     => 
       pConfig(Sigma, Delta,
             family (fns[blist]) lq blist ::= 
              preNF(BRL , x : T <- read cn2 ; R1) ,
             I, O, A)
   if          
   elem (toBound cn2) T Delta A 
  /\ typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(fam (fns[blist]) , I), A, R1) 
     == 
     typeInCtx(fam (fns[blist]), A, Delta)              
  .  

  crl [moveReadInnerPreNfFamily] :
    pConfig(Sigma, Delta,
             family (fns[blist]) lq blist ::= preNF((x : T <- read cn2) BRL , R1) ,
             I, O, A)  
     => 
       pConfig(Sigma, Delta,
             family (fns[blist]) lq blist ::= 
              preNF(BRL , x : T <- read cn2 ; R1) ,
             I, O, A) 
             if          
   elem (toBound cn2) T Delta A 
  /\ typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(fam (fns[blist]) , I), A, R1) 
     == 
     typeInCtx(fam (fns[blist]), A, Delta)          
  . 

  *** drop for families, TODO: not used, remove
  
    crl [DROP-nf-families] :
    pConfig(Sigma, Delta,
            (family (fns1[bound nt]) (qidAsTerm i) (bound nt) ::= nf(BRL, samp Dist)) 
            || 
            (family (fns2[bound nt]) (qidAsTerm i) (bound nt) ::= 
              nf( (x : T1 <- read (fns1[nj])) BRL', R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (family (fns1[bound nt]) (qidAsTerm i) (bound nt) ::= nf(BRL, samp Dist)) 
            || 
            (family (fns2[bound nt]) (qidAsTerm i) (bound nt) ::= nf( BRL', R2) ),
            I, O, A) 
    if
     typeOf(Sigma, Delta, addDeclarations BRL' (x : T1), 
             insert(fam (fns1[bound nt]), 
              insert(fam (fns2[bound nt]), I)), A, R2) 
     == 
     typeInCtx(fam (fns2[bound nt]), A, Delta)
     /\
     elem (fam (fns1[bound nt])) T1 Delta A        
    . 

  *** this rule is derived from drop and subsume
  crl [DROP-SUBSUME-families] :
    pConfig(Sigma, Delta,
            (family (fns1[bound nt]) (qidAsTerm i) (bound nt1) ::= nf(BRL, samp Dist)) || 
            (family (fns2[bound nt]) (qidAsTerm i) (bound nt2) ::= 
              nf( (x : T1 <- read (fns1[i])) BRL' , R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (family (fns1[bound nt]) (qidAsTerm i) (bound nt1) ::= nf(BRL, samp Dist)) || 
            (family (fns2[bound nt]) (qidAsTerm i) (bound nt2) ::= 
              nf(BRL BRL' , R2) ),
            I, O, A) 
    if 
     typeOf(Sigma, Delta, addDeclarations BRL (x : T1), 
             insert(fam (fns2[bound nt]), insert(fam (fns1[bound nt]), I)), A, R2) 
     == 
     typeInCtx(fam (fns2[bound nt]), A, Delta)
     /\
     elem (fam (fns1[bound nt])) T1 Delta A
    .

 var blist2 : List{Bounds} .

  *** drop read of a channel from a family
    crl [DROP-SUBSUME-channel-family-gen] :
    pConfig(Sigma, Delta,
            (cn ::= nf(BRL, samp Dist)) || 
            (family (fns2[blist2]) nlist2 blist2 ::= 
              nf( (x : T1 <- read cn) BRL' , R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (cn ::= nf(BRL, samp Dist)) || 
            (family (fns2[blist2]) nlist2 blist2 ::= 
              nf(BRL BRL' , R2) ),
            I, O, A) 
    if *** sameIndices nlist1 blist1 tlist 
     *** /\
     typeOf(Sigma, Delta, addDeclarations BRL' (x : T1), 
             insert(fam (fns2[blist2]), insert(chn cn, I)), A, R2) 
     == 
     typeInCtx(fam (fns2[blist2]), A, Delta)
     /\
     elem (chn cn) T1 Delta A
    .

  crl [DROP-SUBSUME-ret-channel-family-gen] :
    pConfig(Sigma, Delta,
            (cn ::= preNF(BRL, y : T <- samp Dist ;  return M) ) || 
            (family (fns2[blist2]) nlist2 blist2 ::= 
              nf( (x : T1 <- read cn) BRL' , R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (cn ::= preNF(BRL, y : T <- samp Dist ;  return M) ) || 
            (family (fns2[blist2]) nlist2 blist2 ::= 
              nf(BRL BRL' , R2) ),
            I, O, A) 
    if *** sameIndices nlist1 blist1 tlist 
     *** /\
     typeOf(Sigma, Delta, addDeclarations BRL' (x : T1), 
             insert(fam (fns2[blist2]), insert(chn cn, I)), A, R2) 
     == 
     typeInCtx(fam (fns2[blist2]), A, Delta)
     /\
     elem (chn cn) T1 Delta A
    .  

*** drop read of a family from a channel
    crl [DROP-SUBSUME-family-channel-gen] :
    pConfig(Sigma, Delta,
            (family (fns1[blist1]) nlist1 blist1 ::= nf(BRL, samp Dist)) || 
            (cn ::= 
              nf( (x : T1 <- read (fns1[tlist])) BRL' , R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (family (fns1[blist1]) nlist1 blist1 ::= nf(BRL, samp Dist)) || 
            (cn ::= 
              nf(BRL BRL' , R2) ),
            I, O, A) 
    if *** sameIndices nlist1 blist1 tlist 
     *** /\
     typeOf(Sigma, Delta, addDeclarations BRL' (x : T1), 
             insert(chn cn, insert(fam (fns1[blist1]), I)), A, R2) 
     == 
     typeInCtx(chn cn, A, Delta)
     /\
     elem (fam (fns1[blist1])) T1 Delta A
    .

   *** n-ary generalization
    crl [DROP-SUBSUME-families-gen] :
    pConfig(Sigma, Delta,
            (family (fns1[blist1]) nlist1 blist1 ::= nf(BRL, samp Dist)) || 
            (family (fns2[blist2]) nlist2 blist2 ::= 
              nf( (x : T1 <- read (fns1[tlist])) BRL' , R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (family (fns1[blist1]) nlist1 blist1 ::= nf(BRL, samp Dist)) || 
            (family (fns2[blist2]) nlist2 blist2 ::= 
              nf(BRL BRL' , R2) ),
            I, O, A) 
    if *** sameIndices nlist1 blist1 tlist 
     *** /\
     typeOf(Sigma, Delta, addDeclarations BRL' (x : T1), 
             insert(fam (fns2[blist2]), insert(fam (fns1[blist1]), I)), A, R2) 
     == 
     typeInCtx(fam (fns2[blist2]), A, Delta)
     /\
     elem (fam (fns1[blist1])) T1 Delta A
    .

   *** drop for channel-family  
  crl [DROP-nf-cf] :
      pConfig(Sigma, Delta,
            (family (fns[blist]) (qidAsTerm i) (bound nt) ::= nf(BRL, samp Dist)) 
            || 
            (cn ::= nf( (x : T1 <- read (fns[nj])) BRL', R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (family (fns[blist]) (qidAsTerm i) (bound nt) ::= nf(BRL, samp Dist)) 
            || 
            (cn ::= nf( BRL', R2) ),
            I, O, A) 
    if
     typeOf(Sigma, Delta, addDeclarations BRL' (x : T1), 
             insert(fam (fns[bound nt]), insert(chn cn, I)), A, R2) 
     == 
     typeInCtx(chn cn, A, Delta)
     /\
     elem (fam (fns[bound nt])) T1 Delta A
  .  

  *** variant with cases
  
  *** improvement, only add new reads, TODO: for other rules as well
  
  op addNewReads__ : BRList BRList -> BRList .
  eq addNewReads emptyBRList BRL' = BRL' .
  eq addNewReads ((q : T <- read cn) BRL) ((q' : T <- read cn) BRL') =
     addNewReads                     BRL  ((q' : T <- read cn) BRL') .
  eq addNewReads ((q : T <- read cn) BRL) BRL' =
     addNewReads                     BRL  ((q : T <- read cn) BRL') 
    [owise] .
    
  op addNewReadVars___ : BRList BRList List{NatTerm} -> List{NatTerm} .
  eq addNewReadVars emptyBRList BRL' QL = QL .
  eq addNewReadVars ((q : T <- read cn) BRL) ((q' : T <- read cn) BRL') QL =
     addNewReadVars                     BRL  ((q' : T <- read cn) BRL') QL .
  eq addNewReadVars ((q : T <- read cn) BRL) BRL' QL =
     addNewReadVars                     BRL  ((q : T <- read cn) BRL') (QL (qidAsTerm q))
    [owise] .  

   crl [DROP-SUBSUME-families-gen-case] :
    pConfig(Sigma, Delta,
            (family (fns1[blist1]) nlist1 blist1 ::= 
             whenList1 ;;
             (when bt -->  nf(BRL, samp Dist)) ;;
             whenList2             
            ) || 
            (family (fns2[blist2]) nlist2 blist2 ::= 
              nf( (x : T1 <- read (fns1[tlist])) BRL' , R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (family (fns1[blist1]) nlist1 blist1 ::= 
             whenList1 ;;
             (when bt -->  nf(BRL, samp Dist)) ;;
             whenList2             
            ) || 
            (family (fns2[blist2]) nlist2 blist2 ::= 
              nf(addNewReads (replaceVarsB(BRL, mapFromLists nlist1 tlist))  BRL' , 
                  R2)
            ),
            I, O, A) 
    if
    ***   addAssumptions (addAssumptions (addAssumptions A nlist1 blist1) nlist1 (toFixedBounds tlist)) 
    ***  nlist2 blist2 |= bt 
    ***   with (mapFromLists nlist1 tlist)  *** empty
     *** /\ 
     *** sameIndices nlist1 blist1 tlist  do we need this?
     *** /\
     typeOf(Sigma, Delta, 
             addDeclarations
             (addNewReads (replaceVarsB(BRL, mapFromLists nlist1 tlist))  BRL')
             (x : T1), 
             insert(fam (fns2[blist2]), insert(fam (fns1[blist1]), I)), A, R2) 
     == 
     typeInCtx(fam (fns2[blist2]), A, Delta)
     /\
     elem (fam (fns1[blist1])) T1 Delta A
    .   

  *** drop for channel-family with cases 
  crl [DROP-nf-cf-cases] :
      pConfig(Sigma, Delta,
            (family (fns[bound nt]) (qidAsTerm i) (bound nt) ::= 
               whenList1 ;;
               (when bt --> nf(BRL, samp Dist)) ;;
               whenList2
            ) 
            || 
            (cn ::= nf( (x : T1 <- read (fns[nj])) BRL', R2) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (family (fns[bound nt]) (qidAsTerm i) (bound nt) ::= 
               whenList1 ;;
               (when bt --> nf(BRL, samp Dist)) ;;
               whenList2
            ) 
            || 
            (cn ::= nf( BRL', R2) ),
            I, O, A) 
    if A |= bt with i |-> nj /\
     typeOf(Sigma, Delta, addDeclarations BRL' (x : T1), 
             insert(fam (fns[bound nt]), insert(chn cn, I)), A, R2) 
     == 
     typeInCtx(chn cn, A, Delta)
     /\
     elem (fam (fns[bound nt]) ) T1 Delta A
  . 

  *** subsume reverse for families
  
   crl [subsume-families-one-rev] :
    pConfig(Sigma, Delta, 
            (family (fns1[bound nt]) (qidAsTerm i) (bound nt) ::= 
               nf((x0 : T0 <- read cn) BRL, R1)) || 
            (family (fns2[bound nt]) (qidAsTerm i) (bound nt) ::= 
               nf((x1 : T1 <- read (fns1[nj])) BRL', R2)) 
           , I, O, A)
    => 
    pConfig(Sigma, Delta,
            (family (fns1[bound nt]) (qidAsTerm i) (bound nt) ::= nf((x0 : T0 <- read cn) BRL, R1)) || 
            (family (fns2[bound nt]) (qidAsTerm i) (bound nt) ::= 
               nf((x0 : T0 <- read cn) 
                  (x1 : T1 <- read (fns1[nj])) BRL', 
                  R2)  
            )      
           , I, O, A)
   if typeOf(Sigma, Delta, x1 : T1, 
             insert(fam (fns1[bound nt]) , insert(fam (fns2[bound nt]) , I)), A, R2) 
      == 
      typeInCtx(fam (fns2[bound nt]) , A, Delta) 
   /\ 
    O == insert(fam (fns1[bound nt]) , insert(fam (fns2[bound nt]) , empty)) 
   /\ fns1 =/= fns2 /\ elem (fam (fns1[bound nt]) ) T1 Delta A 
   .

  crl [subsume-channels-one-rev] :
    pConfig(Sigma, Delta, 
            (cn1 ::= nf((x0 : T0 <- read cn) BRL, R1)) || 
            (cn2 ::= nf((x1 : T1 <- read cn1) BRL', R2)) 
           , I, O, A)
    => 
    pConfig(Sigma, Delta,
            (cn1 ::= nf((x0 : T0 <- read cn) BRL, R1)) || 
            (cn2 ::= 
               nf((x0 : T0 <- read cn) 
                  (x1 : T1 <- read cn1) BRL', 
                  R2)  
            )      
           , I, O, A)
   if typeOf(Sigma, Delta, x1 : T1, insert(toBound cn1, insert(toBound cn2, I)), A, R2) == 
      typeInCtx(toBound cn2, A, Delta) 
   /\ O == insert(toBound cn1, insert(toBound cn2, empty)) /\ cn1 =/= cn2 /\
   elem (toBound cn1) T1 Delta A 
   . 

   crl [subsume-channels-family-one-rev] :
    pConfig(Sigma, Delta, 
            (family (fns[blist]) (qidAsTerm i) (bound nt) ::= nf((x0 : T0 <- read cn) BRL, R1)) || 
            (cn2 ::= nf((x1 : T1 <- read (fns[nj])) BRL', R2)) 
           , I, O, A)
    => 
    pConfig(Sigma, Delta,
            (family (fns[blist]) (qidAsTerm i) (bound nt) ::= nf((x0 : T0 <- read cn) BRL, R1)) || 
            (cn2 ::= 
               nf((x0 : T0 <- read cn) 
                  (x1 : T1 <- read (fns[nj])) BRL', 
                  R2)  
            )      
           , I, O, A)
   if typeOf(Sigma, Delta, x1 : T1, 
             insert(fam (fns[bound nt]), insert(toBound cn2, I)), A, R2) == 
      typeInCtx(toBound cn2, A, Delta) 
   /\ O == insert(fam (fns[bound nt]), insert(toBound cn2, empty)) /\ fns =/= cn2 /\
   elem (fam (fns[bound nt])) T1 Delta A 
   . 

   crl [subsume-family-cases-channel] :
     pConfig(Sigma, Delta, 
            (family (fns[bound nt]) (qidAsTerm i) (bound nt) ::= cases) || 
            (cn2 ::= nf((x1 : T1 <- read (fns[nj])) BRL, R)) 
           , I, O, A)
    => 
     pConfig(Sigma, Delta, 
            (family (fns[bound nt]) (qidAsTerm i) (bound nt) ::= cases) || 
            (cn2 ::= R2) 
           , I, O, A)
    if  
     pConfig(Sigma, Delta, 
            (projectIndex (family (fns[bound nt]) (qidAsTerm i) (bound nt)  ::= cases) nj A empty) || 
            (cn2 ::= nf((x1 : T1 <- read (fns[nj])) BRL, R)) 
           , I, (chn cn2, chn (fns[nj])), A)      
     => 
     pConfig(Sigma, Delta, 
            (fns[nj] ::= R1) || 
            (cn2 ::= R2) 
           , I, O', A)
    /\ O' ==  (chn cn2, chn (fns[nj]))               
   .
   
   var C2 : Qid . 

   op sameIndices___ : List{NatTerm} List{Bounds} List{NatTerm} -> Bool .
   eq sameIndices nlist blist nil = true .
   eq sameIndices ((qidAsTerm q) nlist) (bd1 blist) ((qidAsTerm q) nlist') =
      sameIndices nlist blist nlist' .
   eq sameIndices ((qidAsTerm q) nlist) ((fixedBound nt) blist) (nt nlist') =
      sameIndices nlist blist nlist' .   
   eq sameIndices nlist blist nlist' = false [owise] . 
   
   op toTerms___ : List{NatTerm}  List{Bounds} List{NatTerm} ->  List{NatTerm} .
   eq toTerms nil nil nlist = nlist .
   eq toTerms ((qidAsTerm q) nlist) ((fixedBound nt) blist) nlist' =
      toTerms nlist blist (nlist' nt) .
   eq toTerms ((qidAsTerm q) nlist) (bd1 blist) nlist' =
      toTerms nlist blist (nlist' (qidAsTerm q)) 
   .

   crl [subst-diverge-family] : 
    pConfig(Sigma, Delta, 
              (family (cn1[blist]) nlist blist ::= 
                 nf(x1 : T1 <- read (cn1[tlist]), return x1)
              )
              || 
              (family (cn2[blist2]) nlist2 blist2 ::= 
                nf( (x2 : T1 <- read (cn1[nlist'])) BRL , R2
                  )
              ),
              I, O, A
           )    
    =>
    pConfig(Sigma, Delta, 
              (family (cn1[blist]) nlist blist ::= 
                 nf(x1 : T1 <- read (cn1[tlist]), return x1))
              || 
              (family (cn2[blist2]) nlist2 blist2 ::= 
                 nf(x3 : typeInCtx( fam (cn2[blist2]), A, Delta) <- 
                         read (cn2[toTerms nlist2 blist2 nil]), 
                    return x3)),
              I, O, A
           ) 
   if sameIndices nlist blist tlist        
   ***(  here subst fns1/2 with cn1/2          
   if        
   O == insert(fam (fns1[blist]), fam (fns2[blist2]))
 /\
     elem (fam (fns1[blist]))  T1 Delta A
     /\
     elem ( fam (fns2[blist2])) T2 Delta A
     /\
     typeOf(Sigma, Delta, addDeclarations BRL (x2 : T1), 
            insert(fam (fns1[blist]), insert( fam (fns2[blist2]), I)), A, R2) 
     == 
     typeInCtx( fam (fns2[blist2]), A, Delta) 
  )   
           [nonexec] *** because x3 is new and T2 must be specified as well!
  . 

  crl [subst-diverge-join-cases] : 
    *** TODO: bt3 and bt4 must be updated for tlist in fns1!!!
    *** this might be why things don't work?
       pConfig(Sigma, Delta, 
              (family (fns1[blist1]) nlist1 blist1 ::= 
                 (when bt1 --> nf((x1 : T1 <- read (fns2[tlist])) BRL, R1))
                 ;;
                 (when bt2 --> nf((x2 : T2 <- read (fns1[nlist1])),
                                   return x2 ))
              )
              || 
              (family (fns2[blist2]) nlist2 blist2 ::= 
                 (when bt3 --> R2)
                 ;;
                 (when bt4 --> nf((x3 : T1 <- read (fns2[nlist2])),
                                   return x3))
              ),
              I, O, A
           )
       => 
       pConfig(Sigma, Delta,
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 (when (bt1 conj bt3) --> R)
                 ;;
                 (when (bt2 disj bt4)--> 
                                nf((x2 : T2 <- read (fns1[nlist1])),
                                   return x2))
              )
              || 
              (family (fns2[blist2]) nlist2 blist2 ::= 
                 (when bt3 --> R2)
                 ;;
                 (when bt4 --> nf((x3 : T1 <- read (fns2[nlist2])),
                                   return x3))
              )
              , I, O, A)  
   if pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 nf((x1 : T1 <- read (fns2[tlist])) BRL, R1)
               )
               ||
               (family (fns2[blist2]) nlist2 blist2 ::= R2),
             I, O, (bt1, bt3, A))
      => 
      pConfig(Sigma, Delta, 
              (family (fns1[blist1]) nlist1 blist1 ::= R)
               ||
              (family (fns2[blist2]) nlist2 blist2 ::= R2), 
              I, O, A') 
      /\
      A' == (bt1, bt3, A)                           
  .

  crl [subst-diverge-family-channel] : 
    pConfig(Sigma, Delta, 
              (family (fns[blist]) nlist blist ::= 
                 nf(x1 : T1 <- read (fns[nlist]), return x1)
              )
              || 
              (cn ::= 
                nf( (x2 : T1 <- read (fns[nlist2])) BRL , R2
                  )
              ),
              I, O, A
           )    
    =>
    pConfig(Sigma, Delta, 
              (family (fns[blist]) nlist blist ::= 
                 nf(x1 : T1 <- read (fns[nlist]), return x1))
              || 
              (cn ::= 
                 nf(x3 : T2 <- read cn, return x3)),
              I, O, A
           ) 
   if        
   O == insert(fam (fns[blist]), chn cn)
   /\
     elem (fam (fns[blist])) T1 Delta A
     /\
     elem (chn cn) T2 Delta A
     /\
     typeOf(Sigma, Delta, addDeclarations BRL (x2 : T1), 
            insert(fam (fns[blist]), insert(chn cn, I)), A, R2) 
     == 
     typeInCtx(chn cn, A, Delta) 
           [nonexec] *** because x3 is new and T2 must be specified as well!
  .
 
  ***(
  crl [subst-diverge-family-channel-old] : 
    pConfig(Sigma, Delta, 
              (family (C[bound nt1]) i (bound nt1) ::= 
                 nf(x1 : T1 <- read (C[i]), return x1, x1)
              )
              || 
              (cn ::= 
                nf( (x2 : T1 <- read (C[nj])) BRL , R2
                  )
              ),
              I, O, A
           )    
    =>
    pConfig(Sigma, Delta, 
              (family (C[bound nt1]) i (bound nt1) ::= 
                 nf(x1 : T1 <- read (C[i]), return x1, x1 ))
              || 
              (cn ::= 
                 nf(x3 : T2 <- read cn, return x3, x3 )),
              I, O, A
           ) 
   if        
   O == insert(fam (C[bound nt1]), chn cn)
   /\
     elem (fam (C[bound nt1])) T1 Delta A
     /\
     elem (chn cn) T2 Delta A
     /\
     typeOf(Sigma, Delta, addDeclarations BRL (x2 : T1), 
            insert(fam (C[bound nt1]), insert(chn cn, I)), A, R2) 
     == 
     typeInCtx(chn cn, A, Delta) 
           [nonexec] *** because x3 is new and T2 must be specified as well!
  .
  
  *** we don't use this rule!
  rl [SUBST-nf-rev-family] : 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (family C lq blist ::= preNF( BRL , R1) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (family C lq blist ::= preNF((x1 : T1 <- read cn1) BRL , return x1 )),
             I, O, A) 
    [nonexec] .      
    )

   crl [SUBST-nf-rev-families-one] : 
     pConfig(Sigma, Delta,
             (family (fns1[bound nt1]) (qidAsTerm q) (bound nt1) ::= cases) 
             || 
             (family (fns2[bound nt2]) (qidAsTerm q') (bound nt2) ::= preNF( BRL , R1) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (family (fns1[bound nt1]) (qidAsTerm q) (bound nt1) ::= cases) 
             || 
              (family (fns2[bound nt2]) (qidAsTerm q') (bound nt2) ::= 
                preNF((x1 : T1 <- read (fns1[nj])) BRL , return x1 )),
             I, O, A) 
     if 
     typeOf(Sigma, Delta, emptyTypeContext, 
            insert(fam (fns1[bound nt1]), insert(fam (fns2[bound nt2]) , I)), 
                   insert(qidAsTerm q =T= nj, A), R2) 
     == 
     typeInCtx(fam (fns1[bound nt1]), insert(qidAsTerm q =T= nj, A), Delta) 
     /\
     typeOf(Sigma, Delta, addDeclarations BRL emptyTypeContext, 
            insert(fam (fns1[bound nt1]), insert(fam (fns2[bound nt2]) , I)), A, R1) 
     == 
     typeInCtx( fam (fns2[bound nt2]), A, Delta) 
     /\       
     (projectIndex (family (fns1[bound nt]) (qidAsTerm q) (bound nt1)  ::= cases) nj 
          insert(qidAsTerm q =T= nj, A) empty) == (fns1[nj] ::= R2)
     /\ 
     R1 == convertNF(R2)               
  [nonexec] . 

  crl [subst-families-one] :
     pConfig(Sigma, Delta, 
             (family (fns[blist]) nlist blist ::= cases)
             ||
             (cn2 ::= nf((x : T <- read (fns[tlist])) BRL, R)),
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             (family (fns[blist]) nlist blist ::= cases)
             ||
             (cn2 ::= preNF((x : T <~ (
              getReaction 
               (project2Index (family (fns[blist]) nlist blist ::= cases) nlist tlist 
                (addAssumptions A nlist blist) empty) 
               (chn (fns[tlist]))
                            ) ) BRL, R)
             )
             ,
             I, O, A) 
     if 
      typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(fam (fns[blist]), insert(toBound cn2 , I)), A, R) 
     == 
     typeInCtx(toBound cn2, A, Delta) 
     /\ 
     typeInCtx(fam (fns[blist]), A, Delta) == T
     *** (/\ 
     (fns[tlist] ::= R2) == 
     (project2Index (family (fns[blist]) nlist blist ::= cases) nlist tlist 
          (addAssumptions A nlist blist) empty) 
         
     [nonexec] 
     )
     .

   var t1 t2 t3 : NatTerm .
   
   crl [subst-families-three] :
     pConfig(Sigma, Delta, 
             (family (fns[bd1 bd2 bd3]) 
             ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 bd2 bd3) ::= cases)
             ||
             (cn2 ::= nf((x : T <- read (fns[t1 t2 t3])) BRL, R)),
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             (family (fns[bd1 bd2 bd3])
             ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 bd2 bd3) ::= cases)
             ||
             (cn2 ::= preNF((x : T <~ R2) BRL, R))
             ,
             I, O, A) 
     if
      typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(fam (fns[bd1 bd2 bd3]), insert(toBound cn2 , I)), A, R) 
     == 
     typeInCtx(toBound cn2, A, Delta) 
     /\ 
     typeInCtx(fam (fns[bd1 bd2 bd3]), A, Delta) == T 
     /\
     (projectIndex (family (fns[blist])((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 bd2 bd3) ::= cases) 
         (t1 t2 t3) 
          insert(qidAsTerm q1 =T= t1, insert(qidAsTerm q2 =T= t2, insert(qidAsTerm q3 =T= t3, A))) empty) 
     == 
     (fns[t1 t2 t3] ::= R2)      
     [nonexec] . 

     crl [subst-families-one-cases] :
     pConfig(Sigma, Delta, 
             (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= cases)
             ||
             (cn2 ::= nf((x : T <- read (fns[nj])) BRL, R)),
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= cases)
             ||
             (cn2 ::= cases')
             ,
             I, O, A) 
     if 
      typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(fam (fns[bound nt]), insert(toBound cn2 , I)), A, R) 
     == 
     typeInCtx(toBound cn2, A, Delta) 
     /\ 
     typeInCtx(fam (fns[bound nt]), A, Delta) == T
     /\
     pConfig(Sigma, Delta, 
             (cn2 ::= nf((x : T <- read (fns[nj])) BRL, R)) 
             || 
             (projectIndex (family (fns[bound nt]) (qidAsTerm q) (bound nt)  ::= cases) nj 
              insert((qidAsTerm q) =T= nj, A) empty),
             I, (chn cn2, chn (fns[nj])), A
            ) 
     => 
     pConfig(Sigma, Delta, 
             (cn2 ::= cases') 
             || 
             P,
             I, (chn cn, chn (fns[nj])), A
            )  
     . 
     
     var C1 : Qid .
   *** TODO: was made generic, one should go away!
     crl [subst-channel-one-family] :
     pConfig(Sigma, Delta, 
             (cn ::= R2)
             ||
             (family (fns[blist]) nlist blist ::= 
                nf((x : T <- read cn) BRL, R)
             ),
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             (cn ::= R2)
             ||
             (family (fns[blist]) nlist blist ::= 
               preNF((x : T <~ R2) BRL, R )
             ),
             I, O, A) 
     if isSampFree(R2) /\
        O == insert(toBound cn, fam (fns[blist])) /\ 
     typeOf(Sigma, Delta, emptyTypeContext, 
            insert(toBound cn, insert(fam (fns[blist]), I)), A, R2) == T /\
     typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(toBound cn, insert(fam (fns[blist]), I)), A, R) 
     == 
     typeInCtx(fam (fns[blist]), A, Delta)
     /\ 
     elem (toBound cn) T Delta A 
     . 
  *** TODO: conditions?
     rl [subst-families-gen] :
     pConfig(Sigma, Delta, 
             (family (fns2[blist2]) nlist2 blist2 ::= cases) || 
             (family (fns1[blist1]) nlist1 blist1 ::=
               nf((x : T <- read (fns2[tlist]) ) BRL, 
                  R
                 )
             ),
             I, O, A
     )
     => 
     pConfig(Sigma, Delta, 
             (family (fns2[blist2]) nlist2 blist2 ::= cases) || 
             (family (fns1[blist1]) nlist1 blist1 ::=
               preNF((x : T <~ (
              getReaction 
               (project2Index (family (fns2[blist2]) nlist2 blist2 ::= cases) nlist2 tlist 
                (addAssumptions A nlist1 blist1) empty) 
               (chn (fns2[tlist]))
             )) BRL, 
                  R
                 )
             ),
             I, O, A
     )
     .
***(
   crl [subst-families-gen] :
     pConfig(Sigma, Delta, 
             (family (fns2[blist2]) nlist2 blist2 ::= cases) || 
             (family (fns1[blist1]) nlist1 blist1 ::=
               nf((x : T <- read (fns2[tlist]) ) BRL, 
                  R
                 )
             ),
             I, O, A
     )
     => 
     pConfig(Sigma, Delta, 
             (family (fns2[blist2]) nlist2 blist2 ::= cases) || 
             (family (fns1[blist1]) nlist1 blist1 ::=
               preNF((x : T <~ R2) BRL, 
                  R
                 )
             ),
             I, O, A
     )
     if (project2Index (family (fns2[blist2]) nlist2 blist2 ::= cases) nlist2 tlist
          A empty) == (fns2[tlist] ::= R2)
     [nonexec] 
     . )

     rl [subst-families-one-family] :
     pConfig(Sigma, Delta, 
             (family (fns2[bound nt]) (qidAsTerm q) (bound nt) ::= cases)
             ||
             (family (fns1[bound nt]) (qidAsTerm q') (bound nt1) ::= 
                nf((x : T <- read (fns2[nj])) BRL, R)),
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             (family (fns2[bound nt]) (qidAsTerm q) (bound nt) ::= cases)
             ||
             (family (fns1[bound nt]) (qidAsTerm q')  (bound nt1) ::= 
              preNF((x : T <~ (
                 getReaction 
                   (projectIndex (family (fns2[bound nt]) (qidAsTerm q) (bound nt)  ::= cases) nj 
                    insert((qidAsTerm q) =T= nj, A) empty) (chn (fns2[nj]))
                               )
                    ) BRL, R)
             )
             ,
             I, O, A) 
     .

   crl [subst-families-three-family] :
     pConfig(Sigma, Delta, 
             (family (fns2[bd1 bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 bd2 bd3) ::= cases)
             ||
             (family (fns1[bd4 bd5 bd6]) ((qidAsTerm q4)(qidAsTerm q5) qidAsTerm q6) (bd4 bd5 bd6) ::= 
                nf((x : T <- read (fns2[t1 t2 t3])) BRL, R)),
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             (family (fns2[bd1 bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 bd2 bd3) ::= cases)
             ||
             (family (fns1[bd4 bd5 bd6]) ((qidAsTerm q4)(qidAsTerm q5) qidAsTerm q6) (bd4 bd5 bd6) ::= 
                preNF((x : T <~ R2) BRL, R )),
             I, O, A) 
     if (projectIndex (family (fns2[bd1 bd2 bd3]) ((qidAsTerm q1)(qidAsTerm q2) qidAsTerm q3) (bd1 bd2 bd3) ::= cases) (t1 t2 t3)
          (qidAsTerm q1 =T= t1, 
           qidAsTerm q2 =T= t2, 
           qidAsTerm q3 =T= t3, A) empty) == (fns2[t1 t2 t3] ::= R2)
     [nonexec] 
     . 

     var fns3 : ChannelName .
      rl [subst-nf-read-rev-families] :
     pConfig(Sigma, Delta,
       (family (fns1[blist1]) nlist1 blist1 ::= cases) || 
       (family (fns2[blist1]) nlist1 blist1 ::=
          nf(x : T <- read (fns1[nlist1]), return x) 
       ) || 
       (family (fns3[blist2]) nlist2 blist2 ::=
          nf(y : T <- read (fns1[nlist1]), return y) ),
       I, O, A
     )
     =>
     pConfig(Sigma, Delta,
       (family (fns1[blist1]) nlist1 blist1 ::= cases) || 
       (family (fns2[blist1]) nlist1 blist1 ::=
          nf(x : T <- read (fns3[nlist2]), return x) 
       ) || 
       (family (fns3[blist2]) nlist2 blist2 ::=
          nf(y : T <- read (fns1[nlist1]), return y) ),
       I, O, A
     )
     . 

   crl [subst-2-families-one] :
     pConfig(Sigma, Delta, 
             (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= cases')
             ||
             (cn2 ::= cases),
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= cases')
             ||
             (cn2 ::= nf('x : T <- read (fns[nj]), 
                         return 'x
                         )  *** TODO: 'x should turn into a var!!!
             ),
             I, O, A) 
     if (projectIndex (family (fns[bound nt]) (qidAsTerm q) (bound nt)  ::= cases') nj 
          insert(qidAsTerm q =T= nj, A) empty) == (fns[nj] ::= cases)
     [nonexec] 
     . 
     
  var nj' : NatTerm . 

  crl [subst-families-two] : *** TODO: turn 'x into a variable!
     pConfig(Sigma, Delta, 
             (family (fns[(bound (natAsTerm n)) (bound nt)])
             ((qidAsTerm q1)(qidAsTerm q2)) ((bound (natAsTerm n)) (bound nt)) ::= cases')
             ||
             (cn2 ::= cases),
             I, O, A)
     => 
    pConfig(Sigma, Delta, 
             (family (fns[(bound (natAsTerm n)) (bound nt)])
            ((qidAsTerm q1)(qidAsTerm q2)) ((bound (natAsTerm n)) (bound nt))  ::= cases')
             ||
             (cn2 ::= nf('x : T <- read (fns[nj nj']), return 'x) ),
             I, O, A) 
     if (projectIndex 
          (family (fns[(bound (natAsTerm n)) (bound nt)])
           ((qidAsTerm q1)(qidAsTerm q2)) ((bound (natAsTerm n)) (bound nt)) ::= cases') 
          (nj nj') A empty) 
        == 
        (fns[nj nj'] ::= cases)
     [nonexec] . 

   rl [subst-rev-families] : *** TODO: turn 'x into a variable
  *** TODO: check if this rule is sound!
     pConfig(Sigma, Delta, 
             (family (fns[blist])(qidAsTerm q) (bound (natAsTerm n)) ::= 
                whenList1 ;; (when (qidAsTerm q =T= nj) --> R) ;; whenList2)
             ||
             (cn2 ::= R),
             I, O, A)
     => 
    pConfig(Sigma, Delta, 
             (family (fns[blist])(qidAsTerm q) (bound (natAsTerm n)) ::= 
               whenList1 ;; (when (qidAsTerm q =T= nj) --> R) ;; whenList2)
             ||
             (cn2 ::= nf('x : T <- read (fns[nj]), return 'x)),
             I, O, A)
    *** if typeOf(Sigma, Delta, emptyTypeContext, I, A, R) == T  *** TODO: need to add Cs to I?
    [nonexec] . 
    
  *** was (q1 n1 :: T1) (q2 n2 :: T2) (C n :: T1)
      *** family q = read cn1 || cn2 = .. x <- read q[j]...
      *** rewrites to
      *** family q = read cn1 || cn2 = .. x <- read cn1...
      *** but we may have cn1 parameterized as well and then we need to replace! 

  crl [SUBST-nf-read-family-one] : 
     pConfig(Sigma, Delta ,
             (family (fns1[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                nf((x2 : T1 <- read cn1), return x2 )) || 
             (cn2 ::= nf( (x1 : T1 <- read (fns1[nj])) BRL , R2) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (family (fns1[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
               nf((x2 : T1 <- read cn1), return x2 ))  || 
             (cn2 ::= 
               nf((x2 : T1 <- read (evalCName cn1 (q |-> nj))) BRL , 
                  R2 [x1 / x2])),
             I, O, A) 
     if *** TODO: add condition about nj being in bounds
     isElemB(cn1, I, A) ***( /\
     elem (fam (fns1[bound (natAsTerm n)])) T1 Delta A /\
     elem (toBound cn1) T1 Delta A /\
     O == insert(fam (fns1[bound (natAsTerm n)]), toBound cn2)  /\
     typeOf(Sigma, Delta, addDeclarations BRL (x1 : T1), 
            insert(fam (fns1[bound (natAsTerm n)]), insert(toBound cn1, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta) 
     )       .
  
  var n1 : NatTerm .

  rl [SUBST-nf-read-family-two] : 
     pConfig(Sigma, Delta ,
             (family (fns1[(bound n1) (bound nt)]) ((qidAsTerm q1)(qidAsTerm q2)) ((bound n1) (bound nt)) ::= 
                 nf((x2 : T1 <- read cn1), return x2)) || 
             (cn2 ::= nf( (x1 : T1 <- read (fns1[(qidAsTerm q1) nj])) BRL , R2) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (family (fns1[(bound n1) (bound nt)]) 
               ((qidAsTerm q1)(qidAsTerm q2)) ((bound n1) (bound nt)) ::= 
                nf((x2 : T1 <- read cn1), return x2 ))  || 
             (cn2 ::= 
               nf((x2 : T1 <- read (evalCName cn1 (q2 |-> nj))) BRL , 
                  R2 [x1 / x2])),
             I, O, A) 
     ***( if *** TODO: add condition about nj being in bounds
     isElemB(cn1, I, A)  /\
     elem (fam (fns1[bound (natAsTerm n)])) T1 Delta A /\
     elem (toBound cn1) T1 Delta A /\
     O == insert(fam (fns1[bound (natAsTerm n)]), toBound cn2)  /\
     typeOf(Sigma, Delta, addDeclarations BRL (x1 : T1), 
            insert(fam (fns1[bound (natAsTerm n)]), insert(toBound cn1, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta) 
     )       . 

   rl [SUBST-nf-read-family-two-family] : 
     pConfig(Sigma, Delta ,
             (family (fns1[(bound n1) (bound nt)]) ((qidAsTerm q1)(qidAsTerm q2)) ((bound n1) (bound nt)) ::= 
                 nf((x2 : T1 <- read cn1), return x2  )) || 
             (family (fns2[bound nt2]) (qidAsTerm q'') (bound nt2) ::= 
                 nf( (x1 : T1 <- read (fns1[(qidAsTerm q) nj])) BRL , R2) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (family (fns1[(bound n1) (bound nt)]) ((qidAsTerm q1)(qidAsTerm q2)) ((bound n1) (bound nt)) ::= 
                nf((x2 : T1 <- read cn1), return x2 ))  || 
             (family (fns2[bound nt2]) (qidAsTerm q'') (bound nt2) ::= 
                nf((x2 : T1 <- read (evalCName cn1 (q2 |-> nj))) BRL , 
                    R2 [x1 / x2])),
             I, O, A) . 

   crl [SUBST-nf-read-family] : 
     pConfig(Sigma, Delta ,
             (family (fns1[bounds]) ntl bounds ::= 
               nf((x2 : T1 <- read cn1), return x2 )) || 
             (cn2 ::= nf( (x1 : T1 <- read (fns1[nj])) BRL , R2) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (family (fns1[bounds]) ntl bounds ::= 
              nf((x2 : T1 <- read cn1), return x2 ))  || 
             (cn2 ::= nf((x2 : T1 <- read cn1) BRL , R2 [x1 / x2])),
             I, O, A) 
     if *** TODO: add condition about nj being in bounds
     isElemB(cn1, I, A) /\
     elem (fam (fns1[bounds])) T1 Delta A /\
     elem (toBound cn1) T1 Delta A /\
     O == insert(fam (fns1[bounds]), toBound cn2)  /\
     typeOf(Sigma, Delta, addDeclarations BRL (x1 : T1), 
            insert(fam (fns1[bounds]), insert(toBound cn1, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta) .  

   rl [comp-new-families] : 
     pConfig(Sigma, Delta, newNF(ltq1, P1) || newNF(ltq2, P2), I, O, A)
     => 
     pConfig(Sigma, Delta, newNF(ltq1 ltq2, P1 || P2), I, O, A) 
     . 

   crl [use-family-p] : 
     pConfig(Sigma, Delta1, P1 || family (fns[blist]) lq blist ::= P, I, O1, A)
     => 
     pConfig(Sigma, Delta2, P2 || family (fns[blist]) lq blist ::= P, I, O2, A)
     if 
     pConfig(Sigma, Delta1, P1 || P, I, O1, A)
     => 
     pConfig(Sigma, Delta2, P2 || P, I, O2, A)
     /\
     Delta1 equiv Delta2 
     /\ 
     O1 equiv O2
      .

   rl [fold-bind-new-nf-families] :
    pConfig(Sigma, Delta, 
             newNF({ (fns1[bound (natAsTerm n)]) (qidAsTerm q) : T } ltq, 
                   P || (family (fns1[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= R) || 
                        (family (fns2[bound n1]) (qidAsTerm q') (bound n1) ::= 
                       nf((x : T <- read (fns1[qidAsTerm q'])) BRL, S))),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, P || 
                    (family (fns2[bound n1]) (qidAsTerm q') (bound n1) ::= 
                     preNF((x : T <~ R) BRL, S ))
                  ),
            I, O, A) 
    ***( 
    if typeOf(Sigma, addChannels ltq (Delta ((toBound fns1):: T)), addDeclarations BRL emptyTypeContext, 
            insert(toBound o, insert(toBound fns1, union(I, getOutputs(P)))), A, R) == T 
    )        
  .  

  rl [fold-bind-new-nf-families-gen] :
   pConfig(Sigma, Delta,
   newNF({ (fns1[blist]) nlist : T } ltq, 
        P || 
        (family (fns1[blist]) nlist blist ::= R) || 
        (family (fns2[blist']) nlist' blist' ::= 
                        nf((x : T <- read (fns1[nlist])) BRL, S)
        )                
        ), I, O, A)
   =>  
   pConfig(Sigma, Delta,    
   newNF(ltq, 
        P ||
        (family (fns2[blist']) nlist' blist' ::= 
                        preNF((x : T <~ R) BRL, S)
        )                
        ), I, O, A)
  .

  rl [fold-bind-new-nf-families-gen-preNF] :
   pConfig(Sigma, Delta,
   newNF({ (fns1[blist]) nlist : T } ltq, 
        P || 
        (family (fns1[blist]) nlist blist ::= R) || 
        (family (fns2[blist']) nlist' blist' ::= 
                        preNF((x : T <- read (fns1[nlist])) BRL, S)
        )                
        ), I, O, A)
   =>  
   pConfig(Sigma, Delta,    
   newNF(ltq, 
        P ||
        (family (fns2[blist']) nlist' blist' ::= 
                        preNF((x : T <~ R) BRL, S)
        )                
        ), I, O, A)
  .

  rl [fold-bind-new-nf-families-gen-zero] :
   pConfig(Sigma, Delta,
   newNF({ (fns1[blist]) nlist : T } ltq,  
        (family (fns1[blist]) nlist blist ::= R) || 
        (family (fns2[blist']) nlist' blist' ::= 
                        nf((x : T <- read (fns1[nlist])) BRL, S)
        )                
        ), I, O, A)
   =>  
   pConfig(Sigma, Delta,    
   newNF(ltq, 
        (family (fns2[blist']) nlist' blist' ::= 
                        preNF((x : T <~ R) BRL, S)
        )                
        ), I, O, A)
  .

  rl [fold-bind-new-nf-families-zero] :
    pConfig(Sigma, Delta, 
             newNF({ (fns1[bound (natAsTerm n)]) (qidAsTerm q) : T } ltq, 
                  (family (fns1[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= R) || 
                      (family (fns2[bound n1]) (qidAsTerm q') (bound n1) ::= 
                        nf((x : T <- read (fns1[qidAsTerm q'])) BRL, S))),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, 
                   (family (fns2[bound n1]) (qidAsTerm q') (bound n1) ::= 
                     preNF((x : T <~ R) BRL, S ))),
            I, O, A) 
    ***( 
    if typeOf(Sigma, addChannels ltq (Delta ((toBound fns1):: T)), addDeclarations BRL emptyTypeContext, 
            insert(toBound o, insert(toBound fns1, union(I, getOutputs(P)))), A, R) == T 
    )        
  . 

  *** congruence rules for families
    
     crl [CONG-NEWFAMILY] : 
     pConfig(Sigma, Delta1, newfamily (fns[blist]) lq blist : T in P1, I, O1, A)
     =>  
     pConfig(Sigma, Delta2, newfamily (fns[blist]) lq blist : T in P2, 
             I, O2 \ (fam (fns[blist])), A)
     if 
     pConfig(Sigma, Delta1 ((fam (fns[blist])) :: T), P1, I, insert(fam (fns[blist]), O1), A)
     =>
     pConfig(Sigma, Delta2 ((fam (fns[blist])) :: T), P2, I, O2, A)
     . *** adding the old fns in Delta2 ensures that we cannot split fns!
     
     crl [CONG-FAMILY-R] : 
     pConfig(Sigma, Delta, family (fns[blist]) lq blist ::= R, I, O, A)
     => 
     pConfig(Sigma, Delta, family (fns[blist]) lq blist ::= R', I, O, A)
     if 
     rConfig(Sigma, Delta, emptyTypeContext, R, insert(fam (fns[blist]), I), A, 
             typeInCtx(fam (fns[blist]), A, Delta))
     =>
     rConfig(Sigma, Delta, emptyTypeContext, R', I', A, T) 
     /\ I' == insert(fam (fns[blist]), I)  
     /\ T == typeInCtx(fam (fns[blist]), A, Delta)
     .
     
     crl [CONG-FAMILY-P] : 
     pConfig(Sigma, Delta1, family (fns[blist]) lq blist ::= P1, I, O1, A)
     => 
     pConfig(Sigma, Delta2, family (fns[blist]) lq blist ::= P2, I, O2, A)
     if
     pConfig(Sigma, Delta1, P1, I, O1, A)
     =>
     pConfig(Sigma, Delta2, P2, I, O2, A) 
     /\
     Delta1 equiv Delta2 
     /\ 
     O1 equiv O2 . 
     
     crl [CONG-FAMILY-WHENLIST-P] : 
     pConfig(Sigma, Delta1, 
             family (fns[blist]) lq blist ::= whenList1 ;; (when bt --> P1) ;; whenList2, 
             I, O1, A)
     => 
     pConfig(Sigma, Delta2, 
             family (fns[blist]) lq blist ::= whenList1 ;; (when bt --> P2) ;; whenList2, 
             I, O2, A) 
     if 
     pConfig(Sigma, Delta1, P1, I, O1, insert(bt, A) )
     =>  
     pConfig(Sigma, Delta2, P2, I, O2, A')
     /\ 
     A' == insert(bt, A)
     /\
     Delta1 equiv Delta2 
     /\ 
     O1 equiv O2
     . 
     
     crl [CONG-FAMILY-WHENLIST-R] : 
     pConfig(Sigma, Delta, 
       family (fns[blist]) nlist blist ::= 
        (whenList1 ;; (when bt --> R1) ;; whenList2), I, O, A)
     => 
     pConfig(Sigma, Delta, 
       family (fns[blist]) nlist blist ::= 
        (whenList1 ;; (when bt --> R2) ;; whenList2), I, O, A) 
     if 
     rConfig(Sigma, Delta, emptyTypeContext, R1, insert(fam (fns[blist]), I), 
              addAssumptions insert(bt, A) nlist blist, 
              typeOf(Sigma, Delta, emptyTypeContext, I, 
                     addAssumptions insert(bt, A) nlist blist, R1))
     =>  
     rConfig(Sigma, Delta, emptyTypeContext, R2, I', A', T)
     /\
     A' == addAssumptions insert(bt, A) nlist blist 
     /\
     I' == insert(fam (fns[blist]), I)
     /\
     T ==  typeOf(Sigma, Delta, emptyTypeContext, I, 
                  addAssumptions insert(bt, A) nlist blist, R1)
     .   

    *** case distinction
     
     var aP1 aP2 : Protocol .
     var A'' : Set{BoolTerm} .
     var aQid : Qid .
     
     ****************************
     **** case substitution for channels
     ****************************
     
     crl [channel-cases-subst-end-otherwise]:
      pConfig(Sigma, Delta, 
               (cn1 ::= 
                 nf( ( x : T <- read cn2) BRL, 
                     R
                   )
               )
                || 
               (cn2 ::= 
                 (otherwise --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn1 ::= 
                 (otherwise --> R2) 
               )
                || 
               (cn2 ::= 
                 (otherwise --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( cn2 ::= R1 ) 
             || 
             ( cn1 ::= nf( (x : T <- read cn2 ) BRL, R)
             ),
             I, insert(chn cn1, chn cn2), A
           )
    =>
    pConfig(Sigma, Delta, 
             (cn2 ::= R1) || (cn1 ::= R2),
             I, O', A
           )       
    /\ O' == insert(chn cn1, chn cn2)
    [nonexec]
    .
   
     crl [channel-cases-subst-end-when]:
      pConfig(Sigma, Delta, 
               (cn1 ::= 
                 nf( ( x : T <- read cn2 ) BRL, 
                     R
                   )
               )
                || 
               (cn2 ::= 
                 (when bt --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn1 ::= (when bt --> R2))
                || 
               (cn2 ::= (when bt --> R1)),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( cn2 ::= R1 ) 
             || 
             ( cn1 ::= nf( (x : T <- read cn2 ) BRL, R)
             ),
             I,
             insert(chn cn1, chn cn2), 
             insert(bt, A)
           )
    =>
    pConfig(Sigma, Delta, 
             (cn2 ::= R1) || (cn1 ::= R2),
             I, O', A'
           )       
    /\ A' == insert(bt, A)
    /\ O' == insert(chn cn1, chn cn2)
    [nonexec]
    .
     
     crl [channel-cases-subst]:
      pConfig(Sigma, Delta, 
               (cn1 ::= 
                 nf( ( x : T <- read cn2 ) BRL, 
                     R
                   )
               )
                || 
               (cn2 ::= 
                 (when bt --> R1) ;; whenList
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn1 ::= 
                 (when bt --> R2) 
                 ;;
                 whenList'
               )
                || 
               (cn2 ::= 
                 (when bt --> R1) 
                 ;; 
                 whenList
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( cn2 ::= R1 ) 
             || 
             ( cn1 ::= nf( (x : T <- read cn2 ) BRL, R)
             ),
             I, insert(chn cn1, chn cn2), 
             insert(bt, A)
           )
    =>
    pConfig(Sigma, Delta, 
             (cn2 ::= R1) || (cn1 ::= R2),
             I, O', A'
           )       
    /\ A' == insert(bt, A)
    /\ O' == insert(chn cn1, chn cn2)
    /\ *** now the step
    pConfig(Sigma, Delta, 
              (cn1 ::= 
                 nf( ( x : T <- read cn2 ) BRL, 
                     R
                   )
               )
                || 
               (cn2 ::= 
                 whenList
               ),
               I, O, insert(neg bt, A) 
           )
   => 
   pConfig(Sigma, Delta, 
              (cn1 ::= 
                 whenList'
               )
                || 
               (cn2 ::= 
                 whenList
               ),
               I, O, A''
           )  
    /\
    A'' == insert(neg bt, A)
    . 


        ****************************
     **** case substitution channel/family
     ****************************
     
     crl [fc-cases-subst-end-otherwise]:
      pConfig(Sigma, Delta, 
               (cn ::= 
                 nf( ( x : T <- read (fns[nj]) ) BRL, 
                     R
                   )
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (otherwise --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn ::= 
                 (otherwise --> R2) 
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (otherwise --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= R1) 
             || 
             ( cn ::= nf( (x : T <- read (fns[nj]) ) BRL, R)
             ),
             I, insert(fam (fns[bound nt]), chn cn), A
           )
    =>
    pConfig(Sigma, Delta, 
             ( family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= R1)  || (cn ::= R2),
             I, O', A
           )       
    /\ O' == insert(fam (fns[bound nt]), chn cn)
    [nonexec]
    .
         
     crl [fc-cases-subst-end-when]:
      pConfig(Sigma, Delta, 
               (cn ::= 
                 nf( ( x : T <- read (fns[nj]) ) BRL, 
                     R
                   )
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn ::= 
                 (when subst(bt, q |-> nj) --> R2) 
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= R1)
             || 
             ( cn ::= nf( (x : T <- read (fns[nj]) ) BRL, R)
             ),
             I,
             insert(fam (fns[bound nt]), chn cn), 
             insert(subst(bt, q |-> nj), A)
           )
    =>
    pConfig(Sigma, Delta, 
             ( family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= R1) || (cn ::= R2),
             I, O', A'
           )       
    /\ A' == insert(subst(bt, q |-> nj), A)
    /\ O' == insert(fam (fns[bound nt]), chn cn)
    [nonexec]
    .
        
     crl [fc-cases-subst]:
      pConfig(Sigma, Delta, 
               (cn ::= 
                 nf( ( x : T <- read (fns[nj]) ) BRL, 
                     R
                   )
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R1) ;; whenList
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn ::= 
                 (when subst(bt, q |-> nj) --> R2) 
                 ;;
                 whenList'
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R1) 
                 ;; 
                 whenList
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= R1) 
             || 
             ( cn ::= nf( (x : T <- read (fns[nj]) ) BRL, R)
             ),
             I, insert(fam (fns[bound nt]), chn cn), insert(subst(bt, q |-> nj), A)
           )
    =>
    pConfig(Sigma, Delta, 
             ( family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= R1) || (cn ::= R2),
             I, O', A'
           )       
    /\ A' == insert(subst(bt, q |-> nj), A)    
    /\ O' == insert(fam (fns[bound nt]), chn cn)
    /\
    pConfig(Sigma, Delta, 
              (cn ::= 
                 nf( ( x : T <- read (fns[nj]) ) BRL, 
                     R
                   )
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 whenList
               ),
               I, O, insert(neg (subst(bt, q |-> nj)), A) 
           )
   => 
   pConfig(Sigma, Delta, 
              (cn ::= 
                 whenList'
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 whenList
               ),
               I, O, A''
           )  
    /\
    A'' == insert(neg (subst(bt, q |-> nj)), A)
    .

       *****************************
    *** case subst, generic
    *****************************
    
    crl [gen-cases-subst-end-when]:
     pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 nf( ( x : T <- read (fns2[tlist]) ) BRL, 
                     R
                   )
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 (when bt --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 (when bt --> R2) 
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 (when bt --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( family (fns2[blist2]) nlist2 blist2 ::= R1 ) 
             || 
             ( family (fns1[blist1]) nlist1 blist1 ::= 
                nf( (x : T <- read (fns2[tlist]) ) BRL, R)
             ),
             I, *** TODO: might need to add fns1 as inputs
             insert(fam (fns2[blist2]), fam(fns1[blist1])), 
             addAssumptions insert(bt, A) nlist1 blist1
           )
    =>
    pConfig(Sigma, Delta, 
             (family (fns2[blist2]) nlist2 blist2 ::= R1) 
             || 
             (family (fns1[blist1]) nlist1 blist1 ::= R2),
             I, O', A'
           )       
    /\ A' == addAssumptions insert(bt, A) nlist1 blist1  
    /\ O' == insert(fam (fns2[blist2]), fam(fns1[blist1]))
    *** [nonexec]
    .
     
     crl [gen-cases-subst-end-otherwise]:
      pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 nf( ( x : T <- read (fns2[tlist]) ) BRL, 
                     R
                   )
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 (otherwise --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 (otherwise --> R2) 
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 (otherwise --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( family (fns2[blist2]) nlist2 blist2 ::= R1 ) 
             || 
             ( family (fns1[blist1]) nlist1 blist1 ::= 
               nf( (x : T <- read (fns2[tlist]) ) BRL, R)
             ),
             I, insert(fam (fns2[blist2]), fam(fns1[blist1])), 
             addAssumptions A nlist1 blist1
           )
    =>
    pConfig(Sigma, Delta,
             ( family (fns2[blist2]) nlist2 blist2 ::= R1 ) 
             || 
             ( family (fns1[blist1]) nlist1 blist1 ::= R2),
             I, O', A'
           )       
    /\ A' == addAssumptions A nlist1 blist1
    /\ O' == insert(fam (fns2[blist2]), fam(fns1[blist1]))
    .

    crl [gen-cases-subst]:
      pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 nf( ( x : T <- read (fns2[tlist]) ) BRL, 
                     R
                   )
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 (when bt --> R1) ;; whenList
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 (when bt --> R2) 
                 ;;
                 whenList'
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 (when bt --> R1) 
                 ;; 
                 whenList
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( family (fns2[blist2]) nlist2 blist2 ::= R1 ) 
             || 
             ( family (fns1[blist1]) nlist1 blist1 ::= 
               nf( (x : T <- read (fns2[tlist]) ) BRL, R)
             ),
             I, insert(fam (fns2[blist2]), fam(fns1[blist1])), 
             addAssumptions insert(bt, A) nlist1 blist1  
           )
    =>
    pConfig(Sigma, Delta, 
             (family (fns2[blist2]) nlist2 blist2 ::= R1) || 
             (family (fns1[blist1]) nlist1 blist1 ::= R2),
             I, O', A'
           )       
    /\ A' == addAssumptions insert(bt, A) nlist1 blist1   
    /\ O' == insert(fam (fns2[blist2]), fam(fns1[blist1]))
    /\
    pConfig(Sigma, Delta, 
              (family (fns1[blist1]) nlist1 blist1 ::= 
                 nf( ( x : T <- read (fns2[tlist]) ) BRL, 
                     R
                   )
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 whenList
               ),
               I, O, insert(neg bt, A) 
           )
   => 
   pConfig(Sigma, Delta, 
              (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList'
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 whenList
               ),
               I, O, A''
           )  
    /\
    A'' == insert(neg bt, A)
    .

      *************************
    *** gen same cases subst
    *************************
    
    *** ends with otherwise
    
    crl [gen-same-cases-subst-end-otherwise]:
      pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 otherwise --> R2
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 (otherwise --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 (otherwise --> R3) 
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 (otherwise --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( family (fns2[blist2]) nlist2 blist2 ::= R1 ) 
             || 
             ( family (fns1[blist1]) nlist1 blist1 ::= R2),
             I, insert(fam (fns2[blist2]), fam(fns1[blist1])),
             addAssumptions A nlist1 blist1
           )
    =>
    pConfig(Sigma, Delta, 
             ( family (fns2[blist2]) nlist2 blist2 ::= R1) || 
             (family (fns1[blist1]) nlist1 blist1 ::= R3),
             I, O', A'
           )       
    /\ A' == addAssumptions A nlist1 blist1   
    /\ O' == insert(fam (fns2[blist2]), fam(fns1[blist1]))
    .
     
    *** ends with when 
     
    crl [gen-same-cases-subst-end-when]:
      pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 when bt --> R2
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 (when bt --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 (when bt --> R3) 
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 (when bt --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( family (fns2[blist2]) nlist2 blist2 ::= R1 ) 
             || 
             ( family (fns1[blist1]) nlist1 blist1 ::= R2),
             I, insert(fam (fns2[blist2]), fam(fns1[blist1])), 
             addAssumptions insert(bt, A) nlist1 blist1
           )
    =>
    pConfig(Sigma, Delta, 
             (family (fns2[blist2]) nlist2 blist2 ::= R1) || 
             (family (fns1[blist1]) nlist1 blist1 ::= R3),
             I, O', A'
           )       
    /\ A' == addAssumptions insert(bt, A) nlist1 blist1 
    /\ O' == insert(fam (fns2[blist2]), fam(fns1[blist1]))
    [nonexec]
    .
    
    *** recursion step
    
    crl [gen-same-cases-subst]:
      pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 (when bt --> R2)
                 ;;
                 whenList2
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 (when bt --> R1)
                 ;;
                 whenList1
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 (when bt --> R3)
                 ;;
                 whenList' 
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 (when bt --> R1)
                 ;;
                 whenList1 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( family (fns2[blist2]) nlist2 blist2 ::= R1 ) 
             || 
             ( family (fns1[blist1]) nlist1 blist1 ::= R2),
             I, insert(fam (fns2[blist2]), fam(fns1[blist1])), 
             addAssumptions
            (addAssumptions 
             insert(bt, A) 
             nlist1 blist1)
             nlist2 blist2
           )
    =>
    pConfig(Sigma, Delta, 
             (family (fns2[blist2]) nlist2 blist2 ::= R1) || 
             (family (fns1[blist1]) nlist1 blist1 ::= R3),
             I, O', A'
           )       
    /\ A' == addAssumptions
            (addAssumptions 
             insert(bt, A) 
             nlist1 blist1)
             nlist2 blist2
    /\ O' == insert(fam (fns2[blist2]), fam(fns1[blist1]))
    /\
    pConfig(Sigma, Delta, 
              (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList2
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 whenList1
               ),
               I, O, insert(neg bt, A) 
           )
   => 
   pConfig(Sigma, Delta, 
              (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList'
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 whenList1
               ),
               I, O, A''
           )  
    /\
    A'' == insert(neg bt, A)             
    [nonexec]
    .
    
       ****************************
     **** case substitution
     ****************************
     
     *** diverge if  we diverge on a condition of the branch 
     *** of the family that we read from, and that condition holds for the terms
     
     crl[diverge-case] :
     pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 nf( ( x : T <- read (fns2[tlist]) ) BRL, 
                     R1
                   )
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 whenList1 ;;
                 (when bt --> nf(y : T <- read (fns2[nlist2]), return y))
                 ;;
                 whenList2
               ),
               I, O, A
         ) 
         =>
     pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 nf(q : typeInCtx( fam (fns1[blist1]), A, Delta) <- read (fns1[nlist1]), return q)
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 whenList1 ;;
                 (when bt --> nf(y : T <- read (fns2[nlist2]), return y)
                 )
                 ;;
                 whenList2
               ),
               I, O, A
         ) 
     if addAssumptions
        (addAssumptions A nlist1 blist1)
        nlist2 blist2 |= bt with mapFromLists nlist2 tlist   
        [nonexec]
     .

        
     *** derived rule
     *** NB: q must be specified by the strategy!
     crl [subst-or-diverge] :
     pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 nf( ( x : T <- read (fns2[tlist]) ) BRL, 
                     R1
                   )
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 (when bt --> R2)
                 ;;
                 (whenCond --> 
                  nf(y : T <- read (fns2[nlist2]), return y)
                 )
               ),
               I, O, A
         )
         =>
     pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 (when bt --> R)
                 ;;
                 (whenCond --> 
                  nf(q : T <- read (fns1[nlist1]), return q)
                 )
                
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 (when bt --> R2)
                 ;;
                 (whenCond --> 
                  nf(y : T <- read (fns2[nlist2]), return y)
                 )
               ),
               I, O, A
         )
     if pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 nf( ( x : T <- read (fns2[tlist]) ) BRL, 
                     R1
                   )
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= R2
               ),
               I, O, insert(bt, A)
         )
         => 
         pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 R
               )
                || 
               (family (fns2[blist2]) nlist2 blist2 ::= R2
                 
               ),
               I, O, A'
         )
         /\ A' ==  insert(bt, A)
      [nonexec]
     . 

     **************************************
  *** cases subst
  **************************************
  
  crl [cases-subst-end-otherwise]:
      pConfig(Sigma, Delta, 
               (family (fns1[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 nf( ( x : T <- read (fns2[q]) ) BRL, 
                     R
                   )
               )
                || 
               (family (fns2[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 (otherwise --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family (fns1[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 (otherwise --> R2) 
               )
                || 
               (family (fns2[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 (otherwise --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns2[q] ::= R1 ) 
             || 
             ( fns1[q] ::= nf( (x : T <- read (fns2[q]) ) BRL, R)
             ),
             I, insert(chn (fns2[q]), chn (fns1[q]) ), insert(qidAsTerm q <T natAsTerm n, A)
           )
    =>
    pConfig(Sigma, Delta, 
             (fns2[q] ::= R1) || (fns1[q] ::= R2),
             I, O', A'
           )       
    /\ A' == insert(qidAsTerm q <T natAsTerm n, A)   
    /\ O' ==  insert(chn (fns2[q]), chn (fns1[q]) )
    *** [nonexec]
    .
     
     crl [cases-subst-end-when]:
      pConfig(Sigma, Delta, 
               (family (fns1[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 nf( ( x : T <- read (fns2[q]) ) BRL, 
                     R
                   )
               )
                || 
               (family (fns2[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 (when bt --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family (fns1[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 (when bt --> R2) 
               )
                || 
               (family (fns2[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 (when bt --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns2[q] ::= R1 ) 
             || 
             ( fns1[q] ::= nf( (x : T <- read (fns2[q]) ) BRL, R)
             ),
             I, *** TODO: might need to add fns1 as inputs
             insert(chn (fns2[q]), chn (fns1[q])), 
             insert(qidAsTerm q <T natAsTerm n, insert(bt, A))
           )
    =>
    pConfig(Sigma, Delta, 
             (fns2[q] ::= R1) || (fns1[q] ::= R2),
             I, O', A'
           )       
    /\ A' == insert(qidAsTerm q <T natAsTerm n, insert(bt, A))     
    /\ O' == insert(chn (fns2[q]), chn (fns1[q]))
    *** [nonexec]
    .
     
     
     crl [cases-subst]:
      pConfig(Sigma, Delta, 
               (family (fns1[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 nf( ( x : T <- read (fns2[q]) ) BRL, 
                     R
                   )
               )
                || 
               (family (fns2[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 (when bt --> R1) ;; whenList
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family (fns1[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 (when bt --> R2) 
                 ;;
                 whenList'
               )
                || 
               (family (fns2[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 (when bt --> R1) 
                 ;; 
                 whenList
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns2[q] ::= R1 ) 
             || 
             ( fns1[q] ::= nf( (x : T <- read (fns2[q]) ) BRL, R)
             ),
             I, insert(chn (fns2[q]), chn (fns1[q])), insert(qidAsTerm q <T natAsTerm n, insert(bt, A))
           )
    =>
    pConfig(Sigma, Delta, 
             (fns2[q] ::= R1) || (fns1[q] ::= R2),
             I, O', A'
           )       
    /\ A' == insert(qidAsTerm q <T natAsTerm n, insert(bt, A))     
    /\ O' == insert(chn (fns2[q]), chn (fns1[q]))
    /\
    pConfig(Sigma, Delta, 
              (family (fns1[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 nf( ( x : T <- read (fns2[q]) ) BRL, 
                     R
                   )
               )
                || 
               (family (fns2[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 whenList
               ),
               I, O, insert(neg bt, A) 
           )
   => 
   pConfig(Sigma, Delta, 
              (family (fns1[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 whenList'
               )
                || 
               (family (fns2[bound (natAsTerm n)]) (qidAsTerm q) (bound (natAsTerm n)) ::= 
                 whenList
               ),
               I, O, A''
           )  
    /\
    A'' == insert(neg bt, A)
    .               

    *************************
    *** same cases subst
    *************************
    
    *** ends with otherwise
    
    crl [same-cases-subst-end-otherwise]:
      pConfig(Sigma, Delta, 
               (family (fns1[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 otherwise --> R2
               )
                || 
               (family (fns2[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (otherwise --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family (fns1[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (otherwise --> R3) 
               )
                || 
               (family (fns2[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (otherwise --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns2[q] ::= R1 ) 
             || 
             ( fns1[q] ::= R2),
             I, insert(chn (fns2[q]), chn (fns1[q])), insert(qidAsTerm q <T nt, A)
           )
    =>
    pConfig(Sigma, Delta, 
             (fns2[q] ::= R1) || (fns1[q] ::= R3),
             I, O', A'
           )       
    /\ A' == insert(qidAsTerm q <T nt, A)   
    /\ O' == insert(chn (fns2[q]), chn (fns1[q]))
    [nonexec]
    .
     
    *** ends with when 
     
    crl [same-cases-subst-end-when]:
      pConfig(Sigma, Delta, 
               (family (fns1[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 when bt --> R2
               )
                || 
               (family (fns2[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family (fns1[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R3) 
               )
                || 
               (family (fns2[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns2[q] ::= R1 ) 
             || 
             ( fns1[q] ::= R2),
             I, insert(chn (fns2[q]), chn (fns1[q])), insert(bt, insert(qidAsTerm q <T nt, A))
           )
    =>
    pConfig(Sigma, Delta, 
             (fns2[q] ::= R1) || (fns1[q] ::= R3),
             I, O', A'
           )       
    /\ A' == insert(bt, insert(qidAsTerm q <T nt, A))  
    /\ O' == insert(chn (fns2[q]), chn (fns1[q]))
    [nonexec]
    .
    
    *** recursion step
    
    crl [same-cases-subst]:
      pConfig(Sigma, Delta, 
               (family (fns1[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R2)
                 ;;
                 whenList2
               )
                || 
               (family (fns2[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R1)
                 ;;
                 whenList1
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family (fns1[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R3)
                 ;;
                 whenList' 
               )
                || 
               (family (fns2[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R1)
                 ;;
                 whenList1 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns2[q] ::= R1 ) 
             || 
             ( fns1[q] ::= R2),
             I, insert(chn (fns2[q]), chn (fns1[q])), insert(bt, insert(qidAsTerm q <T nt, A))
           )
    =>
    pConfig(Sigma, Delta, 
             (fns2[q] ::= R1) || (fns1[q] ::= R3),
             I, O', A'
           )       
    /\ A' == insert(bt, insert(qidAsTerm q <T nt, A))   
    /\ O' == insert(chn (fns2[q]), chn (fns1[q]))
    /\
    pConfig(Sigma, Delta, 
              (family (fns1[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 whenList2
               )
                || 
               (family (fns2[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 whenList1
               ),
               I, O, insert(neg bt, A) 
           )
   => 
   pConfig(Sigma, Delta, 
              (family (fns1[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 whenList'
               )
                || 
               (family (fns2[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 whenList1
               ),
               I, O, A''
           )  
    /\
    A'' == insert(neg bt, A)             
    [nonexec]
    .

      *************************
    *** same cases subst family/channel
    *************************
    
    *** ends with otherwise
    
    crl [fc-same-cases-subst-end-otherwise]:
      pConfig(Sigma, Delta, 
               (cn ::= 
                 otherwise --> nf(BRL (x : T <- read (fns[nj])), R )
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (otherwise --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn ::= 
                 (otherwise --> R3) 
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (otherwise --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns[nj] ::= replaceVars(R1, q |-> nj )) 
             || 
             ( cn ::= nf(BRL (x : T <- read (fns[nj])), R )),
             I, insert(chn (fns[nj]), chn cn), insert(nj <T nt, A)
           )
    =>
    pConfig(Sigma, Delta, 
             (fns[q] ::= R') || (cn ::= R3),
             I, O', A'
           )       
    /\ R' == replaceVars(R1, q |-> nj)       
    /\ A' == insert(nj <T nt, A)   
    /\ O' == insert(chn (fns[nj]), chn cn)
    [nonexec]
    .
     
    *** ends with when 
     
    crl [fc-same-cases-subst-end-when]:
      pConfig(Sigma, Delta, 
               (cn ::= 
                 when bt --> nf(BRL (x : T <- read (fns[nj])), R )
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn ::= 
                 (when bt --> R3) 
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns[nj] ::= replaceVars(R1, q |-> nj) ) 
             || 
             ( cn ::= nf(BRL (x : T <- read (fns[nj])), R )),
             I, insert(chn (fns[nj]), chn cn), insert(bt, insert(nj <T nt, A))
           )
    =>
    pConfig(Sigma, Delta, 
             (fns[nj] ::= R') || (cn ::= R3),
             I, O', A'
           )
    /\ R' == replaceVars(R1, q |-> nj)             
    /\ A' == insert(bt, insert(nj <T nt, A))  
    /\ O' == insert(chn (fns[nj]), chn cn)
    [nonexec]
    .
    
    *** recursion step
    
    crl [fc-same-cases-subst]:
      pConfig(Sigma, Delta, 
               (cn ::= 
                 (when bt --> nf(BRL (x : T <- read (fns[nj])), R )
                 )
                 ;;
                 whenList2
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R1)
                 ;;
                 whenList1
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn ::= 
                 (when bt --> R3)
                 ;;
                 whenList' 
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 (when bt --> R1)
                 ;;
                 whenList1 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns[nj] ::= replaceVars(R1, q |-> nj) ) 
             || 
             ( cn ::= nf(BRL (x : T <- read (fns[nj])), R )),
             I, insert(chn (fns[nj]), chn cn), insert(bt, insert(nj <T nt, A))
           )
    =>
    pConfig(Sigma, Delta, 
             (fns[nj] ::= R') || (cn ::= R3),
             I, O', A'
           )       
    /\ R' ==  replaceVars(R1, q |-> nj)      
    /\ A' == insert(bt, insert(nj <T nt, A))   
    /\ O' == insert(chn (fns[nj]), chn cn)
    /\
    pConfig(Sigma, Delta, 
              (cn ::= 
                 whenList2
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 whenList1
               ),
               I, O, insert(neg bt, A) 
           )
   => 
   pConfig(Sigma, Delta, 
              (cn ::= 
                 whenList'
               )
                || 
               (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                 whenList1
               ),
               I, O, A''
           )  
    /\
    A'' == insert(neg bt, A)             
    [nonexec]
    . 

       *********************************
    *** subst on a case
    *********************************
   
    crl [subst-family-case] :
       pConfig(Sigma, Delta, 
               (family (fns1[bound nt1]) (qidAsTerm i) (bound nt1) ::= cases) || 
               (family (fns2[bound nt2]) (qidAsTerm i) (bound nt2) ::= 
                whenList1 ;;
                (when bt --> nf((x : T <- read (fns1[nj]) ) BRL, R)
                ) ;;
                whenList2), I, O, A)
       =>    
       pConfig(Sigma, Delta, 
               (family (fns1[bound nt1]) (qidAsTerm i) (bound nt1) ::= cases) || 
               (family (fns2[bound nt2]) (qidAsTerm i) (bound nt2) ::= 
                whenList1 ;;
                (when bt --> R'
                ) ;;
                whenList2), I, O, A)
       if 
       pConfig(Sigma, Delta, 
               (family (fns1[bound nt1]) (qidAsTerm i) (bound nt1) ::= cases) || 
               (fns2[i] ::= nf((x : T <- read (fns1[nj]) ) BRL, R)), 
               insert(fam (fns2[bound nt2]), I), 
                *** because we could read fns2[0] or fns2[i - 1]
               O, insert(qidAsTerm i <T nt2, insert(bt, A) )
              )
      =>
      pConfig(Sigma, Delta, 
               (family (fns1[bound nt]) (qidAsTerm i) (bound nt1) ::= cases) || 
               (fns2[i] ::= R'), 
               I', O, A')
     /\
     I' == insert(fam (fns2[bound nt2]), I)
     /\
     A' == insert(qidAsTerm i <T nt2, insert(bt, A))
    
    .
      
   *** same rule for families with three indices
   
    crl [subst-family-case-three] :
       pConfig(Sigma, Delta, 
               (family (fns1[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q')(qidAsTerm q'')) (bd1 bd2 bd3) ::= cases) || 
               (family (fns2[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q')(qidAsTerm q'')) (bd1 bd2 bd3) ::= 
                whenList1 ;;
                (when bt --> nf((x : T <- read (fns1[t1 t2 t3]) ) BRL, R)
                ) ;;
                whenList2), I, O, A)
       =>    
       pConfig(Sigma, Delta, 
               (family (fns1[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q')(qidAsTerm q'')) (bd1 bd2 bd3) ::= cases) || 
               (family (fns2[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q')(qidAsTerm q'')) (bd1 bd2 bd3) ::= 
                whenList1 ;;
                (when bt --> R'
                ) ;;
                whenList2)
               , I, O, A)
       if          
       pConfig(Sigma, Delta, 
               (family (fns1[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q')(qidAsTerm q'')) (bd1 bd2 bd3) ::= cases) || 
               (family (fns2[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q')(qidAsTerm q'')) (bd1 bd2 bd3) ::= 
                  nf((x : T <- read (fns1[t1 t2 t3]) ) BRL, R)
               ), 
               I, *** TODO important and C2 as inputs, but outdated rule!
               (fam (fns1[bd1 bd2 bd3]), fam (fns2[bd1 bd2 bd3])), 
               ( insert(bt, A), addAssumptions A ((qidAsTerm q) (qidAsTerm q')(qidAsTerm q'')) (bd1 bd2 bd3) )
              )
      =>
      pConfig(Sigma, Delta, 
               (family (fns1[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q')(qidAsTerm q'')) (bd1 bd2 bd3) ::= cases) || 
               (family (fns2[bd1 bd2 bd3]) ((qidAsTerm q) (qidAsTerm q')(qidAsTerm q'')) (bd1 bd2 bd3) ::= R'), 
               I, O', A')
     /\
     O' == (fam (fns1[bd1 bd2 bd3]), fam (fns2[bd1 bd2 bd3]))
     /\
     A' == ( insert(bt, A), addAssumptions A ((qidAsTerm q) (qidAsTerm q')(qidAsTerm q'')) (bd1 bd2 bd3) )
    .  
    
   var ntlist : List{NatTerm} . 
    
   *** generic version
       crl [subst-family-case-generic] :
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= cases) || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                whenList1 ;;
                (when bt --> nf((x : T <- read (fns1[ntlist]) ) BRL, R)
                ) ;;
                whenList2), I, O, A)
       =>    
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= cases) || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                whenList1 ;;
                (when bt --> R'
                ) ;;
                whenList2)
               , I, O, A)
       if          
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= cases) || 
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 nf((x : T <- read (fns1[ntlist]) ) BRL, R)), 
               (I, fam(fns2[blist2])),
               (fam (fns1[blist1]), fam (fns2[blist2])), 
               ( insert(bt, A), addAssumptions A nlist2 blist2 )
              )
      =>
      pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= cases) || 
               (family (fns2[blist2]) nlist2 blist2 ::= R'), 
               I', O', A')
     /\
     I' ==  (I, fam(fns2[blist2])) 
     /\
     O' == (fam (fns1[blist1]),fam (fns2[blist2]))
     /\
     A' == ( insert(bt, A), addAssumptions A nlist2 blist2 )
    . 

     *** same rules for channels
   
   *** subst on a branch
      crl [subst-channel-case-channel] :
       pConfig(Sigma, Delta, 
               (cn1 ::= cases) || 
               (cn2 ::= 
                whenList1 ;;
                (when bt --> nf((x : T <- read cn1 ) BRL, R)
                ) ;;
                whenList2), I, O, A)
       =>    
       pConfig(Sigma, Delta, 
               (cn1 ::= cases) || 
               (cn2 ::= 
                whenList1 ;;
                (when bt --> R'
                ) ;;
                whenList2), I, O, A)
       if 
       pConfig(Sigma, Delta, 
               (cn1 ::= cases) || 
               (cn2 ::= nf((x : T <- read cn1 ) BRL, R)), 
               I, O, (A, bt)
              )
      =>
      pConfig(Sigma, Delta, 
               (cn1 ::= cases) || 
               (cn ::= R'), 
               I, O, A')
     /\
     A' == (A, bt)
    .  
   
   crl [subst-channel-case] :
       pConfig(Sigma, Delta, 
               (family (fns1[bound nt1]) (qidAsTerm i) (bound nt1) ::= cases) || 
               (cn ::= 
                whenList1 ;;
                (when bt --> nf((x : T <- read (fns1[nj]) ) BRL, R)
                ) ;;
                whenList2), I, O, A)
       =>    
       pConfig(Sigma, Delta, 
               (family (fns1[bound nt1]) (qidAsTerm i) (bound nt1) ::= cases) || 
               (cn ::= 
                whenList1 ;;
                (when bt --> R'
                ) ;;
                whenList2), I, O, A)
       if 
       pConfig(Sigma, Delta, 
               (family (fns1[bound nt1]) (qidAsTerm i) (bound nt1) ::= cases) || 
               (cn ::= nf((x : T <- read (fns1[nj]) ) BRL, R)), 
               insert( chn cn, I), O, insert(bt, A)
              )
      =>
      pConfig(Sigma, Delta, 
               (family (fns1[bound nt1]) (qidAsTerm i) (bound nt1) ::= cases) || 
               (cn ::= R'), 
               I', O, A')
     /\
     I' == insert( chn cn, I)
     /\
     A' == insert(bt, A)
    .   

       *** select a case for a channel and do the substitution
    
    crl [select-case-subst] :
       pConfig(Sigma, Delta, 
               (cn1 ::= whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               (cn2 ::= nf((x : T <- read cn1) BRL, R2)),
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               (cn1 ::= whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               (cn2 ::= R'),
               I, O, A)
      if A |= bt with empty
      /\
         pConfig(Sigma, Delta, 
               (cn1 ::= R1)
               ||
               (cn2 ::= nf((x : T <- read cn1) BRL, R2)),
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               (cn1 ::= R1)
               ||
               (cn2 ::= R'),
               I, O, A)      
    .

 *** select a case for a channel and do the substitution
    
    crl [select-case-subst-family] :
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 nf((x : T <- read (fns1[tlist])) BRL, R2)),
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               (family (fns2[blist2]) nlist2 blist2 ::= R'),
               I, O, A)
      if *** A |= bt with empty
         addAssumptions A nlist2 blist2 |= bt with (mapFromLists nlist1 tlist)
      /\
         pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= R1)
               ||
               (family (fns2[blist2]) nlist2 blist2 ::= 
                nf((x : T <- read (fns1[tlist])) BRL, R2)),
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= R1)
               ||
               (family (fns2[blist2]) nlist2 blist2 ::= R'),
               I, O, A)      
    .
    
    var P' : Protocol . 
    
      crl [select-case-family-p] :
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList1 ;; (when bt --> P1) ;; whenList2)
               ||
               P,
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList1 ;; (when bt --> P1) ;; whenList2)
               ||
               P',
               I, O, A)
      if A |= bt with empty
      /\
         pConfig(Sigma, Delta, 
               P1
               ||
               P,
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               P1
               ||
               P',
               I, O, A)      
    .
    
     crl [select-case-channel-r] :
       pConfig(Sigma, Delta, 
               (cn ::= 
                 whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               P,
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               (cn ::= 
                 whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               P',
               I, O, A)
      if *** for now! A |= bt with empty /\
         pConfig(Sigma, Delta, 
               (cn ::= R1)
               ||
               P,
               I, O, (A, bt))
       =>       
       pConfig(Sigma, Delta, 
               (cn ::= R1)
               ||
               P',
               I, O, A') 
      /\
      A' == (A, bt)              
    .
    
    crl [select-case-family-r] :
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               P,
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               P',
               I, O, A)
      if addAssumptions A nlist1 blist1 |= bt with empty
      /\
         pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= R1)
               ||
               P,
               I, O, (A, bt))
       =>       
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= R1)
               ||
               P',
               I, O, A') 
      /\
      A' == (A, bt)              
    .
    
     crl [select-case-subst-family-p] :
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList1 ;; (when bt --> P1) ;; whenList2)
               ||
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 cases),
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList1 ;; (when bt --> P1) ;; whenList2)
               ||
               (family (fns2[blist2]) nlist2 blist2 ::= cases'),
               I, O, A)
      if *** was A |= bt with empty
         addAssumptions A nlist2 blist2 |= bt with empty
      /\
         pConfig(Sigma, Delta, 
               P1
               ||
               (family (fns2[blist2]) nlist2 blist2 ::= cases),
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               P1
               ||
               (family (fns2[blist2]) nlist2 blist2 ::= cases'),
               I, O, A)      
    .
    
    crl [select-case-subst-family-r] :
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               (family (fns2[blist2]) nlist2 blist2 ::= 
                 cases),
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               (family (fns2[blist2]) nlist2 blist2 ::= cases'),
               I, O, A)
      if *** was A |= bt with empty
        *** NEW!  addAssumptions A nlist2 blist2 |= bt with empty
      *** /\
        pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= R1)
               ||
               (family (fns2[blist2]) nlist2 blist2 ::= cases),
               I, O, (A, bt))
       =>       
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= R1)
               ||
               (family (fns2[blist2]) nlist2 blist2 ::= cases'),
               I, O, A')
               /\     
               A' == insert(bt, A)
    .
    
       crl [select-case-subst-family-r-gen] :
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               (cn2 ::= nf((x : T <- read (fns1[tlist])) BRL, R2)),
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= 
                 whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               P',
               I, O, A)
      if *** Was: A |= bt with (mapFromLists nlist1 tlist)
         *** addAssumptions A tlist blist1 |= bt with empty
         *** /\
         pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= R1)
               ||
               (cn2 ::= nf((x : T <- read (fns1[tlist])) BRL, R2)),
               I, O, (A, bt))
       =>       
       pConfig(Sigma, Delta, 
               (family (fns1[blist1]) nlist1 blist1 ::= R1)
               ||
               P',
               I, O, A')
               /\     
               A' == insert(bt, A)
    .

***(    
     crl [select-case-subst-channel-r-gen] :
       pConfig(Sigma, Delta, 
               (cn1 ::= 
                 whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               (cn2 ::= nf((x : T <- read (fns1[tlist])) BRL, R2)),
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               (cn1 ::= 
                 whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               P',
               I, O, A)
      if A |= bt with (mapFromLists nlist1 tlist)
         *** addAssumptions A tlist blist1 |= bt with empty
      /\
         pConfig(Sigma, Delta, 
               (cn1 ::= R1)
               ||
               (cn2 ::= nf((x : T <- read (fns1[tlist])) BRL, R2)),
               I, O, (A, bt))
       =>       
       pConfig(Sigma, Delta, 
               (cn1 ::= R1)
               ||
               P',
               I, O, A')
               /\     
               A' == insert(bt, A)
    .
    )

      *** case distinction for family with protocols on cases
     
     crl [CASE-DISTINCTION-one] :
     pConfig (Sigma, Delta, 
               P || family (fns[blist]) nlist (blist) ::= 
                 ((when bt --> aP1) ;; whenList),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || family (fns[blist]) nlist (blist) ::= 
               ((when bt --> aP2) ;; whenList'),
               I, O, A) 
     if 
     *** was pConfig(Sigma, Delta, P || aP1, insert(fam (fns[blist]), I), O, insert(bt, A))
     pConfig(Sigma, Delta, P || aP1, I, O, insert(bt, A))
     =>
     pConfig(Sigma, Delta, P || aP2, I, O, A')
     /\
     A' == insert(bt, A)
     *** /\
     *** I' == insert(fam (fns[blist]), I)
     /\
     pConfig (Sigma, Delta, 
               P || family (fns[blist]) nlist (blist) ::= whenList,
               I, O, insert(neg bt, A)) 
     =>
     pConfig(Sigma, Delta, 
              P || family (fns[blist]) nlist (blist) ::= whenList',
               I, O, A'')
     /\
     A'' == insert(neg bt, A)
     .

    crl [CASE-DISTINCTION-one-end] :
     pConfig (Sigma, Delta, 
               P || family (fns[blist]) nlist (blist) ::= (whenCond --> aP1),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || family (fns[blist]) nlist (blist) ::= (whenCond --> aP2),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || aP1, insert(fam (fns[blist]), I), O, 
             (whenCondToBoolTerm whenCond, A)) 
     =>
     pConfig(Sigma, Delta, P || aP2, I', O, A')            
     /\
     I' == insert(fam (fns[blist]), I)
     /\
     A' == (whenCondToBoolTerm whenCond, A)
     .

   *** congruence for cases TODO: remove, duplicates cong-whenlist-R
     *** TODO: might need it for otherwise too?
    
     crl [cong-cases-reaction] :
      pConfig(Sigma, Delta, cn ::= (whenList1 ;; (when bt --> R1) ;; whenList2), I, O, A)
      =>
      pConfig(Sigma, Delta, cn ::= (whenList1 ;; (when bt --> R2) ;; whenList2), I, O, A)
      if 
      pConfig(Sigma, Delta, cn ::= R1, I, O, insert(bt, A))
      =>
      pConfig(Sigma, Delta, cn ::= R2, I, O, A')
      /\
      A' == insert(bt, A)
     . 
     
  *** crl [CASE-DISTINCTION-one-end] :
  ***    pConfig (Sigma, Delta, 
  ***              P || family (fns[blist]) nlist (blist) ::= (otherwise --> aP1),
  ***              I, O, A)
  ***    => 
  ***    pConfig(Sigma, Delta, 
  ***             P || family (fns[blist]) nlist (blist) ::= (otherwise --> aP2),
  ***              I, O, A) 
  ***    if 
  ***    pConfig(Sigma, Delta, P || aP1, insert(fam (fns[blist]), I), O, A) 
  ***            *** A already has all negated conditions
  ***    =>
  ***    pConfig(Sigma, Delta, P || aP2, I', O, A)            
  ***    /\
  ***    I' == insert(fam (fns[blist]), I)
  ***    .
     
  ***    crl [CASE-DISTINCTION-one-end-when] :
  ***    pConfig (Sigma, Delta, 
  ***              P || family (fns[blist]) nlist (blist) ::= (when bt --> aP1),
  ***              I, O, A)
  ***    => 
  ***    pConfig(Sigma, Delta, 
  ***             P || family (fns[blist]) nlist (blist) ::= (when bt --> aP2),
  ***              I, O, A) 
  ***    if 
  ***    pConfig(Sigma, Delta, P || aP1, insert(fam (fns[blist]), I), O, insert(bt, A)) 
  ***    =>
  ***    pConfig(Sigma, Delta, P || aP2, I', O, A')            
  ***    /\
  ***    I' == insert(fam (fns[blist]), I)
  ***    /\
  ***    A' == insert(bt, A)
  ***    .
     
   *** case distinction for families with reactions on cases
     crl [CASE-DISTINCTION-one-R] :
     pConfig (Sigma, Delta, 
               P || family (fns[blist]) nlist (blist) ::= ((when bt --> R1) ;; whenList),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || family (fns[blist]) nlist (blist) ::= ((when bt --> R2) ;; whenList'),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || family (fns[blist]) nlist (blist) ::= R1, 
             (fam (fns[blist]), I), O, (A, bt))
     =>
     pConfig(Sigma, Delta, P || family (fns[blist]) nlist (blist) ::= R2, I', O, A')
     /\
     A' == (A, bt)
     /\ 
     I' == (fam (fns[blist]), I)
     /\
     pConfig (Sigma, Delta, 
               P || family (fns[blist]) nlist (blist) ::= whenList,
               I, O, (neg bt, A)) 
     =>
     pConfig(Sigma, Delta, 
              P || family (fns[blist]) nlist (blist) ::= whenList',
               I, O, A'')
     /\
     A'' == (neg bt, A) 
     . 

     crl [CASE-DISTINCTION-one-R-end] :
     pConfig (Sigma, Delta, 
               P || family (fns[blist]) nlist (blist) ::= (whenCond --> R1),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || family (fns[blist]) nlist (blist) ::= (whenCond --> R2),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || family (fns[blist]) nlist (blist) ::= R1, 
             insert(fam (fns[blist]), I), O, (whenCondToBoolTerm whenCond, A)) 
       *** A already has all negated conditions
     =>
     pConfig(Sigma, Delta, P || family (fns[blist]) nlist (blist) ::= R2, I', O, A')            
     /\
     I' == insert(fam (fns[blist]), I)
     /\ 
     A' == (whenCondToBoolTerm whenCond, A) 
     .  
               
    ***  crl [CASE-DISTINCTION-one-R-end] :
    ***  pConfig (Sigma, Delta, 
    ***            P || family (fns[blist]) nlist (blist) ::= (otherwise --> R1),
    ***            I, O, A)
    ***  => 
    ***  pConfig(Sigma, Delta, 
    ***           P || family (fns[blist]) nlist (blist) ::= (otherwise --> R2),
    ***            I, O, A) 
    ***  if 
    ***  pConfig(Sigma, Delta, P || family (fns[blist]) nlist (blist) ::= R1, 
    ***          insert(fam (fns[blist]), I), O, A)
    ***    *** A already has all negated conditions
    ***  =>
    ***  pConfig(Sigma, Delta, P || family (fns[blist]) nlist (blist) ::= R2, I', O, A)            
    ***  /\
    ***  I' == insert(fam (fns[blist]), I)
    ***  .
     
    ***  crl [CASE-DISTINCTION-one-R-end-when] :
    ***  pConfig (Sigma, Delta, 
    ***            P || family (fns[blist]) nlist (blist) ::= (when bt --> R1),
    ***            I, O, A)
    ***  => 
    ***  pConfig(Sigma, Delta, 
    ***           P || family (fns[blist]) nlist (blist) ::= (when bt --> R2),
    ***            I, O, A) 
    ***  if 
    ***  pConfig(Sigma, Delta, P || family (fns[blist]) nlist (blist) ::= R1, 
    ***          insert(fam (fns[blist]), I), O, insert(bt, A)) 
    ***    *** A already has all negated conditions
    ***  =>
    ***  pConfig(Sigma, Delta, P || family (fns[blist]) nlist (blist) ::= R2, I', O, A')            
    ***  /\
    ***  I' == insert(fam (fns[blist]), I)
    ***  /\
    ***  A' == insert(bt, A)
    ***  . 

   *** case distinction for channels with reactions on cases
     crl [CASE-DISTINCTION-channel] :
     pConfig (Sigma, Delta, 
               P || cn ::= ((when bt --> R1) ;; whenList),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || cn ::= ((when bt --> R2) ;; whenList'),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || cn ::= R1, 
             I, O, insert(bt, A))
     =>
     pConfig(Sigma, Delta, P || cn ::= R2, I, O, A')
     /\
     A' == insert(bt, A)
     /\
     pConfig (Sigma, Delta, 
               P || cn ::= whenList,
               I, O, insert(neg bt, A)) 
     =>
     pConfig(Sigma, Delta, 
              P || cn ::= whenList',
               I, O, A'')
     /\
     A'' == insert(neg bt, A) 
     .   

     crl [CASE-DISTINCTION-channel-end] :
     pConfig (Sigma, Delta, 
               P || cn ::= (whenCond --> R1),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || cn ::= (whenCond --> R2),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || cn ::= R1, 
             I, O, (whenCondToBoolTerm whenCond, A)) 
       *** A already has all negated conditions
     =>
     pConfig(Sigma, Delta, P || cn ::= R2, I, O, A')
     /\ 
     A' == (whenCondToBoolTerm whenCond, A)            
     . 

    ***  crl [CASE-DISTINCTION-channel-end] :
    ***  pConfig (Sigma, Delta, 
    ***            P || cn ::= (otherwise --> R1),
    ***            I, O, A)
    ***  => 
    ***  pConfig(Sigma, Delta, 
    ***           P || cn ::= (otherwise --> R2),
    ***            I, O, A) 
    ***  if 
    ***  pConfig(Sigma, Delta, P || cn ::= R1, 
    ***          I, O, A) 
    ***    *** A already has all negated conditions
    ***  =>
    ***  pConfig(Sigma, Delta, P || cn ::= R2, I, O, A)            
    ***  .
     
    ***  crl [CASE-DISTINCTION-channel-end-when] :
    ***  pConfig (Sigma, Delta, 
    ***            P || cn ::= (when bt --> R1),
    ***            I, O, A)
    ***  => 
    ***  pConfig(Sigma, Delta, 
    ***           P || cn ::= (when bt --> R2),
    ***            I, O, A) 
    ***  if 
    ***  pConfig(Sigma, Delta, P || cn ::= R1, 
    ***          I, O, insert(bt, A)) 
    ***    *** A already has all negated conditions
    ***  =>
    ***  pConfig(Sigma, Delta, P || cn ::= R2, I, O, A')            
    ***  /\
    ***  A' == insert(bt, A)
    ***  .
     
    var ltq' : TypedCNameList .
    
  *** apply a rule on a branch of a family
 crl [select-branch-family-p] :
 pConfig(Sigma, Delta1, 
               newNF(ltq, 
               P || 
               (family (fns[blist]) nlist blist ::= 
                whenList1 ;;
                (when bt --> P1) ;;
                whenList2)),
                I, O1, A)
 =>
 pConfig(Sigma, Delta2, 
               newNF(ltq', 
               P || 
               (family (fns[blist]) nlist blist ::= 
                whenList1 ;;
                (when bt --> P2) ;;
                whenList2)),
                I, O2, A)
 if 
  pConfig(Sigma, Delta1, newNF(ltq, P || P1), I, O1, (A, bt)) 
  =>
  pConfig(Sigma, Delta2, newNF(ltq', P || P2), I, O2, A')
  /\
  A' == (A, bt)
  /\
     Delta1 equiv Delta2 
     /\ 
     O1 equiv O2
.    

 *** can't call it in a strategy because these aren't higher order
 *** the frontend will take care of this
 crl [select-branch-family-r] :  
 pConfig(Sigma, Delta, 
               P || 
               (family (fns[blist])nlist blist ::= 
                whenList1 ;;
                (when bt --> R1) ;;
                whenList2),
                I, O, A)
 =>
 pConfig(Sigma, Delta, 
               P || 
               (family (fns[blist])nlist blist ::= 
                whenList1 ;;
                (when bt --> R2) ;;
                whenList2),
                I, O, A)
 if 
  pConfig(Sigma, Delta, P || (family (fns[blist])nlist blist ::= R1), I, O, (A, bt)) 
  =>
  pConfig(Sigma, Delta, P || (family (fns[blist])nlist blist ::= R2), I, O, A')
  /\
  A' == (A, bt)
 .  
 
 crl [select-branch-channel-r] :  
 pConfig(Sigma, Delta, 
               P || 
               (cn ::= 
                whenList1 ;;
                (when bt --> R1) ;;
                whenList2),
                I, O, A)
 =>
 pConfig(Sigma, Delta, 
               P || 
               (cn ::= 
                whenList1 ;;
                (when bt --> R2) ;;
                whenList2),
                I, O, A)
 if 
  pConfig(Sigma, Delta, P || (cn ::= R1), I, O, insert(bt, A)) 
  =>
  pConfig(Sigma, Delta, P || (cn ::= R2), I, O, A')
  /\
  A' == insert(bt, A)
 .             

      *** induction
 
     var k n2 : Nat . 
     var R'' : Reaction .
     var qlist : List{NatTerm} .
     *** could be we need k < n in A?
     var idx : Qid .
     
     crl [INDUCTION-P-3] : 
       pConfig(Sigma, Delta, 
               P || family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= P1, 
               I, O, A)
       =>         
       pConfig(Sigma, Delta, 
               P || family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= P2, 
               I, O, A)
       if *** no base, nt = 0 means emptyProtocol
        pConfig(Sigma, Delta, 
               P || (family (fns[bound (qidAsTerm idx)])
                    (qidAsTerm q) (bound (qidAsTerm idx)) ::= (adjustIndex P2 (qidAsTerm idx))) 
                 || substIndex P1 q (qidAsTerm idx) A, 
               I, O, insert(qidAsTerm idx <T nt, A))       
        =>  
        pConfig(Sigma, Delta, 
               P3,
               I, O, A')
        /\
        A' == insert(qidAsTerm idx <T nt, A)
        /\
        isSubprotocolOf (substIndex P2 q (qidAsTerm idx) A) P3
        [nonexec]
        . 
  
   var whenCond1 whenCond2 : WhenCond .

          crl [SINGLE-INDUCTION-new] : 
       pConfig(Sigma, Delta, 
               P || family (cn[blist])qlist blist ::= P1, 
               I, O, A)
       =>         
       pConfig(Sigma, Delta, 
               P || family (cn[blist])qlist blist ::= P2, 
               I, O, A)
       if *** no base, q = 0 means emptyProtocol
        pConfig(Sigma, 
               deltaInd Delta P2 q idx,
               getInductionBase (P || family (cn[blist])qlist blist ::= P1) cn q idx A P2, 
               I, 
               getOutputs(
                  getInductionBase (P || family (cn[blist])qlist blist ::= P1) cn q idx A P2
               ), 
               insert(genBoundCond q (qidAsTerm idx) qlist blist, A))       
        =>  
        pConfig(Sigma, Delta', 
               P3,
               I, O', A')
        /\
        A' == insert(genBoundCond q (qidAsTerm idx) qlist blist, A)
        /\
        isSubprotocolOf (substIndex P2 q (qidAsTerm idx) A) P3
        *** /\
        *** allFixed q qlist blist
        *** add Delta' equiv, O' equiv
        *** add type checking condition 
        *** that P typechecks without P2
        [nonexec]
        .  
        
       crl [SINGLE-INDUCTION-new-R] : 
       pConfig(Sigma, Delta, 
               P || family (cn[blist]) qlist blist ::= cases, 
               I, O, A)
       =>         
       pConfig(Sigma, Delta, 
               P || family (cn[blist]) qlist blist ::= cases', 
               I, O, A)
       if
        pConfig(Sigma, 
               deltaInd Delta (family (cn[blist])qlist blist ::= cases') q idx, 
               P || (adjustIndexP q idx (family (cn[blist])qlist blist ::= cases'))
                 || (substIndex (family (cn[blist])qlist blist ::= cases) q (qidAsTerm idx) A), 
               I, 
               getOutputs(
                 P || 
                 (adjustIndexP q idx (family (cn[blist])qlist blist ::= cases'))
                 || (substIndex (family (cn[blist])qlist blist ::= cases) q (qidAsTerm idx) A)),
               insert(genBoundCond q (qidAsTerm idx) qlist blist, A))       
        =>  
        pConfig(Sigma, Delta', 
               P3,
               I, O', A')
        /\
        A' == insert(genBoundCond q (qidAsTerm idx) qlist blist, A)
        /\
        isSubprotocolOf (substIndex (family (cn[blist])qlist blist ::= cases') q (qidAsTerm idx) A) P3
        *** /\
        *** allFixed q qlist blist
        *** add Delta' equiv, O' equiv
        *** add type checking condition 
        *** that P typechecks without P2       
        [nonexec]
        .  

    
   crl [wrap-channel-family] :  
       *** this should be made more general 
       *** R may depend on q
       *** R could be on the otherwise branch
     pConfig(Sigma, Delta, 
             newNF( ltq { (fns[bound nt]) (qidAsTerm q) : T } < fns[nt + natAsTerm 1] : T >
                   , 
                   P || ( fns[nt + natAsTerm 1] ::= R ) || 
                   family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                     (whenList1 ;; (when bt --> R) ;; whenList2)),
             I, O, A)  
     => 
     pConfig(Sigma, Delta, 
             newNF(ltq { (fns[bound (nt + natAsTerm 1) ]) (qidAsTerm q) : T }
                   , 
                   P || 
                   family (fns[bound (nt + natAsTerm 1)]) (qidAsTerm q) (bound (nt + natAsTerm 1)) ::=  
                     (whenList1 ;; (when bt --> R) ;; whenList2)
                  ),
             I, O, A)  
     if A |= bt with (q |-> (nt + natAsTerm 1))
     .
     
     rl [unwrap-channel-family] :
     pConfig(Sigma, Delta, 
             newNF( ltq { (fns[bound (nt + natAsTerm 1) ]) (qidAsTerm q) : T }
                   , 
                   P  || family (fns[bound (nt + natAsTerm 1)])  
                                 (qidAsTerm q) (bound (nt + natAsTerm 1)) ::= cases),
             I, O, A)  
     => 
     pConfig(Sigma, Delta, 
             newNF( ltq { (fns[bound nt]) (qidAsTerm q) : T } < fns[nt + natAsTerm 1] : T >
                   , 
                   P || 
                   (projectIndex (
                       family (fns[bound (nt + natAsTerm 1)]) (qidAsTerm q) (bound (nt + natAsTerm 1)) ::= cases) 
                   (nt + natAsTerm 1) A empty) ||
                   (family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= cases)),
             I, O, A)  
    .  
    
    rl [wrap-channel-family-new-R] :
     pConfig(Sigma, Delta, 
             newNF( ltq { (fns[bound nt]) (qidAsTerm q) : T } < fns[nt + natAsTerm 1] : T >
                   , 
                   P || ( fns[nt + natAsTerm 1] ::= R1 ) 
                     || family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= R2),
             I, O, A) 
     =>
     pConfig(Sigma, Delta, 
             newNF( ltq { (fns[bound (nt + natAsTerm 1) ]) (qidAsTerm q) : T }
                   , 
                   P || family (fns[bound (nt + natAsTerm 1)])(qidAsTerm q) (bound (nt + natAsTerm 1)) ::= 
                          ((when (qidAsTerm q =T= (nt + natAsTerm 1)) --> R1) ;; 
                            otherwise --> R2)),
             I, O, A)
    .  
    
     rl [wrap-channel-family-new-W] :
     pConfig(Sigma, Delta, 
             newNF( ltq { (fns[bound nt]) (qidAsTerm q) : T } < fns[nt + natAsTerm 1] : T >
                   , 
                   P || ( fns[nt + natAsTerm 1] ::= R1 ) || 
                     family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= whenList),
             I, O, A) 
     =>
     pConfig(Sigma, Delta, 
             newNF( ltq { (fns[bound (nt + natAsTerm 1) ]) (qidAsTerm q) : T }
                   , 
                   P || family (fns[bound (nt + natAsTerm 1)])(qidAsTerm q) (bound (nt + natAsTerm 1)) ::= 
                          ((when (qidAsTerm q =T= (nt + natAsTerm 1)) --> R1) ;; 
                            whenList)),
             I, O, A)
    . 

      crl [merge-cases] : 
    pConfig(Sigma, Delta, 
             family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                         (whenList1 ;;
                          (when (qidAsTerm q =T= nt1) --> R1) ;;
                          whenList2 ;;
                          (otherwise --> R2)
                         ),
             I, O, A) 
     => 
        pConfig(Sigma, Delta, 
             family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                         (whenList1 ;;
                          whenList2 ;;
                          (otherwise --> R2)
                         ),
             I, O, A) 
     if replaceVars(R2, q |-> nt1) == R1 
   .
   
   crl [merge-drop-cases] : 
    pConfig(Sigma, Delta, 
            family (fns[blist]) nlist blist ::= 
                          (when (qidAsTerm q =T= nt1) --> R1) ;;
                          (whenCond --> R2),
                         I, O, A) 
     => 
       pConfig(Sigma, Delta, 
            family (fns[blist]) nlist blist ::= R2,                          
                         I, O, A) 
     if replaceVars(R2, q |-> nt1) == R1 
   .

      ***(                         
    rl [convert-combined] :
       family (fns[blist]) (qidAsTerm q) (bound (natAsTerm n)) ::=
        (
         (when bt --> P1 )
         ;;
         (otherwise --> P2)
        )
       => 
       combine q n bt P1 P2 .
       )
       
   crl [convert-combined-new] :
      pConfig(Sigma, Delta,
       family (fns[blist]) nlist blist ::= cases,
       I, O, A)
       => 
       pConfig(Sigma, Delta,
       newCombine(family (fns[blist]) nlist blist ::= cases),
       I, O, A) 
   if typeOf(Sigma, Delta, I, A, family (fns[blist]) nlist blist ::= cases)    
   .   

   crl [convert-combined-fam] :
      pConfig(Sigma, Delta,
       family (fns[blist]) nlist blist ::= cases,
       I, O, A)
       => 
       pConfig(Sigma, Delta,
        newCombineFam(family (fns[blist]) nlist blist ::= cases),
       I, O, A) 
   if typeOf(Sigma, Delta, I, A, family (fns[blist]) nlist blist ::= cases)    
   . 
   
   crl [convert-combined-new-group] :
      pConfig(Sigma, Delta,
       family (fns[blist]) nlist blist ::= cases,
       I, O, A)
       => 
       pConfig(Sigma, Delta,
       family (fns[blist]) nlist blist ::= newCombine(family (fns[blist]) nlist blist ::= cases),
       I, O, A) 
   if typeOf(Sigma, Delta, I, A, family (fns[blist]) nlist blist ::= cases)    
   .    
       
   rl [drop-group-name] :
     family (fns[blist]) nlist blist ::= P 
     => 
     P . 
  
  ***( auxiliaries for induction on bound   
 
 var cases1 cases2 : Cases .    
     
  op channelsOf : Protocol -> Set{Qid} .
  eq channelsOf(family C (qidAsTerm q) (bound nt) ::= cases) = C .
  eq channelsOf(q ::= cases) = q .       
  eq channelsOf(q[nt] ::= cases) = q . 
  eq channelsOf(P1 || P2) = union(channelsOf(P1), channelsOf(P2)) .   
  op validForFamily___ : Cases Protocol Set{BoolTerm} -> Bool .
  eq validForFamily cases2 (family (fns[blist])(qidAsTerm q) (bound nt) ::= cases1) A =
     (projectIndex (family (fns[blist])(qidAsTerm q) (bound (nt ++ 1)) ::= cases1) (nt ++ 1) A empty)
     ==
     (fns[nt ++ 1] ::= cases2)
 . 
 ) 

    rl [merge-cases-when] : 
    pConfig(Sigma, Delta, 
             newNF( ltq { (fns[blist]) nlist : T }
                   , 
                   P || family (fns[blist]) nlist blist ::= 
                          (whenCond1 --> R) ;;
                          (whenCond2 --> R)),
             I, O, A) 
     => 
        pConfig(Sigma, Delta, 
             newNF( ltq { (fns[blist]) nlist : T }
                   , 
                   P || family (fns[blist]) nlist blist ::= R),
             I, O, A) 
   .
     
  rl [merge-cases-channel] : 
    pConfig(Sigma, Delta, 
             newNF( ltq < cn : T >, 
                   P || cn ::= 
                          (whenCond1 --> R) ;;
                          (whenCond2 --> R)),
             I, O, A) 
     => 
        pConfig(Sigma, Delta, 
             newNF( ltq < cn : T >, 
                   P || cn ::= R),
             I, O, A) 
   .    
  
  rl [merge-cases-channel] : 
    pConfig(Sigma, Delta, 
             newNF( ltq < cn : T >, 
                   P || cn ::= 
                          (whenCond1 --> R) ;;
                          (whenCond2 --> R)),
             I, O, A) 
     => 
        pConfig(Sigma, Delta, 
             newNF( ltq < cn : T >, 
                   P || cn ::= R),
             I, O, A) 
   . 

    crl [all-same-cases] :
   pConfig(Sigma, Delta, 
           cn ::= ((whenCond1 --> R) ;; whenList), I, O, A)
   =>         
   pConfig(Sigma, Delta, 
           cn ::= R, I, O, A) 
   if allSameReaction whenList R .
   
   crl [all-same-cases-family] :
   pConfig(Sigma, Delta, 
           family (fns[blist]) nlist blist ::= ((whenCond1 --> R) ;; whenList), I, O, A)
   =>         
   pConfig(Sigma, Delta, 
           family (fns[blist]) nlist blist ::= R, I, O, A) 
   if allSameReaction whenList R .  
   
    crl [all-same-cases-family-p] :
   pConfig(Sigma, Delta, 
           family (fns[blist]) nlist blist ::= ((whenCond1 --> P) ;; whenList), I, O, A)
   =>         
   pConfig(Sigma, Delta, 
           family (fns[blist]) nlist blist ::= P, I, O, A) 
   if allSameProtocol whenList P .

  *** rules for grouping and ungrouping families
      
  op mergeCasesChannels____ : ChannelName WhenList ChannelName WhenList -> WhenList .
  eq mergeCasesChannels cn1 (whenCond --> R1) cn2 (whenCond --> R2) =
     whenCond --> ((cn1 ::= R1) || (cn2 ::= R2)) .
  eq mergeCasesChannels cn1 ((whenCond --> R1) ;; whenList1) 
                        cn2 ((whenCond --> R2) ;; whenList2) =
    (whenCond --> ((cn1 ::= R1) || (cn2 ::= R2)))
    ;;
    mergeCasesChannels cn1 whenList1 cn2 whenList2 .    
  
  rl [group-merge-channels] :
   pConfig(Sigma, Delta, 
   (cn1 ::= whenList1)  ||
   (cn2 ::= whenList2),
   I, O, A)
   =>
   pConfig(Sigma, Delta, 
    family fns[bound natAsTerm 1] qidAsTerm 'i bound natAsTerm 1 ::=
    mergeCasesChannels cn1 whenList1 cn2 whenList2,
   I, O, A)
   [nonexec]
   *** in order to apply the rule, the conditions must fit
   *** impose this via a condition
  .        
  
      
  rl [group-families-new] :
   pConfig( Sigma, Delta, 
           (family (fns1[blist]) nlist (blist) ::= cases) || 
           (family (fns2[blist]) nlist (blist) ::= cases'),
           I, O, A)
   => 
   pConfig( Sigma, Delta, *** don't change context, temporary representation
    family (('Comp[qidAsTerm fns1 qidAsTerm fns2])[blist]) nlist blist ::= 
     ((family (fns1[blist]) nlist (blist) ::= cases) || 
      (family (fns2[blist]) nlist (blist) ::= cases')
     ),
   I, O, A
   )
 .
 
 rl [ungroup-families-new] :
   pConfig( Sigma, Delta,
   family (('Comp[qidAsTerm fns1 qidAsTerm fns2])[blist]) nlist blist ::= 
     ((family (fns1[blist]) nlist (blist) ::= cases) || 
      (family (fns2[blist]) nlist (blist) ::= cases')
     ),
   I, O, A
   )
   => 
   pConfig( Sigma, Delta, 
           (family (fns1[blist]) nlist (blist) ::= cases) || 
           (family (fns2[blist]) nlist (blist) ::= cases'),
           I, O, A)
 .       
 
 rl [group-families] :
   pConfig( Sigma, Delta, 
           P || (family (fns1[bound nt]) (qidAsTerm q) (bound nt) ::= R1) || 
                (family (fns2[bound nt]) (qidAsTerm q) (bound nt) ::= R2),
           I, O, A)
   => 
   pConfig( Sigma, Delta, *** don't change context, temporary representation
   P || family (('Comp[qidAsTerm fns1 qidAsTerm fns2])[bound nt]) (qidAsTerm q) (bound nt) ::= 
     ((fns1[qidAsTerm q] ::= R1) || (fns2[qidAsTerm q] ::= R2)),
   I, O, A
   )
 .
 
 rl [ungroup-families] :
   pConfig( Sigma, Delta,
   P || family (('Comp[qidAsTerm fns1 qidAsTerm fns2])[bound nt]) (qidAsTerm q) (bound nt) ::= 
       ((fns1[qidAsTerm q] ::= R1) || (fns2[qidAsTerm q] ::= R2)),
   I, O, A
   )
   => 
   pConfig( Sigma, Delta, 
           P || (family (fns1[bound nt]) (qidAsTerm q) (bound nt) ::= R1) || 
                (family (fns2[bound nt]) (qidAsTerm q) (bound nt) ::= R2),
           I, O, A)
 . 

  rl [add-same-cases] :
   pConfig(Sigma, Delta, family (fns[blist]) nlist blist ::= R, I, O, A) 
   =>
   pConfig(Sigma, Delta, 
            family (fns[blist]) nlist blist ::= 
              (when bt --> R)
              ;;
              (otherwise --> R), I, O, A) 
 [nonexec]
 . 
 
 rl [replace-var-branch] :
  pConfig(Sigma, Delta, 
           family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                whenList1 
             ;; (when (qidAsTerm q =T= nj) --> R)
             ;; whenList2, I, O, A)
  =>  
  pConfig(Sigma, Delta, 
           family (fns[bound nt]) (qidAsTerm q) (bound nt) ::= 
                whenList1 
             ;; (when (qidAsTerm q =T= nj) --> replaceVars(R, q |-> nj))
             ;; whenList2, I, O, A)
 . 

 *********** until here
  
 var cases1 cases2 : Cases . 
    
 rl [otherwise-to-neg] :
 pConfig(Sigma, Delta, 
            family (fns[blist]) nlist blist ::= 
              (when bt --> cases1)
              ;;
              (otherwise --> cases2), I, O, A) 
 =>
 pConfig(Sigma, Delta, 
            family (fns[blist]) nlist blist ::= 
              (when bt --> cases1)
              ;;
              (when (neg bt) --> cases2), I, O, A)    
 .  
 
 rl [neg-to-otherwise] :
 pConfig(Sigma, Delta, 
            family (fns[blist]) nlist blist ::= 
              (when bt --> cases1)
              ;;
              (when (neg bt) --> cases2), I, O, A) 
 =>
 pConfig(Sigma, Delta, 
            family (fns[blist]) nlist blist ::= 
              (when bt --> cases1)
              ;;
              (otherwise --> cases2), I, O, A)    
 .  
endm 

mod PROTOCOL-EQUALITY is
 protecting PROTOCOL-EQ-FAMILY .

endm 

 
fmod APPROX-EQ-SIZES is 
 protecting PROTOCOL-CONFIG .
 protecting EXPRESSION-TYPING .

 *** wrappers for width and length
  
  sort Width .
  sort Length .
  
  op width_ : Int -> Width [ctor] .
  op length_ : Int -> Length [ctor] .

  var T T1 T2 : IPDLType .
  var x : Qid .
  var f : Qid .
  var exp exp1 exp2 : IPDLExpression .
  var whenCond : WhenCond .
  var whenList : WhenList .
  var blist bdlist : List{Bounds} .
  var nlist ntlist : List{NatTerm} .

  var fn : FamilyName .
  var cn : ChannelName .
  var ns : ChannelName .

  var Sigma : Signature .
  var Delta : ChannelContext .
  var Gamma : TypeContext .
  var R R1 R2 : Reaction .
  var P Q P1 P2 : Protocol .

 var Delta' Delta'' Delta1 Delta2 : ChannelContext .
 var P' Q' : Protocol .
 var I O I' O' I1 O1 O'' : Set{CNameBound} .
 var A A' : Set{BoolTerm} .
 var w w' : Width .
 var l l' : Length .
 var n n' n1 n2 nw nw1 nw2 nw' nl nl1 nl2 nl' : Nat .
 var nt nt1 nt2 nt3 : NatTerm .
 var bt bt1 bt2 bt3 : BoolTerm .
 var d F q q1 q2 q3 : Qid .
 var ltq : TypedCNameList .
 
 var cnmap : CNameMap .

 *** TODO: move
 op revertNF : Reaction -> Reaction .
 eq revertNF(nf( (x : T <- read cn) binds, R ))
  = x : T <- read cn ; revertNF(nf(binds, R)) .
 eq revertNF(nf(emptyBRList, R)) = R . 
 eq revertNF(preNF( (x : T <- read cn) binds, R ))
  = x : T <- read cn ; revertNF(nf(binds, R)) .
 eq revertNF(preNF(emptyBRList, R)) = R . 
 eq revertNF(R) = R [owise] . 
  

 op  sizeIPDLP : Signature ChannelContext Set{BoolTerm} Protocol -> Nat . 
eq  sizeIPDLP(Sigma, Delta, A, emptyProtocol) = 0 .
eq  sizeIPDLP(Sigma, Delta, A, cn ::= R) 
 =  sizeIPDLR(Sigma, Delta, emptyTypeContext, R) + 5 .
eq  sizeIPDLP(Sigma, Delta, A, P1 || P2) 
 =  sizeIPDLP(Sigma, Delta, A, P1) +  sizeIPDLP(Sigma, Delta, A, P2) + 3 .
eq  sizeIPDLP(Sigma, Delta, A, new cn : T in P) =
   5 +  sizeIPDLT(T) +  sizeIPDLP(Sigma, Delta (chn cn :: T), A, P) .
eq  sizeIPDLP(Sigma, Delta, A, newfamily fn nlist blist : T in P) =
   5 +  sizeIPDLT(T) +  sizeIPDLP(Sigma, Delta (fam fn :: T), A, P) .
eq  sizeIPDLP(Sigma, Delta, A, newNF(ltq, P1)) 
 =  sizeIPDLP(Sigma, Delta, A, newNF2New(newNF(ltq, P1))) . 
 *** families with one index  
eq  sizeIPDLP(Sigma, Delta, A, family fn qidAsTerm q bound nt ::= R ) 
 =  sizeIPDLNT(A, nt) *  (sizeIPDLR(Sigma, Delta, emptyTypeContext, R) + 5)  + 
    3 * sizeIPDLNT(A, nt) + 1 .
eq  sizeIPDLP(Sigma, Delta, A, family fn qidAsTerm q bound nt ::= P) 
 =  sizeIPDLNT(A, nt) *  sizeIPDLP(Sigma, Delta, A, P)  + 
    3 * sizeIPDLNT(A, nt) + 1 .
eq  sizeIPDLP(Sigma, Delta, A, family fn qidAsTerm q bound nt ::= whenList) 
 =  sizeIPDLNT(A, nt) * sizeIPDLW(Sigma, Delta, A, whenList)  + 
    3 * sizeIPDLNT(A, nt) + 1 .
*** families with two indices
eq  sizeIPDLP(Sigma, Delta, A, family fn qidAsTerm q1 qidAsTerm q2 bound nt1 bound nt2 ::= R ) 
 =  sizeIPDLNT(A, nt1) * ( 
    sizeIPDLNT(A, nt2) *  (sizeIPDLR(Sigma, Delta, emptyTypeContext, R) + 5)  + 
    3 * sizeIPDLNT(A, nt2) + 1 
    ) + 
    3 * sizeIPDLNT(A, nt1) + 1 .
eq  sizeIPDLP(Sigma, Delta, A, family fn qidAsTerm q1 qidAsTerm q2 bound nt1 bound nt2 ::= P ) 
 =  sizeIPDLNT(A, nt1) * ( 
    sizeIPDLNT(A, nt2) *  sizeIPDLP(Sigma, Delta, A, P)  + 
    3 * sizeIPDLNT(A, nt2) + 1 
    ) + 
    3 * sizeIPDLNT(A, nt1) + 1 .    
eq  sizeIPDLP(Sigma, Delta, A, family fn qidAsTerm q1 qidAsTerm q2 bound nt1 bound nt2 ::= whenList ) 
 =  sizeIPDLNT(A, nt1) * ( 
    sizeIPDLNT(A, nt2) *  sizeIPDLW(Sigma, Delta, A, whenList)  + 
    3 * sizeIPDLNT(A, nt2) + 1 
    ) + 
    3 * sizeIPDLNT(A, nt1) + 1 .    
    
*** families with three indices
eq  sizeIPDLP(Sigma, Delta, A, 
     family fn qidAsTerm q1 qidAsTerm q2 qidAsTerm q3 bound nt1 bound nt2 bound nt3 ::= R ) 
 =  sizeIPDLNT(A, nt1) * ( 
    sizeIPDLNT(A, nt2) * ( 
    sizeIPDLNT(A, nt3) *  (sizeIPDLR(Sigma, Delta, emptyTypeContext, R) + 5)  + 
    3 * sizeIPDLNT(A, nt3) + 1 
    ) + 
    3 * sizeIPDLNT(A, nt2) + 1 ) + 
    3 * sizeIPDLNT(A, nt1) + 1 .
eq  sizeIPDLP(Sigma, Delta, A, 
      family fn qidAsTerm q1 qidAsTerm q2 qidAsTerm q3 bound nt1 bound nt2 bound nt3 ::= P ) 
 =  sizeIPDLNT(A, nt1) * ( 
    sizeIPDLNT(A, nt2) * ( 
    sizeIPDLNT(A, nt3) *  sizeIPDLP(Sigma, Delta, A, P)  + 
    3 * sizeIPDLNT(A, nt3) + 1 
    ) + 
    3 * sizeIPDLNT(A, nt2) + 1 ) + 
    3 * sizeIPDLNT(A, nt1) + 1 .    
eq  sizeIPDLP(Sigma, Delta, A, 
     family fn qidAsTerm q1 qidAsTerm q2 qidAsTerm q3 bound nt1 bound nt2 bound nt3 ::= whenList ) 
 =  sizeIPDLNT(A, nt1) * ( 
    sizeIPDLNT(A, nt2) * ( 
    sizeIPDLNT(A, nt3) *  sizeIPDLW(Sigma, Delta, A, whenList)  + 
    3 * sizeIPDLNT(A, nt3) + 1 
    ) + 
    3 * sizeIPDLNT(A, nt2) + 1 ) + 
    3 * sizeIPDLNT(A, nt1) + 1 . 

*** families with two indices, dep bound
eq  sizeIPDLP(Sigma, Delta, A, family fn qidAsTerm q1 qidAsTerm q2 bound nt1 dependentBound F ::= R ) 
 =  sizeIPDLNT(A, nt1) * ( 
    maxValue(F, nt1) *  (sizeIPDLR(Sigma, Delta, emptyTypeContext, R) + 5)  + 
    3 * maxValue(F, nt1)  + 1 
    ) + 
    3 * sizeIPDLNT(A, nt1) + 1 .
eq  sizeIPDLP(Sigma, Delta, A, family fn qidAsTerm q1 qidAsTerm q2 bound nt1 dependentBound F ::= P ) 
 =  sizeIPDLNT(A, nt1) * ( 
    maxValue(F, nt1) *  sizeIPDLP(Sigma, Delta, A, P)  + 
    3 * maxValue(F, nt1)  + 1 
    ) + 
    3 * sizeIPDLNT(A, nt1) + 1 .    
eq  sizeIPDLP(Sigma, Delta, A, family fn qidAsTerm q1 qidAsTerm q2 bound nt1 dependentBound F ::= whenList ) 
 =  sizeIPDLNT(A, nt1) * ( 
    maxValue(F, nt1) *  sizeIPDLW(Sigma, Delta, A, whenList)  + 
    3 * maxValue(F, nt1)  + 1 
    ) + 
    3 * sizeIPDLNT(A, nt1) + 1 . 
*** families with three indices, dep bound
eq  sizeIPDLP(Sigma, Delta, A, 
     family fn qidAsTerm q1 qidAsTerm q2 qidAsTerm q3 bound nt1 bound nt2 dependentBound F ::= R ) 
 =  sizeIPDLNT(A, nt1) * ( 
    sizeIPDLNT(A, nt2) * ( 
    maxValue(F, nt2) *  (sizeIPDLR(Sigma, Delta, emptyTypeContext, R) + 5)  + 
    3 *  maxValue(F, nt2) + 1 
    ) + 
    3 * sizeIPDLNT(A, nt2) + 1 ) + 
    3 * sizeIPDLNT(A, nt1) + 1 .
eq  sizeIPDLP(Sigma, Delta, A, 
    family fn qidAsTerm q1 qidAsTerm q2 qidAsTerm q3 bound nt1 bound nt2 dependentBound F ::= P ) 
 =  sizeIPDLNT(A, nt1) * ( 
    sizeIPDLNT(A, nt2) * ( 
     maxValue(F, nt2) *  sizeIPDLP(Sigma, Delta, A, P)  + 
    3 *  maxValue(F, nt2) + 1 
    ) + 
    3 * sizeIPDLNT(A, nt2) + 1 ) + 
    3 * sizeIPDLNT(A, nt1) + 1 .    
eq  sizeIPDLP(Sigma, Delta, A, 
    family fn qidAsTerm q1 qidAsTerm q2 qidAsTerm q3 bound nt1 bound nt2 dependentBound F ::= whenList ) 
 =  sizeIPDLNT(A, nt1) * ( 
    sizeIPDLNT(A, nt2) * ( 
     maxValue(F, nt2) *  sizeIPDLW(Sigma, Delta, A, whenList)  + 
    3 *  maxValue(F, nt2) + 1 
    ) + 
    3 * sizeIPDLNT(A, nt2) + 1 ) + 
    3 * sizeIPDLNT(A, nt1) + 1 . 

*** channels with cases    
eq  sizeIPDLP(Sigma, Delta, A, cn ::= whenList) 
 =  sizeIPDLW(Sigma, Delta, A, whenList) + 5 . 
 
*** embedding 
 eq sizeIPDLP(Sigma, Delta, A, embedProtocol(P, F from Delta1 to Delta2 is cnmap)) = 
    sizeIPDLP(Sigma, Delta2, A, P) .  

  
 var binds : BindList .

  *** types
op  sizeIPDLT : IPDLType -> Nat .
eq  sizeIPDLT(typeName 'unit) = 0 .
eq  sizeIPDLT(typeName 'bool) = 1 .
eq  sizeIPDLT(T1 * T2) =  sizeIPDLT(T1) +  sizeIPDLT(T2) .
*** expressions
op  sizeIPDLE : Signature TypeContext IPDLExpression -> Nat .
eq  sizeIPDLE(Sigma , Gamma (x : T), x) =  sizeIPDLT(T) + 5 .
eq  sizeIPDLE(Sigma , Gamma, True) = 3 .
eq  sizeIPDLE(Sigma , Gamma, False) = 3 .
eq  sizeIPDLE(Sigma , Gamma, ()) = 3 .
eq  sizeIPDLE(Sigma (f : T1 ~> T2), Gamma, ap f exp) = 
    sizeIPDLT(T1) +  sizeIPDLT(T2) +  sizeIPDLE(Sigma (f : T1 ~> T2), Gamma, exp) + 5 .
eq  sizeIPDLE(Sigma, Gamma, pair(exp1, exp2)) =  
    sizeIPDLE(Sigma, Gamma, exp1) +  sizeIPDLE(Sigma, Gamma, exp2) .
eq  sizeIPDLE(Sigma, Gamma, fst exp) 
 =  sizeIPDLT(prj1(typeOf(Sigma, Gamma, exp))) +  
    sizeIPDLT(prj2(typeOf(Sigma, Gamma, exp))) +  sizeIPDLE(Sigma, Gamma, exp) + 5 
 . 
eq  sizeIPDLE(Sigma, Gamma, snd exp) 
 =  sizeIPDLT(prj1(typeOf(Sigma, Gamma, exp))) +  
    sizeIPDLT(prj2(typeOf(Sigma, Gamma, exp))) +  sizeIPDLE(Sigma, Gamma, exp) + 5
 .
*** reactions
op  sizeIPDLR : Signature ChannelContext TypeContext Reaction -> Nat .
eq  sizeIPDLR(Sigma, Delta, Gamma, return exp) =  sizeIPDLE(Sigma, Gamma, exp) + 3 .
eq  sizeIPDLR(Sigma (d : T1 ~>> T2), Delta, Gamma, samp (d < exp >)) 
 = 5 +  sizeIPDLT(T1) +  sizeIPDLT(T2) +  sizeIPDLE(Sigma (d : T1 ~>> T2), Gamma, exp) .
eq  sizeIPDLR(Sigma, Delta, Gamma, if exp then R1 else R2) 
 = 5 +  sizeIPDLE(Sigma, Gamma, exp) + 
    sizeIPDLR(Sigma, Delta, Gamma, R1) +
    sizeIPDLR(Sigma, Delta, Gamma, R2) .
eq  sizeIPDLR(Sigma, Delta, Gamma, x : T <- R1 ; R2) 
 = 6 +  sizeIPDLT(T) +  sizeIPDLR(Sigma, Delta, Gamma, R1) +  sizeIPDLR(Sigma, Delta, Gamma (x : T), R2) .
eq  sizeIPDLR(Sigma, Delta (chn cn :: T), Gamma, read cn) =  sizeIPDLT(T) + 6 .
eq  sizeIPDLR(Sigma, Delta (fam (ns[bdlist]) :: T), Gamma, read (ns[ntlist])) =  sizeIPDLT(T) + 6 .
eq  sizeIPDLR(Sigma, Delta, Gamma, nf(binds, R))
 =  sizeIPDLR(Sigma, Delta, Gamma, revertNF(nf(binds, R))) .
eq  sizeIPDLR(Sigma, Delta, Gamma, preNF(binds, R))
 =  sizeIPDLR(Sigma, Delta, Gamma, revertNF(preNF(binds, R))) . 
 
*** underspecified
op maxValue : Qid NatTerm -> Nat . 
*** should compute the max of Q(0) ... Q (eval(nt) - 1)
op eval : Qid NatTerm -> Nat .
*** should compute Q(nt)
op eval : Set{BoolTerm} Qid -> Nat . 
*** should give the value of the variable with name Q

ceq 0 < eval(A, q) = true if A |= natAsTerm 0 <T qidAsTerm q with empty .

op  sizeIPDLNT : Set{BoolTerm} NatTerm -> Nat .
eq  sizeIPDLNT(A, qidAsTerm q) = eval(A, q) .
eq  sizeIPDLNT(A, natAsTerm n) = n .
eq  sizeIPDLNT(A, nt1 + nt2) =  sizeIPDLNT(A, nt1) +  sizeIPDLNT(A, nt2) .
*** eq  sizeIPDLNT(nt1 - nt2) =  sizeIPDLNT(nt1) -  sizeIPDLNT(nt2) .
eq  sizeIPDLNT(A, fun f nt) = eval(f, nt) .

op  sizeIPDLW : Signature ChannelContext Set{BoolTerm} WhenList -> Nat .
eq  sizeIPDLW(Sigma, Delta, A, (whenCond --> R)) =  sizeIPDLR(Sigma, Delta, emptyTypeContext, R) .
eq  sizeIPDLW(Sigma, Delta, A, (whenCond --> P)) =  sizeIPDLP(Sigma, Delta, A, P) .
eq  sizeIPDLW(Sigma, Delta, A, (whenCond --> R) ;; whenList) = 
   defMax(  sizeIPDLR(Sigma, Delta, emptyTypeContext, R), 
           sizeIPDLW(Sigma, Delta, A, whenList)
         ) .
eq  sizeIPDLW(Sigma, Delta, A, (whenCond --> P) ;; whenList) = 
   defMax(  sizeIPDLP(Sigma, Delta, A, P), 
            sizeIPDLW(Sigma, Delta, A, whenList)
         ) .
         
  *** for some reason Maude does not set the max between anything and 0
 *** to that anything, and we need this for a bound, which is a constant
 *** of sort Nat.   

 var anInt anInt1 anInt2 : Int .

 op savedSetCard___ : List{NatTerm} List{Bounds} WhenCond -> Int .

 op defMax : Int Int -> Int [comm] .
 eq defMax(anInt, 0) = anInt .
 eq defMax(0, anInt) = anInt .
 eq defMax(anInt, anInt) = anInt .
 eq defMax(anInt1, anInt2) = max(anInt1, anInt2) [owise] . 

 op _defPlus_ : Int Int -> Int [assoc comm] .
 eq anInt defPlus 0 = anInt .
 eq 0 defPlus anInt = anInt .
 eq anInt1 defPlus anInt2 = anInt1 + anInt2 .

 op _defDiff_ : Int Int -> Int .

 eq (s(n1) + an:Nat) defDiff 1 = n1 + an:Nat .

  op _defTimes_ : Int Int -> Int [assoc comm] .
 eq anInt defTimes 1 = anInt .
 eq 1 defTimes anInt = anInt .
 eq anInt1 defTimes anInt2 = anInt1 * anInt2 .

 *** op pConf2aConf___ : ProtocolConfig Width Length -> ApproxEqConfig .
 *** eq pConf2aConf pConfig(Sigma, Delta, P, I, O, A) w l
 *** = aConfig(Sigma, Delta, P, I, O, A, w, l) .  
 *** don't need it anymore

 eq an:Nat + s(n2) * an:Nat = (n2 + 2) * an:Nat .
 eq s(n1) * an:Nat + s(n2) * an:Nat = (n1 + n2 + 2) * an:Nat .
 eq an:Nat + an:Nat = 2 * an:Nat .

 eq  sizeIPDLT(T) +  sizeIPDLT(T) = 2 *  sizeIPDLT(T) .
 eq n1 *  sizeIPDLT(T) +  sizeIPDLT(T) = (n1 + 1) *  sizeIPDLT(T) .
 eq n1 *  sizeIPDLT(T) +  n2 * sizeIPDLT(T) = (n1 + n2) *  sizeIPDLT(T) .
 eq s(n1) * eval(A, q) + s(n2) * eval(A', q) = (n1 + n2 + 2) * eval(A, q) .
 eq eval(A, q) + s(n2) * eval(A, q) = (n2 + 2) * eval(A, q) .

 eq (n1 + n2) * an:Nat = n1 * an:Nat + n2 * an:Nat .
  
endfm  

fmod APPROX-BOUNDS is
  pr MAP{Qid,Int} .
  pr PROTOCOL .

 sort UnconditionalBound .
 
 op uncondBound_ : Map{Qid,Int} -> UnconditionalBound [ctor] .
 
 op emptyBound : -> UnconditionalBound .
 eq emptyBound = uncondBound empty .
 
 sort ConditionalSingleBound .
 op singleBound__ : WhenCond UnconditionalBound -> ConditionalSingleBound [ctor] .
 
 sort ConditionalBound .
 subsort ConditionalSingleBound < ConditionalBound .
 op __ : ConditionalBound ConditionalBound -> ConditionalBound [assoc] .
 
 sort ProtocolBound .
 subsort ConditionalBound < ProtocolBound .
 subsort UnconditionalBound < ProtocolBound . 
 
 sort FamilyBound .
 op famBound__ : List{Bounds} ProtocolBound -> FamilyBound [ctor] .
 
 sort ComplexityBound . 
 subsort FamilyBound < ComplexityBound .
 subsort ProtocolBound < ComplexityBound .
 
endfm  

fmod  APPROX-CONGR-CONFIG is 
 pr APPROX-EQ-SIZES .
 pr APPROX-BOUNDS .     
  *** the new configuration
  
  sort ApproxCongrConfig .
  
  op aCongrConfig : ProtocolConfig ProtocolBound -> 
                    ApproxCongrConfig [ctor] .

endfm  
 
fmod  APPROX-EQ-CONFIG is 
 pr APPROX-EQ-SIZES .
 pr APPROX-BOUNDS .     
  *** the new configuration
  
  sort ApproxEqConfig .
  
  op aConfig : ProtocolConfig 
               ComplexityBound *** the count
               ComplexityBound *** the context
               -> 
               ApproxEqConfig [ctor] .

  op emptyAConfig : -> ApproxEqConfig .
  eq emptyAConfig = aConfig(eConfig, emptyBound, emptyBound) .

endfm 

mod APPROX-CONGR is
 pr APPROX-CONGR-CONFIG .
 pr PROTOCOL-EQUALITY .
 
  var Sigma : Signature .
 var Delta Delta' Delta'' Delta1 Delta2 : ChannelContext .
 var P Q P' Q' : Protocol .
 var I O I' O' I1 O1 O'' : Set{CNameBound} .
 var A A' A'' : Set{BoolTerm} .
 var w w' : Width .
 var l l' : Length .
 var n n' n1 n2 nw nw1 nw2 nw' nl nl1 nl2 nl' : Int .
 var P1 P2 P1' aP1 aP2 : Protocol .
  var blist : List{Bounds} .
  var nlist : List{NatTerm} .
  var c cn : ChannelName . 
  var q q' x : Qid .
  var ltq : TypedCNameList .
  var bt : BoolTerm .
  var fn : FamilyName .
  var cnbl : List{CNameBound} .
   var T : IPDLType .
  var R R1 R2 : Reaction .
  var BL : BindList .
  var BRL : BRList .
  var QL : List{NatTerm} .
  var pConf pConf' : ProtocolConfig .
  var whenList1 whenList2 : WhenList .
  var whenCond : WhenCond .
  var phi : IPDLEmbedding .
  var ucb : UnconditionalBound .
  var cb1 cb2 : ProtocolBound .
  var f : Map{Qid,Int} .
  
  
    crl [INPUT-UNUSED-APPROX] :
  aCongrConfig(pConfig(Sigma, Delta, P1, I', O, A), cb1)
  =>
  aCongrConfig(pConfig(Sigma, Delta, P2, I', O, A), cb2)
 if 
  aCongrConfig(pConfig(Sigma, Delta, P1, I, O, A), cb1)
  => 
  aCongrConfig(pConfig(Sigma, Delta, P2, I, O, A), cb2)
  /\ 
  I subset I'
  [nonexec]
 .

   crl [EMBED-APPROX] :
    aCongrConfig(pConfig(Sigma, Delta1, P1', I', O', A), cb1 )
    => 
    aCongrConfig(pConfig(Sigma, Delta1, embedProtocol(P2, phi), I', O', A), 
                 cb2)
    if 
    aCongrConfig(pConfig(Sigma, Delta2, P1, I, O, A), cb1)
    =>
    aCongrConfig(pConfig(Sigma, Delta2, P2, I, O, A), cb2 )
    /\
    embedIO(I, phi) subset I'
    /\
    embedIO(O, phi) == O'
    /\
    P1' == embedProtocol(P1, phi)
  [nonexec]
  . 
  
  crl [CONG-COMP-APPROX] :
  aCongrConfig(pConfig(Sigma, Delta, P1 || Q, I, O, A), cb1)
  =>
  aCongrConfig(pConfig(Sigma, Delta', P2 || Q, I, union (O1, getOutputs(Q)), A),
          addValue cb2 (sizeIPDLP(Sigma, Delta,  A, Q) defPlus 3)
         )
 if 
  aCongrConfig(pConfig(Sigma, Delta, P1, union(I, getOutputs(Q)), getOutputs(P1), A),
               cb1)
  => 
  aCongrConfig(pConfig(Sigma, Delta', P2, I1, O1, A), cb2)
  /\ O1 == getOutputs(P2) 
  /\ I1 == union(I, getOutputs(Q))
  /\ typeOf(Sigma, Delta, union(I, getOutputs(P1)), A, Q) 
 .

 op addToMap__ : Map{Qid,Int} Int -> Map{Qid,Int} .
 eq addToMap empty nl2 = empty .
 eq addToMap (q |-> nl1, f) nl2 
  = (q |-> nl1 defPlus nl2, addToMap f nl2) .
 
 op addValue__ : ProtocolBound Int -> ProtocolBound .
 eq addValue (uncondBound f) nl2 = uncondBound (addToMap f nl2) .
 eq addValue (singleBound whenCond ucb) nl2 
  = singleBound whenCond (addValue ucb nl2) .
 eq addValue 
    ((singleBound whenCond ucb) cb1) nl2 = 
     (addValue (singleBound whenCond ucb) nl2 ) 
     (addValue cb1 nl2) .
  
 crl [CONG-NEW-APPROX] :
   aCongrConfig(pConfig(Sigma, Delta, new cn : T in P , I, O, A), cb1)
  =>
   aCongrConfig(pConfig(Sigma, Delta', new cn : T in P' , I, O', A), cb2)
 if 
   aCongrConfig(pConfig(Sigma, Delta (chn cn :: T), P, I, union (chn cn, O), A), 
                emptyBound)
  =>   
  aCongrConfig(pConfig(Sigma, Delta' (chn cn :: T), P', I, (chn cn, O'), A), cb2)
 .  
 
 crl [CONG-NEW-NF-APPROX] :
   aCongrConfig(pConfig(Sigma, Delta, newNF(ltq, P), I, O, A), cb1)
  =>
   aCongrConfig(pConfig(Sigma, diff Delta' (addChannels ltq emptyChannelCtx), 
           newNF(ltq, P') , I, O' \ (chansInList ltq), A), 
           cb2)
 if 
   aCongrConfig(pConfig(Sigma, addChannels ltq Delta, P, I, union(chansInList ltq, O), A),
                emptyBound)
  =>   
   aCongrConfig(pConfig(Sigma, Delta', P', I, O', A), cb2)
  /\ O' equiv union(chansInList ltq, O)
  /\ Delta' equiv addChannels ltq Delta
 .  
  
   crl [APPROX-CASE-DISTINCTION-one] :
     aCongrConfig(pConfig (Sigma, Delta, 
               cn ::= 
                 ((when bt --> aP1) ;; whenList1),
               I, O, A), cb1)
     => 
     aCongrConfig(pConfig(Sigma, Delta, 
              cn ::= 
               ((when bt --> aP2) ;; whenList2),
               I, O, A),
               (singleBound (when bt) ucb) cb2
               )
     if 
     aCongrConfig(pConfig(Sigma, Delta, aP1, I, O, insert(bt, A)), 
                   emptyBound)
     =>
     aCongrConfig(pConfig(Sigma, Delta, aP2, I, O, A'), ucb)
     /\
     A' == insert(bt, A)
     /\
     aCongrConfig(pConfig (Sigma, Delta, 
               cn ::= whenList1,
               I, O, insert(neg bt, A)), emptyBound) 
     =>
     aCongrConfig(pConfig(Sigma, Delta, 
              cn ::= whenList2,
               I, O, A''), cb2)
     /\
     A'' == insert(neg bt, A)
     . 
     
  crl [APPROX-CASE-DISTINCTION-one-end] :
     aCongrConfig(pConfig (Sigma, Delta, 
               cn ::= (whenCond --> aP1),
               I, O, A), cb1)
     => 
     aCongrConfig(pConfig(Sigma, Delta, 
              cn ::= (whenCond --> aP2),
               I, O, A), 
               singleBound whenCond ucb )
     if 
     aCongrConfig(pConfig(Sigma, Delta, aP1, I, O, (whenCondToBoolTerm whenCond, A)), 
         emptyBound )
             *** A already has all negated conditions
     =>
     aCongrConfig(pConfig(Sigma, Delta, aP2, I, O, A'), 
                  ucb)
    /\ A' == (whenCondToBoolTerm whenCond, A)
     .    
 
endm

mod APPROX-EQUALITY is
  protecting PROTOCOL-EQUALITY .
  protecting APPROX-EQ-CONFIG .
  protecting APPROX-CONGR .
    
  var Sigma : Signature .
 var Delta Delta' Delta'' Delta1 Delta2 : ChannelContext .
 var P Q P' Q' : Protocol .
 var I O I' O' I1 O1 O'' : Set{CNameBound} .
 var A A' : Set{BoolTerm} .
 var w w' : Width .
 var l l' : Length .
 var n n' n1 n2 nw nw1 nw2 nw' nl nl1 nl2 nl' : Int .
 var P1 P2 P1' : Protocol .
  var blist : List{Bounds} .
  var nlist : List{NatTerm} .
  var c cn : ChannelName . 
  var q' : Qid .
  var ltq : TypedCNameList .
  var bt : BoolTerm .
  var fn : FamilyName .
  var cnbl : List{CNameBound} .
   var T : Type .
  var R R1 R2 : Reaction .
  var x : Qid .
  var BL : BindList .
  var BRL : BRList .
  var QL : List{NatTerm} .
  var pConf pConf' : ProtocolConfig .
  var whenList1 whenList2 : WhenList .
  var phi : IPDLEmbedding .
  var fns : NameWithScripts .
  var aP1 aP2 : Protocol .
  var whenList whenList' : WhenList .
  var A'' : Set{BoolTerm} .
  var  nt1 nt2 nt3 : NatTerm .
  var i j k : Qid .
  var cb1 cb2 
      countb1 contextb1 
      countb2 contextb2 
      countb contextb : ComplexityBound .
 
 *** the rules
 
 crl [STRICT] :
   aConfig(pConfig(Sigma, Delta, P, I, O, A), cb1, cb2) 
   =>
   aConfig(pConfig(Sigma, Delta', Q, I, O', A), cb1, cb2)
 if
  pConfig(Sigma, Delta, P, I, O, A)
  => 
  pConfig(Sigma, Delta', Q, I, O', A)
 . 
 
 crl [APPROX-CONG] :
   aConfig(pConfig(Sigma, Delta, P1, I, O, A), countb1, contextb1)
   => 
   aConfig(pConfig(Sigma, Delta, P2, I, O, A), 
           updateCount cb1 ,
           cb1
          )
   if 
   aCongrConfig(pConfig(Sigma, Delta, P1, I, O, A), emptyBound)
   => 
   aCongrConfig(pConfig(Sigma, Delta, P2, I, O, A), cb1) 
 .     
    
 var q : Qid .
 var whenCond : WhenCond .
 var f g h f1 g1 f2 g2 : Map{Qid, Int} .
 var ucb : UnconditionalBound .
 var cb : ComplexityBound .
 var cnb : ConditionalBound .
 var pb : ProtocolBound .
 var Q1 : Protocol . 

 op updateCount_ : ProtocolBound -> ComplexityBound .
 eq updateCount (uncondBound (q |-> nl)) = uncondBound (q |-> 1) .
 eq updateCount (singleBound whenCond (uncondBound (q |-> nl))) 
  = singleBound whenCond (uncondBound (q |-> 1)) .
 eq updateCount ((singleBound whenCond ucb) cb2) 
  = (updateCount (singleBound whenCond ucb)) 
    (updateCount cb2) . *** if this doesn't type check, add an aux method!     
  
 crl [SYM-APPROX] :
   aConfig(pConfig(Sigma, Delta, P, I, O, A), countb1, contextb1)
   =>
   aConfig(pConfig(Sigma, Delta1, Q, I, O1, A), countb2, contextb2)
   if
    aConfig(pConfig(Sigma, Delta1, Q, I, O1, A), countb1, contextb1)
   =>
    aConfig(pConfig(Sigma, Delta, P, I, O, A), countb2, contextb2) 
 [nonexec]
 .
 
 crl [TRANS] :
  aConfig(pConfig(Sigma, Delta, P, I, O, A), countb, contextb)
  => 
  aConfig(pConfig(Sigma, Delta'', P2, I, O'', A), 
          pointwiseSum countb1 countb2, pointwiseMax contextb1 contextb2)
 if
  aConfig(pConfig(Sigma, Delta, P, I, O, A), emptyBound, emptyBound)
  => 
  aConfig(pConfig(Sigma, Delta', P1, I, O', A), countb1, contextb1)
  /\ 
  aConfig(pConfig(Sigma, Delta', P1, I, O', A), emptyBound, emptyBound)
  => 
  aConfig(pConfig(Sigma, Delta'', P2, I, O'', A), countb2, contextb2)
 .  
  
 op pointwiseSum__ : ComplexityBound ComplexityBound -> ComplexityBound [comm] .
 eq pointwiseSum (uncondBound empty) cb = cb .
 ceq pointwiseSum (uncondBound (q |-> nl1, f)) 
                  (uncondBound (q |-> nl2, g))
  = uncondBound (q |-> nl1 defPlus nl2, h) 
  if uncondBound h := pointwiseSum (uncondBound f) (uncondBound g) .
 ceq pointwiseSum (uncondBound (q |-> nl1, f))  
                  (uncondBound g)
  = uncondBound (q |-> nl1, h)
  if uncondBound h := pointwiseSum (uncondBound f) (uncondBound g) 
  /\ g[q] == undefined .  
  eq pointwiseSum (singleBound whenCond (uncondBound f)) (uncondBound g) 
   = singleBound whenCond (pointwiseSum (uncondBound f) (uncondBound g)) .
  eq pointwiseSum ((singleBound whenCond (uncondBound f)) cb) (uncondBound g) 
   = (singleBound whenCond (pointwiseSum (uncondBound f) (uncondBound g)))
     pointwiseSum cb (uncondBound g) . 
  eq pointwiseSum (famBound blist cb1) cb2 
   = famBound blist (pointwiseSum cb1 cb2) .                 
  
 op pointwiseMax__ : ComplexityBound ComplexityBound -> ComplexityBound [comm] .
 eq pointwiseMax (uncondBound empty) cb = cb .
 ceq pointwiseMax (uncondBound (q |-> nl1, f))  
                 (uncondBound (q |-> nl2, g))
  = uncondBound (q |-> defMax(nl1, nl2), h)
  if uncondBound h := pointwiseMax (uncondBound f) (uncondBound g) .
 ceq pointwiseMax (uncondBound (q |-> nl1, f))  
                  (uncondBound g)
  = uncondBound (q |-> nl1, h)
  if uncondBound h := pointwiseMax (uncondBound f) (uncondBound g) 
  /\ g[q] == undefined .
  eq pointwiseMax (singleBound whenCond (uncondBound f)) (uncondBound g) 
   = singleBound whenCond (pointwiseMax (uncondBound f) (uncondBound g)) .
  eq pointwiseMax ((singleBound whenCond (uncondBound f)) cb) (uncondBound g) 
   = (singleBound whenCond (pointwiseMax (uncondBound f) (uncondBound g)))
     pointwiseMax cb (uncondBound g) . 
  eq pointwiseMax (famBound blist cb1) cb2 
   = famBound blist (pointwiseMax cb1 cb2) . 
  
 *** derived rules
 
   crl [CONG-COMP-EQ-APPROX] :
  aConfig(pConfig(Sigma, Delta, P1 || Q, I, O, A), 
              countb, contextb)
  =>
  aConfig(pConfig(Sigma, Delta', P2 || Q, I, union (O1, getOutputs(Q)), A),
          pointwiseSum countb countb1,
          sumValue contextb1 (sizeIPDLP(Sigma, Delta,  A, Q) + 3)
  )
 if 
  aConfig(pConfig(Sigma, Delta, P1, union(I, getOutputs(Q)), getOutputs(P1), A),
          emptyBound, emptyBound)
  => 
  aConfig(pConfig(Sigma, Delta', P2, I1, O1, A), 
               countb1, contextb1)
  *** /\ O1 == getOutputs(P2) 
  *** /\ I1 == union(I, getOutputs(Q))
  *** /\ typeOf(Sigma, Delta, union(I, getOutputs(P1)), A, Q) 
 .
 
 crl [CONG-NEW-NF-EQ-APPROX] :
  aConfig(pConfig(Sigma, Delta, newNF(ltq, P), I, O, A), countb1, contextb1)
  =>
   aConfig(pConfig(Sigma, diff Delta' (addChannels ltq emptyChannelCtx), 
           newNF(ltq, P') , I, O' \ (chansInList ltq), A), 
          pointwiseSum countb1 countb2,
          pointwiseMax contextb1 contextb2)
 if 
   aConfig(pConfig(Sigma, addChannels ltq Delta, P, I, union(chansInList ltq, O), A),
           emptyBound, emptyBound)
  =>   
   aConfig(pConfig(Sigma, Delta', P', I, O', A), 
           countb2, contextb2)
  /\ O' equiv union(chansInList ltq, O)
  /\ Delta' equiv addChannels ltq Delta
 .  
 
 op sumValue__ : ComplexityBound Int -> ComplexityBound .
 eq sumValue pb n = addValue pb n .
 eq sumValue (famBound blist pb) n = famBound blist (addValue pb n) .
     
   crl [GEN-APPROX-cases-3] :
  aConfig(pConfig(Sigma, Delta, 
          family cn[bound nt1 bound nt2 bound nt3] 
                 (qidAsTerm i qidAsTerm j qidAsTerm k)  
                 (bound nt1 bound nt2 bound nt3) ::= whenList1, 
          I, O, A), countb1, contextb1)
  =>         
  aConfig(pConfig(Sigma, Delta,  
          family cn[bound nt1 bound nt2 bound nt3] 
                 (qidAsTerm i qidAsTerm j qidAsTerm k)    
                 (bound nt1 bound nt2 bound nt3) ::=  whenList2, 
          I, O, A), 
          famBound (bound nt1 bound nt2 bound nt3) 
    (toCountFam contextb (qidAsTerm i qidAsTerm j qidAsTerm k)  (bound nt1 bound nt2 bound nt3) ), 
          famBound (bound nt1 bound nt2 bound nt3) 
    (toContextFam contextb (bound nt1 bound nt2 bound nt3) whenList1 whenList2 
                  Sigma Delta A)
    )              
  if 
  aCongrConfig(pConfig(Sigma, 
     toChannelCCtx Delta (toChannel I (qidAsTerm i qidAsTerm j qidAsTerm k), 
                          getOutputs(cn[qidAsTerm i qidAsTerm j qidAsTerm k ] ::= whenList1)), 
          cn[qidAsTerm i qidAsTerm j qidAsTerm k ] ::= whenList1, 
          toChannel I (qidAsTerm i qidAsTerm j qidAsTerm k), 
          toChannel O (qidAsTerm i qidAsTerm j qidAsTerm k), A), emptyBound)
  =>
  aCongrConfig(pConfig(Sigma, Delta', 
          cn[qidAsTerm i qidAsTerm j qidAsTerm k  ] ::= whenList2, 
          I', O', A), contextb)      
  /\ 
  Delta' == toChannelCCtx Delta (toChannel I (qidAsTerm i qidAsTerm j qidAsTerm k), 
                                 getOutputs(cn[qidAsTerm i qidAsTerm j qidAsTerm k ] ::= whenList1))    
  /\ 
  I' == toChannel I (qidAsTerm i qidAsTerm j qidAsTerm k)
  /\ 
  O' == toChannel O (qidAsTerm i qidAsTerm j qidAsTerm k)
  .        
  
  op toCountFam___ : ProtocolBound List{NatTerm} List{Bounds} -> ProtocolBound .
  eq toCountFam (uncondBound f) nlist blist  
   = uncondBound f .
  eq toCountFam cnb nlist blist = mapToCard cnb nlist blist .
  *** for each axiom ax that occurs on a branch
  *** ax |-> | { (i, j, k) | cond holds } | 
  
  op mapToCard___ : ConditionalBound List{NatTerm} List{Bounds} -> ConditionalBound .
  eq mapToCard (singleBound whenCond (uncondBound (q |-> nl))) nlist blist 
   = singleBound whenCond (uncondBound (q |-> savedSetCard nlist blist whenCond)) .
  eq mapToCard ((singleBound whenCond (uncondBound (q |-> nl))) cnb) nlist blist 
   = (singleBound whenCond uncondBound (q |-> savedSetCard nlist blist whenCond)) 
     (mapToCard cnb nlist blist) . 
  
  op toContextFam_______ : 
      ProtocolBound List{Bounds} 
      WhenList WhenList 
      Signature ChannelContext
      Set{BoolTerm} -> ProtocolBound .  
  eq toContextFam 
    (singleBound whenCond uncondBound (q |-> nl)) 
    (bound nt1 bound nt2 bound nt3)
    (whenCond --> P1)
    (whenCond --> Q1)
    Sigma Delta A
   = singleBound whenCond uncondBound (q |->
     nl + (sizeIPDLNT(A, nt3) defDiff 1) * 
     defMax(sizeIPDLP(Sigma, Delta,  A, P1), 
            sizeIPDLP(Sigma, Delta,  A, Q1)) + 
     3 * sizeIPDLNT(A, nt3) + 1 +
     (sizeIPDLNT(A, nt2) defDiff 1) * 
     (sizeIPDLNT(A, nt3) * defMax(sizeIPDLP(Sigma, Delta,  A, P1), 
            sizeIPDLP(Sigma, Delta,  A, Q1)) + 3 * sizeIPDLNT(A, nt3) + 1) + 
            3 * sizeIPDLNT(A, nt2) + 1 +
     (sizeIPDLNT(A, nt1) defDiff 1) * 
     (sizeIPDLNT(A, nt2) * (sizeIPDLNT(A, nt3) * defMax(sizeIPDLP(Sigma, Delta,  A, P1), 
            sizeIPDLP(Sigma, Delta,  A, Q1)) + 3 * sizeIPDLNT(A, nt3) + 1) + 
            3 * sizeIPDLNT(A, nt2) + 1) + 3 * sizeIPDLNT(A, nt1) + 1
     )
 .    
 eq toContextFam 
    ((singleBound whenCond uncondBound (q |-> nl)) cnb) 
    (bound nt1 bound nt2 bound nt3)
    ((whenCond --> P1) ;; whenList1)
    ((whenCond --> Q1) ;; whenList2) 
    Sigma Delta A =
    (toContextFam (singleBound whenCond uncondBound (q |-> nl))
     (bound nt1 bound nt2 bound nt3)
     (whenCond --> P1)
     (whenCond --> Q1) 
     Sigma Delta A
    ) 
    (toContextFam 
    ((singleBound whenCond uncondBound (q |-> nl)) ) 
    (bound nt1 bound nt2 bound nt3)
     whenList1
     whenList2 
     Sigma Delta A) .
      
endm

view ApproxEqConfig from TRIV to APPROX-EQ-CONFIG is
 sort Elt to ApproxEqConfig .
endv
