lang IPDL

import BASEGMWN .

parameter N : nat .
parameter K : nat .

`` Sigma

function xor : bool * bool -> bool .
function ** : bool * bool  -> bool .
function neg : bool -> bool .
distribution flip : unit -> bool .

`` assumptions

expression-assumption %automatic andFalseLeft using x : 
   (x : bool)  |= 
   **( (False, x) ) = False .

    expression-assumption %automatic andFalseRight using x : 
   (x : bool)  |= 
   **( (x, False) ) = False . 

   expression-assumption %automatic andTrueLeft using x : 
   (x : bool)  |= 
   **( (True, x) ) = x .

    expression-assumption %automatic andTrueRight using x : 
   (x : bool)  |= 
   **( (x, True) ) = x .
   
    expression-assumption %automatic xorFalseLeft using x : 
   (x : bool)  |= 
   xor( (False, x) ) = x .

    expression-assumption %automatic xorFalseRight using x : 
   (x : bool)  |= 
   xor( (x, False) ) = x . 
   
    expression-assumption %automatic xorFalse using x : 
   (x : bool)  |= 
   xor( (x, x) ) = False . 
   
   expression-assumption %automatic falseXor using x : 
   (x : bool)  |= 
   xor( (False, False) ) = False . 


hypothesis not (isNotGate(0)) .
hypothesis not (isXorGate(0)) .
hypothesis not (isAndGate(0)) .
hypothesis isHonest(N + 1) .

`` deltaReal 

channel context deltaReal =

input    In[bound N + 2 dependentBound I] : bool ;
output   Out[bound N + 2 bound K] : bool ;
output   CtrbPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   InPartyAdv[bound N + 2 dependentBound I] : bool ;
output   InRcvdPartyAdv[bound N + 2 dependentBound I] : unit ;
output   InSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   InShare$PartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   InShare$-SumPartyAdv[bound N + 1 bound N + 2 dependentBound I] : bool ;
output   OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTOutOtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OutPartyAdv[bound N + 2 bound K] : bool ;
output   OutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OutShareSumPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   RcvdOutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SendBitPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SendInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   SendOutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SharePartyAdv[bound N + 2 bound K] : bool
 .


protocol pInt1 = 
 newfamily InShare[bound N + 2 bound N + 2 dependentBound I] 
   indices: n, m, i 
   bounds: bound N + 2 bound N + 2 dependentBound I : bool in 
 newfamily Share[bound N + 2 bound K] 
   indices: n, k 
   bounds: bound N + 2 bound K : bool in 
 (simpleRestrInitial || splitCirc1 || restrFinal)
where
simpleRestrInitial = 
( newfamily InShare$[bound N + 2 bound N + 2 dependentBound I] 
  indices: m, n, i 
  bounds: bound N + 2 bound N + 2 dependentBound I : bool in
 newfamily InShare$-Sum[bound N + 1 bound N + 2 dependentBound I] 
  indices: m, n, i 
  bounds: bound N + 1 bound N + 2 dependentBound I : bool in
  (
  (family InPartyAdv[bound N + 2 dependentBound I]
  indices: n, i bounds: bound N + 2 dependentBound I ::= 
   (when (isSemiHonest(n)) --> 
     nf(in : bool <- read In[n, i], return in) 
   )  ;; 
   (when (isHonest(n)) --> nf(in : bool <- read InPartyAdv[n, i], return in)
   )
)
||
(
family InRcvdPartyAdv[bound N + 2 dependentBound I]
  indices: n, i bounds: bound N + 2 dependentBound I ::= 
  (when (isHonest(n)) --> 
    nf(x : bool <- read In[n, i], return () )
  ) ;;
  ( when (isSemiHonest(n)) --> nf(in : unit <- read InRcvdPartyAdv[n, i], return in)
  )
)
||
(
family InShare[bound N + 2 bound N + 2 dependentBound I]
  indices: n, m, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
 nf(in : bool <- read InShare$[n, m, i], return in)
)
||
(
family InShare$[bound N + 2 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when (m = N + 1) --> 
    nf((s : bool <- read InShare$-Sum[N, n, i]) 
        x : bool <- read In[n, i], 
        return xor((x, s)))
  ) ;; 
  (otherwise --> nf(x : bool <- read In[n, i], samp flip (()) )
  )
)
||
(
family InShare$-Sum[bound N + 1 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 1 bound N + 2 dependentBound I ::= 
  (when (0 = m) --> 
    nf(in : bool <- read InShare$[0, n, i], return in) 
  ) ;; 
  (otherwise --> 
    nf((s : bool <- read InShare$-Sum[m - 1, n, i]) 
        x : bool <- read InShare$[m, n, i], 
        return xor((s, x)))
  )      
)
||
(
family InShare$-SumPartyAdv[bound N + 1 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 1 bound N + 2 dependentBound I ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read InShare$-Sum[m, n, i], return s) 
  ) ;;
  (when (isHonest(n)) --> 
    nf(s : bool <- read InShare$-SumPartyAdv[m, n, i], return s)
  )  
)
||
(
family InShare$PartyAdv[bound N + 2 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
 (when (isSemiHonest(n)) --> 
    nf(in : bool <- read InShare$[m, n, i], return in) 
 ) ;; 
 (when (isHonest(n)) --> 
   nf(in : bool <- read InShare$PartyAdv[m, n, i], return in)
 )  
)
||
(
family InSharePartyAdv[bound N + 2 bound N + 2 dependentBound I]
  indices: n, m, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when (isSemiHonest(n)) --> nf(s : bool <- read InShare[n, m, i], return s)
  ) 
  ;; 
  (when (isHonest(n)) --> nf(s : bool <- read InSharePartyAdv[n, m, i], return s))
)
||
(
family RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I]
  indices: n, m, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when (isSemiHonest(n)) --> nf(in : bool <- read InShare$[n, m, i], return in) 
  ) ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read RcvdInSharePartyAdv[n, m, i], return s)
  )  
)
||
(
family SendInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when (isSemiHonest(n)) --> 
    nf(in : bool <- read InShare$[m, n, i], return in)
  ) ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read SendInSharePartyAdv[m, n, i], return s)
  )  
)
  )
)`` end simplRestrInitial  
and
splitCirc1 = (
 newfamily SendBit[bound N + 2 bound N + 2 bound K] 
  indices: n, m, k 
  bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily RcvdBit[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k 
   bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily Ctrb[bound N + 2 bound N + 2 bound K] 
  indices: n, m, k 
  bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily CtrbSum[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k 
   bounds: bound N + 2 bound N + 2 bound K : bool in
 (adv || shares)
 where 
adv = (
   family Adv[bound K] indices: k bounds: bound K ::=
  (`` start group 
(when (isInputGate(k)) --> 
(
(family CtrbPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool  <- read CtrbPartyAdv[n, m, k], return b) 
)
||
(
family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(b : bool <- read CtrbSumPartyAdv[n, m, k], return b) 
)
||
(
family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-0OtAdv[n, m, k], return oc) 
)
||
(

family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-1OtAdv[n, m, k], return oc)
)
||
(
family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(oc : unit <- read OTChcRcvd-0OtAdv[n, m, k], return oc)
)
||
(

family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : unit <- read OTChcRcvd-1OtAdv[n, m, k], return oc) 
)
||
(

family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-0OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : bool <- read OTMsg-1OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-3OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-0OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : unit <- read OTMsgRcvd-1OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-3OtAdv[n, m, k], return om) 
)
||
(
family OTOutOtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(out : bool <- read OTOutOtAdv[n, m, k], return out) 
)
||
(
family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb :  bool <- read RcvdBitPartyAdv[n, m, k], return rb) 
)
||
(
family SendBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb :  bool <- read SendBitPartyAdv[n, m, k], return sb) 
)
||
(
family SharePartyAdv[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read  Share[n, k], return s) 
  )  
  ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read SharePartyAdv[n, k], return s)
  )  
)
) `` end input gate
) `` end when
;;
(when (isNotGate(k)) --> 
(
(family CtrbPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool  <- read CtrbPartyAdv[n, m, k], return b) 
)
||
(
family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(b : bool <- read CtrbSumPartyAdv[n, m, k], return b) 
)
||
(
family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-0OtAdv[n, m, k], return oc) 
)
||
(

family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-1OtAdv[n, m, k], return oc)
)
||
(
family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(oc : unit <- read OTChcRcvd-0OtAdv[n, m, k], return oc)
)
||
(

family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : unit <- read OTChcRcvd-1OtAdv[n, m, k], return oc) 
)
||
(

family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-0OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : bool <- read OTMsg-1OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-3OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-0OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : unit <- read OTMsgRcvd-1OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-3OtAdv[n, m, k], return om) 
)
||
(
family OTOutOtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(out : bool <- read OTOutOtAdv[n, m, k], return out) 
)
||
(
family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb :  bool <- read RcvdBitPartyAdv[n, m, k], return rb) 
)
||
(
family SendBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb :  bool <- read SendBitPartyAdv[n, m, k], return sb) 
)
||
(
family SharePartyAdv[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read  Share[n, k], return s) 
  )  
  ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read SharePartyAdv[n, k], return s)
  )  
)
) `` end not gate
) `` end when
;;
(when (isXorGate(k)) --> 
(
(family CtrbPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool  <- read CtrbPartyAdv[n, m, k], return b) 
)
||
(
family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(b : bool <- read CtrbSumPartyAdv[n, m, k], return b) 
)
||
(
family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-0OtAdv[n, m, k], return oc) 
)
||
(

family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-1OtAdv[n, m, k], return oc)
)
||
(
family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(oc : unit <- read OTChcRcvd-0OtAdv[n, m, k], return oc)
)
||
(

family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : unit <- read OTChcRcvd-1OtAdv[n, m, k], return oc) 
)
||
(

family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-0OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : bool <- read OTMsg-1OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-3OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-0OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : unit <- read OTMsgRcvd-1OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-3OtAdv[n, m, k], return om) 
)
||
(
family OTOutOtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(out : bool <- read OTOutOtAdv[n, m, k], return out) 
)
||
(
family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb :  bool <- read RcvdBitPartyAdv[n, m, k], return rb) 
)
||
(
family SendBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb :  bool <- read SendBitPartyAdv[n, m, k], return sb) 
)
||
(
family SharePartyAdv[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read  Share[n, k], return s) 
  )
  ;; 
  ( when (isHonest(n)) --> 
    nf(s : bool <- read SharePartyAdv[n, k], return s)
  )  
)
) `` end xor gate
) `` end when
;;

(when (isAndGate(k)) --> 
(
(family CtrbPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=  
   (when (isSemiHonest(n)) --> nf(s : bool <- read Ctrb[n, m, k], return s) 
   )
   ;; 
   (when (isHonest(n)) --> nf(s : bool <- read CtrbPartyAdv[n, m, k], return s)
   )
)
||
(
family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when (isSemiHonest(n)) --> 
     nf(s : bool <- read CtrbSum[n, m, k], return s) 
   )  
   ;; 
   (when (isHonest(n)) --> 
   nf(s : bool <- read CtrbSumPartyAdv[n, m, k], return s)
   )
)
||
(
family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isSemiHonest(m))) --> 
      nf(x : bool <- read Share[m, wire0(k)], return x) 
    )  
    ;; 
    (when ((m <= n) or (isHonest(m)) ) --> 
    nf(oc : bool <- read OTChc-0OtAdv[n, m, k], return oc)
    )
)
||
(

family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isSemiHonest(m))) --> 
     nf(x : bool <- read Share[m, wire1(k)], return x) 
    ) 
    ;; 
       (when ((m <= n) or (isHonest(m)) ) -->  
        nf(oc : bool <- read OTChc-1OtAdv[n, m, k], return oc)
       ) 
)
||
(
family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when ((n < m) and (isHonest(m))) --> 
    nf(x : bool <- read Share[m, wire0(k)], return()) 
   ) 
   ;; 
   (when ((m <= n) or (isSemiHonest(m))) --> 
    nf(oc : unit <- read OTChcRcvd-0OtAdv[n, m, k], return oc)
   ) 
)
||
(

family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 (when ((n < m) and (isHonest(m))) --> 
   nf(x : bool <- read Share[m, wire1(k)], return()) 
 )  
  ;; 
  (when ((m <= n) or (isSemiHonest(m))) --> 
   nf(oc : unit <- read OTChcRcvd-1OtAdv[n, m, k], return oc)
   )
)
||
(

family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isSemiHonest(n))) --> 
     nf((b : bool <- read SendBit[n, m, k])
        (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return b) 
    )    
    ;; 
    (when ((m <= n) or (isHonest(n))) --> 
     nf(om : bool <- read OTMsg-0OtAdv[n, m, k], return om)
    ) 
)
||
(
family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isSemiHonest(n))) --> 
         nf((b : bool <- read SendBit[n, m, k])
            (x : bool <- read Share[n, wire0(k)]) 
             y : bool <- read Share[n, wire1(k)], return xor((x, b))) 
    )
   ;; 
   (when ((m <= n) or (isHonest(n))) -->  
     nf(om : bool <- read OTMsg-1OtAdv[n, m, k], return om)
   )
)
||
(

family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   ( when ((n < m) and (isSemiHonest(n))) -->  
    nf((b : bool <- read SendBit[n, m, k])
       (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return xor((y, b))
      )
   )    
    ;; 
    (when ((m <= n) or (isHonest(n)))
    --> nf(om : bool <- read OTMsg-2OtAdv[n, m, k], return om)
    ) 
)
||
(

family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when ((n < m) and (isSemiHonest(n))) -->  
    nf((b : bool <- read SendBit[n, m, k])
       (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return xor((xor((x, y)), b))
      )
   )     
    ;; 
    (when ((m <= n) or (isHonest(n))) --> 
      nf(om : bool <- read OTMsg-3OtAdv[n, m, k], return om)
    )  
)
||
(
family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=  
  (when ((n < m) and (isHonest(n))) --> 
    nf((b : bool <- read SendBit[n, m, k])
       (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return()
      )
  )      
    ;; 
  (when ((m <= n) or (isSemiHonest(n))) -->  
    nf(om : unit <- read OTMsgRcvd-0OtAdv[n, m, k], return om)
  )  
)
||
(
family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when ((n < m) and (isHonest(n))) --> 
    nf((b : bool <- read SendBit[n, m, k])
       (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return()
      )
   )        
    ;; 
    (when ((m <= n) or (isSemiHonest(n))) --> 
     nf(om : unit <- read OTMsgRcvd-1OtAdv[n, m, k], return om)
    ) 
)
||
(
family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isHonest(n))) --> 
     nf((b : bool <- read SendBit[n, m, k])
        (x : bool <- read Share[n, wire0(k)]) 
         y : bool <- read Share[n, wire1(k)], return()
       ) 
    )   
    ;; 
    (when ((m <= n) or (isSemiHonest(n))) --> 
      nf(om : unit <- read OTMsgRcvd-2OtAdv[n, m, k], return om)
    )  
)
||
(
family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isHonest(n))) --> 
   nf((b : bool <-  read SendBit[n, m, k])
      (x : bool <- read Share[n, wire0(k)]) 
       y : bool <- read Share[n, wire1(k)], return()
     ) 
  )   
    ;; 
   ( when ((m <= n) or (isSemiHonest(n))) --> 
    nf(om : unit <- read OTMsgRcvd-3OtAdv[n, m, k], return om)
   ) 
)
||
(
family OTOutOtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
     (when (isSemiHonest(m)) --> 
       nf(out : bool <- read RcvdBit[m, n, k], return out)
     )  
     ;; 
     (when (isHonest(m)) --> 
       nf(out : bool <- read OTOutOtAdv[n, m, k], return out)
     )  
)
||
(
family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read RcvdBit[n, m, k], return s) 
  )  
    ;; 
   ( when (isHonest(n))  --> 
     nf(s : bool <- read RcvdBitPartyAdv[n, m, k], return s)
   )  
)
||
(
family SendBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read SendBit[n, m, k], return s) 
  ) ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read SendBitPartyAdv[n, m, k], return s)
  )  
)
||
(
family SharePartyAdv[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::=  
   (when (isSemiHonest(n)) --> 
     nf(s : bool <- read Share[n, k], return s) 
   )  
   ;; 
   (when (isHonest(n)) --> 
     nf(s : bool <- read SharePartyAdv[n, k], return s)
   )
)     
) `` end and gate
) `` end when
)`` end group   
 )

 and 
 shares = (
  family Shares[bound K] indices: k bounds: bound K ::=
   
   (when (isInputGate(k)) --> 
   (
    (family Ctrb[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
     nf(b : bool <- read Ctrb[n, m, k], return b) 
    )
    ||
(
family CtrbSum[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool <- read CtrbSum[n, m, k], return b) 
)
||
(
family RcvdBit[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb : bool <- read RcvdBit[n, m, k], return rb) 
)
||
(
family SendBit[bound N + 2 bound N + 2 bound K] 
 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb : bool <- read SendBit[n, m, k], return sb) 
)
||
(
family Share[bound N + 2 bound K] 
 indices: n, k bounds: bound N + 2 bound K ::=
  nf(in : bool <- read InShare[n, wire0(k), wire1(k)], return in) 
)
   
   ) ``end input gate
   ) ``end when 
 ;;
( when (isNotGate(k)) -->
(
 (family Ctrb[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
     nf(b : bool <- read Ctrb[n, m, k], return b) 
)
||
(
family CtrbSum[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool <- read CtrbSum[n, m, k], return b) 
)
||
(
family RcvdBit[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb : bool <- read RcvdBit[n, m, k], return rb) 
)
||
(
family SendBit[bound N + 2 bound N + 2 bound K] 
 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb : bool <- read SendBit[n, m, k], return sb) 
)
||
(
family Share[bound N + 2 bound K] 
 indices: n, k bounds: bound N + 2 bound K ::=
  (when (n = N + 1) --> nf(x : bool <- read Share[n, wire0(k)], return neg(x)) 
  )
  ;; 
  (when (not (n = N + 1)) --> nf(s : bool <- read Share[n, wire0(k)], return s)  
  )
)
) `` end not gate
) `` end when
;; 
( when (isXorGate(k)) -->
(
 (family Ctrb[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
     nf(b : bool <- read Ctrb[n, m, k], return b) 
)
||
(
family CtrbSum[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool <- read CtrbSum[n, m, k], return b) 
)
||
(
family RcvdBit[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb : bool <- read RcvdBit[n, m, k], return rb) 
)
||
(
family SendBit[bound N + 2 bound N + 2 bound K] 
 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb : bool <- read SendBit[n, m, k], return sb) 
)
||
(
family Share[bound N + 2 bound K] 
 indices: n, k bounds: bound N + 2 bound K ::=
  nf((x : bool <- read Share[n, wire0(k)]) y : bool <- read
    Share[n, wire1(k)], return xor((x, y))) 
)
) `` end xor gate
) `` end when  
;; 
( when (isAndGate(k)) --> 
(
(family Ctrb[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when (n < m) --> nf(s : bool <- read SendBit[n, m, k], return s) )
    ;; 
    (when (m = n) --> 
     nf((x : bool <- read Share[n, wire0(k)]) 
         y : bool <- read Share[n, wire1(k)], return **((x, y))
       ) 
    )   
    ;;
    (when (m < n) --> nf(r : bool <- read RcvdBit[n, m, k], return r)
    )
)
||
(
family CtrbSum[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=  
  (when (0 = m)  --> nf(b : bool <- read Ctrb[n, 0, k], return b) )
  ;; 
  (when (not (0 = m)) --> 
   nf((b : bool <- read Ctrb[n, m, k]) 
       s : bool <- read CtrbSum[n, m - 1, k], return xor((s, b)) 
     )
  )   
)
||
(
family RcvdBit[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   nf((b : bool <- read SendBit[m, n, k])
      (xm : bool <- read Share[m, wire0(k)])
      (xn : bool <- read Share[n, wire0(k)])
      (ym : bool <- read Share[m, wire1(k)]) 
       yn : bool <- read Share[n, wire1(k)], 
        return xor((xor((**((xm, yn)), **((xn, ym)))), b))
     )
)
||
(
family SendBit[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 (when (n < m) --> 
  nf((x : bool <- read Share[n, wire0(k)]) 
      y : bool <- read Share[n, wire1(k)], samp flip(())
    ) 
 )   
 ;; 
 (when (m <= n) --> nf(sb : bool <- read SendBit[n, m, k], return sb)
 )
)
||
(
family Share[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::= 
  nf(bs : bool <- read CtrbSum[n, N + 1, k], return bs)
)
) `` end and gate
) `` end when
   
  ) `` end shares

) `` end splitcirc
and 
restrFinal = 
(
   newfamily SendOutShare[bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k 
             bounds: bound N + 2 bound N + 2 bound K : bool in          
   newfamily OutShare[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily OutShareSum[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K : bool in
   ( 
     (family SendOutShare[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isOutputWire(k)) --> 
         s : bool <- read Share[n, k] ; return s
       ) 
       ;; 
       (when (not (isOutputWire(k))) --> 
         s : bool <- read SendOutShare[m, n, k] ; return s
       )       
     )
     ||
    (family SendOutSharePartyAdv
               [bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendOutShare[m, n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SendOutSharePartyAdv[m, n, k] ;
         return s
       )       
     )
     ||
     (family RcvdOutSharePartyAdv
               [bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendOutShare[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read RcvdOutSharePartyAdv[n, m, k] ;
         return s
       )       
     )
     || 
     (family OutShare[bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       s : bool <- read SendOutShare[n, m, k] ; return s       
     )
     ||
     (family OutSharePartyAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read OutShare[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutSharePartyAdv[n, m, k] ;
         return s
       )       
     )
     ||
     (family OutShareSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (m = 0) --> 
         s : bool <- read OutShare[n, 0, k] ;
         return s
       )
       ;;
       (otherwise -->
         s : bool <- read OutShareSum[n, m - 1, k] ;
         x : bool <- read OutShare[n, m, k] ;
         return xor((s, x))
       )
     )        
     ||
     (family OutShareSumPartyAdv
              [bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read OutShareSum[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutShareSumPartyAdv[n, m, k] ;
         return s
       )       
     )
     ||
     (family Out[bound N + 2 bound K]  indices: n, k
            bounds: bound N + 2 bound K ::=
       s : bool <- read OutShareSum[n, N + 1, k] ;
       return s
     )
     ||
     (family OutPartyAdv[bound N + 2 bound K]  indices: n, k
             bounds: bound N + 2 bound K  ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Out[n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutPartyAdv[n, k] ;
         return s
       )       
     )
   ) `` end new

) `` ends restrFinal
.

`` pInt1

`` subproofs
strict subproof addSharesOK = 
group  
   fam ShareOK[bound N + 2 bound K],
   fam SendBit-OK[bound N + 2 bound N + 2 bound K],
   fam RcvdBit-OK[bound N + 2 bound N + 2 bound K],
   fam Ctrb-OK[bound N + 2 bound N + 2 bound K],
   fam CtrbSum-OK[bound N + 2 bound N + 2 bound K]
in SharesOK 
indices: k
bounds: bound K .

strict subproof addInitOK =
group  
  fam InShareOK[bound N + 2 bound N + 2 dependentBound I],
  fam InShare$-OK[bound N + 2 bound N + 2 dependentBound I],
  fam InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I]
in InitOK 
indices: m, n, i
bounds: bound N + 2 bound N + 2 dependentBound I .

strict subproof changeShares = 
 sym from 
( branch when (isInputGate(k)) of fam Shares[bound K]
 change fam Share[fixedBound N + 1 bound K]
 with x : unit <- read InShareOK[N + 1, wire0(k), wire1(k)] ;
      in : bool <- read InShare[N + 1, wire0(k), wire1(k)] ;
      return in
 in 
 (branch when (isNotGate(k))  of fam Shares[bound K]
  change fam Share[fixedBound N + 1 bound K]
  with 
       s : unit <- read ShareOK[N + 1, wire0(k)] ;
       x : bool <- read Share[N + 1, wire0(k)] ;
       return neg(x)
  in (
   branch when (isXorGate(k)) of fam Shares[bound K]
   change fam Share[fixedBound N + 1 bound K]
   with  
         a : unit <- read ShareOK[N + 1, wire0(k)] ;
         b : unit <- read ShareOK[N + 1, wire1(k)] ;
         x : bool <- read Share[N + 1, wire0(k)] ;
         y : bool <- read Share[N + 1, wire1(k)] ;
         return xor((x, y)) 
   in (branch when (isAndGate(k)) of fam Shares[bound K]
   change fam Share[fixedBound N + 1 bound K]
   with
    x : unit <- read CtrbSum-OK[N + 1, N + 1, k] ;
    bs : bool <- read CtrbSum[N + 1, N + 1, k] ;
    return bs    
   in currentProtocol
   )
  )        
  ) 
)  (
   ungroup fam SharesOK[bound K] then
   ungroup fam InitOK[bound N + 2 bound N + 2 dependentBound I] then
   on branch isInputGate(k) of group Shares[bound K](
     subst fam InShareOK[bound N + 2 bound N + 2 dependentBound I] 
     into fam Share[fixedBound N + 1 bound K]
   ) then
   on branch isNotGate(k) of group Shares[bound K](
     subst fam ShareOK[bound N + 2 bound K]
     into fam Share[fixedBound N + 1 bound K]
   ) then
   on branch isXorGate(k) of group Shares[bound K](
     subst fam ShareOK[bound N + 2 bound K]
     into fam Share[fixedBound N + 1 bound K] then
     rename x to inA in fam Share[fixedBound N + 1 bound K] then
     subst fam ShareOK[bound N + 2 bound K]
     into fam Share[fixedBound N + 1 bound K] then
     rename x to y, inA to x in fam Share[fixedBound N + 1 bound K]  
   )  then 
   on branch isAndGate(k) of group Shares[bound K](
     subst fam CtrbSum-OK[bound N + 2 bound N + 2 bound K]
     into fam Share[fixedBound N + 1 bound K] 
   ) then
   call addSharesOK then
   call addInitOK 
   ) 
.

strict subproof addInOK = 
 add internal family In-OK 
     indices: n, i 
     bounds: bound N + 2 dependentBound I 
     typed: unit 
     assigned: 
       in : bool <- read In[n, i] ; 
       return ()
.

strict subproof addWiresOK =
 add internal family Wire-OK
     indices: k
     bounds: bound K 
     typed: unit
     assigned: 
          (when (isInputGate(k)) --> 
            in : unit <- read In-OK[wire0(k), wire1(k)] ;
            return in
          )
          ;;
          (when (isNotGate(k)) --> 
            w : unit <- read Wire-OK[wire0(k)] ;
            return ()
          )
          ;;
          (when (isXorGate(k)) --> 
            w0 : unit <- read Wire-OK[wire0(k)] ;
            w1 : unit <- read Wire-OK[wire1(k)] ;
            return () 
          )
          ;;
          (when (isAndGate(k)) --> 
            w0 : unit <- read Wire-OK[wire0(k)] ;
            w1 : unit <- read Wire-OK[wire1(k)] ;
            return () 
          ) then
  group  
   fam Wire-OK[bound K]
in Wires-OK 
indices: k
bounds: bound K        
.

strict subproof splitShareOK = 
 split fam ShareOK[bound N + 2 bound K] on first index inside group SharesOK[bound K]
.

strict subproof sym3 = 
 add internal family InShareOK
indices: m, n, i
bounds: bound N + 2 bound N + 2 dependentBound I 
typed: unit 
assigned: 
 is : bool <- read InShare[m, n, i] ; return () then
add internal family ShareOK
indices: n, k
bounds: bound N + 2 bound K
typed: unit
assigned: x : bool <- read Share[n, k] ; return ()
.

strict subproof sym4 =
 on branch isAndGate(k) of group Adv[bound K](
on branch n < N + 1 of family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K](
  sym from change fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] 
    with x : unit <- read ShareOK[N + 1, wire0(k)] ; return ()
    in currentProtocol(
      subst fam ShareOK[bound N + 2 bound K]
      into fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] 
    )
) then
on branch n < N + 1 of family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K](
  sym from change fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] 
    with x : unit <- read ShareOK[N + 1, wire1(k)] ; return ()
    in currentProtocol(
      subst fam ShareOK[bound N + 2 bound K]
      into fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] 
    )
)
)
.

strict subproof sym5 = 
 add internal family InShare$-OK
indices: m, n, i
bounds: bound N + 2  bound N + 2 dependentBound I
typed: unit
assigned: is : bool <- read InShare$[m, n, i] ; return () then
add internal family InShare$Sum-OK
indices: m, n, i
bounds: bound N + 1  bound N + 2 dependentBound I
typed: unit
assigned: is : bool <- read InShare$-Sum[m, n, i] ; return () then
add internal family SendBit-OK
indices: n, m, k
bounds: bound N + 2  bound N + 2 bound K
typed: unit
assigned: s : bool <- read SendBit[n, m, k] ; return () then
add internal family RcvdBit-OK
indices: n, m, k
bounds: bound N + 2  bound N + 2 bound K
typed: unit
assigned: r : bool <- read RcvdBit[n, m, k] ; return () then
add internal family Ctrb-OK
indices: n, m, k
bounds: bound N + 2  bound N + 2 bound K
typed: unit
assigned: c : bool <- read Ctrb[n, m, k] ; return () then
add internal family CtrbSum-OK
indices: n, m, k
bounds: bound N + 2  bound N + 2 bound K
typed: unit
assigned: c : bool <- read CtrbSum[n, m, k] ; return ()
.

strict subproof sym8 = 
 sym from 
         branch
          when (isInputGate(k)) 
         of 
          fam Shares[bound K] 
         change 
          fam Share[fixedBound (N + 1) bound K] 
         with 
          x : unit <- read InShareOK[N + 1, wire0(k), wire1(k)] ;
          in : bool <- read InShare[N + 1, wire0(k), wire1(k)] ;
          return in
         in 
         (branch
           when (isNotGate(k)) 
         of 
           fam Shares[bound K] 
         change 
          fam Share[fixedBound (N + 1) bound K] 
         with 
          s : unit <- read ShareOK[N + 1, wire0(k)] ;
          x : bool <- read Share[N + 1, wire0(k)];
          return neg(x)
         in 
         (branch
            when (isXorGate(k))
          of  
           fam Shares[bound K] 
          change 
           fam Share[fixedBound (N + 1) bound K] 
          with 
           a : unit <- read ShareOK[N + 1, wire0(k)] ;
           b : unit <- read ShareOK[N + 1, wire1(k)] ;
           x : bool <- read Share[N + 1, wire0(k)] ;
           y : bool <- read Share[N + 1, wire1(k)] ;
           return xor((x, y))
         in 
          (branch
            when (isAndGate(k))
          of  
           fam Shares[bound K] 
          change 
           fam Share[fixedBound (N + 1) bound K] 
          with 
           x : unit <- read CtrbSum-OK[N + 1, N + 1, k] ;
           bs : bool <- read CtrbSum[N + 1, N + 1, k] ;
           return bs 
         in currentProtocol
          ) ) )
 ( on branch isInputGate(k) of group Shares[bound K] (
     subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
      into fam Share[fixedBound (N + 1) bound K]
   ) then
   on branch isNotGate(k) of group Shares[bound K] (
     subst fam ShareOK[bound (N + 2) bound K]
      into fam Share[fixedBound (N + 1) bound K]
   ) then  
   on branch isXorGate(k) of group Shares[bound K] (
     subst fam ShareOK[bound (N + 2) bound K]
      into fam Share[fixedBound (N + 1) bound K] then
     rename x to inA in fam Share[fixedBound (N + 1) bound K] then
     subst fam ShareOK[bound (N + 2) bound K]
      into fam Share[fixedBound (N + 1) bound K] then
     rename x to y, inA to x 
      in fam Share[fixedBound (N + 1) bound K] 
   ) then 
   on branch isAndGate(k) of group Shares[bound K] (
     subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
      into fam Share[fixedBound (N + 1) bound K]
   )  
 )
 .

strict subproof inIndSym7 = 
 sym from
       change 
        fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]  
        with
         s : bool <- read SendBit[n, m, B] ;  return ()
        in currentProtocol
(  
  sym from 
          change 
        fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
        with
         (when (n < m) --> 
           s : bool <- read SendBit[n, m, B] ;  return () 
         )
         ;;
         (when (m <= n) --> 
           s : bool <- read SendBit[n, m, B] ;  return () 
         )
        in currentProtocol 
         ( merge cases for fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         ) then

 case distinction on family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] (
  case:(
   using branch when isAndGate(B)
         of group Shares[fixedBound B]
         ( 
           using branch when n < m
            of family SendBit[bound (N + 2) bound (N + 2) fixedBound B]
            ( drop read 
                fam SendBit[bound (N + 2) bound (N + 2) fixedBound B]
              from fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
            )
         )       
 )

 case: (
  using branch when isAndGate(B)
         of group Shares[fixedBound B]
         ( 
           using branch when m <= n
            of family SendBit[bound (N + 2) bound (N + 2) fixedBound B]
            ( diverge 
                on fam SendBit[bound (N + 2) bound (N + 2) fixedBound B] 
                with fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
                var sb
            )
         )
 )
 )
)

. 

strict subproof inIndSym10 =
 rewrite family CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
  to c : bool <- read CtrbSum[n, m, B] ; return ()
  by induction on m bound M
  (
  case distinction on family CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B](
   case: (subst fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
     into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B] then 
    sym from 
     change fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
     with c : bool <- read CtrbSum[n, M, B] ;  return ()
     in currentProtocol 
     (
       using branch when isAndGate(B) of
        group Shares[fixedBound B]
        ( subst fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
           into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
        ) then     
        rename b to c in fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
    )
  ) 
   
   case: ( subst fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
      into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B] then
     rename c to b in fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B] then
     subst fam CtrbSum-OK[bound (N + 2) bound M fixedBound B]
      into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B] then       
     rename c to s in fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B] then       
     sym from 
      change fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
        with c : bool <- read CtrbSum[n, M, B] ; return ()
          in currentProtocol 
      ( using branch when isAndGate(B) of
        group Shares[fixedBound B]
        ( subst fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
           into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
        )
      )
   )
  
  
  ) then
   
  merge cases for fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
  
  )

.

strict subproof inIndSym11 =
 sym from 
   change 
        fam ShareOK[bound (N + 1) fixedBound B]
        with
         x : bool <- read Share[n, B] ; return ()
        in currentProtocol
  ( using branch when isAndGate(B)
     of group Shares[fixedBound B]
    (subst fam Share[bound (N + 1) fixedBound B]
      into fam ShareOK[bound (N + 1) fixedBound B] then
     rename bs to c in fam ShareOK[bound (N + 1) fixedBound B]  
    ) 
  )      
.

strict subproof inIndSym12 =
 sym from 
   change 
        chn ShareOK[N + 1, B]
        with
         x : bool <- read Share[N + 1, B] ; return ()
        in currentProtocol
  ( using branch when isAndGate(B)
     of group Shares[fixedBound B]
    (subst chn Share[N + 1, B]
      into chn ShareOK[N + 1, B] then
     rename bs to c in chn ShareOK[N + 1, B]  
    ) then
    subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
     into chn ShareOK[N + 1, B]
  )      
.   

strict subproof changeComp =
sym from
     change fam SharesOK[bound K]
        with 
           (when (isInputGate(k)) -->
         (  
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(
family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 i : unit <- read InShareOK[n, wire0(k), wire1(k)] ; return i
)
||
(
family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 i : unit <- read InShareOK[N + 1, wire0(k), wire1(k)] ;
 return i
)
         )
) 
;;
(when (isNotGate(k)) -->
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(
family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : unit <- read ShareOK[n, wire0(k)] ; return x
)
||
(
family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : unit <- read ShareOK[N + 1, wire0(k)] ; 
 return x
)
)
)
;;
(when (isXorGate(k)) -->
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(
family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : unit <- read ShareOK[n, wire0(k)] ;
 y : unit <- read ShareOK[n, wire1(k)] ; 
 return ()
)
||
(
family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : unit <- read ShareOK[N + 1, wire0(k)] ;
 y : unit <- read ShareOK[N + 1, wire1(k)] ; 
 return ()
)
)
)
;;
(when (isAndGate(k)) -->
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : unit <- read SendBit-OK[n, m, k] ; return s
) 
;;
(when (m < n) -->
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
;;
(when (m = n) -->
 x : unit <- read ShareOK[n, wire0(k)] ; 
 y : unit <- read ShareOK[n, wire1(k)] ; 
 return () 
)
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (0 = m) -->
 c : unit <- read Ctrb-OK[n, 0, k] ; return c
)
;;
(when (not (0 = m)) -->
  x : unit <- read CtrbSum-OK[n, m - 1, k] ;
  y : unit <- read Ctrb-OK[n, m, k] ; 
  return () 
)
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : unit <- read SendBit-OK[m, n, k] ;
 xm : unit <- read ShareOK[m, wire0(k)] ;
 xn : unit <- read ShareOK[n, wire0(k)] ; 
 ym : unit <- read ShareOK[m, wire1(k)] ; 
 yn : unit <- read ShareOK[n, wire1(k)] ; 
 return ()
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : unit <- read ShareOK[n, wire0(k)] ;
 y : unit <- read ShareOK[n, wire1(k)] ; 
    return ()
)
;;
(when (m <= n) -->
 sb : unit <- read SendBit-OK[n, m, k] ; return sb
)
)
||
(family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 c : unit <- read CtrbSum-OK[n, N + 1, k] ; return c
)
||
(family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 c : unit <- read CtrbSum-OK[N + 1, N + 1, k] ;
 return c  
)
)
)
  in currentProtocol 
(
in the presence of 
  fam InitOK[bound (N + 2) bound (N + 2) dependentBound I]
  rewrite
  group Shares[bound K] and SharesOK[bound K]
  to
  (
(family Shares[bound K] 
 indices: k
 bounds: bound K
::=
(
(when (isInputGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read  Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read  CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read  RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read  SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <- read  InShare[n, wire0(k), wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 in : bool <- read  InShare[N + 1, wire0(k), wire1(k)] ;
 x : unit <- read  InShareOK[N + 1, wire0(k), wire1(k)] ; 
 return in
)
)
)
;;
(when (isNotGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read  Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read  CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read  RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read  SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <- read  Share[n, wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 s : unit <- read  ShareOK[N + 1, wire0(k)] ;
 x : bool <- read  Share[N + 1, wire0(k)] ; 
 return neg(x)
)
)
)
;;
(when (isXorGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read  Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read  CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read  RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read  SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <- read  Share[n, wire0(k)] ;
 y : bool <- read  Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 a : unit <- read  ShareOK[N + 1, wire0(k)] ;
 b : unit <- read  ShareOK[N + 1, wire1(k)] ;
 x : bool <- read  Share[N + 1, wire0(k)] ;
 y : bool <- read  Share[N + 1, wire1(k)] ; 
 return xor((x, y))
)
) 
)
;;
(when (isAndGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <- read  SendBit[n, m, k] ; return s
)
;;
(when (m = n) -->
 x : bool <- read  Share[n, wire0(k)] ;
 y : bool <- read  Share[n, wire1(k)] ;
 return **((x, y))
) 
;;
(when (m < n) -->
 r : bool <- read  RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (0 = m) -->
 b : bool <- read  Ctrb[n, 0, k] ; return b
)
;;
(when (not (0 = m)) -->
  b : bool <- read  Ctrb[n, m, k] ;
  s : bool <- read  CtrbSum[n, m - 1, k] ; 
  return xor((s, b))
)
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read  SendBit[m, n, k] ;
 xm : bool <- read  Share[m, wire0(k)] ;
 xn : bool <- read  Share[n, wire0(k)] ;
 ym : bool <- read  Share[m, wire1(k)] ;
 yn : bool <- read  Share[n, wire1(k)] ; 
    return xor( (  xor( (**((xm, yn)) , **((xn, ym))) ),  b) )
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <- read  Share[n, wire0(k)] ;
 y : bool <- read  Share[n, wire1(k)] ;
 samp flip(())
) 
;;
(when (m <= n) -->
 sb : bool <- read  SendBit[n, m, k] ; return sb
)
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <- read  CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 bs : bool <- read  CtrbSum[N + 1, N + 1, k] ;
 x : unit <- read  CtrbSum-OK[N + 1, N + 1, k] ;
 return bs
)
)
)
)
)
||
(family SharesOK[bound K] 
 indices: k
 bounds: bound K
::=
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : bool <- read  Ctrb[n, m, k] ;  return ()
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : bool <- read  CtrbSum[n, m, k] ;  return ()
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : bool <- read  RcvdBit[n, m, k] ;  return ()
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : bool <- read  SendBit[n, m, k] ;  return ()
)
||
(family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <- read  Share[n, k] ; return ()
)
||
(family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <- read  Share[N + 1, k] ; return ()
)
)
)
)
  by induction on k bound B 
 (
  ungroup fam InitOK[bound (N + 2) bound (N + 2) dependentBound I] then
  case distinction on group SharesOK[fixedBound B] 
  (
   case: (
    using branch when isInputGate(B) of group Shares[fixedBound B]( 
    sym var c terms n, m, B 
          diverge fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
          into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] var c then
    sym var c terms n, m, B 
          diverge fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
          into fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B] var c then    
    sym var r terms n, m, B 
          diverge fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B]
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] var r then 
    sym var s terms n, m, B 
          diverge fam SendBit[bound (N + 2) bound (N + 2) fixedBound B]
          into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] var s then    
    subst fam InShareOK[bound N + 2 bound N + 2 dependentBound I ]
    into chn ShareOK[N + 1, B] then
      sym from 
          change 
        chn ShareOK[N + 1, B]
        with
         x : bool <- read Share[N + 1, B] ; return ()
        in currentProtocol  
        (  subst chn Share[N + 1, B] into chn ShareOK[N + 1, B] then
           subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
            into chn ShareOK[N + 1, B] then 
           rename in to is in chn ShareOK[N + 1, B] 
        ) then
    rename indices to x, y in fam ShareOK[bound(N + 1) fixedBound B] then
      subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
       into fam ShareOK[bound (N + 1) fixedBound B] then
      rename indices to n, k in fam ShareOK[bound(N + 1) fixedBound B] then
      rename is to in in fam ShareOK[bound(N + 1) fixedBound B] then
      sym from 
         change 
        fam ShareOK[bound(N + 1) fixedBound B]
        with
         x : bool <- read Share[n, B] ; return ()
        in currentProtocol 
         ( subst
             fam Share[bound (N + 1) fixedBound B] into
             fam ShareOK[bound (N + 1) fixedBound B]
         )     
                 
   ) 
   ) 

   case: (
    using branch when isNotGate(B) of group Shares[fixedBound B]( 

    sym var c terms n, m, B 
          diverge fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
          into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] var c then
    sym var c terms n, m, B 
          diverge fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
          into fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B] var c then    
    sym var r terms n, m, B 
          diverge fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B]
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] var r then 
    sym var s terms n, m, B 
          diverge fam SendBit[bound (N + 2) bound (N + 2) fixedBound B]
          into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] var s then
    using group SharesOK[bound B]
       ( subst fam ShareOK[fixedBound (N + 1) bound B] into
               chn ShareOK[N + 1, B] ) then
      sym from 
       change chn ShareOK[N + 1, B]
       with
         x : bool <- read Share[N + 1, B] ; return ()
        in currentProtocol ( 
          subst chn Share[N + 1, B] into chn ShareOK[N + 1, B] then
          using group SharesOK[bound B]
           ( 
             subst fam ShareOK[fixedBound (N + 1) bound B] 
              into chn ShareOK[N + 1, B]
           ) 
         ) then
      using group SharesOK[bound B]
       ( subst fam ShareOK[bound (N + 1) bound B] into
               fam ShareOK[bound(N + 1) fixedBound B] ) then
      sym from 
       change 
        fam ShareOK[bound (N + 1) fixedBound B]
        with
         x : bool <- read Share[n, B] ; return ()
        in currentProtocol 
         (
         subst fam Share[bound (N + 1) fixedBound B]
          into fam ShareOK[bound (N + 1) fixedBound B] then
         rename s to x in fam ShareOK[bound(N + 1) fixedBound B]   
         )          
   )
   ) 

   case:(
    using branch when isXorGate(B) of group Shares[fixedBound B]( 

    sym var c terms n, m, B 
          diverge fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
          into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] var c then
    sym var c terms n, m, B 
          diverge fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
          into fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B] var c then    
    sym var r terms n, m, B 
          diverge fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B]
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] var r then 
    sym var s terms n, m, B 
          diverge fam SendBit[bound (N + 2) bound (N + 2) fixedBound B]
          into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] var s then 
      using group SharesOK[bound B]
       ( subst fam ShareOK[fixedBound (N + 1) bound B] into
               chn ShareOK[N + 1, B] then
         rename x to a in chn ShareOK[N + 1, B] then 
         subst fam ShareOK[fixedBound (N + 1) bound B] into
               chn ShareOK[N + 1, B] then 
         rename x to y, a to x in chn ShareOK[N + 1, B] ) then       
     sym from 
        change 
        chn ShareOK[N + 1, B]
        with
         x : bool <- read Share[N + 1, B] ; return ()
        in currentProtocol 
        ( 
        subst chn Share[N + 1, B] into chn ShareOK[N + 1, B] then 
        using group SharesOK[bound B] 
         (subst fam ShareOK[fixedBound (N + 1) bound B] into
               chn ShareOK[N + 1, B] then
         rename x to a in chn ShareOK[N + 1, B] then 
         subst fam ShareOK[fixedBound (N + 1) bound B] into
               chn ShareOK[N + 1, B] then 
         rename x to y, a to x in chn ShareOK[N + 1, B]
         ) 
        ) then
     using group SharesOK[bound B]
       ( subst fam ShareOK[bound (N + 1) bound B] into
               fam ShareOK[bound (N + 1) fixedBound B] then
         rename x to a in fam ShareOK[bound (N + 1) fixedBound B] then 
         subst fam ShareOK[bound (N + 1) bound B] into
               fam ShareOK[bound (N + 1) fixedBound B] then 
         rename x to y, a to x in fam ShareOK[bound (N + 1) fixedBound B] ) then    
     sym from 
      change 
        fam ShareOK[bound (N + 1) fixedBound B]
        with
         x : bool <- read Share[n, B] ; return ()
        in currentProtocol (
            subst fam Share[bound (N + 1) fixedBound B] 
             into fam ShareOK[bound (N + 1) fixedBound B]
            )
  )

   )

   case: (
    on branch n < m of family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] (
    using group SharesOK[bound B]( 
    subst fam ShareOK[bound (N + 1) bound B] 
        into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
    rename x to a in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
    subst fam ShareOK[bound (N + 1) bound B] 
        into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
    rename x to y, a to x in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
    ) 
  ) then 
  call inIndSym7 then
   using group SharesOK[bound B]
        (
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
         rename x to a in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then     
         rename x to yn, a to xn 
          in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then    
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
         rename x to a in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
         rename x to ym, a to xm 
          in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
         rename xm to a, xn to xm, yn to xn, ym to yn, a to ym 
          in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then        
         rename indices to x, y, z
           in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then     
         subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then         
         rename indices to n, m, k
           in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then     
         rename s to b in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]       
        ) then
       sym from 
         change 
        fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
        with
         r : bool <- read RcvdBit[n, m, B] ;  return ()
        in currentProtocol
       (
         using branch when isAndGate(B)
         of group Shares[fixedBound B]
         (subst fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B] 
           into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]  )
       ) then
       on branch n < m of 
        family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] 
       (subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
         into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
       ) then
       on branch m < n of 
        family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] 
       (subst fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
         into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
       ) then
       unsplit fam ShareOK[bound (N + 1) bound B] 
        and fam ShareOK[fixedBound (N + 1) bound B] inside group SharesOK[bound B] then
       using group SharesOK[bound B]
        ( on branch m = n 
          of family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] 
          (
            subst fam ShareOK[bound (N + 2) bound B] 
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
            rename x to a in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
            subst fam ShareOK[bound (N + 2) bound B] 
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
            rename x to y, a to x 
              in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] 
          )   
        ) then
        split fam ShareOK[bound (N + 2) bound B] inside group SharesOK[bound B] then   
        sym from 
         change 
        fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
        with
         c : bool <- read Ctrb[n, m, B] ; return ()
        in currentProtocol
        (
         sym from 
          change 
        fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
        with
         (when (n < m) --> 
           c : bool <- read Ctrb[n, m, B] ;  return ()
         )
         ;;
         (when (m < n) --> 
           c : bool <- read Ctrb[n, m, B] ;  return ()
         )
         ;;
         (when (m = n) --> 
           c : bool <- read Ctrb[n, m, B] ;  return ()
         )
        in currentProtocol
         (merge cases for fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] ) then
        case distinction on family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
        (
        
         case: (
         using branch when isAndGate(B) of
          group Shares[fixedBound B]
          (using branch when n < m of
            family Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
           (subst fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]) 
          )
        )
         
         case: (
         using branch when isAndGate(B) of
          group Shares[fixedBound B]
          (using branch when m < n of
            family Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
           (subst fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]) 
          )
        ) 
         
         case:   (
         using branch when isAndGate(B) of
          group Shares[fixedBound B]
          (using branch when n = m of
            family Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
           (subst fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]) 
          )
        ) 
        
        )
        ) then
  call inIndSym10 then
  subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B] 
            into fam ShareOK[bound (N + 1) fixedBound B] then
  call inIndSym11 then 
  subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
   into chn ShareOK[N + 1, B] then
  call inIndSym12 
   )  

  ) then
  merge cases for fam SharesOK[fixedBound B] then
  call addInitOK 

  )
)

.

strict subproof asym0 =
  sym from 
   change fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
     with is : unit <- read InShare$-OK[m, n, i] ;  return ()
       in currentProtocol
  (subst fam InShare$-OK[bound (N + 2) bound (N + 2) dependentBound I] 
    into fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I] 
  )        
 . 

strict subproof asym1 =
  sym from
    change 
     fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I]
    with
       s : unit <- read InShare$Sum-OK[N, n, i] ; 
       x : unit <- read In-OK[n, i] ;
       return () 
    in currentProtocol
  (subst fam In-OK[bound (N + 2) dependentBound I]
    into fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I] then
   subst fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
    into fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I]
  )             
 .
 
 strict subproof asym2 = 
  compose fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
   with fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I] in group then
sym from 
  change 
   fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
  with
        (when (0 = m) -->
           in : unit <- read InShare$-OK[m, n, i] ; return () 
        )
        ;;
        (otherwise -->
           s : unit <- read InShare$Sum-OK[m - 1, n, i] ; 
           x : unit <- read InShare$-OK[m, n, i] ;
              return () 
        )
        in currentProtocol (
in the presence of 
   fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I],
   fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]
rewrite 
 group InShare$-OK[bound N + 1 bound N + 2 dependentBound I] and InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I]
 to (
    (family InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I]
     indices: m ,n ,i 
     bounds: bound N + 1 bound N + 2 dependentBound I ::= 
     is : bool <- read InShare$-Sum[m ,n ,i] ; return ()
    ) 
    || 
    (family InShare$-OK[bound N + 1 bound N + 2 dependentBound I]
      indices: m ,n ,i 
      bounds: bound N + 1 bound N + 2 dependentBound I ::= 
      x : bool <- read In [n ,i] ; return ()
    )
   )
   by induction on m bound M
(
turn otherwise into neg 
     for fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
case distinction on  family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
  case: (
    subst fam InShare$-OK[fixedBound M bound N + 2 dependentBound I]
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]     
  )

  case: (
    subst fam InShare$Sum-OK[bound M bound (N + 2) dependentBound I] 
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
subst fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
rename is to s in fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  )
) then 
sym from 
             change 
              fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
             with 
              is : bool <- read InShare$-Sum[M, n, i] ;  return ()
             in currentProtocol
(
sym from 
    change 
              fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
             with 
              ( when (M = 0) --> 
                 is : bool <- read InShare$-Sum[M, n, i] ;  return ()
              )
              ;;
              ( when (not (M = 0)) --> 
                 is : bool <- read InShare$-Sum[M, n, i] ;  return ()
              )
             in currentProtocol
    (merge cases for 
      fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]  
    ) then
   turn otherwise into neg 
      for fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I] then
    case distinction on family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
 
     case: (
     
 subst branch when m = 0 of 
    fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
    into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  then
      drop read branch when not (m = N + 1) of  
            fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
         from fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
     )

     case: (
      subst branch when not (m = 0) of 
    fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
    into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  then
      drop read branch when not (m = N + 1) of  
            fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
         from fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
     )
    ) then 
     turn neg into otherwise 
      for fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
)
)
) then
decompose fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
   with fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
 . 

strict subproof asym01 =
  sym from change 
        fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I]
        with
          x : unit <- read In-OK[n, i] ; return ()
        in currentProtocol
 ( subst fam In-OK[bound (N + 2) dependentBound I] 
     into fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] then
    rename in to x in 
     fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I]     
 )   
 .  

strict subproof indProofInitOK =
 in the presence of fam In-OK[bound N + 2 dependentBound I] 
rewrite group InitOK[bound (N + 2) bound (N + 2) dependentBound I]
 to
   (family InShare$-OK[bound (N + 2) bound (N + 2) dependentBound I] 
     indices: m, n, i
     bounds: bound (N + 2) bound (N + 2) dependentBound I
::=
 x : unit <- read In-OK[n, i] ; return ()
)
||
(family InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]  
     indices: m, n, i
     bounds: bound (N + 1) bound (N + 2) dependentBound I
::=
x : unit <- read In-OK[n, i] ; return ()
)
||
(family InShareOK[bound (N + 2) bound (N + 2) dependentBound I] 
     indices: m, n, i
     bounds: bound (N + 2) bound (N + 2) dependentBound I
::=
x : unit <- read In-OK[n, i] ; return ()
)
 by induction on m bound M (
case distinction on
family InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
   (
    case:(
    using group InitOK[bound M bound (N + 2) dependentBound I](
    subst fam InShare$Sum-OK[bound M bound (N + 2) dependentBound I]
     into fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
    )
    )

    case:(
      idle
    ) 
   ) then
merge cases for fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I] then
   subst fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
    into fam InShareOK[fixedBound M bound (N + 2) dependentBound I] then
   turn otherwise into neg 
    for fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
   case distinction on family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
   case: (
    subst  fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
     into  fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
   )  
   case: 
   (using group InitOK[bound M bound N + 2 dependentBound I ](
    subst fam InShare$Sum-OK[bound M bound (N + 2) dependentBound I]
     into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] ) then
    subst fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
     into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
   ) 
   ) then 
   merge cases for fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
) 
. 

strict subproof symInput =
 sym from 
             change 
              fam ShareOK[bound (N + 1) fixedBound B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol(  
     using group Wires-OK[fixedBound B]
     (
       using branch when isInputGate(B) of channel Wire-OK[B]
       (subst chn Wire-OK[B] 
         into fam ShareOK[bound (N + 1) fixedBound B]
       )
     ) then
     unit-ext on fam ShareOK[bound (N + 1) fixedBound B] at 1 then
     rename in to x in fam ShareOK[bound (N + 1) fixedBound B] 
             ) 
.   

strict subproof symInputC =
  sym from 
             change 
              chn ShareOK[N + 1, B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
   (
            using group Wires-OK[fixedBound B]
            (using branch when isInputGate(B)
              of channel Wire-OK[B]
             (subst chn Wire-OK[B]
              into chn ShareOK[N + 1, B]
             ) )
              then
              unit-ext on chn ShareOK[N + 1, B] at 1 then 
              rename in to x in chn ShareOK[N + 1, B]
  ) 
. 

strict subproof wireSymNot =
   sym from 
             change 
              fam ShareOK[bound (N + 1) fixedBound B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
   (
     using group Wires-OK[fixedBound B]
     (
       using branch when isNotGate(B) 
       of channel Wire-OK[B]
       (subst chn Wire-OK[B] 
         into fam ShareOK[bound (N + 1) fixedBound B])
     ) 
   )    
 .
 
 strict subproof wireSymNotC =
    sym from 
             change 
              chn ShareOK[N + 1, B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
   (
            using group Wires-OK[fixedBound B]
            (using branch when isNotGate(B)
              of channel Wire-OK[B]
             (subst chn Wire-OK[B]
              into chn ShareOK[N + 1, B]) 
            )
  )
 .

 strict subproof wireSymXor =
  sym from 
             change 
              fam ShareOK[bound (N + 1) fixedBound B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
   (
     using group Wires-OK[fixedBound B]
     (
       using branch when isXorGate(B) 
       of channel Wire-OK[B]
       (subst chn Wire-OK[B] 
         into fam ShareOK[bound (N + 1) fixedBound B])
     ) 
   )    
 .

strict subproof wireSymXorC =
  sym from 
             change 
              chn ShareOK[N + 1, B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
   (
            using group Wires-OK[fixedBound B]
            (using branch when isXorGate(B)
              of channel Wire-OK[B]
             (subst chn Wire-OK[B]
              into chn ShareOK[N + 1, B]) 
            )
  )
 .
 strict subproof wireSymAnd =
  sym from 
             change 
              fam ShareOK[bound (N + 1) fixedBound B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
   (
     using group Wires-OK[fixedBound B]
     (
       using branch when isAndGate(B) 
       of channel Wire-OK[B]
       (subst chn Wire-OK[B] 
         into fam ShareOK[bound (N + 1) fixedBound B])
     ) 
   )          
 . 

 strict subproof wireSymAndC =
   sym from 
             change 
              chn ShareOK[N + 1, B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
   (
            using group Wires-OK[fixedBound B]
            (using branch when isAndGate(B)
              of channel Wire-OK[B]
             (subst chn Wire-OK[B]
              into chn ShareOK[N + 1, B]) 
            )
  )
 .

strict subproof symRcvdBit =
    sym from
             change 
              fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
             with 
              (when (m < n) --> 
                sb : unit <- read SendBit-OK[m, n, B]  ;
                xm : unit <- read ShareOK[m, wire0(B)] ;
                xn : unit <- read ShareOK[n, wire0(B)] ;
                ym : unit <- read ShareOK[m, wire1(B)] ; 
                yn : unit <- read ShareOK[n, wire1(B)] ; 
                return () 
              ) ;;
              (when (n <= m) --> 
                sb : unit <- read SendBit-OK[m, n, B]  ;
                xm : unit <- read ShareOK[m, wire0(B)] ;
                xn : unit <- read ShareOK[n, wire0(B)] ;
                ym : unit <- read ShareOK[m, wire1(B)] ; 
                yn : unit <- read ShareOK[n, wire1(B)] ; 
                return () 
              )
             in currentProtocol
  ( merge cases for 
     fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
  )
.

strict subproof indWiresShares =
 in the presence of 
  fam InitOK[bound (N + 2) bound (N + 2) dependentBound I]
  rewrite 
   group Wires-OK[bound K] and SharesOK[bound K]
  to
  ( 
 (family SharesOK[bound K] 
    indices: k
    bounds: bound K
::=
(when (isInputGate(k)) -->
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(family ShareOK[bound (N + 1) bound K]
  indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
  indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
)
;;
(when (isNotGate(k)) -->
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(family ShareOK[bound (N + 1) bound K]
  indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
  indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
)
;;
(when (isXorGate(k)) -->
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(family ShareOK[bound (N + 1) bound K]
  indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
  indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
)
;;
(when (isAndGate(k)) -->
(
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return ()
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (m < n) -->
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return ()
)
;;
(when (n <= m) -->
 rb : unit <- read RcvdBit-OK[n, m, k] ; return rb
)
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return ()
)
;;
(when (m <= n) -->
 sb : unit <- read SendBit-OK[n, m, k] ; return sb
)
)
||
(family ShareOK[bound (N + 1) bound K]
  indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
  indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
 )
)
||
(family Wires-OK[bound K] 
  indices: k
  bounds: bound K
::=
family Wire-OK[bound K] 
 indices: k
 bounds: bound K
::=
(when (isInputGate(k)) -->
 in : unit <- read In-OK[wire0(k), wire1(k)] ; return in
)
;;
(when (isNotGate(k)) -->
 w : unit <- read Wire-OK[wire0(k)] ; return ()
)
;;
(when (isXorGate(k)) -->
 w0 : unit <- read Wire-OK[wire0(k)] ;
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
;;
(when (isAndGate(k)) -->
 w0 : unit <- read Wire-OK[wire0(k)] ;
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
)
)
  by induction on k bound B 
(  
ungroup fam InitOK[bound (N + 2) bound (N + 2) dependentBound I] then
remove fam ShareOK[bound (N + 1) bound B] from group SharesOK[bound B] then
         merge cases for fam ShareOK[bound (N + 1) bound B] then
         remove fam ShareOK[fixedBound (N + 1) bound B]
           from group SharesOK[bound B] then  
         merge cases for fam ShareOK[fixedBound (N + 1) bound B] then
         unsplit fam ShareOK[bound (N + 1) bound B]
          and fam ShareOK[fixedBound (N + 1) bound B] then
 case distinction on group SharesOK[fixedBound B](
  case: (
    subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
          into fam ShareOK[bound (N + 1) fixedBound B] then
           call symInput  then
           subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
           into chn ShareOK[N + 1, B] then
           call symInputC 
  )

 case: (
    subst fam ShareOK[bound (N + 2) bound B]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          unit-ext on fam ShareOK[bound (N + 1) fixedBound B] at 1 then
           call wireSymNot then
           subst fam ShareOK[bound (N + 2) bound B]
           into chn ShareOK[N + 1, B] then
           unit-ext on chn ShareOK[N + 1, B] at 1 then
           call wireSymNotC    
  )

  case: (
     subst fam ShareOK[bound (N + 2) bound B]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          rename w to w0 in fam ShareOK[bound (N + 1) fixedBound B] then           
          subst fam ShareOK[bound (N + 2) bound B]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          rename w to w1 in fam ShareOK[bound (N + 1) fixedBound B] then           
          call wireSymXor then
           subst fam ShareOK[bound (N + 2) bound B]
           into chn ShareOK[N + 1, B] then
           rename w to w0 in chn ShareOK[N + 1, B] then
           subst fam ShareOK[bound (N + 2) bound B]
           into chn ShareOK[N + 1, B] then
           rename w to w1 in chn ShareOK[N + 1, B] then
           call wireSymXorC        
  )

    case: (
    case distinction on 
          family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         (
           case: (
            subst fam ShareOK[bound (N + 2) bound B]
             into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
            rename w to w0 in 
             fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
            subst fam ShareOK[bound (N + 2) bound B]
             into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
            rename w to w1 in 
             fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
           )
           
           case: ( idle )
         
         ) then
         rename indices to m, n, k in  
          fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
         call symRcvdBit then 
         case distinction on
          family RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         ( 
           case: (
            using branch when m < n of
            family  SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
            ( subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
               into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
            ) then
            subst fam ShareOK[bound (N + 2) bound B]
             into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
            subst fam ShareOK[bound (N + 2) bound B]
             into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
            rename w to w0 in 
             fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
            subst fam ShareOK[bound (N + 2) bound B]
             into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
            subst fam ShareOK[bound (N + 2) bound B]
             into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
            rename w to w1 in 
             fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
           )
           
           case: (
           using branch when n <= m of 
           family  SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
           (
            diverge on
             fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] 
             with
             fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
             var rb
           )
              
           )
          ) then 
          rename indices to n, m, k in  
          fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]  then
      case distinction on
  family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
 (
  
   case: (
    using branch when n < m of 
     family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
    (subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
      into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
    ) 
   )
   
  case: (
    using branch when m < n of 
     family RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
    (subst fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
      into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
    ) 
   )
   
   case: (
     subst fam ShareOK[bound (N + 2) bound B]
      into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
     rename w to w0 in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
      subst fam ShareOK[bound (N + 2) bound B]
      into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
     rename w to w1 in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
   )
 
 ) then 
 merge cases for 
  fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
          then
      in the presence of fam  Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
      rewrite family CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
      to 
       w0 : unit <- read Wire-OK[wire0(B)] ;
       w1 : unit <- read Wire-OK[wire1(B)] ;
       return () 
      by induction on m bound M
      (
        case distinction on family CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B](
          case: (
            subst fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
             into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
          )
          case: (subst fam CtrbSum-OK[bound N + 2 bound M fixedBound B]
         into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B] then
       subst fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
         into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]) 

        ) then
      merge cases for 
        fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
      ) then
          subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          call wireSymAnd then
          subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
           into chn ShareOK[N + 1, B] then
          call wireSymAndC

    )
 ) then 
 call addInitOK then
         split fam ShareOK[bound (N + 2) bound B] on first index then
         move family ShareOK[bound (N + 1) bound B] 
          on each branch of group SharesOK[bound B] then
         move family ShareOK[fixedBound (N + 1) bound B] 
          on each branch of group SharesOK[bound B] 
  )  
.

strict subproof addHidden = 
  sym from 
  extend currentProtocol 
  with internal family Hidden
  indices: k
  bounds: bound K 
  typed: unit
  assigned:
   return ()
 ( absorb fam Hidden[bound K]  
 )
.

strict subproof addHiddenGroup =
group  
  fam Hidden[bound K]
in HiddenGroup 
indices: k
bounds: bound K 
.

strict subproof symSharesInput =
  sym from 
             change 
              chn Share[N + 1, B]
             with 
              in : bool <- read InShare[N + 1, wire0(B),wire1(B)] ; 
              w : unit <- read Wire-OK[B] ;
              return in
             in currentProtocol
            (
              rename in to is in chn Share[N + 1, B] then
              using group Wires-OK[bound K]
              (subst fam Wire-OK[bound K]
                into chn  Share[N + 1, B]
              ) then  
              rename in to x, is to in
               in chn Share[N + 1, B]
            )             
 .

 strict subproof symSharesNot = 
  sym from 
            change 
              chn Share[N + 1, B]
             with 
              w : unit <- read Wire-OK[B] ;
              x : bool <- read Share[N + 1, wire0(B)] ; 
              return neg(x)
             in currentProtocol
           (
             using group Wires-OK[bound K]
              (subst fam Wire-OK[bound K]
                into chn  Share[N + 1, B]
              )  
           ) 
 .
 
 strict subproof symSharesXor = 
  sym from 
            change 
              chn Share[N + 1, B]
             with 
              w : unit <- read Wire-OK[B] ;
              x : bool <- read Share[N + 1, wire0(B)] ; 
              y : bool <- read Share[N + 1, wire1(B)] ; 
              return xor((x, y))
             in currentProtocol
           (
             using group Wires-OK[bound K]
              (subst fam Wire-OK[bound K]
                into chn  Share[N + 1, B]
              )  
           ) 
 .
  
 strict subproof symSharesAnd = 
  sym from 
            change 
              chn Share[N + 1, B]
             with 
              bs : bool <- read CtrbSum[N + 1, N + 1, B] ; 
              w : unit <- read Wire-OK[B] ; 
              return bs
             in currentProtocol
           (
             using group Wires-OK[bound K]
              (subst fam Wire-OK[bound K]
                into chn  Share[N + 1, B]
              )  
           )
 .

strict subproof indTimingShares =
 in the presence of 
 fam InitOK[bound N + 2 bound N + 2 dependentBound I],
 fam Wires-OK[bound K],
 fam ShareOK[fixedBound (N + 1) bound K],
 fam CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
rewrite group HiddenGroup[bound K] and Shares[bound K]
  to 
  (
(family HiddenGroup[bound K] 
  indices: k
  bounds: bound K
::=
(family Hidden[bound K] 
  indices: k
  bounds: bound K
::=
return ()
)
)
||
 (
    family Shares[bound K]
     indices: k
  bounds: bound K
::=
(
(when (isInputGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <- read InShare[n , wire0(k) , wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 in : bool <- read InShare[N + 1, wire0(k) , wire1(k)] ; 
 w : unit <- read  Wire-OK[k] ; 
 return in
) 
)
)
;;
(when (isNotGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <- read Share[n , wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read  Wire-OK[k] ;
 x : bool <- read Share[N + 1 , wire0(k)] ; 
 return neg(x)
) 
)
)
;;
(when (isXorGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <- read Share[n , wire0(k)] ;  
 y : bool <- read Share[n , wire1(k)] ; 
 return  xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read  Wire-OK[k] ;
 x : bool <- read Share[N + 1, wire0(k)] ; 
 y : bool <- read Share[N + 1, wire1(k)] ; 
 return  xor((x, y))
)
)
)
;;
when (isAndGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <- read SendBit[n, m, k] ; return s
) 
;;
(when (m = n) -->
 x : bool <- read Share[n , wire0(k)] ;
 y : bool <- read Share[n , wire1(k)] ; 
 return  **((x, y))
) 
;;
(when (m < n) -->
 r : bool <- read RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (0 = m) -->
 b : bool <- read Ctrb[n, 0, k] ; return b
) 
;;
(when not (0 = m) -->
 b : bool <- read Ctrb[n, m, k] ; 
 s : bool <- read CtrbSum[n, m - 1, k] ; 
 return xor((s, b))
) 
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read SendBit[m, n, k] ;
 xm : bool <- read Share[m , wire0(k)] ; 
 xn : bool <- read Share[n , wire0(k)] ; 
 ym : bool <- read Share[m , wire1(k)] ; 
 yn : bool <- read Share[n, wire1(k)] ; 
 return xor( ( xor( (**((xm, yn)), **((xn, ym))) ) , b) ) 
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <- read Share[n , wire0(k)] ;
 y : bool <- read Share[n , wire1(k)] ; 
  samp flip (())
)
;;
(when (m <= n) -->
 sb : bool <- read SendBit[n, m, k] ; return sb
)
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[N + 1, N + 1, k] ;
 w : unit <- read Wire-OK[k] ; 
 return bs
)
)
) 
 )
)
  by induction on k bound B (
ungroup fam InitOK[bound N + 2 bound N + 2 dependentBound I] then
case distinction on group Shares[fixedBound B] (
  case: (
     subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I] 
      into chn Share[N + 1, B] then 
     call symSharesInput
  )
  case: (
    subst fam ShareOK[fixedBound (N + 1) bound K] 
      into chn Share[N + 1, B] then 
     call symSharesNot
  )
  case: (
    subst fam ShareOK[fixedBound (N + 1) bound K] 
      into chn Share[N + 1, B] then 
     rename w to w0 in chn Share[N + 1, B] then
     subst fam ShareOK[fixedBound (N + 1) bound K] 
      into chn Share[N + 1, B] then 
     rename w to w1 in chn Share[N + 1, B] then      
     call symSharesXor
  )
  case: (
    subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
      into chn Share[N + 1, B] then    
     call symSharesAnd
  )
) then
call addInitOK
)

.

strict subproof addCtrbsOK = 
group  
   fam SendBit-OK[bound N + 2 bound N + 2 bound K],
   fam RcvdBit-OK[bound N + 2 bound N + 2 bound K],
   fam Ctrb-OK[bound N + 2 bound N + 2 bound K],
   fam CtrbSum-OK[bound N + 2 bound N + 2 bound K]
in Ctrbs-OK 
indices: k
bounds: bound K .

strict subproof restoreCtrbsOK = 
 call addCtrbsOK then
 sym from 
  change fam Ctrbs-OK[bound K]
    with 
    (
(when isInputGate(k) --> (
 (family SendBit-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k 
    bounds: bound N + 2 bound N + 2 bound K ::= 
    s : unit <- read SendBit-OK[n ,m ,k ] ;
    return s
 ) || 
 (family RcvdBit-OK[bound N + 2 bound N + 2 bound K] 
    indices: n ,m ,k 
    bounds: bound N + 2 bound N + 2 bound K ::= 
    r : unit <- read RcvdBit-OK[n ,m ,k ] ; 
    return r 
 ) || 
 (family CtrbSum-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k 
    bounds: bound N + 2 bound N + 2 bound K ::= 
    c : unit <- read CtrbSum-OK[n ,m ,k] ; return c
 ) || 
 (family Ctrb-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k 
    bounds: bound N + 2 bound N + 2 bound K ::= 
    c : unit <- read Ctrb-OK[n ,m ,k ] ; return c 
 ) 
 )
) 
 ;; 
( when isNotGate(k) --> (
 (family SendBit-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k 
    bounds: bound N + 2 bound N + 2 bound K ::= 
    s : unit <- read SendBit-OK[n ,m ,k ] ; return s
 ) || 
 (family RcvdBit-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    r : unit <- read RcvdBit-OK[n ,m ,k ] ; return r 
 ) || 
 (family CtrbSum-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    c : unit <- read CtrbSum-OK[n ,m ,k ] ; return c 
 ) || 
 (family Ctrb-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    c : unit <- read Ctrb-OK[n ,m ,k ] ; return c 
 )
 )
)   
;; 
( when isXorGate(k) --> (
 (family SendBit-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k 
    bounds: bound N + 2 bound N + 2 bound K ::= 
    s : unit <- read SendBit-OK[n ,m ,k ] ; return s
 ) || 
 (family RcvdBit-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    r : unit <- read RcvdBit-OK[n ,m ,k ] ; return r 
 ) || 
 (family CtrbSum-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    c : unit <- read CtrbSum-OK[n ,m ,k ] ; return c 
 ) || 
 (family Ctrb-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    c : unit <- read Ctrb-OK[n ,m ,k ] ; return c 
 )
 )
)    
;; 
(
when isAndGate(k)--> (
 (family SendBit-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    (
    (when n < m --> 
     w0 : unit <- read Wire-OK[wire0(k)] ; 
     w1 : unit <- read Wire-OK[wire1(k)] ; 
     return ()
   ) 
   ;; 
   (when m <= n --> 
    sb : unit <- read SendBit-OK[n ,m ,k ] ; 
    return sb
   )
   ) 
 ) || 
 (family RcvdBit-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    (
    (when m < n --> 
      w0 : unit <- read Wire-OK[wire0(k)] ; 
      w1 : unit <- read Wire-OK[wire1(k)] ;
      return ()
    ) 
    ;; 
    (when n <= m --> 
      rb : unit <- read RcvdBit-OK[n ,m ,k ] ; 
      return rb
    )
    ) 
 ) || 
 (family CtrbSum-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
    w0 : unit <- read Wire-OK[wire0(k)] ;
    w1 : unit <- read Wire-OK[wire1(k)] ;
    return ()
 ) || 
 (family Ctrb-OK[bound N + 2 bound N + 2 bound K]
    indices: n ,m ,k bounds: bound N + 2 bound N + 2 bound K ::= 
     w0 : unit <- read Wire-OK[wire0(k)] ;
     w1 : unit <- read Wire-OK[wire1(k)] ; 
     return ()
 )
 )
)
)
      in currentProtocol
  ( combine fam Ctrbs-OK[bound K] then
    call addCtrbsOK 
  )         
.  

strict subproof introShareSumOK = 
 sym from 
  extend currentProtocol 
  with internal family ShareSum-OK 
  indices: m, k 
  bounds: bound N + 1 bound K 
  typed: unit
  assigned:
   s : bool  <- read ShareSum[m, k] ;
   return ()
 ( absorb fam ShareSum-OK[bound N + 1 bound K]  
 )
.

strict subproof sym20 =
 sym from  
         branch 
          when isAndGate(k)
         of
          fam Adv[bound K]
         change
          fam  OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K]
         with
          (when (n < N + 1) -->
             x : unit <- read ShareSum-OK[N, wire1(k)] ; return ()
          )  
          ;;
          (when (n = N + 1) -->
             oc : unit <- read OTChcRcvd-1OtAdv[n, N + 1, k] ; return oc
          )
          in
          (
          branch 
           when isAndGate(k)
         of
          fam Adv[bound K]
         change
          fam  OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K]
         with
          (when (n < N + 1) -->
             x : unit <- read ShareSum-OK[N, wire0(k)] ; return ()
          )   
          ;;
          (when (n = N + 1) -->
             oc : unit <- read OTChcRcvd-0OtAdv[n, N + 1, k] ; return oc
          )
          in
          currentProtocol)
       (
       on branch isAndGate(k)
          of group Adv[bound K]
         (on branch n < N + 1 
           of family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K]
           ( subst fam ShareSum-OK[bound (N + 1) bound K] 
              into fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] then
             rename s to x 
              in fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K]      
           ) then
           on branch n < N + 1
           of family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K]
           ( subst fam ShareSum-OK[bound (N + 1) bound K] 
              into fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] then
             rename s to x 
              in fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K]      
           )
           
         )
     )     
   . 

strict subproof symShareSumOK0 =
  sym from
        change 
         fam ShareSum-OK[fixedBound M bound K]
        with
         s : bool <- read ShareSum[M, k] ;  return ()
        in 
        currentProtocol
       (call subst1 then
       rename s to x in fam ShareSum-OK[fixedBound M bound K]
       )                             
 .
 
strict subproof subst1 = 
    subst branch when (0 = m)
    of fam ShareSum[bound (N + 2) bound K]
    into fam  ShareSum-OK[fixedBound M bound K] 

 . 
strict subproof symShareSumOKM = 
  sym from
        change 
         fam ShareSum-OK[fixedBound M bound K]
        with
         s : bool <- read ShareSum[M, k] ;  return ()
        in 
        currentProtocol
       (call subst2 then
       rename xm to x, xs to s 
         in fam ShareSum-OK[fixedBound M bound K]
       )        
 .

strict subproof subst2 = 
 subst branch when not (0 = m)
    of fam ShareSum[bound (N + 2) bound K]
    into fam  ShareSum-OK[fixedBound M bound K] 
 . 

strict subproof inIndSym9 =
 sym from 
         change 
        fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
        with
         c : bool <- read Ctrb[n, m, B] ; return ()
        in currentProtocol
        (
         sym from 
          change 
        fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
        with
         (when (n < m) --> 
           c : bool <- read Ctrb[n, m, B] ;  return ()
         )
         ;;
         (when (m < n) --> 
           c : bool <- read Ctrb[n, m, B] ;  return ()
         )
         ;;
         (when (m = n) --> 
           c : bool <- read Ctrb[n, m, B] ;  return ()
         )
        in currentProtocol
         (merge cases for fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] ) then
        on branch n < m of 
           family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
         (
         using branch when isAndGate(B) of
          group Shares[fixedBound B]
          (using branch when n < m of
            family Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
           (subst fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]) 
          )
        ) then 
        on branch m < n of 
           family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
         (
         using branch when isAndGate(B) of
          group Shares[fixedBound B]
          (using branch when m < n of
            family Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
           (subst fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]) 
          )
        ) then 
        on branch n = m of 
           family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
         (
         using branch when isAndGate(B) of
          group Shares[fixedBound B]
          (using branch when n = m of
            family Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
           (subst fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
             into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]) 
          )
        ) 
        )
        .  

`` deltaRealSplit 

channel context deltaRealSplit =

input    In[bound N + 2 dependentBound I] : bool ;
output   Out[bound N + 2 bound K] : bool ;
output   CtrbPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   InPartyAdv[bound N + 2 dependentBound I] : bool ;
output   InRcvdPartyAdv[bound N + 2 dependentBound I] : unit ;
output   InSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   InShare$PartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   InShare$-SumPartyAdv[bound N + 1 bound N + 2 dependentBound I] : bool ;
output   OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] : unit ;
output   OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] : unit ;
output   OTChcRcvd-0OtAdv[bound N + 2 bound N + 1 bound K] : unit ;
output   OTChcRcvd-1OtAdv[bound N + 2 bound N + 1 bound K] : unit ;
output   OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTOutOtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OutPartyAdv[bound N + 2 bound K] : bool ;
output   OutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OutShareSumPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   RcvdOutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SendBitPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SendInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   SendOutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SharePartyAdv[bound N + 2 bound K] : bool
 .

protocol pInt2 =
 newfamily Ctrb[bound N + 2 bound N + 2 bound K ]
           indices: n, m, k
           bounds: bound N + 2 bound N + 2 bound K : bool in   
 newfamily CtrbSum[bound N + 2 bound N + 2 bound K ]
           indices: n, m, k
           bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily InShare[bound N + 2 bound N + 2 dependentBound I]
           indices: n, m, i
           bounds: bound N + 2 bound N + 2 dependentBound I : bool in
 newfamily InShare$[bound N + 2 bound N + 2 dependentBound I]
           indices: m, n, i
           bounds: bound N + 2 bound N + 2 dependentBound I : bool in
 newfamily InShare$-Sum[bound N + 1 bound N + 2 dependentBound I]
           indices: m, n, i
           bounds: bound N + 1 bound N + 2 dependentBound I : bool in          
 newfamily OutShare[bound N + 2 bound N + 2 bound K ]
           indices: n, m, k
           bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily OutShareSum[bound N + 2 bound N + 2 bound K ]
           indices: n, m, k
           bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily RcvdBit[bound N + 2 bound N + 2 bound K ]
           indices: n, m, k
           bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily SendBit[bound N + 2 bound N + 2 bound K ]
           indices: n, m, k
           bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily Share[bound N + 1 bound K ]
           indices: n, k
           bounds: bound N + 1 bound K : bool in
 newfamily Share[fixedBound N + 1 bound K ]
           indices: n, k
           bounds: fixedBound N + 1 bound K : bool in
 newfamily ShareSum[bound N + 2 bound K ]
           indices: m, k
           bounds: bound N + 2 bound K : bool in (
(family Adv[bound K] 
 indices: k 
 bounds: bound K ::= 
 (when isInputGate(k) --> (
 (family SharePartyAdv[bound N + 2 bound K] 
 indices: n ,k 
 bounds: bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read Share[n ,k ] ; return s 
  )
  ;; 
  (when isHonest(n) -->
    s : bool <- read SharePartyAdv[n ,k] ; return s 
  )
 ) || 
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  sb : bool <- read SendBitPartyAdv[n ,m ,k ] ; return sb 
 ) || 
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  rb : bool <- read RcvdBitPartyAdv[n ,m ,k ] ; return rb 
 ) ||
 (family OTOutOtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  out : bool <- read OTOutOtAdv[n ,m ,k ] ; return out
 ) ||
 (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-3OtAdv[n ,m ,k ] ; return om
 ) || 
 (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-2OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-1OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-0OtAdv[n ,m ,k ] ; return om
 ) || 
 (family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-3OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-2OtAdv[n ,m , k ] ; return om 
 ) || 
 (family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-1OtAdv[n ,m ,k] ; return om 
 ) || 
 (family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-0OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-1OtAdv[n ,N + 1 ,k ] ; return oc 
 ) || 
 (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-1OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::=
  oc : unit <- read OTChcRcvd-0OtAdv[n ,N + 1 ,k ] ; return oc
 ) || 
 (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-0OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  oc : bool <- read OTChc-1OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  oc : bool <- read OTChc-0OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSumPartyAdv[n ,m ,k ] ; return b 
 ) || 
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbPartyAdv[n ,m ,k ] ; return b )
)) ;; 
(when isNotGate(k) --> (
 (family SharePartyAdv[bound N + 2 bound K] 
 indices: n ,k 
 bounds: bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read Share[n ,k ] ; return s 
  )
  ;; 
  (when isHonest(n) -->
    s : bool <- read SharePartyAdv[n ,k] ; return s 
  )
 ) || 
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  sb : bool <- read SendBitPartyAdv[n ,m ,k ] ; return sb 
 ) || 
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  rb : bool <- read RcvdBitPartyAdv[n ,m ,k ] ; return rb 
 ) ||
 (family OTOutOtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  out : bool <- read OTOutOtAdv[n ,m ,k ] ; return out
 ) ||
 (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-3OtAdv[n ,m ,k ] ; return om
 ) || 
 (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-2OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-1OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-0OtAdv[n ,m ,k ] ; return om
 ) || 
 (family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-3OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-2OtAdv[n ,m , k ] ; return om 
 ) || 
 (family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-1OtAdv[n ,m ,k] ; return om 
 ) || 
 (family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-0OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-1OtAdv[n ,N + 1 ,k ] ; return oc 
 ) || 
 (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-1OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::=
  oc : unit <- read OTChcRcvd-0OtAdv[n ,N + 1 ,k ] ; return oc
 ) || 
 (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-0OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  oc : bool <- read OTChc-1OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  oc : bool <- read OTChc-0OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSumPartyAdv[n ,m ,k ] ; return b 
 ) || 
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbPartyAdv[n ,m ,k ] ; return b ) 
 )) ;; 
(when isXorGate(k) --> (
 (family SharePartyAdv[bound N + 2 bound K] 
 indices: n ,k 
 bounds: bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read Share[n ,k ] ; return s 
  )
  ;; 
  (when isHonest(n) -->
    s : bool <- read SharePartyAdv[n ,k] ; return s 
  )
 ) || 
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  sb : bool <- read SendBitPartyAdv[n ,m ,k ] ; return sb 
 ) || 
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  rb : bool <- read RcvdBitPartyAdv[n ,m ,k ] ; return rb 
 ) ||
 (family OTOutOtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  out : bool <- read OTOutOtAdv[n ,m ,k ] ; return out
 ) ||
 (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-3OtAdv[n ,m ,k ] ; return om
 ) || 
 (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-2OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-1OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : unit <- read OTMsgRcvd-0OtAdv[n ,m ,k ] ; return om
 ) || 
 (family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-3OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-2OtAdv[n ,m , k ] ; return om 
 ) || 
 (family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-1OtAdv[n ,m ,k] ; return om 
 ) || 
 (family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  om : bool <- read OTMsg-0OtAdv[n ,m ,k ] ; return om 
 ) || 
 (family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-1OtAdv[n ,N + 1 ,k ] ; return oc 
 ) || 
 (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-1OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::=
  oc : unit <- read OTChcRcvd-0OtAdv[n ,N + 1 ,k ] ; return oc
 ) || 
 (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  oc : unit <- read OTChcRcvd-0OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  oc : bool <- read OTChc-1OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  oc : bool <- read OTChc-0OtAdv[n ,m ,k ] ; return oc 
 ) || 
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSumPartyAdv[n ,m ,k ] ; return b 
 ) || 
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbPartyAdv[n ,m ,k ] ; return b ) 
)) ;; 
(when isAndGate(k) --> (
 (family SharePartyAdv[bound N + 2 bound K] 
 indices: n, k 
 bounds: bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read Share[n ,k ] ; return s 
  ) ;; 
  (when isHonest(n) -->
    s : bool <- read SharePartyAdv[n ,k ] ; return s 
  )
  ) || 
  (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read SendBit[n ,m ,k ] ; return s 
  ) ;; 
  (when isHonest(n) -->
    s : bool <- read SendBitPartyAdv[n ,m ,k ] ; return s 
  )
  ) || 
  (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read RcvdBit[n ,m ,k ] ; return s
  ) ;; 
  (when isHonest(n) -->
    s : bool <- read RcvdBitPartyAdv[n ,m ,k ] ; return s 
  )
  ) || 
  (family OTOutOtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(m) -->
    out : bool <- read RcvdBit[m ,n ,k ] ; return out 
  ) ;; 
  (when isHonest(m) -->
    out : bool <- read OTOutOtAdv[n ,m ,k ] ; return out 
  )
  ) || 
  (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isHonest(n))) -->
    b : bool <- read SendBit[n ,m ,k ] ;
    x : bool <- read Share[n , wire0(k)] ;
    y : bool <- read Share[n , wire1(k)] ; 
    return ()
  ) ;; 
  (when ((m <= n) or (isSemiHonest(n))) -->
    om : unit <- read OTMsgRcvd-3OtAdv[n ,m ,k ] ; return om 
  )
  ) ||
  (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isHonest(n) )) -->
    b : bool <- read SendBit[n ,m ,k ] ;
    x : bool <- read Share[n , wire0(k)] ; 
    y : bool <- read Share[n , wire1(k)] ; 
    return ()
  ) ;; 
  (when ((m <= n) or (isSemiHonest(n))) -->
    om : unit <- read OTMsgRcvd-2OtAdv[n ,m ,k ] ; return om
  )
  ) || 
  (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isHonest(n))) -->
    b : bool <- read SendBit[n ,m ,k ] ;
    x : bool <- read Share[n , wire0(k)] ;
    y : bool <- read Share[n , wire1(k)] ; 
    return ()
  ) ;; 
  (when ((m <= n) or (isSemiHonest(n))) -->
    om : unit <- read OTMsgRcvd-1OtAdv[n ,m ,k ] ; return om
  )
  ) || 
  (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
   (when ((n < m) and (isHonest(n))) -->
     b : bool <- read SendBit[n ,m ,k ] ;
     x : bool <- read Share[n , wire0(k)] ;
     y : bool <- read Share[n , wire1(k)] ; 
     return ()
   ) ;;
   (when ((m <= n) or (isSemiHonest(n))) -->
     om : unit <- read OTMsgRcvd-0OtAdv[n ,m ,k ] ; return om
   )
   ) ||
   (family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isSemiHonest(n))) -->
     b : bool <- read SendBit[n ,m ,k ] ;
     x : bool <- read Share[n , wire0(k)] ;
     y : bool <- read Share[n , wire1(k)] ; 
     return xor((xor((x ,y )), b))
  ) ;; 
  (when ((m <= n) or (isHonest(n))) -->
    om : bool <- read OTMsg-3OtAdv[n ,m ,k ] ; return om
  )
  ) || 
  (family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isSemiHonest(n))) -->
    b : bool <- read SendBit[n ,m ,k ] ;
    x : bool <- read Share[n, wire0(k)] ;
    y : bool <- read Share[n, wire1(k)] ; 
    return xor((y ,b ))
   ) ;; 
   (when ((m <= n) or (isHonest(n))) -->
     om : bool <- read OTMsg-2OtAdv[n ,m ,k ] ; return om 
   )
   ) || 
   (family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isSemiHonest(n))) -->
    b : bool <- read SendBit[n ,m, k] ;
    x : bool <- read Share[n , wire0(k)] ;
    y : bool <- read Share[n , wire1(k)] ; 
    return xor((x ,b ))
  ) ;; 
  (when ((m <= n) or (isHonest(n))) -->
    om : bool <- read OTMsg-1OtAdv[n, m ,k ] ; return om 
  )
  ) || 
  (family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isSemiHonest(n))) -->
    b : bool <- read SendBit[n ,m ,k ] ;
    x : bool <- read Share[n , wire0(k)] ;
    y : bool <- read Share[n , wire1(k)] ; 
    return b
  ) ;; 
  (when ((m <= n) or (isHonest(n))) -->
    om : bool <- read OTMsg-0OtAdv[n ,m ,k ] ; return om
  )
  ) || 
  (family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::= 
  (when n < N + 1 --> 
     x : bool <- read ShareSum[N , wire1(k)] ; return ()
  ) ;; 
  (when n = N + 1 --> 
   oc : unit <- read OTChcRcvd-1OtAdv[n ,N + 1 ,k ] ; return oc
  )
  ) || 
  (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  (when ((n < m) and (isHonest(m))) -->
    x : bool <- read Share[m , wire1(k)] ; 
    return ()
  ) ;; 
  (when ((m <= n) or (isSemiHonest(m))) -->
   oc : unit <- read OTChcRcvd-1OtAdv[n ,m ,k ] ; return oc
  )
  ) || 
  (family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 fixedBound N + 1 bound K ::= 
  (when n < N + 1 --> 
     x : bool <- read ShareSum[N , wire0(k)] ; return ()
  ) ;; 
  (when n = N + 1 --> 
    oc : unit <- read OTChcRcvd-0OtAdv[n ,N + 1 ,k ] ; return oc
  )
  ) || 
  (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 1 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 1 bound K ::= 
  (when ((n < m) and (isHonest(m)))  -->
    x : bool <- read Share[m , wire0(k)] ; 
    return ()
  ) ;; 
  (when ((m <= n) or (isSemiHonest(m))) -->
    oc : unit <- read OTChcRcvd-0OtAdv[n ,m ,k ] ; return oc
  )
  ) ||
  (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isSemiHonest(m))) -->
    x : bool <- read Share[m , wire1(k)] ; 
    return x 
  ) ;; 
  (when ((m <= n) or (isHonest(m))) -->
    oc : bool <- read OTChc-1OtAdv[n , m, k ] ; return oc
  )
  ) || 
(family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isSemiHonest(m))) -->
    x : bool <- read Share[m ,wire0(k)] ; return x 
  )
  ;; 
  (when ((m <= n) or (isHonest(m))) -->
    oc : bool <- read OTChc-0OtAdv[n ,m ,k ] ; return oc 
  )
)
||  
(family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read CtrbSum[n ,m ,k ] ; return s 
  ) 
  ;; 
  (when isHonest(n) -->
    s : bool <- read CtrbSumPartyAdv[n ,m ,k ] ; return s 
  )
) || 
( family CtrbPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(n) -->
    s : bool <- read Ctrb[n ,m ,k ] ; return s
  )
  ;; 
  (when isHonest(n) -->
    s : bool <- read CtrbPartyAdv[n ,m ,k ] ; return s 
  )
) 
))
)
 ||
(family InPartyAdv[bound N + 2 dependentBound I] 
 indices: n ,i 
 bounds: bound N + 2 dependentBound I ::= 
  (when isSemiHonest(n) -->
    in : bool <- read In[n ,i ] ; return in 
  )
  ;; 
  (when isHonest(n) -->
    in : bool <- read InPartyAdv[n ,i ] ; return in 
  )
) ||
(family InRcvdPartyAdv[bound N + 2 dependentBound I] 
 indices: n ,i 
 bounds: bound N + 2 dependentBound I ::= 
  (when isHonest(n) -->
    x : bool <- read In[n ,i ] ; return ()
  )
  ;; 
  (when isSemiHonest(n) -->
    in : unit <- read InRcvdPartyAdv[n ,i ] ; return in 
  )
) ||
(family InShare[bound N + 2 bound N + 2 dependentBound I] 
 indices: n ,m ,i 
 bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  in : bool <- read InShare$[n ,m ,i ] ; return in 
) ||
(family InShare$[bound N + 2 bound N + 2 dependentBound I] 
 indices: m ,n ,i 
 bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when m = N + 1 --> 
    s : bool <- read InShare$-Sum[N ,n ,i ] ;
    x : bool <- read In[n ,i ] ; 
    return xor((x ,s ))
  )
   ;; 
  (otherwise --> 
    x : bool <- read In[n ,i ] ; samp flip (())
  )
) ||
(family InShare$-Sum[bound N + 1 bound N + 2 dependentBound I] 
 indices: m ,n ,i 
 bounds: bound N + 1 bound N + 2 dependentBound I ::= 
  (when 0 = m --> 
    in : bool <- read InShare$[0, n ,i ] ; return in 
  )
  ;; 
  (otherwise --> 
    s : bool <- read InShare$-Sum[m - 1 ,n ,i ] ; 
    x : bool <- read InShare$[m ,n ,i ] ; 
    return xor((s ,x ))
  )
) ||
(family InShare$-SumPartyAdv[bound N + 1 bound N + 2 dependentBound I] 
 indices: m ,n ,i 
 bounds: bound N + 1 bound N + 2 dependentBound I ::= 
  (when isSemiHonest(n) -->
    s : bool <- read InShare$-Sum[m ,n ,i ] ; return s
  )
  ;; 
  (when isHonest(n) -->
    s : bool <- read InShare$-SumPartyAdv[m ,n ,i ] ; return s 
  )
) ||
(family InShare$PartyAdv[bound N + 2 bound N + 2 dependentBound I] 
 indices: m ,n ,i 
 bounds: bound N + 2 bound N + 2 dependentBound I ::= 
 (when isSemiHonest(n) --> 
   in : bool <- read InShare$[m ,n ,i ] ; return in 
 ) 
 ;; 
 (when isHonest(n) --> 
   in : bool <- read InShare$PartyAdv[m ,n ,i ] ; return in 
 )
) ||
(family InSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] 
 indices: n ,m ,i 
 bounds: bound N + 2 bound N + 2 dependentBound I ::= 
 (when isSemiHonest(n) -->
 
   s : bool <- read InShare[n ,m ,i ] ; return s 
 ) 
 ;; 
 (when isHonest(n ) -->
 
   s : bool <- read InSharePartyAdv[n ,m ,i ] ; return s 
 )
) ||
(family Out[bound N + 2 bound K] 
 indices: n ,k 
 bounds: bound N + 2 bound K ::= 
  s : bool <- read OutShareSum[n ,N + 1 ,k ] ; return s
) ||
(family OutPartyAdv[bound N + 2 bound K] 
 indices: n ,k 
 bounds: bound N + 2 bound K ::= 
  (when isSemiHonest(n) --> 
    s : bool <- read Out[n ,k ] ; return s 
  ) 
  ;; 
  (when isHonest(n) -->
    s : bool <- read OutPartyAdv[n ,k ] ; return s 
  )
) ||
(family OutShare[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isOutputWire(k ) --> 
    s : bool <- read Share[m ,k ] ; return s
  ) 
  ;; 
  (when not isOutputWire(k) --> 
    z : bool <- read OutShare[n ,m ,k ] ; return z 
  )
) ||
(family OutSharePartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(n) --> 
    s : bool <- read OutShare[n ,m , k ] ; return s 
  ) 
  ;; 
  (when isHonest(n) -->
 
    s : bool <- read OutSharePartyAdv[n ,m ,k ] ; return s 
  )
) ||
(family OutShareSum[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when 0 = m --> 
    s : bool <- read OutShare[n ,0 ,k ] ; return s 
  ) 
  ;;
  (otherwise -->  
    s : bool <- read OutShareSum[n ,m - 1 ,k ] ; 
    x : bool <- read OutShare[n ,m ,k ] ; 
    return xor((s ,x ))
  )
) ||
(family OutShareSumPartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(n) --> 
    s : bool <- read OutShareSum[n ,m ,k ] ; return s 
  ) 
  ;; 
  (when isHonest(n) --> 
    s : bool <- read OutShareSumPartyAdv[n ,m ,k ] ; return s 
  )
) ||
(family RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] 
 indices: n ,m ,i 
 bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when isSemiHonest(n) --> 
    in : bool <- read InShare$[n ,m ,i ] ; return in
  ) 
  ;; 
  (when isHonest(n) --> 
    s : bool <- read RcvdInSharePartyAdv[n ,m ,i ] ; return s 
  )
) ||
(family RcvdOutSharePartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(n) and isOutputWire(k) --> 
    s : bool <- read Share[m, k] ; return s 
  )
  ;; 
  (when isHonest(n) or not isOutputWire(k) --> 
    s : bool <- read RcvdOutSharePartyAdv[n ,m ,k ] ; return s 
  )
) ||
(family SendInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] 
 indices: m ,n ,i 
 bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when isSemiHonest(n) --> 
    in : bool <- read InShare$[m ,n ,i ] ; return in
  )
  ;; 
  (when isHonest(n) --> 
    s : bool <- read SendInSharePartyAdv[m ,n ,i ] ; return s 
  )
) ||
(family SendOutSharePartyAdv[bound N + 2 bound N + 2 bound K] 
 indices: m ,n ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when isSemiHonest(n) and isOutputWire(k) --> 
    s : bool <- read Share[n ,k ] ; 
    return s
  ) 
  ;; 
  (when isHonest(n) or not isOutputWire(k) -->
    s : bool <- read SendOutSharePartyAdv[m ,n ,k ]  ; return s 
  )
) ||
(family ShareSum[bound N + 2 bound K] 
 indices: m ,k 
 bounds: bound N + 2 bound K ::= 
  (when 0 = m --> 
    s : bool <- read Share[0, k] ; return s
  )
  ;; 
  (when not (0 = m) --> 
    xm : bool <- read Share[m ,k ] ; 
    xs : bool <- read ShareSum[m - 1 ,k ] ; 
    return xor((xs ,xm ))
  )
) ||
(family Shares[bound K] 
 indices: k 
 bounds: bound K ::= 
(when isInputGate (k ) --> (
 (family Share[fixedBound N + 1 bound K] 
 indices: n ,k 
 bounds: fixedBound N + 1 bound K ::= 
  in : bool <- read InShare[N + 1 , wire0(k), wire1(k)] ; 
  xs : bool <- read ShareSum[N ,k ] ; 
  return in  
 ) || 
 (family Share[bound N + 1 bound K] 
 indices: n ,k 
 bounds: bound N + 1 bound K
    ::= 
  in : bool <- read InShare[n , wire0(k), wire1(k)] ; return in 
) ||
(family SendBit[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  sb : bool <- read SendBit[n ,m ,k ] ; return sb 
) || 
(family RcvdBit[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  rb : bool <- read RcvdBit[n ,m ,k ] ; return rb
) || 
(family CtrbSum[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSum[n ,m ,k ] ; return b
) || 
(family Ctrb[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read Ctrb[n ,m ,k ] ; return b
)
)) ;; 
(when isNotGate (k ) --> (
 (family Share[fixedBound N + 1 bound K] 
 indices: n ,k 
 bounds: fixedBound N + 1 bound K ::= 
  x : bool <- read Share[N + 1 ,wire0(k)] ;
  xs : bool <- read ShareSum[N ,k ] ; 
  return neg(x )
 ) || 
 (family Share[bound N + 1 bound K] 
 indices: n ,k 
 bounds: bound N + 1 bound K ::= 
  s : bool <- read Share[n ,wire0(k)] ; return s
 ) || 
 (family SendBit[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  sb : bool <- read SendBit[n ,m ,k ] ; 
  return sb
 ) || 
 (family RcvdBit[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  rb : bool <- read RcvdBit[n ,m ,k ] ; 
  return rb
 ) || 
 (family CtrbSum[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSum[n ,m ,k ] ; return b 
 ) || 
 (family Ctrb[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read Ctrb[n ,m ,k ] ; return b
 ) 
)) ;; 
(when isXorGate (k ) --> (
 (family Share[fixedBound N + 1 bound K] 
 indices: n ,k 
 bounds: fixedBound N + 1 bound K ::= 
  x : bool <- read Share[N + 1 , wire0(k)] ;
  xs : bool <- read ShareSum[N ,k ] ;
  y : bool <- read Share[N + 1 , wire1(k)] ; 
  return xor((x ,y ))
 ) || 
 (family Share[bound N + 1 bound K] 
 indices: n ,k 
 bounds: bound N + 1 bound K ::=
  x : bool <- read Share[n , wire0(k)] ; 
  y : bool <- read Share[n , wire1(k)] ; 
  return xor((x ,y ))
 ) || 
 (family SendBit[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  sb : bool <- read SendBit[n ,m ,k ] ; return sb 
 ) || 
 (family RcvdBit[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  rb : bool <- read RcvdBit[n ,m ,k ] ; return rb 
 ) || 
 (family CtrbSum[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSum[n ,m ,k ] ; return b 
 ) || 
 (family Ctrb[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read Ctrb[n ,m ,k ] ; return b 
 )
)) ;;
(when isAndGate (k ) --> (
 (family Share[fixedBound N + 1 bound K] 
 indices: n ,k 
 bounds: fixedBound N + 1 bound K ::= 
  bs : bool <- read CtrbSum[N + 1 ,N + 1 ,k ] ;
  xs : bool <- read ShareSum[N ,k ] ; 
  return bs 
 ) || 
 (family Share[bound N + 1 bound K] 
 indices: n ,k 
 bounds: bound N + 1 bound K ::= 
  bs : bool <- read CtrbSum[n ,N + 1 ,k ] ; return bs 
 ) ||
 (family SendBit[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (n < m) --> 
    x : bool <- read Share[n , wire0(k)] ;
    y : bool <- read Share[n , wire1(k)] ; 
    samp flip (())
  ) ;; 
  (when (m <= n) --> 
    sb : bool <- read SendBit[n ,m ,k ] ; return sb
  )
 ) || 
 (family RcvdBit[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read SendBit[m ,n ,k ] ; 
  xm : bool <- read Share[m , wire0(k)] ;
  xn : bool <- read Share[n , wire0(k)] ;
  ym : bool <- read Share[m , wire1(k)] ;
  yn : bool <- read Share[n , wire1(k)] ; 
  return xor((xor((**((xm ,yn )), **((xn ,ym )))),b ))
 ) || 
 (family CtrbSum[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (0 = m) --> 
    b : bool <- read Ctrb[n ,0 ,k ] ; return b 
  ) ;;
  (when not (0 = m) --> 
    b : bool <- read Ctrb[n ,m ,k ] ;
    s : bool <- read CtrbSum[n ,m - 1 ,k ] ; 
    return xor((s ,b ))
  )
 ) || 
 (family Ctrb[bound N + 2 bound N + 2 bound K] 
 indices: n ,m ,k 
 bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (n < m) --> 
    s : bool <- read SendBit[n ,m ,k ] ; return s 
  ) ;; 
  (when (m = n) --> 
    x : bool <- read Share[n , wire0(k)] ;
    y : bool <- read Share[n , wire1(k)] ; 
    return **((x ,y ))
  ) ;; 
  (when (m < n) --> 
    r : bool <- read RcvdBit[n ,m ,k ] ; return r 
  )
 )
))  
)
)
 .


`` subproofs go above this line

`` up to the absorb of SOS is 10.4.3
start with pInt1 over deltaReal

subst  fam SendOutShare[bound N + 2 bound N + 2 bound K] 
into fam SendOutSharePartyAdv[bound N + 2 bound N + 2 bound K] then
rename variables m to n, n to m, k to k  
 of  fam SendOutShare[bound N + 2 bound N + 2 bound K]  then
subst  fam SendOutShare[bound N + 2 bound N + 2 bound K] 
into fam RcvdOutSharePartyAdv[bound N + 2 bound N + 2 bound K] then
subst or diverge fam SendOutShare[bound N + 2 bound N + 2 bound K] 
into fam OutShare[bound N + 2 bound N + 2 bound K] var z then
absorb  fam SendOutShare[bound N + 2 bound N + 2 bound K] then 
add internal family ShareSum 
indices: m, k 
bounds: bound N + 2 bound K
typed: bool
assigned: 
(when (m = 0) --> 
 s : bool <- read Share[0, k] ; return s
) ;;
(when (not (m = 0))  --> 
 xs : bool <- read ShareSum[m - 1, k] ;
 xm : bool <- read Share[m, k] ;
 return xor( (xs, xm) )
) then
on all branches of fam Adv[bound K] 
split fam OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] on second index then
on all branches of fam Adv[bound K] 
split fam OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] on second index then
on all branches of fam Shares[bound K]
split fam Share[bound N + 2 bound K] on first index then 
on branch (isNotGate(k)) of group Shares[bound K] (
    remove only branch of fam Share[bound N + 1 bound K]
) then
save current configuration then
call sym3 then
call sym4 then 
call sym5 then
call sym8 then
call addInitOK then
call addSharesOK then
call addInOK then 
call addWiresOK then
call splitShareOK then
compose fam Shares[bound K] with fam SharesOK[bound K] in group 
call changeComp then
ungroup fam InitOK[bound N + 2 bound N + 2 dependentBound I] then
rename indices to m, n, i in fam InShare[bound (N + 2) bound (N + 2) dependentBound I] then
subst fam InShare[bound (N + 2) bound (N + 2) dependentBound I]
 into fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I] then
rename in to is in fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I] then
rename indices to m, n, i in fam InShare[bound (N + 2) bound (N + 2) dependentBound I] then
call asym0 then
turn otherwise into neg for fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] then
split fam InShare$-OK[bound (N + 2) bound (N + 2) dependentBound I] on first index then
drop read branch when not m = N + 1 of 
  fam InShare$[bound N + 2 bound N + 2 dependentBound I ] 
  from fam InShare$-OK[bound N + 1 bound N + 2 dependentBound I ] then
subst fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
 into fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I] then
rename s to is, x to in
 in fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I] then
call asym1 then
compose fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
   with fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I] in group then
`` start asym2   
sym from 
  change 
   fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
  with
        (when (0 = m) -->
           in : unit <- read InShare$-OK[m, n, i] ; return () 
        )
        ;;
        (otherwise -->
           s : unit <- read InShare$Sum-OK[m - 1, n, i] ; 
           x : unit <- read InShare$-OK[m, n, i] ;
              return () 
        )
        in currentProtocol
(
in the presence of 
   fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I],
   fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]
rewrite 
 group InShare$-OK[bound N + 1 bound N + 2 dependentBound I] and InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I]
 to (
    (family InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I]
     indices: m ,n ,i 
     bounds: bound N + 1 bound N + 2 dependentBound I ::= 
     is : bool <- read InShare$-Sum[m ,n ,i] ; return ()
    ) 
    || 
    (family InShare$-OK[bound N + 1 bound N + 2 dependentBound I]
      indices: m ,n ,i 
      bounds: bound N + 1 bound N + 2 dependentBound I ::= 
      x : bool <- read In [n ,i] ; return ()
    )
   )
   by induction on m bound M
(
turn otherwise into neg 
     for fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
case distinction on  family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
  case: (
    subst fam InShare$-OK[fixedBound M bound N + 2 dependentBound I]
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]     
  )

  case: (
    subst fam InShare$Sum-OK[bound M bound (N + 2) dependentBound I] 
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
subst fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
rename is to s in fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  )
) then 
sym from 
             change 
              fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
             with 
              is : bool <- read InShare$-Sum[M, n, i] ;  return ()
             in currentProtocol
(
sym from 
    change 
              fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
             with 
              ( when (M = 0) --> 
                 is : bool <- read InShare$-Sum[M, n, i] ;  return ()
              )
              ;;
              ( when (not (M = 0)) --> 
                 is : bool <- read InShare$-Sum[M, n, i] ;  return ()
              )
             in currentProtocol
    (merge cases for 
      fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]  
    ) then
   turn otherwise into neg 
      for fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I] then
    case distinction on family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
 
     case: (
     
 subst branch when m = 0 of 
    fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
    into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  then
      drop read branch when not (m = N + 1) of  
            fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
         from fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
     )

     case: (
      subst branch when not (m = 0) of 
    fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
    into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  then
      drop read branch when not (m = N + 1) of  
            fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
         from fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
     )
    ) then 
     turn neg into otherwise 
      for fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
)
)
) then
decompose fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
   with fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I] then
``end asym2   
call asym01 then
unsplit fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I]
 and fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I] then
call addInitOK then
call indProofInitOK then
decompose fam Shares[bound K] with fam SharesOK[bound K] then
compose fam Wires-OK[bound K] with fam SharesOK[bound K] in group then
call indWiresShares then
decompose fam Wires-OK[bound K] with fam SharesOK[bound K] then
remove fam ShareOK[bound (N + 1) bound K]
           from group SharesOK[bound K] then
merge cases for fam ShareOK[bound (N + 1) bound K] then
remove fam ShareOK[fixedBound (N + 1) bound K]
           from group SharesOK[bound K] then
merge cases for fam ShareOK[fixedBound (N + 1) bound K] then
change name fam SharesOK[bound K] to Ctrbs-OK then
on branch isAndGate(k) of group Adv[bound K] (
  on branch n < N + 1 of
   family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K ]
  (subst fam ShareOK[fixedBound (N + 1) bound K]
    into fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K ]) then
  on branch n < N + 1 of
   family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K ]
  (subst fam ShareOK[fixedBound (N + 1) bound K]
    into fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K ])
) then
call addHidden then
call addHiddenGroup then
compose fam HiddenGroup[bound K] with fam Shares[bound K] in group then
combine fam Ctrbs-OK[bound K] then
call indTimingShares then
decompose fam HiddenGroup[bound K] with fam Shares[bound K] then
ungroup fam HiddenGroup[bound K] then
absorb fam Hidden[bound K] then
call restoreCtrbsOK  then
`` the sym proof
sym from
 branch 
          when (isInputGate (k))
         of
          fam Shares[bound K]
         change
          fam Share[fixedBound (N + 1) bound K]
         with
          xs : bool <- read ShareSum[N, k] ;
          in : bool <- read InShare[N + 1, wire0(k), wire1(k)] ;
          return in
          in 
          (
          branch 
          when (isNotGate(k))
         of
          fam Shares[bound K]
         change
          fam Share[fixedBound (N + 1) bound K]
         with
          xs : bool <- read ShareSum[N, k] ;
          x : bool <- read Share[N + 1, wire0(k)] ; 
          return neg(x)
          in 
          (
          branch 
          when (isXorGate(k))
         of
          fam Shares[bound K] 
         change
          fam Share[fixedBound (N + 1) bound K] 
         with
          xs : bool <- read ShareSum[N, k] ;
          x : bool <- read Share[N + 1, wire0(k)] ;
          y : bool <- read Share[N + 1, wire1(k)] ; 
          return xor((x, y)) 
          in 
          (branch 
          when (isAndGate(k))
         of
          fam Shares[bound K] 
         change
          fam Share[fixedBound (N + 1) bound K]
         with
          xs : bool <- read ShareSum[N, k] ;
          bs : bool <- read CtrbSum[N + 1, N + 1, k] ;
          return bs
          in 
          (branch 
          when (isAndGate(k))
         of
          fam Adv[bound K] 
         change
          fam OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K]
         with
          (when (n < N + 1) -->
            x : bool <- read ShareSum[N, wire1(k)] ;
            return ()
          )  
          ;;
         (when (n = N + 1) -->
           oc : unit <- read OTChcRcvd-1OtAdv[n, N + 1, k] ;
           return oc
         )
          in
          (
          branch 
          when (isAndGate(k))
         of
          fam Adv[bound K]
         change
          fam OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K]
         with
          (when (n < N + 1) -->
            x : bool <- read ShareSum[N, wire0(k)] ;
            return ()
          )  
          ;;
          (when (n = N + 1) -->
            oc : unit <- read OTChcRcvd-0OtAdv[n, N + 1, k] ;
            return oc
          ) 
          in savedProtocol
          ))
          )
          )
          ) 
          over savedDelta 
(
call sym3 then
call introShareSumOK then
sym from  
         branch 
          when isAndGate(k)
         of
          fam Adv[bound K]
         change
          fam  OTChcRcvd-1OtAdv[bound (N + 2) fixedBound (N + 1) bound K]
         with
          (when (n < N + 1) -->
             x : unit <- read ShareSum-OK[N, wire1(k)] ; return ()
          )  
          ;;
          (when (n = N + 1) -->
             oc : unit <- read OTChcRcvd-1OtAdv[n, N + 1, k] ; return oc
          )
          in
          (
          branch 
           when isAndGate(k)
         of
          fam Adv[bound K]
         change
          fam  OTChcRcvd-0OtAdv[bound (N + 2) fixedBound (N + 1) bound K]
         with
          (when (n < N + 1) -->
             x : unit <- read ShareSum-OK[N, wire0(k)] ; return ()
          )   
          ;;
          (when (n = N + 1) -->
             oc : unit <- read OTChcRcvd-0OtAdv[n, N + 1, k] ; return oc
          )
          in
          currentProtocol)
(
  on branch isAndGate(k)
          of group Adv[bound K] (
on branch n < N + 1 
           of family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K]
           ( subst fam ShareSum-OK[bound (N + 1) bound K] 
              into fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K] then
             rename s to x 
              in fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K]      
           ) then
           on branch n < N + 1
           of family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K]
           ( subst fam ShareSum-OK[bound (N + 1) bound K] 
              into fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K] then
             rename s to x 
              in fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K]      
           )
          )
) then
sym from
         change 
          fam Shares[bound K]
    with
    (when isInputGate(k) -->(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <- read InShare[n, wire0(k), wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 in : bool <- read InShare[N + 1, wire0(k), wire1(k)] ; 
 xs : unit <- read ShareSum-OK[N, k] ; 
 return in
)
)
)
;;
(when isNotGate(k) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <- read Share[n, wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <- read Share[N + 1, wire0(k)] ;
 xs : unit <- read ShareSum-OK[N, k] ;
 return neg(x)
)
)
)
;;
(when (isXorGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <- read Share[n, wire0(k)] ;
 y : bool <- read Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <- read Share[N + 1, wire0(k)] ;
 xs : unit <- read ShareSum-OK[N, k] ; 
 y : bool <- read Share[N + 1, wire1(k)] ; 
 return xor((x, y))
)
)
)
;;
(when isAndGate(k) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <- read SendBit[n, m, k] ; return s
) 
;;
(when (m = n) -->
 x : bool <- read Share[n, wire0(k)] ;
 y : bool <- read Share[n, wire1(k)] ;
 return **((x, y))
)
;;
(when (m < n) -->
 r : bool <- read RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (0 = m) -->
 b : bool <- read Ctrb[n, 0, k] ; return b
)
;;
(when not (0 = m) -->
 b : bool <- read Ctrb[n, m, k] ;
 s : bool <- read CtrbSum[n, m - 1, k] ; 
 return xor((s, b))
)
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read SendBit[m, n, k] ;
 xm : bool <- read Share[m, wire0(k)] ;
 xn : bool <- read Share[n, wire0(k)] ;
 ym : bool <- read Share[m, wire1(k)] ;
 yn : bool <- read Share[n, wire1(k)] ; 
 return xor( ( xor( ( **((xm, yn)) , **((xn, ym)) ) )  , b ) )
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <- read Share[n, wire0(k)] ;
 y : bool <- read Share[n, wire1(k)] ;
 samp flip (()) 
) 
;;
when (m <= n) -->
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[N + 1, N + 1, k] ; 
 xs : unit <- read ShareSum-OK[N, k] ; 
 return bs 
)
)
)
    in currentProtocol (
 on branch isInputGate(k)
  of group Shares[bound K]
  (subst fam ShareSum-OK[bound (N + 1) bound K]
    into fam Share[fixedBound (N + 1) bound K] then
   rename s to xs in fam Share[fixedBound (N + 1) bound K] 
  ) then
  on branch isNotGate(k)
  of group Shares[bound K]
  (subst fam ShareSum-OK[bound (N + 1) bound K]
    into fam Share[fixedBound (N + 1) bound K] then
   rename s to xs in fam Share[fixedBound (N + 1) bound K] 
  ) then
  on branch isXorGate(k)
  of group Shares[bound K]
  (subst fam ShareSum-OK[bound (N + 1) bound K]
    into fam Share[fixedBound (N + 1) bound K] then
   rename s to xs in fam Share[fixedBound (N + 1) bound K] 
  ) then
  on branch isAndGate(k)
  of group Shares[bound K]
  (subst fam ShareSum-OK[bound (N + 1) bound K]
    into fam Share[fixedBound (N + 1) bound K] then
   rename s to xs in fam Share[fixedBound (N + 1) bound K] 
  )
    ) then
call addInOK then 
call addWiresOK then
call sym5 then 
call addInitOK then
call addSharesOK then
sym from 
        change
          fam ShareSum-OK[bound (N + 1) bound K]
         with
          (when (m = 0) -->
             s : unit <- read ShareOK[0, k] ;  return ()
          )
          ;;
          (when (not (m = 0)) -->
             ss : unit <- read ShareSum-OK[m - 1, k] ;
              s : unit <- read ShareOK[m, k] ;
             return ()
          )
          in
          currentProtocol ( 
    in the presence of 
      fam ShareSum[bound N + 2 bound K] ,
      fam SharesOK[bound K]  
     rewrite family ShareSum-OK[bound (N + 1) bound K]
     to s : bool <- read ShareSum[m, k] ;  return ()
     by induction on m bound M 
     (
       case distinction on
       family ShareSum-OK[fixedBound M bound K]
       (
        case: (
        using group SharesOK[bound K]
        (subst fam ShareOK[bound (N + 2) bound K]
          into fam ShareSum-OK[fixedBound M bound K] then
         call symShareSumOK0
        )
        ) 
        
        case:  ( using group SharesOK[bound K]
        (subst fam ShareOK[bound (N + 2) bound K]
          into fam ShareSum-OK[fixedBound M bound K] then
         subst fam ShareSum-OK[bound M bound K]
          into fam ShareSum-OK[fixedBound M bound K] then
         call symShareSumOKM 
        )
        ) 
       ) then
       merge cases for fam  ShareSum-OK[fixedBound M bound K]
     )
          )  then
  split fam ShareOK[bound (N + 2) bound K] 
     inside group SharesOK[bound K] then
  compose fam Shares[bound K] with fam SharesOK[bound K] in group then
sym from
     change fam SharesOK[bound K]
        with 
           (when (isInputGate(k)) --> (
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(
family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 i : unit <- read InShareOK[n, wire0(k), wire1(k)] ; return i
)
||
(
family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 i : unit <- read InShareOK[N + 1, wire0(k), wire1(k)] ;
 ss : unit <- read ShareSum-OK[N, k] ;
 return i
)
)
)
;;
(when (isNotGate(k)) --> (
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(
family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : unit <- read ShareOK[n, wire0(k)] ; return x
)
||
(
family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : unit <- read ShareOK[N + 1, wire0(k)] ;
 ss : unit <- read ShareSum-OK[N, k] ;  
 return x
)
) 
)
;;
(when (isXorGate(k)) --> (
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(
family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : unit <- read ShareOK[n, wire0(k)] ;
 y : unit <- read ShareOK[n, wire1(k)] ; 
 return ()
)
||
(
family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 ss : unit <- read ShareSum-OK[N, k] ;
 x : unit <- read ShareOK[N + 1, wire0(k)] ;
 y : unit <- read ShareOK[N + 1, wire1(k)] ; 
 return ()
)
)
) 
;;
(when (isAndGate(k)) --> (
(family Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : unit <- read SendBit-OK[n, m, k] ; return s
) 
;;
(when (m < n) -->
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
;;
(when (m = n) -->
 x : unit <- read ShareOK[n, wire0(k)] ; 
 y : unit <- read ShareOK[n, wire1(k)] ; 
 return () 
)
)
||
(family CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (0 = m) -->
 c : unit <- read Ctrb-OK[n, 0, k] ; return c
)
;;
(when (not (0 = m)) -->
  x : unit <- read CtrbSum-OK[n, m - 1, k] ;
  y : unit <- read Ctrb-OK[n, m, k] ; 
  return () 
)
)
||
(family RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : unit <- read SendBit-OK[m, n, k] ;
 xm : unit <- read ShareOK[m, wire0(k)] ;
 xn : unit <- read ShareOK[n, wire0(k)] ; 
 ym : unit <- read ShareOK[m, wire1(k)] ; 
 yn : unit <- read ShareOK[n, wire1(k)] ; 
 return ()
)
||
(family SendBit-OK[bound (N + 2) bound (N + 2) bound K] 
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : unit <- read ShareOK[n, wire0(k)] ;
 y : unit <- read ShareOK[n, wire1(k)] ; 
    return ()
)
;;
(when (m <= n) -->
 sb : unit <- read SendBit-OK[n, m, k] ; return sb
)
)
||
(family ShareOK[bound (N + 1) bound K] 
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 c : unit <- read CtrbSum-OK[n, N + 1, k] ; return c
)
||
(family ShareOK[fixedBound (N + 1) bound K] 
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 c : unit <- read CtrbSum-OK[N + 1, N + 1, k] ;
 ss : unit <- read ShareSum-OK[N, k] ;
 return c  
)
)
)
          in currentProtocol (
in the presence of 
  fam InitOK[bound (N + 2) bound (N + 2) dependentBound I]
rewrite group Shares[bound K] and SharesOK[bound K]
   to (
   (family  Shares[bound K] 
 indices: k
 bounds: bound K
::=
(when (isInputGate(k)) --> (
(family  Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family  CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family  RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family  SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family  Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <- read InShare[n, wire0(k), wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 in : bool <- read InShare[N + 1, wire0(k), wire1(k)] ; 
 xs : unit <- read ShareSum-OK[N, k] ; 
 return in
)
)
   )
;;
(when (isNotGate(k)) --> (
(family  Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family  CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family  RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family  SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family  Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <- read Share[n, wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
  x : bool <- read Share[N + 1, wire0(k)] ; 
  xs : unit <- read ShareSum-OK[N, k] ;
  return neg(x)
)
)
)
;;
(when (isXorGate(k)) --> (
(family  Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family  CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family  RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family  SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family  Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <- read Share[n, wire0(k)] ;
 y : bool <- read Share[n, wire1(k)] ;
 return xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <- read Share[N + 1, wire0(k)] ;
 xs : unit <- read ShareSum-OK[N, k] ;
 y : bool <- read Share[N + 1, wire1(k)] ; 
 return xor((x, y))
)
)
)
;;
(when (isAndGate(k)) --> (
(family  Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <- read SendBit[n, m, k] ; return s
)
;;
(when (m = n) -->
 x : bool <- read Share[n, wire0(k)] ;
 y : bool <- read Share[n, wire1(k)] ;
 return **((x, y))
)
;;
(when (m < n) -->
 r : bool <- read RcvdBit[n, m, k] ; return r
)
)
||
(family  CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (0 = m) -->
 b : bool <- read Ctrb[n, 0, k] ; return b
)
;;
(when not (0 = m) -->
  b : bool <- read Ctrb[n, m, k] ;
  s : bool <- read CtrbSum[n, m - 1, k] ; 
  return xor((s, b))
)
)
||
(family  RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read SendBit[m, n, k] ;
 xm : bool <- read Share[m, wire0(k)] ;
 xn : bool <- read Share[n, wire0(k)] ;
 ym : bool <- read Share[m, wire1(k)] ;
 yn : bool <- read Share[n, wire1(k)] ; 
 return xor( ( xor( (**((xm, yn)) , **((xn, ym)) ) )  , b ) ) 
)
||
(family  SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <- read Share[n, wire0(k)] ; 
 y : bool <- read Share[n, wire1(k)] ;
 samp flip (()) 
)
;;
(when (m <= n) -->
 sb : bool <- read SendBit[n, m, k] ; return sb
)
)
||
(family  Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[N + 1, N + 1, k] ;
 xs : unit <- read ShareSum-OK[N, k] ;
 return bs
)
)
)
   )
||
(family SharesOK[bound K] 
 indices: k
 bounds: bound K
::= (
(family  Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : bool <- read Ctrb[n, m, k] ;  return ()
)
||
(family  CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : bool <- read CtrbSum[n, m, k] ;  return ()
)
||
(family  RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : bool <- read RcvdBit[n, m, k] ;  return ()
)
||
(family  SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : bool <- read SendBit[n, m, k] ;  return ()
)
||
(family  ShareOK[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <- read Share[n, k] ; return ()
)
||
(family ShareOK[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 x : bool <- read Share[N + 1, k] ; return ()
)
)
)
   )
   by induction on k bound B 
   (
   ungroup fam InitOK[bound N + 2 bound N + 2 dependentBound I] then
   case distinction on group SharesOK[fixedBound B](
    case: (
      using branch when (isInputGate(B))
    of group Shares[fixedBound B]
     ( sym var c terms n, m, B 
         diverge fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
         into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var c then
       sym var c terms n, m, B 
         diverge fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
         into fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var c then  
       sym var r terms n, m, B 
         diverge fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B]
         into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var r then
       sym var s terms n, m, B 
         diverge fam SendBit[bound (N + 2) bound (N + 2) fixedBound B]
         into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var s then  
       rename indices to x, y in fam ShareOK[bound (N + 1) fixedBound B] then
       subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]  
        into fam ShareOK[bound (N + 1) fixedBound B] then
       rename indices to n, k in fam ShareOK[bound (N + 1) fixedBound B] then 
       rename is to in in fam ShareOK[bound (N + 1) fixedBound B] then
       sym from 
         change 
        fam ShareOK[bound(N + 1) fixedBound B]
        with
         x : bool <- read Share[n, B] ; return ()
        in currentProtocol 
         ( subst
             fam Share[bound (N + 1) fixedBound B] into
             fam ShareOK[bound (N + 1) fixedBound B]
         )
     ) then
     subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
      into chn ShareOK[N + 1, B] then
      sym from
         change 
          chn ShareOK[N + 1, B]
         with
          x : bool <- read Share[N + 1, B] ; return ()
         in currentProtocol
       (
        using branch when (isInputGate(B))
        of group Shares[fixedBound B]
        (subst chn Share[N + 1, B]
          into chn ShareOK[N + 1, B] then
         rename in to is, xs to ss 
          in chn ShareOK[N + 1, B] 
        )
      )
    )
    case: (
        using branch when (isNotGate(B))
    of group Shares[fixedBound B]
     ( sym var c terms n, m, B 
         diverge fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
         into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var c then
       sym var c terms n, m, B 
         diverge fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
         into fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var c then  
       sym var r terms n, m, B 
         diverge fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B]
         into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var r then
       sym var s terms n, m, B 
         diverge fam SendBit[bound (N + 2) bound (N + 2) fixedBound B]
         into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var s then  
       unit-ext on fam ShareOK[bound (N + 1) fixedBound B] at 1 then
       using group SharesOK[bound B]
       (
        subst fam ShareOK[bound (N + 1) bound B]
         into fam ShareOK[bound (N + 1) fixedBound B]
       ) then
       sym from 
       change 
        fam ShareOK[bound (N + 1) fixedBound B]
        with
         x : bool <- read Share[n, B] ; return ()
        in currentProtocol 
         (
         subst fam Share[bound (N + 1) fixedBound B]
          into fam ShareOK[bound (N + 1) fixedBound B] then
         rename s to x in fam ShareOK[bound(N + 1) fixedBound B]   
         )        
       ) then
       using group SharesOK[bound B]
        (
         subst fam ShareOK[fixedBound (N + 1) bound B]
         into chn ShareOK[N + 1, B]
        ) then 
       sym from
         change 
          chn ShareOK[N + 1, B]
         with
          x : bool <- read Share[N + 1, B] ; return ()
         in currentProtocol
       (
        using branch when (isNotGate(B))
        of group Shares[fixedBound B]
        (subst chn Share[N + 1, B]
          into chn ShareOK[N + 1, B] then
         rename xs to ss 
          in chn ShareOK[N + 1, B] 
        )
      )
    )
    case: (
     using branch when (isXorGate(B))
    of group Shares[fixedBound B]
     ( sym var c terms n, m, B 
         diverge fam Ctrb[bound (N + 2) bound (N + 2) fixedBound B]
         into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var c then
       sym var c terms n, m, B 
         diverge fam CtrbSum[bound (N + 2) bound (N + 2) fixedBound B]
         into fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var c then  
       sym var r terms n, m, B 
         diverge fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B]
         into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var r then
       sym var s terms n, m, B 
         diverge fam SendBit[bound (N + 2) bound (N + 2) fixedBound B]
         into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         var s then  
     using group SharesOK[bound B]
       ( 
         subst fam ShareOK[bound (N + 1) bound B]
         into fam ShareOK[bound (N + 1) fixedBound B] then
         rename x to a in fam ShareOK[bound (N + 1) fixedBound B] then
         subst fam ShareOK[bound (N + 1) bound B]
         into fam ShareOK[bound (N + 1) fixedBound B] then
         rename x to y, a to x in fam ShareOK[bound (N + 1) fixedBound B] 
       ) then
       sym from 
         change 
        fam ShareOK[bound(N + 1) fixedBound B]
        with
         x : bool <- read Share[n, B] ; return ()
        in currentProtocol 
         ( subst
             fam Share[bound (N + 1) fixedBound B] into
             fam ShareOK[bound (N + 1) fixedBound B]
         )
     ) then
     using group SharesOK[bound B]
     ( subst
             fam ShareOK[fixedBound (N + 1) bound B] into
             chn ShareOK[N + 1, B] then
       rename x to x0 in chn ShareOK[N + 1, B] then  
       subst
             fam ShareOK[fixedBound (N + 1) bound B] into
             chn ShareOK[N + 1, B] then
       rename x to x1 in chn ShareOK[N + 1, B] then             
       sym from
         change 
          chn ShareOK[N + 1, B]
         with
          x : bool <- read Share[N + 1, B] ; return ()
         in currentProtocol
       (
        using branch when (isXorGate(B))
        of group Shares[fixedBound B]
        (subst chn Share[N + 1, B]
          into chn ShareOK[N + 1, B] then
         rename xs to ss, x to x0, y to x1
          in chn ShareOK[N + 1, B] 
        )
      )
     )
    )
    case: (
     case distinction on family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
     (
      case: (
        using group SharesOK[bound B]
        (
          subst fam ShareOK[bound (N + 1) bound B] 
           into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
          rename x to a in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
          subst fam ShareOK[bound (N + 1) bound B] 
           into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
          rename x to y, a to x in 
           fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
        )
      )
      
      case: (idle)
     ) then
     call inIndSym7 then
     using group SharesOK[bound B]
        (
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
         rename x to a in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then     
         rename x to yn, a to xn 
          in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then    
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
         rename x to a in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
         subst fam ShareOK[bound (N + 1) bound B] 
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then 
         rename x to ym, a to xm 
          in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then
         rename xm to a, xn to xm, yn to xn, ym to yn, a to ym 
          in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then        
         rename indices to x, y, z
           in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then     
         subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
          into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then         
         rename indices to n, m, k
           in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B] then     
         rename s to b in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
         
        ) then
        sym from 
         change 
        fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
        with
         r : bool <- read RcvdBit[n, m, B] ;  return ()
        in currentProtocol
       (
         using branch when isAndGate(B)
         of group Shares[fixedBound B]
         (subst fam RcvdBit[bound (N + 2) bound (N + 2) fixedBound B] 
           into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]  )
       ) then
       case distinction on family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] (
     case: (
      subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
          into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] 
     )

     case: (
       subst fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B]
          into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] 
     )
     case: ( idle )
   ) then
 unsplit fam ShareOK[bound (N + 1) bound B] 
           and fam ShareOK[fixedBound (N + 1) bound B] inside group SharesOK[bound B] then 
 using group SharesOK[bound B]
       (
          case distinction on family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] (
             case: ( idle )
              case: ( idle )
               case: ( subst fam ShareOK[bound (N + 2) bound B] 
              into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
             rename x to a
              in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
              subst fam ShareOK[bound (N + 2) bound B] 
              into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] then
             rename x to y, a to x
              in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]  )

          )
       ) then
 split fam ShareOK[bound (N + 2) bound B] inside group SharesOK[bound B] then
 call inIndSym9 then
 call inIndSym10 then
  subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B] 
            into fam ShareOK[bound (N + 1) fixedBound B] then
  call inIndSym11 then
  subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
            into chn ShareOK[N + 1, B] then
  sym from
         change 
          chn ShareOK[N + 1, B]
         with
          x : bool <- read Share[N + 1, B] ; return ()
         in currentProtocol
       (
        using branch when (isAndGate(B))
        of group Shares[fixedBound B]
        (subst chn Share[N + 1, B]
          into chn ShareOK[N + 1, B] then
         rename xs to ss, bs to c
          in chn ShareOK[N + 1, B] 
        )
      )
    )
   ) then 
   merge cases for fam SharesOK[fixedBound B] then
   call addInitOK
   )
          ) then
    decompose fam Shares[bound K] with fam SharesOK[bound K] then
    ungroup fam InitOK[bound N + 2 bound N + 2 dependentBound I] then
    rename indices to m, n, i in fam InShare[bound (N + 2) bound (N + 2) dependentBound I] then
subst fam InShare[bound (N + 2) bound (N + 2) dependentBound I]
 into fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I] then
rename in to is in fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I] then
rename indices to m, n, i in fam InShare[bound (N + 2) bound (N + 2) dependentBound I] then
call asym0 then
split fam InShare$-OK[bound (N + 2) bound (N + 2) dependentBound I]       
 on first index then
turn otherwise into neg for fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] then
drop read branch when not m = N + 1 of 
  fam InShare$[bound N + 2 bound N + 2 dependentBound I ] 
  from fam InShare$-OK[bound N + 1 bound N + 2 dependentBound I ] then
subst fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
 into fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I] then
rename s to is, x to in
 in fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I] then
call asym1 then
compose fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
   with fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I] in group then
`` start asym2
sym from 
  change 
   fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I]
  with
        (when (0 = m) -->
           in : unit <- read InShare$-OK[m, n, i] ; return () 
        )
        ;;
        (otherwise -->
           s : unit <- read InShare$Sum-OK[m - 1, n, i] ; 
           x : unit <- read InShare$-OK[m, n, i] ;
              return () 
        )
        in currentProtocol
(
in the presence of 
   fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I],
   fam InShare$[bound (N + 2) bound (N + 2) dependentBound I]
rewrite 
 group InShare$-OK[bound N + 1 bound N + 2 dependentBound I] and InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I]
 to (
    (family InShare$Sum-OK[bound N + 1 bound N + 2 dependentBound I]
     indices: m ,n ,i 
     bounds: bound N + 1 bound N + 2 dependentBound I ::= 
     is : bool <- read InShare$-Sum[m ,n ,i] ; return ()
    ) 
    || 
    (family InShare$-OK[bound N + 1 bound N + 2 dependentBound I]
      indices: m ,n ,i 
      bounds: bound N + 1 bound N + 2 dependentBound I ::= 
      x : bool <- read In [n ,i] ; return ()
    )
   )
   by induction on m bound M
(
turn otherwise into neg 
     for fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
case distinction on  family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
  case: (
    subst fam InShare$-OK[fixedBound M bound N + 2 dependentBound I]
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]     
  )

  case: (
    subst fam InShare$Sum-OK[bound M bound (N + 2) dependentBound I] 
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
subst fam InShare$-OK[fixedBound M bound (N + 2) dependentBound I]
 into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] then
rename is to s in fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  )
) then 
sym from 
             change 
              fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
             with 
              is : bool <- read InShare$-Sum[M, n, i] ;  return ()
             in currentProtocol
(
sym from 
    change 
              fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
             with 
              ( when (M = 0) --> 
                 is : bool <- read InShare$-Sum[M, n, i] ;  return ()
              )
              ;;
              ( when (not (M = 0)) --> 
                 is : bool <- read InShare$-Sum[M, n, i] ;  return ()
              )
             in currentProtocol
    (merge cases for 
      fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]  
    ) then
   turn otherwise into neg 
      for fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I] then
    case distinction on family InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I](
 
     case: (
     
 subst branch when m = 0 of 
    fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
    into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  then
      drop read branch when not (m = N + 1) of  
            fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
         from fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
     )

     case: (
      subst branch when not (m = 0) of 
    fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
    into fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I] 
  then
      drop read branch when not (m = N + 1) of  
            fam InShare$[bound (N + 2) bound (N + 2) dependentBound I] 
         from fam InShare$Sum-OK[fixedBound M bound (N + 2) dependentBound I]
     )
    ) then 
     turn neg into otherwise 
      for fam InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound I]
)
)
) then
decompose fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I] 
   with fam InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound I] then
`` end asym2   
call asym01 then
unsplit fam InShare$-OK[bound (N + 1) bound (N + 2) dependentBound I]
 and fam InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound I] then
call addInitOK then
call indProofInitOK then
move family ShareSum-OK[bound (N + 1) bound K] on each
 branch of group SharesOK[bound K] then
compose fam Wires-OK[bound K] with fam SharesOK[bound K] in group then
in the presence of fam InitOK[bound (N + 2) bound (N + 2) dependentBound I]
 rewrite group Wires-OK[bound K] and SharesOK[bound K]
 to 
 (
  (family  SharesOK[bound K] 
 indices: k
 bounds: bound K
::=
(when (isInputGate(k)) --> (
(family  Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family  CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family  RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family  SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(family  ShareOK[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family  ShareSum-OK[bound (N + 1) bound K] 
 indices: m, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
)
;;
(when (isNotGate(k)) --> (
(family  Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family  CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family  RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family  SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(family  ShareOK[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family  ShareSum-OK[bound (N + 1) bound K] 
 indices: m, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
)
;;
(when (isXorGate(k)) --> (
(family  Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read Ctrb-OK[n, m, k] ; return c
)
||
(family  CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 c : unit <- read CtrbSum-OK[n, m, k] ; return c
)
||
(family  RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 r : unit <- read RcvdBit-OK[n, m, k] ; return r
)
||
(family  SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 s : unit <- read SendBit-OK[n, m, k] ; return s
)
||
(family  ShareOK[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family  ShareSum-OK[bound (N + 1) bound K] 
 indices: m, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
)
;;
(when (isAndGate(k)) --> (
(family  Ctrb-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
||
(family  CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
||
(family  RcvdBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (m < n) -->
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
;;
(when (n <= m) -->
 rb : unit <- read RcvdBit-OK[n, m, k] ; return rb
)
)
||
(family  SendBit-OK[bound (N + 2) bound (N + 2) bound K]
 indices: n, m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
;;
(
when (m <= n) -->
 sb : unit <- read SendBit-OK[n, m, k] ; return sb
)
)
||
(family  ShareOK[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family  ShareSum-OK[bound (N + 1) bound K] 
 indices: m, k
 bounds: bound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
||
(family ShareOK[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read Wire-OK[k] ; return w
)
)
)
)
||
(family Wires-OK[bound K] 
 indices: k
 bounds: bound K
::=
family Wire-OK[bound K] 
 indices: k
 bounds: bound K
::= (
(when (isInputGate(k)) -->
 in : unit <- read In-OK[wire0(k), wire1(k)] ; return in
)
;;
(when (isNotGate(k)) -->
 w : unit <- read Wire-OK[wire0(k)] ; return ()
)
;;
(when (isXorGate(k)) -->
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
;;
(when (isAndGate(k)) -->
 w0 : unit <- read Wire-OK[wire0(k)] ; 
 w1 : unit <- read Wire-OK[wire1(k)] ;
 return () 
)
)
)
)
 by induction on k bound B (
  ungroup fam InitOK[bound N + 2 bound N + 2 dependentBound I] then
        remove fam ShareOK[bound (N + 1) bound B] from group SharesOK[bound B] then
        merge cases for fam ShareOK[bound (N + 1) bound B] then    
        remove fam ShareOK[fixedBound (N + 1) bound B] from group SharesOK[bound B] then
        merge cases for fam ShareOK[fixedBound (N + 1) bound B] then        
        remove fam ShareSum-OK[bound (N + 1) bound B] from group SharesOK[bound B] then
        merge cases for fam ShareSum-OK[bound (N + 1) bound B] then
        remove and merge fam ShareSum-OK[bound (N + 1) fixedBound B] 
          from group SharesOK[fixedBound B] then
        unsplit fam ShareOK[bound (N + 1) bound B] and 
                fam ShareOK[fixedBound (N + 1) bound B] then
        case distinction on group SharesOK[fixedBound B] (
  case: (
          subst fam InShareOK[bound (N + 2) bound (N + 2) dependentBound I]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          call symInput 
       )
  case: (
          subst fam ShareOK[bound (N + 2) bound B]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          unit-ext on fam ShareOK[bound (N + 1) fixedBound B] at 1 then
          call wireSymNot            
       )
  case:  (
          subst fam ShareOK[bound (N + 2) bound B]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          rename w to w0 in fam ShareOK[bound (N + 1) fixedBound B] then           
          subst fam ShareOK[bound (N + 2) bound B]
           into fam ShareOK[bound (N + 1) fixedBound B] then
          rename w to w1 in fam ShareOK[bound (N + 1) fixedBound B] then           
          call wireSymXor            
       )
  case: (
         case distinction on family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
         (
         case: (subst fam ShareOK[bound (N + 2) bound B]
                into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
                rename w to w0 in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
                subst fam ShareOK[bound (N + 2) bound B]
                into fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
                rename w to w1 in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
         )       
         case: (idle)
         ) then
         rename indices to m, n, k 
          in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
         call symRcvdBit then 
         case distinction on family RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
         (
          case: (
          using branch when (m < n)
           of family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          ( 
            subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
             into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          ) then
          subst fam ShareOK[bound (N + 2) bound B]
           into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
          subst fam ShareOK[bound (N + 2) bound B]
           into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
          rename w to w0 in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then  
          subst fam ShareOK[bound (N + 2) bound B]
           into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
          subst fam ShareOK[bound (N + 2) bound B]
           into fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
          rename w to w1 in fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] 
         )
          
          case: (
          using branch when n <= m 
           of family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          (  diverge on fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] 
              with fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] var rb  
          ) 
                )
         
         ) then
         rename indices to n, m, k
          in fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] then  
         case distinction on
          family Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ]
         (
           case: (
           using branch when (n < m)
            of family SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          (subst fam SendBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] 
            into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          )  
           )
           case: (
           using branch when (m < n)
            of family RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          (subst fam RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound B ] 
            into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          )  
           )
           case: (
           subst fam ShareOK[bound (N + 2) bound B] 
            into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
           rename w to w0 in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
           subst fam ShareOK[bound (N + 2) bound B] 
            into fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
           rename w to w1 in fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ]       
           )
         ) then 
         merge cases for fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B ] then
         in the presence of fam  Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B] 
         rewrite family CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B ]
         to w0 : unit <- read Wire-OK[wire0(B)] ;
            w1 : unit <- read Wire-OK[wire1(B)] ;
            return ()
         by induction on m bound M
         (
           case distinction on 
           family CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B ]
           (
           case: (
            subst fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
             into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]
           )
           case: (
           subst fam Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound B]
             into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B] then
           subst fam CtrbSum-OK[bound (N + 2) bound M fixedBound B]
             into fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B]  
           )
           ) then
           merge cases for fam CtrbSum-OK[bound (N + 2) fixedBound M fixedBound B ]
         ) then   
         subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B ]
          into fam ShareOK[bound (N + 1) fixedBound B] then
          call wireSymAnd 
       ) 
      ) then
      remove fam ShareOK[bound (N + 1) fixedBound B]
        from group SharesOK[fixedBound B] then
      merge cases for fam ShareOK[bound (N + 1) fixedBound B] then
      in the presence of fam ShareOK[bound (N + 1) fixedBound B] 
       rewrite family ShareSum-OK[bound (N + 1) fixedBound B]
       to w : unit <- read Wire-OK[B] ; return w
       by induction on m bound M
       (
        case distinction on 
         channel ShareSum-OK[M, B]
        ( case: (
           subst fam ShareOK[bound (N + 1) fixedBound B]
            into chn ShareSum-OK[M, B]
          )
        
          case: (
            subst fam ShareOK[bound (N + 1) fixedBound B]
            into chn ShareSum-OK[M, B] then
            subst fam ShareSum-OK[bound M fixedBound B]
            into chn ShareSum-OK[M, B]
          )
        
        ) then
        merge cases for chn ShareSum-OK[M, B] then
         sym from 
         change 
          chn ShareSum-OK[M, B]
         with
          w : unit <- read Wire-OK[B] ; return w
         in currentProtocol (
            unit-ext on  chn ShareSum-OK[M, B] at 1
          )   
      ) then
       move family ShareOK[bound (N + 1) fixedBound B]
        on each branch of group SharesOK[fixedBound B] then
       move family ShareSum-OK[bound (N + 1) fixedBound B]
        on each branch of group SharesOK[fixedBound B] then
   case distinction on group SharesOK[fixedBound B] (
  case: ( 
         subst fam InShareOK[bound N + 2 bound N + 2 dependentBound I]         
          into chn ShareOK[N + 1, B] then 
         subst fam ShareSum-OK[bound (N + 1) fixedBound B]         
          into chn ShareOK[N + 1, B] then
         using group Wires-OK[fixedBound B]
         (
          using branch when isInputGate(B)
           of channel Wire-OK[B]
           (subst chn Wire-OK[B]
           into chn ShareOK[N + 1, B])
         ) then
         sym from
             change 
              chn ShareOK[N + 1, B]
             with 
              w : unit <- read Wire-OK[B] ; return w
             in currentProtocol
        (
          using group Wires-OK[fixedBound B]
          ( using branch when isInputGate(B)
            of channel Wire-OK[B]
             (subst chn Wire-OK[B] into chn ShareOK[N + 1, B] then
              unit-ext on chn ShareOK[N + 1, B] at 1
             )
            )
       )       
       )
  case: (  subst fam ShareSum-OK[bound (N + 1) fixedBound B]         
          into chn ShareOK[N + 1, B] then
         rename w to w0 in chn ShareOK[N + 1, B] then
         subst fam ShareOK[bound (N + 2) bound B]         
          into chn ShareOK[N + 1, B] then
          using group Wires-OK[fixedBound B]
         (
          using branch when isNotGate(B)
           of channel Wire-OK[B]
           (subst chn Wire-OK[B]
           into chn ShareOK[N + 1, B])
         ) then
         unit-ext on chn ShareOK[N + 1, B] at 1 then
         call wireSymNotC  
       )  
  case:  ( subst fam ShareOK[bound (N + 2) bound B]         
          into chn ShareOK[N + 1, B] then
         rename w to w0 in chn ShareOK[N + 1, B] then
         subst fam ShareOK[bound (N + 2) bound B]         
          into chn ShareOK[N + 1, B] then
         rename w to w1 in chn ShareOK[N + 1, B] then
         subst fam ShareSum-OK[bound (N + 1) fixedBound B]   
          into chn ShareOK[N + 1, B] then
         using group Wires-OK[fixedBound B]
         (
          using branch when isXorGate(B)
           of channel Wire-OK[B]
           (subst chn Wire-OK[B]
           into chn ShareOK[N + 1, B])
         ) then
         call wireSymXorC               
       )
  case:  (
       subst fam CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound B]
        into chn ShareOK[N + 1, B] then
       subst fam ShareSum-OK[bound (N + 1) fixedBound B]
        into chn ShareOK[N + 1, B] then    
       using group Wires-OK[fixedBound B]
       (
         using branch when (isAndGate(B))
          of channel Wire-OK[B]
         (subst chn Wire-OK[B]
           into chn ShareOK[N + 1, B] ) 
       ) then
       call wireSymAndC
       )
 ) then
  call addInitOK then
           split fam ShareOK[bound (N + 2) bound B] on first index then
           move family ShareOK[bound (N + 1) bound B] 
            on each branch of group SharesOK[bound B] then
           move family ShareOK[fixedBound (N + 1) bound B] 
            on each branch of group SharesOK[bound B] then
          move family ShareSum-OK[bound (N + 1) bound B] 
            on each branch of group SharesOK[bound B]      
  ) then
  decompose fam Wires-OK[bound K] with fam SharesOK[bound K] then 
    remove fam ShareOK[bound (N + 1) bound K]
           from group SharesOK[bound K] then
merge cases for fam ShareOK[bound (N + 1) bound K] then
remove fam ShareOK[fixedBound (N + 1) bound K]
           from group SharesOK[bound K] then
merge cases for fam ShareOK[fixedBound (N + 1) bound K] then
remove fam ShareSum-OK[bound (N + 1) bound K]
           from group SharesOK[bound K] then
merge cases for fam ShareSum-OK[bound (N + 1) bound K] then 
change name fam SharesOK[bound K] to Ctrbs-OK then
on branch isAndGate(k) of group Adv[bound K] (
  on branch n < N + 1 of
   family OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K ]
  (subst fam ShareSum-OK[bound (N + 1) bound K]
    into fam OTChcRcvd-0OtAdv[bound N + 2 fixedBound N + 1 bound K ]) then
  on branch n < N + 1 of
   family OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K ]
  (subst fam ShareSum-OK[bound (N + 1) bound K]
    into fam OTChcRcvd-1OtAdv[bound N + 2 fixedBound N + 1 bound K ])
) then
     `` now induction for Shares
      call addHidden then
call addHiddenGroup then
compose fam HiddenGroup[bound K] with fam Shares[bound K] in group then
  in the presence of fam ShareSum-OK [bound N + 1 bound K ] 
  rewrite group HiddenGroup[bound K] and Shares[bound K]
  to 
   (
    (family HiddenGroup[bound K]  
      indices: k
      bounds: bound K ::=
     family Hidden[bound K] 
      indices: k
      bounds: bound K ::=
       return ()
    )
   ||
 (
    family Shares[bound K]
     indices: k
  bounds: bound K
::=
(
(when (isInputGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 in : bool <- read InShare[n , wire0(k) , wire1(k)] ; return in
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 in : bool <- read InShare[N + 1, wire0(k) , wire1(k)] ; 
 w : unit <- read  Wire-OK[k] ; 
 return in
) 
)
)
;;
(when (isNotGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 s : bool <- read Share[n , wire0(k)] ; return s
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read  Wire-OK[k] ;
 x : bool <- read Share[N + 1 , wire0(k)] ; 
 return neg(x)
) 
)
)
;;
(when (isXorGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read Ctrb[n, m, k] ; return b
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read CtrbSum[n, m, k] ; return b
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 rb : bool <- read RcvdBit[n, m, k] ; return rb
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 sb : bool <- read SendBit[n, m, k] ; return sb
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 x : bool <- read Share[n , wire0(k)] ;  
 y : bool <- read Share[n , wire1(k)] ; 
 return  xor((x, y))
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 w : unit <- read  Wire-OK[k] ;
 x : bool <- read Share[N + 1, wire0(k)] ; 
 y : bool <- read Share[N + 1, wire1(k)] ; 
 return  xor((x, y))
)
)
)
;;
when (isAndGate(k)) -->
(
(family Ctrb[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 s : bool <- read SendBit[n, m, k] ; return s
) 
;;
(when (m = n) -->
 x : bool <- read Share[n , wire0(k)] ;
 y : bool <- read Share[n , wire1(k)] ; 
 return  **((x, y))
) 
;;
(when (m < n) -->
 r : bool <- read RcvdBit[n, m, k] ; return r
)
)
||
(family CtrbSum[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (0 = m) -->
 b : bool <- read Ctrb[n, 0, k] ; return b
) 
;;
(when not (0 = m) -->
 b : bool <- read Ctrb[n, m, k] ; 
 s : bool <- read CtrbSum[n, m - 1, k] ; 
 return xor((s, b))
) 
)
||
(family RcvdBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
 b : bool <- read SendBit[m, n, k] ;
 xm : bool <- read Share[m , wire0(k)] ; 
 xn : bool <- read Share[n , wire0(k)] ; 
 ym : bool <- read Share[m , wire1(k)] ; 
 yn : bool <- read Share[n, wire1(k)] ; 
 return xor( ( xor( (**((xm, yn)), **((xn, ym))) ) , b) ) 
)
||
(family SendBit[bound (N + 2) bound (N + 2) bound K]
 indices: n,m, k
 bounds: bound (N + 2) bound (N + 2) bound K
::=
(when (n < m) -->
 x : bool <- read Share[n , wire0(k)] ;
 y : bool <- read Share[n , wire1(k)] ; 
  samp flip (())
)
;;
(when (m <= n) -->
 sb : bool <- read SendBit[n, m, k] ; return sb
)
)
||
(family Share[bound (N + 1) bound K]
 indices: n, k
 bounds: bound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[n, N + 1, k] ; return bs
)
||
(family Share[fixedBound (N + 1) bound K]
 indices: n, k
 bounds: fixedBound (N + 1) bound K
::=
 bs : bool <- read CtrbSum[N + 1, N + 1, k] ;
 w : unit <- read Wire-OK[k] ; 
 return bs
)
)
) 
 )
   )
  by induction on k bound B
  (
  case distinction on group Shares[fixedBound B]
  (
    case: (
    subst fam ShareSum-OK[bound (N + 1) bound K]
     into chn Share[N + 1, B]
  )
    case: (
    subst fam ShareSum-OK[bound (N + 1) bound K]
     into chn Share[N + 1, B]
  )
    case: (
    subst fam ShareSum-OK[bound (N + 1) bound K]
     into chn Share[N + 1, B]
  ) 
    case: (
    subst fam ShareSum-OK[bound (N + 1) bound K]
     into chn Share[N + 1, B]
  )  
  )
  ) then
  decompose fam HiddenGroup[bound K] with fam Shares[bound K] then
ungroup fam HiddenGroup[bound K] then
absorb fam Hidden[bound K] then
absorb fam ShareSum-OK[bound (N + 1) bound K]
)     

current-protocol
     check-proof pInt2
          quit