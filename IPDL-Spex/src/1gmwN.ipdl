lang IPDL

import BASEGMWN .

parameter N : nat .
parameter K : nat .

`` Sigma

function xor : bool * bool -> bool .
function ** : bool * bool  -> bool .
function neg : bool -> bool .
distribution flip : unit -> bool .

`` assumptions

expression-assumption %automatic andFalseLeft using x : 
   (x : bool)  |= 
   **( (False, x) ) = False .

    expression-assumption %automatic andFalseRight using x : 
   (x : bool)  |= 
   **( (x, False) ) = False . 

   expression-assumption %automatic andTrueLeft using x : 
   (x : bool)  |= 
   **( (True, x) ) = x .

    expression-assumption %automatic andTrueRight using x : 
   (x : bool)  |= 
   **( (x, True) ) = x .
   
    expression-assumption %automatic xorFalseLeft using x : 
   (x : bool)  |= 
   xor( (False, x) ) = x .

    expression-assumption %automatic xorFalseRight using x : 
   (x : bool)  |= 
   xor( (x, False) ) = x . 
   
    expression-assumption %automatic xorFalse using x : 
   (x : bool)  |= 
   xor( (x, x) ) = False . 
   
   expression-assumption %automatic falseXor using x : 
   (x : bool)  |= 
   xor( (False, False) ) = False . 


hypothesis not (isNotGate(0)) .
hypothesis not (isXorGate(0)) .
hypothesis not (isAndGate(0)) .
hypothesis isHonest(N + 1) .

`` deltaReal 

channel context deltaReal =

input    In[bound N + 2 dependentBound I] : bool ;
output   Out[bound N + 2 bound K] : bool ;
output   CtrbPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   InPartyAdv[bound N + 2 dependentBound I] : bool ;
output   InRcvdPartyAdv[bound N + 2 dependentBound I] : unit ;
output   InSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   InShare$PartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   InShare$-SumPartyAdv[bound N + 1 bound N + 2 dependentBound I] : bool ;
output   OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] : unit ;
output   OTOutOtAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OutPartyAdv[bound N + 2 bound K] : bool ;
output   OutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   OutShareSumPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   RcvdOutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SendBitPartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SendInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I] : bool ;
output   SendOutSharePartyAdv[bound N + 2 bound N + 2 bound K] : bool ;
output   SharePartyAdv[bound N + 2 bound K] : bool
 .

protocol restr =
   newfamily InShare[bound N + 2 bound N + 2 dependentBound I] 
              indices: n, m, i 
             bounds: bound N + 2 bound N + 2 dependentBound I : bool in   
   newfamily Share[bound N + 2 bound K]  
              indices: n, k 
             bounds: bound N + 2 bound K : bool in
(             
     restrInitial || restrInductive || restrFinal
  where    
   restrInitial = 
(   
    newfamily InShare$[bound N + 2 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I : bool in
  newfamily InShare$-Sum[bound N + 1 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 1 bound N + 2 dependentBound I : bool in       
   newfamily SendInShare[bound N + 2 bound N + 2 dependentBound I]
              indices: m, n, i 
             bounds: bound N + 2 bound N + 2 dependentBound I : bool in
   ( 
     (family InPartyAdv[bound N + 2 dependentBound I] 
            indices: n, i
            bounds: bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         in : bool <- read In[n, i] ; return in
       ) 
       ;; 
       (when (isHonest(n)) --> 
         in : bool <- read InPartyAdv[n, i] ; return in
       )       
     ) 
    ||
     (family InRcvdPartyAdv[bound N + 2 dependentBound I] 
        indices: n, i
            bounds:  bound N + 2 dependentBound I ::=
       (when (isHonest(n)) --> 
         x : bool <- read In[n, i] ; return ()
       ) 
       ;; 
       (when (isSemiHonest(n))  --> 
         in : unit <- read InRcvdPartyAdv[n, i] ; return in
       )       
     )
    ||
     (family InShare$[bound N + 2 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (m = N + 1) --> 
             x : bool <- read In[n, i] ;
             s : bool <- read InShare$-Sum[N, n, i] ;
             return xor( (x, s) )
       )
       ;;
       (otherwise --> 
         x : bool <- read In[n, i] ; samp flip (())
       )      
     )
     ||
     (family InShare$-Sum[(bound N + 1 bound N + 2 dependentBound I)] 
             indices: m, n, i  
            bounds: bound N + 1 bound N + 2 dependentBound I ::=
        (when (m = 0) --> 
          in : bool <- read InShare$[0, n, i] ; return in
        )
        ;;
        (otherwise --> 
           x : bool <- read InShare$[m, n, i] ;
           s : bool <- read InShare$-Sum[m - 1, n, i] ;
           return xor((s, x))
        )    
     )
     ||
       (family InShare$PartyAdv
               [bound N + 2 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
          in : bool <- read InShare$[m, n, i] ; return in
       )
       ;;
       (when (isHonest(n))  --> 
         in : bool <- read InShare$PartyAdv[m, n, i] ; return in
       )      
     )
     ||
     (family InShare$-SumPartyAdv
              [bound N + 1 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 1 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read InShare$-Sum[m, n, i] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read InShare$-SumPartyAdv[m, n, i] ;
         return s
       )       
     )
     ||
     (family SendInShare[bound N + 2 bound N + 2 dependentBound I] 
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
        in : bool <- read InShare$[m, n, i] ; return in
     )  
     ||
     (family SendInSharePartyAdv
              [bound N + 2 bound N + 2 dependentBound I]  
             indices: m, n, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendInShare[m, n, i] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SendInSharePartyAdv[m, n, i] ;
         return s
       )        
     )   
     ||
     (family RcvdInSharePartyAdv
              [bound N + 2 bound N + 2 dependentBound I] 
             indices: n, m, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendInShare[n, m, i] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
          s : bool <- read RcvdInSharePartyAdv[n, m, i] ; 
          return s
       )        
     ) 
     ||
    (family InShare[bound N + 2 bound N + 2 dependentBound I] 
             indices: n, m, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
        s : bool <- read SendInShare[n, m, i] ; return s
     )      
     ||
     (family InSharePartyAdv
              [bound N + 2 bound N + 2 dependentBound I] 
             indices: n, m, i  
            bounds: bound N + 2 bound N + 2 dependentBound I ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read InShare[n, m, i] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read InSharePartyAdv[n, m, i] ;
         return s
       )        
     ) 
     ) `` end new    
 ) `` ends restrInitial
 and 
  restrInductive = 
(  
   newfamily OTMsg-0[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in  
   newfamily OTMsg-1[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in 
   newfamily OTMsg-2[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in 
   newfamily OTMsg-3[bound N + 2 bound N + 2 bound K ]
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in 
   newfamily OTChc-0[bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k 
             bounds: bound N + 2 bound N + 2 bound K : bool in  
   newfamily OTChc-1[bound N + 2 bound N + 2 bound K ]
              indices: m, n,  k 
             bounds: bound N + 2 bound N + 2 bound K : bool in                             
   newfamily OTOut[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in   
   newfamily SendBit[bound N + 2 bound N + 2 bound K]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily RcvdBit[bound N + 2 bound N + 2 bound K]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily Ctrb[bound N + 2 bound N + 2 bound K]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily CtrbSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in 
   ( `` start new
    family Circuit[bound N + 2 bound K]  
          indices: n, k 
         bounds: bound N + 2 bound K ::=  
      ( `` start circuit
       (when (isInputGate(k)) -->          
      ( 
         (family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-0[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-0OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-1[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c0 : bool <- read OTChc-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-0OtAdv[n, m, k] ; 
       return oc
     )   
   )
   ||
   (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c1 : bool <- read OTChc-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   ( family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-0[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-1[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-2[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-3[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m0 : bool <- read OTMsg-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m1 : bool <- read OTMsg-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m2 : bool <- read OTMsg-2[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m3 : bool <- read OTMsg-3[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTOutOtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       out : bool <- read OTOut[n, m, k] ; return out
     ) 
     ;;
     (when (isHonest(m))--> 
       out : bool <- read OTOutOtAdv[n, m, k] ; return out
     )   
   )
   ||
   (family OTOut[bound N + 2 bound N + 2 bound K]  
     indices: n, m, k 
     bounds: bound N + 2 bound N + 2 bound K ::=
     m0 : bool <- read OTMsg-0[n, m, k] ;
     m1 : bool <- read OTMsg-1[n, m, k] ;
     m2 : bool <- read OTMsg-2[n, m, k] ;
     m3 : bool <- read OTMsg-3[n, m, k] ;
     c0 : bool <- read OTChc-0[n, m, k] ;
     c1 : bool <- read OTChc-1[n, m, k] ;
         ( if c0 
         then if c1 then return m3 else return m2
         else if c1 then return m1 else return m0
         )
   ) 
   ||
       ( family SendBit[bound N + 2 bound N + 2 bound K ]
                 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBit[n, m, k] ; return sb
 )
 ||
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBitPartyAdv[n, m, k] ; return sb 
 )               
 ||
 ( family RcvdBit[bound N + 2 bound N + 2 bound K ] 
           indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    rb : bool <- read RcvdBit[n, m, k] ; return rb
 )
 ||
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K ] 
          indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
   rb : bool <- read RcvdBitPartyAdv[n, m, k] ; return rb          
 ) 
 ||
 ( family Ctrb[bound N + 2 bound N + 2 bound K ] 
           indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    b : bool <- read Ctrb[n, m, k] ; return b           
 )
 ||
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K ] 
           indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbPartyAdv[n, m, k] ; return b           
 )  
 ||
 (family CtrbSum[bound N + 2 bound N + 2 bound K ] 
          indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbSum[n, m, k] ; return b  
 )
 ||
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K ] 
            indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbSumPartyAdv[n, m, k] ; return b           
 )  
 ||
     ( family Share[ bound N + 2 bound K] 
         indices: n, k 
         bounds: bound N + 2 bound K ::= 
       in : bool <- read InShare[n, wire0(k), wire1(k)] ; return in
     )
     ||
     (family SharePartyAdv[ bound N + 2 bound K]  indices: n, k  
             bounds: bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Share[n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SharePartyAdv[n, k] ; return s
       )        
     )
     ||
     ( family OTMsg-0[bound N + 2 bound N + 2 bound K ] 
               indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-0[n, m, k] ; return om
     )
     ||
     ( family OTMsg-1[bound N + 2 bound N + 2 bound K ]  
        indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-1[n, m, k] ; return om
     )
     ||
     ( family OTMsg-2[bound N + 2 bound N + 2 bound K ] 
       indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-2[n, m, k] ; return om
     )
     ||
     ( family OTMsg-3[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-3[n, m, k]; return om
     )
     ||
     ( family OTChc-0[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-0[m, n, k]; return oc
     )
     ||
     ( family OTChc-1[bound N + 2 bound N + 2 bound K ]  
        indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-1[m, n, k] ; return oc
     )
     )
   )
   ;;
   (when (isNotGate(k)) -->    
      (    (family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-0[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-0OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-1[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c0 : bool <- read OTChc-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-0OtAdv[n, m, k] ; 
       return oc
     )   
   )
   ||
   (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c1 : bool <- read OTChc-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   ( family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-0[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-1[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-2[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-3[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m0 : bool <- read OTMsg-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m1 : bool <- read OTMsg-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m2 : bool <- read OTMsg-2[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m3 : bool <- read OTMsg-3[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTOutOtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       out : bool <- read OTOut[n, m, k] ; return out
     ) 
     ;;
     (when (isHonest(m))--> 
       out : bool <- read OTOutOtAdv[n, m, k] ; return out
     )   
   )
   ||
   (family OTOut[bound N + 2 bound N + 2 bound K]  
     indices: n, m, k 
     bounds: bound N + 2 bound N + 2 bound K ::=
     m0 : bool <- read OTMsg-0[n, m, k] ;
     m1 : bool <- read OTMsg-1[n, m, k] ;
     m2 : bool <- read OTMsg-2[n, m, k] ;
     m3 : bool <- read OTMsg-3[n, m, k] ;
     c0 : bool <- read OTChc-0[n, m, k] ;
     c1 : bool <- read OTChc-1[n, m, k] ;
         ( if c0 
         then if c1 then return m3 else return m2
         else if c1 then return m1 else return m0
         )
   ) 
   ||
       ( family SendBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBit[n, m, k]; return sb
 )
 ||
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBitPartyAdv[n, m, k]; return sb 
 )               
 ||
 ( family RcvdBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    rb : bool <- read RcvdBit[n, m, k]; return rb
 )
 ||
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
   rb : bool <- read RcvdBitPartyAdv[n, m, k]; 
      return rb          
 ) 
 ||
 ( family Ctrb[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    b : bool <- read Ctrb[n, m, k]; return b           
 )
 ||
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbPartyAdv[n, m, k]; return b           
 )  
 ||
 (family CtrbSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbSum[n, m, k]; return b  
 )
 ||
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSumPartyAdv[n, m, k]; return b           
 )  
 ||
     ( family Share[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::= 
        (when (n = N + 1) --> 
          x : bool <- read Share[n, wire0(k)] ; return neg(x)
        )
        ;;
        (when (not(n = N + 1))--> 
          s : bool <- read Share[n, wire0(k)] ; return s
        )
          
     )
     ||
     (family SharePartyAdv[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Share[n, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SharePartyAdv[n, k] ; return s
       )        
     )
     ||
     ( family OTMsg-0[bound N + 2 bound N + 2 bound K ]  
        indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-0[n, m, k] ; return om
     )
     ||
     ( family OTMsg-1[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-1[n, m, k] ; return om
     )
     ||
     ( family OTMsg-2[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-2[n, m, k] ; return om
     )
     ||
     ( family OTMsg-3[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-3[n, m, k] ; return om
     )
     ||
     ( family OTChc-0[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-0[m, n, k] ; return oc
     )
     ||
     ( family OTChc-1[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-1[m, n, k] ; return oc
     )
     ) 
   )
   ;;
   (when (isXorGate(k)) --> 
      (    (family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-0[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-0OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-1[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c0 : bool <- read OTChc-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-0OtAdv[n, m, k] ; 
       return oc
     )   
   )
   ||
   (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c1 : bool <- read OTChc-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   ( family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-0[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-1[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-2[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-3[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m0 : bool <- read OTMsg-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m1 : bool <- read OTMsg-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m2 : bool <- read OTMsg-2[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m3 : bool <- read OTMsg-3[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTOutOtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       out : bool <- read OTOut[n, m, k] ; return out
     ) 
     ;;
     (when (isHonest(m))--> 
       out : bool <- read OTOutOtAdv[n, m, k] ; return out
     )   
   )
   ||
   (family OTOut[bound N + 2 bound N + 2 bound K]  
     indices: n, m, k 
     bounds: bound N + 2 bound N + 2 bound K ::=
     m0 : bool <- read OTMsg-0[n, m, k] ;
     m1 : bool <- read OTMsg-1[n, m, k] ;
     m2 : bool <- read OTMsg-2[n, m, k] ;
     m3 : bool <- read OTMsg-3[n, m, k] ;
     c0 : bool <- read OTChc-0[n, m, k] ;
     c1 : bool <- read OTChc-1[n, m, k] ;
         ( if c0 
         then if c1 then return m3 else return m2
         else if c1 then return m1 else return m0
         )
   ) 
   ||
       ( family SendBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBit[n, m, k]; return sb
 )
 ||
 (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
    sb : bool <- read SendBitPartyAdv[n, m, k]; 
       return sb 
 )               
 ||
 ( family RcvdBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    rb : bool <- read RcvdBit[n, m, k]; return rb
 )
 ||
 (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
   rb : bool <- read RcvdBitPartyAdv[n, m, k]; 
      return rb          
 ) 
 ||
 ( family Ctrb[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    b : bool <- read Ctrb[n, m, k]; return b           
 )
 ||
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbPartyAdv[n, m, k]; return b           
 )  
 ||
 (family CtrbSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   b : bool <- read CtrbSum[n, m, k]; return b  
 )
 ||
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  b : bool <- read CtrbSumPartyAdv[n, m, k]; return b           
 )          
 ||
     ( family Share[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::= 
        x : bool <- read Share[n, wire0(k)] ;
        y : bool <- read Share[n, wire1(k)];
        return  xor((x, y))
     )
     ||
     (family SharePartyAdv[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Share[n, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SharePartyAdv[n, k]; 
            return s
       )        
     )
     ||
     ( family OTMsg-0[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-0[n, m, k];
          return om
     )
     ||
     ( family OTMsg-1[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-1[n, m, k];
          return om
     )
     ||
     ( family OTMsg-2[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-2[n, m, k];
          return om
     )
     ||
     ( family OTMsg-3[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       om : bool <- read OTMsg-3[n, m, k];
          return om
     )
     ||
     ( family OTChc-0[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-0[m, n, k];
          return oc
     )
     ||
     ( family OTChc-1[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       oc : bool <- read OTChc-1[m, n, k];
          return oc
     )   
   ) 
   )
      ;;
   (when (isAndGate(k)) -->
     ( 
        (family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-0[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-0OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       oc : bool <- read OTChc-1[n, m, k] ; return oc
     ) 
     ;;
     (when (isHonest(m))--> 
       oc : bool <- read OTChc-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   (family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c0 : bool <- read OTChc-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-0OtAdv[n, m, k] ; 
       return oc
     )   
   )
   ||
   (family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(m))--> 
       c1 : bool <- read OTChc-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(m))--> 
       oc : unit <- read OTChcRcvd-1OtAdv[n, m, k] ; return oc
     )   
   )
   ||
   ( family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-0[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-1[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-2[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   ( family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(n)) --> 
       om : bool <- read OTMsg-3[n, m, k] ; return om
     ) 
     ;;
     (when (isHonest(n)) --> 
       om : bool <- read OTMsg-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m0 : bool <- read OTMsg-0[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-0OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m1 : bool <- read OTMsg-1[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-1OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m2 : bool <- read OTMsg-2[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-2OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isHonest(n)) --> 
       m3 : bool <- read OTMsg-3[n, m, k] ; return ()
     ) 
     ;;
     (when (isSemiHonest(n)) --> 
       om : unit <- read OTMsgRcvd-3OtAdv[n, m, k] ; return om
     )   
   )
   ||
   (family OTOutOtAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::=
     (when (isSemiHonest(m))--> 
       out : bool <- read OTOut[n, m, k] ; return out
     ) 
     ;;
     (when (isHonest(m))--> 
       out : bool <- read OTOutOtAdv[n, m, k] ; return out
     )   
   )
   ||
   (family OTOut[bound N + 2 bound N + 2 bound K]  
     indices: n, m, k 
     bounds: bound N + 2 bound N + 2 bound K ::=
     m0 : bool <- read OTMsg-0[n, m, k] ;
     m1 : bool <- read OTMsg-1[n, m, k] ;
     m2 : bool <- read OTMsg-2[n, m, k] ;
     m3 : bool <- read OTMsg-3[n, m, k] ;
     c0 : bool <- read OTChc-0[n, m, k] ;
     c1 : bool <- read OTChc-1[n, m, k] ;
         ( if c0 
         then if c1 then return m3 else return m2
         else if c1 then return m1 else return m0
         )
   ) 
   ||
   
     ( family SendBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
            x : bool <- read Share[n, wire0(k)] ; 
            y : bool <- read Share[n, wire1(k)] ;
            samp flip (())
       )
       ;;
       (when (m <= n) --> 
         sb : bool <- read SendBit[n, m, k];
          return sb
       )   
     )
     ||
      (family SendBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendBit[n, m, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SendBitPartyAdv[n, m, k]; 
            return s
       )        
     )
     ||
     ( family OTMsg-0[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
         b : bool <- read SendBit[n, m, k] ;
         x : bool <- read Share[n, wire0(k)] ;
         y : bool <- read Share[n, wire1(k)] ;
         return b
       )
       ;;
       (when (m  <= n) --> 
         om : bool <- read OTMsg-0[n, m, k];
          return om
       )   
     )
     ||
     ( family OTMsg-1[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
          b : bool <- read SendBit[n, m, k] ;
          x : bool <- read Share[n, wire0(k)] ;
          y : bool <- read Share[n, wire1(k)] ;
          return xor((x, b))
       )
       ;;
       (when (m  <= n) --> 
         om : bool <- read OTMsg-1[n, m, k];
          return om
       )   
     )
     ||
     ( family OTMsg-2[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
         b : bool <- read SendBit[n, m, k] ;
          x : bool <- read Share[n, wire0(k)] ;
          y : bool <- read Share[n, wire1(k)] ;
          return xor((y, b))
       )
       ;;
       (when (m  <= n) --> 
         om : bool <- read OTMsg-2[n, m, k];
          return om
       )   
     )
     ||
     ( family OTMsg-3[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (n < m) --> 
         b : bool <- read SendBit[n, m, k] ;
          x : bool <- read Share[n, wire0(k)] ;
          y : bool <- read Share[n, wire1(k)] ;
          return xor( ( xor( (x, y) ), b )  )   
       )
       ;;
       (when (m <= n) --> 
         om : bool <- read OTMsg-3[n, m, k];
          return om
       )   
     )
     ||
     ( family OTChc-0[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
      (when (m < n) --> 
         x : bool <- read Share[n, wire0(k)];
          return x
      )
       ;;
       (when (n <= m) --> 
         oc : bool <- read OTChc-0[m, n, k];
          return oc
       )   
     )
     ||
     ( family OTChc-1[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (m < n) --> 
         x : bool <- read Share[n, wire1(k)];
          return x
       )
       ;;
       (when (n <= m) --> 
         oc : bool <- read OTChc-1[m, n, k];
          return oc
       )   
     )
     ||
     ( family RcvdBit[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
          out : bool <- read OTOut[m, n, k];
              return out
    )
    ||
     (family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (isSemiHonest(n)) --> 
         s : bool <- read RcvdBit[n, m, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read RcvdBitPartyAdv[n, m, k]; 
            return s
       )        
     )
      ||
      ( family Ctrb[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
      (when (n < m) --> 
         s : bool <- read SendBit[n, m, k];
          return s
       )
       ;;
       (when (n = m) --> 
         x : bool <- read Share[n, wire0(k)] ;
         y : bool <- read Share[n, wire1(k)];
          return **((x, y))
          
       )
       ;;
       (when (m < n) --> 
         r : bool <- read RcvdBit[n, m, k];
          return r
       )   
     )
     ||
 (family CtrbPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
         s : bool <- read Ctrb[n, m, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read CtrbPartyAdv[n, m, k]; 
            return s
       )               
 )  
      ||
      (family CtrbSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when (m = 0) --> 
     b : bool <- read Ctrb[n, 0, k];
          return b
   )
   ;;
   (when (not (m = 0)) --> 
     s : bool <- read CtrbSum[n, m - 1, k] ;
     b : bool <- read Ctrb[n, m, k];
     return xor((s, b)) 
   )
 )
 ||
 (family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K ]  indices: n, m, k 
           bounds: bound N + 2 bound N + 2 bound K ::= 
       (when (isSemiHonest(n)) --> 
         s : bool <- read CtrbSum[n, m, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read CtrbSumPartyAdv[n, m, k]; 
            return s
       )        
     )
      ||   
 ( family Share[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::= 
          bs : bool <- read CtrbSum[n, N + 1, k];
              return bs
 )   
 ||
     (family SharePartyAdv[bound N + 2 bound K]  
        indices: n, k 
        bounds: bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Share[n, k]; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SharePartyAdv[n, k]; 
            return s
       )        
     ) 
     )
   )    
      ) `` end circuit
   
   ) `` end new
     
)  `` ends restrinductive
and  
restrFinal = 
(
   newfamily SendOutShare[bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k 
             bounds: bound N + 2 bound N + 2 bound K : bool in          
   newfamily OutShare[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily OutShareSum[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K : bool in
   ( 
     (family SendOutShare[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isOutputWire(k)) --> 
         s : bool <- read Share[n, k] ; return s
       ) 
       ;; 
       (when (not (isOutputWire(k))) --> 
         s : bool <- read SendOutShare[m, n, k] ; return s
       )       
     )
     ||
    (family SendOutSharePartyAdv
               [bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendOutShare[m, n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SendOutSharePartyAdv[m, n, k] ;
         return s
       )       
     )
     ||
     (family RcvdOutSharePartyAdv
               [bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendOutShare[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read RcvdOutSharePartyAdv[n, m, k] ;
         return s
       )       
     )
     || 
     (family OutShare[bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       s : bool <- read SendOutShare[n, m, k] ; return s       
     )
     ||
     (family OutSharePartyAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read OutShare[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutSharePartyAdv[n, m, k] ;
         return s
       )       
     )
     ||
     (family OutShareSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (m = 0) --> 
         s : bool <- read OutShare[n, 0, k] ;
         return s
       )
       ;;
       (otherwise -->
         s : bool <- read OutShareSum[n, m - 1, k] ;
         x : bool <- read OutShare[n, m, k] ;
         return xor((s, x))
       )
     )        
     ||
     (family OutShareSumPartyAdv
              [bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read OutShareSum[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutShareSumPartyAdv[n, m, k] ;
         return s
       )       
     )
     ||
     (family Out[bound N + 2 bound K]  indices: n, k
            bounds: bound N + 2 bound K ::=
       s : bool <- read OutShareSum[n, N + 1, k] ;
       return s
     )
     ||
     (family OutPartyAdv[bound N + 2 bound K]  indices: n, k
             bounds: bound N + 2 bound K  ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Out[n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutPartyAdv[n, k] ;
         return s
       )       
     )
   ) `` end new

) `` ends restrFinal

) . `` ends the where and the protocol declaration

`` pInt0 

protocol pInt0 = 
 newfamily InShare[bound N + 2 bound N + 2 dependentBound I] 
   indices: n, m, i 
   bounds: bound N + 2 bound N + 2 dependentBound I : bool in 
 newfamily Share[bound N + 2 bound K] 
   indices: n, k 
   bounds: bound N + 2 bound K : bool in 
 (simpleRestrInitial || splitCirc || restrFinal)
where
simpleRestrInitial = 
( newfamily InShare$[bound N + 2 bound N + 2 dependentBound I] 
  indices: m, n, i 
  bounds: bound N + 2 bound N + 2 dependentBound I : bool in
 newfamily InShare$-Sum[bound N + 1 bound N + 2 dependentBound I] 
  indices: m, n, i 
  bounds: bound N + 1 bound N + 2 dependentBound I : bool in
  (
  (family InPartyAdv[bound N + 2 dependentBound I]
  indices: n, i bounds: bound N + 2 dependentBound I ::= 
   (when (isSemiHonest(n)) --> 
     nf(in : bool <- read In[n, i], return in) 
   )  ;; 
   (when (isHonest(n)) --> nf(in : bool <- read InPartyAdv[n, i], return in)
   )
)
||
(
family InRcvdPartyAdv[bound N + 2 dependentBound I]
  indices: n, i bounds: bound N + 2 dependentBound I ::= 
  (when (isHonest(n)) --> 
    nf(x : bool <- read In[n, i], return () )
  ) ;;
  ( when (isSemiHonest(n)) --> nf(in : unit <- read InRcvdPartyAdv[n, i], return in)
  )
)
||
(
family InShare[bound N + 2 bound N + 2 dependentBound I]
  indices: n, m, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
 nf(in : bool <- read InShare$[n, m, i], return in)
)
||
(
family InShare$[bound N + 2 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when (m = N + 1) --> 
    nf((s : bool <- read InShare$-Sum[N, n, i]) 
        x : bool <- read In[n, i], 
        return xor((x, s)))
  ) ;; 
  (otherwise --> nf(x : bool <- read In[n, i], samp flip (()) )
  )
)
||
(
family InShare$-Sum[bound N + 1 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 1 bound N + 2 dependentBound I ::= 
  (when (0 = m) --> 
    nf(in : bool <- read InShare$[0, n, i], return in) 
  ) ;; 
  (otherwise --> 
    nf((s : bool <- read InShare$-Sum[m - 1, n, i]) 
        x : bool <- read InShare$[m, n, i], 
        return xor((s, x)))
  )      
)
||
(
family InShare$-SumPartyAdv[bound N + 1 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 1 bound N + 2 dependentBound I ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read InShare$-Sum[m, n, i], return s) 
  ) ;;
  (when (isHonest(n)) --> 
    nf(s : bool <- read InShare$-SumPartyAdv[m, n, i], return s)
  )  
)
||
(
family InShare$PartyAdv[bound N + 2 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
 (when (isSemiHonest(n)) --> 
    nf(in : bool <- read InShare$[m, n, i], return in) 
 ) ;; 
 (when (isHonest(n)) --> 
   nf(in : bool <- read InShare$PartyAdv[m, n, i], return in)
 )  
)
||
(
family InSharePartyAdv[bound N + 2 bound N + 2 dependentBound I]
  indices: n, m, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when (isSemiHonest(n)) --> nf(s : bool <- read InShare[n, m, i], return s)
  ) 
  ;; 
  (when (isHonest(n)) --> nf(s : bool <- read InSharePartyAdv[n, m, i], return s))
)
||
(
family RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I]
  indices: n, m, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when (isSemiHonest(n)) --> nf(in : bool <- read InShare$[n, m, i], return in) 
  ) ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read RcvdInSharePartyAdv[n, m, i], return s)
  )  
)
||
(
family SendInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I]
  indices: m, n, i bounds: bound N + 2 bound N + 2 dependentBound I ::= 
  (when (isSemiHonest(n)) --> 
    nf(in : bool <- read InShare$[m, n, i], return in)
  ) ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read SendInSharePartyAdv[m, n, i], return s)
  )  
)
  )
)`` end simplRestrInitial  
and
splitCirc = (
 newfamily SendBit[bound N + 2 bound N + 2 bound K] 
  indices: n, m, k 
  bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily RcvdBit[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k 
   bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily Ctrb[bound N + 2 bound N + 2 bound K] 
  indices: n, m, k 
  bounds: bound N + 2 bound N + 2 bound K : bool in
 newfamily CtrbSum[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k 
   bounds: bound N + 2 bound N + 2 bound K : bool in
 (adv || shares || 1OutOf4OT)
 where 
adv = (
   family Adv[bound K] indices: k bounds: bound K ::=
  (`` start group 
(when (isInputGate(k)) --> 
(
(family CtrbPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool  <- read CtrbPartyAdv[n, m, k], return b) 
)
||
(
family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(b : bool <- read CtrbSumPartyAdv[n, m, k], return b) 
)
||
(
family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-0OtAdv[n, m, k], return oc) 
)
||
(

family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-1OtAdv[n, m, k], return oc)
)
||
(
family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(oc : unit <- read OTChcRcvd-0OtAdv[n, m, k], return oc)
)
||
(

family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : unit <- read OTChcRcvd-1OtAdv[n, m, k], return oc) 
)
||
(

family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-0OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : bool <- read OTMsg-1OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-3OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-0OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : unit <- read OTMsgRcvd-1OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-3OtAdv[n, m, k], return om) 
)
||
(
family OTOutOtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(out : bool <- read OTOutOtAdv[n, m, k], return out) 
)
||
(
family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb :  bool <- read RcvdBitPartyAdv[n, m, k], return rb) 
)
||
(
family SendBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb :  bool <- read SendBitPartyAdv[n, m, k], return sb) 
)
||
(
family SharePartyAdv[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read  Share[n, k], return s) 
  )  
  ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read SharePartyAdv[n, k], return s)
  )  
)
) `` end input gate
) `` end when
;;
(when (isNotGate(k)) --> 
(
(family CtrbPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool  <- read CtrbPartyAdv[n, m, k], return b) 
)
||
(
family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(b : bool <- read CtrbSumPartyAdv[n, m, k], return b) 
)
||
(
family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-0OtAdv[n, m, k], return oc) 
)
||
(

family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-1OtAdv[n, m, k], return oc)
)
||
(
family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(oc : unit <- read OTChcRcvd-0OtAdv[n, m, k], return oc)
)
||
(

family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : unit <- read OTChcRcvd-1OtAdv[n, m, k], return oc) 
)
||
(

family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-0OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : bool <- read OTMsg-1OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-3OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-0OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : unit <- read OTMsgRcvd-1OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-3OtAdv[n, m, k], return om) 
)
||
(
family OTOutOtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(out : bool <- read OTOutOtAdv[n, m, k], return out) 
)
||
(
family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb :  bool <- read RcvdBitPartyAdv[n, m, k], return rb) 
)
||
(
family SendBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb :  bool <- read SendBitPartyAdv[n, m, k], return sb) 
)
||
(
family SharePartyAdv[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read  Share[n, k], return s) 
  )  
  ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read SharePartyAdv[n, k], return s)
  )  
)
) `` end not gate
) `` end when
;;
(when (isXorGate(k)) --> 
(
(family CtrbPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool  <- read CtrbPartyAdv[n, m, k], return b) 
)
||
(
family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(b : bool <- read CtrbSumPartyAdv[n, m, k], return b) 
)
||
(
family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-0OtAdv[n, m, k], return oc) 
)
||
(

family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-1OtAdv[n, m, k], return oc)
)
||
(
family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(oc : unit <- read OTChcRcvd-0OtAdv[n, m, k], return oc)
)
||
(

family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : unit <- read OTChcRcvd-1OtAdv[n, m, k], return oc) 
)
||
(

family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-0OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : bool <- read OTMsg-1OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-3OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-0OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  nf(om : unit <- read OTMsgRcvd-1OtAdv[n, m, k], return om)
)
||
(
family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-2OtAdv[n, m, k], return om) 
)
||
(
family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : unit <- read OTMsgRcvd-3OtAdv[n, m, k], return om) 
)
||
(
family OTOutOtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(out : bool <- read OTOutOtAdv[n, m, k], return out) 
)
||
(
family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb :  bool <- read RcvdBitPartyAdv[n, m, k], return rb) 
)
||
(
family SendBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb :  bool <- read SendBitPartyAdv[n, m, k], return sb) 
)
||
(
family SharePartyAdv[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read  Share[n, k], return s) 
  )
  ;; 
  ( when (isHonest(n)) --> 
    nf(s : bool <- read SharePartyAdv[n, k], return s)
  )  
)
) `` end xor gate
) `` end when
;;

(when (isAndGate(k)) --> 
(
(family CtrbPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=  
   (when (isSemiHonest(n)) --> nf(s : bool <- read Ctrb[n, m, k], return s) 
   )
   ;; 
   (when (isHonest(n)) --> nf(s : bool <- read CtrbPartyAdv[n, m, k], return s)
   )
)
||
(
family CtrbSumPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when (isSemiHonest(n)) --> 
     nf(s : bool <- read CtrbSum[n, m, k], return s) 
   )  
   ;; 
   (when (isHonest(n)) --> 
   nf(s : bool <- read CtrbSumPartyAdv[n, m, k], return s)
   )
)
||
(
family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isSemiHonest(m))) --> 
      nf(x : bool <- read Share[m, wire0(k)], return x) 
    )  
    ;; 
    (when ((m <= n) or (isHonest(m)) ) --> 
    nf(oc : bool <- read OTChc-0OtAdv[n, m, k], return oc)
    )
)
||
(

family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isSemiHonest(m))) --> 
     nf(x : bool <- read Share[m, wire1(k)], return x) 
    ) 
    ;; 
       (when ((m <= n) or (isHonest(m)) ) -->  
        nf(oc : bool <- read OTChc-1OtAdv[n, m, k], return oc)
       ) 
)
||
(
family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when ((n < m) and (isHonest(m))) --> 
    nf(x : bool <- read Share[m, wire0(k)], return()) 
   ) 
   ;; 
   (when ((m <= n) or (isSemiHonest(m))) --> 
    nf(oc : unit <- read OTChcRcvd-0OtAdv[n, m, k], return oc)
   ) 
)
||
(

family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 (when ((n < m) and (isHonest(m))) --> 
   nf(x : bool <- read Share[m, wire1(k)], return()) 
 )  
  ;; 
  (when ((m <= n) or (isSemiHonest(m))) --> 
   nf(oc : unit <- read OTChcRcvd-1OtAdv[n, m, k], return oc)
   )
)
||
(

family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isSemiHonest(n))) --> 
     nf((b : bool <- read SendBit[n, m, k])
        (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return b) 
    )    
    ;; 
    (when ((m <= n) or (isHonest(n))) --> 
     nf(om : bool <- read OTMsg-0OtAdv[n, m, k], return om)
    ) 
)
||
(
family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isSemiHonest(n))) --> 
         nf((b : bool <- read SendBit[n, m, k])
            (x : bool <- read Share[n, wire0(k)]) 
             y : bool <- read Share[n, wire1(k)], return xor((x, b))) 
    )
   ;; 
   (when ((m <= n) or (isHonest(n))) -->  
     nf(om : bool <- read OTMsg-1OtAdv[n, m, k], return om)
   )
)
||
(

family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   ( when ((n < m) and (isSemiHonest(n))) -->  
    nf((b : bool <- read SendBit[n, m, k])
       (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return xor((y, b))
      )
   )    
    ;; 
    (when ((m <= n) or (isHonest(n)))
    --> nf(om : bool <- read OTMsg-2OtAdv[n, m, k], return om)
    ) 
)
||
(

family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when ((n < m) and (isSemiHonest(n))) -->  
    nf((b : bool <- read SendBit[n, m, k])
       (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return xor((xor((x, y)), b))
      )
   )     
    ;; 
    (when ((m <= n) or (isHonest(n))) --> 
      nf(om : bool <- read OTMsg-3OtAdv[n, m, k], return om)
    )  
)
||
(
family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=  
  (when ((n < m) and (isHonest(n))) --> 
    nf((b : bool <- read SendBit[n, m, k])
       (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return()
      )
  )      
    ;; 
  (when ((m <= n) or (isSemiHonest(n))) -->  
    nf(om : unit <- read OTMsgRcvd-0OtAdv[n, m, k], return om)
  )  
)
||
(
family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   (when ((n < m) and (isHonest(n))) --> 
    nf((b : bool <- read SendBit[n, m, k])
       (x : bool <- read Share[n, wire0(k)]) 
        y : bool <- read Share[n, wire1(k)], return()
      )
   )        
    ;; 
    (when ((m <= n) or (isSemiHonest(n))) --> 
     nf(om : unit <- read OTMsgRcvd-1OtAdv[n, m, k], return om)
    ) 
)
||
(
family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when ((n < m) and (isHonest(n))) --> 
     nf((b : bool <- read SendBit[n, m, k])
        (x : bool <- read Share[n, wire0(k)]) 
         y : bool <- read Share[n, wire1(k)], return()
       ) 
    )   
    ;; 
    (when ((m <= n) or (isSemiHonest(n))) --> 
      nf(om : unit <- read OTMsgRcvd-2OtAdv[n, m, k], return om)
    )  
)
||
(
family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  (when ((n < m) and (isHonest(n))) --> 
   nf((b : bool <-  read SendBit[n, m, k])
      (x : bool <- read Share[n, wire0(k)]) 
       y : bool <- read Share[n, wire1(k)], return()
     ) 
  )   
    ;; 
   ( when ((m <= n) or (isSemiHonest(n))) --> 
    nf(om : unit <- read OTMsgRcvd-3OtAdv[n, m, k], return om)
   ) 
)
||
(
family OTOutOtAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
     (when (isSemiHonest(m)) --> 
       nf(out : bool <- read RcvdBit[m, n, k], return out)
     )  
     ;; 
     (when (isHonest(m)) --> 
       nf(out : bool <- read OTOutOtAdv[n, m, k], return out)
     )  
)
||
(
family RcvdBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read RcvdBit[n, m, k], return s) 
  )  
    ;; 
   ( when (isHonest(n))  --> 
     nf(s : bool <- read RcvdBitPartyAdv[n, m, k], return s)
   )  
)
||
(
family SendBitPartyAdv[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (isSemiHonest(n)) --> 
    nf(s : bool <- read SendBit[n, m, k], return s) 
  ) ;; 
  (when (isHonest(n)) --> 
    nf(s : bool <- read SendBitPartyAdv[n, m, k], return s)
  )  
)
||
(
family SharePartyAdv[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::=  
   (when (isSemiHonest(n)) --> 
     nf(s : bool <- read Share[n, k], return s) 
   )  
   ;; 
   (when (isHonest(n)) --> 
     nf(s : bool <- read SharePartyAdv[n, k], return s)
   )
)     
) `` end and gate
) `` end when
)`` end group   
 )

 and 
 shares = (
  family Shares[bound K] indices: k bounds: bound K ::=
   
   (when (isInputGate(k)) --> 
   (
    (family Ctrb[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
     nf(b : bool <- read Ctrb[n, m, k], return b) 
    )
    ||
(
family CtrbSum[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool <- read CtrbSum[n, m, k], return b) 
)
||
(
family RcvdBit[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb : bool <- read RcvdBit[n, m, k], return rb) 
)
||
(
family SendBit[bound N + 2 bound N + 2 bound K] 
 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb : bool <- read SendBit[n, m, k], return sb) 
)
||
(
family Share[bound N + 2 bound K] 
 indices: n, k bounds: bound N + 2 bound K ::=
  nf(in : bool <- read InShare[n, wire0(k), wire1(k)], return in) 
)
   
   ) ``end input gate
   ) ``end when 
 ;;
( when (isNotGate(k)) -->
(
 (family Ctrb[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
     nf(b : bool <- read Ctrb[n, m, k], return b) 
)
||
(
family CtrbSum[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool <- read CtrbSum[n, m, k], return b) 
)
||
(
family RcvdBit[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb : bool <- read RcvdBit[n, m, k], return rb) 
)
||
(
family SendBit[bound N + 2 bound N + 2 bound K] 
 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb : bool <- read SendBit[n, m, k], return sb) 
)
||
(
family Share[bound N + 2 bound K] 
 indices: n, k bounds: bound N + 2 bound K ::=
  (when (n = N + 1) --> nf(x : bool <- read Share[n, wire0(k)], return neg(x)) 
  )
  ;; 
  (when (not (n = N + 1)) --> nf(s : bool <- read Share[n, wire0(k)], return s)  
  )
)
) `` end not gate
) `` end when
;; 
( when (isXorGate(k)) -->
(
 (family Ctrb[bound N + 2 bound N + 2 bound K] 
   indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
     nf(b : bool <- read Ctrb[n, m, k], return b) 
)
||
(
family CtrbSum[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(b : bool <- read CtrbSum[n, m, k], return b) 
)
||
(
family RcvdBit[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(rb : bool <- read RcvdBit[n, m, k], return rb) 
)
||
(
family SendBit[bound N + 2 bound N + 2 bound K] 
 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(sb : bool <- read SendBit[n, m, k], return sb) 
)
||
(
family Share[bound N + 2 bound K] 
 indices: n, k bounds: bound N + 2 bound K ::=
  nf((x : bool <- read Share[n, wire0(k)]) y : bool <- read
    Share[n, wire1(k)], return xor((x, y))) 
)
) `` end xor gate
) `` end when  
;; 
( when (isAndGate(k)) --> 
(
(family Ctrb[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
    (when (n < m) --> nf(s : bool <- read SendBit[n, m, k], return s) )
    ;; 
    (when (m = n) --> 
     nf((x : bool <- read Share[n, wire0(k)]) 
         y : bool <- read Share[n, wire1(k)], return **((x, y))
       ) 
    )   
    ;;
    (when (m < n) --> nf(r : bool <- read RcvdBit[n, m, k], return r)
    )
)
||
(
family CtrbSum[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=  
  (when (0 = m)  --> nf(b : bool <- read Ctrb[n, 0, k], return b) )
  ;; 
  (when (not (0 = m)) --> 
   nf((b : bool <- read Ctrb[n, m, k]) 
       s : bool <- read CtrbSum[n, m - 1, k], return xor((s, b)) 
     )
  )   
)
||
(
family RcvdBit[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
   nf((b : bool <- read SendBit[m, n, k])
      (xm : bool <- read Share[m, wire0(k)])
      (xn : bool <- read Share[n, wire0(k)])
      (ym : bool <- read Share[m, wire1(k)]) 
       yn : bool <- read Share[n, wire1(k)], 
        return xor((xor((**((xm, yn)), **((xn, ym)))), b))
     )
)
||
(
family SendBit[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 (when (n < m) --> 
  nf((x : bool <- read Share[n, wire0(k)]) 
      y : bool <- read Share[n, wire1(k)], samp flip(())
    ) 
 )   
 ;; 
 (when (m <= n) --> nf(sb : bool <- read SendBit[n, m, k], return sb)
 )
)
||
(
family Share[bound N + 2 bound K]
  indices: n, k bounds: bound N + 2 bound K ::= 
  nf(bs : bool <- read CtrbSum[n, N + 1, k], return bs)
)
) `` end and gate
) `` end when
   
  ) `` end shares
 and 
1OutOf4OT = (
   newfamily OTMsg-0[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in  
   newfamily OTMsg-1[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in 
   newfamily OTMsg-2[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in 
   newfamily OTMsg-3[bound N + 2 bound N + 2 bound K ]
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in 
   newfamily OTChc-0[bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k 
             bounds: bound N + 2 bound N + 2 bound K : bool in  
   newfamily OTChc-1[bound N + 2 bound N + 2 bound K ]
              indices: m, n,  k 
             bounds: bound N + 2 bound N + 2 bound K : bool in                             
   newfamily OTOut[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k 
             bounds: bound N + 2 bound N + 2 bound K : bool in
     family 1OutOf4OT[bound K]
  indices: k bounds: bound K ::=     
 (``start 1outof4ot       
      (when (isInputGate(k)) --> 
(      
  (family OTChc-0[bound N + 2 bound N + 2 bound K] 
    indices: m, n, k bounds: bound N + 2 bound N + 2 bound K ::= 
    nf(oc : bool <- read OTChc-0[m, n, k], return oc) 
)
||
(
family OTChc-1[bound N + 2 bound N + 2 bound K] 
indices: m, n, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-1[m, n, k], return oc) 
)
||
(
family OTMsg-0[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-0[n, m, k], return om) 
)
||
(
family OTMsg-1[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
nf(om : bool <- read OTMsg-1[n, m, k], return om) 
)
||
(
family OTMsg-2[bound N + 2 bound N + 2 bound K] 
 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(om : bool <- read OTMsg-2[n, m, k], return om) 
)
||
(
family OTMsg-3[bound N + 2 bound N + 2 bound K] 
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(om : bool <- read OTMsg-3[n, m, k], return om) 
)
||
(
family OTOut[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(o : bool <- read OTOut[n, m, k], return o) 
)
  )`` end input gate
) `` end when  
 ;;
 (when (isNotGate(k)) --> 
 (
   (family OTChc-0[bound N + 2 bound N + 2 bound K] 
    indices: m, n, k bounds: bound N + 2 bound N + 2 bound K ::= 
    nf(oc : bool <- read OTChc-0[m, n, k], return oc) 
)
||
(
family OTChc-1[bound N + 2 bound N + 2 bound K] 
indices: m, n, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-1[m, n, k], return oc) 
)
||
(
family OTMsg-0[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-0[n, m, k], return om) 
)
||
(
family OTMsg-1[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
nf(om : bool <- read OTMsg-1[n, m, k], return om) 
)
||
(
family OTMsg-2[bound N + 2 bound N + 2 bound K] 
 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(om : bool <- read OTMsg-2[n, m, k], return om) 
)
||
(
family OTMsg-3[bound N + 2 bound N + 2 bound K] 
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(om : bool <- read OTMsg-3[n, m, k], return om) 
)
||
(
family OTOut[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(o : bool <- read OTOut[n, m, k], return o) 
)
 ) `` end not gate
 ) `` end when  
 ;;
 (when (isXorGate(k)) -->
 (
   (family OTChc-0[bound N + 2 bound N + 2 bound K] 
    indices: m, n, k bounds: bound N + 2 bound N + 2 bound K ::= 
    nf(oc : bool <- read OTChc-0[m, n, k], return oc) 
)
||
(
family OTChc-1[bound N + 2 bound N + 2 bound K] 
indices: m, n, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(oc : bool <- read OTChc-1[m, n, k], return oc) 
)
||
(
family OTMsg-0[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(om : bool <- read OTMsg-0[n, m, k], return om) 
)
||
(
family OTMsg-1[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
nf(om : bool <- read OTMsg-1[n, m, k], return om) 
)
||
(
family OTMsg-2[bound N + 2 bound N + 2 bound K] 
 indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(om : bool <- read OTMsg-2[n, m, k], return om) 
)
||
(
family OTMsg-3[bound N + 2 bound N + 2 bound K] 
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf(om : bool <- read OTMsg-3[n, m, k], return om) 
)
||
(
family OTOut[bound N + 2 bound N + 2 bound K] 
indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
 nf(o : bool <- read OTOut[n, m, k], return o) 
)
 ) `` end xor gate
 ) `` end when  
;;
( when isAndGate(k) --> 
(
 (family OTChc-0[bound N + 2 bound N + 2 bound K]
  indices: m, n, k bounds: bound N + 2 bound N + 2 bound K ::= 
     (when (m < n) --> nf(x : bool <- read Share[n, wire0(k)], return x))
     ;; 
     (when (n <= m)  --> nf(oc : bool <- read OTChc-0[m, n, k], return oc))
)
||
(
family OTChc-1[bound N + 2 bound N + 2 bound K]
  indices: m, n, k bounds: bound N + 2 bound N + 2 bound K ::= 
     (when (m < n) --> nf(x : bool <- read Share[n, wire1(k)], return x) ) 
     ;; 
     (when (n <= m)  --> nf(oc : bool <- read OTChc-1[m, n, k], return oc))
)
||
(
family OTMsg-0[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (n < m) --> 
    nf((b : bool <- read SendBit[n, m, k])
       (x : bool <- read Share[n, wire0(k)])
        y : bool <- read Share[n, wire1(k)], return b) 
  )      
  ;; 
  (when (m <= n) --> nf(om : bool <- read OTMsg-0[n, m, k], return om)
  )
)
||
(
family OTMsg-1[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (n < m) --> nf((b : bool <- read SendBit[n, m, k])(x : bool <- read Share[n, wire0(k)])
    y : bool <- read Share[n, wire1(k)], return xor((x, b))) 
  )  
  ;; 
  (when (m <= n) --> nf(om : bool <- read OTMsg-1[n, m, k], return om)
  )
)
||
(
family OTMsg-2[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  (when (n < m) --> nf((b : bool <- read SendBit[n, m, k])(x : bool <- read Share[n, wire0(k)])
    y : bool <- read Share[n, wire1(k)], return xor((y, b))) 
  )  
  ;; 
  (when (m <= n) --> nf(om : bool <- read OTMsg-2[n, m, k], return om)
  )
)
||
(
family OTMsg-3[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::=
  (when (n < m) -->  nf((b : bool <- read SendBit[n, m, k])(x : bool <- read Share[n, wire0(k)])
    y : bool <- read Share[n, wire1(k)], return xor((xor((x, y)), b))) 
  )  
  ;; 
  (when (m <= n) --> nf(om : bool <- read OTMsg-3[n, m, k], return om)
  )
)
||
(
family OTOut[bound N + 2 bound N + 2 bound K]
  indices: n, m, k bounds: bound N + 2 bound N + 2 bound K ::= 
  nf((c0 : bool <- read OTChc-0[n, m, k])
     (c1 : bool <- read OTChc-1[n, m, k])
     (m0 : bool <- read OTMsg-0[n, m, k])
     (m1 : bool <- read OTMsg-1[n, m, k])
     (m2 : bool <- read OTMsg-2[n, m, k]) 
      m3 : bool <- read OTMsg-3[n, m, k], 
       if c0 then if c1 then return m3 else return m2 
             else if c1 then return m1 else return m0)
)

) `` end and gate
) `` end when  
) ``end 1outof4ot group
  ) `` end protocol =

) `` end splitcirc
and 
restrFinal = 
(
   newfamily SendOutShare[bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k 
             bounds: bound N + 2 bound N + 2 bound K : bool in          
   newfamily OutShare[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K : bool in
   newfamily OutShareSum[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K : bool in
   ( 
     (family SendOutShare[bound N + 2 bound N + 2 bound K ]  indices: m, n,  k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isOutputWire(k)) --> 
         s : bool <- read Share[n, k] ; return s
       ) 
       ;; 
       (when (not (isOutputWire(k))) --> 
         s : bool <- read SendOutShare[m, n, k] ; return s
       )       
     )
     ||
    (family SendOutSharePartyAdv
               [bound N + 2 bound N + 2 bound K ] 
              indices: m, n,  k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendOutShare[m, n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read SendOutSharePartyAdv[m, n, k] ;
         return s
       )       
     )
     ||
     (family RcvdOutSharePartyAdv
               [bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read SendOutShare[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read RcvdOutSharePartyAdv[n, m, k] ;
         return s
       )       
     )
     || 
     (family OutShare[bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       s : bool <- read SendOutShare[n, m, k] ; return s       
     )
     ||
     (family OutSharePartyAdv[bound N + 2 bound N + 2 bound K ] 
              indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read OutShare[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutSharePartyAdv[n, m, k] ;
         return s
       )       
     )
     ||
     (family OutShareSum[bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (m = 0) --> 
         s : bool <- read OutShare[n, 0, k] ;
         return s
       )
       ;;
       (otherwise -->
         s : bool <- read OutShareSum[n, m - 1, k] ;
         x : bool <- read OutShare[n, m, k] ;
         return xor((s, x))
       )
     )        
     ||
     (family OutShareSumPartyAdv
              [bound N + 2 bound N + 2 bound K ]  indices: n, m, k
             bounds: bound N + 2 bound N + 2 bound K ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read OutShareSum[n, m, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutShareSumPartyAdv[n, m, k] ;
         return s
       )       
     )
     ||
     (family Out[bound N + 2 bound K]  indices: n, k
            bounds: bound N + 2 bound K ::=
       s : bool <- read OutShareSum[n, N + 1, k] ;
       return s
     )
     ||
     (family OutPartyAdv[bound N + 2 bound K]  indices: n, k
             bounds: bound N + 2 bound K  ::=
       (when (isSemiHonest(n)) --> 
         s : bool <- read Out[n, k] ; return s
       ) 
       ;; 
       (when (isHonest(n))  --> 
         s : bool <- read OutPartyAdv[n, k] ;
         return s
       )       
     )
   ) `` end new

) `` ends restrFinal
.



`` ends pInt0

start with restr over deltaReal then
on branch isSemiHonest(n) of family SendInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I](
    subst fam SendInShare[bound N + 2 bound N + 2 dependentBound I]
    into fam SendInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I]
) then
rename variables m to x, n to y, i to z of fam SendInShare[bound N + 2 bound N + 2 dependentBound I] then
on branch isSemiHonest(n) of family RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I](
    subst fam SendInShare[bound N + 2 bound N + 2 dependentBound I]
    into fam RcvdInSharePartyAdv[bound N + 2 bound N + 2 dependentBound I]
) then
subst fam SendInShare[bound N + 2 bound N + 2 dependentBound I]
into  fam InShare[bound N + 2 bound N + 2 dependentBound I] then
absorb fam SendInShare[bound N + 2 bound N + 2 dependentBound I] then
on branch isInputGate(k) of group Circuit[bound N + 2 bound K] (
    on branch isSemiHonest(n) of family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-0[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-0[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(n) of family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-1[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-1[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(n) of family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-2[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-2[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(n) of family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-3[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-3[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables m to x, n to y, k to z of fam OTChc-0[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(m) of family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-0[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(m) of family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-0[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables x to m, y to n, z to k of fam OTChc-0[bound N + 2 bound N + 2 bound K] then
    rename variables m to x, n to y, k to z of fam OTChc-1[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(m) of family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-1[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(m) of family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-1[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables x to m, y to n, z to k of fam OTChc-1[bound N + 2 bound N + 2 bound K] then
    diverge on fam OTOut[bound N + 2 bound N + 2 bound K] 
    with fam OTMsg-0[bound N + 2 bound N + 2 bound K]  
    var o then
    on branch isSemiHonest(m) of family OTOutOtAdv[bound N + 2 bound N + 2 bound K]  (
       diverge on fam OTOutOtAdv[bound N + 2 bound N + 2 bound K] 
       with fam OTOut[bound N + 2 bound N + 2 bound K]  
       var out
    ) then
    merge cases for fam OTOutOtAdv[bound N + 2 bound N + 2 bound K]
) then
`` not
on branch isNotGate(k) of group Circuit[bound N + 2 bound K] (
    on branch isSemiHonest(n) of family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-0[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-0[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(n) of family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-1[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-1[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(n) of family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-2[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-2[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(n) of family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-3[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-3[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables m to x, n to y, k to z of fam OTChc-0[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(m) of family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-0[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(m) of family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-0[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables x to m, y to n, z to k of fam OTChc-0[bound N + 2 bound N + 2 bound K] then
    rename variables m to x, n to y, k to z of fam OTChc-1[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(m) of family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-1[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(m) of family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-1[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables x to m, y to n, z to k of fam OTChc-1[bound N + 2 bound N + 2 bound K] then
    diverge on fam OTOut[bound N + 2 bound N + 2 bound K] 
    with fam OTMsg-0[bound N + 2 bound N + 2 bound K]  
    var o then
    on branch isSemiHonest(m) of family OTOutOtAdv[bound N + 2 bound N + 2 bound K]  (
       diverge on fam OTOutOtAdv[bound N + 2 bound N + 2 bound K] 
       with fam OTOut[bound N + 2 bound N + 2 bound K]  
       var out
    ) then
    merge cases for fam OTOutOtAdv[bound N + 2 bound N + 2 bound K]
) then
`` xor
on branch isXorGate(k) of group Circuit[bound N + 2 bound K] (
    on branch isSemiHonest(n) of family OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-0[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-0[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(n) of family OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-1[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-1[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(n) of family OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-2[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-2[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(n) of family OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-3[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(n) of family OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTMsg-3[bound N + 2 bound N + 2 bound K]  
       var om
    ) then
    merge cases for fam OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables m to x, n to y, k to z of fam OTChc-0[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(m) of family OTChc-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChc-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-0[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(m) of family OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-0[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables x to m, y to n, z to k of fam OTChc-0[bound N + 2 bound N + 2 bound K] then
    rename variables m to x, n to y, k to z of fam OTChc-1[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(m) of family OTChc-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChc-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-1[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] then
    on branch isHonest(m) of family OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K ] (
       diverge on fam OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K]
       with fam OTChc-1[bound N + 2 bound N + 2 bound K]  
       var oc
    ) then
    merge cases for fam OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables x to m, y to n, z to k of fam OTChc-1[bound N + 2 bound N + 2 bound K] then
    diverge on fam OTOut[bound N + 2 bound N + 2 bound K] 
    with fam OTMsg-0[bound N + 2 bound N + 2 bound K]  
    var o then
    on branch isSemiHonest(m) of family OTOutOtAdv[bound N + 2 bound N + 2 bound K]  (
       diverge on fam OTOutOtAdv[bound N + 2 bound N + 2 bound K] 
       with fam OTOut[bound N + 2 bound N + 2 bound K]  
       var out
    ) then
    merge cases for fam OTOutOtAdv[bound N + 2 bound N + 2 bound K]
) then
``and 
on branch isAndGate(k) of group Circuit[bound N + 2 bound K] (
    subst fam OTMsg-0[bound N + 2 bound N + 2 bound K]
    into fam OTMsg-0OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTMsg-1[bound N + 2 bound N + 2 bound K]
    into fam OTMsg-1OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTMsg-2[bound N + 2 bound N + 2 bound K]
    into fam OTMsg-2OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTMsg-3[bound N + 2 bound N + 2 bound K]
    into fam OTMsg-3OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTMsg-0[bound N + 2 bound N + 2 bound K]
       into fam OTMsgRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTMsg-1[bound N + 2 bound N + 2 bound K]
       into fam OTMsgRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTMsg-2[bound N + 2 bound N + 2 bound K]
       into fam OTMsgRcvd-2OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTMsg-3[bound N + 2 bound N + 2 bound K]
       into fam OTMsgRcvd-3OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam RcvdBit[bound N + 2 bound N + 2 bound K] then
    on branch isSemiHonest(m) of family OTOutOtAdv[bound N + 2 bound N + 2 bound K](
        reverse subst fam RcvdBit[bound N + 2 bound N + 2 bound K]
                in fam OTOutOtAdv[bound N + 2 bound N + 2 bound K]
                using fam OTOut[bound N + 2 bound N + 2 bound K] 
    ) then
    rename variables m to x, n to y, k to z of fam RcvdBit[bound N + 2 bound N + 2 bound K] then
    subst fam OTOut[bound N + 2 bound N + 2 bound K] into  fam RcvdBit[bound N + 2 bound N + 2 bound K] then
    rename variables x to n, y to m, z to k of fam RcvdBit[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam OTMsg-0[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam OTMsg-1[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam OTMsg-2[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam OTMsg-3[bound N + 2 bound N + 2 bound K] then
    subst or diverge fam OTMsg-0[bound N + 2 bound N + 2 bound K]
    into fam RcvdBit[bound N + 2 bound N + 2 bound K] var z then
    on branch m < n of family RcvdBit[bound N + 2 bound N + 2 bound K](
        subst fam OTMsg-1[bound N + 2 bound N + 2 bound K] 
        into fam RcvdBit[bound N + 2 bound N + 2 bound K] then
        subst fam OTMsg-2[bound N + 2 bound N + 2 bound K] 
        into fam RcvdBit[bound N + 2 bound N + 2 bound K] then
        subst fam OTMsg-3[bound N + 2 bound N + 2 bound K] 
        into fam RcvdBit[bound N + 2 bound N + 2 bound K] then 
        rename x to xm, y to ym in fam RcvdBit[bound N + 2 bound N + 2 bound K] then
        subst fam OTChc-0[bound N + 2 bound N + 2 bound K] 
        into fam RcvdBit[bound N + 2 bound N + 2 bound K] then
        rename x to xn in fam RcvdBit[bound N + 2 bound N + 2 bound K] then
        subst fam OTChc-1[bound N + 2 bound N + 2 bound K] 
        into fam RcvdBit[bound N + 2 bound N + 2 bound K] then
        rename x to yn in fam RcvdBit[bound N + 2 bound N + 2 bound K] 
    ) then
    rename variables m to n, n to m, k to k of fam OTMsg-0[bound N + 2 bound N + 2 bound K] then
    rename variables m to n, n to m, k to k of fam OTMsg-1[bound N + 2 bound N + 2 bound K] then
    rename variables m to n, n to m, k to k of fam OTMsg-2[bound N + 2 bound N + 2 bound K] then
    rename variables m to n, n to m, k to k of fam OTMsg-3[bound N + 2 bound N + 2 bound K] then
    rename variables m to n, n to m, k to k of fam OTChc-0[bound N + 2 bound N + 2 bound K] then
    rename variables m to n, n to m, k to k of fam OTChc-1[bound N + 2 bound N + 2 bound K] then
    subst fam OTChc-0[bound N + 2 bound N + 2 bound K] 
       into fam OTChc-0OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTChc-1[bound N + 2 bound N + 2 bound K] 
       into fam OTChc-1OtAdv[bound N + 2 bound N + 2 bound K] then   
    subst fam OTChc-0[bound N + 2 bound N + 2 bound K] 
       into fam OTChcRcvd-0OtAdv[bound N + 2 bound N + 2 bound K] then
    subst fam OTChc-1[bound N + 2 bound N + 2 bound K] 
       into fam OTChcRcvd-1OtAdv[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam OTChc-0[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam OTChc-1[bound N + 2 bound N + 2 bound K] then
    rename variables n to m, m to n, k to k of fam SendBit[bound N + 2 bound N + 2 bound K] then
 sym from change fam RcvdBit[bound N + 2 bound N + 2 bound K]
          with 
  (when (m < n) -->        
  nf(               (b : bool <- read SendBit[m, n, k])
                  (xm : bool <- read Share[m, wire0(k)])
                  (xn : bool <- read Share[n, wire0(k)])
                  (ym : bool <- read Share[m, wire1(k)]) 
                   yn : bool <- read Share[n, wire1(k)], 
                  
                  return xor (
                    ( xor (( **((xm, yn))  , **((xn, ym))  )), 
                    b)
                  )

    ) 
   ) ;;
 (when (n <= m) -->
      nf(z : bool <- read RcvdBit[n, m, k], return z)
 ) 
  in currentProtocol(    
  on branch (m < n) of family RcvdBit[bound N + 2 bound N + 2 bound K] (     
 on reaction of fam RcvdBit[bound N + 2 bound N + 2 bound K] (
  if-ext on yn then if-ext on xn
 )
 )
 ) then
 sym from change fam RcvdBit[bound N + 2 bound N + 2 bound K]
          with 
  (when (m < n) -->        
  nf(               (b : bool <- read SendBit[m, n, k])
                  (xm : bool <- read Share[m, wire0(k)])
                  (xn : bool <- read Share[n, wire0(k)])
                  (ym : bool <- read Share[m, wire1(k)]) 
                   yn : bool <- read Share[n, wire1(k)], 
                  
                  return xor (
                    ( xor (( **((xm, yn))  , **((xn, ym))  )), 
                    b)
                  )

    ) 
   ) ;;
 (when (n <= m) -->
   nf(               (b : bool <- read SendBit[m, n, k])
                  (xm : bool <- read Share[m, wire0(k)])
                  (xn : bool <- read Share[n, wire0(k)])
                  (ym : bool <- read Share[m, wire1(k)]) 
                   yn : bool <- read Share[n, wire1(k)], 
                  
                  return xor (
                    ( xor (( **((xm, yn))  , **((xn, ym))  )), 
                    b)
                  )

    ) 
 ) 
  in currentProtocol(    
  on branch (n <= m) of family RcvdBit[bound N + 2 bound N + 2 bound K] (     
 diverge on fam RcvdBit[bound N + 2 bound N + 2 bound K] 
     with branch n <= m 
     of fam SendBit[bound N + 2 bound N + 2 bound K] 
     var z 
 )
 ) then 
 merge cases for fam RcvdBit[bound N + 2 bound N + 2 bound K] then
 rename variables m to n, n to m, k to k of fam SendBit[bound N + 2 bound N + 2 bound K]
   
    
)  then
combine fam Circuit[bound N + 2 bound K]  then
sym from pInt0 (
combine fam Adv[bound K] then
combine fam Shares[bound K] then 
combine fam 1OutOf4OT[bound K]
)

current-protocol
quit
