***( IPDL

  Copyright : (C) 2022, Kristina Sojakova
  License   : GNU General Public License v3.0 or later (GPL-3.0-or-later)
  Authors   : Mihai Codescu <mscodescu@gmail.com>
              Kristina Sojakova <sojakova.kristina@gmail.com>

)


fmod TYPES is
 protecting NAT .

 sort Type . 
 op unit : -> Type . 
 op bool : -> Type .
 op _*_ : Type Type -> Type .

 op |_| : Type -> Nat .
 
 vars A B : Type .

 eq | unit | = 0 . 
 eq | bool | = 1 .
 eq | A * B | = | A | + | B | .

 op prj1 : Type -> Type .
 op prj2 : Type -> Type .
 eq prj1(A * B) = A .
 eq prj2(A * B) = B .

endfm

fmod VAR-CONTEXT is
 protecting QID . 
 protecting TYPES .

 sort VarContextElem .

 op _:_ : Qid Type -> VarContextElem [ctor] .

 var q : Qid . 
 var t : Type .

 op qidOf_ : VarContextElem -> Qid . 
 eq qidOf (q : t) = q . 

 op typeOf_ : VarContextElem -> Type . 
 eq typeOf (q : t) = t .

 sort VarContext . 
 op emptyVarContext : -> VarContext [ctor] .
 subsort VarContextElem < VarContext . 
 op __ : VarContext VarContext -> VarContext [ctor assoc comm id: emptyVarContext] .

 vars Q1 Q2 : Qid .
 vars T T1 T2 : Type . 
 vars Gamma1 Gamma2 : VarContext .
 
 op _elem_ : Qid VarContext -> Bool .
 eq Q1 elem emptyVarContext = false . 
 ceq Q1 elem ((Q2 : T) Gamma1) = true if Q1 == Q2 .
 ceq Q1 elem ((Q2 : T) Gamma1) = Q1 elem Gamma1 if Q1 =/= Q2 .

 op varType : Qid VarContext -> Type .
 ceq varType(Q1, (Q2 : T) Gamma1) = T if Q1 == Q2 .
 ceq varType(Q1, (Q2 : T) Gamma1) = varType(Q1, Gamma1) if Q1 =/= Q2 .

 op validContext_ : VarContext -> Bool .
 eq validContext emptyVarContext = true .
 eq validContext ((Q1 : T1) Gamma1) = not (Q1 elem Gamma1) and validContext Gamma1 .  

endfm

fmod SIGNATURE is 
 protecting QID . 
 protecting TYPES .

 sort SigElem .

 op _:_~>_  : Qid Type Type -> SigElem [ctor] . *** function symbol
 op _:_~>>_ : Qid Type Type -> SigElem [ctor] . *** distribution

 vars Q1 Q2 : Qid .
 vars T T1 T2 : Type . 

 op dom_ : SigElem -> Type .
 op cod_ : SigElem -> Type .
  
 eq dom(Q1 : T1 ~> T2)  = T1 .
 eq dom(Q1 : T1 ~>> T2) = T1 .
  
 eq cod(Q1 : T1 ~> T2) = T2 . 
 eq cod(Q1 : T1 ~>> T2) = T2 .

 sort Signature . 
 op emptySig : -> Signature [ctor] .
 subsort SigElem < Signature . 
 op __ : Signature Signature -> Signature [ctor assoc comm id: emptySig] .

 vars Sig1 Sig2 : Signature .

 op _elem_ : Qid Signature -> Bool .
 eq Q1 elem emptySig = false .
 ceq Q1 elem ((Q2 : T1 ~> T2) Sig1) = true if Q1 == Q2 .
 ceq Q1 elem ((Q2 : T1 ~> T2) Sig1) = Q1 elem Sig1 if Q1 =/= Q2 .
 ceq Q1 elem ((Q2 : T1 ~>> T2) Sig1) = true if Q1 == Q2 .
 ceq Q1 elem ((Q2 : T1 ~>> T2) Sig1) = Q1 elem Sig1 if Q1 =/= Q2 .

 op find__ : Qid Signature -> SigElem . *** only find symbols that appear in signature!
 ceq find Q1 ((Q2 : T1 ~> T2) Sig1)  = Q1 : T1 ~> T2 if Q1 == Q2 .
 ceq find Q1 ((Q2 : T1 ~> T2) Sig1)  = find Q1 Sig1 if Q1 =/= Q2 .
 ceq find Q1 ((Q2 : T1 ~>> T2) Sig1) = Q1 : T1 ~>> T2 if Q1 == Q2 .
 ceq find Q1 ((Q2 : T1 ~>> T2) Sig1) = find Q1 Sig1 if Q1 =/= Q2 .

 op validSig_ : Signature -> Bool .
 eq validSig emptySig = true .
 eq validSig ((Q1 : T1 ~> T2) Sig1) = not (Q1 elem Sig1) and validSig Sig1 .
 eq validSig ((Q1 : T1 ~>> T2) Sig1) = not (Q1 elem Sig1) and validSig Sig1 .

endfm
 
fmod MESSAGE is
 protecting QID .

 sort Message . 
 
 subsort Qid < Message . *** variables

 ops True, False : -> Message [ctor] . 

 op () : -> Message [ctor] .

 op ap__ : Qid Message -> Message [ctor] . *** function application

 op pair : Message Message -> Message [ctor] . *** (_,_)

 op fst_ : Message -> Message [ctor] .
 op snd_ : Message -> Message [ctor] .
 
endfm

fmod MESSAGE-TYPING is 
 protecting MESSAGE .
 protecting SIGNATURE .
 protecting VAR-CONTEXT .

 op typeOf : Signature VarContext Message -> Type .

 var Sigma : Signature .
 var Gamma : VarContext .
 var x f : Qid .
 var M M1 M2 : Message .
 var T T1 T2 : Type .

 eq typeOf(Sigma, Gamma (x : T), x) = T .
 eq typeOf(Sigma, Gamma, ()) = unit .
 eq typeOf(Sigma, Gamma, True) = bool .
 eq typeOf(Sigma, Gamma, False) = bool .
 ceq typeOf(Sigma (f : T1 ~> T2), Gamma, ap f M) = T2 
     if typeOf(Sigma (f : T1 ~> T2), Gamma, M) == T1 .
 eq typeOf(Sigma, Gamma, pair(M1, M2)) = typeOf(Sigma, Gamma, M1) * typeOf(Sigma, Gamma, M2) .

 eq typeOf(Sigma, Gamma, fst M) = prj1(typeOf(Sigma, Gamma, M)) .
 eq typeOf(Sigma, Gamma, snd M) = prj2(typeOf(Sigma, Gamma, M)) .

endfm

fmod MESSAGE-EQUALITY is
 protecting MESSAGE-TYPING . 

 *** op _;_|-_=M=_:_ : Signature VarContext Message Message Type -> Bool .
 
 var Sigma : Signature .
 var Gamma : VarContext . 
 vars M M1 M2 M3 M4 : Message .
 vars T T1 T2 T3 T4 : Type . 
 var f c : Qid .
 
*** x xor y xor y =M= x


*** ceq Sigma ; Gamma |- M =M= () : unit = true
***     if
***     typeOf(Sigma, Gamma, M) == unit .

 eq fst pair(M1, M2) = M1 .
 eq snd pair(M1, M2) = M2 .
 eq pair(fst M, snd M) = M .

endfm

fmod DISTRIBUTION is
 protecting MESSAGE .
 protecting TYPES . 

 sort Distribution . 
 op flip : -> Distribution [ctor] .
 op _<_> : Qid Message -> Distribution [ctor] .
endfm 

fmod DISTRIBUTION-TYPING is
 protecting DISTRIBUTION .
 protecting MESSAGE-TYPING .

 op typeOf : Signature VarContext Distribution -> Type .

 vars T T1 T2 : Type .
 var M : Message .
 var Sigma : Signature .
 var Gamma : VarContext .
 var d : Qid .

 eq typeOf(Sigma, Gamma, flip) = bool .
 ceq typeOf(Sigma (d : T1 ~>> T2), Gamma, d < M >) = T2 
     if typeOf(Sigma, Gamma, M) == T1 .  

endfm
 
fmod DISTRIBUTION-EQUALITY is
 protecting MESSAGE-EQUALITY .
 protecting DISTRIBUTION .

 *** op _;_|-_=D=_:_ : Signature VarContext Distribution Distribution Type -> Bool .

 vars T1 T2 : Type .
 var M1 M2 : Message .
 var Sigma : Signature .
 var Gamma : VarContext .
 var d : Qid .

 *** ceq Sigma (d : T1 ~>> T2); Gamma |- d < M1 > =D= d < M2 > : T2 = true
 ***     if Sigma (d : T1 ~>> T2); Gamma |- M1 =M= M2 : T1 .

endfm

fmod NAT-TERM is
 protecting QID .
 pr MAP{Qid, Nat} .
 
 sort NatTerm .
 subsort Nat < NatTerm .
 subsort Qid < NatTerm .
 
 op _++_ : NatTerm NatTerm -> NatTerm .
 op _--_ : NatTerm NatTerm -> NatTerm .
 *** more if needed.
 sort BoolTerm .
 *** subsort Bool < BoolTerm .
 op apply__ : Qid NatTerm -> BoolTerm [ctor] . *** predicates over natterms
 op neg_ : BoolTerm -> BoolTerm [ctor] .
 
 var n1 n2 : Nat .
 var t t1 t2 : NatTerm .
 
 op evalBoolTerm : BoolTerm -> Bool . 
 
 op _=T=_ : NatTerm NatTerm -> BoolTerm [ctor] .
*** eq n1 =T= n2 = n1 == n2 .
 
 op _<T_ : NatTerm NatTerm -> BoolTerm [ctor] .
*** eq n1 <T n2 = n1 < n2 .
 
 op _<=T_ : NatTerm NatTerm -> BoolTerm [ctor] .
*** eq n1 <=T n2 = n1 <= n2 .
 
 var f : Map{Qid, Nat} .
 var q : Qid .
 
 op _-_ : Nat Nat -> Nat . *** unsafe difference on naturals
 eq n1 - 0 = n1 .
 eq s(n1) - s(n2) = n1 - n2 .
 
 op evalTerm__ : NatTerm Map{Qid, Nat} -> Nat .
 eq evalTerm n1 f = n1 .
 eq evalTerm q f = f[q] .
 eq evalTerm (t1 ++ t2) f = (evalTerm t1 f) + (evalTerm t2 f) . 
 eq evalTerm (t1 -- t2) f = (evalTerm t1 f) - (evalTerm t2 f) . 
  
endfm

view NatTerm from TRIV to NAT-TERM is
 sort Elt to NatTerm .
endv

view BoolTerm from TRIV to NAT-TERM is
 sort Elt to BoolTerm .
endv

fmod BOOLTERM-ENTAILS is
 protecting SET{BoolTerm} .
 
 op entails__ : Set{BoolTerm} BoolTerm -> Bool .
 
endfm

fmod CHANNEL-NAME is
 protecting QID .
 protecting LIST{NatTerm} .
 
 sort ChannelName .
 subsort Qid < ChannelName .
 op _[_] : Qid List{NatTerm} -> ChannelName [ctor] .
 
 var q q1 q2 : Qid .
 var nlist : List{NatTerm} .
 
 op matchesQid__ : ChannelName Qid -> Bool .
 eq matchesQid q1 q2 = q1 == q2 .
 eq matchesQid q1[nlist] q2 = q1 == q2 .
 
 op length : ChannelName -> Nat .
 eq length(q1) = 0 .
 eq length(q1[nlist]) = size(nlist) .
 
 op qidOfName : ChannelName -> Qid .
 eq qidOfName(q) = q .
 eq qidOfName(q[nlist]) = q .
 
endfm

view CName from TRIV to CHANNEL-NAME is
 sort Elt to ChannelName .
endv

fmod CNAME-SET is
 protecting SET{CName} .
 
 *** extended membership test, q[list] is an element if q is
 op _isElem_ : ChannelName Set{CName} -> Bool .
 
 var q : Qid .
 var lt : List{NatTerm} .
 var cn : ChannelName .
 var s : Set{CName} .
 
 eq q[lt] isElem s = (q in s) or (q[lt] in s) .
 eq q isElem s = q in s .
 
endfm

fmod CHANNEL is
 protecting QID .
 protecting TYPES .
 protecting CNAME-SET .
 
 sort TypedChannel .
 op __::_ : Qid Nat Type -> TypedChannel [ctor] .

 sort ChannelContext .
 op emptyChannelCtx : -> ChannelContext [ctor] .
 subsort TypedChannel < ChannelContext .
 op __ : ChannelContext ChannelContext -> ChannelContext 
         [ctor assoc comm id: emptyChannelCtx] .

 vars Q Q1 Q2 : Qid .
 var T T1 T2 : Type .
 vars Delta1 Delta2 : ChannelContext .
 var I : Set{CName} .
 var cn : ChannelName .
 var nlist : List{NatTerm} .
 var x y : Nat .

 op elem___ : ChannelName Type ChannelContext -> Bool .
 eq elem cn T emptyChannelCtx = false .
 ceq elem Q1 T1 ((Q2 x :: T2) Delta1) = true 
   if Q1 == Q2 and T1 == T2 and x == 0 .
 ceq elem Q1 T1 ((Q2 x :: T2) Delta1) = elem Q1 T1 Delta1 
   if Q1 =/= Q2 or T1 =/= T2 or x =/= 0 . 
 ceq elem (Q1[nlist]) T1 ((Q2 x :: T2) Delta1) = true
   if Q1 == Q2 and size(nlist) == x and T1 == T2 .
 ceq elem (Q1[nlist]) T1 ((Q2 x :: T2) Delta1) = false
   if Q1 =/= Q2 or size(nlist) =/= x or T1 =/= T2 .  
  
 op occurs__ : ChannelName ChannelContext -> Bool .
 eq occurs cn emptyChannelCtx = false .
 eq occurs Q1 ((Q1 x :: T) Delta1) = true .
 eq occurs Q1 ((Q2 x :: T) Delta1) = occurs Q1 Delta1 [owise] .
 ***ceq occurs Q1 ((Q2 x :: T) Delta1) = occurs Q1 Delta1 if Q1 =/= Q2 .
 eq occurs Q[nlist] ((Q x :: T) Delta1) = x == size(nlist) .
 eq occurs Q[nlist] ((Q2 x :: T) Delta1) = occurs Q[nlist] Delta1 [owise] . 
   
 op validChannelCtx_ : ChannelContext -> Bool .
 eq validChannelCtx emptyChannelCtx = true .
 ceq validChannelCtx ((Q1 0 :: T1) Delta1) = false if occurs Q1 Delta1 .
 ceq validChannelCtx ((Q1 0 :: T1) Delta1) = validChannelCtx Delta1 if not occurs Q1 Delta1 .
 ceq validChannelCtx ((Q1 x :: T1) Delta1) = false if occurs Q1[replicate x Q1] Delta1 .
 ceq validChannelCtx ((Q1 x :: T1) Delta1) = validChannelCtx Delta1 if not occurs Q1[replicate x Q1] Delta1 .
  
 op replicate__ : Nat Qid -> List{NatTerm} .
 eq replicate 0 Q = nil .
 eq replicate s(x) Q = Q (replicate x Q) .  
 
 op validChanSet__ : Set{CName} ChannelContext -> Bool .
 eq validChanSet empty Delta1 = true . 
 ceq validChanSet (cn, I) Delta1 = false if not occurs cn Delta1 .
 ceq validChanSet (cn, I) Delta1 = validChanSet I Delta1 if occurs cn Delta1 . 

   
endfm 

fmod QID-NAT-MAP is
 pr QID .
 pr MAP{Qid, Nat} .
endfm

fmod REACTION is
 protecting MESSAGE .
 protecting TYPES . 
 protecting DISTRIBUTION .
 protecting CHANNEL-NAME .
 protecting QID-NAT-MAP .

 sort Reaction .

 sort ReadReaction . 
 op read_ : ChannelName -> ReadReaction [ctor] .
 
 sort BindReaction . 
 
 sort BindReadReaction .
 subsort BindReadReaction < BindReaction .
 op _:_<-_ : Qid Type ReadReaction -> BindReadReaction [ctor] .
 
 sort UnrestrictedBindReaction . *** everything allowed
 subsort UnrestrictedBindReaction < BindReaction .
 op _:_<~_ : Qid Type Reaction -> UnrestrictedBindReaction [ctor] .
 
 sort BRList .
 subsort BindReadReaction < BRList .
 op emptyBRList : -> BRList [ctor] .
 op __ : BRList BRList -> BRList [ctor assoc comm id: emptyBRList] .
 
 sort BindList .
 subsort BindReaction < BindList .
 subsort BRList < BindList .
 op __ : BindList BindList -> BindList [ctor assoc comm id: emptyBRList] .
 
 sort BindFreeReaction .
 subsort ReadReaction < BindFreeReaction .
 op return_ : Message -> BindFreeReaction [ctor] .
 op samp_ : Distribution -> BindFreeReaction [ctor] .
 op if_then_else_ : Message BindFreeReaction BindFreeReaction -> BindFreeReaction [ctor] .
  
  
 sort CNameList . 
 op emptyCNameList : -> CNameList [ctor] .
 op _::_ : ChannelName CNameList -> CNameList [ctor] .
 
 *** helpers
 vars ql ql' : CNameList .
 var q q' x y : ChannelName .
 
 op reverse_ : CNameList -> CNameList .
 eq reverse ql = revAux emptyCNameList ql .
 
 op revAux__ : CNameList CNameList -> CNameList .
 eq revAux ql emptyCNameList = ql .
 eq revAux ql (q :: ql') = revAux (q :: ql) ql' .
 
 op _++_ : CNameList CNameList -> CNameList .
 eq emptyCNameList ++ ql = ql .
 eq (q :: ql') ++ ql = q :: (ql' ++ ql) .
 
 op replace___ : ChannelName ChannelName CNameList -> CNameList .
 eq replace q q' emptyCNameList = emptyCNameList .
 eq replace q q' (x :: ql) = if x == q then q' :: ql
                                       else x :: (replace q q' ql) fi . 
 
 op del__ : ChannelName CNameList -> CNameList .
 eq del q ql = delAux q ql emptyCNameList .
 
 op delAux___ : ChannelName CNameList CNameList -> CNameList .
 eq delAux q emptyCNameList ql' = reverse ql' .
 eq delAux q (q :: ql) ql' = (reverse ql') ++ ql .
 eq delAux q (q' :: ql) ql' = delAux q ql (q' :: ql') [owise] .
 
 op addBefore___ : ChannelName ChannelName CNameList -> CNameList .
 eq addBefore x y emptyCNameList = x :: emptyCNameList .
 eq addBefore x y (y :: ql) = x :: y :: ql .
 eq addBefore x y (q :: ql) = q :: (addBefore x y ql) [owise] .
 
 op addListBefore___ : CNameList ChannelName CNameList -> CNameList .
 eq addListBefore emptyCNameList y ql = ql .
 eq addListBefore (x :: ql) y ql' = addListBefore ql y (addBefore x y ql') .
 
 sort NFReaction .
 op nf : BRList BindFreeReaction CNameList -> NFReaction [ctor] .
 
 sort PreNFReaction .
 op preNF : BindList Reaction CNameList Qid -> PreNFReaction [ctor] .


 subsort ReadReaction < Reaction .
 *** subsort BindReaction < Reaction .
 subsort BindFreeReaction < Reaction .
 subsort NFReaction < Reaction .
 subsort PreNFReaction < Reaction .
 subsort UnrestrictedBindReaction < Reaction .
 op if_then_else_ : Message Reaction Reaction -> Reaction [ctor] . 
 op _:_<-_;_ : Qid Type Reaction Reaction -> Reaction [ctor] .
     
 vars M M1 M2 V : Message .
 var c : ChannelName .
 var w f d i : Qid .
 vars R R1 R2 : Reaction .
 var T : Type .
 var n : Nat .
 var QL : CNameList .
 var BL : BRList .
 var D : Distribution .
 
 op isSampFree : Reaction -> Bool .
 eq isSampFree(return M) = true .
 eq isSampFree(samp D) = false .
 eq isSampFree(read c) = true .
 eq isSampFree(if M then R1 else R2) = isSampFree(R1) and isSampFree(R2) .
 eq isSampFree(x : T <- R1 ; R2) = isSampFree(R1) and isSampFree(R2) .
 eq isSampFree(nf(BL, R, QL)) = isSampFree(R) .

 op _[_/_] : Reaction Qid Message -> Reaction . 
 eq (return M) [w / V] = return (M [w := V]) .
 eq (samp (d < M >)) [w / V] = samp (d < M [w := V] >) .
 eq (read c) [w / V] = read c . *** don't replace ?
 eq (if M then R1 else R2) [w / V] = if M [w := V] then (R1 [w / V]) else (R2 [w / V]) .
 eq (x : T <- R1 ; R2) [w / V] = x : T <- (R1 [w / V]) ; (R2 [w / V]) .
 eq (nf(BL, R, QL)) [w / V] = nf(BL, R [w / V], QL) .
 eq (preNF(BL, R, QL, x)) [w / V] = preNF(BL, R [w / V], QL, x) . *** subst in BL too?

 op _[_:=_] : Message Qid Message -> Message .

 eq w [w := V] = V . 
 eq ()[w := V] = () . ***TODO: this should be caught by next eq, since () =/= w is true.
 ceq x [w := V] = x if x =/= w .
 eq True [w := V] = True .
 eq False [w := V] = False .
 eq (ap f M) [w := V] = ap f (M [w := V]) .
 eq (pair(M1, M2)) [w := V] = pair(M1 [w := V] , M2 [w := V]) .
 eq (fst M) [w := V] = fst (M [w := V]) .
 eq (snd M) [w := V] = snd (M [w := V]) .
 
 var lq : List{NatTerm} .
 var val : Map{Qid,Nat} .
 
 vars nt1 nt2 : NatTerm .
 var m : Nat .
 
 op evalCName__ : ChannelName Map{Qid,Nat} -> ChannelName .
 eq evalCName (x [ lq ]) val = x [ evalList(lq, val) ] .
 eq evalCName x val = x .
 
 op evalList : List{NatTerm} Map{Qid,Nat} -> List{NatTerm} .
 eq evalList(nil, val) = nil .
 eq evalList(nt1 lq, val) = (eval(nt1, val)) (evalList(lq, val)) . 
 
 op _-_ : Nat Nat -> Nat . *** unsafe difference on Nat.
 eq n - 0 = n .
 eq s(n) - s(m) = n - m .
   
 op eval : NatTerm Map{Qid,Nat} -> Nat .
 eq eval(n, val) = n .
 eq eval(x, val) = if val[x] == undefined then x else val[x] fi . *** eval with default
 eq eval(nt1 ++ nt2, val) = eval(nt1, val) + eval(nt2, val) .
 eq eval(nt1 -- nt2, val) = eval(nt1, val) - eval(nt2, val) .
  
 
 op replaceVars : Reaction Map{Qid,Nat}  -> Reaction .
 eq replaceVars(return M, val) = return M .
 eq replaceVars(samp (d < M >), val) = samp (d < M >) .
 eq replaceVars(read c, val) = read (evalCName c val) . 
 eq replaceVars(if M then R1 else R2, val) = 
      if M then replaceVars(R1, val) else replaceVars(R2, val) .
 eq replaceVars(x : T <- R1 ; R2, val) = 
      x : T <- replaceVars(R1, val); replaceVars(R2, val) .
 eq replaceVars(nf(BL, R, ql), val) = nf(replaceVarsB(BL, val), replaceVars(R, val), ql) .
 
 var brr : BindReadReaction .
 
 op replaceVarsB : BindList Map{Qid, Nat} -> Reaction .
 eq replaceVarsB(x : T <- R, val) = x : T <- replaceVars(R, val) .
 eq replaceVarsB(x : T <~ R, val) = x : T <~ replaceVars(R, val) .
 eq replaceVarsB(brr BL, val) = replaceVarsB(brr, val) replaceVarsB(BL, val) .    
      
endfm

fmod REACTION-TYPING is
 protecting REACTION .
 protecting CHANNEL .
 protecting MESSAGE-TYPING .
 protecting DISTRIBUTION-TYPING .

 op typeOf : Signature ChannelContext VarContext Set{CName} Reaction -> Type .

 var Sigma : Signature .
 var Gamma : VarContext .
 var Delta : ChannelContext .
 vars R R1 R2 R3 : Reaction .
 vars T T1 T2 T3 : Type .
 var M M1 M2 : Message .
 var I : Set{CName} . 
 var d i x q : Qid .
 var c : ChannelName .
 var D : Distribution .
 var QL : CNameList .
 var BRL : BRList .
 var BL : BindList .
 var nlist : List{NatTerm} .
 var n : Nat .
 
 op validForCtx : BRList ChannelContext -> Bool .
 eq validForCtx(emptyBRList, Delta) = true .
 eq validForCtx((x : T <- read q) BRL, Delta (q 0 :: T)) = validForCtx(BRL, Delta) .
 ceq validForCtx((x : T <- read (q[nlist])) BRL, Delta (q n :: T)) =
     validForCtx(BRL, Delta) if n == size(nlist) .
                                      *** here c goes away, don't allow multiple reads!
 eq validForCtx(BRL, Delta) = false [owise] .
 
 op addDeclarations__ : BindList VarContext -> VarContext .
 eq addDeclarations emptyBRList Gamma = Gamma .
 eq addDeclarations ((x : T <- R) BL) Gamma = addDeclarations BL (Gamma (x : T)) .
 eq addDeclarations ((x : T <~ R) BL) Gamma = addDeclarations BL (Gamma (x : T)) .

 eq typeOf(Sigma, Delta, Gamma, I, return M) = typeOf(Sigma, Gamma, M) .
 eq typeOf(Sigma, Delta, Gamma, I, samp D) = typeOf(Sigma, Gamma, D) .
 ceq typeOf(Sigma, Delta (q 0 :: T), Gamma, I, read q) = T if q isElem I .
 ceq typeOf(Sigma, Delta (q n :: T), Gamma, I, read (q[nlist])) = T 
     if q isElem I and n == size(nlist) .
 ceq typeOf(Sigma, Delta, Gamma, I, if M then R1 else R2) = typeOf(Sigma, Delta, Gamma, I, R1)
     if typeOf(Sigma, Gamma, M) == bool
     /\ typeOf(Sigma, Delta, Gamma, I, R1) == typeOf(Sigma, Delta, Gamma, I, R2) .
 ceq typeOf(Sigma, Delta, Gamma, I, x : T1 <- R1 ; R2) = 
     typeOf(Sigma, Delta, Gamma (x : T1), I, R2)
     if typeOf(Sigma, Delta, Gamma, I, R1) == T1 .
 ceq typeOf(Sigma, Delta, Gamma, I, nf(BRL, R, QL)) = 
       typeOf(Sigma, Delta, addDeclarations BRL Gamma, I, R) 
     if validForCtx(BRL, Delta) .
 eq typeOf(Sigma, Delta, Gamma, I, preNF(BL, R, QL, x)) =
       typeOf(Sigma, Delta, addDeclarations BL Gamma, I, R) .    

endfm

mod REACTION-EQUALITY is
 protecting MESSAGE-TYPING .
 protecting MESSAGE-EQUALITY .
 protecting REACTION-TYPING .
 protecting DISTRIBUTION-EQUALITY .

 sort ReactionConfig . 
  
 op rConfig : Signature ChannelContext VarContext Reaction Set{CName} Type 
                     -> ReactionConfig [ctor] .

 var Sigma : Signature .
 var Gamma Gamma' : VarContext .
 var Delta : ChannelContext .
 vars R R1 R2 R3 R4 S S1 S2 S3 S4 : Reaction .
 vars T T1 T2 T3 : Type .
 var M M1 M2 : Message .
 var I I' : Set{CName} . 
 var x x1 x2 y b z c : ChannelName .
 var i o1 o2 : ChannelName .
 var D D' : Distribution .
 var QL QL' : CNameList .
 var BL : BindList .
 var BRL : BRList .
 var n : Nat .
 
 var q : Qid .
 
 sort CNameTuple .
 op mkTuple : ChannelName ChannelName CNameList -> CNameTuple [ctor] .
  
 op keepFirstAux____ : ChannelName ChannelName CNameList CNameList -> CNameTuple .
 eq keepFirstAux x y emptyCNameList QL' = mkTuple(x, y, emptyCNameList) .
 ceq keepFirstAux x y (z :: QL) QL' = mkTuple(x, y, (reverse QL') ++ (del y (z :: QL))) 
       if x == z .
 ceq keepFirstAux x y (z :: QL) QL' = mkTuple(y, x, (reverse QL') ++ (del x (z :: QL))) 
       if y == z .  
 eq keepFirstAux x y (z :: QL) QL' = keepFirstAux x y QL (z :: QL') [owise] .     
           
 op keepFirst : ChannelName ChannelName CNameList -> CNameTuple .
 eq keepFirst(x, y, QL) = keepFirstAux x y QL emptyCNameList .

 crl [sym] : rConfig(Sigma, Delta, Gamma, R2, I, T) 
             => 
             rConfig(Sigma, Delta, Gamma, R1, I, T)
     if rConfig(Sigma, Delta, Gamma, R1, I, T) 
        =>
        rConfig(Sigma, Delta, Gamma, R2, I, T) [nonexec] .
 
 *** refl and trans are properties of => anyways.

 *** crl [cong-ret] : rConfig(Sigma, Delta, Gamma, return M1, I, T)
 ***                  =>
 ***                 rConfig(Sigma, Delta, Gamma, return M2, I, T) 
 ***    if Sigma ; Gamma |- M1 =M= M2 : T [nonexec] .

 *** crl [cong-samp] : rConfig(Sigma, Delta, Gamma, samp D, I, T)
 ***                  => 
 ***                  rConfig(Sigma, Delta, Gamma, samp D', I, T)
 ***    if Sigma ; Gamma |- D =D= D' : T [nonexec] .

 crl [cong-branch] : 
     rConfig(Sigma, Delta, Gamma, if M1 then R1 else R2, I, T)
     => 
     rConfig(Sigma, Delta, Gamma, if M2 then R3 else R4, I, T)
     if
     rConfig(Sigma, Delta, Gamma, R1, I , T) => 
     rConfig(Sigma, Delta, Gamma, R3, I, T)
     /\
     rConfig(Sigma, Delta, Gamma, R2, I, T) => 
     rConfig(Sigma, Delta, Gamma, R4, I, T) 
     /\
     M1 == M2 [nonexec] .

 crl [cong-pre-nf] :
     rConfig(Sigma, Delta, Gamma, preNF(BL , R1 , QL, c), I, T)
     => 
     rConfig(Sigma, Delta, Gamma, preNF(BL , R2 , QL, c), I, T)
     if 
     rConfig(Sigma, Delta, addDeclarations BL Gamma, R1, I, T) 
     => 
     rConfig(Sigma, Delta, Gamma', R2, I, T) 
     /\
     Gamma' == addDeclarations BL Gamma [nonexec] .
     
 crl [read2Binds] : 
    rConfig(Sigma, Delta (q n :: T1), Gamma, preNF(BL (x : T1 <~ read i), R , QL, c), I, T) 
    =>
    rConfig(Sigma, Delta (q n :: T1), Gamma, preNF(BL (x : T1 <- read i), R , QL, c), I, T) 
    if q isElem I and matchesQid i q and length(i) == n .
     
 rl [pre2Nf] : preNF(BRL, R, QL, c) => nf(BRL, R, QL) .
 
 rl [nf2Pre] : nf(BL, R, QL) => preNF(BL, R, QL, c) [nonexec] .
      
 crl [merge-pre] :
     rConfig(Sigma, Delta, Gamma, preNF(BL (x : T1 <~ R1) , R2 , QL, c), I, T2)
     =>
     rConfig(Sigma, Delta, Gamma, preNF(BL , x : T1 <- R1 ; R2 , del x QL, c), I, T2) 
     if typeOf(Sigma, Delta, addDeclarations BL Gamma, I, R1) == T1
     /\ typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1)), I, R2) == T2
     .
      *** TODO: ok to del here?
      
 crl [bind2R-pre] :
     rConfig(Sigma, Delta, Gamma, preNF(BL (x : T1 <- R1) , R2 , QL, c), I, T2)
     =>
     rConfig(Sigma, Delta, Gamma, preNF(BL , x : T1 <- R1 ; R2 , del x QL, c), I, T2) 
     if typeOf(Sigma, Delta, addDeclarations BL Gamma, I, R1) == T1
     /\ typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1)), I, R2) == T2
     .
     
  crl [bind2R-pre-reverse] :
     rConfig(Sigma, Delta, Gamma, 
             preNF(BL , x : T1 <- R1 ; R2 , QL, c), 
             I, T2)
     =>
     rConfig(Sigma, Delta, Gamma, 
             preNF(BL (x : T1 <- R1) , R2 , x :: QL, c), *** TODO: add before c?
             I, T2) 
     if typeOf(Sigma, Delta, addDeclarations BL Gamma, I, R1) == T1
     /\ typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1)), I, R2) == T2
     .                    
      
 crl [cong-bind] :
     rConfig(Sigma, Delta, Gamma, x : T1 <- R1 ; R2, I , T2) 
     => 
     rConfig(Sigma, Delta, Gamma, x : T1 <- R3 ; R4, I, T2) 
     if
     rConfig(Sigma, Delta, Gamma, R1, I, T1)  
     => 
     rConfig(Sigma, Delta, Gamma, R3, I, T1) 
     /\
     rConfig(Sigma, Delta, Gamma (x : T1), R2, I, T2)
     => 
     rConfig(Sigma, Delta, Gamma (x : T1), R4, I, T2) .
     *** /\ ((R1 =/= R3) or (R2 =/= R4)) .

 crl [samp-pure] : 
     rConfig(Sigma, Delta, Gamma, x : T1 <- samp D ; R, I, T2)
     => 
     rConfig(Sigma, Delta, Gamma, R, I, T2)
     if typeOf(Sigma, Gamma, D) == T1 /\ typeOf(Sigma, Delta, Gamma, I, R) == T2 . 

 crl [read-det] : 
     rConfig(Sigma, Delta (q n :: T1), Gamma, 
                    x : T1 <- read i ; y : T1 <- read i ; R , I, T2) 
     => 
     rConfig(Sigma, Delta (q n :: T1), Gamma, 
                    x : T1 <- read i ; (R [y / x]), I, T2)
     if
     q isElem I 
     /\ matchesQid i q
     /\ length(i) == n
     /\
     typeOf(Sigma, Delta (i n :: T1), Gamma (x : T1) (y : T1), I, R) == T2 .
     
  crl [read-det-pre] : 
     rConfig(Sigma, Delta (q n :: T1), Gamma, 
               preNF( (x : T1 <- read i) (y : T1 <- read i) BL , R , QL, c), I, T2) 
     =>
     rConfig(Sigma, Delta (q n :: T1), Gamma, 
               preNF( (x : T1 <- read i) BL , R [y / x] , del y QL, c), I, T2) 
     if q isElem I /\ matchesQid i q /\ length(i) == n /\
     typeOf(Sigma, Delta (i n :: T1), 
            addDeclarations BL (Gamma (x : T1) (y : T1)), I, R) == T2        
     .
 ***  if keepFirst(y, x, QL) == mkTuple(f, l, QL') [nonexec] .     
               
  crl [bind-ret-2-pre] : 
     rConfig(Sigma, Delta, Gamma, 
               preNF( (x : T1 <~ R1) BL , return x , QL, c), I, T1) 
     =>
     rConfig(Sigma, Delta, Gamma, 
               nf( BL , R1 , del x QL), I, T1) 
     if typeOf(Sigma, Delta, addDeclarations BL Gamma, I, R1) == T1 .                    

  crl [if-left] : 
     rConfig(Sigma, Delta, Gamma, if True then R1 else R2, I, T) 
     =>  
     rConfig(Sigma, Delta, Gamma, R1, I, T)
     if
     typeOf(Sigma, Delta, Gamma, I, R1) == T
     /\
     typeOf(Sigma, Delta, Gamma, I, R2) == T .

 crl [if-right] : 
     rConfig(Sigma, Delta, Gamma, if False then R1 else R2, I, T) 
     =>  
     rConfig(Sigma, Delta, Gamma, R2, I, T)
     if
     typeOf(Sigma, Delta, Gamma, I, R1) == T 
     /\
     typeOf(Sigma, Delta, Gamma, I, R2) ==  T . 

***( this rule can't be applied by Maude so we replaced it with derived rules
  crl [if-ext] : 
     rConfig(Sigma, Delta, Gamma, R [b / M], I, T)
     => 
     rConfig(Sigma, Delta, Gamma, if M then (R [b / True]) else (R [b / False]), I, T)
     if
     typeOf(Sigma, Gamma, M) == bool
     /\
     typeOf(Sigma, Delta, Gamma (b : bool), I, R) == T . 
)

 crl [ret-bind] : 
     rConfig(Sigma, Delta, Gamma, x : T1 <- return M ; R , I , T2) 
     => 
     rConfig(Sigma, Delta, Gamma, R [x / M], I, T2) 
     if
     typeOf(Sigma, Gamma, M) == T1
     /\
     typeOf(Sigma, Delta, Gamma (x : T1), I, R) == T2 .
     
 crl [ret-bind-pre] :
     rConfig(Sigma, Delta, Gamma, preNF((x : T1 <~ return M) BL, R , QL, c), I, T2) 
     =>
     rConfig(Sigma, Delta, Gamma, preNF(BL, R [x / M] , del x QL, c), I, T2) 
     if
     typeOf(Sigma, Gamma, M) == T1 
     /\  typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1)), I, R) == T2 .   
     
     *** TODO: might need to make it nf here already! 
     
 crl [ret-bind-2] :
     rConfig(Sigma, Delta, Gamma, R, I, T2) 
     =>
     rConfig(Sigma, Delta, Gamma, x : T1 <- return M1 ; R2, I, T2)
     if  
     typeOf(Sigma, Gamma, M1) == T1  /\
     typeOf(Sigma, Delta, Gamma, I, R) == T2 /\
     typeOf(Sigma, Delta, Gamma (x : T1), I, R2) == T2 /\
     R == R2[x / M1] [nonexec] .

 crl [bind-ret] : 
     rConfig(Sigma, Delta, Gamma, x : T <- R ; return x, I , T) 
     => 
     rConfig(Sigma, Delta, Gamma, R, I, T)
     if 
     typeOf(Sigma, Delta, Gamma, I, R) == T . 

 crl [bind-ret-2] : 
     rConfig(Sigma, Delta, Gamma, R, I , T) 
     => 
     rConfig(Sigma, Delta, Gamma, x : T <- R ; return x, I, T)
     if 
     typeOf(Sigma, Delta, Gamma, I, R) == T [nonexec] .

 crl [bind-bind] : 
     rConfig(Sigma, Delta, Gamma, x2 : T2 <- (x1 : T1 <- R1 ; R2) ; R3, I, T3)
     => 
     rConfig(Sigma, Delta, Gamma, x1 : T1 <- R1 ; (x2 : T2 <- R2 ; R3), I, T3)
     if
     typeOf(Sigma, Delta, Gamma, I, R1) == T1
     /\
     typeOf(Sigma, Delta, Gamma (x1 : T1), I, R2) == T2
     /\ 
     typeOf(Sigma, Delta, Gamma (x2 : T2), I, R3) == T3 .
     
 crl [bind-bind-pre] :
     rConfig(Sigma, Delta, Gamma, 
              preNF((x2 : T2 <~ nf(BRL, R2, QL')) BL, R1, QL, c), I, T1)
     =>  
     rConfig(Sigma, Delta, Gamma, 
              preNF(BRL (x2 : T2 <~ R2) BL, 
                    R1, addListBefore QL' x2 QL, c), I, T1) 
     if  
     typeOf(Sigma, Delta, 
            addDeclarations BRL (addDeclarations BL Gamma), I, R2) == T2
     /\          
     typeOf(Sigma, Delta, 
            addDeclarations BL (Gamma (x2 : T2)), I, R1) == T1
     . 
                 

 crl [exchange] : 
     rConfig(Sigma, Delta, Gamma, x1 : T1 <- R1 ; x2 : T2 <- R2 ; R, I, T3)
     => 
     rConfig(Sigma, Delta, Gamma, x2 : T2 <- R2 ; x1 : T1 <- R1 ; R, I, T3)
     if
     typeOf(Sigma, Delta, Gamma, I, R1) == T1
     /\
     typeOf(Sigma, Delta, Gamma, I, R2) == T2
     /\
     typeOf(Sigma, Delta, Gamma (x1 : T1) (x2 : T2), I, R) == T3 .
     
 rl [exchange-no-cond] : 
     rConfig(Sigma, Delta, Gamma, x1 : T1 <- R1 ; x2 : T2 <- R2 ; R, I, T3)
     => 
     rConfig(Sigma, Delta, Gamma, x2 : T2 <- R2 ; x1 : T1 <- R1 ; R, I, T3)
     .    
     
     
 *** derived rules:
 
  rl [change-order] :
     rConfig(Sigma, Delta, Gamma, nf(BRL, R, QL), I, T)
     =>
     rConfig(Sigma, Delta, Gamma, nf(BRL, R, QL'), I, T) 
     [nonexec] . 
     *** TODO: check that QL' has same vars as QL?
     
    rl [change-order-pre] :
     rConfig(Sigma, Delta, Gamma, preNF(BRL, R, QL, c), I, T)
     =>
     rConfig(Sigma, Delta, Gamma, preNF(BRL, R, QL', c), I, T) 
     [nonexec] . 
     *** TODO: check that QL' has same vars as QL?   
 
  rl [same-reaction-if] : 
     rConfig(Sigma, Delta, Gamma, if M then R else R, I, T)
     => 
     rConfig(Sigma, Delta, Gamma, R, I, T) . *** could we prove this without if-ext? 
 
  crl [cong-branch-refl] : 
     rConfig(Sigma, Delta, Gamma, if M then R1 else R2, I, T)
     => 
     rConfig(Sigma, Delta, Gamma, if M then R3 else R4, I, T)
     if
     rConfig(Sigma, Delta, Gamma, R1, I , T) => 
     rConfig(Sigma, Delta, Gamma, R3, I, T)
     /\
     rConfig(Sigma, Delta, Gamma, R2, I, T) => 
     rConfig(Sigma, Delta, Gamma, R4, I, T) . 
     
 crl [read-inside-if] : 
    rConfig(Sigma, Delta (q n :: T1), Gamma, x : T1 <- read i ; if M then R1 else R2, I, T) 
    => 
    rConfig(Sigma, Delta (q n :: T1), Gamma, 
             if M then x : T1 <- read i ; R1 
                  else x : T1 <- read i ; R2, I, T) 
    if matchesQid i q /\ length(i) == n .

 crl [read-outside-if] : 
    rConfig(Sigma, Delta (q n :: T1), Gamma, if M then x : T1 <- read i ; R1 
                                                  else x : T1 <- read i ; R2
            , I, T) 
    => 
    rConfig(Sigma, Delta (q n :: T1), Gamma, 
             x : T1 <- read i ; if M then R1 else R2, I, T) 
    if matchesQid i q /\ length(i) == n 
    .
                  
     
 rl [if-over-bind-same-2] :
     rConfig(Sigma, Delta, Gamma, x : T1 <- if M1 
                                             then if M2 then R1 else R2
                                             else if M2 then R3 else R4 ;
                                  if M1 
                                     then if M2 then S1 else S2
                                     else if M2 then S3 else S4,
                                 I, T)
    => 
    rConfig(Sigma, Delta, Gamma, if M1 
                                    then if M2 then (x : T1 <- R1 ; S1) 
                                               else (x : T1 <- R2 ; S2)
                                    else if M2 then (x : T1 <- R3 ; S3) 
                                               else (x : T1 <- R4 ; S4),          
                                 I, T) .                             
 
 crl [if-over-bind-same] :
    rConfig(Sigma, Delta, Gamma, x : T1 <- if M then R1 else R2 ; 
                                 if M then R3 else R4, I, T)
    =>
    rConfig(Sigma, Delta, Gamma, if M then x : T1 <- R1 ; R3 else x : T1 <- R2 ; R4 , 
                                 I, T)                   
    if typeOf(Sigma, Delta, Gamma, I, R1) == T1  /\
       typeOf(Sigma, Delta, Gamma, I, R2) == T1  /\
       typeOf(Sigma, Delta, Gamma (x : T1), I, R3) == T /\
       typeOf(Sigma, Delta, Gamma (x : T1), I, R4) == T /\
       typeOf(Sigma, Gamma, M) == bool .
 
 crl [if-over-bind] : 
    rConfig(Sigma, Delta, Gamma, x : T1 <- if M then R1 else R2 ; R , I, T) 
    =>
    rConfig(Sigma, Delta, Gamma, if M then x : T1 <- R1 ; R else x : T1 <- R2 ; R , 
            I, T) 
    if typeOf(Sigma, Delta, Gamma, I, R1) == T1  /\
       typeOf(Sigma, Delta, Gamma, I, R2) == T1  /\
       typeOf(Sigma, Delta, Gamma (x : T1), I, R) == T /\
       typeOf(Sigma, Gamma, M) == bool .
       
 crl [if-over-read] : 
     rConfig(Sigma, Delta, Gamma, if M then x : T1 <- R1 ; R else x : T1 <- R1 ; S, I, T)
     =>        
     rConfig(Sigma, Delta, Gamma, x : T1 <- R1 ; if M then R else S, I, T)
     if
     typeOf(Sigma, Delta, Gamma, I, R1) == T1 /\
     typeOf(Sigma, Delta, Gamma (x : T1), I, R) == T /\
     typeOf(Sigma, Delta, Gamma (x : T1), I, S) == T /\
     typeOf(Sigma, Gamma, M) == bool .
       
 var vx vy : Qid .     
       
 crl [alpha] :
     rConfig(Sigma, Delta, Gamma, vx : T1 <- R1 ; R2 , I, T2 )
     =>
     rConfig(Sigma, Delta, Gamma, vy : T1 <- R1 ; (R2 [vx / vy]), I, T2)
     if typeOf(Sigma, Delta, Gamma, I, R1) == T1 /\
        typeOf(Sigma, Delta, Gamma (vx : T1), I, R2) == T2 [nonexec] .
        
 crl [samp-free] : 
     rConfig(Sigma, Delta, emptyVarContext,
             x1 : T1 <- R1 ; x2 : T1 <- R1 ; return pair(x1, x2),
             I, T1 * T2)
     => 
     rConfig(Sigma, Delta, emptyVarContext,
             x1 : T1 <- R1 ;  return pair(x1, x1),
             I, T1 * T2)
     if isSampFree(R1) .  
     
  var Dist : Distribution .   
     
  *** TODO: is this true?
 rl [samp-over-if] :
    rConfig(Sigma, Delta, Gamma, 
            preNF((x : T1 <~ samp Dist) BL, if M then R1 else R2, QL, c), I, T) 
    => 
    rConfig(Sigma, Delta, Gamma, 
            preNF(BL, if M then (x : T1 <- samp Dist ; R1) 
                           else (x : T1 <- samp Dist ; R2), 
                           del x QL, c), 
            I, T) 
    .
endm

fmod NAT-PAIRS is
 protecting NAT .

 sort NatPairs .
 op (_;;_) : Nat Nat -> NatPairs [ctor] .

endfm

view NatPairs from TRIV to NAT-PAIRS is
 sort Elt to NatPairs .
endv

fmod BOUNDS is
 protecting LIST{NatPairs} .

 sort Bounds .
 op bound_ : Nat -> Bounds [ctor] .
 op uniformBound_ : Nat -> Bounds [ctor] . 
 op dependentBound_ : List{NatPairs} -> Bounds [ctor] . 
 
endfm

view Bounds from TRIV to BOUNDS is
 sort Elt to Bounds .
endv

fmod TYPEDQID is
 protecting QID .
 protecting TYPES .
 protecting CHANNEL-NAME .
 protecting LIST{Bounds} .
 
 sort TypedCName .
 op <_:_> : ChannelName Type -> TypedCName .
 op {___:_} : Qid List{NatTerm} List{Bounds} Type -> TypedCName .

 sort TypedCNameList .
 subsort TypedCName < TypedCNameList .
 op emptyTypedCNameList : -> TypedCNameList [ctor] .
 op __ : TypedCNameList TypedCNameList -> TypedCNameList [comm assoc ctor id: emptyTypedCNameList] .

endfm 

fmod PROTOCOL is
 protecting REACTION .
 protecting QID .
 protecting TYPEDQID .
 protecting LIST{Bounds} .
 
 sort Protocol .

 op emptyProtocol : -> Protocol [ctor] .
 op _::=_ : ChannelName Reaction -> Protocol [ctor] .
 op _||_ : Protocol Protocol -> Protocol [ctor assoc comm] .
 op new_:_in_ : ChannelName Type Protocol -> Protocol [ctor] .
 op newfamily___:_in_ : Qid List{NatTerm} List{Bounds} Type Protocol -> Protocol [ctor] . 
 op newNF : TypedCNameList Protocol CNameList -> Protocol [ctor] .
 op family___::=_ : Qid List{NatTerm} List{Bounds} Cases -> Protocol [ctor] .
 
 sort When .
 sort WhenCond .
 *** sort Cond . 
 *** subsort Bool < Cond .
 *** op condM_ : NatTerm -> Cond [ctor] .
 op when_ : BoolTerm -> WhenCond [ctor] .
 op otherwise : -> WhenCond [ctor] .
 op _-->_ : WhenCond Cases -> When [ctor] .
 
 sort WhenList .
 subsort When < WhenList .
 op emptyWhen : -> WhenList [ctor] .
 op _;;_ : WhenList WhenList -> WhenList [ctor assoc id: emptyWhen] .
 
 sort Cases .
 subsort Reaction < Cases . *** for C[i] ::= R(i)
 subsort Protocol < Cases . *** for Party[i] ::= some parallel composition, no cases
 subsort WhenList < Cases .

 var q q2 i q' : Qid .
 var n x y n1 n2 m : Nat .
 var R R' : Reaction .
 var T : Type .
 var ql : CNameList .
 var P P' P1 P2 : Protocol .
 var cn C D : ChannelName .
 var ltq : TypedCNameList .
 var cases : Cases .
 var whenList : WhenList .
 var whenCond : WhenCond .
 var nlist : List{NatTerm} .
 
 var blist : List{Bounds} .
 var evalMap : Map{Qid, Nat} .
 
 op newNF2New : Protocol -> Protocol .
 eq newNF2New(newNF(emptyTypedCNameList, P, ql)) = P .
 eq newNF2New(newNF({ cn nlist blist : T } ltq, P, cn :: ql)) = 
                  newfamily cn nlist blist : T in (newNF2New(newNF(ltq, P, ql))) .
 eq newNF2New(newNF(< cn : T > ltq, P, cn :: ql)) = 
                  new cn : T in (newNF2New(newNF(ltq, P, ql))) .
 eq newNF2New(P) = P [owise] .

 op new2NF : Protocol -> Protocol .
 eq new2NF(P) = dropEmpty(new2NFAux P newNF(emptyTypedCNameList, emptyProtocol, emptyCNameList)) .

 op dropEmpty : Protocol -> Protocol .
 eq dropEmpty(newNF(emptyTypedCNameList, P, ql)) = P .
 eq dropEmpty(P) = P [owise] .

 op new2NFAux__ : Protocol Protocol -> Protocol .
 eq new2NFAux (new cn : T in P) newNF(ltq, P', ql) = 
      new2NFAux P newNF( < cn : T > ltq, P', ql ++ (cn :: emptyCNameList)) .
 eq new2NFAux (newfamily cn nlist blist : T in P) newNF(ltq, P', ql) = 
      new2NFAux P newNF( {cn nlist blist : T } ltq, P', ql ++ (cn :: emptyCNameList)) . 
 eq new2NFAux (P1 || P2)  newNF(ltq, P', ql) = newNF(ltq, new2NF(P1) || new2NF(P2) ,ql) .
 eq new2NFAux (family C nlist blist ::= P) newNF(ltq, P', ql) = 
     newNF(ltq, family C nlist blist ::= new2NF(P) , ql) .
 eq new2NFAux (family C nlist blist ::= (whenCond --> P) ) newNF(ltq, P', ql) = 
      newNF(ltq, family C nlist blist ::= (whenCond --> new2NF(P) ) , ql) . 
 eq new2NFAux (family C nlist blist ::= (whenCond --> P) ;; whenList ) newNF(ltq, P', ql) = 
      newNF(ltq, family C nlist blist ::= (whenCond --> new2NF(P)) ;; whenList   , ql) .      
        *** TODO: this is wrong! do the same on whenList!
 eq new2NFAux P newNF(ltq, P', ql) = newNF(ltq, P, ql) [owise] .
  
 var plist : List{NatPairs} .  
  
 op nf2p : Protocol -> Protocol . *** desugar new family
 eq nf2p(newfamily C q (bound n) : T in P) = genNew1 C n T P 0 .
 eq nf2p(newfamily C (q q') ((bound n1)(uniformBound n2)) : T in P) = genNew2 C n1 n2 T P 0 0 .
 eq nf2p(newfamily C (q q') ((bound n1)(dependentBound plist)) : T in P) = 
    gen2Dep C n1 plist T P 0 0 . 

 op genNew1_____ : Qid Nat Type Protocol Nat -> Protocol .
 ceq genNew1 C n T P x = P if x == n + 1 .                     *** TODO: desugar family as well?
 eq genNew1 C n T P x = new C [ x ] : T in (genNew1 C n T P s(x)) .
 
 op genNew2_______ : Qid Nat Nat Type Protocol Nat Nat -> Protocol .
 ceq genNew2 C n1 n2 T P x y = P if x == n1 + 1 .
 eq genNew2 C n1 n2 T P x y = new C [ x y ] : T in 
    (if y == n2 then genNew2 C n1 n2  T P (x + 1) 0 
               else genNew2 C n1 n2 T P x (y + 1)
     fi) .
     
 op gen2Dep_______ : Qid Nat List{NatPairs} Type Protocol Nat Nat -> Protocol .
 eq gen2Dep C n nil T P x y = P .
 eq gen2Dep C n ((n1 ;; n2) plist) T P x y =
 if x == n + 1 then P *** this allows us to stop if we have too many bounds
 else 
  if y == n2 + 1 then gen2Dep C n plist T P (x + 1) 0
  else 
   new C [ x  y] : T in gen2Dep C n ((n1 ;; n2) plist) T P x (y + 1)
  fi 
 fi .

  
 op f2p : Protocol -> Protocol .
 eq f2p(family C q (bound n) ::= cases) = f2p1 (C [q]) empty C q n cases 0 .
 eq f2p(family C (q q') blist ::= cases) = f2p2 C q q' blist cases .
 eq f2p(P) = P [owise] .
 
 *** desugaring for two indices
 
 op f2p2_____ : Qid Qid Qid List{Bounds} Cases -> Protocol .
 eq f2p2 C q q' blist cases = emptyProtocol .
 
 *** desugaring for one index
 
 op f2p1_______ : ChannelName Map{Qid, Nat} Qid Qid Nat Cases Nat -> Protocol .
 eq f2p1 cn evalMap C q n R x =
  if x == n 
  then ((evalCName cn (q |-> x, evalMap)) ::= replaceVars(R, (q |-> x, evalMap)))
  else ((evalCName cn (q |-> x, evalMap))::= replaceVars(R, (q |-> x, evalMap))) 
       || (f2p1 cn evalMap C q n R (x + 1)) 
  fi .
 eq f2p1 cn evalMap C q n (D [q] ::= R) x = parComp cn evalMap n (D [q] ::= R) 0 .
 eq f2p1 cn evalMap C q n (family D q' (uniformBound m) ::= cases) x = 
   if x == n then
    f2p1 (D [q q']) (q |-> x, evalMap) D q' m cases 0 
   else
    (f2p1 (D [q q']) (q |-> x, evalMap) D q' m cases 0) || 
    (f2p1 (D [q q']) evalMap C q n (family D q' (uniformBound m) ::= cases) (x + 1))
   fi   .
 eq f2p1 cn evalMap C q n ((D [q] ::= R) || P) x = 
     (parComp cn evalMap n (D [q] ::= R) 0) || f2p1 cn evalMap C q n P x .
 eq f2p1 cn evalMap C q n whenList x = 
  if x == n then (selectCase cn C (q |-> x, evalMap) n whenList x) 
  else (selectCase cn C (q |-> x, evalMap) n whenList x) || f2p1 cn evalMap C q n whenList (x + 1)
  fi .
  
  
 op parComp_____ : ChannelName Map{Qid, Nat} Nat Protocol Nat -> Protocol .
 eq parComp cn evalMap n (D[q] ::= R) x = 
  if x == n
  then ((evalCName cn (q |-> x, evalMap)) ::= replaceVars(R, (q |-> x, evalMap))
       )
  else ((evalCName cn (q |-> x, evalMap)) ::= replaceVars(R, (q |-> x, evalMap))) 
       || parComp cn evalMap n (D[q] ::= R) (x + 1)
  fi . 
 
 var nt nt1 nt2 : NatTerm .
 var p : Qid .
 
 op selectCaseFamily______ : Qid Qid Nat Map{Qid,Nat} WhenList Nat -> Protocol .
 eq selectCaseFamily C q n evalMap whenList x =  
     family C q (bound n) ::= selectReaction evalMap whenList x .

 op selectReaction___ : Map{Qid,Nat} WhenList Nat -> Reaction .
 eq selectReaction evalMap ( (when (nt1 =T= nt2) --> R ) ;; whenList) x =
  if (evalTerm nt1 evalMap) == (evalTerm nt2 evalMap)
  then replaceVars(R, evalMap) 
  else selectReaction evalMap whenList x
  fi .
  eq selectReaction evalMap ( (when (nt1 <T nt2) --> R ) ;; whenList) x =
  if (evalTerm nt1 evalMap) < (evalTerm nt2 evalMap) 
  then replaceVars(R, evalMap) 
  else selectReaction evalMap whenList x
  fi . 
  eq selectReaction evalMap ( (when (nt1 <=T nt2) --> R ) ;; whenList) x =
  if (evalTerm nt1 evalMap) <= (evalTerm nt2 evalMap) 
  then replaceVars(R, evalMap) 
  else selectReaction evalMap whenList x
  fi . 
  eq selectReaction evalMap ( (otherwise --> R ) ;; whenList) x =
  replaceVars(R, evalMap) .
  eq selectReaction evalMap ( (when (apply p nt1) --> R ) ;; whenList) x =
  if (evalBoolTerm(apply p (evalTerm nt1 evalMap)) == true)
  then replaceVars(R, evalMap) 
  else selectReaction evalMap whenList x
  fi .

 
 *** TODO: call selectCase with a evalMap q |-> x, so that we can reuse code for family in family!
 op selectCase______ : ChannelName Qid Map{Qid,Nat} Nat WhenList Nat -> Protocol .
 eq selectCase cn C evalMap n ( (when (nt1 =T= nt2) --> R ) ;; whenList) x = 
  if evalTerm nt1 evalMap == evalTerm nt2 evalMap 
  then (evalCName cn evalMap) ::= replaceVars(R, evalMap) 
  else selectCase cn C evalMap n whenList x 
  fi .
 eq selectCase cn C evalMap n ( (when (nt1 <T nt2) --> R ) ;; whenList) x = 
  if (evalTerm nt1 evalMap) < (evalTerm nt2 evalMap)
  then (evalCName cn evalMap) ::= replaceVars(R, evalMap) 
  else selectCase cn C evalMap n whenList x 
  fi .
  eq selectCase cn C evalMap n ( (when (nt1 <=T nt2) --> R ) ;; whenList) x = 
  if (evalTerm nt1 evalMap) <= (evalTerm nt2 evalMap)
  then (evalCName cn evalMap) ::= replaceVars(R, evalMap) 
  else selectCase cn C evalMap n whenList x 
  fi .  
 eq selectCase cn C evalMap n ( (otherwise --> R ) ;; whenList) x = 
    (evalCName cn evalMap) ::= replaceVars(R, evalMap) .
 eq selectCase cn C evalMap n ( (when (apply p nt1) --> R ) ;; whenList) x = 
  if (evalBoolTerm(apply p (evalTerm nt1 evalMap)) == true) then 
   (evalCName cn evalMap) ::= replaceVars(R, evalMap)
   else
   selectCase cn C evalMap n whenList x 
   fi .
 *** for protocols
 eq selectCase cn C evalMap n ( (when (nt1 =T= nt2) --> (D [q] ::= R) ) ;; whenList) x = 
  if evalTerm nt1 evalMap == evalTerm nt2 evalMap 
  then D [x] ::= replaceVars(R, evalMap) 
  else selectCase cn C evalMap n whenList x 
  fi . 
  eq selectCase cn C evalMap n ( (when (nt1 <T nt2) --> (D [q] ::= R) ) ;; whenList) x = 
  if (evalTerm nt1 evalMap) < (evalTerm nt2 evalMap)
  then D [x] ::= replaceVars(R, evalMap) 
  else selectCase cn C evalMap n whenList x 
  fi .
  eq selectCase cn C evalMap n ( (when (nt1 <=T nt2) --> (D [q] ::= R) ) ;; whenList) x = 
  if (evalTerm nt1 evalMap) <= (evalTerm nt2 evalMap)
  then D [x] ::= replaceVars(R, evalMap) 
  else selectCase cn C evalMap n whenList x 
  fi .  
 eq selectCase cn C evalMap n ( (otherwise --> (D [q] ::= R) ) ;; whenList) x = 
     D [x] ::= replaceVars(R, evalMap) .
 eq selectCase cn C evalMap n ( (when (apply p nt1) --> (D [q] ::= R) ) ;; whenList) x = 
  if evalBoolTerm(apply p (evalTerm nt1 evalMap)) == true then 
   D [x] ::= replaceVars(R, evalMap)
   else
   selectCase cn C evalMap n whenList x 
   fi .   

***( OLD STUFF, reuse 
  
 op f2p : Protocol -> Protocol .
 ceq f2p(family C lq n := cOf) = f2p1 C lq n cOf 0   if size(lq) == 1 .
 ceq f2p(family C lq n := cOf) = f2p2 C lq n cOf 0 0 if size(lq) == 2 .
 ceq f2p(family C lq n := cOf) = emptyProtocol if size(lq) > 2 .
 eq f2p(P) = P [owise] .
 
 op f2p2______ : Qid List{NatTerm} Nat CaseOf Nat Nat -> Protocol .
 ceq f2p2 C lq n cOf x y = emptyProtocol if x == n + 1 .
 eq f2p2 C lq n cOf x y = (valCase2 C lq (x y) cOf) || 
   (if y < n then f2p2 C lq n cOf x (y + 1)
             else f2p2 C lq n cOf (x + 1) 0
    fi) [owise] .
    
 op valCase2____ : Qid List{NatTerm} List{NatTerm} CaseOf -> Protocol . 
 *** eq valCase2 C (q q') (x y) cOf = C [ x y ] ::= return True .
 eq valCase2 C (q q') (x y) (case q2 is emptyCaseList) = emptyProtocol . *** shouldn't happen
 eq valCase2 C (q q') (x y)
    (case q2 is ((honest --> R) ;; cl)) = emptyProtocol .
 eq valCase2 C (q q') (x y)
    (case q2 is ((corrupt --> R) ;; cl)) = emptyProtocol . 
 eq valCase2 C (q q') (x y) 
    (case q2 is ((otherwise --> R) ;; cl)) = 
      C [ x y ] ::= replaceVars(R, (q |-> x , q' |-> y))  .  
 ceq valCase2 C (q q') (x y) (case q2 is ((index =i= n2 --> R) ;; cl)) = 
     C [ x y] ::= replaceVars(R, (q |-> x , q' |-> y)) 
     if (if q2 == q then x else y fi) == n2 .  
 ceq valCase2 C (q q') (x y) (case q2 is ((index =i= n2 --> R) ;; cl)) = 
     valCase2 C (q q') (x y) (case q2 is cl)
     if (if q2 == q then x else y fi) =/= n2 .  
 ceq valCase2 C (q q') (x y) (case q2 is ((index < n2 --> R) ;; cl)) = 
     C [ x y] ::= replaceVars(R, (q |-> x , q' |-> y)) 
     if (if q2 == q then x else y fi) < n2 .  
 ceq valCase2 C (q q') (x y) (case q2 is ((index < n2 --> R) ;; cl)) = 
     valCase2 C (q q') (x y) (case q2 is cl)
     if (if q2 == q then x else y fi) >= n2 .  
 ceq valCase2 C (q q') (x y) (case q2 is ((index <= n2 --> R) ;; cl)) = 
     C [ x y] ::= replaceVars(R,(q |-> x , q' |-> y)) 
     if (if q2 == q then x else y fi) <= n2 .  
 ceq valCase2 C (q q') (x y) (case q2 is ((index <= n2 --> R) ;; cl)) = 
     valCase2 C (q q') (x y) (case q2 is cl)
     if (if q2 == q then x else y fi) > n2 .                        
 
 op f2p1_____ : Qid List{NatTerm} Nat CaseOf Nat -> Protocol .
 ceq f2p1 C q n cOf x = emptyProtocol if x == n + 1 .
 eq f2p1 C q n cOf x = (valCase1 C q x cOf) || (f2p1 C q n cOf s(x)) [owise] .
 
 op valCase1____ : Qid Qid Nat CaseOf -> Protocol .
 eq valCase1 C q x R = C [ x ] ::= R .
 eq valCase1 C q x (case q is emptyCaseList) = emptyProtocol . *** shouldn't happen
 ceq valCase1 C q x (case q is ((honest --> R) ;; cl)) = 
     C [ x ] ::= replaceVars(R, q |-> x) 
      if checkHonest(x) .
 ceq valCase1 C q x (case q is ((honest --> R) ;; cl)) = valCase1 C q x (case q is cl)  
      if not checkHonest(x) .    
 ceq valCase1 C q x (case q is ((corrupt --> R) ;; cl)) = 
     C [ x ] ::= replaceVars(R, q |-> x) 
      if not checkHonest(x) .
 ceq valCase1 C q x (case q is ((corrupt --> R) ;; cl)) = valCase1 C q x (case q is cl)  
      if checkHonest(x) . 
 eq valCase1 C q x (case q is ((otherwise --> R) ;; cl)) = 
      C [ x ] ::= replaceVars(R, q |-> x)  .
 ceq valCase1 C q x (case q is ((index =i= n2 --> R) ;; cl)) = 
     C [ x ] ::= replaceVars(R, q |-> x) 
     if x == n2 . 
 ceq valCase1 C q x (case q is ((index =i= n2 --> R) ;; cl)) = valCase1 C q x (case q is cl)
      if x =/= n2 .
 ceq valCase1 C q x (case q is ((index < n2 --> R) ;; cl)) = 
     C [ x ] ::= replaceVars(R, q |-> x)
      if x < n2 .     
 ceq valCase1 C q x (case q is ((index < n2 --> R) ;; cl)) = valCase1 C q x (case q is cl)
      if x >= n2 . 
 ceq valCase1 C q x (case q is ((index <= n2 --> R) ;; cl)) = 
      C [ x ] ::= replaceVars(R, q |-> x)
      if x <= n2 .     
 ceq valCase1 C q x (case q is ((index <= n2 --> R) ;; cl)) = valCase1 C q x (case q is cl)
      if x > n2 . 
)
      
 vars C1 C2 : ChannelName .
 vars R1 R2 : Reaction .     
      
 op keepTwo___ : Protocol ChannelName ChannelName -> Protocol .
 eq keepTwo ((C1 ::= R1) || (C2 ::= R2) || P) C1 C2 =  (C1 ::= R1) || (C2 ::= R2) .  
 eq keepTwo (new C : T in P) C1 C2 = keepTwo P C1 C2 .
 
 op removeTwo___ : Protocol ChannelName ChannelName -> Protocol .
 eq removeTwo ((C1 ::= R1) || (C2 ::= R2) || P) C1 C2 =  P . 
 eq removeTwo (new C : T in P) C1 C2 = removeTwo P C1 C2 .
 
 op keepOne__ : Protocol ChannelName -> Protocol .
 eq keepOne ((C1 ::= R1) || P) C1 =  (C1 ::= R1) .  
 eq keepOne (new C : T in P) C1 = keepOne P C1 .
 eq keepOne ((family C1 nlist blist ::= cases) || P) C1 = family C1 nlist blist ::= cases .
 eq keepOne (newfamily C2 nlist blist : T in P) C1 = keepOne P C1 .
 
 op removeOne__ : Protocol ChannelName -> Protocol .
 eq removeOne ((C1 ::= R1) || P) C1 =  P . 
 eq removeOne (new C : T in P) C1 = removeOne P C1  .
 eq removeOne ((family C1 nlist blist ::= cases) || P) C1 = P .
 eq removeOne (newfamily C2 nlist blist : T in P) C1 = removeOne P C1 .
                         
endfm

fmod PROTOCOL-INDEP is
 protecting PROTOCOL .
 protecting CHANNEL .
 
 var cn : ChannelName .
 var P P1 P2 : Protocol .
 var T : Type .
 vars R : Reaction . 
 var ltq : TypedCNameList .
 var ql : CNameList .
  var nlist : List{NatTerm} .
 var blist : List{Bounds} .
 var whenList : WhenList .
 var whenCond : WhenCond .
 var q i j : Qid . 
 
 op projZero_ : Protocol -> Protocol .
 eq projZero emptyProtocol = emptyProtocol .
 eq projZero (P1 || P2) = projZero P1 || projZero P2 .
 eq projZero (new cn : T in P) = new cn : T in (projZero P) .
 eq projZero (newfamily q j blist : T in P) = new q [0] : T in projZero P  .
 eq projZero (family q j blist ::= R) = q[0] ::= (replaceVars(R, j |-> 0)) .
 eq projZero (family q j blist ::= P) = family q j blist ::= (projZero P) .
 eq projZero (q ::= R) = q ::= R .
 eq projZero (q[j] ::= R) = q[0] ::= (replaceVars (R, j |-> 0)) . 
 
 
 op isIndepComp__ : Qid Protocol -> Bool .
 eq isIndepComp i emptyProtocol = true .
 eq isIndepComp i (P1 || P2) = (isIndepComp i P1) and (isIndepComp i P2) .
 eq isIndepComp i (new cn : T in P) = isIndepComp i P .
 eq isIndepComp i (newfamily q nlist blist : T in P) = isIndepComp i P .
 eq isIndepComp i (family q j blist ::= R) = isIndepR j R .
 eq isIndepComp i (family q j blist ::= P) = isIndepComp j P .
 eq isIndepComp i (family q j blist ::= (whenCond --> R)) = isIndepR j R .
 eq isIndepComp i (family q j blist ::= (whenCond --> P)) = isIndepComp j P .
 eq isIndepComp i 
     (family q j blist ::= (whenCond --> R) ;; whenList) = 
   (isIndepR j R) and (isIndepComp i (family q j blist ::= whenList)).
 eq isIndepComp i 
     (family q j blist ::= (whenCond --> P) ;; whenList) = 
   (isIndepComp j P) and (isIndepComp i (family q j blist ::= whenList)).
 eq isIndepComp i newNF(ltq, P, ql) = isIndepComp i P .
 eq isIndepComp i (q ::= R) = isIndepR i R .
 eq isIndepComp i (q[nlist] ::= R) = isIndepR i R . *** TODO: add cond on nlist?
 
 var M : Message .
 var D : Distribution .
 var R1 R2 : Reaction .
 var x : Qid .
 var BL : BindList .
 var QL : CNameList .
   
 op isIndepR__ : Qid Reaction -> Bool .
 eq isIndepR i (return M) = true .
 eq isIndepR i (samp D) = true .
 eq isIndepR i (samp flip) = true .
 eq isIndepR i (if M then R1 else R2) = isIndepR i R1 and isIndepR i R2 .  
 eq isIndepR i (x : T <- R1 ; R2) = isIndepR i R1 and isIndepR i R2 .
 eq isIndepR i (nf(BL, R, QL)) = isIndepR i R and isIndepB i BL .
 eq isIndepR i (preNF(BL, R, QL, x)) = isIndepR i R and isIndepB i BL .
 eq isIndepR i (read q) = true .
 eq isIndepR i (read (q[nlist])) = hasOnlyI i nlist .
 
 var n : Nat .
 var nt1 nt2 : NatTerm .
 
 op hasOnlyI__ : Qid List{NatTerm} -> Bool .
 eq hasOnlyI i j = i == j .
 eq hasOnlyI i n = true .
 eq hasOnlyI i (nt1 ++ nt2) = false .
 eq hasOnlyI i (nt1 -- nt2) = false .
 eq hasOnlyI i (nt1 nlist) = hasOnlyI i nt1 and hasOnlyI i nlist .
 
 op isIndepB__ : Qid BindList -> Bool .
 eq isIndepB i emptyBRList = true .
 eq isIndepB i (x : T <- R) = isIndepR i R .
 eq isIndepB i (x : T <~ R) = isIndepR i R .
 eq isIndepB i ((x : T <- R) BL) = isIndepR i R and isIndepB i BL .
 eq isIndepB i ((x : T <~ R) BL) = isIndepR i R and isIndepB i BL .
 
endfm 
 
fmod PROTOCOL-IO is
 protecting PROTOCOL .
 protecting CHANNEL .

 op getOutputs : Protocol -> Set{CName} .
 
 var c : ChannelName .
 var P P1 P2 : Protocol .
 var T : Type .
 vars R : Reaction . 
 var ltq : TypedCNameList .
 var ql : CNameList .
  var nlist : List{NatTerm} .
 var blist : List{Bounds} .
 var whenList : WhenList .
 var whenCond : WhenCond .
 var q : Qid . 

op chansInList_ : TypedCNameList -> Set{CName} .
eq chansInList emptyTypedCNameList = empty .
eq chansInList (< q : T > ltq) = insert(q, chansInList ltq) .
eq chansInList (< q[nlist] : T > ltq) = insert(q, chansInList ltq) .
eq chansInList ({c nlist blist : T} ltq) = insert(c, chansInList ltq) .
               

 eq getOutputs(emptyProtocol) = empty .
 eq getOutputs(q ::= R) = q [label getOutputsAssign] .
 eq getOutputs(q[nlist] ::= R) = q .
 eq getOutputs((q ::= R) || P2) = union(q, getOutputs(P2)) [label getOutputsParallel] .
 eq getOutputs((q[nlist] ::= R) || P2) = union(q, getOutputs(P2)) .
 eq getOutputs(P1 || P2) = union(getOutputs(P1), getOutputs(P2)) [owise] .
 eq getOutputs(new c : T in P) = getOutputs(P) \ qidOfName(c) [label getOutputsNew] .
 eq getOutputs(newfamily c nlist blist : T in P) = getOutputs(P) \ c .
 eq getOutputs(newNF(ltq, P, ql)) = getOutputs(P) \ (chansInList ltq) [label getOutputsNewNF] .
 eq getOutputs(family c nlist blist ::= R) = c .
 eq getOutputs(family c nlist blist ::= (whenCond --> R) ;; whenList) = c .
 eq getOutputs(family c nlist blist ::= (whenCond --> P) ;; whenList) = getOutputs(P) .
 eq getOutputs(family c nlist blist ::= P) = getOutputs(P) .
   
endfm

fmod PROTOCOL-TYPING is 
 protecting PROTOCOL-IO .
 protecting PROTOCOL-INDEP .
 protecting REACTION-TYPING .

 var Sigma : Signature .
 var Delta : ChannelContext .
 var I : Set{CName} .
 var Q o cn : ChannelName .
 var c q : Qid .
 var T : Type .
 var R : Reaction .
 var P1 P2 P : Protocol .
 var n n0 : Nat .

 op typeOf : Signature ChannelContext Set{CName} Protocol -> Bool .
 
 eq typeOf(Sigma, Delta, I, emptyProtocol) = validChanSet I Delta .
 
 ceq typeOf(Sigma, Delta (q n :: T), I, cn ::= R) = 
    validChanSet I (Delta (q n :: T)) 
     and
    typeOf(Sigma, Delta (q n :: T), emptyVarContext, I, R) == T
     and 
    not q isElem I
 if length(cn) == n and qidOfName(cn) == q .
  
 eq typeOf(Sigma, Delta, I, P1 || P2) =
     validChanSet I Delta 
     and
     typeOf(Sigma, Delta, union(I, getOutputs(P2)), P1) 
     and 
     typeOf(Sigma, Delta, union(I,  getOutputs(P1)), P2)
     .

 eq typeOf(Sigma, Delta, I, new o : T in P) =
     validChanSet I Delta 
     and 
     not occurs o Delta 
     and
     typeOf(Sigma, Delta (qidOfName(o) length(o) :: T), I, P)
     [label typeOfNew] . 
     
 eq typeOf(Sigma, Delta, I, newfamily c nlist blist : T in P) =
    validChanSet I Delta
    and 
    not occurs c Delta 
    and
    typeOf(Sigma, Delta (c (size(nlist)) :: T), I, P) 
  .
 
 var cases : Cases . 
 var whenCond : WhenCond .
 var whenList : WhenList .
  
 eq typeOf(Sigma, Delta (c n :: T), I, family c nlist blist ::= R) = 
     validChanSet I (Delta (c n :: T)) 
     and
     typeOf(Sigma, Delta (c n :: T), emptyVarContext, insert(c,I), R) == T
     and 
     not c isElem I 
     and
     n == size(nlist) .
 
 eq typeOf(Sigma, Delta, I, family c nlist blist ::= P) = 
    typeOf(Sigma, Delta, I, P) . 
       
 
 eq typeOf(Sigma, Delta (c n :: T), I, family c nlist blist ::= (whenCond --> R)) = 
     validChanSet I (Delta (c n :: T)) 
     and
     typeOf(Sigma, Delta (c n :: T), emptyVarContext, insert(c, I), R) == T
     and
     n == size(nlist) 
     .   
      
  eq typeOf(Sigma, Delta , I, family c nlist blist ::= (whenCond --> P)) = 
     typeOf(Sigma, Delta , I, P) .      
    
 eq typeOf(Sigma, Delta (c n :: T), I, family c nlist blist ::= (whenCond --> R) ;; whenList) = 
    typeOf(Sigma, Delta (c n :: T), I, family c nlist blist ::= (whenCond --> R))
    and
    typeOf(Sigma, Delta (c n :: T), I, family c nlist blist ::= whenList)
    .
 
 eq typeOf(Sigma, Delta, I, family c nlist blist ::= (whenCond --> P) ;; whenList) = 
    typeOf(Sigma, Delta, I, family c nlist blist ::= (whenCond --> P))
    and
    typeOf(Sigma, Delta, I, family c nlist blist ::= whenList)  
    *** TODO: add this back in
 .
  *** TODO: can we improve by checking validChanSet just once?
 
 var ltq : TypedCNameList .   
 var ql : CNameList . 
     
 eq typeOf(Sigma, Delta, I, newNF(ltq, P, ql)) = 
    typeOf(Sigma, Delta, I, newNF2New(newNF(ltq, P, ql)))
    .
    
 var nlist : List{NatTerm} .
 var blist : List{Bounds} .   
    
 op allNew__ : TypedCNameList ChannelContext -> Bool .
 eq allNew emptyTypedCNameList Delta = true .
 eq allNew (< c : T > ltq) Delta = not occurs c Delta and allNew ltq Delta .
 eq allNew ({c nlist blist : T } ltq) Delta = not occurs c Delta and allNew ltq Delta .
 
 op addChannels__ : TypedCNameList ChannelContext -> ChannelContext .
 eq addChannels emptyTypedCNameList Delta = Delta .   
 eq addChannels (< c : T > ltq) Delta = addChannels ltq (Delta (c 0 :: T)) .
 eq addChannels (< c[nlist] : T > ltq) Delta = addChannels ltq (Delta (c (size(nlist)) :: T)) .
 eq addChannels ({c nlist blist : T } ltq) Delta = addChannels ltq (Delta (c (size(nlist)) :: T)) .
 
endfm

mod PROTOCOL-EQUALITY is
 protecting PROTOCOL-TYPING .
 protecting REACTION-EQUALITY .
 protecting SET{BoolTerm} .

 var Sigma : Signature .
 vars Delta D Delta' : ChannelContext .
 vars R R' R1 R2 R3 R4 S1 S2 S : Reaction .
 vars T T0 T1 T2 T3 : Type .
 vars M M1 M2 : Message .
 vars I I' I'' I1 O O' O'' O1 O2 O3 : Set{CName} . 
 var l r c i o o1 o2 o3 : ChannelName .
 var b x x0 x1 x2 y y0 y1 y2 z : ChannelName . *** was Qid 
 vars P P1 P2 P3 P4 Q : Protocol .
 var n : Nat .
 var lq : List{NatTerm} .
 var ltq ltq1 ltq2 : TypedCNameList .
 var Dist : Distribution .
 var q : Qid .
 
  var BRL : BRList .
 var QL : CNameList .
 var A : Set{BoolTerm} .

 sort ProtocolConfig . 
 op pConfig : Signature ChannelContext Protocol Set{CName} Set{CName} Set{BoolTerm} -> ProtocolConfig [ctor] .

 crl [proof-composition] :
    pConfig(Sigma, Delta, P1, I, O, A) 
    => 
    pConfig(Sigma, Delta, P2, I, O, A)
    if
    isIndepComp 'any P1 *** the qid does not matter here!
    /\
    pConfig(Sigma, Delta, projZero P1, I, O, A)
    => 
    pConfig(Sigma, Delta, P3, I, O, A)
    /\
    P3 == projZero P2 [nonexec] .
 
 rl [rewrite-protocol] : 
    pConfig(Sigma, Delta, P1, I, O, A)
    =>
    pConfig(Sigma, Delta, P2, I, O, A) [nonexec] .

 *** helpers
 
 op countNew : ProtocolConfig -> Nat .
 
 eq countNew(pConfig(Sigma, D, emptyProtocol, I, O, A)) = 0 .
 eq countNew(pConfig(Sigma, D, c ::= R, I, O, A)) = 0 .
 eq countNew(pConfig(Sigma, D, P1 || P2, I, O, A)) = 0 .
 eq countNew(pConfig(Sigma, D, new c : T in P, I, O, A)) = 1 + countNew(pConfig(Sigma, D, P, I, O, A)) .

 var C : Qid .
*** var cOf : CaseOf .
 var ql ql1 ql2 : CNameList .


***(
 rl [desugar-family] : 
    family C lq n := cOf =>
    f2p(family C lq n := cOf) . 
    
 rl [desugar-newfamily] :
    newfamily C lq n : T in P =>
    nf2p(newfamily C lq n : T in P) .  
 )   

 rl [desugar-newNF] :
     pConfig(Sigma, Delta, newNF(ltq, P1, ql), I, O, A)
     =>
     pConfig(Sigma, Delta, newNF2New(newNF(ltq, P1, ql)), I, O, A) 
 .
     
 rl [sugar-newNF] :
    pConfig(Sigma, Delta, P, I, O, A)
    => 
    pConfig(Sigma, Delta, new2NF(P), I, O, A) .
       
 crl [CONG-NEW-NF] : 
    pConfig(Sigma, Delta, newNF(ltq, P1, ql), I, O, A) 
    => 
    pConfig(Sigma, Delta, newNF(ltq, P2, ql), I, O, A)
    if
    pConfig(Sigma, addChannels ltq Delta, P1, I, union(chansInList ltq, O), A)
    =>
    pConfig(Sigma, Delta', P2, I, O', A) 
    /\
    Delta' == addChannels ltq Delta
    /\
    O' == union(chansInList ltq, O)
    .   
    
 crl [absorb-new-nf] : 
     pConfig(Sigma, Delta, newNF(< c : T > ltq, P || (c ::= R), ql), I, O, A) 
     => 
     pConfig(Sigma, Delta, newNF(ltq, P, del c ql), I, O, A) 
     if
     typeOf(Sigma, addChannels ltq (Delta (qidOfName(c) length(c) :: T)), emptyVarContext, 
            insert(c, union(I, getOutputs(P))), R) == T 
     /\
     typeOf(Sigma, addChannels ltq Delta, I, P)       
     /\ 
     getOutputs(newNF2New(newNF(ltq, P, ql))) == O
     .
     
 var nlist : List{NatTerm} .
 var cases : Cases .    
     
 crl [absorb-reverse-new-nf-family] : 
     pConfig(Sigma, Delta, newNF(ltq, P, ql), I, O, A)
     =>
     pConfig(Sigma, Delta, 
             newNF({q nlist blist : T } ltq, 
                   P || (family q nlist blist ::= cases), q :: ql), I, O, A) 
     if
     *** typeOf(Sigma, addChannels ltq (Delta (q size(nlist) :: T)), emptyVarContext, 
     ***       insert(q, union(I, getOutputs(P))), cases) == T 
     *** /\
     typeOf(Sigma, addChannels ltq Delta, I, P)       
     *** /\ 
     *** getOutputs(newNF2New(newNF(ltq, P, ql))) == O
     [nonexec] .    
     
 crl [comp-new-nf-left] : 
     pConfig(Sigma, Delta, newNF(< c : T > ltq, P || (c ::= R), ql), I, O, A) 
    => 
     pConfig(Sigma, Delta, newNF(ltq, P || new c : T in (c ::= R), del c ql), I, O, A) 
    if
     typeOf(Sigma, addChannels ltq Delta, I, P) 
     /\
     typeOf(Sigma, addChannels ltq (Delta (qidOfName(c) length(c) :: T)), emptyVarContext, 
            insert(c, union(I, getOutputs(P))), R) == T 
    . 
   
 crl [comp-new-nf-right] :   *** TODO! where we add c
    pConfig(Sigma, Delta, newNF(ltq, P || new c : T in Q, ql), I, O, A)
    =>
    pConfig(Sigma, Delta, newNF(< c : T > ltq, P || Q, c :: ql), I, O, A) 
    if
     typeOf(Sigma, addChannels ltq Delta, union(I, getOutputs(Q)), P) 
     /\
     typeOf(Sigma, addChannels ltq (Delta (qidOfName(c) length(c) :: T)), union(I, getOutputs(P)), Q) 
    .
    
  crl [comp-new-nf-right-family] :   *** TODO! where we add c
    pConfig(Sigma, Delta, newNF(ltq, P || newfamily c nlist blist : T in Q, ql), I, O, A)
    =>
    pConfig(Sigma, Delta, newNF({ c nlist blist : T } ltq, P || Q, c :: ql), I, O, A) 
    if
     typeOf(Sigma, addChannels ltq Delta, union(I, getOutputs(Q)), P) 
     /\
     typeOf(Sigma, addChannels ltq (Delta (c size(nlist) :: T)), union(I, getOutputs(P)), Q) 
    .   
    
 crl [fold-bind-new] :
    pConfig(Sigma, Delta, 
             newNF(< c : T > ltq, P || (c ::= R) || (o ::= x : T <- read c ; S), ql),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, P || (o ::= x : T <- R ; S), del c ql),
            I, O, A) 
    if 
    typeOf(Sigma, addChannels ltq (Delta (qidOfName(c) length(c) :: T)), emptyVarContext, 
            insert(o, insert(c, union(I, getOutputs(P)))), R) == T . 
            
  crl [fold-bind-new-nf] :
    pConfig(Sigma, Delta, 
             newNF(< c : T > ltq, P || (c ::= R) || 
                                 (o ::= nf((x : T <- read c) BRL, S, QL)), 
                   ql),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, P || (o ::= preNF((x : T <~ R) BRL, S, QL, x)), del c ql),
            I, O, A) 
    if typeOf(Sigma, addChannels ltq (Delta (qidOfName(c) length(c) :: T)), addDeclarations BRL emptyVarContext, 
            insert(o, insert(c, union(I, getOutputs(P)))), R) == T .  
            
  crl [fold-bind-new-prenf] :
    pConfig(Sigma, Delta, 
             newNF(< c : T > ltq, P || (c ::= R) || 
                                 (o ::= preNF((x : T <- read c) BRL, S, QL, x1)), ql),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, P || (o ::= preNF((x : T <~ R) BRL, S, QL, x1)), del c ql),
            I, O, A) 
    if        
    typeOf(Sigma, addChannels ltq (Delta (qidOfName(c) length(c) :: T)), emptyVarContext, 
            insert(o, insert(c, union(I, getOutputs(P)))), R) == T .                     

 crl [SYM] :
     pConfig(Sigma, Delta, P2, I, O, A) 
     => 
     pConfig(Sigma, Delta, P1, I, O, A)
     if
     pConfig(Sigma, Delta, P1, I, O, A)
     => 
     pConfig(Sigma, Delta, P2, I, O, A) [nonexec] .
     
 var cn : ChannelName .    

 crl [CONG-REACT] : 
     pConfig(Sigma, Delta (o n :: T), cn ::= R, I, o, A) 
     =>
     pConfig(Sigma, Delta (o n :: T), cn ::= R', I, o, A)
     if
     rConfig(Sigma, Delta (o n :: T), emptyVarContext, R, insert(o, I), T)
     =>
     rConfig(Sigma, Delta (o n :: T), emptyVarContext, R', I', T) 
     /\ I' == insert(o, I)  
     /\ matchesQid cn o 
     /\ length(cn) == n .
     *** /\ R =/= R' .

 crl [CONG-COMP-LEFT] :
     pConfig(Sigma, Delta, P1 || Q, I, O, A) 
     => 
     pConfig(Sigma, Delta, P2 || Q, I, O, A)
     if
     pConfig(Sigma, Delta, P1, union(I, getOutputs(Q)), getOutputs(P1), A)
     => 
     pConfig(Sigma, Delta, P2, I1, O1, A)
     /\
     O1 == getOutputs(P1) /\ I1 == union(I, getOutputs(Q))
     /\ typeOf(Sigma, Delta, union(I, getOutputs(P1)), Q) 
     /\ O == union(getOutputs(P1), getOutputs(Q))
 .

  crl [CONG-COMP-RIGHT] :
     pConfig(Sigma, Delta, Q || P1, I, O, A) 
     => 
     pConfig(Sigma, Delta, Q || P2, I, O, A)
     if
     pConfig(Sigma, Delta, P1, union(I, getOutputs(Q)), getOutputs(P1), A)
     => 
     pConfig(Sigma, Delta, P2, I1, O1, A)
     /\ O1 == getOutputs(P1) 
     /\ I1 == union(I, getOutputs(Q))
     /\ typeOf(Sigma, Delta, union(I, getOutputs(P1)), Q) 
     /\ O == union(getOutputs(P1), getOutputs(Q))
     .
     
 crl [CONG-NEW] : 
     pConfig(Sigma, Delta, new cn : T in P1, I, O, A)
     => 
     pConfig(Sigma, Delta, new cn : T in P2, I, O, A)
     if
     pConfig(Sigma, Delta (qidOfName(cn) length(cn) :: T),  P1, I, insert(qidOfName(cn), O), A)
     => 
     pConfig(Sigma, Delta (q' n :: T),  P2, I, O', A) 
     /\ O' == insert(qidOfName(cn), O)
     /\ q' == qidOfName(cn)
     /\ length(cn) == n
     [nonexec] .
     *** /\ P1 =/= P2 .   

  *** COMP-COMM and COMP-ASSOC are out, || has these attributes
  *** AXIOM don't requires a new rule, one is added for each axiom
  *** EMBED is just application of rules to terms.
 
  var q1 q2 : Qid .
  var cn1 cn2 : ChannelName .
  
  crl [NEW-EXCH] :
     pConfig(Sigma, Delta, new cn1 : T1 in new cn2 : T2 in P, I, O, A) 
     => 
     pConfig(Sigma, Delta, new cn2 : T2 in new cn1 : T1 in P, I, O, A)
     if
     typeOf(Sigma, Delta (qidOfName(cn1) length(cn1) :: T1) 
                         (qidOfName(cn2) length(cn2) :: T2), I, P) /\
     getOutputs(P) == insert(qidOfName(cn1), insert(qidOfName(cn2), O)) .

 crl [COMP-NEW] :
     pConfig(Sigma, Delta, P || (new cn : T in Q), I, O, A)
     =>  
     pConfig(Sigma, Delta, new cn : T in (P || Q), I, O, A)
     if
     typeOf(Sigma, Delta (qidOfName(cn) length(cn) :: T), union(I, getOutputs(P)), Q)
     /\
     typeOf(Sigma, Delta, union(I ,(getOutputs(Q) \ qidOfName(cn))), P) .
     
  crl [COMP-NEW-newNF-newfamily] :
     pConfig(Sigma, Delta, P || (newfamily c nlist blist : T in Q), I, O, A)
     =>  
     pConfig(Sigma, Delta, newNF( {c nlist blist : T}, P || Q, c :: emptyCNameList), I, O, A)
     if 
     typeOf(Sigma, Delta (c size(nlist) :: T), union(I, getOutputs(P)), Q)
     /\
     typeOf(Sigma, Delta, union(I ,(getOutputs(Q) \ c)), P) .  

  crl [COMP-NEW-2] :
     pConfig(Sigma, Delta, new cn : T in (P || Q), I, O, A)
     =>  
     pConfig(Sigma, Delta, P || (new cn : T in Q), I, O, A)
     if
     typeOf(Sigma, Delta (qidOfName(cn) length(cn) :: T), union(I, getOutputs(P)), Q)
     /\
     typeOf(Sigma, Delta, union(I ,(getOutputs(Q) \ qidOfName(cn))), P) .

  crl [ABSORB-LEFT] : 
     pConfig(Sigma, Delta, P1 || P2, I, O, A) =>
     pConfig(Sigma, Delta, P1, I, O, A) 
     if
     typeOf(Sigma, Delta, I, P1) 
     /\
     typeOf(Sigma, Delta, union(I, O), P2) 
     /\
     getOutputs(P1) == O
     /\ 
     getOutputs(P2) == empty
     .
      
     
 crl [ABSORB-LEFT-2] : 
     pConfig(Sigma, Delta, P1 , I, O, A) =>
     pConfig(Sigma, Delta, P1 || P2, I, O, A) 
     if
     typeOf(Sigma, Delta, I, P1) 
     /\
     typeOf(Sigma, Delta, union(I, O), P2) 
     /\
     getOutputs(P1) == O
     /\ 
     getOutputs(P2) == empty [nonexec] .    

 crl [ABSORB-RIGHT] : 
     pConfig(Sigma, Delta, P1 || P2, I, O, A) =>
     pConfig(Sigma, Delta, P2, I, O, A) 
     if
     typeOf(Sigma, Delta, I, P2) 
     /\
     typeOf(Sigma, Delta, union(I, O), P1) 
     /\
     getOutputs(P2) == O
     /\ 
     getOutputs(P1) == empty .

  crl [DIVERGE] :
     pConfig(Sigma, Delta (q n :: T), cn ::= x : T <- read cn ; R, I, q, A)
     =>
     pConfig(Sigma, Delta (q n :: T), cn ::= read cn, I, q, A)
     if
     typeOf(Sigma, Delta, emptyVarContext, insert(q, I), R) == T /\
     length(cn) == n /\ 
     qidOfName(cn) == q .

    crl [FLIP-UNIF] : 
      pConfig(Sigma, Delta (q n :: bool),
              cn ::= x : bool <- samp flip ;
                     if x then return True else read cn, I, O, A)
      => 
      pConfig(Sigma, Delta (q n :: bool),
              cn ::= x : bool <- samp flip ;
                     if x then read cn else return False , I, O, A)
    if O == q /\ not q isElem I /\ length(cn) == n /\ qidOfName(cn) == q .

 crl [FOLD-IF-RIGHT] :
     pConfig(Sigma, Delta (q n :: T),
             new cn1 : T in ((cn2 ::= b : bool <- R ;
                                if b then S1 else read cn1)
                          ||
                           (cn1 ::= S2))
            ,I, O, A)
     => 
     pConfig(Sigma, Delta (q n :: T),
             cn2 ::= b : bool <- R ;
                   if b then S1 else S2
             , I, O, A)
     if
     typeOf(Sigma, Delta (q n :: T), emptyVarContext, insert(q, I), S1) == T
     /\
     typeOf(Sigma, Delta (q n :: T), emptyVarContext, insert(q, I), S2) == T
     /\
     O == q 
     /\
     length(cn2) == n /\ 
     qidOfName(cn2) == q .

  crl [FOLD-IF-LEFT] :
     pConfig(Sigma, Delta (q n :: T),
             new cn2 : T in ((cn1 ::= b : bool <- R ;
                                if b then read cn2 else S2)
                          ||
                           (cn2 ::= S1))
            ,I, O, A)
     => 
     pConfig(Sigma, Delta (q n :: T),
             cn1 ::= b : bool <- R ;
                   if b then S1 else S2
             , I, O, A)
     if
     typeOf(Sigma, Delta (q n :: T), emptyVarContext, insert(q, I), S1) == T
     /\
     typeOf(Sigma, Delta (q n :: T), emptyVarContext, insert(q, I), S2) == T
     /\
     O == q /\
     length(cn1) == n /\ 
     qidOfName(cn1) == q .

  crl [FOLD-BIND] :
     pConfig(Sigma, Delta, 
             new c : T in ((o ::= x : T <- read c ; S)
                           ||
                           (c ::= R)),
             I, O, A)
     =>
     pConfig(Sigma, Delta,
             o ::= x : T <- R ; S,
             I, O, A)
    if O == qidOfName(o) .
    
  crl [FOLD-BIND-2] :
     pConfig(Sigma, Delta, 
             o ::= x : T <- R ; S,
             I, O, A)
     =>
     pConfig(Sigma, Delta,
             new c : T in ((o ::= x : T <- read c ; S)
                           ||
                           (c ::= R)),
             I, O, A)
    if O == o [nonexec] . 
    
 crl [SUBSUME] :
    pConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2), 
            (cn1 ::= x0 : T0 <- read i ; R1) || 
            (cn2 ::= x0 : T0 <- read i ; x1 : T1 <- read cn1 ; R2) 
           , I, O, A)
    => 
    pConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2),
            (cn1 ::= x0 : T0 <- read i ; R1) || 
            (cn2 ::= x1 : T1 <- read cn1 ; R2)  
           , I, O, A)
   if typeOf(Sigma, Delta, x1 : T1, insert(q1, insert(q2,I)), R2) == T2  
   /\ O == insert(q1, insert(q2, empty)) /\ cn1 =/= cn2 /\
   length(cn1) == n1 /\ 
   qidOfName(cn1) == q1 /\
   length(cn2) == n2 /\ 
   qidOfName(cn2) == q2  . 
    
 crl [UNUSED] : 
   pConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2),
           (cn1 ::= R1) || (cn2 ::= x1 : T1 <- read cn1 ; R2)
          ,I, O, A)
   => 
   pConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2),
           (cn1 ::= R1) || (cn2 ::= R2)
          ,I, O, A)
   if rConfig(Sigma, Delta, emptyVarContext, 
              x1 : T1 <- R1 ; R2
             , insert(q1, insert(q2, I)), T2) 
      => 
      rConfig(Sigma, Delta, emptyVarContext, 
              R2
             ,I', T2) /\
      I' == insert(q1, insert(q2, I)) /\
      O == insert(q1, insert(q2, empty)) /\
      typeOf(Sigma, Delta, emptyVarContext, 
             insert(q1, insert(q2, I)), R2) == T2 /\ 
      cn1 =/= cn2 /\
      length(cn1) == n1 /\ 
   qidOfName(cn1) == q1 /\
   length(cn2) == n2 /\ 
   qidOfName(cn2) == q2
      [nonexec] .
      
      
  *** this rule is actually derived from unused and samp-pure!    
  crl [UNUSED-nf] :
    pConfig(Sigma, Delta (q1 0 :: T1) (q2 0 :: T2),
            (q1 ::= samp Dist) || (q2 ::= nf( (x : T1 <- read q1) BRL , R2, QL) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta (q1 0 :: T1) (q2 0 :: T2),
            (q1 ::= samp Dist) || (q2 ::= nf( BRL , R2, del x QL) ),
            I, O, A) 
    if
     typeOf(Sigma, Delta (q1 0 :: T1) (q2 0 :: T2), addDeclarations BRL (x : T1), 
             insert(q1, insert(q2, I)), R2) == T2
    . 
            
  crl [UNUSED-pre-nf] :
    pConfig(Sigma, Delta (q1 0 :: T1) (q2 0 :: T2),
            (q1 ::= samp Dist) || (q2 ::= preNF( (x : T1 <- read q1) BRL , R2, QL, c) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta (q1 0 :: T1) (q2 0 :: T2),
            (q1 ::= samp Dist) || (q2 ::= preNF( BRL , R2, del x QL, c) ),
            I, O, A) 
     if
     typeOf(Sigma, Delta (q1 0 :: T1) (q2 0 :: T2), addDeclarations BRL (x : T1), 
             insert(q1, insert(q2, I)), R2) == T2
     .          
              
  crl [SUBST-nf] : 
     pConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2),
             (cn1 ::= R1) || (cn2 ::= nf( (x1 : T1 <- read cn1) BRL , R2, QL) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2),
             (cn1 ::= R1) || (cn2 ::= preNF((x1 : T1 <~ R1) BRL , R2, QL, x1)),
             I, O, A) 
     if isSampFree(R1) /\
        O == insert(q1, q2) /\ 
     typeOf(Sigma, Delta, emptyVarContext, 
            insert(q1, insert(q2, I)), R1) == T1 /\
     typeOf(Sigma, Delta, addDeclarations BRL (x1 : T1), 
            insert(q1, insert(q2, I)), R2) == T2
     /\
      length(cn1) == n1 /\ 
   qidOfName(cn1) == q1 /\
   length(cn2) == n2 /\ 
   qidOfName(cn2) == q2   
     . 

***(     
  var nlist1 nlist2 : List{NatTerm} . 
  var qid1 qid2 : Qid .  
     
  crl [SUBST-nf-cname] : 
     pConfig(Sigma, Delta (qid1 :: T1) (qid2 :: T2),
             (o1 ::= R1) || 
             (o2 ::= nf( (x1 : T1 <- read o1) BRL , R2, QL) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta (qid1 :: T1) (qid2 :: T2),
             (o1 ::= R1) || 
             (o2 ::= preNF((x1 : T1 <~ R1) BRL , R2, QL, x1)),
             I, O, A) 
     if isSampFree(R1) /\ matchesQid o1 qid1 /\ matchesQid o2 qid2 ***( /\
        O == insert(qid1, qid2) /\ 
     typeOf(Sigma, Delta, emptyVarContext, 
            insert(qid1, insert(qid2, I)), R1) == T1 /\
     typeOf(Sigma, Delta, addDeclarations BRL (x1 : T1), 
            insert(qid1, insert(qid2, I)), R2) == T2   )
     .   
)
         
  crl [SUBST-nf-read] : 
     pConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2) (C n :: T1),
             (cn1 ::= nf((x2 : T1 <- read C), return x2, x2 :: emptyCNameList )) || 
             (cn2 ::= nf( (x1 : T1 <- read cn1) BRL , R2, QL) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2) (C n :: T1),
             (cn1 ::= nf((x2 : T1 <- read C), return x2, x2 :: emptyCNameList )) || 
             (cn2 ::= nf((x2 : T1 <- read C) BRL , R2 [x1 / x2], replace x1 x2 QL)),
             I, O, A) 
     if
     C isElem I /\
     O == insert(q1, q2) /\ 
     typeOf(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2)(C n :: T1), addDeclarations BRL (x1 : T1), 
             insert(q1, insert(q2, I)), R2) == T2 
             /\
      length(cn1) == n1 /\ 
   qidOfName(cn1) == q1 /\
   length(cn2) == n2 /\ 
   qidOfName(cn2) == q2
     .  

   crl [SUBST] : 
     pConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2),
             (cn1 ::= R1) || (cn2 ::= x1 : T1 <- read cn1 ; R2),
             I, O, A)  
     => 
     pConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2),
             (cn1 ::= R1) || (cn2 ::= x1 : T1 <- R1 ; R2),
             I, O, A) 
     if
     rConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2), emptyVarContext,
             x1 : T1 <- R1 ; x2 : T1 <- R1 ; return pair(x1, x2),
             insert(q1, insert(q2, I)), T1 * T2)
     => 
     rConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2), emptyVarContext,
             x1 : T1 <- R1 ;  return pair(x1, x1),
             I', T1 * T2) /\
     O == insert(q1, q2) /\ 
     I' == insert(q1, insert(q2, I)) /\
     q1 =/= q2 /\
      length(cn1) == n1 /\ 
   qidOfName(cn1) == q1 /\
   length(cn2) == n2 /\ 
   qidOfName(cn2) == q2 [nonexec] .
 
     
   crl [SUBST-2] : 
     pConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2),
             (cn1 ::= R1) || (cn2 ::= x1 : T1 <- R1 ; R2),
             I, O, A)  
     => 
     pConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2),
             (cn1 ::= R1) || (cn2 ::= x1 : T1 <- read cn1 ; R2),
             I, O, A) 
     if
     rConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2), emptyVarContext,
             x1 : T1 <- R1 ; x2 : T1 <- R1 ; return pair(x1, x2),
             insert(q1, insert(q2, I)), T1 * T2)
     => 
     rConfig(Sigma, Delta (q1 n1 :: T1) (q2 n2 :: T2), emptyVarContext,
             x1 : T1 <- R1 ;  return pair(x1, x1),
             I', T1 * T2) /\
     O == insert(q1, insert(q2, empty)) /\ 
     I' == insert(q1, insert(q2, I)) /\
     q1 =/= q2 /\
      length(cn1) == n1 /\ 
   qidOfName(cn1) == q1 /\
   length(cn2) == n2 /\ 
   qidOfName(cn2) == q2 [nonexec] .  
   
     *** rules for families, check
  
     rl [comp-new-families] : 
     pConfig(Sigma, Delta, newNF(ltq1, P1, ql1) || newNF(ltq2, P2, ql2), I, O, A)
     => 
     pConfig(Sigma, Delta, newNF(ltq1 ltq2, P1 || P2, ql1 ++ ql2), I, O, A) 
     .
     
     crl [use-family-p] : 
     pConfig(Sigma, Delta, P1 || family C lq blist ::= P, I, O, A)
     => 
     pConfig(Sigma, Delta, P2 || family C lq blist ::= P, I, O, A)
     if 
     pConfig(Sigma, Delta, P1 || P, I, O, A)
     => 
     pConfig(Sigma, Delta, P2 || P, I, O, A)
     [nonexec] .
     
     *** congruence rules for families
     var blist : List{Bounds} .
     
     crl [CONG-NEWFAMILY] : 
     pConfig(Sigma, Delta, newfamily C lq blist : T in P1, I, O, A)
     =>  
     pConfig(Sigma, Delta, newfamily C lq blist : T in P2, I, O, A)
     if 
     pConfig(Sigma, Delta (C (size(lq)) :: T), P1, I, insert(C, O), A)
     =>
     pConfig(Sigma, Delta (C (size(lq)) :: T), P1, I, O', A)
     /\
     O' == insert(C, O)
     [nonexec]
     .
      
     crl [CONG-FAMILY-R] : 
     pConfig(Sigma, Delta (C n :: T), family C lq blist ::= R, I, O, A)
     => 
     pConfig(Sigma, Delta (C n :: T), family C lq blist ::= R', I, O, A)
     if 
     rConfig(Sigma, Delta (C n :: T), emptyVarContext, R, insert(C, I), T)
     =>
     rConfig(Sigma, Delta (C n :: T), emptyVarContext, R', I', T) 
     /\ I' == insert(C, I)  
     /\ size(lq) == n [nonexec] .
          
     crl [CONG-FAMILY-P] : 
     pConfig(Sigma, Delta, family C lq blist ::= P1, I, O, A)
     => 
     pConfig(Sigma, Delta, family C lq blist ::= P2, I, O, A)
     if
     pConfig(Sigma, Delta, P1, I, O, A)
     =>
     pConfig(Sigma, Delta, P2, I, O, A) [nonexec] .
     
     var whenCond : WhenCond .
     var whenList1 whenList2 : WhenList .
     
     crl [CONG-FAMILY-WHENLIST-P] : 
     pConfig(Sigma, Delta, family C lq blist ::= whenList1 ;; (whenCond --> P1) ;; whenList2, I, O, A)
     => 
     pConfig(Sigma, Delta, family C lq blist ::= whenList1 ;; (whenCond --> P2) ;; whenList2, I, O, A) 
     if 
     pConfig(Sigma, Delta, P1, I, O, A)
     =>  
     pConfig(Sigma, Delta, P2, I, O, A) [nonexec] . *** TODO: might need two more for whenlists are nonempty?

     crl [CONG-FAMILY-WHENLIST-R] : 
     pConfig(Sigma, Delta (C n :: T), 
       family C lq blist ::= whenList1 ;; (whenCond --> R1) ;; whenList2, I, O, A)
     => 
     pConfig(Sigma, Delta (C n :: T), 
       family C lq blist ::= whenList1 ;; (whenCond --> R2) ;; whenList2, I, O, A) 
     if 
     rConfig(Sigma, Delta (C n :: T), emptyVarContext, R1, insert(C,I), T)
     =>  
     rConfig(Sigma, Delta(C n :: T), emptyVarContext, R2, I', T)
     /\ 
     I' == insert(C, I) [nonexec] . 
     
     *** case distinction
     
     var aP1 aP2 : Protocol .
     var A' A'' : Set{BoolTerm} .
     var aQid : Qid .
     
     crl [CASE-DISTINCTION-one] :
     pConfig (Sigma, Delta, 
               P || family aQid q (bound n) ::= ((when bt --> aP1) ;; whenList),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || family aQid q (bound n) ::= ((when bt --> aP2) ;; whenList'),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || aP1, I, O, insert(bt, A))
     =>
     pConfig(Sigma, Delta, P || aP2, I, O, A')
     /\
     A' == insert(bt, A)
     /\
     pConfig (Sigma, Delta, 
               P || family aQid q (bound n) ::= whenList,
               I, O, insert(neg bt, A)) 
     =>
     pConfig(Sigma, Delta, 
              P || family aQid q (bound n) ::= whenList',
               I, O, A'')
     /\
     A'' == insert(neg bt, A)              [nonexec] .   
     
     crl [CASE-DISTINCTION-one-end] :
     pConfig (Sigma, Delta, 
               P || family C q (bound n) ::= (otherwise --> aP1),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || family C q (bound n) ::= (otherwise --> aP2),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || aP1, I, O, A) *** A already has all negated conditions
     =>
     pConfig(Sigma, Delta, P || aP2, I, O, A)            
     [nonexec] .
     
     *** induction
     
     var q' : Qid .
     var k n1 n2 : Nat . 
     var R'' : Reaction .
     *** could be we need k < n in A?
     
     crl [INDUCTION-R-one] :
     pConfig(Sigma, Delta (C 1 :: T), 
       P || (family C q (bound n) ::= R), I, O, A)
     =>
     pConfig(Sigma, Delta (C 1 :: T), 
       P || (family C q (bound n) ::= R'), I, O, A)
     if 
     pConfig(Sigma, Delta (C 1 :: T), 
       P || (C [0] ::= (R [q / 0])), I, O, A) 
     => 
     pConfig(Sigma, Delta (C 1 :: T), 
       P || (C [0] ::= R''), I, O, A)
     /\
     R'' == (R' [q / 0])   
     /\
     pConfig(Sigma, Delta (C 1 :: T), 
       P || (family C q (bound k) ::= R') || (C[k + 1] ::= (R [q / k + 1])), I, O, A) 
     =>
     pConfig(Sigma, Delta (C 1 :: T), 
       P || (family C q (bound k) ::= R') || (C[k + 1] ::= R3), I, O, A) 
     /\
     R3 == (R' [q / k + 1])  
       [nonexec] .
 
       
     crl [INDUCTION-R-two] :
     pConfig(Sigma, Delta (C 2 :: T), 
       P || (family C (q q') ((bound n1) (uniformBound n2)) ::= R), I, O, A)
     =>
     pConfig(Sigma, Delta (C 2 :: T), 
       P || (family C (q q') ((bound n1) (uniformBound n2)) ::= R'), I, O, A)
     if 
     pConfig(Sigma, Delta (C 2 :: T), 
       P || (family C q (bound n1) ::= (R [q' / 0])), I, O, A) 
     => 
     pConfig(Sigma, Delta (C 2 :: T), 
       P || (family C q (bound n1) ::= R2), I, O, A) 
     /\
     R2 == (R' [q' / 0])
     /\
     pConfig(Sigma, Delta (C 2 :: T), 
       P || (family C (q q') ((bound n1) (uniformBound k)) ::= R') 
       || (family C q (bound n1) ::= (R [q' / k + 1])), I, O, A) 
     =>
     pConfig(Sigma, Delta (C 2 :: T), 
       P || (family C (q q') ((bound n1) (uniformBound k)) ::= R')
         || (family C q (bound n1) ::= R3), I, O, A) 
     /\
     R3 == (R' [q / k + 1])    
       [nonexec] .  
 
     var whenList whenList' : WhenList .  
       
     crl [INDUCTION-when-one] :
     pConfig(Sigma, Delta (C 1 :: T), 
       P || (family C q (bound n1) ::= whenList), I, O, A)
     =>
     pConfig(Sigma, Delta (C 1 :: T), 
       P || (family C q (bound n1) ::= whenList'), I, O, A)
     if 
     pConfig(Sigma, Delta (C 1 :: T), 
       P || (selectCase C[q] C (q |-> 0) n1 whenList 0 ), I, O, A) 
     => 
     pConfig(Sigma, Delta (C 1 :: T), 
       P || P2, I, O, A) 
     /\
     P2 == selectCase C[q] C (q |-> 0) n1 whenList' 0 
     /\
     pConfig(Sigma, Delta (C 1 :: T), 
       P || (family C q (bound k) ::= whenList') || 
       (selectCase C[q] C (q |-> (k + 1)) n1 whenList (k + 1)), I, O, A)
       =>
     pConfig(Sigma, Delta (C 1 :: T), 
       P || (family C q (bound k) ::= whenList') || P4, I, O, A)  
     /\
     P4 == selectCase C[q] C (q |-> (k + 1)) n1 whenList' (k + 1)
       [nonexec] .    
       
    var bt : BoolTerm .  
    var C' : Qid .
    var m : Nat .  
       
    rl [convert-combined] :
       family C q (bound n) ::=
        (
         (when bt --> P1 )
         ;;
         (otherwise --> P2)
        )
       => 
       combine q n bt P1 P2 .
       
   op combine_____ : Qid NatTerm BoolTerm Protocol Protocol -> Protocol .
   eq combine q n bt (C' [q] ::= R1) (C' [q] ::= R2) = 
      family C' q (bound n) ::= ((when bt --> R1) ;; (otherwise --> R2)) .
   eq combine q n bt (family C' q' (uniformBound m) ::= R1) (family C' q' (uniformBound m) ::= R2) = 
      family C' (q q') ((bound n) (uniformBound m)) ::= ((when bt --> R1) ;; (otherwise --> R2)) .
   eq combine q n bt (P1 || C' [q] ::= R1) (P2 || C' [q] ::= R2) = 
      (family C' q (bound n) ::= ((when bt --> R1) ;; (otherwise --> R2)))
      ||
      combine q n bt P1 P2 . 
   eq combine q n bt (P1 || family C' q' (uniformBound m) ::= R1) 
                     (P2 || family C' q' (uniformBound m) ::= R2) = 
      (family C' (q q') ((bound n) (uniformBound m)) ::= ((when bt --> R1) ;; (otherwise --> R2)) )
      ||
      combine q n bt P1 P2 .
  ***( eq combine q n bt (P1 || (cn ::= R1)) (P2 || (cn ::= R2)) = 
      (cn ::= ((when bt --> R1) ;; (otherwise --> R2)) ) ||
      combine q n bt P1 P2 . )
   eq combine q n bt P1 P2 = emptyProtocol [owise] .       
          
endm

