***( IPDL

  Copyright : (C) 2022-23, Kristina Sojakova, Mihai Codescu
  License   : GNU General Public License v3.0 or later (GPL-3.0-or-later)
  Authors   : Mihai Codescu <mscodescu@gmail.com>
              Kristina Sojakova <sojakova.kristina@gmail.com>

)

fmod TYPES is
 protecting INT .

 sort Type . 
 op unit : -> Type . 
 op bool : -> Type .
 op _*_ : Type Type -> Type .
 
 var A B : Type .

 op prj1 : Type -> Type .
 op prj2 : Type -> Type .
 eq prj1(A * B) = A .
 eq prj2(A * B) = B .

endfm

fmod TYPE-CONTEXT is
 protecting QID . 
 protecting TYPES .

 sort TypeContextElem .

 op _:_ : Qid Type -> TypeContextElem [ctor] .

 var q : Qid . 
 var t : Type .

 op qidOf_ : TypeContextElem -> Qid . 
 eq qidOf (q : t) = q . 

 op typeOf_ : TypeContextElem -> Type . 
 eq typeOf (q : t) = t .

 sort TypeContext . 
 op emptyTypeContext : -> TypeContext [ctor] .
 subsort TypeContextElem < TypeContext . 
 op __ : TypeContext TypeContext -> TypeContext [ctor assoc comm id: emptyTypeContext] .

 vars Q1 Q2 : Qid .
 vars T T1 T2 : Type . 
 vars Gamma1 Gamma2 : TypeContext .
 
 *** check whether a variable with the name Q1 occurs in a var context
 *** with any type
 op _elem_ : Qid TypeContext -> Bool .
 eq Q1 elem emptyTypeContext = false . 
 ceq Q1 elem ((Q2 : T) Gamma1) = true if Q1 == Q2 .
 ceq Q1 elem ((Q2 : T) Gamma1) = Q1 elem Gamma1 if Q1 =/= Q2 .


 *** for a variable that we know occurs in a var context, retrieve the type
 op varType : Qid TypeContext -> Type .
 ceq varType(Q1, (Q2 : T) Gamma1) = T if Q1 == Q2 .
 ceq varType(Q1, (Q2 : T) Gamma1) = varType(Q1, Gamma1) if Q1 =/= Q2 .

 *** a context is valid if a variable doesn't occur twice with different names
 op validContext_ : TypeContext -> Bool .
 eq validContext emptyTypeContext = true .
 eq validContext ((Q1 : T1) Gamma1) = not (Q1 elem Gamma1) and validContext Gamma1 .  

endfm

fmod SIGNATURE is 
 protecting QID . 
 protecting TYPES .

 sort SigElem .

 op _:_~>_  : Qid Type Type -> SigElem [ctor format(b o r o r o)]  . *** function symbol
 op _:_~>>_ : Qid Type Type -> SigElem [ctor format(b o r o r o)] . *** distribution

 vars Q1 Q2 : Qid .
 vars T T1 T2 : Type . 

 op dom_ : SigElem -> Type .
 op cod_ : SigElem -> Type .
  
 eq dom(Q1 : T1 ~> T2)  = T1 .
 eq dom(Q1 : T1 ~>> T2) = T1 .
  
 eq cod(Q1 : T1 ~> T2) = T2 . 
 eq cod(Q1 : T1 ~>> T2) = T2 .

 sort Signature . 
 op emptySig : -> Signature [ctor] .
 subsort SigElem < Signature . 
 op __ : Signature Signature -> Signature [ctor assoc comm id: emptySig format(d n d)] .

 vars Sig1 Sig2 : Signature .

 *** check that a symbol occurs in a signature
 *** independent of its type
 *** and whether if it is a function or distribution name
 op _elem_ : Qid Signature -> Bool .
 eq Q1 elem emptySig = false .
 ceq Q1 elem ((Q2 : T1 ~> T2) Sig1) = true if Q1 == Q2 .
 ceq Q1 elem ((Q2 : T1 ~> T2) Sig1) = Q1 elem Sig1 if Q1 =/= Q2 .
 ceq Q1 elem ((Q2 : T1 ~>> T2) Sig1) = true if Q1 == Q2 .
 ceq Q1 elem ((Q2 : T1 ~>> T2) Sig1) = Q1 elem Sig1 if Q1 =/= Q2 .

 op find__ : Qid Signature -> SigElem . 
 *** only find symbols that appear in signature!
 ceq find Q1 ((Q2 : T1 ~> T2) Sig1)  = Q1 : T1 ~> T2 if Q1 == Q2 .
 ceq find Q1 ((Q2 : T1 ~> T2) Sig1)  = find Q1 Sig1 if Q1 =/= Q2 .
 ceq find Q1 ((Q2 : T1 ~>> T2) Sig1) = Q1 : T1 ~>> T2 if Q1 == Q2 .
 ceq find Q1 ((Q2 : T1 ~>> T2) Sig1) = find Q1 Sig1 if Q1 =/= Q2 .
 
 *** a sig is valid if a symbol name doesn't appear twice
 op validSig_ : Signature -> Bool .
 eq validSig emptySig = true .
 eq validSig ((Q1 : T1 ~> T2) Sig1) = not (Q1 elem Sig1) and validSig Sig1 .
 eq validSig ((Q1 : T1 ~>> T2) Sig1) = not (Q1 elem Sig1) and validSig Sig1 .

endfm
 
fmod EXPRESSION is
 protecting QID .

 sort Expression . 
 
 subsort Qid < Expression . *** variables

 ops True, False : -> Expression [ctor] . 

 op () : -> Expression [ctor] .

 op ap__ : Qid Expression -> Expression [ctor] . *** function application

 op pair : Expression Expression -> Expression [ctor] . *** (_,_)

 op fst_ : Expression -> Expression [ctor] .
 op snd_ : Expression -> Expression [ctor] .
 
endfm

fmod EXPRESSION-TYPING is 
 protecting EXPRESSION .
 protecting SIGNATURE .
 protecting TYPE-CONTEXT .

 op typeOf : Signature TypeContext Expression -> Type .

 var Sigma : Signature .
 var Gamma : TypeContext .
 var x f : Qid .
 var M M1 M2 : Expression .
 var T T1 T2 : Type .

 eq typeOf(Sigma, Gamma (x : T), x) = T .
 eq typeOf(Sigma, Gamma, ()) = unit .
 eq typeOf(Sigma, Gamma, True) = bool .
 eq typeOf(Sigma, Gamma, False) = bool .
 ceq typeOf(Sigma (f : T1 ~> T2), Gamma, ap f M) = T2 
     if typeOf(Sigma (f : T1 ~> T2), Gamma, M) == T1 .
 eq typeOf(Sigma, Gamma, pair(M1, M2)) = typeOf(Sigma, Gamma, M1) * typeOf(Sigma, Gamma, M2) .

 eq typeOf(Sigma, Gamma, fst M) = prj1(typeOf(Sigma, Gamma, M)) .
 eq typeOf(Sigma, Gamma, snd M) = prj2(typeOf(Sigma, Gamma, M)) .

endfm

fmod EXPRESSION-EQUALITY is
 protecting EXPRESSION-TYPING . 
 
 var Sigma : Signature .
 var Gamma : TypeContext . 
 vars M M1 M2 M3 M4 : Expression .
 vars T T1 T2 T3 T4 : Type . 
 var f c : Qid .

 eq fst pair(M1, M2) = M1 .
 eq snd pair(M1, M2) = M2 .
 eq pair(fst M, snd M) = M .

endfm

fmod DISTRIBUTION is
 protecting EXPRESSION .
 protecting TYPES . 

 sort Distribution . 
 *** op flip : -> Distribution [ctor] .
 op _<_> : Qid Expression -> Distribution [ctor] .
endfm 

fmod DISTRIBUTION-TYPING is
 protecting DISTRIBUTION .
 protecting EXPRESSION-TYPING .

 op typeOf : Signature TypeContext Distribution -> Type .

 vars T T1 T2 : Type .
 var M : Expression .
 var Sigma : Signature .
 var Gamma : TypeContext .
 var d : Qid .

 *** eq typeOf(Sigma, Gamma, flip) = bool .
 ceq typeOf(Sigma (d : T1 ~>> T2), Gamma, d < M >) = T2 
     if typeOf(Sigma, Gamma, M) == T1 .  

endfm
 
fmod NAT-TERM is
 protecting QID .
 
 *** we need these for indices and their assumptions
 
 sort NatTerm .
 subsort Nat < NatTerm .
 subsort Qid < NatTerm .
 
 op _++_ : NatTerm NatTerm -> NatTerm [assoc comm] .
 op _--_ : NatTerm NatTerm -> NatTerm .
 op fun__ : Qid NatTerm -> NatTerm [ctor] . *** unary function application
 *** more if needed. 
 
 sort BoolTerm .
 
 *** we need these for conditions in cases
 
 op falseBT : -> BoolTerm [ctor] .
 op trueBT : -> BoolTerm [ctor] .
 op apply__ : Qid NatTerm -> BoolTerm [ctor] . *** predicates over natterms
 op neg_ : BoolTerm -> BoolTerm [ctor] .
 op _=T=_ : NatTerm NatTerm -> BoolTerm [ctor comm] .
 op _<T_ : NatTerm NatTerm -> BoolTerm [ctor] .
 op _<=T_ : NatTerm NatTerm -> BoolTerm [ctor] .
 op _conj_ : BoolTerm BoolTerm -> BoolTerm [ctor assoc comm] .
 op _disj_ : BoolTerm BoolTerm -> BoolTerm [ctor assoc comm] .
 
 var b1 b2 b3 : BoolTerm .
 *** eq (b1 conj b2) disj b3 = (b1 disj b3) conj (b2 disj b3) .
 *** eq (b1 disj b2) conj b3 = (b1 conj b3) disj (b2 conj b3) .
 eq (b1 conj neg b1) = falseBT .
 eq (b1 disj neg b1) = trueBT .
 
endfm

view NatTerm from TRIV to NAT-TERM is
 sort Elt to NatTerm .
endv

view BoolTerm from TRIV to NAT-TERM is
 sort Elt to BoolTerm .
endv

fmod NAT-TERM-EVAL is
 pr NAT-TERM .
 pr MAP{Qid, NatTerm} .
 pr SET{BoolTerm} .
 pr INT .
 
  var n n1 n2 n3 x y : Nat .
  var t t1 t2 t3 t4 nt nt1 nt2 : NatTerm .
  var A : Set{BoolTerm} .
  var bt bt' : BoolTerm .
  var q q' : Qid .
  var f : Map{Qid, NatTerm} .
 
 op diff : Nat Nat -> Nat . *** unsafe difference on naturals
 eq diff(n1, n2) = n1 - n2 .
  
 op subst : NatTerm Map{Qid, NatTerm} -> NatTerm .
 *** substitute in a nat term a qid with another nat term
 eq subst(nt, empty) = nt .
 eq subst(n, f) = n .
 eq subst(q, f) = if f[q] == undefined then q else f[q] fi  .
 eq subst(nt1 ++ nt2, f) = subst(nt1, f) ++ subst(nt2, f) .
 eq subst(nt1 -- nt2, f) = subst(nt1, f) -- subst(nt2, f) .
 eq subst(fun q' nt1, f) = fun q' subst(nt1, f) .
 
 *** properties of the ops on nat terms, the expected ones
 eq (nt ++ x) ++ y = nt ++ (x + y) .
 ceq (nt ++ x) -- y = nt ++ (x - y) if y <= x .
 ceq (nt ++ x) -- y = nt -- (y - x) if x < y .
 eq nt ++ 0 = nt .
 eq (nt -- x) -- y = nt -- (x + y) .
 ceq (nt -- x) ++ y = nt -- (x - y) if y <= x .
 ceq (nt -- x) ++ y = nt -- (y - x) if x < y .
 
 ***(
 eq (n - x) - y = n - (x + y) .
 ceq (n + x) - y = n + (x - y) if y < x .
 ceq (n + x) - y = n - (y - x) if x < y .
 ceq (n - x) + y = n - (x - y) if y <= x .
 ceq (n - x) + y = n - (y - x) if x < y .
 )
 
 op subst : BoolTerm Map{Qid, NatTerm} -> BoolTerm .
 *** substitute a var with a nat term in a bool term
 eq subst(bt, empty) = bt .
 eq subst(nt1 =T= nt2, f) = subst(nt1, f) =T= subst(nt2, f) .
 eq subst(nt1 <T nt2, f) = subst(nt1, f) <T subst(nt2, f) .
 eq subst(nt1 <=T nt2, f) = subst(nt1, f) <=T subst(nt2, f) .
 eq subst(neg bt, f) = neg subst(bt, f) .
 eq subst(apply q' nt1, f) = apply q' subst(nt1, f) .
 eq subst(bt conj bt', f) = (subst(bt, f)) conj (subst(bt', f)) .
 eq subst(bt disj bt', f) = (subst(bt, f)) disj (subst(bt', f)) .
 
 op extendWithAssums__ : Set{BoolTerm} Map{Qid, NatTerm} -> Map{Qid, NatTerm} .
 eq extendWithAssums (A, (q =T= n)) f = extendWithAssums A insert(q, n, f) .
 eq extendWithAssums A f = f [owise] .
 
 op evalBoolTerm : BoolTerm Set{BoolTerm} Map{Qid, NatTerm} -> Bool . 
 *** evaluation w.r.t. a set of assumptions 
 *** and a valuation function
 
 ceq evalBoolTerm(bt, A, f) = true if bt in A .
 ceq evalBoolTerm(bt, A, f) = false if (neg bt) in A .
 
 eq evalBoolTerm(bt conj bt', A, f) =
    evalBoolTerm(bt, A, f) and evalBoolTerm(bt', A, f) .
 eq evalBoolTerm(bt disj bt', A, f) =
    evalBoolTerm(bt, A, f) or evalBoolTerm(bt', A, f) .   
 
 ceq evalBoolTerm(neg bt, A, f) = false if bt in A .
 ceq evalBoolTerm(neg bt, A, f) = true if neg bt in A .
 ceq evalBoolTerm(neg (t =T= 0), A, f) = true if evalBoolTerm(0 <T evalTerm t f, A, f) .
 ceq evalBoolTerm(neg (t1 =T= t2), A, f) = false 
     if evalTerm t1 f == evalTerm t2 f .
 ceq evalBoolTerm(neg (t1 =T= t2), A, f) = true 
     if evalTerm t1 f =/= evalTerm t2 f /\ ((evalTerm t1 f) :: Nat) /\ ((evalTerm t2 f) :: Nat) .
     
 ceq evalBoolTerm(0 =T= t ++ n1, A, f) = false if n1 =/= 0 .
 eq evalBoolTerm(t1 =T= t2, A, f) = evalTerm t1 f == evalTerm t2 f .
 *** eq evalBoolTerm(n1 =T= n2, A, f) = n1 == n2 .
 ceq evalBoolTerm(t1 =T= t2, ((t1 =T= t3), (t4 =T= t2), A), f ) = true 
  if evalBoolTerm(evalTerm t3 f =T= evalTerm t4 f, A, f) .  
 
 eq evalBoolTerm(t + n1 <T t + n2, A, f) = n1 < n2 .
 ceq evalBoolTerm(t <T t1, A, f) = true if (t <=T t1 + 1) in A .
 ceq evalBoolTerm(t <T t1, A, f) = true if (t <=T t1 + 2) in A .
 eq evalBoolTerm(t -- n <T t, A, f) = true .
 ceq evalBoolTerm(t -- n <T t2, A, f) = true if evalBoolTerm( t <=T t2, A, f) .
 eq evalBoolTerm(n1 <T n2, A, f) = n1 < n2 . 
 ceq evalBoolTerm(t1 <T t2 ++ n1, A, f) = true if n1 =/= 0 /\ evalBoolTerm(t1 <T t2, A, f) .
 ceq evalBoolTerm(t1 <T t4, (t1 <T t2, t3 <T t4, A), f) = true 
     if evalBoolTerm(evalTerm t2 f <=T evalTerm t3 f, A, f) .
 eq evalBoolTerm(t <T t, A, f) = false .
 ceq evalBoolTerm(0 <T t ++ n1, A, f) = true if n1 > 0 .
 eq evalBoolTerm(t <T t ++ n1, A, f) = true .
 eq evalBoolTerm(t1 <T t2, (A, t1 <=T t3, t3 ++ 1 <=T t2), f) = true .
 
 ceq evalBoolTerm(t <T t1 + n1, (A, t <T t1 + n2), f) = true 
  if n2 < n1 . 
 eq evalBoolTerm(t <T t + n, A, f) = n > 0 . 
 
 eq evalBoolTerm(0 <=T t, A, f) = true .
 eq evalBoolTerm(t <=T t, A, f) = true . 
 eq evalBoolTerm(n1 <=T n1 + n2, A, f) = true . *** this is new!
 ceq evalBoolTerm(t1 <=T t2 + n2, A, f) = true if t1 <=T n2 in A .
 eq evalBoolTerm(t + n1 <=T t + n2, A, f) = n1 <= n2 .
 eq evalBoolTerm(n1 <=T n2, A, f) = n1 <= n2 .
 ceq evalBoolTerm(t1 -- t2 <=T t, A, f) = true if evalBoolTerm(t1 <=T t, A, f) .
 ceq evalBoolTerm(t1 <=T t2, A, f) = true if evalBoolTerm(t1 <T t2, A, f) .
 ceq evalBoolTerm(t1 <=T t2, A, f) = true if evalBoolTerm(t1 =T= t2, A, f) .
 ceq evalBoolTerm(t1 <=T t4, (t1 <=T t2, t3 <=T t4, A), f) = true 
     if evalBoolTerm(evalTerm t2 f <=T evalTerm t3 f, A, f) .
 ceq evalBoolTerm(t1 <=T t2, A, f) = true if t1 ++ 1 <=T t2 in A .    
      
 op evalTerm__ : NatTerm Map{Qid, NatTerm} -> NatTerm .
 eq evalTerm n1 f = n1 .
 eq evalTerm q f = if f[q] == undefined then q else f[q] fi .
 eq evalTerm (t1 ++ 0) f = evalTerm t1 f .
 ceq evalTerm (t1 ++ t2) f = (evalTerm t1 f) + (evalTerm t2 f) 
  if (evalTerm t1 f) : Nat /\ (evalTerm t2 f) : Nat . 
 eq evalTerm (t1 ++ t2) f = (evalTerm t1 f) ++ (evalTerm t2 f) [owise] .
 ceq evalTerm (t1 -- t2) f = (evalTerm t1 f) - (evalTerm t2 f) 
  if (evalTerm t1 f) : Nat /\ (evalTerm t2 f) : Nat .
 eq evalTerm (t1 -- t2) f = (evalTerm t1 f) -- (evalTerm t2 f) [owise] . 
 *** evaluation is not defined for fun
 *** we will define that for each function symbol
 
 
endfm

fmod BOOL-TERM-ENTAILS is
 pr NAT-TERM-EVAL .
 
 op _|=_with_ : Set{BoolTerm} BoolTerm Map{Qid,NatTerm} -> Bool .
 *** check whether a set of assumptions 
 *** entails a predication with a valuation map
 
 var A : Set{BoolTerm} .
 var nt1 nt2 : NatTerm .
 var n1 n2 : Nat . 
 var q1 q2 : Qid .
 var f : Map{Qid,NatTerm} .
 var bt bt' : BoolTerm .
 
 ceq A |= apply q1 nt1 with f = true 
  if (apply q1 (evalTerm nt1 (extendWithAssums A f))) in A .
  
 ceq A |= nt1 =T= nt2 with f = true 
   if evalBoolTerm(evalTerm nt1 (extendWithAssums A f) =T= evalTerm nt2 (extendWithAssums A f),
                   A , f) .
 eq A |= nt1 =T= nt2 with f = false [owise] .
 
 ceq A |= nt1 <T nt2 with f = true 
  if evalBoolTerm(evalTerm nt1 (extendWithAssums A f) <T evalTerm nt2 (extendWithAssums A f),
                  A, f) .
 eq A |= nt1 <T nt2 with f = false [owise] .
 
 ceq A |= nt1 <=T nt2 with f = true 
  if evalBoolTerm(evalTerm nt1 (extendWithAssums A f) <=T evalTerm nt2 (extendWithAssums A f),
                  A, f) .
 eq A |= nt1 <=T nt2 with f = false [owise] .
 
 *** actually we also want to check f(bt)!
 ceq A |= neg bt with f = true 
  if evalBoolTerm(subst(neg bt, extendWithAssums A f), A, f) .
 eq A |= neg bt with f = false [owise] . 
 
 eq A |= bt conj bt' with f = 
    A |= bt with f and A |= bt' with f .
    
 eq (A, bt conj bt') |= bt with f = true .
 
 eq A |= bt disj bt' with f = 
    A |= bt with f or A |= bt' with f .   
 
endfm

fmod CHANNEL-NAME is
 protecting QID .
 protecting LIST{NatTerm} .
 
 sort NameWithScripts .
 subsort Qid < NameWithScripts .
 op _^^_.._ : NameWithScripts Qid Qid -> NameWithScripts [ctor] .  
   

 var ns : NameWithScripts .
 var aQid sup1 sub1 sup2 sub2 : Qid .

 sort ChannelName .
 subsort NameWithScripts < ChannelName .
 op _[_] : NameWithScripts List{NatTerm} -> ChannelName [ctor] .
 
 var q q1 q2 : Qid .
 var ns2 : NameWithScripts .
 var x : Nat .
 var cn : ChannelName .
 var nlist : List{NatTerm} .
 
 op length : ChannelName -> Nat .
 *** how many indices are in a name
 eq length(ns) = 0 .
 eq length(ns[nlist]) = size(nlist) .
 
 op qidOfName : ChannelName -> NameWithScripts .
 eq qidOfName(ns) = ns .
 eq qidOfName(ns[nlist]) = ns .
 
 op matchesQid__ : ChannelName NameWithScripts -> Bool .
 *** a channel name matches a name
 *** if it is does not have indices and they are equal
 *** or it is a name with indices and the name without indices is equal to it
 eq matchesQid cn ns2 = qidOfName(cn) == ns2 .
 
 *** helper: replicate a name n times, and get a list of nat terms
  
 op replicate__ : Nat Qid -> List{NatTerm} .
 eq replicate 0 q = nil .
 eq replicate s(x) q = q (replicate x q) . 
 
endfm

fmod CNAME-BOUND is
 
 protecting CHANNEL-NAME .
 
 *** we need these to accomodate families
 
 sort CNameBound .
 op _@_ : ChannelName List{NatTerm} -> CNameBound [ctor] .

 var cn : ChannelName .


 *** embed a channel name to a bounded one, with no bounds 
 op toBound_ : ChannelName -> CNameBound .
 eq toBound cn = cn @ nil .
 
endfm

view CName from TRIV to CHANNEL-NAME is
 sort Elt to ChannelName .
endv

view CNameBound from TRIV to CNAME-BOUND is
 sort Elt to CNameBound .
endv

fmod CNAMEBOUND-SET is
 protecting SET{CNameBound} .
 protecting SET{BoolTerm} .
 pr BOOL-TERM-ENTAILS .
 
 
 *** custom membership test
 *** check whether the index is within bounds
 op isElemB : ChannelName Set{CNameBound} Set{BoolTerm} -> Bool .
 
 var q : NameWithScripts .
 var nt1 nt2 nt3 b1 b2 b3 : NatTerm .
 var S : Set{CNameBound} .
 var A : Set{BoolTerm} .
 
 eq isElemB(q, S, A) = q @ nil in S .
 
 eq isElemB(q[nt1], (S, q[nt1] @ nil ), A) = true .
 eq isElemB(q[nt1], (S, q @ b1 ), A) = A |= nt1 <T b1 with empty . 
 eq isElemB(q[nt1], S, A) = false [owise] .
 
 eq isElemB(q[nt1 nt2], (S, q[nt1 nt2] @ nil ), A) = true .
 eq isElemB(q[nt1 nt2], (S, q @ (b1 b2) ), A) = 
  A |= nt1 <T b1 with empty
  and
  A |= nt2 <T b2 with empty .
 eq isElemB(q[nt1 nt2], S, A) = false [owise] .
 
 eq isElemB(q[nt1 nt2 nt3], (S, q[nt1 nt2 nt3] @ nil ), A) = true .
 eq isElemB(q[nt1 nt2 nt3], (S, q @ (b1 b2 b3) ), A) = 
  A |= nt1 <T b1 with empty
  and
  A |= nt2 <T b2 with empty 
  and
  A |= nt3 <T b3 with empty .
 eq isElemB(q[nt1 nt2 nt3], S, A) = false [owise] .

endfm

fmod CHANNEL is
 protecting QID .
 protecting TYPES .
 protecting CNAMEBOUND-SET .
 
 *** typed bounded channel names
 
 sort TypedChannel .
 op _::_ : CNameBound Type -> TypedChannel [ctor format(b o r o)] .

 
 *** a channel context is a commutative list of them
 sort ChannelContext .
 subsort TypedChannel < ChannelContext .
 op emptyChannelCtx : -> ChannelContext [ctor].
 op __ : ChannelContext ChannelContext -> ChannelContext 
         [ctor assoc comm id: emptyChannelCtx format(d n d)] .

 vars ns ns1 ns2 : NameWithScripts .
 vars Q Q1 Q2 f : Qid .
 var T T1 T2 : Type .
 vars Delta1 Delta2 Delta : ChannelContext .
 var I : Set{CNameBound} .
 var A : Set{BoolTerm} .
 var cn cn1 cn2 : ChannelName .
 var nlist nlist1 nlist2 : List{NatTerm} .
 var nt nt1 nt2 nt3 nt' nt'' : NatTerm .
 var x y : Nat .
 var bn : CNameBound .
 var b b1 b2 b3 : NatTerm .
 
 *** this function checks whether a bounded name fits the context and the assumptions
 *** no type, we will use it for inputs/outputs
 op occurs___ : CNameBound ChannelContext Set{BoolTerm} -> Bool .
 eq occurs bn emptyChannelCtx A = false .
 
 eq occurs (ns @ nil) (((ns @ nil) :: T)  Delta) A = true .
 eq occurs (ns @ nil) Delta A = false [owise] .
  
 eq occurs (ns[nt] @ nil) (((ns[nt] @ nil) :: T) Delta) A = true .
 eq occurs (ns[nt] @ nil) (((ns @ b) :: T) Delta) A = A |= nt <T b with empty .
 eq occurs (ns[nt] @ nil) Delta A = false [owise] .
 
 eq occurs (ns[nt1 nt2] @ nil) (((ns[nt1 nt2] @ nil) :: T) Delta) A = true .
 eq occurs (ns[nt1 nt2] @ nil) (((ns @ (b1 f)) :: T) Delta) A = 
    A |= nt1 <T b1 with empty and 
    A |= nt2 <T fun f nt1 with empty .
 eq occurs (ns[nt1 nt2] @ nil) (((ns @ (b1 b2)) :: T) Delta) A = 
  A |= nt1 <T b1 with empty and 
  A |= nt2 <T b2 with empty [owise] .
 eq occurs (ns[nt1 nt2] @ nil) Delta A = false [owise] .
 
 eq occurs (ns[nt1 nt2 nt3] @ nil) (((ns[nt1 nt2 nt3] @ nil) :: T) Delta) A = true .
 eq occurs (ns[nt1 nt2 nt3] @ nil) (((ns @ (b1 b2 f)) :: T) Delta) A = 
  A |= nt1 <T b1 with empty and 
  A |= nt2 <T b2 with empty and
  A |= nt3 <T fun f nt2 with empty .
 eq occurs (ns[nt1 nt2 nt3] @ nil) (((ns @ (b1 b2 b3)) :: T) Delta) A = 
  A |= nt1 <T b1 with empty and 
  A |= nt2 <T b2 with empty and
  A |= nt3 <T b3 with empty [owise] .
 eq occurs (ns[nt1 nt2 nt3] @ nil) Delta A = false [owise] .

 eq occurs (ns @ nlist) (((ns @ nlist) :: T) Delta) A = true .
 ceq occurs (ns @ nt) ( (ns @ b :: T) Delta) A = true
     if A |= nt <T b with empty .
 ceq occurs (ns @ (nt1 nt2)) ( (ns @ (b1 b2) :: T) Delta) A = true
     if A |= nt1 <T b1 with empty /\ 
        A |= nt2 <T b2 with empty .
     
 eq occurs (ns @ nlist) Delta A = false [owise] .
  
 *** this is the typed version of elem, we will need it for Delta
 *** occurs checks for bounds, elem does not
 *** should we change?
 op elem____ : CNameBound Type ChannelContext Set{BoolTerm} -> Bool .
 eq elem (cn @ nlist) T emptyChannelCtx A = false .
 eq elem (ns[nt] @ nil) T (Delta ((ns[nt] @ nil) :: T)) A = true .
 eq elem (ns[nt] @ nil) T (((ns @ b) :: T) Delta) A = A |= nt <T b with empty .
 eq elem (ns[nt] @ nil) T Delta A = false [owise] .
 eq elem (ns[nt1 nt2] @ nil) T (Delta ((ns[nt1 nt2] @ nil) :: T)) A = true .
 eq elem (ns[nt1 nt2] @ nil) T (((ns @ (b1 b2)) :: T) Delta) A = true .
 eq elem (ns[nt1 nt2] @ nil) T Delta A = false [owise] .
 eq elem (ns[nt1 nt2 nt3] @ nil) T (Delta ((ns[nt1 nt2 nt3] @ nil) :: T)) A = true .
 eq elem (ns[nt1 nt2 nt3] @ nil) T (((ns @ (b1 b2 b3)) :: T) Delta) A = true .
 eq elem (ns[nt1 nt2 nt3] @ nil) T Delta A = false [owise] .
 eq elem (ns @ nlist) T (((ns @ nlist) :: T) Delta) A = true .
 eq elem (ns @ nlist) T Delta A = false [owise] .   
     
 op validChanSet___ : Set{CNameBound} ChannelContext Set{BoolTerm} -> Bool .
 eq validChanSet empty Delta A = true .
 ceq validChanSet (bn, I) Delta A = false if not occurs bn Delta A .
 ceq validChanSet (bn, I) Delta A = validChanSet I Delta A if occurs bn Delta A .
   
 op validChannelCtx__ : ChannelContext Set{BoolTerm} -> Bool .
 eq validChannelCtx emptyChannelCtx A = true .
 ceq validChannelCtx (((cn @ nlist) :: T1) Delta1) A = false 
     if occurs (cn @ nlist) Delta1 A .
 ceq validChannelCtx (((cn @ nlist) :: T1) Delta1) A = 
     validChannelCtx Delta1 A 
     if not occurs (cn @ nlist) Delta1 A .
     
 *** unsafe type lookup function!    
 op typeInCtx : CNameBound Set{BoolTerm} ChannelContext -> Type .
 eq typeInCtx(ns @ nil, A, Delta ((ns @ nil) :: T)) = T . 
 eq typeInCtx(ns[nt] @ nil, A, Delta ((ns[nt] @ nil) :: T)) = T .
 eq typeInCtx(ns[nt] @ nil, A, Delta ((ns @ b) :: T)) = T .
 eq typeInCtx(ns[nt1 nt2] @ nil, A, Delta ((ns[nt1 nt2] @ nil) :: T)) = T .
 eq typeInCtx(ns[nt1 nt2] @ nil, A, Delta ((ns @ (b1 b2)) :: T)) = T .
 eq typeInCtx(ns[nt1 nt2 nt3] @ nil, A, Delta ((ns[nt1 nt2 nt3] @ nil) :: T)) = T .
 eq typeInCtx(ns[nt1 nt2 nt3] @ nil, A, Delta ((ns @ (b1 b2 b3)) :: T)) = T .

 eq typeInCtx(ns @ nlist, A, Delta (ns @ nlist :: T)) = T .
 eq typeInCtx(ns @ nt1, A, Delta (ns @ nt2 :: T)) = T .
 eq typeInCtx(ns @ (nt1 nt2), A, Delta (ns @ (b1 b2) :: T)) = T .
 eq typeInCtx(ns @ (nt1 nt2 nt3), A, Delta (ns @ (b1 b2 b3) :: T)) = T .

endfm 

fmod REACTION is
 protecting EXPRESSION .
 protecting TYPES . 
 protecting DISTRIBUTION .
 protecting CHANNEL-NAME .
 protecting BOOL-TERM-ENTAILS .

 sort Reaction .

 sort ReadReaction . 
 op read_ : ChannelName -> ReadReaction [ctor] .
 
 sort BindReaction . 
 
 *** bind-read reactions appear on first component of normal forms
 sort BindReadReaction .
 subsort BindReadReaction < BindReaction .
 op _:_<-_ : Qid Type ReadReaction -> BindReadReaction [ctor] .
 op _<-_ : Qid ReadReaction -> BindReadReaction [ctor] . *** abbreviation notation
 op ~<-_ : ReadReaction -> BindReadReaction [ctor] . *** name not important 
 
 *** while these are in pre-normal forms
 sort UnrestrictedBindReaction . *** everything allowed
 subsort UnrestrictedBindReaction < BindReaction .
 op _:_<~_ : Qid Type Reaction -> UnrestrictedBindReaction [ctor] .
 
 sort BRList .
 subsort BindReadReaction < BRList .
 op emptyBRList : -> BRList [ctor] .
 op __ : BRList BRList -> BRList [ctor assoc comm id: emptyBRList] .
  
 sort BindList .
 subsort BindReaction < BindList .
 subsort BRList < BindList .
 op __ : BindList BindList -> BindList [ctor assoc comm id: emptyBRList] .
 
 
 var br : BindReaction .
 var bl : BindList .
 
 op size : BindList -> Nat .
 eq size(emptyBRList) = 0 .
 eq size(br bl) = 1 + size(bl) .
 
 sort BindFreeReaction .
 subsort ReadReaction < BindFreeReaction .
 op return_ : Expression -> BindFreeReaction [ctor] .
 op samp_ : Distribution -> BindFreeReaction [ctor] .
 op if_then_else_ : Expression BindFreeReaction BindFreeReaction -> BindFreeReaction [ctor] .
  
 *** list of names, for orders in normal forms 
 sort CNameList . 
 op emptyCNameList : -> CNameList [ctor] .
 op _::_ : ChannelName CNameList -> CNameList [ctor] .
 
 *** helpers: operations on lists
 vars ql ql' : CNameList .
 var q q' x y : ChannelName .
 
 op reverse_ : CNameList -> CNameList .
 eq reverse ql = revAux emptyCNameList ql .
 
 op revAux__ : CNameList CNameList -> CNameList .
 eq revAux ql emptyCNameList = ql .
 eq revAux ql (q :: ql') = revAux (q :: ql) ql' .
 
 op _++_ : CNameList CNameList -> CNameList .
 eq emptyCNameList ++ ql = ql .
 eq (q :: ql') ++ ql = q :: (ql' ++ ql) .
 
 op replace___ : ChannelName ChannelName CNameList -> CNameList .
 eq replace q q' emptyCNameList = emptyCNameList .
 eq replace q q' (x :: ql) = if x == q then q' :: ql
                                       else x :: (replace q q' ql) fi . 
 
 op del__ : ChannelName CNameList -> CNameList .
 eq del q ql = delAux q ql emptyCNameList .
 
 op delAux___ : ChannelName CNameList CNameList -> CNameList .
 eq delAux q emptyCNameList ql' = reverse ql' .
 eq delAux q (q :: ql) ql' = (reverse ql') ++ ql .
 eq delAux q (q' :: ql) ql' = delAux q ql (q' :: ql') [owise] .
 
 op addBefore___ : ChannelName ChannelName CNameList -> CNameList .
 eq addBefore x y emptyCNameList = x :: emptyCNameList .
 eq addBefore x y (y :: ql) = x :: y :: ql .
 eq addBefore x y (q :: ql) = q :: (addBefore x y ql) [owise] .
 
 op addListBefore___ : CNameList ChannelName CNameList -> CNameList .
 eq addListBefore emptyCNameList y ql = ql .
 eq addListBefore (x :: ql) y ql' = addListBefore ql y (addBefore x y ql') .
 
 sort NFReaction .
 op nf : BRList BindFreeReaction CNameList -> NFReaction [ctor] .
 
 sort PreNFReaction .
 op preNF : BindList Reaction CNameList -> PreNFReaction [ctor] .


 subsort ReadReaction < Reaction .
 *** subsort BindReaction < Reaction .
 subsort BindFreeReaction < Reaction .
 subsort NFReaction < Reaction .
 subsort PreNFReaction < Reaction .
 subsort UnrestrictedBindReaction < Reaction .
 op if_then_else_ : Expression Reaction Reaction -> Reaction [ctor] . 
 op _:_<-_;_ : Qid Type Reaction Reaction -> Reaction [ctor] .
 op _<-_;_ : Qid Reaction Reaction -> Reaction [ctor] . *** abbreviation notation
     
 vars M M1 M2 V : Expression .
 var c : ChannelName .
 var w f d i : Qid .
 vars R R1 R2 : Reaction .
 var T : Type .
 var n : Nat .
 var QL : CNameList .
 var BL : BRList .
 var D : Distribution .
 
 *** change representation, from normal form to core reaction
 op convertNF : NFReaction -> Reaction .
 eq convertNF(nf(emptyBRList, R, emptyCNameList)) = R .
 eq convertNF(nf((i : T <- R1 ) BL, R2, i :: QL)) = 
     i : T <- R1 ; convertNF(nf(BL, R2, QL)) .
 
 *** check recursively whether samp occurs
 op isSampFree : Reaction -> Bool .
 eq isSampFree(return M) = true .
 eq isSampFree(samp D) = false .
 eq isSampFree(read c) = true .
 eq isSampFree(if M then R1 else R2) = isSampFree(R1) and isSampFree(R2) .
 eq isSampFree(x : T <- R1 ; R2) = isSampFree(R1) and isSampFree(R2) .
 eq isSampFree(nf(BL, R, QL)) = isSampFree(R) .
 
 *** subst a variable with am expression in a reaction
 op _[_/_] : Reaction Qid Expression -> Reaction . 
 eq (return M) [w / V] = return (M [w := V]) .
 eq (samp (d < M >)) [w / V] = samp (d < M [w := V] >) .
 eq (read c) [w / V] = read c .
 eq (if M then R1 else R2) [w / V] = if M [w := V] then (R1 [w / V]) else (R2 [w / V]) .
 eq (x : T <- R1 ; R2) [w / V] = x : T <- (R1 [w / V]) ; (R2 [w / V]) .
 eq (nf(BL, R, QL)) [w / V] = nf(BL, R [w / V], QL) .
 eq (preNF(BL, R, QL)) [w / V] = preNF(BL, R [w / V], QL) . *** subst in BL too?
 
 *** subst a var with an expression in an expression
 op _[_:=_] : Expression Qid Expression -> Expression .

 eq w [w := V] = V . 
 eq ()[w := V] = () . ***TODO: this should be caught by next eq, since () =/= w is true.
 ceq x [w := V] = x if x =/= w .
 eq True [w := V] = True .
 eq False [w := V] = False .
 eq (ap f M) [w := V] = ap f (M [w := V]) .
 eq (pair(M1, M2)) [w := V] = pair(M1 [w := V] , M2 [w := V]) .
 eq (fst M) [w := V] = fst (M [w := V]) .
 eq (snd M) [w := V] = snd (M [w := V]) .
 
 var lq : List{NatTerm} .
 var val : Map{Qid,NatTerm} .
 
 vars nt1 nt2 : NatTerm .
 var m : Nat .
 var ns : NameWithScripts .
 
 *** evaluate the vars in a channel name
 *** by a valuation map
 op evalCName__ : ChannelName Map{Qid,NatTerm} -> ChannelName .
 eq evalCName (ns [ lq ]) val = ns [ evalList(lq, val) ] .
 eq evalCName ns val = ns .
 
 *** same for lists of nat terms
 op evalList : List{NatTerm} Map{Qid,NatTerm} -> List{NatTerm} .
 eq evalList(nil, val) = nil .
 eq evalList(nt1 lq, val) = (eval(nt1, val)) (evalList(lq, val)) . 
 
 *** and for nat terms
 op eval : NatTerm Map{Qid,NatTerm} -> NatTerm .
 eq eval(n, val) = n .
 eq eval(fun i nt1, val) = fun i eval(nt1, val) .
 eq eval(x, val) = if val[x] == undefined then x else val[x] fi . *** eval with default
 ceq eval(nt1 ++ nt2, val) = eval(nt1, val) + eval(nt2, val) 
  if eval(nt1, val) :: Nat /\ eval(nt2, val) :: Nat .
 eq eval(nt1 ++ nt2, val) = eval(nt1, val) ++ eval(nt2, val) [owise] . 
 ceq eval(nt1 -- nt2, val) = diff(eval(nt1, val), eval(nt2, val)) 
   if eval(nt1, val) :: Nat /\ eval(nt2, val) :: Nat .
 eq eval(nt1 -- nt2, val) = eval(nt1, val) -- eval(nt2, val) [owise] .  
  
 *** replace vars in a reaction using a valuation
 op replaceVars : Reaction Map{Qid,NatTerm}  -> Reaction .
 eq replaceVars(return M, val) = return M .
 *** eq replaceVars(samp flip, val) = samp flip .
 eq replaceVars(samp (d < M >), val) = samp (d < M >) .
 eq replaceVars(read c, val) = read (evalCName c val) . 
 eq replaceVars(if M then R1 else R2, val) = 
      if M then replaceVars(R1, val) else replaceVars(R2, val) .
 eq replaceVars(x : T <- R1 ; R2, val) = 
      x : T <- replaceVars(R1, val); replaceVars(R2, val) .
 eq replaceVars(nf(BL, R, ql), val) = nf(replaceVarsB(BL, val), replaceVars(R, val), ql) .
 
 var brr : BindReadReaction .
 
 *** same for bind list
 op replaceVarsB : BindList Map{Qid, NatTerm} -> Reaction .
 eq replaceVarsB(x : T <- R, val) = x : T <- replaceVars(R, val) .
 eq replaceVarsB(x : T <~ R, val) = x : T <~ replaceVars(R, val) .
 eq replaceVarsB(brr BL, val) = replaceVarsB(brr, val) replaceVarsB(BL, val) .
 eq replaceVarsB(emptyBRList, val) = emptyBRList .    
      
endfm

fmod REACTION-TYPING is
 protecting REACTION .
 protecting CHANNEL .
 protecting EXPRESSION-TYPING .
 protecting DISTRIBUTION-TYPING .
 protecting CNAMEBOUND-SET .
 
 
 *** the type of a reaction in the context given by
 *** a signature, a channel context, a variable context
 *** a set of inputs and a set of index assumptions
 op typeOf : Signature ChannelContext TypeContext 
             Set{CNameBound} Set{BoolTerm} Reaction -> Type .

 var Sigma : Signature .
 var Gamma : TypeContext .
 var Delta : ChannelContext .
 vars R R1 R2 R3 : Reaction .
 vars T T1 T2 T3 : Type .
 var M M1 M2 : Expression .
 var I : Set{CNameBound} . 
 var d i x q f : Qid .
 var ns : NameWithScripts .
 var c : ChannelName .
 var D : Distribution .
 var QL : CNameList .
 var BRL : BRList .
 var BL : BindList .
 var nlist nlist' : List{NatTerm} .
 var nt b nt1 nt2 nt3 b1 b2 b3 : NatTerm .
 var n : Nat .
 var A : Set{BoolTerm} .
 
 *** a bind-read list is valid for a context 
 *** if the context contains the channels that are being read from
 *** with the right type
 op validForCtx : BRList ChannelContext Set{BoolTerm} -> Bool .
 eq validForCtx(emptyBRList, Delta, A) = true .
 
 eq validForCtx((x : T <- read ns) BRL, Delta (ns @ nil :: T), A) = 
    validForCtx(BRL, Delta, A) .
 
 eq validForCtx((x : T <- read (ns[nt])) BRL, Delta (ns[nt] @ nil :: T), A) =
    validForCtx(BRL, Delta, A) .
 ceq validForCtx((x : T <- read (ns[nt])) BRL, Delta (ns @ b :: T), A) = 
     validForCtx(BRL, Delta (ns @ b :: T), A) *** if ns is a family, read more than once
     if A |= (nt <T b) with empty .
 
  eq validForCtx((x : T <- read (ns[nt1 nt2])) BRL, Delta (ns[nt1 nt2] @ nil :: T), A) = 
     validForCtx(BRL, Delta, A) .
 ceq validForCtx((x : T <- read (ns[nt1 nt2])) BRL, Delta (ns @ (b1 f) :: T), A) = 
     validForCtx(BRL, Delta (ns @ (b1 f) :: T), A)
     if A |= (nt1 <T b1 ) with empty  and A |= (nt2 <T fun f nt1) with empty .
 ceq validForCtx((x : T <- read (ns[nt1 nt2])) BRL, Delta (ns @ (b1 b2) :: T), A) = 
     validForCtx(BRL, Delta (ns @ (b1 b2) :: T), A)
     if A |= (nt1 <T b1 ) with empty  and A |= (nt2 <T b2) with empty .
  
  eq validForCtx((x : T <- read (ns[nt1 nt2 nt3])) BRL, Delta (ns[nt1 nt2 nt3] @ nil :: T), A) = 
     validForCtx(BRL, Delta, A) .
  ceq validForCtx((x : T <- read (ns[nt1 nt2 nt3])) BRL, Delta (ns @ (b1 b2 f) :: T), A) = 
     validForCtx(BRL, Delta (ns @ (b1 b2 f) :: T), A)
     if  A |= (nt1 <T b1) with empty  
     and A |= (nt2 <T b2) with empty  
     and A |= (nt3 <T fun f nt2) with empty .   
  ceq validForCtx((x : T <- read (ns[nt1 nt2 nt3])) BRL, Delta (ns @ (b1 b2 b3) :: T), A) = 
     validForCtx(BRL, Delta (ns @ (b1 b2 b3) :: T), A)
     if  A |= (nt1 <T b1) with empty  
     and A |= (nt2 <T b2) with empty  
     and A |= (nt3 <T b3) with empty .   
     
  
  eq validForCtx(BRL, Delta, A) = false [owise] .

 *** extend a var context with the vars in a bind list
 op addDeclarations__ : BindList TypeContext -> TypeContext .
 eq addDeclarations emptyBRList Gamma = Gamma .
 eq addDeclarations ((x : T <- R) BL) Gamma = addDeclarations BL (Gamma (x : T)) .
 eq addDeclarations ((x : T <~ R) BL) Gamma = addDeclarations BL (Gamma (x : T)) .

 eq typeOf(Sigma, Delta, Gamma, I, A, return M) = typeOf(Sigma, Gamma, M) .
 eq typeOf(Sigma, Delta, Gamma, I, A, samp D) = typeOf(Sigma, Gamma, D) .
 ceq typeOf(Sigma, Delta (ns @ nil :: T), Gamma, I, A, read ns) = T if isElemB(ns, I, A) .
 ceq typeOf(Sigma, Delta ((ns[nlist] @ nil) :: T), Gamma, I, A, read (ns[nlist])) = T 
     if isElemB(ns[nlist], I, A) .
 ceq typeOf(Sigma, Delta ((ns @ nlist') :: T), Gamma, I, A, read (ns[nlist])) = T 
     if isElemB(ns[nlist], I, A) .            
 
 ceq typeOf(Sigma, Delta, Gamma, I, A, if M then R1 else R2) = 
     typeOf(Sigma, Delta, Gamma, I, A, R1)
     if typeOf(Sigma, Gamma, M) == bool
     /\ typeOf(Sigma, Delta, Gamma, I, A, R1) == typeOf(Sigma, Delta, Gamma, I, A, R2) .
 ceq typeOf(Sigma, Delta, Gamma, I, A, x : T1 <- R1 ; R2) = 
     typeOf(Sigma, Delta, Gamma (x : T1), I, A, R2)
     if typeOf(Sigma, Delta, Gamma, I, A, R1) == T1 .
 ceq typeOf(Sigma, Delta, Gamma, I, A, nf(BRL, R, QL)) = 
       typeOf(Sigma, Delta, addDeclarations BRL Gamma, I, A, R) 
     if validForCtx(BRL, Delta, A) .
 eq typeOf(Sigma, Delta, Gamma, I, A, preNF(BL, R, QL)) =
       typeOf(Sigma, Delta, addDeclarations BL Gamma, I, A, R) .    

endfm

mod REACTION-EQUALITY is
 protecting EXPRESSION-TYPING .
 protecting EXPRESSION-EQUALITY .
 protecting REACTION-TYPING .

 *** two reactions R1 R2 are equal w.r.t. Sigma, Delta, Gamma, I, A, T
 *** if 
 *** rConfig(Sigma, Delta, Gamma, R1, I, A, T)
 ***  =>
 *** rConfig(Sigma, Delta, Gamma, R2, I, A, T)

 sort ReactionConfig . 
  
 op rConfig : Signature ChannelContext TypeContext Reaction Set{CNameBound} Set{BoolTerm} Type 
                     -> ReactionConfig [ctor] .

 var A : Set{BoolTerm} .
 var Sigma : Signature .
 var Gamma Gamma' : TypeContext .
 var Delta : ChannelContext .
 vars R R1 R2 R3 R4 S S1 S2 S3 S4 : Reaction .
 vars T T1 T2 T3 : Type .
 var M M1 M2 : Expression .
 var I I' : Set{CNameBound} . 
 var x x1 x2 y b z c : ChannelName .
 var i o1 o2 : ChannelName .
 var D D' : Distribution .
 var QL QL' : CNameList .
 var BL : BindList .
 var BRL : BRList .
 var n : Nat .
 
 var q : Qid .
 var ns : NameWithScripts .
 
 sort CNameTuple .
 op mkTuple : ChannelName ChannelName CNameList -> CNameTuple [ctor] .
  
 op keepFirstAux____ : ChannelName ChannelName CNameList CNameList -> CNameTuple .
 eq keepFirstAux x y emptyCNameList QL' = mkTuple(x, y, emptyCNameList) .
 ceq keepFirstAux x y (z :: QL) QL' = mkTuple(x, y, (reverse QL') ++ (del y (z :: QL))) 
       if x == z .
 ceq keepFirstAux x y (z :: QL) QL' = mkTuple(y, x, (reverse QL') ++ (del x (z :: QL))) 
       if y == z .  
 eq keepFirstAux x y (z :: QL) QL' = keepFirstAux x y QL (z :: QL') [owise] .     
           
 op keepFirst : ChannelName ChannelName CNameList -> CNameTuple .
 eq keepFirst(x, y, QL) = keepFirstAux x y QL emptyCNameList .

 *** deal with abbreviations
 rl [expand-type-bind] :
    rConfig(Sigma, Delta, Gamma, x <- R1 ; R2, I, A, T)
    =>
    rConfig(Sigma, Delta, Gamma, x : typeOf(Sigma, Delta, Gamma, I, A, R1) <- R1 ; R2, I, A, T)
 .   
 
 rl [expand-type-nf] :
    rConfig(Sigma, Delta, Gamma, nf((x <- read c) BRL, R, QL), I, A, T)
    => 
    rConfig(Sigma, Delta, Gamma, 
             nf((x : typeOf(Sigma, Delta, Gamma, I, A, read c) <- read c) BRL, R, QL), 
            I, A, T)
 .   

 *** core rules

 crl [sym] : rConfig(Sigma, Delta, Gamma, R2, I, A, T) 
             => 
             rConfig(Sigma, Delta, Gamma, R1, I, A, T)
     if rConfig(Sigma, Delta, Gamma, R1, I, A, T) 
        =>
        rConfig(Sigma, Delta, Gamma, R2, I, A, T) [nonexec] .
 
 *** refl and trans are properties of => anyways.

 crl [cong-branch] : 
     rConfig(Sigma, Delta, Gamma, if M1 then R1 else R2, I, A, T)
     => 
     rConfig(Sigma, Delta, Gamma, if M2 then R3 else R4, I, A, T)
     if
     rConfig(Sigma, Delta, Gamma, R1, I, A, T) => 
     rConfig(Sigma, Delta, Gamma, R3, I, A, T)
     /\
     rConfig(Sigma, Delta, Gamma, R2, I, A, T) => 
     rConfig(Sigma, Delta, Gamma, R4, I, A, T) 
     /\
     M1 == M2 [nonexec] .
                  
          
 crl [cong-bind] :
     rConfig(Sigma, Delta, Gamma, x : T1 <- R1 ; R2, I , A, T2) 
     => 
     rConfig(Sigma, Delta, Gamma, x : T1 <- R3 ; R4, I, A, T2) 
     if
     rConfig(Sigma, Delta, Gamma, R1, I, A, T1)  
     => 
     rConfig(Sigma, Delta, Gamma, R3, I, A, T1) 
     /\
     rConfig(Sigma, Delta, Gamma (x : T1), R2, I, A, T2)
     => 
     rConfig(Sigma, Delta, Gamma (x : T1), R4, I, A, T2) .
     *** /\ ((R1 =/= R3) or (R2 =/= R4)) .

 crl [samp-pure] : 
     rConfig(Sigma, Delta, Gamma, x : T1 <- samp D ; R, I, A, T2)
     => 
     rConfig(Sigma, Delta, Gamma, R, I, A, T2)
 if typeOf(Sigma, Gamma, D) == T1 /\ typeOf(Sigma, Delta, Gamma, I, A, R) == T2 
 . 

 crl [read-det] : 
     rConfig(Sigma, Delta, Gamma, 
                    x : T1 <- read i ; y : T1 <- read i ; R , I, A, T2) 
     => 
     rConfig(Sigma, Delta, Gamma, 
                    x : T1 <- read i ; (R [y / x]), I, A, T2)
 if  isElemB(i, I, A)  /\ elem (toBound i) T1 Delta A
 /\  typeOf(Sigma, Delta, Gamma (x : T1) (y : T1), I, A, R) == T2 
 .
                             
 crl [if-left] : 
     rConfig(Sigma, Delta, Gamma, if True then R1 else R2, I, A, T) 
     =>  
     rConfig(Sigma, Delta, Gamma, R1, I, A, T)
 if
     typeOf(Sigma, Delta, Gamma, I, A, R1) == T
     /\
     typeOf(Sigma, Delta, Gamma, I, A, R2) == T 
 .

 crl [if-right] : 
     rConfig(Sigma, Delta, Gamma, if False then R1 else R2, I, A, T) 
     =>  
     rConfig(Sigma, Delta, Gamma, R2, I, A, T)
 if
     typeOf(Sigma, Delta, Gamma, I, A, R1) == T 
     /\
     typeOf(Sigma, Delta, Gamma, I, A, R2) ==  T 
 . 

***( this rule can't be applied by Maude so we replaced it with derived rules
  crl [if-ext] : 
     rConfig(Sigma, Delta, Gamma, R [b / M], I, T)
     => 
     rConfig(Sigma, Delta, Gamma, if M then (R [b / True]) else (R [b / False]), I, T)
     if
     typeOf(Sigma, Gamma, M) == bool
     /\
     typeOf(Sigma, Delta, Gamma (b : bool), I, R) == T . 
)

   *** what we can write is the version where M is a variable

   rl [if-intro-ext] :
     rConfig(Sigma, Delta, Gamma (q : bool), R, I, A, T) 
     => 
     rConfig(Sigma, Delta, Gamma (q : bool),
             if q then (R[q / True]) else (R[q / False]), I, A, T)          
  .           

 crl [ret-bind] : 
     rConfig(Sigma, Delta, Gamma, x : T1 <- return M ; R , I , A, T2) 
     => 
     rConfig(Sigma, Delta, Gamma, R [x / M], I, A, T2) 
     if
     typeOf(Sigma, Gamma, M) == T1
     /\
     typeOf(Sigma, Delta, Gamma (x : T1), I, A, R) == T2 .
     
      
 crl [ret-bind-2] :
     rConfig(Sigma, Delta, Gamma, R, I, A, T2) 
     =>
     rConfig(Sigma, Delta, Gamma, x : T1 <- return M1 ; R2, I, A, T2)
     if  
     typeOf(Sigma, Gamma, M1) == T1  /\
     typeOf(Sigma, Delta, Gamma, I, A, R) == T2 /\
     typeOf(Sigma, Delta, Gamma (x : T1), I, A, R2) == T2 /\
     R == R2[x / M1] [nonexec] .

 crl [bind-ret] : 
     rConfig(Sigma, Delta, Gamma, x : T <- R ; return x, I , A, T) 
     => 
     rConfig(Sigma, Delta, Gamma, R, I, A, T)
     if 
     typeOf(Sigma, Delta, Gamma, I, A, R) == T . 

 crl [bind-ret-2] : 
     rConfig(Sigma, Delta, Gamma, R, I, A, T) 
     => 
     rConfig(Sigma, Delta, Gamma, x : T <- R ; return x, I, A, T)
     if 
     typeOf(Sigma, Delta, Gamma, I, A, R) == T [nonexec] .

 crl [bind-bind] : 
     rConfig(Sigma, Delta, Gamma, x2 : T2 <- (x1 : T1 <- R1 ; R2) ; R3, I, A, T3)
     => 
     rConfig(Sigma, Delta, Gamma, x1 : T1 <- R1 ; (x2 : T2 <- R2 ; R3), I, A, T3)
 if
     typeOf(Sigma, Delta, Gamma, I, A, R1) == T1
     /\
     typeOf(Sigma, Delta, Gamma (x1 : T1), I, A, R2) == T2
     /\ 
     typeOf(Sigma, Delta, Gamma (x2 : T2), I, A, R3) == T3 
 .              

 crl [exchange] : 
     rConfig(Sigma, Delta, Gamma, x1 : T1 <- R1 ; x2 : T2 <- R2 ; R, I, A, T3)
     => 
     rConfig(Sigma, Delta, Gamma, x2 : T2 <- R2 ; x1 : T1 <- R1 ; R, I, A, T3)
 if
     typeOf(Sigma, Delta, Gamma, I, A, R1) == T1
     /\
     typeOf(Sigma, Delta, Gamma, I, A, R2) == T2
     /\
     typeOf(Sigma, Delta, Gamma (x1 : T1) (x2 : T2), I, A, R) == T3 
 .
 
 *** rules for normal forms: 
 
 
 crl [cong-pre-nf] :
     rConfig(Sigma, Delta, Gamma, preNF(BL , R1 , QL), I, A, T)
     => 
     rConfig(Sigma, Delta, Gamma, preNF(BL , R2 , QL), I, A, T)
     if 
     rConfig(Sigma, Delta, addDeclarations BL Gamma, R1, I, A, T) 
     => 
     rConfig(Sigma, Delta, Gamma', R2, I, A, T) 
     /\
     Gamma' == addDeclarations BL Gamma [nonexec] .
     
  crl [cong-nf] :
     rConfig(Sigma, Delta, Gamma, nf(BL , R1 , QL), I, A, T)
     => 
     rConfig(Sigma, Delta, Gamma, nf(BL , R2 , QL), I, A, T)
     if 
     rConfig(Sigma, Delta, addDeclarations BL Gamma, R1, I, A, T) 
     => 
     rConfig(Sigma, Delta, Gamma', R2, I, A, T) 
     *** /\  Gamma' == addDeclarations BL Gamma 
     [nonexec] . 
     
 crl [read-det-pre] :
     rConfig(Sigma, Delta, Gamma, 
               preNF( (x : T1 <- read i) (y : T1 <- read i) BL , R , QL), I, A, T2) 
     =>
     rConfig(Sigma, Delta, Gamma, 
               preNF( (x : T1 <- read i) BL , R [y / x] , del y QL), I, A, T2) 
 if *** isElemB(i, I, A)  /\ 
    *** elem (toBound i) T1 Delta A /\
    typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1) (y : T1)), I, A, R) == T2        
 .
 
  crl [read-det-nf] :
     rConfig(Sigma, Delta, Gamma, 
               nf( (x : T1 <- read i) (y : T1 <- read i) BL , R , QL), I, A, T2) 
     =>
     rConfig(Sigma, Delta, Gamma, 
               nf( (x : T1 <- read i) BL , R [y / x] , del y QL), I, A, T2) 
 if *** isElemB(i, I, A)  /\ 
    *** elem (toBound i) T1 Delta A /\
    typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1) (y : T1)), I, A, R) == T2        
 .
                
 crl [bind-ret-2-pre] : 
     rConfig(Sigma, Delta, Gamma, 
               preNF( (x : T1 <~ R1) BL , return x , QL), I, A, T1) 
     =>
     rConfig(Sigma, Delta, Gamma, 
               preNF( BL , R1 , del x QL), I, A, T1) 
 if typeOf(Sigma, Delta, addDeclarations BL Gamma, I, A, R1) == T1 
  .         
     
 crl [read2Binds] : 
    rConfig(Sigma, Delta, Gamma, preNF(BL (x : T1 <~ read i), R , QL), I, A, T) 
    =>
    rConfig(Sigma, Delta, Gamma, preNF(BL (x : T1 <- read i), R , QL), I, A, T) 
    if isElemB(i, I, A) and elem (toBound i) T1 Delta A 
 .
    
 crl [pre2Nf] : preNF(BRL, R, QL) => nf(BRL, R, QL) if R : BindFreeReaction .
 
 rl [nf2Pre] : nf(BL, R, QL) => preNF(BL, R, QL) .
      
 crl [merge-pre] :
     rConfig(Sigma, Delta, Gamma, preNF(BL (x : T1 <~ R1) , R2 , QL), I, A, T2)
     =>
     rConfig(Sigma, Delta, Gamma, preNF(BL , x : T1 <- R1 ; R2 , del x QL), I, A, T2) 
   if typeOf(Sigma, Delta, addDeclarations BL Gamma, I, A, R1) == T1
     /\ typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1)), I, A, R2) == T2
 .
    
 crl [bind2R-nf] :   
 rConfig(Sigma, Delta, Gamma, nf(BRL (x : T1 <- R1) , R2 , QL), I, A, T2)
     =>
     rConfig(Sigma, Delta, Gamma, preNF(BRL , x : T1 <- R1 ; R2 , del x QL), I, A, T2) 
 if typeOf(Sigma, Delta, addDeclarations BRL Gamma, I, A, R1) == T1
 /\ typeOf(Sigma, Delta, addDeclarations BRL (Gamma (x : T1)), I, A, R2) == T2 
     .
    
 crl [bind2R-pre] :
     rConfig(Sigma, Delta, Gamma, preNF(BL (x : T1 <- R1) , R2 , QL), I, A, T2)
     =>
     rConfig(Sigma, Delta, Gamma, preNF(BL , x : T1 <- R1 ; R2 , del x QL), I, A, T2) 
 if typeOf(Sigma, Delta, addDeclarations BL Gamma, I, A, R1) == T1
 /\ typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1)), I, A, R2) == T2 
     .
  
 crl [bind2R-pre-reverse] :
     rConfig(Sigma, Delta, Gamma, 
             preNF(BL , x : T1 <- read i ; R2 , QL), 
             I, A, T2)
     =>
     rConfig(Sigma, Delta, Gamma, 
             preNF(BL (x : T1 <- read i) , R2 , x :: QL),
             I, A, T2) 
 if 
 isElemB(i, I, A)  /\ elem (toBound i) T1 Delta A /\
 typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1)), I, A, R2) == T2
 .  
 
 crl [ret-bind-pre] :
     rConfig(Sigma, Delta, Gamma, preNF((x : T1 <~ return M) BL, R , QL), I, A, T2) 
     =>
     rConfig(Sigma, Delta, Gamma, preNF(BL, R [x / M] , del x QL), I, A, T2) 
 if
     typeOf(Sigma, Gamma, M) == T1 
     /\  typeOf(Sigma, Delta, addDeclarations BL (Gamma (x : T1)), I, A, R) == T2 
 .   
     *** could be a nf already, but the strategy tries to take care of this 

 
 crl [bind-bind-pre] :
     rConfig(Sigma, Delta, Gamma, 
              preNF((x2 : T2 <~ nf(BRL, R2, QL')) BL, R1, QL), I, A, T1)
     =>  
     rConfig(Sigma, Delta, Gamma, 
              preNF(BRL (x2 : T2 <~ R2) BL, 
                    R1, addListBefore QL' x2 QL), I, A, T1) 
 if  
     typeOf(Sigma, Delta, 
            addDeclarations BRL (addDeclarations BL Gamma), I, A, R2) == T2
     /\          
     typeOf(Sigma, Delta, 
            addDeclarations BL (Gamma (x2 : T2)), I, A, R1) == T1
 .  
 
  crl [bind-bind-pre-pre] :
     rConfig(Sigma, Delta, Gamma, 
              preNF((x2 : T2 <~ preNF(BRL, R2, QL')) BL, R1, QL), I, A, T1)
     =>  
     rConfig(Sigma, Delta, Gamma, 
              preNF(BRL (x2 : T2 <~ R2) BL, 
                    R1, addListBefore QL' x2 QL), I, A, T1) 
 if  
     typeOf(Sigma, Delta, 
            addDeclarations BRL (addDeclarations BL Gamma), I, A, R2) == T2
     /\          
     typeOf(Sigma, Delta, 
            addDeclarations BL (Gamma (x2 : T2)), I, A, R1) == T1
 . 
            
 *** derived rules:
  
  rl [change-order] :
     rConfig(Sigma, Delta, Gamma, nf(BRL, R, QL), I, A, T)
     =>
     rConfig(Sigma, Delta, Gamma, nf(BRL, R, QL'), I, A, T) 
     [nonexec] . 
     *** TODO: check that QL' has same vars as QL?
     
    rl [change-order-pre] :
     rConfig(Sigma, Delta, Gamma, preNF(BRL, R, QL), I, A, T)
     =>
     rConfig(Sigma, Delta, Gamma, preNF(BRL, R, QL'), I, A, T) 
     [nonexec] . 
     *** TODO: check that QL' has same vars as QL?   

 
  crl [same-reaction-if] : 
     rConfig(Sigma, Delta, Gamma, if M then R else R, I, A, T)
     => 
     rConfig(Sigma, Delta, Gamma, R, I, A, T) 
  if typeOf(Sigma, Delta, Gamma, I, A, R) == T  
  /\ typeOf(Sigma, Gamma, M) == bool 
  . *** could we prove this without if-ext? 
 
  crl [cong-branch-refl] : 
     rConfig(Sigma, Delta, Gamma, if M then R1 else R2, I, A, T)
     => 
     rConfig(Sigma, Delta, Gamma, if M then R3 else R4, I, A, T)
     if
     typeOf(Sigma, Gamma, M) == bool 
     /\
     rConfig(Sigma, Delta, Gamma, R1, I, A, T) => 
     rConfig(Sigma, Delta, Gamma, R3, I, A, T)
     /\
     rConfig(Sigma, Delta, Gamma, R2, I, A, T) => 
     rConfig(Sigma, Delta, Gamma, R4, I, A, T) . 
      
 crl [read-inside-if] : 
    rConfig(Sigma, Delta, Gamma, x : T1 <- read i ; if M then R1 else R2, I, A, T) 
    => 
    rConfig(Sigma, Delta, Gamma, 
             if M then x : T1 <- read i ; R1 
                  else x : T1 <- read i ; R2, I, A, T) 
    if isElemB(i, I, A)  /\ elem (toBound i) T1 Delta A .
   
 crl [read-outside-if] : 
    rConfig(Sigma, Delta, Gamma, if M then x : T1 <- read i ; R1 
                                      else x : T1 <- read i ; R2
            , I, A, T) 
    => 
    rConfig(Sigma, Delta, Gamma, 
             x : T1 <- read i ; if M then R1 else R2, I, A, T) 
    if isElemB(i, I, A)  /\ elem (toBound i) T1 Delta A
    .
                    
 rl [if-over-bind-same-2] :
     rConfig(Sigma, Delta, Gamma, x : T1 <- if M1 
                                             then if M2 then R1 else R2
                                             else if M2 then R3 else R4 ;
                                  if M1 
                                     then if M2 then S1 else S2
                                     else if M2 then S3 else S4,
                                 I, A, T)
    => 
    rConfig(Sigma, Delta, Gamma, if M1 
                                    then if M2 then (x : T1 <- R1 ; S1) 
                                               else (x : T1 <- R2 ; S2)
                                    else if M2 then (x : T1 <- R3 ; S3) 
                                               else (x : T1 <- R4 ; S4),          
                                 I, A, T) .                             
           
 crl [if-over-bind-same] :
    rConfig(Sigma, Delta, Gamma, x : T1 <- if M then R1 else R2 ; 
                                 if M then R3 else R4, I, A, T)
    =>
    rConfig(Sigma, Delta, Gamma, if M then x : T1 <- R1 ; R3 else x : T1 <- R2 ; R4 , 
                                 I, A, T)                   
 if typeOf(Sigma, Delta, Gamma, I, A, R1) == T1  /\
       typeOf(Sigma, Delta, Gamma, I, A, R2) == T1  /\
       typeOf(Sigma, Delta, Gamma (x : T1), I, A, R3) == T /\
       typeOf(Sigma, Delta, Gamma (x : T1), I, A, R4) == T /\
       typeOf(Sigma, Gamma, M) == bool 
 .
 
 crl [if-over-bind] : 
    rConfig(Sigma, Delta, Gamma, x : T1 <- if M then R1 else R2 ; R , I, A, T) 
    =>
    rConfig(Sigma, Delta, Gamma, if M then x : T1 <- R1 ; R else x : T1 <- R2 ; R , 
            I, A, T) 
 if typeOf(Sigma, Delta, Gamma, I, A, R1) == T1  /\
       typeOf(Sigma, Delta, Gamma, I, A, R2) == T1  /\
       typeOf(Sigma, Delta, Gamma (x : T1), I, A, R) == T /\
       typeOf(Sigma, Gamma, M) == bool
   .
      
 crl [if-over-read] : 
     rConfig(Sigma, Delta, Gamma, if M then x : T1 <- R1 ; R else x : T1 <- R1 ; S, I, A, T)
     =>        
     rConfig(Sigma, Delta, Gamma, x : T1 <- R1 ; if M then R else S, I, A, T)
 if
     typeOf(Sigma, Delta, Gamma, I, A, R1) == T1 /\
     typeOf(Sigma, Delta, Gamma (x : T1), I, A, R) == T /\
     typeOf(Sigma, Delta, Gamma (x : T1), I, A, S) == T /\
     typeOf(Sigma, Gamma, M) == bool 
 .
 
 var vx vy : Qid . 
        
 crl [alpha] :
     rConfig(Sigma, Delta, Gamma, vx : T1 <- R1 ; R2 , I, A, T2 )
     =>
     rConfig(Sigma, Delta, Gamma, vy : T1 <- R1 ; (R2 [vx / vy]), I, A, T2)
     if typeOf(Sigma, Delta, Gamma, I, A, R1) == T1 /\
        typeOf(Sigma, Delta, Gamma (vx : T1), I, A, R2) == T2 [nonexec] .
        
 rl [alpha-nf] : 
    rConfig(Sigma, Delta, Gamma, 
            nf((vx : T1 <- R1) BRL,
               R2,
               QL
              ),
            I, A, T2    
           )
     => 
     rConfig(Sigma, Delta, Gamma, 
            nf((vy : T1 <- R1) BRL,
               R2 [vx / vy] ,
               replace vx vy QL
              ),
            I, A, T2    
           )   
      [nonexec]        
 .       
               
 crl [samp-free] : 
     rConfig(Sigma, Delta, emptyTypeContext,
             x1 : T1 <- R1 ; x2 : T1 <- R1 ; return pair(x1, x2),
             I, A, T1 * T2)
     => 
     rConfig(Sigma, Delta, emptyTypeContext,
             x1 : T1 <- R1 ;  return pair(x1, x1),
             I, A, T1 * T2)
     if isSampFree(R1) .  
     
  var Dist : Distribution .   
     
  *** TODO: is this true?
 rl [samp-over-if] :
    rConfig(Sigma, Delta, Gamma, 
            preNF((x : T1 <~ samp Dist) BL, if M then R1 else R2, QL), I, A, T) 
    => 
    rConfig(Sigma, Delta, Gamma, 
            preNF(BL, if M then (x : T1 <- samp Dist ; R1) 
                           else (x : T1 <- samp Dist ; R2), 
                           del x QL), 
            I, A, T) 
    .

endm

fmod NAT-PAIRS is
 protecting NAT .

 sort NatPairs .
 op (_;;_) : Nat Nat -> NatPairs [ctor] .

endfm

view NatPairs from TRIV to NAT-PAIRS is
 sort Elt to NatPairs .
endv

fmod BOUNDS is
 protecting LIST{NatPairs} .
 protecting BOOL-TERM-ENTAILS .
 
 *** bounds for families
 *** we only worked with uniform bounds so far
 *** so dependent bounds aren't fully supported

 sort Bounds .
 op bound_ : NatTerm -> Bounds [ctor] .       *** all values from 0 to bound-1
 op fixedBound_ : NatTerm -> Bounds [ctor] .  *** always the specified value
 op dependentBound_ : Qid -> Bounds [ctor] .  *** name F of a function
                                              *** ranges from 0 to F(x)-1 
                                              *** where x is the argument provided 
                                              *** for the previous bound
  *** takes as argument the name of the function giving the bound for each value
 
endfm

view Bounds from TRIV to BOUNDS is
 sort Elt to Bounds .
endv


fmod TYPEDQID is
 protecting TYPES .
 protecting CHANNEL-NAME .
 protecting LIST{Bounds} .
 
 *** typed declarations for new normal form
 
 sort TypedCName .
 op <_:_> : ChannelName Type -> TypedCName [ctor] .
 op {___:_} : NameWithScripts List{NatTerm} List{Bounds} Type -> TypedCName [ctor] .

 sort TypedCNameList .
 subsort TypedCName < TypedCNameList .
 op emptyTypedCNameList : -> TypedCNameList [ctor] .
 op __ : TypedCNameList TypedCNameList -> TypedCNameList 
       [comm assoc ctor id: emptyTypedCNameList] .

endfm 

fmod PROTOCOL is
 protecting REACTION .
 protecting TYPEDQID .
 protecting LIST{Bounds} .
 
 sort Protocol .

 op emptyProtocol : -> Protocol [ctor] .
 op _::=_ : ChannelName Cases -> Protocol [ctor format(b o g oni)] .
 op _||_ : Protocol Protocol -> Protocol [ctor assoc comm format(d ni ni o)] .
 op new_:_in_ : ChannelName Type Protocol -> Protocol 
    [ctor format(o b o r nio n+i o)] .
 op newfamily___:_in_ : NameWithScripts List{NatTerm} List{Bounds} Type Protocol -> Protocol 
     [ctor format(o b r nig o b nio ni o)] . 
 op newNF : TypedCNameList Protocol CNameList -> Protocol [ctor] .
 op family___::=_ : ChannelName List{NatTerm} List{Bounds} Cases -> Protocol 
   [ctor format(o b r nb o ng oni)] .
    *** put channelname here only to deal with Comp[A B], but we don't want to allow it otherwise!
 
 sort When .
 sort WhenCond .

 op when_ : BoolTerm -> WhenCond [ctor format(o r d)] .
 op otherwise : -> WhenCond [ctor format(o d)] .
 op _-->_ : WhenCond Cases -> When [ctor format(d o nb d)] .
 
 sort WhenList .
 subsort When < WhenList .
 op emptyWhen : -> WhenList [ctor] .
 op _;;_ : WhenList WhenList -> WhenList 
    [ctor assoc id: emptyWhen format(d no ni d)] .
 
 sort Cases .
 subsort Reaction < Cases . *** for C[i] ::= R(i)
 subsort Protocol < Cases . *** for Party[i] ::= some parallel composition, no cases
 subsort WhenList < Cases .

 var q q2 i q' : Qid .
 var n x y n1 n2 m : Nat .
 var R R' : Reaction .
 var T : Type .
 var ql : CNameList .
 var P P' P1 P2 : Protocol .
 var cn cn' C D : ChannelName .
 var ltq : TypedCNameList .
 var cases : Cases .
 var whenList : WhenList .
 var whenCond : WhenCond .
 var nlist : List{NatTerm} .
 
 var blist : List{Bounds} .
 var evalMap : Map{Qid, NatTerm} .
 
 *** lookup cn ::= cases in P by cn
 
 op getChannel__ : Protocol ChannelName -> Protocol .
 eq getChannel emptyProtocol cn = emptyProtocol .
 eq getChannel (cn ::= cases) cn = cn ::= cases .
 eq getChannel (family cn nlist blist ::= cases) cn = family cn nlist blist ::= cases .
 ceq getChannel (cn' ::= cases) cn = emptyProtocol if cn' =/= cn .
 ceq getChannel (family cn' nlist blist ::= cases) cn = emptyProtocol if cn' =/= cn .
 eq getChannel ((cn ::= cases) || P) cn = cn ::= cases .
 eq getChannel ((family cn nlist blist ::= cases) || P) cn = family cn nlist blist ::= cases .
 eq getChannel (newNF(ltq < cn : T >, P1, ql) || P) cn = getChannel P1 cn .
 eq getChannel (newNF(ltq { cn nlist blist : T }, P1, ql) || P) cn = getChannel P1 cn .
 eq getChannel (P1 || P2) cn = 
    if getChannel P1 cn == emptyProtocol 
     then getChannel P2 cn 
     else getChannel P1 cn
    fi [owise] .
   *** this will not find cn hidden in a list of new/newfamily, works with normal forms only!
 eq getChannel (new cn' : T in P ) cn = getChannel P cn .
 eq getChannel (newfamily q nlist blist : T in P) cn = getChannel P cn .
 eq getChannel newNF(ltq, P, ql) cn = getChannel P cn .
 
 sort ProtocolStructure .
 subsort ChannelName < ProtocolStructure .   *** for ::=
 op emptyS : -> ProtocolStructure [ctor] .   *** for emptyProtocol
 op _||_ : ProtocolStructure ProtocolStructure -> ProtocolStructure [ctor assoc comm] .  
    *** for ||
 op new_in_ : ChannelName ProtocolStructure -> ProtocolStructure [ctor] . *** for new
 op newfamily_in_ : NameWithScripts ProtocolStructure -> ProtocolStructure [ctor] . 
    *** for newfamily
 op newNFS : ProtocolStructure CNameList -> ProtocolStructure [ctor] . *** for newNF
 op _:=_ : Qid ProtocolStructure -> ProtocolStructure [ctor] . *** for groups
  
 op pStructure_ : Protocol -> ProtocolStructure .
 eq pStructure emptyProtocol = emptyS .
 eq pStructure (cn ::= cases) = cn .
 eq pStructure (P1 || P2) = (pStructure P1) || (pStructure P2) .
 eq pStructure (new cn : T in P) = new cn in (pStructure P) .
 eq pStructure (newfamily q nlist blist : T in P) = newfamily q in (pStructure P) .
 eq pStructure (newNF(ltq, P, ql)) = newNFS(pStructure P, ql) .
 eq pStructure (family cn nlist blist ::= P) = cn := (pStructure P) .
 eq pStructure (family cn nlist blist ::= cases) = cn [owise] .
  
 *** functions on protocols, for sym proofs
 
 op addInternalChannel_typed_assigned_in_ : ChannelName Type Cases Protocol -> Protocol .
 eq addInternalChannel cn typed T assigned cases in newNF(ltq, P, ql) = 
    newNF(< cn : T > ltq, P || cn ::= cases, cn :: ql) .
 eq addInternalChannel cn typed T assigned cases in P =  
    new cn : T in P || cn ::= cases [owise] .
    
 op addInternalFamily_typed_params__assigned_in_ : 
      NameWithScripts Type List{NatTerm} List{Bounds} Cases Protocol -> Protocol .   
 eq addInternalFamily C typed T params nlist blist assigned cases in newNF(ltq, P, ql) =
    newNF({ C nlist blist : T } ltq, P || family C nlist blist ::= cases, C :: ql) .
 eq addInternalFamily C typed T params nlist blist assigned cases in P =
    newfamily C nlist blist : T in (P || family C nlist blist ::= cases) [owise] .
 
 var cases' : Cases .
    
 op change_with_in_ : ChannelName Cases Protocol -> Protocol .
 eq change cn with cases in (cn ::= cases') = cn ::= cases .
 eq change C with cases in (family C q (bound nt) ::= cases') = 
      family C q (bound nt) ::= cases . 
 eq change cn with cases in (P || cn ::= cases') = P || cn ::= cases .
 eq change C with cases in (P || family C q (bound nt) ::= cases') = 
      P || family C q (bound nt) ::= cases . 
 eq change C with cases in (newNF(ltq, P, ql) || P2) = 
    (change C with cases in newNF(ltq, P, ql)) || (change C with cases in P2) .
 eq change cn with cases in newNF(ltq, P, ql) =
    newNF(ltq, change cn with cases in P, ql) .
 eq change cn with cases in (family C q (bound nt) ::= P) =   
    family C q (bound nt) ::= change cn with cases in P .
 eq change cn with cases in ((family C q (bound nt) ::= P) || P2) =   
    (family C q (bound nt) ::= change cn with cases in P) 
    ||
    change cn with cases in P2 .
 eq change cn with cases in P = P [owise] .       
  
 *** the bare structure of a protocol
 op getStructure_ : Protocol -> Protocol .
 eq getStructure emptyProtocol = emptyProtocol .
 eq getStructure (cn ::= cases) = emptyProtocol .
 eq getStructure (family cn nlist blist ::= newfamily q nlist' blist' : T in P)
    = family cn nlist blist ::= newfamily q nlist' blist' : T in (getStructure P) .
 eq getStructure (family cn nlist blist ::= newNF(ltq, P, ql)) 
    = (family cn nlist blist ::= newNF(ltq, getStructure P, ql)) .
 eq getStructure (family cn nlist blist ::= P) =
                 (family cn nlist blist ::= getStructure P) .
 eq getStructure (family cn nlist blist ::= (whenCond --> P) ;; whenList) =   
      family cn nlist blist ::= emptyProtocol .              
 eq getStructure (family cn nlist blist ::= cases) = emptyProtocol [owise] .
 eq getStructure newNF(ltq, P, ql) = newNF(ltq, getStructure P, ql) .
 eq getStructure (new cn : T in P) = new cn : T in (getStructure P) .
 eq getStructure (newfamily q nlist blist : T in P) = 
                  newfamily q nlist blist : T in (getStructure P) .
 eq getStructure (P1 || P2) = (getStructure P1) || (getStructure P2) .
 
 *** turn a new normal form into a protocol with new/newfamily 
 op newNF2New : Protocol -> Protocol .
 eq newNF2New(newNF(emptyTypedCNameList, P, ql)) = P .
 eq newNF2New(newNF({ cn nlist blist : T } ltq, P, cn :: ql)) = 
                  newfamily cn nlist blist : T in (newNF2New(newNF(ltq, P, ql))) .
 eq newNF2New(newNF(< cn : T > ltq, P, cn :: ql)) = 
                  new cn : T in (newNF2New(newNF(ltq, P, ql))) .
 eq newNF2New(P) = P [owise] .


 *** compute the new normal form of a protocol
 op new2NF : Protocol -> Protocol .
 eq new2NF(P) = dropEmpty(new2NFAux P newNF(emptyTypedCNameList, emptyProtocol, emptyCNameList)) .

 op dropEmpty : Protocol -> Protocol .
 eq dropEmpty(newNF(emptyTypedCNameList, P, ql)) = P .
 eq dropEmpty(P) = P [owise] .
 
 var fns : NameWithScripts .

 op new2NFAux__ : Protocol Protocol -> Protocol .
 eq new2NFAux (new cn : T in P) newNF(ltq, P', ql) = 
      new2NFAux P newNF( < cn : T > ltq, P', ql ++ (cn :: emptyCNameList)) .
 eq new2NFAux (newfamily cn nlist blist : T in P) newNF(ltq, P', ql) = 
      new2NFAux P newNF( {cn nlist blist : T } ltq, P', ql ++ (cn :: emptyCNameList)) . 
 eq new2NFAux (P1 || P2)  newNF(ltq, P', ql) = newNF(ltq, new2NF(P1) || new2NF(P2) ,ql) .
 eq new2NFAux (family fns nlist blist ::= P) newNF(ltq, P', ql) = 
     newNF(ltq, family fns nlist blist ::= new2NF(P) , ql) .
 eq new2NFAux (family fns nlist blist ::= (whenCond --> P) ) newNF(ltq, P', ql) = 
      newNF(ltq, family fns nlist blist ::= (whenCond --> new2NF(P) ) , ql) . 
 eq new2NFAux (family fns nlist blist ::= (whenCond --> P) ;; whenList ) newNF(ltq, P', ql) = 
      newNF(ltq, family fns nlist blist ::= (whenCond --> new2NF(P)) ;; whenList   , ql) .      
        *** TODO: this is wrong! do the same on whenList!
 eq new2NFAux P newNF(ltq, P', ql) = newNF(ltq, P, ql) [owise] .
  
 var plist : List{NatPairs} .  
 
 *** desugar newfamily, but we never need this 
 op nf2p : Protocol -> Protocol . 
 eq nf2p(newfamily C q (bound n) : T in P) = genNew1 C n T P 0 .
 eq nf2p(newfamily C (q q') ((bound n1)(bound n2)) : T in P) = genNew2 C n1 n2 T P 0 0 .
 *** commented this out for now because we won't do this in practice
 *** eq nf2p(newfamily C (q q') ((bound n1)(dependentBound plist)) : T in P) = 
 ***   gen2Dep C n1 plist T P 0 0 . 

 op genNew1_____ : NameWithScripts Nat Type Protocol Nat -> Protocol .
 ceq genNew1 C n T P x = P if x == n + 1 .                     *** TODO: desugar family as well?
 eq genNew1 C n T P x = new C [ x ] : T in (genNew1 C n T P s(x)) .
 
 op genNew2_______ : NameWithScripts Nat Nat Type Protocol Nat Nat -> Protocol .
 ceq genNew2 C n1 n2 T P x y = P if x == n1 + 1 .
 eq genNew2 C n1 n2 T P x y = new C [ x y ] : T in 
    (if y == n2 then genNew2 C n1 n2  T P (x + 1) 0 
               else genNew2 C n1 n2 T P x (y + 1)
     fi) .
     
 op gen2Dep_______ : NameWithScripts Nat List{NatPairs} Type Protocol Nat Nat -> Protocol .
 eq gen2Dep C n nil T P x y = P .
 eq gen2Dep C n ((n1 ;; n2) plist) T P x y =
 if x == n + 1 then P *** this allows us to stop if we have too many bounds
 else 
  if y == n2 + 1 then gen2Dep C n plist T P (x + 1) 0
  else 
   new C [ x  y] : T in gen2Dep C n ((n1 ;; n2) plist) T P x (y + 1)
  fi 
 fi .

  
 op f2p : Protocol -> Protocol .
 eq f2p(family C q (bound n) ::= cases) = f2p1 (C [q]) empty C q n cases 0 .
 eq f2p(family C (q q') blist ::= cases) = f2p2 C q q' blist cases .
 eq f2p(P) = P [owise] .
 
 *** desugaring for two indices
 
 op f2p2_____ : NameWithScripts Qid Qid List{Bounds} Cases -> Protocol .
 eq f2p2 C q q' blist cases = emptyProtocol .
 
 *** desugaring for one index
 
 op f2p1_______ : ChannelName Map{Qid, NatTerm} NameWithScripts Qid Nat Cases Nat -> Protocol .
 eq f2p1 cn evalMap C q n R x =
  if x == n 
  then ((evalCName cn (q |-> x, evalMap)) ::= replaceVars(R, (q |-> x, evalMap)))
  else ((evalCName cn (q |-> x, evalMap))::= replaceVars(R, (q |-> x, evalMap))) 
       || (f2p1 cn evalMap C q n R (x + 1)) 
  fi .
 eq f2p1 cn evalMap C q n (D [q] ::= R) x = parComp cn evalMap n (D [q] ::= R) 0 .
 eq f2p1 cn evalMap C q n (family D q' (bound m) ::= cases) x = 
   if x == n then
    f2p1 (D [q q']) (q |-> x, evalMap) D q' m cases 0 
   else
    (f2p1 (D [q q']) (q |-> x, evalMap) D q' m cases 0) || 
    (f2p1 (D [q q']) evalMap C q n (family D q' (bound m) ::= cases) (x + 1))
   fi   .
 eq f2p1 cn evalMap C q n ((D [q] ::= R) || P) x = 
     (parComp cn evalMap n (D [q] ::= R) 0) || f2p1 cn evalMap C q n P x .
 eq f2p1 cn evalMap C q n whenList x = 
  if x == n then (selectCase cn C (q |-> x, evalMap) n whenList (q =T= x) x) 
  else (selectCase cn C (q |-> x, evalMap) n whenList (q =T= x) x) || f2p1 cn evalMap C q n whenList (x + 1)
  fi .
  
  
 op parComp_____ : ChannelName Map{Qid, NatTerm} Nat Protocol Nat -> Protocol .
 eq parComp cn evalMap n (D[q] ::= R) x = 
  if x == n
  then ((evalCName cn (q |-> x, evalMap)) ::= replaceVars(R, (q |-> x, evalMap))
       )
  else ((evalCName cn (q |-> x, evalMap)) ::= replaceVars(R, (q |-> x, evalMap))) 
       || parComp cn evalMap n (D[q] ::= R) (x + 1)
  fi . 
 
 var nt nt1 nt2 : NatTerm .
 var p : Qid .
 
 op selectCaseFamily______ : NameWithScripts Qid Nat Map{Qid,NatTerm} WhenList Nat -> Protocol .
 eq selectCaseFamily C q n evalMap whenList x =  
     family C q (bound n) ::= selectReaction evalMap whenList x .

 op selectReaction___ : Map{Qid,NatTerm} WhenList Nat -> Reaction .
 eq selectReaction evalMap ( (when (nt1 =T= nt2) --> R ) ;; whenList) x =
  if (evalTerm nt1 evalMap) == (evalTerm nt2 evalMap)
  then replaceVars(R, evalMap) 
  else selectReaction evalMap whenList x
  fi .
  eq selectReaction evalMap ( (when (nt1 <T nt2) --> R ) ;; whenList) x =
  if (evalTerm nt1 evalMap) < (evalTerm nt2 evalMap) 
  then replaceVars(R, evalMap) 
  else selectReaction evalMap whenList x
  fi . 
  eq selectReaction evalMap ( (when (nt1 <=T nt2) --> R ) ;; whenList) x =
  if (evalTerm nt1 evalMap) <= (evalTerm nt2 evalMap) 
  then replaceVars(R, evalMap) 
  else selectReaction evalMap whenList x
  fi . 
  eq selectReaction evalMap ( (otherwise --> R ) ;; whenList) x =
  replaceVars(R, evalMap) .
  eq selectReaction evalMap ( (when (apply p nt1) --> R ) ;; whenList) x =
  if evalBoolTerm(apply p (evalTerm nt1 evalMap), empty, empty) == true *** TODO: some A?
  then replaceVars(R, evalMap) 
  else selectReaction evalMap whenList x
  fi .

 var A : Set{BoolTerm} .  
 ********************************** WE need NatTerm, maybe also get a when as result!
 
 
 *** TODO: call selectCase with a evalMap q |-> x, so that we can reuse code for family in family!
 op selectCase_______ : ChannelName NameWithScripts Map{Qid,NatTerm} Nat 
                       WhenList Set{BoolTerm} NatTerm -> Protocol .
 eq selectCase cn C evalMap n ( (when (nt1 =T= nt2) --> R ) ;; whenList) A x = 
  if evalTerm nt1 evalMap == evalTerm nt2 evalMap 
  then (evalCName cn evalMap) ::= replaceVars(R, evalMap) 
  else selectCase cn C evalMap n whenList A x 
  fi .
 eq selectCase cn C evalMap n ( (when (nt1 <T nt2) --> R ) ;; whenList) A x = 
  if (evalTerm nt1 evalMap) < (evalTerm nt2 evalMap)
  then (evalCName cn evalMap) ::= replaceVars(R, evalMap) 
  else selectCase cn C evalMap n whenList A x 
  fi .
  eq selectCase cn C evalMap n ( (when (nt1 <=T nt2) --> R ) ;; whenList) A x = 
  if (evalTerm nt1 evalMap) <= (evalTerm nt2 evalMap)
  then (evalCName cn evalMap) ::= replaceVars(R, evalMap) 
  else selectCase cn C evalMap n whenList A x 
  fi .  
 eq selectCase cn C evalMap n ( (otherwise --> R ) ;; whenList) A x = 
    (evalCName cn evalMap) ::= replaceVars(R, evalMap) .
 eq selectCase cn C evalMap n ( (when (apply p nt1) --> R ) ;; whenList) A x = 
  if (evalBoolTerm(apply p (evalTerm nt1 evalMap), A, empty) == true) then 
   (evalCName cn evalMap) ::= replaceVars(R, evalMap)
   else
   selectCase cn C evalMap n whenList A x 
   fi .
 *** for protocols
 eq selectCase cn C evalMap n ( (when (nt1 =T= nt2) --> (D [q] ::= R) ) ;; whenList) A x = 
  if evalTerm nt1 evalMap == evalTerm nt2 evalMap 
  then D [x] ::= replaceVars(R, evalMap) 
  else selectCase cn C evalMap n whenList A x 
  fi . 
  eq selectCase cn C evalMap n ( (when (nt1 <T nt2) --> (D [q] ::= R) ) ;; whenList) A x = 
  if (evalTerm nt1 evalMap) < (evalTerm nt2 evalMap)
  then D [x] ::= replaceVars(R, evalMap) 
  else selectCase cn C evalMap n whenList A x 
  fi .
  eq selectCase cn C evalMap n ( (when (nt1 <=T nt2) --> (D [q] ::= R) ) ;; whenList) A x = 
  if (evalTerm nt1 evalMap) <= (evalTerm nt2 evalMap)
  then D [x] ::= replaceVars(R, evalMap) 
  else selectCase cn C evalMap n whenList A x 
  fi .  
 eq selectCase cn C evalMap n ( (otherwise --> (D [q] ::= R) ) ;; whenList) A x = 
     D [x] ::= replaceVars(R, evalMap) .
 eq selectCase cn C evalMap n ( (when (apply p nt1) --> (D [q] ::= R) ) ;; whenList) A x = 
  if evalBoolTerm(apply p (evalTerm nt1 evalMap), A, empty) == true then
   D [x] ::= replaceVars(R, evalMap)
   else
   selectCase cn C evalMap n whenList A x 
   fi .   
      
 vars C1 C2 C3 : ChannelName .
 vars R1 R2 R3 : Reaction .     
 var blist' : List{Bounds} .
 var nlist' : List{NatTerm} .
 var cases1 cases2 : Cases .
 
 *** next methods are needed to speed-up matching
 
 op keepThree____ : Protocol ChannelName ChannelName ChannelName -> Protocol .
 eq keepThree (P || (C1 ::= cases) || (C2 ::= cases1) || (C3 ::= cases2)) C1 C2 C3 = 
    (C1 ::= cases) || (C2 ::= cases1 ) || (C3 ::= cases2)
 .
 
 op removeThree____ :  Protocol ChannelName ChannelName ChannelName -> Protocol .
 eq removeThree (P || (C1 ::= cases) || (C2 ::= cases1) || (C3 ::= cases2)) C1 C2 C3 = P .  
      
 op keepTwo___ : Protocol ChannelName ChannelName -> Protocol .
 eq keepTwo ((C1 ::= cases1) || (C2 ::= cases2) || P) C1 C2 =  
     (C1 ::= cases1) || (C2 ::= cases2) .
 eq keepTwo ((C1 ::= cases1) || (family C2 nlist blist ::= cases2) || P) C1 C2 =  
    (C1 ::= cases1) || (family C2 nlist blist ::= cases2) . 
 eq keepTwo ((family C1 nlist blist ::= cases1) || (C2 ::= cases2) || P) C1 C2 =  
    (family C1 nlist blist ::= cases1) || (C2 ::= cases2) . 
 eq keepTwo ((family C1 nlist blist ::= cases1) || (family C2 nlist' blist' ::= cases2) || P) C1 C2 =  
    (family C1 nlist blist ::= cases1) || (family C2 nlist' blist' ::= cases2) .   
 eq keepTwo (new C : T in P) C1 C2 = keepTwo P C1 C2 .
 eq keepTwo (newfamily C nlist blist : T in P) C1 C2 = keepTwo P C1 C2 .
 
 op removeTwo___ : Protocol ChannelName ChannelName -> Protocol .
 eq removeTwo ((C1 ::= cases1) || (C2 ::= cases2) || P) C1 C2 =  P .
 eq removeTwo ((family C1 nlist blist ::= cases1) || (C2 ::= cases2) || P) C1 C2 =  P .  
 eq removeTwo ((C1 ::= cases1) || (family C2 nlist blist ::= cases2) || P) C1 C2 =  P .
 eq removeTwo ((family C1 nlist blist ::= cases1) || (family C2 nlist' blist' ::= cases2) || P) C1 C2 =  P .
 eq removeTwo (new C : T in P) C1 C2 = removeTwo P C1 C2 .
 eq removeTwo (newfamily C nlist blist : T in P) C1 C2 = removeTwo P C1 C2 .
 
 op keepOne__ : Protocol ChannelName -> Protocol .
 eq keepOne ((C1 ::= cases) || P) C1 =  (C1 ::= cases) .  
 eq keepOne (new C : T in P) C1 = keepOne P C1 .
 eq keepOne ((family C1 nlist blist ::= cases) || P) C1 = family C1 nlist blist ::= cases .
 eq keepOne (newfamily C2 nlist blist : T in P) C1 = keepOne P C1 .
 
 op removeOne__ : Protocol ChannelName -> Protocol .
 eq removeOne ((C1 ::= cases) || P) C1 =  P . 
 eq removeOne (new C : T in P) C1 = removeOne P C1  .
 eq removeOne ((family C1 nlist blist ::= cases) || P) C1 = P .
 eq removeOne (newfamily C2 nlist blist : T in P) C1 = removeOne P C1 .
        
        
 *** json-like representation
 sort JSON .
 *** TODO: the value should be JSON
 *** 1. cn ::= R                value: {reaction: R}
 *** 2. cn ::= P                value: (toJSON P Delta)
 *** 3. cn ::= when bt -> R     value: {cond: bt, reaction: R}
 *** 4. cn ::= when bt -> P     value: {cond: bt, protocol: (toJSON P Delta)}
 
 op {} : -> JSON [ctor] .
 op {cname:_,value:_,hasType:_,isInternal:_, extras:_} : 
     ChannelName JSON JSON Bool JSON -> JSON 
     [ctor format(d n d d n d d n d d n d d n d n d)] .
 
 op {type:_} : Type -> JSON [ctor] .
 op {reaction:_} : Reaction -> JSON [ctor] .
 op {cond:_,reaction:_} : WhenCond Reaction -> JSON [ctor] .
 op {cond:_,protocol:_} : WhenCond JSON -> JSON [ctor] .
 
 sort JSONList .
 subsort JSON < JSONList .
 op emptyJSONList : -> JSONList [ctor] .
 op __ : JSONList JSONList -> JSONList 
     [ctor comm assoc id: emptyJSONList format(d n d)] .
 
 op {_} : JSONList -> JSON [ctor format(d n n d)] .
 op {indices:_,bounds:_} : List{NatTerm} List{Bounds} -> JSON [ctor] . 
 
 var j j' e v t : JSON .
 var js : JSONList .
 var internal : Bool .
 
 op insertJSON__ : JSON JSON -> JSON .
 eq insertJSON j {js} = {j js} .
 eq insertJSON j j' = {j j'} [owise] .
 
 op updateInternal : JSON ChannelName -> JSON .
 eq updateInternal(
     {cname: cn, value: v, hasType: t, isInternal: internal, extras: e},
      cn
    ) = {cname: cn, value: v, hasType: t, isInternal: true, extras: e} .
 eq updateInternal({j js}, cn) = 
      insertJSON (updateInternal(j, cn)) (updateInternal({js}, cn)) .
 eq updateInternal(j, cn) = j [owise] .  
 
 *** sets the value to emptyProtocol, the typing is no longer correct
 op updateValue : JSON -> JSON .
 eq updateValue (
     {cname: cn, value: {{cond: whenCond, protocol: j} js}, 
      hasType: t, isInternal: internal, extras: e}
    ) = {cname: cn, value: updateValue({{cond: whenCond, protocol: j} js}), 
         hasType: t, isInternal: internal, extras: e} .
 eq updateValue (
     {cname: cn, value: v, hasType: t, isInternal: internal, extras: e}
    ) = {cname: cn, value: {}, hasType: t, isInternal: internal, extras: e} .
 eq updateValue({j js}) = 
      insertJSON (updateValue(j)) (updateValue({js})) .
 eq updateValue({cond: whenCond, protocol: j}) = 
    {cond: whenCond, protocol: updateValue(j)} .     
 eq updateValue(j) = j [owise] .     
    
 
endfm

fmod PROTOCOL-INDEP is
 protecting PROTOCOL .
 protecting CHANNEL .
 
 var cn : ChannelName .
 var P P1 P2 : Protocol .
 var T : Type .
 vars R : Reaction . 
 var ltq : TypedCNameList .
 var ql : CNameList .
  var nlist : List{NatTerm} .
 var blist : List{Bounds} .
 var whenList : WhenList .
 var whenCond : WhenCond .
 var q : NameWithScripts .
 var i j : Qid . 

 *** older idea, we might want to remove it!
 
 op projZero_ : Protocol -> Protocol .
 eq projZero emptyProtocol = emptyProtocol .
 eq projZero (P1 || P2) = projZero P1 || projZero P2 .
 eq projZero (new cn : T in P) = new cn : T in (projZero P) .
 eq projZero (newfamily q j blist : T in P) = new q [0] : T in projZero P  .
 eq projZero (family q j blist ::= R) = q[0] ::= (replaceVars(R, j |-> 0)) .
 eq projZero (family q j blist ::= P) = family q j blist ::= (projZero P) .
 eq projZero (q ::= R) = q ::= R .
 eq projZero (q[j] ::= R) = q[0] ::= (replaceVars (R, j |-> 0)) . 
 
 
 op isIndepComp__ : Qid Protocol -> Bool .
 eq isIndepComp i emptyProtocol = true .
 eq isIndepComp i (P1 || P2) = (isIndepComp i P1) and (isIndepComp i P2) .
 eq isIndepComp i (new cn : T in P) = isIndepComp i P .
 eq isIndepComp i (newfamily q nlist blist : T in P) = isIndepComp i P .
 eq isIndepComp i (family q j blist ::= R) = isIndepR j R .
 eq isIndepComp i (family q j blist ::= P) = isIndepComp j P .
 eq isIndepComp i (family q j blist ::= (whenCond --> R)) = isIndepR j R .
 eq isIndepComp i (family q j blist ::= (whenCond --> P)) = isIndepComp j P .
 eq isIndepComp i 
     (family q j blist ::= (whenCond --> R) ;; whenList) = 
   (isIndepR j R) and (isIndepComp i (family q j blist ::= whenList)).
 eq isIndepComp i 
     (family q j blist ::= (whenCond --> P) ;; whenList) = 
   (isIndepComp j P) and (isIndepComp i (family q j blist ::= whenList)).
 eq isIndepComp i newNF(ltq, P, ql) = isIndepComp i P .
 eq isIndepComp i (q ::= R) = isIndepR i R .
 eq isIndepComp i (q[nlist] ::= R) = isIndepR i R . *** TODO: add cond on nlist?
 
 var M : Expression .
 var D : Distribution .
 var R1 R2 : Reaction .
 var x : Qid .
 var BL : BindList .
 var QL : CNameList .
   
 op isIndepR__ : Qid Reaction -> Bool .
 eq isIndepR i (return M) = true .
 eq isIndepR i (samp D) = true .
 *** eq isIndepR i (samp flip) = true .
 eq isIndepR i (if M then R1 else R2) = isIndepR i R1 and isIndepR i R2 .  
 eq isIndepR i (x : T <- R1 ; R2) = isIndepR i R1 and isIndepR i R2 .
 eq isIndepR i (nf(BL, R, QL)) = isIndepR i R and isIndepB i BL .
 eq isIndepR i (preNF(BL, R, QL)) = isIndepR i R and isIndepB i BL .
 eq isIndepR i (read q) = true .
 eq isIndepR i (read (q[nlist])) = hasOnlyI i nlist .
 
 var n : Nat .
 var nt1 nt2 : NatTerm .
 
 op hasOnlyI__ : Qid List{NatTerm} -> Bool .
 eq hasOnlyI i j = i == j .
 eq hasOnlyI i n = true .
 eq hasOnlyI i (nt1 ++ nt2) = false .
 eq hasOnlyI i (nt1 -- nt2) = false .
 eq hasOnlyI i (nt1 nlist) = hasOnlyI i nt1 and hasOnlyI i nlist .
 
 op isIndepB__ : Qid BindList -> Bool .
 eq isIndepB i emptyBRList = true .
 eq isIndepB i (x : T <- R) = isIndepR i R .
 eq isIndepB i (x : T <~ R) = isIndepR i R .
 eq isIndepB i ((x : T <- R) BL) = isIndepR i R and isIndepB i BL .
 eq isIndepB i ((x : T <~ R) BL) = isIndepR i R and isIndepB i BL .
 
endfm 
 
fmod PROTOCOL-IO is
 protecting PROTOCOL .
 protecting CHANNEL .

 op getOutputs : Protocol -> Set{CNameBound} .
 
 var c : ChannelName .
 var P P1 P2 : Protocol .
 var T : Type .
 vars R : Reaction .
 var cases : Cases . 
 var ltq : TypedCNameList .
 var ql : CNameList .
  var nlist : List{NatTerm} .
 var blist : List{Bounds} .
 var whenList : WhenList .
 var whenCond : WhenCond .
 var q q1 q2 : NameWithScripts .
 var b1 b2 : NatTerm . 
 var b : Qid .

*** convert the channels in a typed list to a set of bounded names
op chansInList_ : TypedCNameList -> Set{CNameBound} .
eq chansInList emptyTypedCNameList = empty .
eq chansInList (< q : T > ltq) = insert(q @ nil, chansInList ltq) .
eq chansInList (< q[nlist] : T > ltq) = insert(q[nlist] @ nil, chansInList ltq) . 

eq chansInList ({c nlist blist : T} ltq) = insert(toBounds c blist, chansInList ltq) .

  *** convert a qid and a list of bounds to a bounded name
  *** we do this for families
  op toBounds__ : Qid List{Bounds} -> CNameBound .
  eq toBounds c blist = c @ (toBound1 blist) .
    
  op toBound1_ : List{Bounds} -> List{NatTerm} .
  eq toBound1 nil = nil .
  eq toBound1 ((bound b1) blist) = b1 (toBound1 blist) .
 *** eq toBound1 ((uniformBound b1) blist) = b1 (toBound1 blist) .
  eq toBound1 ((dependentBound b) blist) = b (toBound1 blist) .
  eq toBound1 ((fixedBound b1) blist) = b1 (toBound1 blist) . 
      *** ^ this is wrong but we will likely never use this
      *** should we refactor?


 *** the outputs of a protocol can be computed
 eq getOutputs(emptyProtocol) = empty .
 eq getOutputs(q ::= R) = q @ nil [label getOutputsAssign] .
 eq getOutputs(q[nlist] ::= cases) = q[nlist] @ nil .
 eq getOutputs((q ::= R) || P2) = union(q @ nil, getOutputs(P2)) [label getOutputsParallel] .
 eq getOutputs((q[nlist] ::= R) || P2) = union(q[nlist] @ nil, getOutputs(P2)) .
 eq getOutputs(P1 || P2) = union(getOutputs(P1), getOutputs(P2)) [owise] .
 eq getOutputs(new c : T in P) = getOutputs(P) \ (c @ nil) [label getOutputsNew] .
 eq getOutputs(newfamily c nlist blist : T in P) = getOutputs(P) \ (toBounds c blist) .
 eq getOutputs(newNF(ltq, P, ql)) = getOutputs(P) \ (chansInList ltq) [label getOutputsNewNF] .
 eq getOutputs(family c nlist blist ::= R) = toBounds c blist .
 eq getOutputs(family c nlist blist ::= (whenCond --> R) ;; whenList) = toBounds c blist .
 eq getOutputs(family c nlist blist ::= (whenCond --> P) ;; whenList) = getOutputs(P) .
 eq getOutputs(family c nlist blist ::= P) = getOutputs(P) .

 eq getOutputs(family 'Comp[q1 q2] nlist blist ::= P) = getOutputs(P) .
   
endfm

fmod PROTOCOL-TYPING is 
 protecting PROTOCOL-IO .
 protecting PROTOCOL-INDEP .
 protecting REACTION-TYPING .

 var Sigma : Signature .
 var Delta : ChannelContext .
 var I : Set{CNameBound} .
 var A : Set{BoolTerm} .
 var Q o cn : ChannelName .
 var c q q1 q2 : NameWithScripts .
 var T : Type .
 var R : Reaction .
 var P1 P2 P : Protocol .
 var n n0 : Nat .
 var nlist : List{NatTerm} .
 var blist : List{Bounds} .
 
 sort BoolWithError .
 subsort Bool < BoolWithError .
 op err_ : String -> BoolWithError [ctor] .
 

 *** a predicate to check that a protocol typechecks
 op typeOf : Signature ChannelContext Set{CNameBound} Set{BoolTerm} Protocol -> BoolWithError .
 
 ceq typeOf(Sigma, Delta, I, A, P) = 
     err ("I invalid for Delta")
 if not (validChanSet I Delta A) .
  
 eq typeOf(Sigma, Delta, I, A, P) = 
    *** validChanSet I Delta A 
    *** and 
    typeOfAux(Sigma, Delta, I, A, P)
    [owise]
 .
  
 op typeOfAux : Signature ChannelContext Set{CNameBound} 
                Set{BoolTerm} Protocol 
             -> BoolWithError .
 
 eq typeOfAux(Sigma, Delta, I, A, emptyProtocol) = true .

 ceq typeOfAux(Sigma, Delta, I, A, cn ::= R) = 
     err "can't assign to an input" 
 if  isElemB(cn, I, A) .
 
 ceq typeOfAux(Sigma, Delta, I, A, cn ::= R) = 
     err ("type mismatch:" + string(cn))
 if  not(
     typeOf(Sigma, Delta, emptyTypeContext, I, A, R) 
     == 
     typeInCtx(toBound cn, A, Delta)    
     )
 .    

 eq typeOfAux(Sigma, Delta, I, A, cn ::= R) = 
    typeOf(Sigma, Delta, emptyTypeContext, I, A, R) 
     == 
    typeInCtx(toBound cn, A, Delta)
    and
    not isElemB(cn, I, A) [owise].
  
 eq typeOfAux(Sigma, Delta, I, A, P1 || P2) =
     typeOfAux(Sigma, Delta, union(I, getOutputs(P2)), A, P1) 
     and 
     typeOfAux(Sigma, Delta, union(I,  getOutputs(P1)), A, P2)
     .

 ceq typeOfAux(Sigma, Delta, I, A, new o : T in P) =
     err (string(o) + " already present in Delta")
     if occurs (toBound o) Delta A .

 eq typeOfAux(Sigma, Delta, I, A, new o : T in P) =
     not occurs (toBound o) Delta A
     and
     typeOfAux(Sigma, Delta ((o @ nil) :: T), I, A, P)
     [owise] . 

 ceq typeOfAux(Sigma, Delta, I, A, newfamily c nlist blist : T in P) =
     err ("family already occurs in Delta:" + string(c))
 if  occurs (toBounds c blist) Delta A .
    
 eq typeOfAux(Sigma, Delta, I, A, newfamily c nlist blist : T in P) =
    not occurs (toBounds c blist) Delta A
    and
    typeOfAux(Sigma, Delta ((toBounds c blist) :: T), I, A, P) 
    [owise]
  .
  
 var cases : Cases . 
 var whenCond : WhenCond .
 var whenList : WhenList .
 
 var ind1 ind2 ind3 : Qid .
 var nt1 nt2 nt3 : NatTerm .
 
 var bt : BoolTerm .
 
 var ltq : TypedCNameList .   
 var ql : CNameList . 
 
 *** add to a set the condition that the variables of a family
 *** are within bounds
 op addAssumptions___ : Set{BoolTerm} List{NatTerm} List{Bounds} -> Set{BoolTerm} .
 eq addAssumptions A ind1 (bound nt1) = insert(ind1 <T nt1, A) .
 eq addAssumptions A (ind1 ind2) ((bound nt1)(bound nt2)) =
     insert(ind2 <T nt2, insert(ind1 <T nt1, A)) .
 eq addAssumptions A (ind1 ind2) ((bound nt1)(fixedBound nt2)) =
     insert(ind2 =T= nt2, insert(ind1 <T nt1, A)) .
 eq addAssumptions A (ind1 ind2) ((fixedBound nt1)(bound nt2)) =
     insert(ind2 <T nt2, insert(ind1 =T= nt1, A)) .          
 eq addAssumptions A (ind1 ind2) ((bound nt1)(dependentBound q)) =
     insert(ind1 <T nt1, insert(ind2 <T fun q ind1, A)) .
 eq addAssumptions A (ind1 ind2) ((fixedBound nt1)(dependentBound q)) =
     insert(ind1 =T= nt1, insert(ind2 <T fun q ind1, A)) .    
 eq addAssumptions A (ind1 ind2 ind3) ((bound nt1)(bound nt2) (bound nt3)) =
     insert(ind3 <T nt3,
     insert(ind2 <T nt2, insert(ind1 <T nt1, A))
     ) . 
 eq addAssumptions A (ind1 ind2 ind3) ((fixedBound nt1)(bound nt2) (bound nt3)) =
     insert(ind3 <T nt3,
     insert(ind2 <T nt2, insert(ind1 =T= nt1, A))
     ) .   
 eq addAssumptions A (ind1 ind2 ind3) ((bound nt1)(fixedBound nt2) (bound nt3)) =
     insert(ind3 <T nt3,
     insert(ind2 =T= nt2, insert(ind1 <T nt1, A))
     ) .  
 eq addAssumptions A (ind1 ind2 ind3) ((bound nt1)(bound nt2) (fixedBound nt3)) =
     insert(ind3 =T= nt3,
     insert(ind2 <T nt2, insert(ind1 <T nt1, A))
     ) .            
 eq addAssumptions A (ind1 ind2 ind3) ((bound nt1)(bound nt2) (dependentBound q)) =
     insert(ind3 <T fun q ind2,
     insert(ind2 <T nt2, insert(ind1 <T nt1, A))
     ) .  
 eq addAssumptions A (ind1 ind2 ind3) ((fixedBound nt1)(bound nt2) (dependentBound q)) =
     insert(ind3 <T fun q ind2,
     insert(ind2 <T nt2, insert(ind1 =T= nt1, A))
     ) . 
 eq addAssumptions A (ind1 ind2 ind3) ((bound nt1)(fixedBound nt2) (dependentBound q)) =
     insert(ind3 <T fun q ind2,
     insert(ind2 =T= nt2, insert(ind1 <T nt1, A))
     ) .                        
 ***(     
 ceq typeOfAux(Sigma, Delta, I, A, family c nlist blist ::= R) = 
     err ("type mismatch family:" + string(c))
 if 
     typeOf(Sigma, Delta, emptyTypeContext, insert(toBounds c blist, I), 
            addAssumptions A nlist blist, R) == 
     typeInCtx(toBounds c blist, addAssumptions A nlist blist, Delta)
     
    . 
 
 ceq typeOfAux(Sigma, Delta, I, A, family c nlist blist ::= R) = 
     err ("missing family" + string(c))   
 if not (occurs (toBounds c blist) Delta A) .     
 ) 
  
 eq typeOfAux(Sigma, Delta, I, A, family c nlist blist ::= R) = 
     occurs (toBounds c blist) Delta A
     and *** here is where we add the assumptions about the vars in nlist for R!
     typeOf(Sigma, Delta, emptyTypeContext, insert(toBounds c blist, I), 
            addAssumptions A nlist blist, R) == 
     typeInCtx(toBounds c blist, addAssumptions A nlist blist, Delta) [owise]
 .
     
 eq typeOfAux(Sigma, Delta, I, A, family c nlist blist ::= P) = 
    typeOfAux(Sigma, Delta, I, A, P) . 
    
 eq typeOfAux(Sigma, Delta, I, A, family 'Comp[q1 q2] nlist blist ::= P) = 
    typeOfAux(Sigma, Delta, I, A, P) .    
    
 eq typeOfAux(Sigma, Delta, I, A, family c nlist blist ::= (when bt --> R)) = 
     occurs (toBounds c blist) Delta A
     and
     typeOf(Sigma, Delta, emptyTypeContext, insert(toBounds c blist, I), 
            insert(bt, addAssumptions A nlist blist), R) == 
     typeInCtx(toBounds c blist, addAssumptions A nlist blist, Delta) 
 . 
    
  eq typeOfAux(Sigma, Delta, I, A, family c nlist blist ::= (otherwise --> R)) = 
     occurs (toBounds c blist) Delta A
     and
     typeOf(Sigma, Delta, emptyTypeContext, 
            insert(toBounds c blist, I), addAssumptions A nlist blist, R)
      == 
     typeInCtx(toBounds c blist, addAssumptions A nlist blist, Delta) 
  .    
     
   eq typeOfAux(Sigma, Delta , I, A, family c nlist blist ::= (otherwise --> P)) = 
      typeOfAux(Sigma, Delta , I, A, P) .
     
   eq typeOfAux(Sigma, Delta , I, A, family c nlist blist ::= (when bt --> P)) = 
      typeOfAux(Sigma, Delta , I, insert(bt, A), P) .       
    
 eq typeOfAux(Sigma, Delta, I, A, family c nlist blist ::= (when bt --> R) ;; whenList) = 
    typeOfAux(Sigma, Delta, I, addAssumptions A nlist blist , 
              family c nlist blist ::= (when bt --> R))
    and
    typeOfAux(Sigma, Delta, I, insert(neg bt, addAssumptions A nlist blist), 
              family c nlist blist ::= whenList) 
    .
 
 eq typeOfAux(Sigma, Delta, I, A, family c nlist blist ::= (when bt --> P) ;; whenList) = 
    typeOfAux(Sigma, Delta, I, insert(bt, A), family c nlist blist ::= P)
    and
    typeOfAux(Sigma, Delta, I, insert(neg bt, A), family c nlist blist ::= whenList)  
 . *** TODO: same sets of outputs for each case

 eq typeOfAux(Sigma, Delta, I, A, newNF(ltq, P, ql)) = 
    typeOfAux(Sigma, Delta, I, A, newNF2New(newNF(ltq, P, ql)))
    .  


 *** check that the names in a typed list
 *** are new for a channel context
 op allNew___ : TypedCNameList ChannelContext Set{BoolTerm} -> Bool .
 eq allNew emptyTypedCNameList Delta A = true .
 eq allNew (< cn : T > ltq) Delta A = not (occurs (cn @ nil) Delta A) and allNew ltq Delta A .
 eq allNew ({c nlist blist : T } ltq) Delta A = 
     not (occurs (toBounds c blist) Delta A) 
     and allNew ltq Delta A .
 
 
 *** extend a channel context with the names in a typed list
 *** we will do this for new normal forms
 op addChannels__ : TypedCNameList ChannelContext -> ChannelContext .
 eq addChannels emptyTypedCNameList Delta = Delta .   
 eq addChannels (< cn : T > ltq) Delta = addChannels ltq (Delta ((cn @ nil) :: T) ) .
 eq addChannels ({c nlist blist : T } ltq) Delta = addChannels ltq (Delta ((toBounds c blist) :: T)) .

endfm

mod PROTOCOL-EQUALITY is
 protecting PROTOCOL-TYPING .
 protecting REACTION-EQUALITY .
 protecting SET{BoolTerm} .
 protecting SET{Qid} .

 var fns fns1 fns2 cns cns1 cns2 : NameWithScripts . 

 var Sigma : Signature .
 vars Delta D Delta' : ChannelContext .
 vars R R' R1 R2 R3 R4 S1 S2 S : Reaction .
 vars T T0 T1 T2 T3 : Type .
 vars M M1 M2 : Expression .
 vars I I' I'' I1 O O' O'' O1 O2 O3 : Set{CNameBound} . 
 var l r c i o o1 o2 o3 : ChannelName .
 var b x x0 x1 x2 y y0 y1 y2 z : ChannelName . *** was Qid 
 vars P P1 P2 P3 P4 Q : Protocol .
 var n : Nat .
 var lq : List{NatTerm} .
 var ltq ltq1 ltq2 : TypedCNameList .
 var Dist : Distribution .
 var q : Qid .
 var ql ql1 ql2 : CNameList .
     var bt : BoolTerm .  
    var C C' q' : Qid .
    var m : Nat .
  var nt nt1 nt2 : NatTerm .
  var nlist nlist' : List{NatTerm} .
 var cases : Cases .
 var blist blist' : List{Bounds} .
 var cn : ChannelName .
 var bn : CNameBound .   

 
  var BRL : BRList .
 var QL : CNameList .
 var A : Set{BoolTerm} .
 var nlist1 nlist2 : List{NatTerm} . 
  var qid1 qid2 : Qid .
    var q1 q2 : Qid .
  var cn1 cn2 : ChannelName .  
     var T' : Type .
     
      var nj nt' : NatTerm .
     var ntl : List{NatTerm} .
     var bounds : List{Bounds} .
     var cases' : Cases .
     
     
 *** TODO: move elsewhere
 op toJSON__ : Protocol ChannelContext -> JSON .
 eq toJSON emptyProtocol Delta = {} .
  *** eq toJSON (P1 || P2) Delta = {(toJSON P1 Delta) (toJSON P2 Delta)} .
  ***    toJSON(P1 || P2 || P3) 
  *** =  {{P1} {P2 || P3}}
  *** =  {{P1} {{P2} {P3}}}
  *** when I want it to be
  *** = {{P1}{P2}{P3}}      
  *** so I have to do a case distinction for protocols without compositions
  
 eq toJSON (emptyProtocol || P2) Delta = {{} (toJSON P2 Delta)} .
 
 eq toJSON ((cn ::= cases) || P2) Delta =
    insertJSON (toJSON (cn ::= cases) Delta) (toJSON P2 Delta) .
 eq toJSON ((family fns nlist blist ::= cases) || P2) Delta =
    insertJSON (toJSON (family fns nlist blist ::= cases) Delta) (toJSON P2 Delta) . 
 eq toJSON ((new cn : T in P) || P2) Delta =
    insertJSON (toJSON (new cn : T in P) Delta) (toJSON P2 Delta) .
 eq toJSON ((newfamily cn nlist blist : T in P) || P2) Delta =
    insertJSON (toJSON (newfamily cn nlist blist : T in P) Delta) (toJSON P2 Delta) .  
       
 eq toJSON (cn ::= R) (Delta (cn @ nil :: T)) =
           {cname: cn, value: {reaction: R}, hasType: {type: T}, 
            isInternal: false, extras: {}} .
 eq toJSON (cn ::= P) Delta =
           {cname: cn, value: (toJSON P Delta), 
            hasType: {}, isInternal: false, extras: {}} .
 eq toJSON (cn ::= whenList) (Delta (cn @ nil :: T)) =
           {cname: cn, value: (toJSON whenList (Delta (cn @ nil :: T))), 
            hasType: {type: T}, isInternal: false, extras: {}} . 
            
 op toJSON : WhenList ChannelContext -> JSON .
 eq toJSON (whenCond --> R) Delta = {cond: whenCond, reaction: R} .
 eq toJSON (whenCond --> P) Delta = {cond: whenCond, protocol: toJSON P Delta} .
 eq toJSON ((whenCond --> R) ;; whenList) Delta = 
    insertJSON ({cond: whenCond, reaction: R}) (toJSON whenList Delta) . 
 eq toJSON ((whenCond --> P) ;; whenList) Delta = 
    insertJSON ({cond: whenCond, protocol: (toJSON P Delta)}) 
               (toJSON whenList Delta) 
 .
 
 eq toJSON (family fns nlist blist ::= R) (Delta (fns @ nlist' :: T)) =
           {cname: fns, value: {reaction: R}, hasType: {type: T}, isInternal: false,
            extras: {indices: nlist, bounds: blist}
           } .
 eq toJSON (family fns nlist blist ::= P) Delta =
           {cname: fns, value: (toJSON P Delta), 
            hasType: {}, isInternal: false,
            extras: {indices: nlist, bounds: blist}
           } .
 eq toJSON (family fns nlist blist ::= ((whenCond --> R) ;; whenList)
           ) 
           (Delta (fns @ nlist' :: T)) =
           {cname: fns, 
            value: (toJSON 
                     ((whenCond --> R) ;; whenList)
                     (Delta (fns @ nlist' :: T))
                   ), 
            hasType: {type: T}, isInternal: false,
            extras: {indices: nlist, bounds: blist}} .
 eq toJSON (family fns nlist blist ::= ((whenCond --> P) ;; whenList)
           ) 
           Delta =
           {cname: fns, 
            value: (toJSON 
                     ((whenCond --> P) ;; whenList)
                     Delta
                   ), 
            hasType: {}, isInternal: false,
            extras: {indices: nlist, bounds: blist}} .                                      
                      
 eq toJSON (new cn : T in P) Delta = 
      updateInternal(toJSON P (Delta (cn @ nil :: T)), cn) .     
 eq toJSON (newfamily cn nlist blist : T in P) Delta = 
      updateInternal(toJSON P (Delta (toBounds cn blist :: T)), cn) .
                            

 *** similar to reactions, we write configurations

 sort ProtocolConfig . 
 op pConfig : 
              Signature ChannelContext Protocol 
              Set{CNameBound} Set{CNameBound} Set{BoolTerm} -> 
              ProtocolConfig [ctor] .

 ****************
 *** core rules
 ****************
 
 crl [SYM] :
     pConfig(Sigma, Delta, P2, I, O, A) 
     => 
     pConfig(Sigma, Delta, P1, I, O, A)
     if
     pConfig(Sigma, Delta, P1, I, O, A)
     => 
     pConfig(Sigma, Delta, P2, I, O, A) [nonexec] .
     
 
 crl [CONG-REACT] : 
     pConfig(Sigma, Delta, cn ::= R, I, bn, A) 
     =>
     pConfig(Sigma, Delta, cn ::= R', I, bn, A)
     if
     rConfig(Sigma, Delta, emptyTypeContext, R, insert(toBound cn, I), A, typeInCtx(toBound cn, A, Delta))
     =>
     rConfig(Sigma, Delta, emptyTypeContext, R', I', A, T) 
     /\ I' == insert(bn, I)
     /\ T == typeInCtx(bn, A, Delta)
     /\ occurs (toBound cn) Delta A
     /\ bn == toBound cn
     . *** TODO: cn shouldn't be in I!

 crl [CONG-COMP-LEFT] :
     pConfig(Sigma, Delta, P1 || Q, I, O, A) 
     => 
     pConfig(Sigma, Delta, P2 || Q, I, O, A)
     if
     pConfig(Sigma, Delta, P1, union(I, getOutputs(Q)), getOutputs(P1), A)
     => 
     pConfig(Sigma, Delta, P2, I1, O1, A)
     /\ O1 == getOutputs(P1) 
     /\ I1 == union(I, getOutputs(Q))
     /\ typeOf(Sigma, Delta, union(I, getOutputs(P1)), A, Q) 
     /\ O == union(getOutputs(P1), getOutputs(Q))
 .

  crl [CONG-COMP-RIGHT] :
     pConfig(Sigma, Delta, Q || P1, I, O, A) 
     => 
     pConfig(Sigma, Delta, Q || P2, I, O, A)
     if
     pConfig(Sigma, Delta, P1, union(I, getOutputs(Q)), getOutputs(P1), A)
     => 
     pConfig(Sigma, Delta, P2, I1, O1, A)
     ***(
     /\ O1 == getOutputs(P1) 
     /\ I1 == union(I, getOutputs(Q))
     *** the condition below made problems!
     /\ typeOf(Sigma, Delta, union(I, getOutputs(P1)), A, Q) 
     /\ O == union(getOutputs(P1), getOutputs(Q))
     )
     .
   
 crl [CONG-NEW] : 
     pConfig(Sigma, Delta, new cn : T in P1, I, O, A)
     => 
     pConfig(Sigma, Delta, new cn : T in P2, I, O, A)
     if
     pConfig(Sigma, Delta ((toBound cn) :: T),  P1, I, insert(toBound cn, O), A)
     => 
     pConfig(Sigma, Delta',  P2, I, O', A) 
     /\ O' == insert(toBound cn, O)
     /\ Delta' == Delta ((toBound cn) :: T)
     [nonexec] .
     *** /\ P1 =/= P2 .   
     
  *** COMP-COMM and COMP-ASSOC are out, || has these attributes
  *** AXIOM don't requires a new rule, axioms are either equations or have own strategies
  *** EMBED is just application of rules to terms.
  
  crl [NEW-EXCH] :
     pConfig(Sigma, Delta, new cn1 : T1 in new cn2 : T2 in P, I, O, A) 
     => 
     pConfig(Sigma, Delta, new cn2 : T2 in new cn1 : T1 in P, I, O, A)
     if
     typeOf(Sigma, Delta (toBound cn1 :: T1) 
                         (toBound cn2 :: T2), I, A, P) /\
     getOutputs(P) == insert(toBound cn1, insert(toBound cn2, O)) .

 crl [COMP-NEW] :
     pConfig(Sigma, Delta, P || (new cn : T in Q), I, O, A)
     =>  
     pConfig(Sigma, Delta, new cn : T in (P || Q), I, O, A)
     if
     typeOf(Sigma, Delta (toBound cn :: T), union(I, getOutputs(P)), A, Q)
     /\
     typeOf(Sigma, Delta, union(I ,(getOutputs(Q) \ (toBound cn))), A, P) 
 .
 
   crl [COMP-NEW-2] :
     pConfig(Sigma, Delta, new cn : T in (P || Q), I, O, A)
     =>  
     pConfig(Sigma, Delta, P || (new cn : T in Q), I, O, A)
     if
     typeOf(Sigma, Delta (toBound cn :: T), union(I, getOutputs(P)), A, Q)
     /\
     typeOf(Sigma, Delta, union(I ,(getOutputs(Q) \ (toBound cn))), A, P) .

  crl [ABSORB-LEFT] : 
     pConfig(Sigma, Delta, P1 || P2, I, O, A) =>
     pConfig(Sigma, Delta, P1, I, O, A) 
     if
     typeOf(Sigma, Delta, I, A, P1) 
     /\
     typeOf(Sigma, Delta, union(I, O), A, P2) 
     /\
     getOutputs(P1) == O
     /\ 
     getOutputs(P2) == empty
     .
        
 crl [ABSORB-LEFT-2] : 
     pConfig(Sigma, Delta, P1 , I, O, A) =>
     pConfig(Sigma, Delta, P1 || P2, I, O, A) 
     if
     typeOf(Sigma, Delta, I, A, P1) 
     /\
     typeOf(Sigma, Delta, union(I, O), A, P2) 
     /\
     getOutputs(P1) == O
     /\ 
     getOutputs(P2) == empty 
     [nonexec] .    
 
 crl [ABSORB-RIGHT] : 
     pConfig(Sigma, Delta, P1 || P2, I, O, A) =>
     pConfig(Sigma, Delta, P2, I, O, A) 
     if
     typeOf(Sigma, Delta, I, A, P2) 
     /\
     typeOf(Sigma, Delta, union(I, O), A, P1) 
     /\
     getOutputs(P2) == O
     /\ 
     getOutputs(P1) == empty 
 .
 
 crl [DIVERGE] :
     pConfig(Sigma, Delta, cn ::= x : T <- read cn ; R, I, bn, A)
     =>
     pConfig(Sigma, Delta, cn ::= read cn, I, bn, A)
     if
     typeOf(Sigma, Delta, emptyTypeContext, insert(toBound cn, I), A, R) == typeInCtx(toBound cn, A, Delta)
     /\ occurs (toBound cn) Delta A
     /\ bn == toBound cn
      .

 ***(
    crl [FLIP-UNIF] : 
      pConfig(Sigma, Delta,
              cn ::= x : bool <- samp flip ;
                     if x then return True else read cn, I, O, A)
      => 
      pConfig(Sigma, Delta,
              cn ::= x : bool <- samp flip ;
                     if x then read cn else return False , I, O, A)
    if O == toBound cn /\ not isElemB(cn, I, A) /\ elem (toBound cn) bool Delta A .
 )   

 crl [FOLD-IF-RIGHT] :
     pConfig(Sigma, Delta,
             new cn1 : T in ((cn2 ::= b : bool <- R ;
                                if b then S1 else read cn1)
                          ||
                           (cn1 ::= S2))
            ,I, O, A)
     => 
     pConfig(Sigma, Delta,
             cn2 ::= b : bool <- R ;
                   if b then S1 else S2
             , I, O, A)
     if
     typeOf(Sigma, Delta, emptyTypeContext, I, A, R) == bool
     /\
     typeOf(Sigma, Delta, emptyTypeContext, insert(toBound cn2, I), A, S1) == T
     /\
     typeOf(Sigma, Delta, emptyTypeContext, insert(toBound cn2, I), A, S2) == T
     /\
     O == toBound cn2 
     /\
     elem (toBound cn2) T Delta A .
    
  crl [FOLD-IF-LEFT] :
     pConfig(Sigma, Delta,
             new cn2 : T in ((cn1 ::= b : bool <- R ;
                                if b then read cn2 else S2)
                          ||
                           (cn2 ::= S1))
            ,I, O, A)
     => 
     pConfig(Sigma, Delta,
             cn1 ::= b : bool <- R ;
                   if b then S1 else S2
             , I, O, A)
     if
     typeOf(Sigma, Delta, emptyTypeContext, I, A, R) == bool
     /\
     typeOf(Sigma, Delta, emptyTypeContext, insert(toBound cn1, I), A, S1) == T
     /\
     typeOf(Sigma, Delta, emptyTypeContext, insert(toBound cn1, I), A, S2) == T
     /\
     O == toBound cn1 
     /\
     elem (toBound cn1) T Delta A .

  crl [FOLD-BIND] :
     pConfig(Sigma, Delta, 
             new c : T in ((o ::= x : T <- read c ; S)
                           ||
                           (c ::= R)),
             I, O, A)
     =>
     pConfig(Sigma, Delta,
             o ::= x : T <- R ; S,
             I, O, A)
    if O == toBound o .
   
  crl [FOLD-BIND-2] :
     pConfig(Sigma, Delta, 
             o ::= x : T <- R ; S,
             I, O, A)
     =>
     pConfig(Sigma, Delta,
             new c : T in ((o ::= x : T <- read c ; S)
                           ||
                           (c ::= R)),
             I, O, A)
    if O == toBound o [nonexec] . 
    
 crl [SUBSUME] :
    pConfig(Sigma, Delta, 
            (cn1 ::= x0 : T0 <- read i ; R1) || 
            (cn2 ::= x0 : T0 <- read i ; x1 : T1 <- read cn1 ; R2) 
           , I, O, A)
    => 
    pConfig(Sigma, Delta,
            (cn1 ::= x0 : T0 <- read i ; R1) || 
            (cn2 ::= x1 : T1 <- read cn1 ; R2)  
           , I, O, A)
   if typeOf(Sigma, Delta, x1 : T1, insert(toBound cn1, insert(toBound cn2, I)), A, R2) == 
      typeInCtx(toBound cn2, A, Delta) 
   /\ O == insert(toBound cn1, insert(toBound cn2, empty)) /\ cn1 =/= cn2 /\
   elem (toBound cn1) T1 Delta A . 
   
 crl [DROP] : 
   pConfig(Sigma, Delta,
           (cn1 ::= R1) || (cn2 ::= x1 : T1 <- read cn1 ; R2)
          ,I, O, A)
   => 
   pConfig(Sigma, Delta,
           (cn1 ::= R1) || (cn2 ::= R2)
          ,I, O, A)
   if rConfig(Sigma, Delta, emptyTypeContext, 
              x1 : T1 <- R1 ; R2
             , insert(toBound cn1, insert(toBound cn2, I)), A, typeInCtx(toBound cn2, A, Delta)) 
      => 
      rConfig(Sigma, Delta, emptyTypeContext, 
              R2
             ,I', A, T2) /\
      T2 == typeInCtx(toBound cn2, A, Delta) /\    
      I' == insert(toBound cn1, insert(toBound cn2, I)) /\
      O == insert(toBound cn1, insert(toBound cn2, empty)) /\
      typeOf(Sigma, Delta, emptyTypeContext, 
             insert(toBound cn1, insert(toBound cn2, I)), A, R2) 
      == 
      typeInCtx(toBound cn2, A, Delta) /\ 
      cn1 =/= cn2 /\
      elem (toBound cn1) T1 Delta A
      [nonexec] .
  
   crl [SUBST] : 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= x1 : T1 <- read cn1 ; R2),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= x1 : T1 <- R1 ; R2),
             I, O, A) 
     if
     rConfig(Sigma, Delta, emptyTypeContext,
             x1 : T1 <- R1 ; x2 : T1 <- R1 ; return pair(x1, x2),
             insert(toBound cn1, insert(toBound cn2, I)), A, 
             T1 * typeInCtx(toBound cn2, A, Delta) )
     => 
     rConfig(Sigma, Delta, emptyTypeContext,
             x1 : T1 <- R1 ;  return pair(x1, x1),
             I', A, T' ) /\
     T' ==  T1 * typeInCtx(toBound cn2, A, Delta) /\       
     O == insert(toBound cn1, toBound cn2) /\ 
     I' == insert(toBound cn1, insert(toBound cn2, I)) /\
     cn1 =/= cn2 /\
     elem (toBound cn1) T1 Delta A
     [nonexec] .
 
     
   crl [SUBST-2] : 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= x1 : T1 <- R1 ; R2),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= x1 : T1 <- read cn1 ; R2),
             I, O, A) 
     if
     rConfig(Sigma, Delta, emptyTypeContext,
             x1 : T1 <- R1 ; x2 : T1 <- R1 ; return pair(x1, x2),
             insert(toBound cn1, insert(toBound cn2, I)), A, T1 * typeInCtx(toBound cn2, A, Delta))
     => 
     rConfig(Sigma, Delta , emptyTypeContext,
             x1 : T1 <- R1 ;  return pair(x1, x1),
             I', A, T') /\
     T' ==  T1 * typeInCtx(toBound cn2, A, Delta) /\         
     O == insert(toBound cn1, insert(toBound cn2, empty)) /\ 
     I' == insert(toBound cn1, insert(toBound cn2, I)) /\
     cn1 =/= cn2 /\
     elem (toBound cn1) T1 Delta A
       [nonexec] .     
 
 ********************************************
 *** derived rules and rules for normal forms
 ********************************************
 
 rl [desugar-newNF] :
     pConfig(Sigma, Delta, newNF(ltq, P1, ql), I, O, A)
     =>
     pConfig(Sigma, Delta, newNF2New(newNF(ltq, P1, ql)), I, O, A) 
 .
     
 rl [sugar-newNF] :
    pConfig(Sigma, Delta, P, I, O, A)
    => 
    pConfig(Sigma, Delta, new2NF(P), I, O, A) 
 .
    
 rl [delete-empty-newNF] :
     pConfig(Sigma, Delta, newNF(emptyTypedCNameList, P, emptyCNameList), I, O, A)
     => 
     pConfig(Sigma, Delta, P, I, O, A) 
 . 
     
 rl [reorder-newNF] :
     pConfig(Sigma, Delta, newNF(ltq, P, ql1), I, O, A)
     =>
     pConfig(Sigma, Delta, newNF(ltq, P, ql2), I, O, A)
    [nonexec]
 . *** check that same names occur in ql1 and ql2
        
  crl [CONG-NEW-NF] : 
    pConfig(Sigma, Delta, newNF(ltq, P1, ql), I, O, A) 
    => 
    pConfig(Sigma, Delta, newNF(ltq, P2, ql), I, O, A)
    if
    pConfig(Sigma, addChannels ltq Delta, P1, I, union(chansInList ltq, O), A)
    =>
    pConfig(Sigma, Delta', P2, I, O', A) 
    /\
    Delta' == addChannels ltq Delta
    /\
    O' == union(chansInList ltq, O)
  .    
 
 crl [absorb-new-nf] :
     pConfig(Sigma, Delta, newNF(< c : T > ltq, P || (c ::= R), ql), I, O, A) 
     => 
     pConfig(Sigma, Delta, newNF(ltq, P, del c ql), I, O, A) 
 if
     typeOf(Sigma, addChannels ltq (Delta (toBound c :: T)), emptyTypeContext, 
            insert(toBound c, union(I, getOutputs(P))), A, R) == T 
     /\
     typeOf(Sigma, addChannels ltq Delta, I, A, P)       
     /\ 
     getOutputs(newNF2New(newNF(ltq, P, ql))) == O 
   .
   
 crl [comp-new-nf-left] : 
     pConfig(Sigma, Delta, newNF(< c : T > ltq, P || (c ::= R), ql), I, O, A) 
    => 
     pConfig(Sigma, Delta, newNF(ltq, P || new c : T in (c ::= R), del c ql), I, O, A) 
    if
     typeOf(Sigma, addChannels ltq Delta, I, A, P) 
     /\
     typeOf(Sigma, addChannels ltq (Delta ((toBound c) :: T)), emptyTypeContext, 
            insert(toBound c, union(I, getOutputs(P))), A, R) == T 
 . 
      
 crl [comp-new-nf-right] :   *** TODO! where we add c
    pConfig(Sigma, Delta, newNF(ltq, P || new c : T in Q, ql), I, O, A)
    =>
    pConfig(Sigma, Delta, newNF(< c : T > ltq, P || Q, c :: ql), I, O, A) 
    if
     typeOf(Sigma, addChannels ltq Delta, union(I, getOutputs(Q)), A, P) 
     /\
     typeOf(Sigma, addChannels ltq (Delta ((toBound c) :: T)), union(I, getOutputs(P)), A, Q) 
 .
 
  crl [fold-bind-new] :
    pConfig(Sigma, Delta, 
             newNF(< c : T > ltq, P || (c ::= R) || (o ::= x : T <- read c ; S), ql),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, P || (o ::= x : T <- R ; S), del c ql),
            I, O, A) 
    if 
    typeOf(Sigma, addChannels ltq (Delta ((toBound c) :: T)), emptyTypeContext, 
            insert(toBound o, insert(toBound c, union(I, getOutputs(P)))), A, R) == T . 
           
  crl [fold-bind-new-nf] :
    pConfig(Sigma, Delta, 
             newNF(< c : T > ltq, P || (c ::= R) || 
                                 (o ::= nf((x : T <- read c) BRL, S, QL)), 
                   ql),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, P || (o ::= preNF((x : T <~ R) BRL, S, QL)), del c ql),
            I, O, A) 
    if typeOf(Sigma, addChannels ltq (Delta ((toBound c):: T)), addDeclarations BRL emptyTypeContext, 
            insert(toBound o, insert(toBound c, union(I, getOutputs(P)))), A, R) == T 
  .  *** TODO: here and below, S matches type of o in Delta! 
  
  crl [fold-bind-new-nf-0] :
    pConfig(Sigma, Delta, 
             newNF(< c : T > ltq, (c ::= R) || 
                                 (o ::= nf((x : T <- read c) BRL, S, QL)), 
                   ql),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, (o ::= preNF((x : T <~ R) BRL, S, QL)), del c ql),
            I, O, A) 
    if typeOf(Sigma, addChannels ltq (Delta ((toBound c):: T)), addDeclarations BRL emptyTypeContext, 
            insert(toBound o, insert(toBound c, I )), A, R) == T 
  .  *** TODO: here and below, S matches type of o in Delta! 
            
  crl [fold-bind-new-prenf] :
    pConfig(Sigma, Delta, 
             newNF(< c : T > ltq, P || (c ::= R) || 
                                 (o ::= preNF((x : T <- read c) BRL, S, QL)), ql),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, P || (o ::= preNF((x : T <~ R) BRL, S, QL)), del c ql),
            I, O, A) 
    if        
    typeOf(Sigma, addChannels ltq (Delta ((toBound c) :: T)), emptyTypeContext, 
            insert(toBound o, insert(toBound c, union(I, getOutputs(P)))), A, R) == T .
            
 crl [COMP-NEW-newNF] :
     pConfig(Sigma, Delta, P || newNF(ltq, Q, QL), I, O, A)
     =>   
     pConfig(Sigma, Delta, newNF(ltq, P || Q, QL), I, O, A)
 if
     typeOf(Sigma, addChannels ltq Delta, union(I, getOutputs(P)), A, Q)
     *** /\
     *** typeOf(Sigma, Delta, I, *** was  union(I, getOutputs(newNF(ltq, Q, QL))), 
     ***       A, P)     
 .
   
   rl [lift-inner-new-nf] :
     pConfig(Sigma, Delta, newNF(ltq1, newNF(ltq2, P, ql2) , ql1), I, O, A)
     => 
     pConfig(Sigma, Delta, newNF(ltq1 ltq2, P, ql1 ++ ql2), I, O, A)
   .
   
  *** this rule is actually derived from drop and samp-pure!    
  crl [DROP-nf] :
    pConfig(Sigma, Delta,
            (cn1 ::= samp Dist) || (cn2 ::= nf( (x : T1 <- read cn1) BRL , R2, QL) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (cn1 ::= samp Dist) || (cn2 ::= nf( BRL , R2, del x QL) ),
            I, O, A) 
    if
     typeOf(Sigma, Delta, addDeclarations BRL (x : T1), 
             insert(toBound cn1, insert(toBound cn2, I)), A, R2) == typeInCtx(toBound cn2, A, Delta)
     /\
     elem (toBound cn1) T1 Delta A        
    . 
    
   crl [DROP-nf-copy] :
    pConfig(Sigma, Delta,
            (cn1 ::= nf(emptyBRList, samp Dist, emptyCNameList)) || 
            (cn2 ::= nf( (x : T1 <- read cn1) BRL , R2, QL) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (cn1 ::= nf(emptyBRList, samp Dist, emptyCNameList)) || 
            (cn2 ::= nf( BRL , R2, del x QL) ),
            I, O, A) 
    if 
     typeOf(Sigma, Delta, addDeclarations BRL (x : T1), 
             insert(toBound cn1, insert(toBound cn2, I)), A, R2) == typeInCtx(toBound cn2, A, Delta)
     /\
     elem (toBound cn1) T1 Delta A
    .  
    
   crl [DROP-nf-channels] :
    pConfig(Sigma, Delta,
            (cn1 ::= nf(BRL, samp Dist, QL)) || 
            (cn2 ::= nf( (x : T1 <- read cn1) BRL' , R2, QL') ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (cn1 ::= nf(BRL, samp Dist, QL)) || 
            (cn2 ::= nf( BRL' , R2, del x QL') ),
            I, O, A) 
    if 
     typeOf(Sigma, Delta, addDeclarations BRL (x : T1), 
             insert(toBound cn1, insert(toBound cn2, I)), A, R2) == typeInCtx(toBound cn2, A, Delta)
     /\
     elem (toBound cn1) T1 Delta A
    .    
    
    
  *** this rule is derived from drop and subsume
  crl [DROP-SUBSUME-families] :
    pConfig(Sigma, Delta,
            (family fns1 i (bound nt1) ::= nf(BRL, samp Dist, QL)) || 
            (family fns2 i (bound nt2) ::= nf( (x : T1 <- read (fns1[i])) BRL' , R2, QL') ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (family fns1 i (bound nt1) ::= nf(BRL, samp Dist, QL)) || 
            (family fns2 i (bound nt2) ::= nf(BRL BRL' , R2, del x (QL ++ QL')) ),
            I, O, A) 
    if 
     typeOf(Sigma, Delta, addDeclarations BRL (x : T1), 
             insert(fns1 @ nt1, insert(fns2 @ nt2, I)), A, R2) 
     == 
     typeInCtx(fns2 @ nt2, A, Delta)
     /\
     elem (fns1 @ nt1) T1 Delta A
    .   
    
    crl [DROP-SUBSUME-channels] :
    pConfig(Sigma, Delta,
            (cn1 ::= nf(BRL, samp Dist, QL)) || 
            (cn2 ::= nf( (x : T1 <- read cn1) BRL' , R2, QL') ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (cn1 ::= nf(BRL, samp Dist, QL)) || 
            (cn2 ::= nf(BRL BRL' , R2, del x (QL ++ QL')) ),
            I, O, A) 
    if 
     typeOf(Sigma, Delta, addDeclarations BRL (x : T1), 
             insert(toBound cn1, insert(toBound cn2, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta)
     /\
     elem (toBound cn1) T1 Delta A
    .  
                   
  crl [DROP-pre-nf] :
    pConfig(Sigma, Delta,
            (cn1 ::= samp Dist) || (cn2 ::= preNF( (x : T1 <- read cn1) BRL , R2, QL) ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (cn1 ::= samp Dist) || (cn2 ::= preNF( BRL , R2, del x QL) ),
            I, O, A) 
     if
     typeOf(Sigma, Delta, addDeclarations BRL (x : T1), 
             insert(toBound cn1, insert(toBound cn2, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta)
             /\
     elem (toBound cn1) T1 Delta A 
     .   
     
  var x3 : Qid .   
     
  crl [subst-diverge] : 
    pConfig(Sigma, Delta, 
              (cn1 ::= nf(x1 : T1 <- read cn1, return x1, x1 :: emptyCNameList))
              || 
              (cn2 ::= nf( (x2 : T1 <- read cn1) BRL , R2, QL)),
              I, O, A
           )    
    =>
    pConfig(Sigma, Delta, 
              (cn1 ::= nf(x1 : T1 <- read cn1, return x1, x1 :: emptyCNameList))
              || 
              (cn2 ::= nf(x3 : T2 <- read cn2, return x3, x3 :: emptyCNameList)),
              I, O, A
           ) 
   if        
   O == insert(toBound cn1, toBound cn2)
   /\
     elem (toBound cn1) T1 Delta A
     /\
     elem (toBound cn2) T2 Delta A
     /\
     typeOf(Sigma, Delta, addDeclarations BRL (x2 : T1), 
            insert(toBound cn1, insert(toBound cn2, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta)   
           [nonexec] *** because x3 is new and T2 must be specified as well!
  .                 
   
  crl [SUBST-nf] : 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= nf( (x1 : T1 <- read cn1) BRL , R2, QL) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= preNF((x1 : T1 <~ R1) BRL , R2, QL)),
             I, O, A) 
     if isSampFree(R1) /\
        O == insert(toBound cn1, toBound cn2) /\ 
     typeOf(Sigma, Delta, emptyTypeContext, 
            insert(toBound cn1, insert(toBound cn2, I)), A, R1) == T1 /\
     typeOf(Sigma, Delta, addDeclarations BRL (x1 : T1), 
            insert(toBound cn1, insert(toBound cn2, I)), A, R2) == typeInCtx(toBound cn2, A, Delta)
     /\
     elem (toBound cn1) T1 Delta A 
     . 
     
     
  crl [moveReadInnerNf] :
    pConfig(Sigma, Delta,
             cn1 ::= nf((x : T <- read cn2) BRL , R1, QL) ,
             I, O, A)  
     => 
       pConfig(Sigma, Delta,
             cn1 ::= preNF(BRL , x : T <- read cn2 ; R1, del x QL) ,
             I, O, A)    
  if elem (toBound cn2) T Delta A 
  /\ typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(toBound cn1, I), A, R1) == typeInCtx(toBound cn1, A, Delta)
  .  
  
    crl [moveReadInnerPreNf] :
    pConfig(Sigma, Delta,
             cn1 ::= preNF((x : T <- read cn2) BRL , R1, QL) ,
             I, O, A)  
     => 
       pConfig(Sigma, Delta,
             cn1 ::= preNF(BRL , x : T <- read cn2 ; R1, del x QL) ,
             I, O, A)  
    if elem (toBound cn2) T Delta A 
     /\ typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(toBound cn1, I), A, R1) == typeInCtx(toBound cn1, A, Delta)          
  .   
  
  *** TODO : validate this rule!   
  rl [SUBST-nf-rev] : 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= preNF( BRL , R1, QL) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (cn2 ::= preNF((x1 : T1 <- read cn1) BRL , return x1, x1 :: QL)),
             I, O, A)   
  [nonexec] .  
  
  crl [SUBST-nf-read] : 
     pConfig(Sigma, Delta,
             (cn1 ::= nf((x2 : T1 <- read cn), return x2, x2 :: emptyCNameList )) || 
             (cn2 ::= nf( (x1 : T1 <- read cn1) BRL , R2, QL) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (cn1 ::= nf((x2 : T1 <- read cn), return x2, x2 :: emptyCNameList )) || 
             (cn2 ::= nf((x2 : T1 <- read cn) BRL , R2 [x1 / x2], replace x1 x2 QL)),
             I, O, A) 
     if
     isElemB(cn, I, A) /\
     O == insert(toBound cn1, toBound cn2) /\ 
     typeOf(Sigma, Delta, addDeclarations BRL (x1 : T1), 
             insert(toBound cn1, insert(toBound cn2, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta)
             /\
     elem (toBound cn1) T1 Delta A 
             /\
     elem (toBound cn) T1 Delta A           
     .   
 
 *********************
 *** rules for families
 *********************
 
  crl [CONG-REACT-family] : 
     pConfig(Sigma, Delta, family fns q (bound n) ::= R, I, fns @ n, A) 
     =>
     pConfig(Sigma, Delta, family fns q (bound n) ::= R', I, fns @ n, A)
     if
     rConfig(Sigma, Delta, emptyTypeContext, R, insert(fns @ n, I), A, 
             typeInCtx(fns @ n, A, Delta))
     =>
     rConfig(Sigma, Delta, emptyTypeContext, R', I', A, T) 
     /\ I' == insert(fns @ n, I)
     /\ T == typeInCtx(fns @ n, A, Delta)
     /\ occurs (fns @ n) Delta A
     . *** TODO: fns @ n shouldn't be in I!
 
 *** rename variable in cases
 op alphaCases___ : Cases Qid Qid -> Cases .
 eq alphaCases R q q' = replaceVars(R, q |-> q') .
 eq alphaCases (when bt --> R) q q' = when (subst(bt, q |-> q')) --> replaceVars(R, q |-> q') .
 eq alphaCases (otherwise --> R) q q' = otherwise --> replaceVars(R, q |-> q') .
 eq alphaCases ((whenCond --> R) ;; whenList) q q' =
    (alphaCases (whenCond --> R) q q') 
    ;;
    (alphaCases whenList q q')
 .   
 
  rl [alpha-family] :
   pConfig(Sigma, Delta, 
            newNF(ltq {fns q (bound n) : T}, 
                  P || family fns q (bound n) ::= cases, QL), 
           I, O, A)
   => 
   pConfig(Sigma, Delta, 
            newNF(ltq {C q' (bound n) : T}, 
                  P || (family fns q' (bound n) ::= (alphaCases cases q q')), QL), 
           I, O, A)
 [nonexec]
 .
 
 var q3 q4 q5 q6 : Qid .
 
   rl [alpha-family-three] :
   pConfig(Sigma, Delta, newNF(ltq {fns (q1 q2 q3) (b1 b2 b3) : T}, 
           P || family fns (q1 q2 q3) (b1 b2 b3)  ::= cases, QL), I, O, A)
   => 
   pConfig(Sigma, Delta, newNF(ltq {fns (q4 q5 q6) (b1 b2 b3)  : T}, 
            P || (family fns (q4 q5 q6) (b1 b2 b3) ::= 
                    (alphaCases (alphaCases (alphaCases (alphaCases (alphaCases 
                      (alphaCases cases q1 '1) 
                      q2 '2) q3 '3) '1 q4) '2 q5) '3 q6)                
                 ), QL), I, O, A)
 [nonexec]
 .
  
 rl [alpha-branch] :
   pConfig(Sigma, Delta, 
            
              P || family fns q (bound n) ::= 
                (whenList1 ;; 
                 (whenCond --> nf((q1 : T1 <- R1) BRL, R2, ql)) ;;
                  whenList2), 
              I, O, A)
   => 
   pConfig(Sigma, Delta, 
        
              P || family fns q (bound n) ::= 
                 (whenList1 ;; 
                 (whenCond --> nf((q2 : T1 <- R1) BRL, R2 [q1 / q2], replace q1 q2 ql)) ;;
                  whenList2), 
              I, O, A)
 [nonexec]
 .
 
 rl [alpha-branch-channel] :
   pConfig(Sigma, Delta,  
              P || cn ::= 
                (whenList1 ;; 
                 (whenCond --> nf((q1 : T1 <- R1) BRL, R2, ql)) ;;
                  whenList2), 
              I, O, A)
   => 
   pConfig(Sigma, Delta,  
              P || cn ::= 
                 (whenList1 ;; 
                 (whenCond --> nf((q2 : T1 <- R1) BRL, R2 [q1 / q2], replace q1 q2 ql)) ;;
                  whenList2), 
              I, O, A)
 [nonexec]
 .
  
 rl [addToGroup] :
   pConfig(Sigma, Delta, 
            (family fns1 q (bound nt) ::= P) || family fns2 q' (bound nt1) ::= cases, 
           I, O, A)
   => 
   pConfig(Sigma, Delta, 
             family fns1 q (bound nt) ::= (P || family fns2 q' (bound nt1) ::= cases), 
           I, O, A)
 . 
 
  rl [addToGroupCases-end] : 
   pConfig(Sigma, Delta, 
           (family fns1 nlist blist ::= (whenCond --> P)) 
           ||
           (family fns2 nlist' blist' ::= cases), I, O, A)
   =>
   pConfig(Sigma, Delta, 
           (family fns1 nlist blist ::= 
             (whenCond --> (P || (family fns2 nlist' blist' ::= cases))
             )
           ) 
           ,
           I, O, A 
           ) 
 . 
 
 crl [addToGroupCases] :
   pConfig(Sigma, Delta, 
           (family fns1 nlist blist ::= (whenCond --> P) ;; whenList) 
           ||
           (family fns2 nlist' blist' ::= cases), I, O, A)
   =>
   pConfig(Sigma, Delta, 
           (family fns1 nlist blist ::= 
             (whenCond --> P || (family fns2 nlist' blist' ::= cases)) ;; 
             whenList'
           ) 
           ,
           I, O, A 
           )
   if 
   pConfig(Sigma, Delta, 
           (family fns1 nlist blist ::= whenList) 
           ||
           (family fns2 nlist' blist' ::= cases), I, O, A)
   =>
   pConfig(Sigma, Delta, 
           (family fns1 nlist blist ::= 
             whenList'
           ) 
           ,
           I, O, A 
           )       
 .                          
    
 
  *** TODO: old idea, perhaps remove it
  crl [proof-composition] :
    pConfig(Sigma, Delta, P1, I, O, A) 
    => 
    pConfig(Sigma, Delta, P2, I, O, A)
    if
    isIndepComp 'any P1 *** the qid does not matter here!
    /\
    pConfig(Sigma, Delta, projZero P1, I, O, A)
    => 
    pConfig(Sigma, Delta, P3, I, O, A)
    /\
    P3 == projZero P2 [nonexec] .
  
  ***( these rules are subsumed by the one below, 
       leave them here until we check that all still works as before!
    
  crl [absorb-new-nf-family-one] : 
     pConfig(Sigma, Delta, 
             newNF({C q (bound n) : T }  ltq, P || (family C q (bound n) ::= cases), ql), 
             I, O, A) 
     => 
     pConfig(Sigma, Delta, newNF(ltq, P, del C ql), I, O, A) 
  if
     typeOf(Sigma, addChannels ({C q (bound n) : T }  ltq) Delta, 
            insert(C @ n, union(I, getOutputs(P))), A, family C q (bound n) ::= cases)
     /\
     typeOf(Sigma, addChannels ltq Delta, I, A, P)       
     /\ 
     getOutputs(newNF2New(newNF(ltq, P, ql))) == O 
 .
 
 crl [absorb-new-nf-family-two] : 
     pConfig(Sigma, Delta, 
             newNF({C (q q')((bound n) (bound nt)) : T }  ltq, 
                   P || (family C (q q')((bound n) (bound nt)) ::= cases), ql), 
             I, O, A) 
     => 
     pConfig(Sigma, Delta, newNF(ltq, P, del C ql), I, O, A) 
 if typeOf(Sigma, 
           addChannels ({C (q q')((bound n) (bound nt)) : T } ltq) Delta, 
           insert(C @ (n nt), union(I, getOutputs(P))), 
           A, 
           family C (q q')((bound n) (bound nt)) ::= cases
          )
     /\
     typeOf(Sigma, addChannels ltq Delta, I, A, P)       
     /\ 
     getOutputs(newNF2New(newNF(ltq, P, ql))) == O     
 .  
 )
 
 crl [absorb-new-nf-family] : 
     pConfig(Sigma, Delta, 
             newNF({fns nlist blist : T }  ltq, 
                   P || (family fns nlist blist ::= cases), ql), 
             I, O, A) 
     => 
     pConfig(Sigma, Delta, newNF(ltq, P, del fns ql), I, O, A) 
 if typeOf(Sigma, 
           addChannels ({fns nlist blist : T } ltq) Delta, 
           insert(toBounds fns blist, union(I, getOutputs(P))), 
           A, 
           family fns nlist blist ::= cases
          )
     /\
     typeOf(Sigma, addChannels ltq Delta, I, A, P)       
     /\ 
     getOutputs(newNF2New(newNF(ltq, P, ql))) == O     
 .  
 
      
 crl [absorb-reverse-new-nf-family] : 
     pConfig(Sigma, Delta, newNF(ltq, P, ql), I, O, A)
     =>
     pConfig(Sigma, Delta, 
             newNF({fns nlist blist : T } ltq, 
                   P || (family fns nlist blist ::= cases), fns :: ql), I, O, A) 
 if   
     typeOf(Sigma, addChannels ltq Delta, I, A, P) 
     /\
     typeOf(Sigma, addChannels ({fns nlist blist : T } ltq) Delta, 
             insert(toBounds fns blist, union(I, O)), A,
             (family fns nlist blist ::= cases)) 
     /\
     getOutputs(newNF2New(newNF(ltq, P, ql))) == O 
 [nonexec] 
 . 
     
   crl [comp-new-nf-right-family] :   *** TODO! where we add fns
    pConfig(Sigma, Delta, newNF(ltq, P || newfamily fns nlist blist : T in Q, ql), I, O, A)
    =>
    pConfig(Sigma, Delta, newNF({ fns nlist blist : T } ltq, P || Q, fns :: ql), I, O, A) 
    if
     typeOf(Sigma, addChannels ltq Delta, union(I, getOutputs(Q)), A, P) 
     /\
     typeOf(Sigma, addChannels ltq (Delta ((toBounds fns blist) :: T)), 
            union(I, getOutputs(P)), A, Q) 
    .   
    
    rl [COMP-NEW-newNF-newfamily] :
     pConfig(Sigma, Delta, P || (newfamily fns nlist blist : T in Q), I, O, A)
     =>  
     pConfig(Sigma, Delta, 
              newNF( {fns nlist blist : T}, P || Q, fns :: emptyCNameList), I, O, A)
     ***( if 
     typeOf(Sigma, Delta ((toBounds fns blist) :: T), union(I, getOutputs(P)), A, Q)
     /\
     typeOf(Sigma, Delta, union(I ,(getOutputs(Q) \ (toBounds fns blist))), A, P) 
     ) .              
 
 crl [moveReadInnerNfFamily] :
    pConfig(Sigma, Delta,
             family fns lq blist ::= nf((x : T <- read cn2) BRL , R1, QL) ,
             I, O, A)  
     => 
       pConfig(Sigma, Delta,
             family fns lq blist ::= preNF(BRL , x : T <- read cn2 ; R1, del x QL) ,
             I, O, A)
   if          
   elem (toBound cn2) T Delta A 
  /\ typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(toBounds fns blist , I), A, R1) 
     == 
     typeInCtx(toBounds fns blist, A, Delta)              
  .  
  
    crl [moveReadInnerPreNfFamily] :
    pConfig(Sigma, Delta,
             family fns lq blist ::= preNF((x : T <- read cn2) BRL , R1, QL) ,
             I, O, A)  
     => 
       pConfig(Sigma, Delta,
             family fns lq blist ::= preNF(BRL , x : T <- read cn2 ; R1, del x QL) ,
             I, O, A) 
             if          
   elem (toBound cn2) T Delta A 
  /\ typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(toBounds fns blist , I), A, R1) 
     == 
     typeInCtx(toBounds fns blist, A, Delta)          
  . 
  
  *** drop for families
  
    crl [DROP-nf-families] :
    pConfig(Sigma, Delta,
            (family fns1 i (bound nt) ::= nf(BRL, samp Dist, QL)) 
            || 
            (family fns2 i (bound nt) ::= nf( (x : T1 <- read (fns1[nj])) BRL', R2, QL') ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (family fns1 i (bound nt) ::= nf(BRL, samp Dist, QL)) 
            || 
            (family fns2 i (bound nt) ::= nf( BRL', R2, del x QL') ),
            I, O, A) 
    if
     typeOf(Sigma, Delta, addDeclarations BRL' (x : T1), 
             insert(fns1 @ nt, insert(fns2 @ nt, I)), A, R2) == typeInCtx(fns2 @ nt, A, Delta)
     /\
     elem (fns1 @ nt) T1 Delta A        
    . 
    
  *** drop for channel-family  
  crl [DROP-nf-cf] :
      pConfig(Sigma, Delta,
            (family fns i (bound nt) ::= nf(BRL, samp Dist, QL)) 
            || 
            (cn ::= nf( (x : T1 <- read (fns[nj])) BRL', R2, QL') ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (family fns i (bound nt) ::= nf(BRL, samp Dist, QL)) 
            || 
            (cn ::= nf( BRL', R2, del x QL') ),
            I, O, A) 
    if
     typeOf(Sigma, Delta, addDeclarations BRL' (x : T1), 
             insert(fns @ nt, insert(cn @ nil, I)), A, R2) == typeInCtx(cn @ nil, A, Delta)
     /\
     elem (fns @ nt) T1 Delta A
  .
  
   *** drop for channel-family with cases 
  crl [DROP-nf-cf-cases] :
      pConfig(Sigma, Delta,
            (family fns i (bound nt) ::= 
               whenList1 ;;
               (when bt --> nf(BRL, samp Dist, QL)) ;;
               whenList2
            ) 
            || 
            (cn ::= nf( (x : T1 <- read (fns[nj])) BRL', R2, QL') ),
            I, O, A) 
    =>           
     pConfig(Sigma, Delta,
            (family fns i (bound nt) ::= 
               whenList1 ;;
               (when bt --> nf(BRL, samp Dist, QL)) ;;
               whenList2
            ) 
            || 
            (cn ::= nf( BRL', R2, del x QL') ),
            I, O, A) 
    if A |= bt with i |-> nj /\
     typeOf(Sigma, Delta, addDeclarations BRL' (x : T1), 
             insert(fns @ nt, insert(cn @ nil, I)), A, R2) == typeInCtx(cn @ nil, A, Delta)
     /\
     elem (fns @ nt) T1 Delta A
  .
  
  
  *** subsume reverse for families
  
  var BRL' : BRList .
  var QL' : CNameList .
  
   crl [subsume-families-one-rev] :
    pConfig(Sigma, Delta, 
            (family fns1  i (bound nt) ::= nf((x0 : T0 <- read cn) BRL, R1, QL)) || 
            (family fns2 i (bound nt) ::= nf((x1 : T1 <- read (fns1[nj])) BRL', R2, QL')) 
           , I, O, A)
    => 
    pConfig(Sigma, Delta,
            (family fns1  i (bound nt) ::= nf((x0 : T0 <- read cn) BRL, R1, QL)) || 
            (family fns2 i (bound nt) ::= 
               nf((x0 : T0 <- read cn) 
                  (x1 : T1 <- read (fns1[nj])) BRL', 
                  R2, 
                  addBefore x0 x1 QL')  
            )      
           , I, O, A)
   if typeOf(Sigma, Delta, x1 : T1, insert(fns1 @ nt, insert(fns2 @ nt, I)), A, R2) == 
      typeInCtx(fns2 @ nt, A, Delta) 
   /\ O == insert(fns1 @ nt, insert(fns2 @ nt, empty)) /\ fns1 =/= fns2 /\
   elem (fns1 @ nt) T1 Delta A 
   .
   
   crl [subsume-channels-one-rev] :
    pConfig(Sigma, Delta, 
            (cn1 ::= nf((x0 : T0 <- read cn) BRL, R1, QL)) || 
            (cn2 ::= nf((x1 : T1 <- read cn1) BRL', R2, QL')) 
           , I, O, A)
    => 
    pConfig(Sigma, Delta,
            (cn1 ::= nf((x0 : T0 <- read cn) BRL, R1, QL)) || 
            (cn2 ::= 
               nf((x0 : T0 <- read cn) 
                  (x1 : T1 <- read cn1) BRL', 
                  R2, 
                  addBefore x0 x1 QL')  
            )      
           , I, O, A)
   if typeOf(Sigma, Delta, x1 : T1, insert(toBound cn1, insert(toBound cn2, I)), A, R2) == 
      typeInCtx(toBound cn2, A, Delta) 
   /\ O == insert(toBound cn1, insert(toBound cn2, empty)) /\ cn1 =/= cn2 /\
   elem (toBound cn1) T1 Delta A 
   .
   crl [subsume-channels-family-one-rev] :
    pConfig(Sigma, Delta, 
            (family fns i (bound nt) ::= nf((x0 : T0 <- read cn) BRL, R1, QL)) || 
            (cn2 ::= nf((x1 : T1 <- read (fns[nj])) BRL', R2, QL')) 
           , I, O, A)
    => 
    pConfig(Sigma, Delta,
            (family fns i (bound nt) ::= nf((x0 : T0 <- read cn) BRL, R1, QL)) || 
            (cn2 ::= 
               nf((x0 : T0 <- read cn) 
                  (x1 : T1 <- read (fns[nj])) BRL', 
                  R2, 
                  addBefore x0 x1 QL')  
            )      
           , I, O, A)
   if typeOf(Sigma, Delta, x1 : T1, insert(fns @ nt, insert(toBound cn2, I)), A, R2) == 
      typeInCtx(toBound cn2, A, Delta) 
   /\ O == insert(fns @ nt, insert(toBound cn2, empty)) /\ fns =/= cn2 /\
   elem (fns @ nt) T1 Delta A 
   .
   
   crl [subsume-family-cases-channel] :
     pConfig(Sigma, Delta, 
            (family fns i (bound nt) ::= cases) || 
            (cn2 ::= nf((x1 : T1 <- read (fns[nj])) BRL, R, QL)) 
           , I, O, A)
    => 
     pConfig(Sigma, Delta, 
            (family fns i (bound nt) ::= cases) || 
            (cn2 ::= R2) 
           , I, O, A)
    if  
     pConfig(Sigma, Delta, 
            (projectIndex (family fns i (bound nt)  ::= cases) nj A empty) || 
            (cn2 ::= nf((x1 : T1 <- read (fns[nj])) BRL, R, QL)) 
           , I, (cn2 @ nil, fns[nj] @ nil), A)      
     => 
     pConfig(Sigma, Delta, 
            (fns[nj] ::= R1) || 
            (cn2 ::= R2) 
           , I, O', A)
    /\ O' ==  (cn2 @ nil, fns[nj] @ nil)               
   .
  
   var C2 : Qid .
   var blist2 : List{Bounds} .
   
    crl [subst-diverge-family] : 
    pConfig(Sigma, Delta, 
              (family fns1 nlist blist ::= 
                 nf(x1 : T1 <- read (fns1[nlist]), return x1, x1 :: emptyCNameList)
              )
              || 
              (family fns2 nlist2 blist2 ::= 
                nf( (x2 : T1 <- read (fns1[nlist'])) BRL , R2, QL
                  )
              ),
              I, O, A
           )    
    =>
    pConfig(Sigma, Delta, 
              (family fns1 nlist blist ::= 
                 nf(x1 : T1 <- read (fns1[nlist]), return x1, x1 :: emptyCNameList))
              || 
              (family fns2 nlist2 blist2 ::= 
                 nf(x3 : T2 <- read (fns2[nlist2]), return x3, x3 :: emptyCNameList)),
              I, O, A
           ) 
   if        
   O == insert(toBounds fns1 blist, toBounds fns2 blist2)
   /\
     elem (toBounds fns1 blist)  T1 Delta A
     /\
     elem (toBounds fns2 blist2) T2 Delta A
     /\
     typeOf(Sigma, Delta, addDeclarations BRL (x2 : T1), 
            insert(toBounds fns1 blist, insert(toBounds fns2 blist2, I)), A, R2) 
     == 
     typeInCtx(toBounds fns2 blist2, A, Delta) 
           [nonexec] *** because x3 is new and T2 must be specified as well!
  . 
  
  crl [subst-diverge-family-channel] : 
    pConfig(Sigma, Delta, 
              (family fns nlist blist ::= 
                 nf(x1 : T1 <- read (fns[nlist]), return x1, x1 :: emptyCNameList)
              )
              || 
              (cn ::= 
                nf( (x2 : T1 <- read (fns[nlist2])) BRL , R2, QL
                  )
              ),
              I, O, A
           )    
    =>
    pConfig(Sigma, Delta, 
              (family fns nlist blist ::= 
                 nf(x1 : T1 <- read (fns[nlist]), return x1, x1 :: emptyCNameList))
              || 
              (cn ::= 
                 nf(x3 : T2 <- read cn, return x3, x3 :: emptyCNameList)),
              I, O, A
           ) 
   if        
   O == insert(toBounds fns blist, cn @ nil)
   /\
     elem (toBounds fns blist) T1 Delta A
     /\
     elem (cn @ nil) T2 Delta A
     /\
     typeOf(Sigma, Delta, addDeclarations BRL (x2 : T1), 
            insert(toBounds fns blist, insert(cn @ nil, I)), A, R2) 
     == 
     typeInCtx(cn @ nil, A, Delta) 
           [nonexec] *** because x3 is new and T2 must be specified as well!
  .
  
  crl [subst-diverge-family-channel-old] : 
    pConfig(Sigma, Delta, 
              (family C i (bound nt1) ::= 
                 nf(x1 : T1 <- read (C[i]), return x1, x1 :: emptyCNameList)
              )
              || 
              (cn ::= 
                nf( (x2 : T1 <- read (C[nj])) BRL , R2, QL
                  )
              ),
              I, O, A
           )    
    =>
    pConfig(Sigma, Delta, 
              (family C i (bound nt1) ::= 
                 nf(x1 : T1 <- read (C[i]), return x1, x1 :: emptyCNameList))
              || 
              (cn ::= 
                 nf(x3 : T2 <- read cn, return x3, x3 :: emptyCNameList)),
              I, O, A
           ) 
   if        
   O == insert(C @ nt1, cn @ nil)
   /\
     elem (C @ nt1) T1 Delta A
     /\
     elem (cn @ nil) T2 Delta A
     /\
     typeOf(Sigma, Delta, addDeclarations BRL (x2 : T1), 
            insert(C @ nt1, insert(cn @ nil, I)), A, R2) 
     == 
     typeInCtx(cn @ nil, A, Delta) 
           [nonexec] *** because x3 is new and T2 must be specified as well!
  .
  
  ***( we don't use this rule!
  rl [SUBST-nf-rev-family] : 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (family C lq blist ::= preNF( BRL , R1, QL) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (cn1 ::= R1) || (family C lq blist ::= preNF((x1 : T1 <- read cn1) BRL , return x1, x1 :: QL)),
             I, O, A) 
    [nonexec] .      
    )
  
 crl [SUBST-nf-rev-families-one] : 
     pConfig(Sigma, Delta,
             (family fns1 q (bound nt1) ::= cases) 
             || 
             (family fns2 q' (bound nt2) ::= preNF( BRL , R1, QL) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (family fns1 q (bound nt1) ::= cases) 
             || 
              (family fns2 q' (bound nt2) ::= 
                preNF((x1 : T1 <- read (fns1[nj])) BRL , return x1, x1 :: QL)),
             I, O, A) 
     if 
     typeOf(Sigma, Delta, emptyTypeContext, 
            insert(toBounds fns1 (bound nt1), insert(toBounds fns2 (bound nt2) , I)), 
                   insert(q =T= nj, A), R2) 
     == 
     typeInCtx(toBounds fns1 (bound nt1), insert(q =T= nj, A), Delta) 
     /\
     typeOf(Sigma, Delta, addDeclarations BRL emptyTypeContext, 
            insert(toBounds fns1 (bound nt1), insert(toBounds fns2 (bound nt2) , I)), A, R1) 
     == 
     typeInCtx(toBounds fns2 (bound nt2), A, Delta) 
     /\       
     (projectIndex (family fns1 q (bound nt1)  ::= cases) nj 
          insert(q =T= nj, A) empty) == (fns1[nj] ::= R2)
     /\ 
     R1 == convertNF(R2)               
  [nonexec] . 
  
    crl [subst-families-one] :
     pConfig(Sigma, Delta, 
             (family fns q (bound nt) ::= cases)
             ||
             (cn2 ::= nf((x : T <- read (fns[nj])) BRL, R, ql)),
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             (family fns q (bound nt) ::= cases)
             ||
             (cn2 ::= preNF((x : T <~ R2) BRL, R, ql)
             )
             ,
             I, O, A) 
     if 
      typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(toBounds fns (bound nt), insert(toBound cn2 , I)), A, R) 
     == 
     typeInCtx(toBound cn2, A, Delta) 
     /\ 
     typeInCtx(fns @ nt, A, Delta) == T
     /\ 
     (projectIndex (family fns q (bound nt)  ::= cases) nj 
          insert(q =T= nj, A) empty) == (fns[nj] ::= R2)
         
     [nonexec] 
     .
     
    crl [subst-families-three] :
     pConfig(Sigma, Delta, 
             (family fns (q q' q'') (b1 b2 b3) ::= cases)
             ||
             (cn2 ::= nf((x : T <- read (fns[t1 t2 t3])) BRL, R, ql)),
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             (family fns (q q' q'') (b1 b2 b3) ::= cases)
             ||
             (cn2 ::= preNF((x : T <~ R2) BRL, R, ql))
             ,
             I, O, A) 
     if 
      typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(toBounds fns (b1 b2 b3), insert(toBound cn2 , I)), A, R) 
     == 
     typeInCtx(toBound cn2, A, Delta) 
     /\ 
     typeInCtx(toBounds fns (b1 b2 b3), A, Delta) == T 
     /\ 
     (projectIndex (family fns (q q' q'') (b1 b2 b3) ::= cases) (t1 t2 t3) 
          insert(q =T= t1, insert(q' =T= t2, insert(q'' =T= t3, A))) empty) 
     == 
     (fns[t1 t2 t3] ::= R2)      
     [nonexec] 
     
     .
     
    crl [subst-families-one-cases] :
     pConfig(Sigma, Delta, 
             (family fns q (bound nt) ::= cases)
             ||
             (cn2 ::= nf((x : T <- read (fns[nj])) BRL, R, ql)),
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             (family fns q (bound nt) ::= cases)
             ||
             (cn2 ::= cases')
             ,
             I, O, A) 
     if 
      typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(toBounds fns (bound nt), insert(toBound cn2 , I)), A, R) 
     == 
     typeInCtx(toBound cn2, A, Delta) 
     /\ 
     typeInCtx(fns @ nt, A, Delta) == T
     /\
     pConfig(Sigma, Delta, 
             (cn2 ::= nf((x : T <- read (fns[nj])) BRL, R, ql)) 
             || 
             (projectIndex (family fns q (bound nt)  ::= cases) nj 
              insert(q =T= nj, A) empty),
             I, (cn2 @ nil, fns[nj] @ nil), A
            ) 
     => 
     pConfig(Sigma, Delta, 
             (cn2 ::= cases') 
             || 
             P,
             I, (cn @ nil, fns[nj] @ nil), A
            )  
     .
     
     var C1 : Qid .
     
     crl [subst-channel-one-family] :
     pConfig(Sigma, Delta, 
             (cn ::= R2)
             ||
             (family fns q' (bound nt1) ::= 
                nf((x : T <- read cn) BRL, R, ql)
             ),
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             (cn ::= R2)
             ||
             (family fns q' (bound nt1) ::= 
               preNF((x : T <~ R2) BRL, R, ql)
             ),
             I, O, A) 
     if isSampFree(R2) /\
        O == insert(toBound cn, fns @ nt1) /\ 
     typeOf(Sigma, Delta, emptyTypeContext, 
            insert(toBound cn, insert(fns @ nt1, I)), A, R2) == T /\
     typeOf(Sigma, Delta, addDeclarations BRL (x : T), 
            insert(toBound cn, insert(fns @ nt1, I)), A, R) == typeInCtx(fns @ nt1, A, Delta)
     /\ 
     elem (toBound cn) T Delta A 
     . 
     
              
     crl [subst-families-one-family] :
     pConfig(Sigma, Delta, 
             (family fns2 q (bound nt) ::= cases)
             ||
             (family fns1 q' (bound nt1) ::= nf((x : T <- read (fns2[nj])) BRL, R, ql)),
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             (family fns2 q (bound nt) ::= cases)
             ||
             (family fns1 q' (bound nt1) ::= preNF((x : T <~ R2) BRL, R, ql)
             )
             ,
             I, O, A) 
     if (projectIndex (family fns2 q (bound nt)  ::= cases) nj 
          insert(q =T= nj, A) empty) == (fns2[nj] ::= R2)
     [nonexec] 
     .
     
     crl [subst-families-three-family] :
     pConfig(Sigma, Delta, 
             (family fns2 (q1 q2 q3) (b1 b2 b3) ::= cases)
             ||
             (family fns1 (q1 q2 q3) (b1 b2 b3) ::= 
                nf((x : T <- read (fns2[t1 t2 t3])) BRL, R, ql)),
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             (family fns2 (q1 q2 q3) (b1 b2 b3) ::= cases)
             ||
             (family fns1 (q1 q2 q3) (b1 b2 b3) ::= 
                preNF((x : T <~ R2) BRL, R, ql)),
             I, O, A) 
     if (projectIndex (family fns2 (q1 q2 q3) (b1 b2 b3) ::= cases) (t1 t2 t3)
          (q1 =T= t1, q2 =T= t2, q3 =T= t3, A) empty) == (fns2[t1 t2 t3] ::= R2)
     [nonexec] 
     .
              
     crl [subst-2-families-one] :
     pConfig(Sigma, Delta, 
             (family fns q (bound nt) ::= cases')
             ||
             (cn2 ::= cases),
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             (family fns q (bound nt) ::= cases')
             ||
             (cn2 ::= nf('x : T <- read (fns[nj]), 
                         return 'x, 
                         'x :: emptyCNameList)
             ),
             I, O, A) 
     if (projectIndex (family fns q (bound nt)  ::= cases') nj 
          insert(q =T= nj, A) empty) == (fns[nj] ::= cases)
     [nonexec] 
     .
     
     var nj' : NatTerm .
     
     crl [subst-families-two] :
     pConfig(Sigma, Delta, 
             (family fns (q q') ((bound n) (bound nt)) ::= cases')
             ||
             (cn2 ::= cases),
             I, O, A)
     => 
    pConfig(Sigma, Delta, 
             (family fns (q q') ((bound n) (bound nt))  ::= cases')
             ||
             (cn2 ::= nf('x : T <- read (fns[nj nj']), return 'x, 'x :: emptyCNameList)),
             I, O, A) 
     if (projectIndex (family fns (q q') ((bound n) (bound nt)) ::= cases') 
                      (nj nj') A empty) 
        == 
        (fns[nj nj'] ::= cases)
     [nonexec] .
     
     rl [subst-rev-families] :
     pConfig(Sigma, Delta, 
             (family fns q (bound n) ::= whenList1 ;; (when (q =T= nj) --> R) ;; whenList2)
             ||
             (cn2 ::= R),
             I, O, A)
     => 
    pConfig(Sigma, Delta, 
             (family fns q (bound n) ::= whenList1 ;; (when (q =T= nj) --> R) ;; whenList2)
             ||
             (cn2 ::= nf('x : T <- read (fns[nj]), return 'x, 'x :: emptyCNameList)),
             I, O, A)
    *** if typeOf(Sigma, Delta, emptyTypeContext, I, A, R) == T  *** TODO: need to add Cs to I?
    [nonexec] .             

      *** was (q1 n1 :: T1) (q2 n2 :: T2) (C n :: T1)
      *** family q = read cn1 || cn2 = .. x <- read q[j]...
      *** rewrites to
      *** family q = read cn1 || cn2 = .. x <- read cn1...
      *** but we may have cn1 parameterized as well and then we need to replace!
      
     crl [SUBST-nf-read-family-one] : 
     pConfig(Sigma, Delta ,
             (family fns1 q (bound n) ::= nf((x2 : T1 <- read cn1), return x2, x2 :: emptyCNameList )) || 
             (cn2 ::= nf( (x1 : T1 <- read (fns1[nj])) BRL , R2, QL) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (family fns1 q (bound n) ::= nf((x2 : T1 <- read cn1), return x2, x2 :: emptyCNameList ))  || 
             (cn2 ::= nf((x2 : T1 <- read (evalCName cn1 (q |-> nj))) BRL , R2 [x1 / x2], replace x1 x2 QL)),
             I, O, A) 
     if *** TODO: add condition about nj being in bounds
     isElemB(cn1, I, A) ***( /\
     elem (toBounds fns1 (bound n)) T1 Delta A /\
     elem (toBound cn1) T1 Delta A /\
     O == insert(toBounds fns1 (bound n), toBound cn2)  /\
     typeOf(Sigma, Delta, addDeclarations BRL (x1 : T1), 
            insert(toBounds fns1 (bound n), insert(toBound cn1, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta) 
     )       . 
     
     rl [SUBST-nf-read-family-two] : 
     pConfig(Sigma, Delta ,
             (family fns1 (q q') ((bound n1) (bound nt)) ::= 
                 nf((x2 : T1 <- read cn1), return x2, x2 :: emptyCNameList )) || 
             (cn2 ::= nf( (x1 : T1 <- read (fns1[q nj])) BRL , R2, QL) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (family fns1 (q q') ((bound n1) (bound nt)) ::= 
                nf((x2 : T1 <- read cn1), return x2, x2 :: emptyCNameList ))  || 
             (cn2 ::= nf((x2 : T1 <- read (evalCName cn1 (q' |-> nj))) BRL , R2 [x1 / x2], replace x1 x2 QL)),
             I, O, A) 
     ***( if *** TODO: add condition about nj being in bounds
     isElemB(cn1, I, A)  /\
     elem (toBounds fns1 (bound n)) T1 Delta A /\
     elem (toBound cn1) T1 Delta A /\
     O == insert(toBounds fns1 (bound n), toBound cn2)  /\
     typeOf(Sigma, Delta, addDeclarations BRL (x1 : T1), 
            insert(toBounds fns1 (bound n), insert(toBound cn1, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta) 
     )       . 
     
     var q'' : Qid .
     
     rl [SUBST-nf-read-family-two-family] : 
     pConfig(Sigma, Delta ,
             (family fns1 (q q') ((bound n1) (bound nt)) ::= 
                 nf((x2 : T1 <- read cn1), return x2, x2 :: emptyCNameList )) || 
             (family fns2 q'' (bound nt2) ::= 
                 nf( (x1 : T1 <- read (fns1[q nj])) BRL , R2, QL) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (family fns1 (q q') ((bound n1) (bound nt)) ::= 
                nf((x2 : T1 <- read cn1), return x2, x2 :: emptyCNameList ))  || 
             (family fns2 q'' (bound nt2) ::= 
                nf((x2 : T1 <- read (evalCName cn1 (q' |-> nj))) BRL , 
                    R2 [x1 / x2], 
                    replace x1 x2 QL)),
             I, O, A) . 
      
     crl [SUBST-nf-read-family] : 
     pConfig(Sigma, Delta ,
             (family fns1 ntl bounds ::= nf((x2 : T1 <- read cn1), return x2, x2 :: emptyCNameList )) || 
             (cn2 ::= nf( (x1 : T1 <- read (fns1[nj])) BRL , R2, QL) ),
             I, O, A)  
     => 
     pConfig(Sigma, Delta,
             (family fns1 ntl bounds ::= nf((x2 : T1 <- read cn1), return x2, x2 :: emptyCNameList ))  || 
             (cn2 ::= nf((x2 : T1 <- read cn1) BRL , R2 [x1 / x2], replace x1 x2 QL)),
             I, O, A) 
     if *** TODO: add condition about nj being in bounds
     isElemB(cn1, I, A) /\
     elem (toBounds fns1 bounds) T1 Delta A /\
     elem (toBound cn1) T1 Delta A /\
     O == insert(toBounds fns1 bounds, toBound cn2)  /\
     typeOf(Sigma, Delta, addDeclarations BRL (x1 : T1), 
            insert(toBounds fns1 bounds, insert(toBound cn1, I)), A, R2) 
     == 
     typeInCtx(toBound cn2, A, Delta) .

  
     rl [comp-new-families] : 
     pConfig(Sigma, Delta, newNF(ltq1, P1, ql1) || newNF(ltq2, P2, ql2), I, O, A)
     => 
     pConfig(Sigma, Delta, newNF(ltq1 ltq2, P1 || P2, ql1 ++ ql2), I, O, A) 
     .
     
      crl [use-family-p] : 
     pConfig(Sigma, Delta, P1 || family fns lq blist ::= P, I, O, A)
     => 
     pConfig(Sigma, Delta, P2 || family fns lq blist ::= P, I, O, A)
     if 
     pConfig(Sigma, Delta, P1 || P, I, O, A)
     => 
     pConfig(Sigma, Delta, P2 || P, I, O, A)
     [nonexec] .
      
      
    rl [fold-bind-new-nf-families] :
    pConfig(Sigma, Delta, 
             newNF({ fns1 q (bound n) : T } ltq, 
                   P || (family fns1 q (bound n) ::= R) || 
                      (family fns2 q' (bound n1) ::= nf((x : T <- read (fns1[q'])) BRL, S, QL)), 
                   ql),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, P || (family fns2 q' (bound n1) ::= preNF((x : T <~ R) BRL, S, QL)), 
                   del fns1 ql),
            I, O, A) 
    ***( 
    if typeOf(Sigma, addChannels ltq (Delta ((toBound fns1):: T)), addDeclarations BRL emptyTypeContext, 
            insert(toBound o, insert(toBound fns1, union(I, getOutputs(P)))), A, R) == T 
    )        
  . 
  
     rl [fold-bind-new-nf-families-zero] :
    pConfig(Sigma, Delta, 
             newNF({ fns1 q (bound n) : T } ltq, 
                  (family fns1 q (bound n) ::= R) || 
                      (family fns2 q' (bound n1) ::= nf((x : T <- read (fns1[q'])) BRL, S, QL)), 
                   ql),
            I, O, A)
    => 
    pConfig(Sigma, Delta, 
             newNF(ltq, (family fns2 q' (bound n1) ::= preNF((x : T <~ R) BRL, S, QL)), 
                   del fns2 ql),
            I, O, A) 
    ***( 
    if typeOf(Sigma, addChannels ltq (Delta ((toBound fns1):: T)), addDeclarations BRL emptyTypeContext, 
            insert(toBound o, insert(toBound fns1, union(I, getOutputs(P)))), A, R) == T 
    )        
  . 
  
     
     *** congruence rules for families
  
     
     crl [CONG-NEWFAMILY] : 
     pConfig(Sigma, Delta, newfamily fns lq blist : T in P1, I, O, A)
     =>  
     pConfig(Sigma, Delta, newfamily fns lq blist : T in P2, I, O, A)
     if 
     pConfig(Sigma, Delta ((toBounds fns blist) :: T), P1, I, insert(toBounds fns blist, O), A)
     =>
     pConfig(Sigma, Delta', P2, I, O', A)
     /\
     O' == insert(toBounds fns blist, O)
     /\
     Delta' == Delta ((toBounds fns blist) :: T)
     [nonexec]
     .
   
     crl [CONG-FAMILY-R] : 
     pConfig(Sigma, Delta, family fns lq blist ::= R, I, O, A)
     => 
     pConfig(Sigma, Delta, family fns lq blist ::= R', I, O, A)
     if 
     rConfig(Sigma, Delta, emptyTypeContext, R, insert(toBounds fns blist, I), A, 
             typeInCtx(toBounds fns blist, A, Delta))
     =>
     rConfig(Sigma, Delta, emptyTypeContext, R', I', A, T) 
     /\ I' == insert(toBounds fns blist, I)  
     /\ T == typeInCtx(toBounds fns blist, A, Delta)
     [nonexec] .
     
           
     crl [CONG-FAMILY-P] : 
     pConfig(Sigma, Delta, family fns lq blist ::= P1, I, O, A)
     => 
     pConfig(Sigma, Delta, family fns lq blist ::= P2, I, O, A)
     if
     pConfig(Sigma, Delta, P1, I, O, A)
     =>
     pConfig(Sigma, Delta, P2, I, O, A) [nonexec] .
     
  
     
     var whenCond : WhenCond .
     var whenList1 whenList2 whenList whenList' : WhenList .
     
     crl [CONG-FAMILY-WHENLIST-P] : 
     pConfig(Sigma, Delta, 
             family fns lq blist ::= whenList1 ;; (when bt --> P1) ;; whenList2, 
             I, O, A)
     => 
     pConfig(Sigma, Delta, 
             family fns lq blist ::= whenList1 ;; (when bt --> P2) ;; whenList2, 
             I, O, A) 
     if 
     pConfig(Sigma, Delta, P1, I, O, insert(bt, A) )
     =>  
     pConfig(Sigma, Delta, P2, I, O, A')
     /\ 
     A' == insert(bt, A) [nonexec] . 

     var A' : Set{BoolTerm} . 

     crl [CONG-FAMILY-WHENLIST-R] : 
     pConfig(Sigma, Delta, 
       family fns lq blist ::= (whenList1 ;; (when bt --> R1) ;; whenList2), I, O, A)
     => 
     pConfig(Sigma, Delta, 
       family fns lq blist ::= (whenList1 ;; (when bt --> R2) ;; whenList2), I, O, A) 
     if 
     rConfig(Sigma, Delta, emptyTypeContext, R1, insert(toBounds fns blist, I), 
             insert(bt, A), T)
     =>  
     rConfig(Sigma, Delta, emptyTypeContext, R2, I', A', T)
     /\
     A' == insert(bt, A) 
     /\
     I' == insert(toBounds fns blist, I) [nonexec] . 

     *** case distinction
     
     var aP1 aP2 : Protocol .
     var A'' : Set{BoolTerm} .
     var aQid : Qid .
     
     ****************************
     **** case substitution for channels
     ****************************
     
     crl [channel-cases-subst-end-otherwise]:
      pConfig(Sigma, Delta, 
               (cn1 ::= 
                 nf( ( x : T <- read cn2) BRL, 
                     R, 
                     QL
                   )
               )
                || 
               (cn2 ::= 
                 (otherwise --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn1 ::= 
                 (otherwise --> R2) 
               )
                || 
               (cn2 ::= 
                 (otherwise --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( cn2 ::= R1 ) 
             || 
             ( cn1 ::= nf( (x : T <- read cn2 ) BRL, R, QL)
             ),
             I, insert(cn1 @ nil, cn2 @ nil), A
           )
    =>
    pConfig(Sigma, Delta, 
             (cn2 ::= R1) || (cn1 ::= R2),
             I, O', A
           )       
    /\ O' == insert(cn1 @ nil, cn2 @ nil)
    [nonexec]
    .
     
     crl [channel-cases-subst-end-when]:
      pConfig(Sigma, Delta, 
               (cn1 ::= 
                 nf( ( x : T <- read cn2 ) BRL, 
                     R, 
                     QL
                   )
               )
                || 
               (cn2 ::= 
                 (when bt --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn1 ::= (when bt --> R2))
                || 
               (cn2 ::= (when bt --> R1)),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( cn2 ::= R1 ) 
             || 
             ( cn1 ::= nf( (x : T <- read cn2 ) BRL, R, QL)
             ),
             I, *** TODO: might need to add C as inputs
             insert(cn1 @ nil, cn2 @ nil), 
             insert(bt, A)
           )
    =>
    pConfig(Sigma, Delta, 
             (cn2 ::= R1) || (cn1 ::= R2),
             I, O', A'
           )       
    /\ A' == insert(bt, A)
    /\ O' == insert(cn1 @ nil, cn2 @ nil)
    [nonexec]
    .
     
     crl [channel-cases-subst]:
      pConfig(Sigma, Delta, 
               (cn1 ::= 
                 nf( ( x : T <- read cn2 ) BRL, 
                     R, 
                     QL
                   )
               )
                || 
               (cn2 ::= 
                 (when bt --> R1) ;; whenList
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn1 ::= 
                 (when bt --> R2) 
                 ;;
                 whenList'
               )
                || 
               (cn2 ::= 
                 (when bt --> R1) 
                 ;; 
                 whenList
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( cn2 ::= R1 ) 
             || 
             ( cn1 ::= nf( (x : T <- read cn2 ) BRL, R, QL)
             ),
             I, insert(cn1 @ nil, cn2 @ nil), 
             insert(bt, A)
           )
    =>
    pConfig(Sigma, Delta, 
             (cn2 ::= R1) || (cn1 ::= R2),
             I, O', A'
           )       
    /\ A' == insert(bt, A)
    /\ O' == insert(cn1 @ nil, cn2 @ nil)
    /\ *** now the step
    pConfig(Sigma, Delta, 
              (cn1 ::= 
                 nf( ( x : T <- read cn2 ) BRL, 
                     R, 
                     QL
                   )
               )
                || 
               (cn2 ::= 
                 whenList
               ),
               I, O, insert(neg bt, A) 
           )
   => 
   pConfig(Sigma, Delta, 
              (cn1 ::= 
                 whenList'
               )
                || 
               (cn2 ::= 
                 whenList
               ),
               I, O, A''
           )  
    /\
    A'' == insert(neg bt, A)
    .
    
    ****************************
     **** case substitution channel/family
     ****************************
     
     crl [fc-cases-subst-end-otherwise]:
      pConfig(Sigma, Delta, 
               (cn ::= 
                 nf( ( x : T <- read (fns[nj]) ) BRL, 
                     R, 
                     QL
                   )
               )
                || 
               (family fns q (bound nt) ::= 
                 (otherwise --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn ::= 
                 (otherwise --> R2) 
               )
                || 
               (family fns q (bound nt) ::= 
                 (otherwise --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( family fns q (bound nt) ::= R1) 
             || 
             ( cn ::= nf( (x : T <- read (fns[nj]) ) BRL, R, QL)
             ),
             I, insert(fns @ nt, cn @ nil), A
           )
    =>
    pConfig(Sigma, Delta, 
             ( family fns q (bound nt) ::= R1)  || (cn ::= R2),
             I, O', A
           )       
    /\ O' == insert(fns @ nt, cn @ nil)
    [nonexec]
    .
     
     crl [fc-cases-subst-end-when]:
      pConfig(Sigma, Delta, 
               (cn ::= 
                 nf( ( x : T <- read (fns[nj]) ) BRL, 
                     R, 
                     QL
                   )
               )
                || 
               (family fns q (bound nt) ::= 
                 (when bt --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn ::= 
                 (when subst(bt, q |-> nj) --> R2) 
               )
                || 
               (family fns q (bound nt) ::= 
                 (when bt --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( family fns q (bound nt) ::= R1)
             || 
             ( cn ::= nf( (x : T <- read (fns[nj]) ) BRL, R, QL)
             ),
             I,
             insert(fns @ nt, cn @ nil), 
             insert(subst(bt, q |-> nj), A)
           )
    =>
    pConfig(Sigma, Delta, 
             ( family fns q (bound nt) ::= R1) || (cn ::= R2),
             I, O', A'
           )       
    /\ A' == insert(subst(bt, q |-> nj), A)
    /\ O' == insert(fns @ nt, cn @ nil)
    [nonexec]
    .
     
     crl [fc-cases-subst]:
      pConfig(Sigma, Delta, 
               (cn ::= 
                 nf( ( x : T <- read (fns[nj]) ) BRL, 
                     R, 
                     QL
                   )
               )
                || 
               (family fns q (bound nt) ::= 
                 (when bt --> R1) ;; whenList
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn ::= 
                 (when subst(bt, q |-> nj) --> R2) 
                 ;;
                 whenList'
               )
                || 
               (family fns q (bound nt) ::= 
                 (when bt --> R1) 
                 ;; 
                 whenList
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( family fns q (bound nt) ::= R1) 
             || 
             ( cn ::= nf( (x : T <- read (fns[nj]) ) BRL, R, QL)
             ),
             I, insert(fns @ nt, cn @ nil), insert(subst(bt, q |-> nj), A)
           )
    =>
    pConfig(Sigma, Delta, 
             ( family fns q (bound nt) ::= R1) || (cn ::= R2),
             I, O', A'
           )       
    /\ A' == insert(subst(bt, q |-> nj), A)    
    /\ O' == insert(fns @ nt, cn @ nil)
    /\
    pConfig(Sigma, Delta, 
              (cn ::= 
                 nf( ( x : T <- read (fns[nj]) ) BRL, 
                     R, 
                     QL
                   )
               )
                || 
               (family fns q (bound nt) ::= 
                 whenList
               ),
               I, O, insert(neg (subst(bt, q |-> nj)), A) 
           )
   => 
   pConfig(Sigma, Delta, 
              (cn ::= 
                 whenList'
               )
                || 
               (family fns q (bound nt) ::= 
                 whenList
               ),
               I, O, A''
           )  
    /\
    A'' == insert(neg (subst(bt, q |-> nj)), A)
    .               
     
     ****************************
     **** case substitution
     ****************************
     
     crl [cases-subst-end-otherwise]:
      pConfig(Sigma, Delta, 
               (family fns1 q (bound n) ::= 
                 nf( ( x : T <- read (fns2[q]) ) BRL, 
                     R, 
                     QL
                   )
               )
                || 
               (family fns2 q (bound n) ::= 
                 (otherwise --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family fns1 q (bound n) ::= 
                 (otherwise --> R2) 
               )
                || 
               (family fns2 q (bound n) ::= 
                 (otherwise --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns2[q] ::= R1 ) 
             || 
             ( fns1[q] ::= nf( (x : T <- read (fns2[q]) ) BRL, R, QL)
             ),
             I, insert(fns2[q] @ nil, fns1[q] @ nil), insert(q <T n, A)
           )
    =>
    pConfig(Sigma, Delta, 
             (fns2[q] ::= R1) || (fns1[q] ::= R2),
             I, O', A'
           )       
    /\ A' == insert(q <T n, A)   
    /\ O' == insert(fns2[q] @ nil, fns1[q] @ nil)
    [nonexec]
    .
     
     crl [cases-subst-end-when]:
      pConfig(Sigma, Delta, 
               (family fns1 q (bound n) ::= 
                 nf( ( x : T <- read (fns2[q]) ) BRL, 
                     R, 
                     QL
                   )
               )
                || 
               (family fns2 q (bound n) ::= 
                 (when bt --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family fns1 q (bound n) ::= 
                 (when bt --> R2) 
               )
                || 
               (family fns2 q (bound n) ::= 
                 (when bt --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns2[q] ::= R1 ) 
             || 
             ( fns1[q] ::= nf( (x : T <- read (fns2[q]) ) BRL, R, QL)
             ),
             I, *** TODO: might need to add fns1 as inputs
             insert(fns2[q] @ nil, fns1[q] @ nil), 
             insert(q <T n, insert(bt, A))
           )
    =>
    pConfig(Sigma, Delta, 
             (fns2[q] ::= R1) || (fns1[q] ::= R2),
             I, O', A'
           )       
    /\ A' == insert(q <T n, insert(bt, A))     
    /\ O' == insert(fns2[q] @ nil, fns1[q] @ nil)
    [nonexec]
    .
     
     crl [cases-subst]:
      pConfig(Sigma, Delta, 
               (family fns1 q (bound n) ::= 
                 nf( ( x : T <- read (fns2[q]) ) BRL, 
                     R, 
                     QL
                   )
               )
                || 
               (family fns2 q (bound n) ::= 
                 (when bt --> R1) ;; whenList
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family fns1 q (bound n) ::= 
                 (when bt --> R2) 
                 ;;
                 whenList'
               )
                || 
               (family fns2 q (bound n) ::= 
                 (when bt --> R1) 
                 ;; 
                 whenList
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns2[q] ::= R1 ) 
             || 
             ( fns1[q] ::= nf( (x : T <- read (fns2[q]) ) BRL, R, QL)
             ),
             I, insert(fns2[q] @ nil, fns1[q] @ nil), insert(q <T n, insert(bt, A))
           )
    =>
    pConfig(Sigma, Delta, 
             (fns2[q] ::= R1) || (fns1[q] ::= R2),
             I, O', A'
           )       
    /\ A' == insert(q <T n, insert(bt, A))     
    /\ O' == insert(fns2[q] @ nil, fns1[q] @ nil)
    /\
    pConfig(Sigma, Delta, 
              (family fns1 q (bound n) ::= 
                 nf( ( x : T <- read (fns2[q]) ) BRL, 
                     R, 
                     QL
                   )
               )
                || 
               (family fns2 q (bound n) ::= 
                 whenList
               ),
               I, O, insert(neg bt, A) 
           )
   => 
   pConfig(Sigma, Delta, 
              (family fns1 q (bound n) ::= 
                 whenList'
               )
                || 
               (family fns2 q (bound n) ::= 
                 whenList
               ),
               I, O, A''
           )  
    /\
    A'' == insert(neg bt, A)
    .               
    
    *************************
    *** same cases subst
    *************************
    
    *** ends with otherwise
    
    crl [same-cases-subst-end-otherwise]:
      pConfig(Sigma, Delta, 
               (family fns1 q (bound nt) ::= 
                 otherwise --> R2
               )
                || 
               (family fns2 q (bound nt) ::= 
                 (otherwise --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family fns1 q (bound nt) ::= 
                 (otherwise --> R3) 
               )
                || 
               (family fns2 q (bound nt) ::= 
                 (otherwise --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns2[q] ::= R1 ) 
             || 
             ( fns1[q] ::= R2),
             I, insert(fns2[q] @ nil, fns1[q] @ nil), insert(q <T nt, A)
           )
    =>
    pConfig(Sigma, Delta, 
             (fns2[q] ::= R1) || (fns1[q] ::= R3),
             I, O', A'
           )       
    /\ A' == insert(q <T nt, A)   
    /\ O' == insert(fns2[q] @ nil, fns1[q] @ nil)
    [nonexec]
    .
     
    *** ends with when 
     
    crl [same-cases-subst-end-when]:
      pConfig(Sigma, Delta, 
               (family fns1 q (bound nt) ::= 
                 when bt --> R2
               )
                || 
               (family fns2 q (bound nt) ::= 
                 (when bt --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family fns1 q (bound nt) ::= 
                 (when bt --> R3) 
               )
                || 
               (family fns2 q (bound nt) ::= 
                 (when bt --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns2[q] ::= R1 ) 
             || 
             ( fns1[q] ::= R2),
             I, insert(fns2[q] @ nil, fns1[q] @ nil), insert(bt, insert(q <T nt, A))
           )
    =>
    pConfig(Sigma, Delta, 
             (fns2[q] ::= R1) || (fns1[q] ::= R3),
             I, O', A'
           )       
    /\ A' == insert(bt, insert(q <T nt, A))  
    /\ O' == insert(fns2[q] @ nil, fns1[q] @ nil)
    [nonexec]
    .
    
    *** recursion step
    
    crl [same-cases-subst]:
      pConfig(Sigma, Delta, 
               (family fns1 q (bound nt) ::= 
                 (when bt --> R2)
                 ;;
                 whenList2
               )
                || 
               (family fns2 q (bound nt) ::= 
                 (when bt --> R1)
                 ;;
                 whenList1
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (family fns1 q (bound nt) ::= 
                 (when bt --> R3)
                 ;;
                 whenList' 
               )
                || 
               (family fns2 q (bound nt) ::= 
                 (when bt --> R1)
                 ;;
                 whenList1 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns2[q] ::= R1 ) 
             || 
             ( fns1[q] ::= R2),
             I, insert(fns2[q] @ nil, fns1[q] @ nil), insert(bt, insert(q <T nt, A))
           )
    =>
    pConfig(Sigma, Delta, 
             (fns2[q] ::= R1) || (fns1[q] ::= R3),
             I, O', A'
           )       
    /\ A' == insert(bt, insert(q <T nt, A))   
    /\ O' == insert(fns2[q] @ nil, fns1[q] @ nil)
    /\
    pConfig(Sigma, Delta, 
              (family fns1 q (bound nt) ::= 
                 whenList2
               )
                || 
               (family fns2 q (bound nt) ::= 
                 whenList1
               ),
               I, O, insert(neg bt, A) 
           )
   => 
   pConfig(Sigma, Delta, 
              (family fns1 q (bound nt) ::= 
                 whenList'
               )
                || 
               (family fns2 q (bound nt) ::= 
                 whenList1
               ),
               I, O, A''
           )  
    /\
    A'' == insert(neg bt, A)             
    [nonexec]
    .

    *************************
    *** same cases subst family/channel
    *************************
    
    *** ends with otherwise
    
    crl [fc-same-cases-subst-end-otherwise]:
      pConfig(Sigma, Delta, 
               (cn ::= 
                 otherwise --> nf(BRL (x : T <- read (fns[nj])), R, ql )
               )
                || 
               (family fns q (bound nt) ::= 
                 (otherwise --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn ::= 
                 (otherwise --> R3) 
               )
                || 
               (family fns q (bound nt) ::= 
                 (otherwise --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns[nj] ::= replaceVars(R1, q |-> nj )) 
             || 
             ( cn ::= nf(BRL (x : T <- read (fns[nj])), R, ql )),
             I, insert(fns[nj] @ nil, cn @ nil), insert(nj <T nt, A)
           )
    =>
    pConfig(Sigma, Delta, 
             (fns[q] ::= R') || (cn ::= R3),
             I, O', A'
           )       
    /\ R' == replaceVars(R1, q |-> nj)       
    /\ A' == insert(nj <T nt, A)   
    /\ O' == insert(fns[nj] @ nil, cn @ nil)
    [nonexec]
    .
     
    *** ends with when 
     
    crl [fc-same-cases-subst-end-when]:
      pConfig(Sigma, Delta, 
               (cn ::= 
                 when bt --> nf(BRL (x : T <- read (fns[nj])), R, ql )
               )
                || 
               (family fns q (bound nt) ::= 
                 (when bt --> R1)
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn ::= 
                 (when bt --> R3) 
               )
                || 
               (family fns q (bound nt) ::= 
                 (when bt --> R1) 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns[nj] ::= replaceVars(R1, q |-> nj) ) 
             || 
             ( cn ::= nf(BRL (x : T <- read (fns[nj])), R, ql )),
             I, insert(fns[nj] @ nil, cn @ nil), insert(bt, insert(nj <T nt, A))
           )
    =>
    pConfig(Sigma, Delta, 
             (fns[nj] ::= R') || (cn ::= R3),
             I, O', A'
           )
    /\ R' == replaceVars(R1, q |-> nj)             
    /\ A' == insert(bt, insert(nj <T nt, A))  
    /\ O' == insert(fns[nj] @ nil, cn @ nil)
    [nonexec]
    .
    
    *** recursion step
    
    crl [fc-same-cases-subst]:
      pConfig(Sigma, Delta, 
               (cn ::= 
                 (when bt --> nf(BRL (x : T <- read (fns[nj])), R, ql )
                 )
                 ;;
                 whenList2
               )
                || 
               (family fns q (bound nt) ::= 
                 (when bt --> R1)
                 ;;
                 whenList1
               ),
               I, O, A
         )
         => 
         pConfig(Sigma, Delta, 
               (cn ::= 
                 (when bt --> R3)
                 ;;
                 whenList' 
               )
                || 
               (family fns q (bound nt) ::= 
                 (when bt --> R1)
                 ;;
                 whenList1 
               ),
               I, O, A)  
    if 
    pConfig(Sigma, Delta, 
             ( fns[nj] ::= replaceVars(R1, q |-> nj) ) 
             || 
             ( cn ::= nf(BRL (x : T <- read (fns[nj])), R, ql )),
             I, insert(fns[nj] @ nil, cn @ nil), insert(bt, insert(nj <T nt, A))
           )
    =>
    pConfig(Sigma, Delta, 
             (fns[nj] ::= R') || (cn ::= R3),
             I, O', A'
           )       
    /\ R' ==  replaceVars(R1, q |-> nj)      
    /\ A' == insert(bt, insert(nj <T nt, A))   
    /\ O' == insert(fns[nj] @ nil, cn @ nil)
    /\
    pConfig(Sigma, Delta, 
              (cn ::= 
                 whenList2
               )
                || 
               (family fns q (bound nt) ::= 
                 whenList1
               ),
               I, O, insert(neg bt, A) 
           )
   => 
   pConfig(Sigma, Delta, 
              (cn ::= 
                 whenList'
               )
                || 
               (family fns q (bound nt) ::= 
                 whenList1
               ),
               I, O, A''
           )  
    /\
    A'' == insert(neg bt, A)             
    [nonexec]
    .

    
    *********************************
    *** subst on a case
    *********************************
   
    crl [subst-family-case] :
       pConfig(Sigma, Delta, 
               (family fns1 i (bound nt1) ::= cases) || 
               (family fns2 i (bound nt2) ::= 
                whenList1 ;;
                (when bt --> nf((x : T <- read (fns1[nj]) ) BRL, R, ql)
                ) ;;
                whenList2), I, O, A)
       =>    
       pConfig(Sigma, Delta, 
               (family fns1 i (bound nt1) ::= cases) || 
               (family fns2 i (bound nt2) ::= 
                whenList1 ;;
                (when bt --> R'
                ) ;;
                whenList2), I, O, A)
       if 
       pConfig(Sigma, Delta, 
               (family fns1 i (bound nt1) ::= cases) || 
               (fns2[i] ::= nf((x : T <- read (fns1[nj]) ) BRL, R, ql)), 
               insert( fns2 @ nt2, I), *** because we could read fns2[0] or fns2[i - 1]
               O, insert(i <T nt2, insert(bt, A) )
              )
      =>
      pConfig(Sigma, Delta, 
               (family fns1 i (bound nt1) ::= cases) || 
               (fns2[i] ::= R'), 
               I', O, A')
     /\
     I' == insert(fns2 @ nt2, I)
     /\
     A' == insert(i <T nt2, insert(bt, A))
    
    .
   
   *** same rule for families with three indices
   
    crl [subst-family-case-three] :
       pConfig(Sigma, Delta, 
               (family fns1 (q q' q'') (b1 b2 b3) ::= cases) || 
               (family fns2 (q q' q'') (b1 b2 b3) ::= 
                whenList1 ;;
                (when bt --> nf((x : T <- read (fns1[t1 t2 t3]) ) BRL, R, ql)
                ) ;;
                whenList2), I, O, A)
       =>    
       pConfig(Sigma, Delta, 
               (family fns1 (q q' q'') (b1 b2 b3) ::= cases) || 
               (family fns2 (q q' q'') (b1 b2 b3) ::= 
                whenList1 ;;
                (when bt --> R'
                ) ;;
                whenList2)
               , I, O, A)
       if          
       pConfig(Sigma, Delta, 
               (family fns1 (q q' q'') (b1 b2 b3) ::= cases) || 
               (fns2[q q' q''] ::= nf((x : T <- read (fns1[t1 t2 t3]) ) BRL, R, ql)), 
               I, *** TODO important and C2 as inputs, but outdated rule!
               (toBounds fns1 (b1 b2 b3), fns2[q q' q''] @ nil), 
               ( insert(bt, A), addAssumptions A (q q' q'') (b1 b2 b3) )
              )
      =>
      pConfig(Sigma, Delta, 
               (family fns1 (q q' q'') (b1 b2 b3) ::= cases) || 
               (fns2[q q' q''] ::= R'), 
               I, O', A')
     /\
     O' == (toBounds fns1 (b1 b2 b3), fns2[q q' q''] @ nil)
     /\
     A' == ( insert(bt, A), addAssumptions A (q q' q'') (b1 b2 b3) )
    .  
    
   var blist1 : List{Bounds} .
   var ntlist : List{NatTerm} .  
    
   *** generic version
       crl [subst-family-case-generic] :
       pConfig(Sigma, Delta, 
               (family fns1 nlist1 blist1 ::= cases) || 
               (family fns2 nlist2 blist2 ::= 
                whenList1 ;;
                (when bt --> nf((x : T <- read (fns1[ntlist]) ) BRL, R, ql)
                ) ;;
                whenList2), I, O, A)
       =>    
       pConfig(Sigma, Delta, 
               (family fns1 nlist1 blist1 ::= cases) || 
               (family fns2 nlist2 blist2 ::= 
                whenList1 ;;
                (when bt --> R'
                ) ;;
                whenList2)
               , I, O, A)
       if          
       pConfig(Sigma, Delta, 
               (family fns1 nlist1 blist1 ::= cases) || 
               (fns2[nlist2] ::= nf((x : T <- read (fns1[ntlist]) ) BRL, R, ql)), 
               (I, toBounds fns2 blist2),
               (toBounds fns1 blist1, fns2[nlist2] @ nil), 
               ( insert(bt, A), addAssumptions A nlist2 blist2 )
              )
      =>
      pConfig(Sigma, Delta, 
               (family fns1 nlist1 blist1 ::= cases) || 
               (fns2[nlist2] ::= R'), 
               I', O', A')
     /\
     I' ==  (I, toBounds fns2 blist2)    
     /\
     O' == (toBounds fns1 blist1, fns2[nlist2] @ nil)
     /\
     A' == ( insert(bt, A), addAssumptions A nlist2 blist2 )
    .  
      
   *** same rules for channels
   
   crl [subst-channel-case] :
       pConfig(Sigma, Delta, 
               (family fns1 i (bound nt1) ::= cases) || 
               (cn ::= 
                whenList1 ;;
                (when bt --> nf((x : T <- read (fns1[nj]) ) BRL, R, ql)
                ) ;;
                whenList2), I, O, A)
       =>    
       pConfig(Sigma, Delta, 
               (family fns1 i (bound nt1) ::= cases) || 
               (cn ::= 
                whenList1 ;;
                (when bt --> R'
                ) ;;
                whenList2), I, O, A)
       if 
       pConfig(Sigma, Delta, 
               (family fns1 i (bound nt1) ::= cases) || 
               (cn ::= nf((x : T <- read (fns1[nj]) ) BRL, R, ql)), 
               insert( cn @ nil, I), O, insert(bt, A)
              )
      =>
      pConfig(Sigma, Delta, 
               (family fns1 i (bound nt1) ::= cases) || 
               (cn ::= R'), 
               I', O, A')
     /\
     I' == insert( cn @ nil, I)
     /\
     A' == insert(bt, A)
    .

    *** select a case for a channel and do the substitution
    
    crl [select-case-subst] :
       pConfig(Sigma, Delta, 
               (cn1 ::= whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               (cn2 ::= nf((x : T <- read cn1) BRL, R2, ql)),
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               (cn1 ::= whenList1 ;; (when bt --> R1) ;; whenList2)
               ||
               (cn2 ::= R'),
               I, O, A)
      if A |= bt with empty
      /\
         pConfig(Sigma, Delta, 
               (cn1 ::= R1)
               ||
               (cn2 ::= nf((x : T <- read cn1) BRL, R2, ql)),
               I, O, A)
       =>       
       pConfig(Sigma, Delta, 
               (cn1 ::= R1)
               ||
               (cn2 ::= R'),
               I, O, A)      
    .
     
     *** case distinction for family with protocols on cases
     
     crl [CASE-DISTINCTION-one] :
     pConfig (Sigma, Delta, 
               P || family fns q (bound n) ::= ((when bt --> aP1) ;; whenList),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || family fns q (bound n) ::= ((when bt --> aP2) ;; whenList'),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || aP1, insert(fns @ n, I), O, insert(bt, A))
     =>
     pConfig(Sigma, Delta, P || aP2, I', O, A')
     /\
     A' == insert(bt, A)
     /\
     I' == insert(fns @ n, I)
     /\
     pConfig (Sigma, Delta, 
               P || family fns q (bound n) ::= whenList,
               I, O, insert(neg bt, A)) 
     =>
     pConfig(Sigma, Delta, 
              P || family fns q (bound n) ::= whenList',
               I, O, A'')
     /\
     A'' == insert(neg bt, A)
     .   
     
     *** congruence for cases
     *** TODO: add a context P
     *** TODO: might need it for otherwise too?
    
     crl [cong-cases-reaction] :
      pConfig(Sigma, Delta, cn ::= (whenList1 ;; (when bt --> R1) ;; whenList2), I, O, A)
      =>
      pConfig(Sigma, Delta, cn ::= (whenList1 ;; (when bt --> R2) ;; whenList2), I, O, A)
      if 
      pConfig(Sigma, Delta, cn ::= R1, I, O, insert(bt, A))
      =>
      pConfig(Sigma, Delta, cn ::= R2, I, O, A')
      /\
      A' == insert(bt, A)
     . 
     
               
     crl [CASE-DISTINCTION-one-end] :
     pConfig (Sigma, Delta, 
               P || family fns q (bound n) ::= (otherwise --> aP1),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || family fns q (bound n) ::= (otherwise --> aP2),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || aP1, insert(fns @ n, I), O, A) 
             *** A already has all negated conditions
     =>
     pConfig(Sigma, Delta, P || aP2, I', O, A)            
     /\
     I' == insert(fns @ n, I)
     .
     
     crl [CASE-DISTINCTION-one-end-when] :
     pConfig (Sigma, Delta, 
               P || family fns q (bound n) ::= (when bt --> aP1),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || family fns q (bound n) ::= (when bt --> aP2),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || aP1, insert(fns @ n, I), O, insert(bt, A)) 
     =>
     pConfig(Sigma, Delta, P || aP2, I', O, A')            
     /\
     I' == insert(fns @ n, I)
     /\
     A' == insert(bt, A)
     .
     
     *** case distinction for families with reactions on cases
     crl [CASE-DISTINCTION-one-R] :
     pConfig (Sigma, Delta, 
               P || family fns q (bound n) ::= ((when bt --> R1) ;; whenList),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || family fns q (bound n) ::= ((when bt --> R2) ;; whenList'),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || family fns q (bound n) ::= R1, 
             insert(fns @ n, I), O, insert(bt, A))
     =>
     pConfig(Sigma, Delta, P || family fns q (bound n) ::= R2, I', O, A')
     /\
     A' == insert(bt, A)
     /\ 
     I' == insert(fns @ n, I)
     /\
     pConfig (Sigma, Delta, 
               P || family fns q (bound n) ::= whenList,
               I, O, insert(neg bt, A)) 
     =>
     pConfig(Sigma, Delta, 
              P || family fns q (bound n) ::= whenList',
               I, O, A'')
     /\
     A'' == insert(neg bt, A) 
     .   
               
     crl [CASE-DISTINCTION-one-R-end] :
     pConfig (Sigma, Delta, 
               P || family fns q (bound n) ::= (otherwise --> R1),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || family fns q (bound n) ::= (otherwise --> R2),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || family fns q (bound n) ::= R1, 
             insert(fns @ n, I), O, A) 
       *** A already has all negated conditions
     =>
     pConfig(Sigma, Delta, P || family fns q (bound n) ::= R2, I', O, A)            
     /\
     I' == insert(fns @ n, I)
     .
     
     crl [CASE-DISTINCTION-one-R-end-when] :
     pConfig (Sigma, Delta, 
               P || family fns q (bound n) ::= (when bt --> R1),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || family fns q (bound n) ::= (when bt --> R2),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || family fns q (bound n) ::= R1, 
             insert(fns @ n, I), O, insert(bt, A)) 
       *** A already has all negated conditions
     =>
     pConfig(Sigma, Delta, P || family fns q (bound n) ::= R2, I', O, A')            
     /\
     I' == insert(fns @ n, I)
     /\
     A' == insert(bt, A)
     .
     
     *** case distinction for channels with reactions on cases
     crl [CASE-DISTINCTION-channel] :
     pConfig (Sigma, Delta, 
               P || cn ::= ((when bt --> R1) ;; whenList),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || cn ::= ((when bt --> R2) ;; whenList'),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || cn ::= R1, 
             I, O, insert(bt, A))
     =>
     pConfig(Sigma, Delta, P || cn ::= R2, I, O, A')
     /\
     A' == insert(bt, A)
     /\
     pConfig (Sigma, Delta, 
               P || cn ::= whenList,
               I, O, insert(neg bt, A)) 
     =>
     pConfig(Sigma, Delta, 
              P || cn ::= whenList',
               I, O, A'')
     /\
     A'' == insert(neg bt, A) 
     .   
               
     crl [CASE-DISTINCTION-channel-end] :
     pConfig (Sigma, Delta, 
               P || cn ::= (otherwise --> R1),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || cn ::= (otherwise --> R2),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || cn ::= R1, 
             I, O, A) 
       *** A already has all negated conditions
     =>
     pConfig(Sigma, Delta, P || cn ::= R2, I, O, A)            
     .
     
     crl [CASE-DISTINCTION-channel-end-when] :
     pConfig (Sigma, Delta, 
               P || cn ::= (when bt --> R1),
               I, O, A)
     => 
     pConfig(Sigma, Delta, 
              P || cn ::= (when bt --> R2),
               I, O, A) 
     if 
     pConfig(Sigma, Delta, P || cn ::= R1, 
             I, O, insert(bt, A)) 
       *** A already has all negated conditions
     =>
     pConfig(Sigma, Delta, P || cn ::= R2, I, O, A')            
     /\
     A' == insert(bt, A)
     . 
     
  var ltq' : TypedCNameList .    
     
     
     *** apply a rule on a branch of a family
 crl [select-branch-family-p] :
 pConfig(Sigma, Delta, 
               newNF(ltq, 
               P || 
               (family fns nlist blist ::= 
                whenList1 ;;
                (when bt --> P1) ;;
                whenList2), QL),
                I, O, A)
 =>
 pConfig(Sigma, Delta, 
               newNF(ltq', 
               P || 
               (family fns nlist blist ::= 
                whenList1 ;;
                (when bt --> P2) ;;
                whenList2), QL),
                I, O, A)
 if 
  pConfig(Sigma, Delta, newNF(ltq, P || P1, QL), I, O, (A, bt)) 
  =>
  pConfig(Sigma, Delta, newNF(ltq', P || P2, QL), I, O, A')
  /\
  A' == (A, bt)
.    
   
     *** induction
 
     var k n1 n2 : Nat . 
     var R'' : Reaction .
     var qlist : List{NatTerm} .
     *** could be we need k < n in A?
     
 op  allFixed___ : Qid List{NatTerm} List{Bounds} -> Bool .
 eq  allFixed q nil nil = true .
 eq  allFixed q (q nlist) (b1 blist) = allFixed q nlist blist .
 ceq allFixed q (q' nlist) ((fixedBound nt) blist) = allFixed q nlist blist 
     if not (q == q').   
 eq  allFixed q nlist blist = false [owise] .  
          
 op adjustIndex___ : Qid Qid Protocol -> Protocol .
 eq adjustIndex q idx (family fns qlist blist ::= P) =
     family fns qlist (updateAt q idx qlist blist) ::=  
        adjustIndex q idx P .
 eq adjustIndex q idx (family fns qlist blist ::= cases) =  
     family fns qlist (updateAt q idx qlist blist) ::= cases . 
 eq adjustIndex q idx ((family fns qlist blist ::= cases) || P) =  
     (family fns qlist (updateAt q idx qlist blist) ::= cases)
     ||
     adjustIndex q idx P .
 *** wrong for now but make it go through
 eq adjustIndex q idx (cn ::= cases) = cn ::= cases .
 eq adjustIndex q idx ( (cn ::= cases) || P) =  
      (cn ::= cases)
     ||
     adjustIndex q idx P .
     
 op updateAt____ : Qid Qid List{NatTerm} List{Bounds} -> List{Bounds} .
 eq updateAt q idx q' b1 = 
      if q == q' then bound idx else b1 fi .
 eq updateAt q idx (q' nlist) (b1 blist) = 
    ((updateAt q idx q' b1) (updateAt q idx nlist blist))
 . 
     
 op mapFromLists__ : List{NatTerm} List{NatTerm} -> Map{Qid, NatTerm} .
 eq mapFromLists q nt = q |-> nt .
 eq mapFromLists (q qlist) (nt nlist) = (q |-> nt, mapFromLists qlist nlist) .
 
 op substIndex____ : Protocol Qid NatTerm Set{BoolTerm} -> Protocol .
 eq substIndex (family fns qlist blist ::= cases) q idx A = 
      projectIndex (family fns qlist blist ::= cases) 
                   (genPrjIdxTerms q idx qlist blist)
                   A 
                   (mapFromLists qlist (genPrjIdxTerms q idx qlist blist)) .
 eq substIndex ((family fns qlist blist ::= cases) || P1) q idx A =
    (substIndex (family fns qlist blist ::= cases) q idx A)
    ||
    (substIndex P1 q idx A)
 .   
 
 op genPrjIdxTerms____ : Qid NatTerm List{NatTerm} List{Bounds} -> List{NatTerm} .
 eq genPrjIdxTerms q nj nil nil = nil .
 eq genPrjIdxTerms q nj q (bound nt) = nj .
 eq genPrjIdxTerms q nj q (dependentBound q') = nj .
 ceq genPrjIdxTerms q nj q' (fixedBound nt) = nt if q =/= q' .
 ceq genPrjIdxTerms q nj q' (bound nt) = q' if q =/= q' .
 eq genPrjIdxTerms q idx (q' nlist) (b1 blist) =
    ((genPrjIdxTerms q idx q' b1)
     (genPrjIdxTerms q idx nlist blist) 
    )
 .  
 
 var F : Qid .    
     
 op genBoundCond____ : Qid NatTerm List{NatTerm} List{Bounds} -> Set{BoolTerm} .       
 eq genBoundCond q idx q (bound nt) = idx <T nt .
 eq genBoundCond q idx (q q') ((bound nt) b1) = idx <T nt .
 eq genBoundCond q idx (q' q) (b1 (bound nt)) = idx <T nt .
 eq genBoundCond q idx (q' q) ((fixedBound nt) (dependentBound F)) = idx <T fun F nt .
 eq genBoundCond q idx (q q' q'') ((bound nt) b1 b2) = idx <T nt .
 eq genBoundCond q idx (q' q q'') (b1 (bound nt) b2) = idx <T nt .
 eq genBoundCond q idx (q' q'' q) (b1 b2 (bound nt)) = idx <T nt .
 eq genBoundCond q idx (q' q'' q) (b1 (fixedBound nt) (dependentBound F)) = idx <T fun F nt . 
 
     
     ***( call project index on each family in a composition
     op substIndex___ : Protocol NatTerm Set{BoolTerm} -> Protocol .
     eq substIndex (family fns q (bound nt) ::= cases) nj A = 
        projectIndex (family fns q (bound nt) ::= cases) nj A (q |-> nj) .
     eq substIndex (P || family fns q (bound nt) ::= cases) nj A = 
        (projectIndex (family fns q (bound nt) ::= cases) nj A (q |-> nj))
        ||
        substIndex P nj A .  
        
     *** todo: implement these, set the bound to fixedBound idx
     op substIndex1___ : Protocol NatTerm Set{BoolTerm} -> Protocol .
     op substIndex2___ : Protocol NatTerm Set{BoolTerm} -> Protocol .
     )   
      
     ***( an attempt without merging, set problems
     op compatibleProtocols_____ : Protocol Protocol Protocol Qid Set{BoolTerm} -> Bool .
     eq compatibleProtocols P1 P2 P3 idx A =
        (channelsOf(P1) == channelsOf(P2))
        and
        resultsMatch(channelsOf(P2), P2, P3, A, idx)
     .   
     
     var qidSet qidSet' : Set{Qid} .
     
     op resultsMatch : Set{Qid} Protocol Protocol Set{BoolTerm} Qid -> Bool .
     eq resultsMatch(empty, P2, P3, A, idx) = true .
     eq resultsMatch(C, P2, P3, A, idx) = 
        (keepOne P3 (C[idx])) 
        ==
        projectIndex (keepOne P2 C) idx A empty
     .  
     eq resultsMatch((C, qidSet), P2, P3, A, idx) = 
        resultsMatch(C, P2, P3, A, idx)
        and
        resultsMatch(qidSet, P2, P3, A, idx)
     . 
     
     crl [INDUCTION-P-2] : 
       pConfig(Sigma, Delta, 
               family C q (bound nt) ::= P1, 
               I, O, A)
       =>         
       pConfig(Sigma, Delta, 
               family C q (bound nt) ::= P2, 
               I, O, A)
       if *** no base, nt = 0 means emptyProtocol
        pConfig(Sigma, Delta, 
               (family C q (bound idx) ::= P2) 
               || 
               substIndex P1 (idx ++ 1) insert(idx ++ 1 <T nt, A), 
               I, O, insert(idx ++ 1 <T nt, A)
               )       
        => 
        pConfig(Sigma, Delta, 
               P3,
               I, O, A')              
        /\
        A' == insert(idx ++ 1 <T nt, A)
        /\
        compatibleProtocols P1 P2 P3 idx A'      
      [nonexec]         
     .
     )
     
     *** only interested in C[idx], so no families
     op isSubprotocolOf__ : Protocol Protocol -> Bool .
     eq isSubprotocolOf (cn ::= cases) P = 
        (cn ::= cases) == keepOne P cn .
     eq isSubprotocolOf (family fns nlist blist ::= cases) P =
        (family fns nlist blist ::= cases) == keepOne P fns .        
     eq isSubprotocolOf ((cn ::= cases) || P1) P = 
        (cn ::= cases) == keepOne P cn 
        and
        isSubprotocolOf P1 P .
     eq isSubprotocolOf ((family fns nlist blist ::= cases)|| P1) P =
        (family fns nlist blist ::= cases) == keepOne P fns 
        and
        isSubprotocolOf P1 P .    
      
               
     *** auxiliary for induction 
     op adjustIndex__ : Protocol NatTerm -> Protocol .
     eq adjustIndex (family fns q (bound nt) ::= cases) idx = 
                     family fns q (bound idx) ::= cases .   
     eq adjustIndex ((family fns q (bound nt) ::= cases) || P) idx = 
                     (family fns q (bound idx) ::= cases) || adjustIndex P idx .
                     
     *** for families with two indices
     op adjustIndex1__ : Protocol NatTerm -> Protocol .
     eq adjustIndex1 (family fns (q q') (b1 b2) ::= cases) idx = 
                     family fns (q q') ((bound idx) b2) ::= cases .
     eq adjustIndex1 ((family fns (q q') (b1 b2) ::= cases) || P) idx = 
                     (family fns (q q') ((bound idx) b2) ::= cases) || adjustIndex1 P idx .
     
     
     op adjustIndex2__ : Protocol NatTerm -> Protocol .
     eq adjustIndex2 (family fns (q q') (b1 b2) ::= cases) idx = 
                     family fns (q q') (b1 (bound idx)) ::= cases .
     eq adjustIndex2 ((family fns (q q') (b1 b2) ::= cases) || P) idx = 
                     (family fns (q q') (b1 (bound idx)) ::= cases) || adjustIndex2 P idx .
     
     op getInductionBase____ : Protocol Protocol Qid Set{BoolTerm} -> Protocol .
     eq getInductionBase (newfamily fns q (bound nt) : T in P) P2 idx A =
        getInductionBase P P2 idx A .
     eq getInductionBase ( P || family fns q (bound nt) ::= P1) P2 idx A =
        P || (family fns q (bound idx) ::= (adjustIndex P2 idx)) 
                 || substIndex P1 q idx A .
     
     crl [INDUCTION-P-3] : 
       pConfig(Sigma, Delta, 
               P || family fns q (bound nt) ::= P1, 
               I, O, A)
       =>         
       pConfig(Sigma, Delta, 
               P || family fns q (bound nt) ::= P2, 
               I, O, A)
       if *** no base, nt = 0 means emptyProtocol
        pConfig(Sigma, Delta, 
               P || (family fns q (bound idx) ::= (adjustIndex P2 idx)) 
                 || substIndex P1 q idx A, 
               I, O, insert(idx <T nt, A))       
        =>  
        pConfig(Sigma, Delta, 
               P3,
               I, O, A')
        /\
        A' == insert(idx <T nt, A)
        /\
        isSubprotocolOf (substIndex P2 q idx A) P3
        [nonexec]
        .
        
      crl [SINGLE-INDUCTION] : 
       pConfig(Sigma, Delta, 
               P || family fns qlist blist ::= P1, 
               I, O, A)
       =>         
       pConfig(Sigma, Delta, 
               P || family fns qlist blist ::= P2, 
               I, O, A)
       if *** no base, q = 0 means emptyProtocol
        pConfig(Sigma, Delta, 
               P || (adjustIndex q idx (family fns qlist blist ::= P2))
                 || (substIndex P1 q idx A), 
               I, O, insert(genBoundCond q idx qlist blist, A))       
        =>  
        pConfig(Sigma, Delta, 
               P3,
               I, O, A')
        /\
        A' == insert(genBoundCond q idx qlist blist, A)
        /\
        isSubprotocolOf (substIndex P2 q idx A) P3
        /\
        allFixed q qlist blist
        [nonexec]
        .
     
     crl [INDUCTION-P] : 
       pConfig(Sigma, Delta, 
               family fns q (bound nt) ::= P1, 
               I, O, A)
       =>         
       pConfig(Sigma, Delta, 
               family fns q (bound nt) ::= P2, 
               I, O, A)
       if *** no base, nt = 0 means emptyProtocol
        pConfig(Sigma, Delta, 
               (family fns q (bound idx) ::= P2) || substIndex P1 q (idx ++ 1) A, 
               I, O, A)       
        => 
        pConfig(Sigma, Delta, 
               P3,
               I, O, A)              
        /\
        (keepOne P3 fns) ==  (family fns q (bound (idx ++ 1)) ::= P2)      
      [nonexec]         
     .
     
     crl [INDUCTION-P-ctx] : 
       pConfig(Sigma, Delta, 
               P || family fns q (bound nt) ::= P1, 
               I, O, A)
       =>         
       pConfig(Sigma, Delta, 
               P || family fns q (bound nt) ::= P2, 
               I, O, A)
       if *** no base, nt = 0 means emptyProtocol
        pConfig(Sigma, Delta, 
                P || (family fns q (bound idx) ::= P2) || substIndex P1 q (idx ++ 1) A, 
               I, O, A)       
        => 
        pConfig(Sigma, Delta, 
               P3,
               I, O, A)              
        /\
        (keepOne P3 fns) ==  (family fns q (bound (idx ++ 1)) ::= P2)      
      [nonexec]         
     .
     
     var idx : Qid .
     
     crl [INDUCTION-R-one] :
     pConfig(Sigma, Delta ((fns @ n) :: T), 
       P || (family fns q (bound n) ::= R), I, O, A)
     =>
     pConfig(Sigma, Delta ((fns @ n) :: T), 
       P || (family fns q (bound n) ::= R'), I, O, A)
     if 
     pConfig(Sigma, Delta ((fns @ n) :: T), 
       P || (fns[0] ::= replaceVars(R, q |-> 0)), I, O, insert(q =T= 0, A)) 
     => 
     pConfig(Sigma, Delta ((fns @ n) :: T), 
       P || (fns[0] ::= R''), I, O, A')
     /\
     R'' == replaceVars(R', q |-> 0)
     /\
     A' == insert(q =T= 0, A)
     /\
     pConfig(Sigma, Delta ((fns @ n) :: T), 
       P || (family fns q (bound idx) ::= R') || 
            (fns[idx ++ 1] ::= replaceVars(R, q |-> idx ++ 1)), I, O, A) 
     =>
     pConfig(Sigma, Delta ((fns @ n) :: T), 
       P || (family fns q (bound idx) ::= R') 
         || (fns[idx ++ 1] ::= R3), I, O, A) 
     /\
     R3 == replaceVars(R', q |-> idx ++ 1) *** TODO: we should have R', check use
       [nonexec] .
   
       
     crl [INDUCTION-R-two] :
     pConfig(Sigma, Delta ((fns @ (n1 n2)) :: T), 
       P || (family fns (q q') ((bound n1) (bound n2)) ::= R), I, O, A)
     =>
     pConfig(Sigma, Delta ((fns @ (n1 n2)) :: T), 
       P || (family fns (q q') ((bound n1) (bound n2)) ::= R'), I, O, A)
     if 
     pConfig(Sigma, Delta ((fns @ (n1 n2)) :: T), 
       P || (fns[q 0] ::= replaceVars(R, q' |-> 0)), 
       I, insert(fns[q 0] @ nil, getOutputs(P)), A) 
     => 
     pConfig(Sigma, Delta ((fns @ (n1 n2)):: T), 
       P || (fns[q 0] ::= R2), I, O', A)
     /\ O' == insert(fns[q 0] @ nil, getOutputs(P)) 
     /\
     R2 == replaceVars(R', q' |-> 0)
     /\
     pConfig(Sigma, Delta ((fns @ (n1 n2)) :: T), 
       P || (family fns (q q') ((bound n1) (bound idx)) ::= R') 
       || (fns[q (idx ++ 1)] ::= replaceVars(R, q' |-> idx ++ 1 )), I, 
       insert(fns @ (n1 idx),  
                insert(fns[q (idx ++ 1)] @ nil, getOutputs(P))), A) 
     => *** TODO: check inputs!!!
     pConfig(Sigma, Delta ((fns @ (n1 n2)) :: T), 
       P || (family fns (q q') ((bound n1) (bound idx)) ::= R')
         || (fns[q (idx ++ 1)] ::= R3), I, O'', A) 
     /\
     O'' == insert(fns @ (n1 idx),  
                insert(fns[q (idx ++ 1)] @ nil, getOutputs(P)))
     /\
     R3 == replaceVars(R', q' |-> idx ++ 1 )
       [nonexec] .  
         
     crl [INDUCTION-when-one] :
     pConfig(Sigma, Delta, 
       P || (family fns q (bound nt1) ::= cases), I, O, A)
     =>
     pConfig(Sigma, Delta , 
       P || (family fns q (bound nt1) ::= cases'), I, O, A)
     if 
     pConfig(Sigma, Delta , 
       P || (projectIndex (family fns q (bound nt1) ::= cases) 0 A empty ), I, 
       insert( fns[0] @ nil, O \ (fns @ nt1)), 
       insert(q =T= 0, A)
       ) 
     => 
     pConfig(Sigma, Delta , P2, I, O', A')
     /\
     O' == insert(fns[0] @ nil, O \ (fns @ nt1))
     /\
     A' ==  insert(q =T= 0, A) 
     /\
     (keepOne P2 (fns[0])) == (projectIndex (family fns q (bound nt1) ::= cases') 0 A empty)
     /\
     pConfig(Sigma, Delta , 
       P || (family fns q (bound idx) ::= cases') || 
       (projectIndex (family fns q (bound nt1) ::= cases) (idx ++ 1) A empty), I, 
       insert(fns @ idx, insert(fns[idx ++ 1] @ nil, O \ (fns @ nt1))), 
       insert(idx ++ 1 <T nt1, A)
       )
       =>
     pConfig(Sigma, Delta, P3, I, O'', A'')
     /\
     O'' = insert(fns @ idx, insert(C[idx ++ 1] @ nil, O \ (fns @ nt1)))
     /\
     A'' == insert(idx ++ 1 <T nt1, A) 
     /\
     (keepOne P3 (fns[idx ++ 1])) == 
     (projectIndex (family fns q (bound nt1) ::= cases') (idx ++ 1) A empty)           
       [nonexec] . 
      
      crl [INDUCTION-when-one-comb] :
     pConfig(Sigma, Delta, 
       P || (family 'Comp[C C'] q (bound nt1) ::= 
                    ((C[q] ::= R1) || (C'[q] ::= R2)) ), I, O, A)
     =>
     pConfig(Sigma, Delta , 
       P || (family 'Comp[C C'] q (bound nt1) ::= 
                    ((C[q] ::= R3) || (C'[q] ::= R4)) ), I, O, A)
     if 
     pConfig(Sigma, Delta , 
       P || ((C [0] ::= replaceVars(R1, q |-> 0)) || 
             (C'[0] ::= replaceVars(R2, q |-> 0))
            ), I, 
       insert( C[0] @ nil, insert( C'[0] @ nil, O \ (insert(C @ nt1, C' @ nt1)))), 
       insert(q =T= 0, A)
       ) 
     => 
     pConfig(Sigma, Delta , P2 , I, O', A')
     /\
     O' == insert( C[0] @ nil, insert( C'[0] @ nil, O \ (insert(C @ nt1, C' @ nt1))))
     /\
     A' ==  insert(q =T= 0, A) 
     /\
     P2 == P || ((C [0] ::= replaceVars(R3, q |-> 0)) || 
                 (C'[0] ::= replaceVars(R4, q |-> 0)))
     /\
     pConfig(Sigma, Delta , 
       P || (family 'Comp[C C'] q (bound idx) ::= 
                    ((C[q] ::= R3) || (C'[q] ::= R4)) ) || 
                      (C[idx ++ 1] ::= replaceVars(R1, q |-> idx ++ 1) ) 
                      ||
                      (C'[idx ++ 1] ::= replaceVars(R2, q |-> idx ++ 1)), I, 

       insert(C @ idx, 
        insert(C' @ idx,
         insert(C[idx ++ 1] @ nil,
           insert(C'[idx ++ 1] @ nil,
                  O \ (insert(C @ nt1, C' @ nt1)
                      )
                  )))),
       insert(idx ++ 1 <T nt1, A)
       )
       =>
     pConfig(Sigma, Delta, P3, I, O'', A'')
     /\
     O'' = insert(C @ idx, 
        insert(C' @ idx,
         insert(C[idx ++ 1] @ nil,
           insert(C'[idx ++ 1] @ nil,
                  O \ (insert(C @ nt1, C' @ nt1)
                      )
                  ))))
     /\
     A'' == insert(idx ++ 1 <T nt1, A) 
     /\
     P3 == (P || (family 'Comp[C C'] q (bound idx) ::= 
                    ((C[q] ::= R3) || (C'[q] ::= R4)) ) || 
                      (C[idx ++ 1] ::= replaceVars(R3, q |-> idx ++ 1) ) 
                      ||
                      (C'[idx ++ 1] ::= replaceVars(R4, q |-> idx ++ 1))
           )
       [nonexec] .   
     ***(  
     crl [INDUCTION-when-two] :
     pConfig(Sigma, Delta, 
       P || (family C (q q') ((bound n1) (bound n2)) ::= cases), I, O, A)
     =>
     pConfig(Sigma, Delta , 
       P || (family C (q q') ((bound n1) (bound n2)) ::= cases'), I, O, A)
     if 
     pConfig(Sigma, Delta , 
       P || 
       (projectIndex (family C (q q') ((bound n1) (bound n2)) ::= cases) (q 0) A empty ), 
       I, 
       union (O \ (C @ (n1 n2)), C[q 0] @ nil), 
       insert(q' =T= 0, insert(q <T n1, A))
       ) 
     => 
     pConfig(Sigma, Delta , 
       P || P2, I, O', A') 
     /\
     O' == union (O \ (C @ (n1 n2)), C[q 0] @ nil)
     /\
     A' == insert(q' =T= 0, insert(q <T n1, A))
     /\
     P2 == projectIndex (family C (q q') ((bound n1) (bound n2)) ::= cases') (q 0) A empty
     /\
     pConfig(Sigma, Delta , 
       P || (family C (q q') ((bound n1) (bound idx)) ::= cases') || 
       (projectIndex (family C (q q') ((bound n1) (bound n2)) ::= cases) 
                     (q (idx ++ 1)) A empty), 
             I, 
             insert( C @ (n1 idx) , 
                     insert( 
                       C[q (idx ++ 1)] @ nil, 
                       (O \ (C @ (n1 n2)) )
                     ) 
            ), 
             insert(idx <T n2, insert(idx ++ 1 <T n2, insert(q <T n1, A)))
             )
       =>
     pConfig(Sigma, Delta , P4, I, O'', A'')  
     /\
     O'' == insert( C @ (n1 idx) , 
                     insert( 
                       C[q (idx ++ 1)] @ nil , 
                       (O \ (C @ (n1 n2)) )
                     ) 
            )
     /\
     A'' == insert(idx <T n2, insert(idx ++ 1 <T n2, insert(q <T n1, A)))
     /\
     P4 == 
           P || 
           (family C (q q') ((bound n1) (bound idx)) ::= cases') || 
           (projectIndex (family C (q q') ((bound n1) (bound n2)) ::= cases') 
                         (q (idx ++ 1)) A empty)
       [nonexec] .  )
                              
    rl [convert-combined] :
       family fns q (bound n) ::=
        (
         (when bt --> P1 )
         ;;
         (otherwise --> P2)
        )
       => 
       combine q n bt P1 P2 .
       
   rl [drop-group-name] :
     family fns q (bound nt) ::= P 
     => 
     P . 
  
  ***( auxiliaries for induction on bound   
 
 var cases1 cases2 : Cases .    
     
  op channelsOf : Protocol -> Set{Qid} .
  eq channelsOf(family C q (bound nt) ::= cases) = C .
  eq channelsOf(q ::= cases) = q .       
  eq channelsOf(q[nt] ::= cases) = q . 
  eq channelsOf(P1 || P2) = union(channelsOf(P1), channelsOf(P2)) .   
  op validForFamily___ : Cases Protocol Set{BoolTerm} -> Bool .
  eq validForFamily cases2 (family fns q (bound nt) ::= cases1) A =
     (projectIndex (family fns q (bound (nt ++ 1)) ::= cases1) (nt ++ 1) A empty)
     ==
     (fns[nt ++ 1] ::= cases2)
 . 
 )
 
 ***    
 
   crl [wrap-channel-family] :  
       *** this should be made more general 
       *** R may depend on q
       *** R could be on the otherwise branch
     pConfig(Sigma, Delta, 
             newNF( ltq { fns q (bound nt) : T } < fns[nt + 1] : T >
                   , 
                   P || ( fns[nt + 1] ::= R ) || 
                   family fns q (bound nt) ::= (whenList1 ;; (when bt --> R) ;; whenList2), 
                   QL),
             I, O, A)  
     => 
     pConfig(Sigma, Delta, 
             newNF(ltq { fns q (bound (nt + 1)) : T }
                   , 
                   P || 
                   family fns q (bound (nt + 1)) ::=  
                     (whenList1 ;; (when bt --> R) ;; whenList2), 
                   del (fns[nt + 1]) QL),
             I, O, A)  
     if A |= bt with (q |-> (nt + 1))
     .
     
     rl [unwrap-channel-family] :
     pConfig(Sigma, Delta, 
             newNF( ltq { fns q (bound (nt + 1)) : T }
                   , 
                   P  || family fns q (bound (nt + 1)) ::= cases, 
                   QL),
             I, O, A)  
     => 
     pConfig(Sigma, Delta, 
             newNF( ltq { fns q (bound nt) : T } < fns[nt + 1] : T >
                   , 
                   P || 
                   (projectIndex (family fns q (bound (nt + 1)) ::= cases) (nt + 1) A empty) ||
                   (family fns q (bound nt) ::= cases), 
                   fns[nt + 1] :: QL),
             I, O, A)  
    .  
    
    rl [wrap-channel-family-new-R] :
     pConfig(Sigma, Delta, 
             newNF( ltq { fns q (bound nt) : T } < fns[nt + 1] : T >
                   , 
                   P || ( fns[nt + 1] ::= R1 ) || family fns q (bound nt) ::= R2,
                   QL),
             I, O, A) 
     =>
     pConfig(Sigma, Delta, 
             newNF( ltq { fns q (bound (nt + 1)) : T }
                   , 
                   P || family fns q (bound (nt + 1)) ::= 
                          ((when (q =T= (nt + 1)) --> R1) ;; 
                            otherwise --> R2),
                   del (fns[nt + 1]) QL),
             I, O, A)
    .  
    
     rl [wrap-channel-family-new-W] :
     pConfig(Sigma, Delta, 
             newNF( ltq { fns q (bound nt) : T } < fns[nt + 1] : T >
                   , 
                   P || ( fns[nt + 1] ::= R1 ) || family fns q (bound nt) ::= whenList,
                   QL),
             I, O, A) 
     =>
     pConfig(Sigma, Delta, 
             newNF( ltq { fns q (bound (nt + 1)) : T }
                   , 
                   P || family fns q (bound (nt + 1)) ::= 
                          ((when (q =T= (nt + 1)) --> R1) ;; 
                            whenList),
                   del (fns[nt + 1]) QL),
             I, O, A)
    . 
      
    crl [merge-cases] : 
    pConfig(Sigma, Delta, 
             newNF( ltq { fns q (bound nt) : T }
                   , 
                   P || family fns q (bound nt) ::= 
                         (whenList1 ;;
                          (when (q =T= nt1) --> R1) ;;
                          whenList2 ;;
                          (otherwise --> R2)),
                   QL),
             I, O, A) 
     => 
        pConfig(Sigma, Delta, 
             newNF( ltq { fns q (bound nt) : T }
                   , 
                   P || family fns q (bound nt) ::= 
                         (whenList1 ;;
                          whenList2 ;;
                          (otherwise --> R2)),
                   QL),
             I, O, A) 
     if replaceVars(R2, q |-> nt1) == R1 
   .  
   
   var whenCond1 whenCond2 : WhenCond .
   
   rl [merge-cases-when] : 
    pConfig(Sigma, Delta, 
             newNF( ltq { fns nlist blist : T }
                   , 
                   P || family fns nlist blist ::= 
                          (whenCond1 --> R) ;;
                          (whenCond2 --> R),
                   QL),
             I, O, A) 
     => 
        pConfig(Sigma, Delta, 
             newNF( ltq { fns nlist blist : T }
                   , 
                   P || family fns nlist blist ::= R,
                   QL),
             I, O, A) 
   .
   
  rl [merge-cases-channel] : 
    pConfig(Sigma, Delta, 
             newNF( ltq < cn : T >, 
                   P || cn ::= 
                          (whenCond1 --> R) ;;
                          (whenCond2 --> R),
                   QL),
             I, O, A) 
     => 
        pConfig(Sigma, Delta, 
             newNF( ltq < cn : T >, 
                   P || cn ::= R,
                   QL),
             I, O, A) 
   . 
   
   crl [all-same-cases] :
   pConfig(Sigma, Delta, 
           cn ::= ((whenCond1 --> R) ;; whenList), I, O, A)
   =>         
   pConfig(Sigma, Delta, 
           cn ::= R, I, O, A) 
   if allSameReaction whenList R .
   
   crl [all-same-cases-family] :
   pConfig(Sigma, Delta, 
           family fns nlist blist ::= ((whenCond1 --> R) ;; whenList), I, O, A)
   =>         
   pConfig(Sigma, Delta, 
           family fns nlist blist ::= R, I, O, A) 
   if allSameReaction whenList R .
   
   op allSameReaction__ : WhenList Reaction -> Bool .
   eq allSameReaction emptyWhen R = true .
   eq allSameReaction ((whenCond --> R1) ;; whenList)  R2 = 
      (R1 == R2) and allSameReaction whenList R2 .        
 
 *********************
 *** helpers
 *********************
 
 rl [rewrite-protocol] : 
    pConfig(Sigma, Delta, P1, I, O, A)
    =>
    pConfig(Sigma, Delta, P2, I, O, A) [nonexec] .
        
   *** switch to combined notation
   *** family 'Group i n ::= 
   ***   when bt -->    C[i] ::= R1
   ***   otherwise -->  C[i] ::= R2
   *** gets rephrased to
   *** family C i n ::= 
   ***  when bt --> R1
   ***  otherwise --> R2
        
   op combine_____ : Qid NatTerm BoolTerm Protocol Protocol -> Protocol .
   eq combine q n bt (fns[q] ::= R1) (fns[q] ::= R2) = 
      family fns q (bound n) ::= ((when bt --> R1) ;; (otherwise --> R2)) .
   eq combine q n bt (family fns q' (bound m) ::= R1) (family fns q' (bound m) ::= R2) = 
      family fns (q q') ((bound n) (bound m)) ::= ((when bt --> R1) ;; (otherwise --> R2)) .
   eq combine q n bt (family fns q (bound m) ::= R1) (family fns q (bound m) ::= R2) = 
      family fns q (bound m) ::= ((when bt --> R1) ;; (otherwise --> R2)) .   
   eq combine q n bt (P1 || fns[q] ::= R1) (P2 || fns[q] ::= R2) = 
      (family fns q (bound n) ::= ((when bt --> R1) ;; (otherwise --> R2)))
      ||
      combine q n bt P1 P2 . 
   eq combine q n bt (P1 || family fns q' (bound m) ::= R1) 
                     (P2 || family fns q' (bound m) ::= R2) = 
      (family fns (q q') ((bound n) (bound m)) ::= ((when bt --> R1) ;; (otherwise --> R2)) )
      ||
      combine q n bt P1 P2 .
    eq combine q n bt (P1 || family fns q (bound m) ::= R1) 
                      (P2 || family fns q (bound m) ::= R2) = 
      (family fns q (bound m) ::= ((when bt --> R1) ;; (otherwise --> R2)) )
      ||
      combine q n bt P1 P2 .   
  ***( eq combine q n bt (P1 || (cn ::= R1)) (P2 || (cn ::= R2)) = 
      (cn ::= ((when bt --> R1) ;; (otherwise --> R2)) ) ||
      combine q n bt P1 P2 . )
   eq combine q n bt P1 P2 = emptyProtocol [owise] .     
   
   var f : Map{Qid, NatTerm} .
   
   *** given a family C and an index i, return C[i] ::= the correspoding case
   *** we might get more than one case, but often we get just a reaction or a protocol
   op projectIndex____ : Protocol List{NatTerm} Set{BoolTerm} Map{Qid, NatTerm} -> Protocol .
   *** projectIndex (family C i n ::= cases) nj A f = C[nj] ::= cases(nj)
   eq projectIndex (family fns q (bound nt) ::= cases) nj A f = 
       projectIndexAux (family fns q (bound nt) ::= cases) nj A f emptyWhen .
   eq projectIndex (family fns (q q') (b1 b2) ::= cases) (t1 t2) A f = 
       projectIndexAux2 (family fns (q q') (b1 b2) ::= cases) (t1 t2) A f emptyWhen .
   eq projectIndex (family fns (q q' q'') (b1 b2 b3) ::= cases) (t1 t2 t3) A f =
      projectIndexAux3 (family fns (q q' q'') (b1 b2 b3) ::= cases) (t1 t2 t3) A f emptyWhen .    
   
   eq projectIndex (family 'Comp[fns1 fns2] q (bound nt) ::= 
                      ( (fns1[q] ::= R1) || (fns2[q] ::= R2) )
                   ) nj A f = 
      (fns1[nj] ::= replaceVars(R1, ((q |-> nj), f)) )
      ||             
      (fns2[nj] ::= replaceVars(R2, ((q |-> nj), f)) )
   .       
          
   eq projectIndex P nj A f = P [owise] .
   
   op projectIndexAux_____ : Protocol NatTerm Set{BoolTerm} Map{Qid, NatTerm} Cases -> Protocol .
   eq projectIndexAux (family fns q (bound nt) ::= R) 
        nj A f cases =
      projectIndexAux (family fns q (bound nt) ::= (otherwise --> R)) 
        nj A f cases .
   eq projectIndexAux
       (family fns q (bound nt) ::= emptyWhen)
       nj A f cases = fns[nj] ::= cases .      
   ceq projectIndexAux 
        (family fns q (bound nt) ::= (when bt --> R) ;; whenList) 
        nj A f cases = 
        fns[nj] ::= replaceVars(R, insert(q, nj, f)) 
    if A |= bt with (insert(q, nj, f)) .
   ceq projectIndexAux 
        (family fns q (bound nt) ::= (when bt --> R) ;; whenList) 
        nj A f cases = 
        projectIndexAux 
        (family fns q (bound nt) ::= whenList) 
        nj A f cases
    if A |= neg bt with (insert(q, nj, f)) .
    eq projectIndexAux 
        (family fns q (bound nt) ::= (when bt --> R) ;; whenList) 
        nj A f cases = 
        projectIndexAux 
        (family fns q (bound nt) ::= whenList) 
        nj A f (cases ;; when subst(bt, q |-> nj) --> replaceVars(R, insert(q, nj, f)))
    [owise] .
    ceq projectIndexAux 
        (family fns q (bound nt) ::= (otherwise --> R)) 
        nj A f cases = 
        fns[nj] ::= replaceVars(R, insert(q, nj, f)) 
    if cases == emptyWhen .
    eq projectIndexAux 
        (family fns q (bound nt) ::= (otherwise --> R)) 
        nj A f cases = 
        fns[nj] ::= cases ;; (otherwise --> replaceVars(R, insert(q, nj, f)))
    [owise] .
    
    var b1 b2 b3 : Bounds .
    
    op projectIndexAux2_____ : 
         Protocol List{NatTerm} Set{BoolTerm} Map{Qid, NatTerm} Cases -> Protocol .   
    eq projectIndexAux2 (family fns (q q') (b1 b2)  ::= R ) 
        (t1 t2) A f cases =
      projectIndexAux2  
         (family fns (q q') (b1 b2)  ::= otherwise --> R ) 
        (t1 t2) A f cases .
    ceq projectIndexAux2 
        (family fns (q q') (b1 b2)  ::= (when bt --> R) ;; whenList) 
        (t1 t2) A f cases = 
        fns[t1 t2] ::= replaceVars(R, ((q |-> t1), (q' |-> t2), f)) 
    if A |= bt with (f, q |-> t1, q' |-> t2) .
   ceq projectIndexAux2 
        (family fns (q q') (b1 b2)  ::= (when bt --> R) ;; whenList) 
        (t1 t2) A f cases = 
        projectIndexAux2 
        (family fns (q q') (b1 b2)  ::= whenList) 
        (t1 t2) A f cases
    if A |= neg bt with (f, q |-> t1, q' |-> t2) .
    eq projectIndexAux2 
        (family fns (q q') (b1 b2) ::= (when bt --> R) ;; whenList) 
        (t1 t2) A f cases = 
        projectIndexAux2 
        (family fns (q q') (b1 b2)  ::= whenList) 
        (t1 t2) A f 
         (cases ;; 
           when subst(bt, (q |-> t1, q' |-> t2)) --> 
             replaceVars(R, ((q |-> t1), (q' |-> t2), f)) 
         )
    [owise] .
    ceq projectIndexAux2 
        (family fns (q q') (b1 b2)  ::= (otherwise --> R)) 
        (t1 t2) A f cases = 
        fns[t1 t2] ::= replaceVars(R, ((q |-> t1), (q' |-> t2), f)) 
    if cases == emptyWhen .
    eq projectIndexAux2 
        (family fns (q q') (b1 b2)  ::= (otherwise --> R)) 
        (t1 t2) A f cases = 
        fns[t1 t2] ::= cases ;; (otherwise --> replaceVars(R, ((q |-> t1), (q' |-> t2), f)) )
    [owise] .
    eq projectIndexAux2 
        (family fns (q q') (b1 b2)  ::= emptyWhen) 
        (t1 t2) A f cases = 
        fns[t1 t2] ::= cases .
        
    
    var nt3 t1 t2 t3 : NatTerm .
    
    op projectIndexAux3_____ 
         : Protocol List{NatTerm} Set{BoolTerm} 
           Map{Qid, NatTerm} Cases -> Protocol .        
    eq projectIndexAux3 (family fns (q q' q'') (b1 b2 b3)  ::= R ) 
        (t1 t2 t3) A f cases' =
      projectIndexAux3  
         (family fns (q q' q'') (b1 b2 b3)  ::= otherwise --> R ) 
        (t1 t2 t3) A f cases' .
    ceq projectIndexAux3 
        (family fns (q q' q'') (b1 b2 b3)  ::= (when bt --> R) ;; whenList) 
        (t1 t2 t3) A f cases' = 
        fns[t1 t2 t3] ::= replaceVars(R, ((q |-> t1),(q' |-> t2),(q'' |-> t3), f)) 
    if A |= bt with (f, q |-> t1, q' |-> t2, q'' |-> t3)  .
   ceq projectIndexAux3 
        (family fns (q q' q'') (b1 b2 b3)  ::= (when bt --> R) ;; whenList) 
        (t1 t2 t3) A f cases' = 
        projectIndexAux3 
        (family fns (q q' q'') (b1 b2 b3)  ::= whenList) 
        (t1 t2 t3) A f cases'
    if A |= neg bt with (f, q |-> t1, q' |-> t2, q'' |-> t3) .
    eq projectIndexAux3 
        (family fns (q q' q'') (b1 b2 b3) ::= (when bt --> R) ;; whenList) 
        (t1 t2 t3) A f cases' = 
        projectIndexAux3
        (family fns (q q' q'') (b1 b2 b3)  ::= whenList) 
        (t1 t2 t3) A f 
        (cases' ;; when subst(
                         bt, 
                         (q |-> t1, q' |-> t2, q'' |-> t3)
                        )  --> 
                         replaceVars(R, ((q |-> t1),(q' |-> t2),(q'' |-> t3), f)) 
        )
    [owise] .
    ceq projectIndexAux3 
        (family fns (q q' q'') (b1 b2 b3)  ::= (otherwise --> R)) 
        (t1 t2 t3) A f cases' = 
        fns[t1 t2 t3] ::= replaceVars(R, ((q |-> t1),(q' |-> t2),(q'' |-> t3), f)) 
    if cases' == emptyWhen .
    eq projectIndexAux3 
        (family fns (q q' q'') (b1 b2 b3)  ::= (otherwise --> R)) 
        (t1 t2 t3) A f cases' = 
        fns[t1 t2 t3] ::= 
          cases' ;; 
          (otherwise --> 
            replaceVars(R, ((q |-> t1),(q' |-> t2),(q'' |-> t3), f)) 
          )
    [owise] .
    eq projectIndexAux3 
        (family fns (q q' q'') (b1 b2 b3) ::= emptyWhen) 
        (t1 t2 t3) A f cases' = 
         fns[t1 t2 t3] ::= cases' .      
      
          
   
    *** rules for grouping and ungrouping families  
 
 rl [group-families] :
   pConfig( Sigma, Delta, 
           P || (family fns1 q (bound nt) ::= R1) || (family fns2 q (bound nt) ::= R2),
           I, O, A)
   => 
   pConfig( Sigma, Delta, *** don't change context, temporary representation
   P || family 'Comp[fns1 fns2] q (bound nt) ::= (fns1[q] ::= R1) || (fns2[q] ::= R2),
   I, O, A
   )
 .
 
 rl [ungroup-families] :
   pConfig( Sigma, Delta,
   P || family 'Comp[fns1 fns2] q (bound nt) ::= (fns1[q] ::= R1) || (fns2[q] ::= R2),
   I, O, A
   )
   => 
   pConfig( Sigma, Delta, 
           P || (family fns1 q (bound nt) ::= R1) || (family fns2 q (bound nt) ::= R2),
           I, O, A)
 .
 
 rl [add-same-cases] :
   pConfig(Sigma, Delta, family fns q (bound nt) ::= R, I, O, A) 
   =>
   pConfig(Sigma, Delta, 
            family fns q (bound nt) ::= 
              (when bt --> R)
              ;;
              (otherwise --> R), I, O, A) 
 [nonexec]
 . 
 
 rl [replace-var-branch] :
  pConfig(Sigma, Delta, 
           family fns q (bound nt) ::= 
                whenList1 
             ;; (when (q =T= n) --> R)
             ;; whenList2, I, O, A)
  =>  
  pConfig(Sigma, Delta, 
           family fns q (bound nt) ::= 
                whenList1 
             ;; (when (q =T= n) --> replaceVars(R, q |-> n))
             ;; whenList2, I, O, A)
 .            

 rl [get-channel] :
 pConfig(Sigma, Delta, P, I, O, A)
 => 
 pConfig(Sigma, Delta, getChannel P cn, I, O, A)
 [nonexec]
 .
 
 rl [get-structure] :
 pConfig(Sigma, Delta, P, I, O, A)
 => 
 pConfig(Sigma, Delta, getStructure P, I, O, A)
 .
         
endm



mod APPROX-EQUALITY is
  protecting PROTOCOL-EQUALITY .
    
  *** wrappers for width and length
  
  sort Width .
  sort Length .
  
  op width_ : Nat -> Width [ctor] .
  op length_ : Nat -> Length [ctor] .
  
  *** measure
  op |_| : Protocol -> Nat .
  op |_| : Reaction -> Nat .
  op |_| : Expression -> Nat .
 
  *** for expressions
  
  var q f : Qid .
  var M M1 M2 : Expression .
  
  eq | q  | = 1 .
  eq | () | = 1 . 
  eq | True | = 1 .
  eq | False | = 1 .
  eq | ap f M | = 1 + | M | .
  eq | pair(M1, M2) | = | M1 | + | M2 | . 
  eq | fst(M) | = | M | .
  eq | snd(M) | = | M | .
  
  *** for reactions
    
  var cn : ChannelName .  
  var T : Type .
  var R R1 R2 : Reaction .
  var x : Qid .
  var BL : BindList .
  var BRL : BRList .
  var QL : CNameList .
    
  eq | return M | = | M | .
  *** eq | samp flip | = 1 .
  eq | samp (q < M > ) | = 1 + | M | . 
  eq | read cn | = 1 . 
  eq | if M then R1 else R2 | = | M | + defMax( | R1 |, | R2 | ) . 
  eq | x : T <- R1 ; R2 | = | R1 | + | R2 | .
  
  eq | x : T <~ R | = | R | .
  eq | nf(BRL, R, QL) | = | R | + size(BRL) .
  eq | preNF(BL, R, QL) | =  | R | + size(BL) .
  
  *** for protocols
  
  var P1 P2 : Protocol .
  var blist : List{Bounds} .
  var nlist : List{NatTerm} .
  var c : NameWithScripts . 
  var q' : Qid .
  var ltq : TypedCNameList .
  var bt : BoolTerm .
  
  eq | emptyProtocol | = 0 .
  eq | cn ::= R | = | R | .
  eq | P1 || P2 | = | P1 | + | P2 | .
  eq | new cn : T in P | = | P | .  
  
  eq | newfamily c nlist blist : T in P | = | P | .
  eq | newNF(ltq, P, QL) | = | P | . 
  eq | family c q (bound n) ::= R | = n * | R | .
  eq | family c q (bound n) ::= P | = n * | P | .
  eq | family c (q q') ((bound n1) (bound n2))  ::= R | = n1 * n2 * | R | .
  eq | family c (q q') ((bound n1) (bound n2))  ::= P | = n1 * n2 * | P | .
  
  eq | family c q (bound n) ::= when bt --> R | = n * | R | .
  eq | family c q (bound n) ::= otherwise --> R | = n * | R | . 
    
  *** the new configuration
  
  sort ApproxEqConfig .
  
  op aConfig : Signature ChannelContext Protocol 
              Set{CNameBound} Set{CNameBound} Set{BoolTerm} 
              Width Length -> 
              ApproxEqConfig [ctor] .
  
 var Sigma : Signature .
 var Delta Delta' : ChannelContext .
 var P Q P' Q' : Protocol .
 var I O I' O' I1 O1 : Set{CNameBound} .
 var A A' : Set{BoolTerm} .
 var w w' : Width .
 var l l' : Length .
 var n n' n1 n2 nw nw1 nw2 nw' nl nl1 nl2 nl' : Nat .
 
 *** the rules
 
 crl [STRICT] :
   aConfig(Sigma, Delta, P, I, O, A, w, l) 
   =>
   aConfig(Sigma, Delta, Q, I, O, A, w, l)
 if
  pConfig(Sigma, Delta, P, I, O, A)
  => 
  pConfig(Sigma, Delta, Q, I, O, A)
 .  
 
 crl [SYM-APPROX] :
   aConfig(Sigma, Delta, P, I, O, A, w, l) 
   =>
   aConfig(Sigma, Delta, Q, I, O, A, w', l')
   if
    aConfig(Sigma, Delta, Q, I, O, A, w, l) 
   =>
   aConfig(Sigma, Delta, P, I, O, A, w', l')
 [nonexec]
 .
 
 crl [TRANS] :
  aConfig(Sigma, Delta, P, I, O, A, width nw, length nl)
  => 
  aConfig(Sigma, Delta, P2, I, O, A, width (nw + nw1 + nw2), length (nl + defMax(nl1, nl2)))
 if
  aConfig(Sigma, Delta, P, I, O, A, width 0, length 0)
  => 
  aConfig(Sigma, Delta, P1, I, O, A, width nw1, length nl1)
  /\ 
  aConfig(Sigma, Delta, P1, I, O, A, width 0, length 0)
  => 
  aConfig(Sigma, Delta, P2, I, O, A, width nw2, length nl2)
 .  
  
 crl [CONG-COMP-APPROX] :
  aConfig(Sigma, Delta, P1 || Q, I, O, A, width nw, length nl)
  =>
  aConfig(Sigma, Delta, P2 || Q, I, O, A, width (nw + nw1), length (nl + nl1 + | Q | ))
 if 
  aConfig(Sigma, Delta, P1, union(I, getOutputs(Q)), getOutputs(P1), A, width 0, length 0)
  => 
  aConfig(Sigma, Delta, P2, I1, O1, A, width nw1, length nl1)
  /\ O1 == getOutputs(P1) 
  /\ I1 == union(I, getOutputs(Q))
  /\ O == union (getOutputs(P1), getOutputs(Q))
  /\ typeOf(Sigma, Delta, union(I, getOutputs(P1)), A, Q) 
 .
  
 crl [CONG-NEW-APPROX] :
   aConfig(Sigma, Delta, new cn : T in P , I, O, A, width nw, length nl)
  =>
   aConfig(Sigma, Delta, new cn : T in P' , I, O, A, width (nw + nw1), length (nl + nl1 ))
 if 
   aConfig(Sigma, Delta (cn @ nil :: T), P, I, union (cn @ nil, O), A, width 0, length 0)
  =>   
  aConfig(Sigma, Delta  (cn @ nil :: T), P', I, O', A, width nw1, length nl1)
  /\ O' == union (cn @ nil, O)
 .  
 
 crl [CONG-NEW-NF-APPROX] :
   aConfig(Sigma, Delta, newNF(ltq, P, QL), I, O, A, width nw, length nl)
  =>
   aConfig(Sigma, Delta, newNF(ltq, P', QL) , I, O, A, width (nw + nw1), length (nl + nl1 ))
 if 
   aConfig(Sigma, addChannels ltq Delta, P, I, union(chansInList ltq, O), A, width 0, length 0)
  =>   
  aConfig(Sigma, Delta', P', I, O', A, width nw1, length nl1)
  /\ O' == union(chansInList ltq, O)
  /\ Delta' == addChannels ltq Delta
 .  
 
 *** for some reason Maude does not set the max between anything and 0
 *** to that anything, and we need this for a bound, which is a constant
 *** of sort Nat.     
 op defMax : Nat Nat -> Nat .
 eq defMax(n, 0) = n .
 eq defMax(0, n) = n .
 eq defMax(n, n) = n .
 eq defMax(n1, n2) = max(n1, n2) [owise] .     
      
endm
