***( IPDL

  Copyright : (C) 2022-23, Kristina Sojakova
  License   : GNU General Public License v3.0 or later (GPL-3.0-or-later)
  Authors   : Mihai Codescu <mscodescu@gmail.com>
              Kristina Sojakova <sojakova.kristina@gmail.com>

 Strategies for applying the rules. They are grouped by the main rule that is applied,
 e.g. subst or absorb, and they may have several forms to be applied in different context
 e.g. channels, families, groups of families, cases.
 
)

in ../src/syntax

smod STRATS is
 pr APPROX-EQUALITY .
 
 *** vars
  
 var pConf : ProtocolConfig .
 var rConf : ReactionConfig .
 var S Sigma : Signature .
 var D Delta : ChannelContext .
 var G : TypeContext .
 var P P1 P2 pr : Protocol .
 var R R1 R2 R3 R4 : Reaction .
 *** var Q Q' C Q1 Q2 x1 x2 y x : Qid .
 var c' : Qid .        
 var I O : Set{CNameBound} .
 var T T' T1 : Type .
 var flag : Bool .
 var M M1 M2 : Expression .
 var Dis : Distribution .
 var C C1 C2 x : ChannelName .
 var Q Q' x1 Q1 Q2 q1 q2 q3 q4 : Qid .
 var A : Set{BoolTerm} .
 var N w l : Nat .
 var nlist : List{NatTerm} .
 var blist : List{Bounds} .
 var BRL : BRList . 
 var ltq : TypedCNameList .
 var ql ql' cnl ql2 : CNameList .
 var nt : NatTerm . 
 
 ***************************************
 *** substitution strategies
 ***************************************
 
 *** try both channel substitution rules
 strat smart-subst-nf : ChannelName ChannelName @ ProtocolConfig . 
 sd smart-subst-nf(C1, C2) :=                        
   substNFRead(C1, C2)
   ? idle
   : substNF(C1, C2) 
   . 
 
 *** substitution
 
 strat substNF : ChannelName ChannelName @ ProtocolConfig .
 sd substNF(C1, C2) :=  
     nTimesSubstNF(C1, C2) 
   ; liftInnerBindsNF(C2)
   ; handleRNF(C2)
   ; try (pre2Nf) 
   .   
 
 *** sub-steps in substitution
 
 *** apply SUBST of C1 in C2
 *** if the current P is newNF(..., C1 ::= R1 || C2 ::= nf( BRL (x <- read C1), R2, order) || Q  ,...) 
 strat nTimesSubstNF : ChannelName ChannelName @ ProtocolConfig .
 sd nTimesSubstNF(C1, C2) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstNF(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
         CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                         P1:Protocol <- keepTwo P C1 C2]{
           SUBST-nf[o1:ChannelName <- C1, 
                    o2:ChannelName <- C2]
         }
         or-else *** deal with the case that Q is empty
         SUBST-nf[o1:ChannelName <- C1, 
                    o2:ChannelName <- C2]
       )            .
                   
 *** similar, but for SUBST-nf-read                               
 strat substNFRead : ChannelName ChannelName @ ProtocolConfig .
 sd substNFRead(C1, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substNFRead(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
         CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                         P1:Protocol <- keepTwo P C1 C2]{
           SUBST-nf-read[o1:ChannelName <- C1, 
                         o2:ChannelName <- C2] 
         }
         or-else  
         SUBST-nf-read[o1:ChannelName <- C1, 
                         o2:ChannelName <- C2] 
       ).                   
 
 *** after subst we got x <~ nf(binds, R, ...)
 *** this strategy moves the binds outside <~
 strat liftInnerBindsNF : ChannelName @ ProtocolConfig .
 sd liftInnerBindsNF(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{liftInnerBindsNF(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        (  
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                        P1:Protocol <- keepOne P C]{
         CONG-REACT[cn:ChannelName <- C]
         { try (     (bind-bind-pre or-else bind-bind-pre-pre)
                   ; (read-det-pre !)
               )
         }
        }
        )
        or-else
        (CONG-REACT[cn:ChannelName <- C]
         { try (     (bind-bind-pre or-else bind-bind-pre-pre)
                   ; (read-det-pre !)
               )
         }) 
       .
 
 *** this strategy handles the reaction of a pre-normal form, 
 *** applying various reaction-level rules.
 *** the goal is to move binds outside the reaction
 strat handleRNF : ChannelName @ ProtocolConfig .  
 sd handleRNF(C1) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{handleRNF(C1)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
         (
         CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C1, 
                             P1:Protocol <- keepOne P C1]{
         CONG-REACT[cn:ChannelName <- C1]
                   {(ret-bind-pre or-else
                    (samp-over-if or-else 
                     (read2Binds or-else
                      (bind-ret-2-pre
                        or-else (merge-pre ; cong-pre-nf{bindFreeS})
                      )
                     )
                    )
                    ) 
                    ; simplifyNF
                   }
       }
       )
       or-else
       (
       CONG-REACT[cn:ChannelName <- C1]
                   {(ret-bind-pre or-else
                    (samp-over-if or-else 
                     (read2Binds or-else
                      (bind-ret-2-pre
                        or-else (merge-pre ; cong-pre-nf{bindFreeS})
                      )
                     )
                    )
                    ) 
                    ; simplifyNF
                   }
       ) .
       
 strat bindFreeS @ ReactionConfig .
 sd bindFreeS := 
     ((smart-ret-bind ; (if-left ? idle : (if-right ? idle : idle)) ) or-else
       (if-over-bind  
        ; cong-branch-refl{bindFreeS, bindFreeS}
       )
       ) or-else idle . 
       
 strat simplifyNF @ ReactionConfig .
 sd simplifyNF :=  
   cong-pre-nf{same-reaction-if} or-else idle 
 .    
 
 strat smart-ret-bind @ ReactionConfig .
 sd smart-ret-bind :=
     if-over-bind-same-2 
     ? (cong-branch-refl
        {cong-branch-refl{ret-bind , ret-bind},
         cong-branch-refl{ret-bind , ret-bind}} 
        ? idle
        : fail)  
     : (if-over-bind-same 
       ? (cong-branch-refl{ret-bind, ret-bind} ? idle : idle) 
       : ret-bind) 
       .   
   
 *** similar to substNF, but for families with one index
 strat substNFFamiliesOne : ChannelName ChannelName Reaction @ ProtocolConfig .
 sd substNFFamiliesOne(C1, C2, R) :=
     nTimesSubstNFFamiliesOne(C1, C2, R)
  ; liftInnerBindsNFFamily(C2)
  ; handleRNFFamily(C2)
  ; (pre2Nf or-else idle)  
 .
 
 *** sub-strategies, similar to the ones above
 strat nTimesSubstNFFamiliesOne :  Qid Qid Reaction @ ProtocolConfig .
 sd nTimesSubstNFFamiliesOne(Q1, Q2, R) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstNFFamiliesOne(Q1, Q2, R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P Q1 Q2, 
                             P1:Protocol <- keepTwo P Q1 Q2]{
          subst-families-one-family[
                   C:Qid <- Q1, 
                   C1:Qid <- Q2,
                   R2:Reaction <- R
                ]
                   } 
                or-else
                subst-families-one-family[
                   C:Qid <- Q1, 
                   C1:Qid <- Q2,
                   R2:Reaction <- R
                ]
       )
 .
 
 strat liftInnerBindsNFFamily : Qid @ ProtocolConfig .
 sd liftInnerBindsNFFamily(Q) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{liftInnerBindsNFFamily(Q)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       (
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P Q, 
                        P1:Protocol <- keepOne P Q]{
         CONG-FAMILY-R[C:Qid <- Q]
         { (  bind-bind-pre 
          ; (read-det-pre !)
           )
           or-else idle
         }
        }
        
        or-else
        CONG-FAMILY-R[C:Qid <- Q]
         { (  bind-bind-pre 
          ; (read-det-pre !)
           )
           or-else idle
         }
         
        )
 . 
      
         
 strat handleRNFFamily : Qid @ ProtocolConfig .  
 sd handleRNFFamily(Q) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{handleRNFFamily(Q)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P Q, 
                             P1:Protocol <- keepOne P Q]{
         CONG-FAMILY-R[C:Qid <- Q]
                   {(ret-bind-pre or-else
                    (samp-over-if or-else 
                     (read2Binds or-else
                      (bind-ret-2-pre
                        or-else (merge-pre ; cong-pre-nf{bindFreeS})
                      )
                     )
                    )
                    ) 
                    ; simplifyNF
                   }
       } 
       or-else
       CONG-FAMILY-R[C:Qid <- Q]
                   {(ret-bind-pre or-else
                    (samp-over-if or-else 
                     (read2Binds or-else
                      (bind-ret-2-pre
                        or-else (merge-pre ; cong-pre-nf{bindFreeS})
                      )
                     )
                    )
                    ) 
                    ; simplifyNF
                   }
       ).  
       
 *** under the assumption that the current protocol is of the form
 ***     family q2 ::= P || family q1 ::= when cond1 --> P1 ;; otherwise --> P2
 ***     do a substitution in P || P1               
 strat applyCaseDistSubst : Qid Qid Qid Qid Protocol @ ProtocolConfig .
 sd applyCaseDistSubst(q1, q2, q3, q4, pr) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyCaseDistSubst(q1, q2, q3, q4, pr)}
    : 
       CASE-DISTINCTION-one[aQid:Qid <- q1]
         { use-family-p[C:Qid <- q2]
             { COMP-NEW-newNF
             ; applySubstReadFamilyTwoFamily(q3, q4)
             ; (SYM[P1:Protocol <- pr]{COMP-NEW-newNF})
             }
         , idle
         } .         
         
  *** sub-strategy
                                               
 strat applySubstReadFamilyTwoFamily : Qid Qid @ ProtocolConfig .
 sd applySubstReadFamilyTwoFamily(q3, q4) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstReadFamilyTwoFamily(q3, q4)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P q3 q4, 
                             P1:Protocol <- keepTwo P q3 q4]
             {SUBST-nf-read-family-two-family}                
             or-else
             SUBST-nf-read-family-two-family
             )
 . 
 
 *** do a subst on the first branch of a family
  strat applySubstChannelBranch : Qid Qid @ ProtocolConfig .
 sd applySubstChannelBranch(q1, q2) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applySubstChannelBranch(q1, q2)}
    :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using  
       CASE-DISTINCTION-one-R[aQid:Qid <- q1, P:Protocol <- removeOne P q1]
         {  substChannelFamilyOne(q2, q1)
           , idle
         } .  
         
  *** substitute a channel in a family
  strat substChannelFamilyOne : ChannelName ChannelName @ ProtocolConfig .
 sd substChannelFamilyOne(C1, C2) :=
    nTimesSubstChannelFamilyOne(C1, C2)
  ; liftInnerBindsNFFamily(C2)
  ; handleRNFFamily(C2)
  ; (pre2Nf or-else idle)  
 . 
 
 *** sub-strategy, similar to subst-nf
 strat nTimesSubstChannelFamilyOne :  ChannelName ChannelName @ ProtocolConfig .
 sd nTimesSubstChannelFamilyOne(C1, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstChannelFamilyOne(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{                  
                   subst-channel-one-family}
               or-else    
               subst-channel-one-family
             )
 .   
 
 *** on the left branch of the right branch of a family, do a substitution
 strat applyCaseDistBranch2 : Qid Qid @ ProtocolConfig .
 sd applyCaseDistBranch2(q1, q2) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyCaseDistBranch2(q1, q2)}
    :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using  
       CASE-DISTINCTION-one-R[aQid:Qid <- q1, P:Protocol <- removeOne P q1]
         { idle
         , CASE-DISTINCTION-one-R[aQid:Qid <- q1]
           { substChannelFamilyOne(q2, q1)
           , idle}
         } .   
         
   *** on the left branch of a family, do a reverse subst
 strat applyBranch2SubstRev : Qid Qid NatTerm Qid Type Reaction @ ProtocolConfig .
 sd applyBranch2SubstRev(q1, q2, nt, x, T, R) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyBranch2SubstRev(q1, q2, nt, x, T, R)}
    :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using  
       CASE-DISTINCTION-one-R[aQid:Qid <- q1, P:Protocol <- removeOne P q1]
         {   applySubstNfRevFamiliesOne(q1, q2, nt, x, T, R)
           , idle
         } . 
         
  *** does the reverse substitution
  strat applySubstNfRevFamiliesOne : ChannelName ChannelName NatTerm Qid Type Reaction @ ProtocolConfig .
 sd applySubstNfRevFamiliesOne(C1, C2, nt, x, T, R) := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstNfRevFamiliesOne(C1, C2, nt, x, T, R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{                  
                    SUBST-nf-rev-families-one[
                      x1:ChannelName <- x, 
                      nj:NatTerm <- nt,
                      R2:Reaction <- R,
                      T1:Type <- T]
                     }
                or-else  
                 SUBST-nf-rev-families-one[
                      x1:ChannelName <- x, 
                      nj:NatTerm <- nt,
                      R2:Reaction <- R,
                      T1:Type <- T]    
              )       
 .                     
   
   *** subst-reverse with a case in a family
 strat applySubstRevFamily : Qid ChannelName Type @ ProtocolConfig .
 sd applySubstRevFamily(Q, C2, T) := 
 match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstRevFamily(Q, C2, T)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
              CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P Q C2, 
                             P1:Protocol <- keepTwo P Q C2]
             {subst-rev-families[C:Qid <- Q, 
                    cn2:ChannelName <- C2,
                    T:Type <- T]} 
              or-else    
              subst-rev-families[C:Qid <- Q, 
                    cn2:ChannelName <- C2,
                    T:Type <- T] 
             )        
 .   
                    
 *** subst-nf-read for families with one and two indices
 strat substNFReadFamilyOneChannel : Qid ChannelName @ ProtocolConfig .
 sd substNFReadFamilyOneChannel(Q, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substNFReadFamilyOneChannel(Q, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P Q C2, 
                             P1:Protocol <- keepTwo P Q C2]{
         SUBST-nf-read-family-one
                      [ q1:ChannelName <-  Q, 
                       cn2:ChannelName <- C2] } 
               or-else   
               SUBST-nf-read-family-one
                      [ q1:ChannelName <-  Q, 
                       cn2:ChannelName <- C2]     
                       ) 
  . 
                       
 strat substNFReadFamilyTwoChannel : Qid ChannelName @ ProtocolConfig .
 sd substNFReadFamilyTwoChannel(Q, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substNFReadFamilyTwoChannel(Q, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P Q C2, 
                             P1:Protocol <- keepTwo P Q C2]{
         SUBST-nf-read-family-two
                      [ q1:ChannelName <-  Q, 
                       cn2:ChannelName <- C2] } 
             or-else          
         SUBST-nf-read-family-two
                      [ q1:ChannelName <-  Q, 
                       cn2:ChannelName <- C2]         
             )
 .
 
 *** subst-reverse for a family and a channel
 strat substRevFamilyChannel : Qid ChannelName NatTerm Type @ ProtocolConfig .
 sd substRevFamilyChannel(Q, C2, nt, T) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substRevFamilyChannel(Q, C2, nt, T)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P Q C2, 
                             P1:Protocol <- keepTwo P Q C2]{
         subst-2-families-one
                      [ C:Qid <-  Q, 
                        cn2:ChannelName <- C2,
                        nj:NatTerm <- nt,
                        T:Type <- T
                      ]   } 
              or-else 
              subst-2-families-one
                      [ C:Qid <-  Q, 
                        cn2:ChannelName <- C2,
                        nj:NatTerm <- nt,
                        T:Type <- T
                      ]       
              )
  .   
                      
 *** subst-nf for families
 strat substNFFamilyOne : ChannelName ChannelName Reaction @ ProtocolConfig .
 sd substNFFamilyOne(C1, C2, R) :=
     nTimesSubstNFFamilyOne(C1, C2, R)
  ; liftInnerBindsNF(C2)
  ; handleRNF(C2)
  ; (pre2Nf or-else idle)  
 .   
 
 *** similar sub-strategy as for channels
 strat nTimesSubstNFFamilyOne : ChannelName ChannelName Reaction @ ProtocolConfig .
 sd nTimesSubstNFFamilyOne(C1, C2, R) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstNFFamilyOne(C1, C2, R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{
          subst-families-one[
                   C:ChannelName <- C1, 
                   cn2:ChannelName <- C2,
                   R2:Reaction <- R
                ]
                   } 
                   or-else
                   subst-families-one[
                   C:ChannelName <- C1, 
                   cn2:ChannelName <- C2,
                   R2:Reaction <- R
                ]
                   )
 .  
 
*** subst-nf for families with three indices
 strat substNFFamilyThree : ChannelName ChannelName Reaction @ ProtocolConfig .
 sd substNFFamilyThree(C1, C2, R) :=
     nTimesSubstNFFamilyThree(C1, C2, R)
  ; liftInnerBindsNF(C2)
  ; handleRNF(C2)
  ; (pre2Nf or-else idle)  
 .   
 
 *** similar sub-strategy as for channels
 strat nTimesSubstNFFamilyThree : ChannelName ChannelName Reaction @ ProtocolConfig .
 sd nTimesSubstNFFamilyThree(C1, C2, R) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstNFFamilyThree(C1, C2, R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{
          subst-families-three[
                   C:ChannelName <- C1, 
                   cn2:ChannelName <- C2,
                   R2:Reaction <- R
                ]
                   } 
                   or-else
                   subst-families-three[
                   C:ChannelName <- C1, 
                   cn2:ChannelName <- C2,
                   R2:Reaction <- R
                ]
                   )
 .  
                   
 *** subst on the left branch of a family
 strat applySubstNFLeft : Qid Qid Reaction @ ProtocolConfig .
 sd applySubstNFLeft(q1, q2, R) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applySubstNFLeft(q1, q2, R)}
    :    
       CASE-DISTINCTION-one-R[aQid:Qid <- q1]
         { substNFFamiliesOne(q2, q1, R)
         , idle
         } .
                 
   
   ************************
   *** drop
   ************************    
  
  *** drop-nf-family-channel
  strat applyDropNFCF : Qid ChannelName @ ProtocolConfig .
  sd applyDropNFCF(C1, C2) :=
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropNFCF(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
         CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                         P1:Protocol <- keepTwo P C1 C2]{
              DROP-nf-cf[C:ChannelName <- C1, 
                         cn:ChannelName <- C2]
         }
         or-else DROP-nf-cf[C:ChannelName <- C1, 
                         cn:ChannelName <- C2]
                                   
       )
  .
  
  *** drop-nf-channel-family with cases
  strat applyDropNFCFCases : Qid ChannelName BoolTerm @ ProtocolConfig .
  sd applyDropNFCFCases(C1, C2, bt) :=
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropNFCFCases(C1, C2, bt)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
         CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                         P1:Protocol <- keepTwo P C1 C2]{
              DROP-nf-cf-cases[C:ChannelName <- C1, 
                         cn:ChannelName <- C2,
                         bt:BoolTerm <- bt]
         }
         or-else DROP-nf-cf-cases[C:ChannelName <- C1, 
                         cn:ChannelName <- C2,
                         bt:BoolTerm <- bt]
                                   
       )
  .
       
  *** DROP-NF
  
 strat applyDropNF : ChannelName ChannelName @ ProtocolConfig .
 sd applyDropNF(C1, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropNF(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{
         DROP-nf[cn1:ChannelName <- C1, 
                   cn2:ChannelName <- C2] 
         or-else
         DROP-nf-copy[
                   cn1:ChannelName <- C1, 
                   cn2:ChannelName <- C2]           } )
          or-else
          (DROP-nf[cn1:ChannelName <- C1, 
                   cn2:ChannelName <- C2] 
         or-else
         DROP-nf-copy[
                   cn1:ChannelName <- C1, 
                   cn2:ChannelName <- C2]  )         
  . 
                   
  *** drop for pre-normal forms
                    
 strat applyDropPreNF : ChannelName ChannelName @ ProtocolConfig .
 sd applyDropPreNF(C1, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropPreNF(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{
         DROP-pre-nf[o1:ChannelName <- C1, 
                   o2:ChannelName <- C2] } 
              or-else
               DROP-pre-nf[o1:ChannelName <- C1, 
                   o2:ChannelName <- C2]
              ) 
                   
 .      
 
 *** apply drop for families
 
 strat applyDropNFFamilies : Qid Qid @ ProtocolConfig .
 sd applyDropNFFamilies(q1, q2) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropNFFamilies(q1, q2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P q1 q2, 
                             P1:Protocol <- keepTwo P q1 q2]{DROP-nf-families}
              or-else  DROP-nf-families
             )
 .       
 
 *** apply drop for channels, several reads before samp
 
  strat applyDropNFChannels : ChannelName ChannelName @ ProtocolConfig .
 sd applyDropNFChannels(C1, C2) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropNFChannels(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{DROP-nf-channels}
              or-else  DROP-nf-channels
             )
 .                     
  
  *********************
  *** subsume
  *********************
  
 strat applyDropSubsumeRevFamilies : Qid Qid @ ProtocolConfig .
 sd applyDropSubsumeRevFamilies(q1, q2) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropSubsumeRevFamilies(q1, q2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P q1 q2, 
                             P1:Protocol <- keepTwo P q1 q2]{
                             DROP-SUBSUME-families
                             }
              or-else DROP-SUBSUME-families
             )
 . 
 
  strat applyDropSubsumeRevChannels : Qid Qid @ ProtocolConfig .
 sd applyDropSubsumeRevChannels(C1, C2) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropSubsumeRevChannels(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{
                             DROP-SUBSUME-channels
                             }
              or-else DROP-SUBSUME-channels
             )
 . 
  
 strat applySubsumeRevFamilies : Qid Qid Qid @ ProtocolConfig .
 sd applySubsumeRevFamilies(q1, q2, x) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubsumeRevFamilies(q1, q2, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P q1 q2, 
                             P1:Protocol <- keepTwo P q1 q2]{
                             subsume-families-one-rev[x0:ChannelName <- x]
                             }
              or-else  (subsume-families-one-rev[x0:ChannelName <- x])
             )
 . 
 
 strat applySubsumeRevChannels : ChannelName ChannelName Qid @ ProtocolConfig .
 sd applySubsumeRevChannels(C1, C2, x) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubsumeRevChannels(C1, C2, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{
                             subsume-channels-one-rev[x0:ChannelName <- x]
                             }
              or-else  (subsume-channels-one-rev[x0:ChannelName <- x])
             )
 . 
 
 strat applySubsumeRevFamilyChannel : Qid ChannelName Qid @ ProtocolConfig .
 sd applySubsumeRevFamilyChannel(q1, C2, x) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubsumeRevChannels(q1, C2, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P q1 C2, 
                             P1:Protocol <- keepTwo P q1 C2]{
                             subsume-channels-family-one-rev[x0:ChannelName <- x]
                             }
              or-else  (subsume-channels-family-one-rev[x0:ChannelName <- x])
             )
 . 
 
 strat applySubsumeRevFamiliesList : Qid Qid CNameList @ ProtocolConfig .
 sd applySubsumeRevFamiliesList(q1, q2, emptyCNameList) := idle .
 sd applySubsumeRevFamiliesList(q1, q2, x :: ql) :=
     applySubsumeRevFamilies(q1, q2, x)
   ; applySubsumeRevFamiliesList(q1, q2, ql)
 .  
   
 strat applySubsumeRevChannelsList : ChannelName ChannelName CNameList @ ProtocolConfig .
 sd applySubsumeRevChannelsList(C1, C2, emptyCNameList) := idle .
 sd applySubsumeRevChannelsList(C1, C2, x :: ql) :=
     applySubsumeRevChannels(C1, C2, x)
   ; applySubsumeRevChannelsList(C1, C2, ql)
 .  
 
 strat applySubsumeFamilyCasesChannelList : ChannelName ChannelName CNameList @ ProtocolConfig .
 sd applySubsumeFamilyCasesChannelList(C1, C2, emptyCNameList) := idle .
 sd applySubsumeFamilyCasesChannelList(C1, C2, x :: ql) :=
     applySubsumeFamilyCasesChannel(C1, C2, x)
   ; applySubsumeFamilyCasesChannelList(C1, C2, ql)
 .  
 
 strat applySubsumeFamilyCasesChannel : ChannelName ChannelName ChannelName @ ProtocolConfig .
 sd applySubsumeFamilyCasesChannel(C1, C2, x) :=
      ( match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubsumeFamilyCasesChannel(C1, C2, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{
                             subsume-family-cases-channel{
       subsume-channels-one-rev[x0:ChannelName <- x]
       }
                             }
              or-else  (subsume-family-cases-channel{
                          subsume-channels-one-rev[x0:ChannelName <- x]
                        }
                       )
             )
       )
       ; 
       removeDuplicateReadsNF(C2)      
 . 
 
 strat applyDropFamilyCasesChannel : ChannelName ChannelName @ ProtocolConfig .
 sd applyDropFamilyCasesChannel(C1, C2) :=
      match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropFamilyCasesChannel(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{
                             subsume-family-cases-channel{
       DROP-nf-channels
       }
                             }
              or-else DROP-nf-channels 
             )
 .

   
  *********************
  *** absorb
  *********************
                   
 *** absorb a channel  
 strat absorbChannel : ChannelName @ ProtocolConfig .
 sd absorbChannel(C) := 
    absorb-new-nf[c:ChannelName <- C] 
 .
 
 *** absorb a family
 strat absorbFamily : Qid @ ProtocolConfig .
 sd absorbFamily(Q) := 
    absorb-new-nf-family-one[C:Qid <- Q] 
    or-else
    absorb-new-nf-family-two[C:Qid <- Q]    
 . 
 
 strat absorbFamilyDeleteEmpty : Qid @ ProtocolConfig .
 sd absorbFamilyDeleteEmpty(Q) := 
    absorbFamily(Q) 
    ; 
    try (delete-empty-newNF)
 .   
  *** add a newfamily to a named group of protocols
 strat addNewFamilyToGroup : Protocol Qid Qid @ ProtocolConfig .
 sd addNewFamilyToGroup(P, Q1, Q2) :=
     applyAbsorbReverse(P)
   ; moveProtocolUnderNewNF
   ; lift-inner-new-nf
   ; applyAddToGroup(Q1, Q2)
 .  
 
 *** substrategies
  strat applyAbsorbReverse : Protocol @ ProtocolConfig .
  sd applyAbsorbReverse(P) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAbsorbReverse(P)}
     :  ABSORB-LEFT-2[P2:Protocol <- new2NF(P)] 
     .  
 

 
 *** under the assumption that the current protocol is of the form
 ***     family q2 ::= P || family q1 ::= when cond1 --> P1 ;; otherwise --> P2
 *** do an absorb   
 strat applyCaseDistAbsorb : Qid Qid Qid Protocol @ ProtocolConfig .
 sd applyCaseDistAbsorb(q1, q2, q3, pr) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyCaseDistAbsorb(q1, q2, q3, pr)}
    : CASE-DISTINCTION-one[aQid:Qid <- q1]
         { use-family-p[C:Qid <- q2]
             { COMP-NEW-newNF
             ; absorbFamilyDeleteEmpty(q3)
             ; (SYM[P1:Protocol <- pr]{COMP-NEW-newNF})
             }
         , idle
         } .       
 
 *********************
 *** fold
 *********************
 
 *** fold a channel
 strat foldNF : ChannelName ChannelName @ ProtocolConfig .
 sd foldNF(C1, C2) := 
                 (fold-bind-new-nf[c:ChannelName <- C1,
                                   o:ChannelName <- C2] 
                  or-else 
                  fold-bind-new-prenf[c:ChannelName <- C1,
                                      o:ChannelName <- C2] 
                  or-else
                  fold-bind-new-nf-0[c:ChannelName <- C1,
                                   o:ChannelName <- C2]                     )
               ; liftInnerBindsNF(C2) 
               ; handleRNF(C2) 
               ; try (pre2Nf)
               ; try (delete-empty-newNF)
                 .
                 
 *** fold a pre-normal form                
 strat foldNFPre : ChannelName ChannelName @ ProtocolConfig .  
 sd foldNFPre(C1, C2) := 
                 fold-bind-new-prenf[c:ChannelName <- C1,
                                     o:ChannelName <- C2] ;
                 liftInnerBindsNF(C2) ;
                 handleRpreNF(C2) 
                 .  
                 
 strat handleRpreNF : ChannelName @ ProtocolConfig .  
 sd handleRpreNF(C1) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{handleRpreNF(C1)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C1, 
                        P1:Protocol <- keepOne P C1]{
         CONG-REACT[o:ChannelName <- C1]
                   {merge-pre}}
          or-else
          CONG-REACT[o:ChannelName <- C1]
                   {merge-pre}        
         )          
        .   
       
 *** fold a family                
 strat foldNFFamily : Qid Qid @ ProtocolConfig .
 sd foldNFFamily(Q1, Q2) := 
                 (fold-bind-new-nf-families[C:Qid  <- Q1,
                                            C':Qid <- Q2] 
                  or-else  
                  fold-bind-new-nf-families-zero[C:Qid  <- Q1,
                                            C':Qid <- Q2]                         
                 )
                 *** these last 2 steps should be reusable from subst!
                 ; liftInnerBindsNFFamily(Q2) 
                 ; handleRNFFamily(Q2) 
                 ; try (pre2Nf)
                  ; try (delete-empty-newNF)
                 .                         
 
 *** do a sym-proof
 *** applying if-ext twice in the reaction of a normal form
 *** on the first branch for a family
 
 strat applyIfExt2 : Qid Reaction Qid Qid @ ProtocolConfig .
 sd applyIfExt2(C, R, Q1, Q2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyIfExt2(C, R, Q1, Q2)}
     : 
        CASE-DISTINCTION-one-R[aQid:Qid <- C]
         {matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                                    P1:Protocol <- keepOne P C]{
                       CONG-REACT-family[C:Qid <- C] { 
                         cong-nf{
                         sym[R1:Reaction <- R]{
                           if-intro-ext[q:Qid <- Q1] 
              ; cong-branch[M2:Expression <- Q1]{
                   if-intro-ext[q:Qid <- Q2], 
                   if-intro-ext[q:Qid <- Q2]
                }  
                } *** end sym
                         }
                       }
                     }
         , 
          idle
         }
             
 .             
 
 ***********************************
 *** pure syntactic transformations
 ***********************************
 
 strat applyGetChannel : ChannelName @ ProtocolConfig .
 sd applyGetChannel(C1) :=
    get-channel[cn:ChannelName <- C1]
 .    
 
 strat removeDuplicateReadsNF : ChannelName @ ProtocolConfig .
 sd removeDuplicateReadsNF(C1) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{removeDuplicateReadsNF(C1)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C1, 
                        P1:Protocol <- keepOne P C1]{
         CONG-REACT[cn:ChannelName <- C1]{read-det-nf !}
       } . 
 
 var bt : BoolTerm .
 
 *** turn a plain family definition to a cases one with same reaction on each branch
 strat applyAddSameCases : Qid BoolTerm @ ProtocolConfig .
 sd applyAddSameCases(C, bt) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAddSameCases(C, bt)}
     : matchrew pConf s.t. 
         pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
              {add-same-cases[bt:BoolTerm <- bt]}                
             or-else add-same-cases[bt:BoolTerm <- bt]
             )                              
 .   
 
 *** get all new declarations in front
 strat moveNewToFront @ ProtocolConfig .
 sd moveNewToFront := 
     ((CONG-NEW-NF{CONG-COMP-RIGHT{comp-new-families}}) !) 
   ; (moveProtocolUnderNewNF !)
   ; (lift-inner-new-nf !)
 .    
 
  *** move the family Q2 inside the group Q1
 strat applyAddToGroup : Qid Qid @ ProtocolConfig .
 sd applyAddToGroup(Q1, Q2) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAddToGroup(Q1, Q2)}
     : matchrew pConf s.t. 
         pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P Q1 Q2, 
                             P1:Protocol <- keepTwo P Q1 Q2]
             {addToGroup}                
             or-else addToGroup
             )
 . 
 
  *** move the family Q2 on each case inside the group Q1
 strat applyAddToGroupCases : Qid Qid @ ProtocolConfig .
 sd applyAddToGroupCases(Q1, Q2) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAddToGroupCases(Q1, Q2)}
     : matchrew pConf s.t. 
         pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P Q1 Q2, 
                             P1:Protocol <- keepTwo P Q1 Q2]
             {applyAddToGroupCasesAux}                
             or-else applyAddToGroupCasesAux
             )
 . 
 
 strat applyAddToGroupCasesAux @ ProtocolConfig .
 sd applyAddToGroupCasesAux :=
  addToGroupCases-end
   or-else
  addToGroupCases{applyAddToGroupCasesAux}
 . 
 
 *** change order of reads in a normal form on a branch of a channel
 strat applyChangeOrderBranch : ChannelName BoolTerm CNameList @ ProtocolConfig .
    sd applyChangeOrderBranch(cn, bt, ql) := 
        match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyChangeOrderBranch(cn, bt, ql)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
          using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P cn, 
                                 P1:Protocol <- keepOne P cn]{
                                 cong-cases-reaction[cn:ChannelName <- cn, bt:BoolTerm <- bt]{
         
                   CONG-REACT[cn:ChannelName <- cn]{change-order[QL':CNameList <- ql]}
                 }
                                 }
                )
    .
 
 *** change order of reads in a normal form or a pre-normal form                        
 strat changeOrder : ChannelName CNameList @ ProtocolConfig .
 sd changeOrder(C, ql) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{changeOrder(C, ql)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]{
         CONG-REACT[o:ChannelName <- C]
         {change-order[QL':CNameList <- ql]
          or-else
          change-order-pre[QL':CNameList <- ql]
         }
         or-else
         CONG-REACT-family[C:Qid <- C]
         {change-order[QL':CNameList <- ql]
          or-else
          change-order-pre[QL':CNameList <- ql]
         }
       }
       or-else
        CONG-REACT[o:ChannelName <- C]
         {change-order[QL':CNameList <- ql]
          or-else
          change-order-pre[QL':CNameList <- ql]
         }
       or-else
         CONG-REACT-family[C:Qid <- C]
         {change-order[QL':CNameList <- ql]
          or-else
          change-order-pre[QL':CNameList <- ql]
         }  
       )
 .
 
 *** turn a nf to prenf 
 strat nf2PreNF : ChannelName @ ProtocolConfig .
 sd nf2PreNF(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nf2PreNF(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                        P1:Protocol <- keepOne P C]
        {CONG-REACT[o:ChannelName <- C]{nf2Pre}} 
        or-else
        CONG-REACT[o:ChannelName <- C]{nf2Pre}
        )
 .  
 
  *** group families 
   strat applyGroupFamilies : Qid Qid @ ProtocolConfig .
   sd applyGroupFamilies(Q1, Q2) :=
   match pConf s.t. startsWithNew pConf
   ? CONG-NEW-NF{applyGroupFamilies(Q1, Q2)}
   : group-families[C:Qid <- Q1, C':Qid <- Q2]
 .       
 
 *** ungroup families
 strat applyUngroupFamilies : Qid Qid @ ProtocolConfig .
 sd applyUngroupFamilies(Q1, Q2) :=
   match pConf s.t. startsWithNew pConf
   ? CONG-NEW-NF{applyUngroupFamilies(Q1, Q2)}
   : ungroup-families[C:Qid <- Q1, C':Qid <- Q2]
 .    
 
 *** get a protocol inside a new normal form
 strat moveProtocolUnderNewNF @ ProtocolConfig .
 sd moveProtocolUnderNewNF := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveProtocolUnderNewNF} 
     : COMP-NEW-newNF
 .
 
  *** strategies for bringing a protocol to combined notation
 strat applyDeleteEmptyNF : Qid @ ProtocolConfig .
 sd applyDeleteEmptyNF(Q) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDeleteEmptyNF(Q)} 
     :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P Q, 
                             P1:Protocol <- keepOne P Q]
                             {CONG-FAMILY-WHENLIST-P{ delete-empty-newNF }  }
              or-else   CONG-FAMILY-WHENLIST-P{ delete-empty-newNF }            
             )
 .
 
 strat applyDropName : Qid @ ProtocolConfig .
 sd applyDropName(Q) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropName(Q)} 
     :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P Q, 
                             P1:Protocol <- keepOne P Q]
                     {drop-group-name[C:Qid <- Q]}
               or-else (drop-group-name[C:Qid <- Q])
             )
 .
 
 strat applyCombine : Qid @ ProtocolConfig .
 sd applyCombine(Q) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCombine(Q)} 
     :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P Q, 
                             P1:Protocol <- keepOne P Q]
                             {convert-combined}
             or-else convert-combined                
             )
 .
 
 var whenCond : WhenCond .
 var q : Qid .
 var cn : ChannelName .
 
 *** do an alpha-renaming on a branch of a family, identified by its condition
 strat applyAlphaBranchCond : ChannelName Qid Qid WhenCond @ ProtocolConfig .
 sd applyAlphaBranchCond(cn, q1, q2, whenCond) :=
   match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyAlphaBranchCond(cn, q1, q2, whenCond)}
    : 
    alpha-branch[C:Qid <- cn, q1:Qid <- q1, q2:Qid <- q2, whenCond:WhenCond <- whenCond]
    or-else
    alpha-branch-channel[cn:ChannelName <- cn, 
      q1:Qid <- q1, q2:Qid <- q2, whenCond:WhenCond <- whenCond
    ]
 .
 
 *** do an alpha-renaming on the first branch of a family or a channel!
 strat applyBranch1Alpha : ChannelName QidPairList @ ProtocolConfig .
 sd  applyBranch1Alpha(cn, QL) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyBranch1Alpha(cn, QL)}
    : (
       (CASE-DISTINCTION-one-R[aQid:Qid <- cn]
         {matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[Q:Protocol  <- removeOne P cn, 
                                    P1:Protocol <- keepOne P cn]{
                       CONG-FAMILY-R { alphaNFOverList(QL)}
                     }
         , 
          idle
         }
       )
       or-else
       (CASE-DISTINCTION-channel[cn:ChannelName <- cn]
         {matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[Q:Protocol  <- removeOne P cn, 
                                    P1:Protocol <- keepOne P cn]{
                       CONG-REACT { alphaNFOverList(QL)}
                     }
         , 
          idle
         }
       )
      )   
    .     

  
 *** do an alpha-renaming on the otherwise branch of a family
 strat applyBranch2Alpha : Qid QidPairList @ ProtocolConfig .
 sd applyBranch2Alpha(q1, QL) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyBranch2Alpha(q1, QL)}
    : 
       CASE-DISTINCTION-one-R[aQid:Qid <- q1]
         {  idle,
            CASE-DISTINCTION-one-R-end
                    [C:Qid <- q1
                    ]
                  {
                     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[Q:Protocol  <- removeOne P q1, 
                                    P1:Protocol <- keepOne P q1]{
                       CONG-FAMILY-R { alphaNFOverList(QL)}
                     }       
                  }
         } 
         . 
         
  *** if a channel has same reaction on all branch, remove the branching
  strat applyAllSameCases : ChannelName @ ProtocolConfig .
  sd applyAllSameCases(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAllSameCases(C)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
        using
        (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                         P1:Protocol <- keepOne P C]{
                   all-same-cases or-else all-same-cases-family
         }
         or-else 
         (all-same-cases or-else all-same-cases-family)
        )
     .   
         
  *** substrategy and helpers
   sort QidPair .
 op <<_,_>> : Qid Qid -> QidPair [ctor] .
 op getFst : QidPair -> Qid .
 op getSnd : QidPair -> Qid .
 eq getFst(<< q1, q2 >>) = q1 .
 eq getSnd(<< q1, q2 >>) = q2 .
 
 sort QidPairList .
 subsort QidPair < QidPairList .
 op emptyQidPairList : -> QidPairList [ctor] .
 op __ : QidPair QidPairList -> QidPairList [ctor] . 
 
 var QL : QidPairList .
 var QP : QidPair .
 
 strat alphaNFOverList : QidPairList @ ReactionConfig .
 sd alphaNFOverList(emptyQidPairList) := idle .
 sd alphaNFOverList(QP QL) := 
     alpha-nf [vx:Qid <- getFst(QP), vy:Qid <- getSnd(QP)] 
   ; alphaNFOverList(QL) 
 .   
 
 *** apply bind2R-pre in a newNF protocol
  strat moveBindInPre : ChannelName Qid @ ProtocolConfig .
 sd moveBindInPre(C, Q) :=      
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveBindInPre(C, Q)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{bind2R-pre[x:Qid <- Q] or-else bind2R-nf[x:Qid <- Q] }}
             or-else
             CONG-REACT[o:ChannelName <- C]{bind2R-pre[x:Qid <- Q] or-else bind2R-nf[x:Qid <- Q] }
             )
    .  
 
 *** move reads from bind list of a normal form to the reaction of the normal form
 ***     on the left branch of a family
  strat applyBranch2MoveReads : Qid CNameList @ ProtocolConfig .
 sd applyBranch2MoveReads(q1, cnl) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyBranch2MoveReads(q1, cnl)}
    :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using  
       CASE-DISTINCTION-one-R[aQid:Qid <- q1, P:Protocol <- removeOne P q1]
         {   moveReadsToRFamily(q1, cnl)
           , idle
         } .
         
  *** move reads from bind list of a normal form to the reaction of the normal form
 strat moveReadsToRFamily : ChannelName CNameList @ ProtocolConfig .
 sd moveReadsToRFamily(C, emptyCNameList) := idle .
 sd moveReadsToRFamily(C, x :: cnl) := 
   match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveReadsToRFamily(C, x :: cnl)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]{
                              moveReadInnerNfFamily[x:ChannelName <- x]
                              or-else
                              moveReadInnerPreNfFamily[x:ChannelName <- x] 
                             }
               or-else  (moveReadInnerNfFamily[x:ChannelName <- x]
                              or-else
                              moveReadInnerPreNfFamily[x:ChannelName <- x] )             
             )
             ; moveReadsToRFamily(C, cnl)                
 .               
  
    
 ***  changes the order in a normal form, on the left branch of a protocol
 strat applyReorderNF : Qid CNameList @ ProtocolConfig .
 sd applyReorderNF(Q, ql2) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReorderNF(Q, ql2)} 
     : CASE-DISTINCTION-one-R[aQid:Qid <- Q]
       { matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
          using  (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P Q, 
                                 P1:Protocol <- keepOne P Q]
                  {CONG-FAMILY-R[C:Qid <- Q]{change-order[QL':CNameList <- ql2]}}
                   or-else
                  CONG-FAMILY-R[C:Qid <- Q]{change-order[QL':CNameList <- ql2]}
                  )
                  ,
         idle 
       }  
 . 
 
 *** alpha renaming
  strat applyAlphaNFPr : ChannelName QidPairList @ ProtocolConfig .
 sd applyAlphaNFPr(C, QL) :=                                 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAlphaNFPr(C, QL) } 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{alphaNFOverList(QL)}
              or-else
              CONG-REACT-family[C:Qid <- C]{alphaNFOverList(QL)} 
             } 
             or-else
             CONG-REACT[o:ChannelName <- C]{alphaNFOverList(QL)}
             or-else
             CONG-REACT-family[C:Qid <- C]{alphaNFOverList(QL)}             
             )
  .  
 
 *****************************
 *** read-inside-if
 *****************************
    
 *** apply read-inside-if in a newNF protocol 
 strat applyReadInsideIfPre : ChannelName @ ProtocolConfig .
 sd applyReadInsideIfPre(C) :=      
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReadInsideIfPre(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
       {CONG-REACT[o:ChannelName <- C]
        {cong-pre-nf{read-inside-if
                    } 
        }
       }
       or-else
       CONG-REACT[o:ChannelName <- C]
        {cong-pre-nf{read-inside-if
                    } 
        }
       )
    . 
    
    *******************************
    *** congruence for cases
    *******************************
    
    strat applyCongCases : ChannelName BoolTerm @ ProtocolConfig .
    sd applyCongCases(cn, bt) := 
        match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCongCases(cn, bt)} 
     : cong-cases-reaction[cn:ChannelName <- cn, bt:BoolTerm <- bt]{
         idle *** the real reaction goes here, for now just a pattern
       }
    .
    
********************
*** subst with cases
********************
 var cn1 cn2 : ChannelName .

 strat applySubstFamilyCase : ChannelName ChannelName Qid Reaction @ ProtocolConfig .
 sd applySubstFamilyCase(cn1, cn2, ind, R) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstFamilyCase(cn1, cn2, ind, R)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P cn1 cn2, 
                             P1:Protocol <- keepTwo P cn1 cn2]
              {subst-family-case[R':Reaction <- R]{ *** TODO: I need two reactions here???
                substNFFamilyOne(cn1, cn2[ind], R)
               }
              }
              )
              or-else 
              subst-family-case[R':Reaction <- R]{
                substNFFamilyOne(cn1, cn2[ind], R)
               }
             ) .
             
 strat applySubstFamilyCase2 : ChannelName ChannelName Qid Reaction Reaction @ ProtocolConfig .
 sd applySubstFamilyCase2(cn1, cn2, ind, R1, R2) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstFamilyCase2(cn1, cn2, ind, R1, R2)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P cn1 cn2, 
                             P1:Protocol <- keepTwo P cn1 cn2]
              {subst-family-case[R':Reaction <- R2]{ *** TODO: I need two reactions here???
                substNFFamilyOne(cn1, cn2[ind], R1)
               }
              }
              )
              or-else 
              subst-family-case[R':Reaction <- R2]{
                substNFFamilyOne(cn1, cn2[ind], R1)
               }
             ) .  
             
 strat applySubstFamilyCase3 : ChannelName ChannelName Qid  
                               Reaction Reaction BoolTerm @ ProtocolConfig .
 sd applySubstFamilyCase3(cn1, cn2, ind, R1, R2, bt) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstFamilyCase3(cn1, cn2, ind, R1, R2, bt)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P cn1 cn2, 
                             P1:Protocol <- keepTwo P cn1 cn2]
              {subst-family-case[R':Reaction <- R2, bt:BoolTerm <- bt]{ 
                 substNFFamilyOne(cn1, cn2[ind], R1)
               }
              }
              )
              or-else 
              subst-family-case[R':Reaction <- R2, bt:BoolTerm <- bt]{
                substNFFamilyOne(cn1, cn2[ind], R1)
               }
             ) . 
 
 var i1 i2 i3 : Qid .           
             
 strat applySubstFamily3IdxCase : ChannelName ChannelName Qid Qid Qid 
                               Reaction Reaction BoolTerm @ ProtocolConfig .
 sd applySubstFamily3IdxCase(cn1, cn2, i1, i2, i3, R1, R2, bt) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstFamily3IdxCase(cn1, cn2, i1, i2, i3, R1, R2, bt)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P cn1 cn2, 
                             P1:Protocol <- keepTwo P cn1 cn2]
              {subst-family-case-three[R':Reaction <- R2, bt:BoolTerm <- bt]{ 
                 substNFFamilyThree(cn1, cn2[i1 i2 i3], R1)
               }
              }
              )
              or-else 
              subst-family-case-three[R':Reaction <- R2, bt:BoolTerm <- bt]{
                substNFFamilyThree(cn1, cn2[i1 i2 i3], R1)
               }
             ) .                
             
 strat applySubstChannelCase3 : ChannelName ChannelName  
                               Reaction Reaction BoolTerm @ ProtocolConfig .
 sd applySubstChannelCase3(cn1, cn2, R1, R2, bt) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstChannelCase3(cn1, cn2, R1, R2, bt)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P cn1 cn2, 
                             P1:Protocol <- keepTwo P cn1 cn2]
              {subst-channel-case[R':Reaction <- R2, bt:BoolTerm <- bt]{ 
                 substNFFamilyOne(cn1, cn2, R1)
               }
              }
              )
              or-else 
              subst-channel-case[R':Reaction <- R2, bt:BoolTerm <- bt]{
                substNFFamilyOne(cn1, cn2, R1)
               }
             ) .                                            


*** when we diverge on the otherwise branch

 var ind : Qid .

 strat applyCasesSubstDivergeOwise : Qid Qid Qid Type Qid @ ProtocolConfig .
 sd applyCasesSubstDivergeOwise(C1, C2, ind, T, x) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCasesSubstDivergeOwise(C1, C2, ind, T, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]
              {
                cases-subst[C:Qid <- C2, aQid:Qid <- C1]{
                  substNF(C1[ind], C2[ind]), 
                  cases-subst-end-otherwise{ 
                    subst-diverge[T2:Type <- T, x3:Qid <- x]
                  }
                } 
              }               
             )                
 .
 
 strat applyCasesSubstChannelDivergeOwise : ChannelName ChannelName Type Qid @ ProtocolConfig .
 sd applyCasesSubstChannelDivergeOwise(cn1, cn2, T, x) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCasesSubstChannelDivergeOwise(cn1, cn2, T, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
              (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P cn1 cn2, 
                             P1:Protocol <- keepTwo P cn1 cn2]
              {
                channel-cases-subst[cn1:ChannelName <- cn1, cn2:ChannelName <- cn2]{
                  substNF(cn2, cn1), 
                  channel-cases-subst-end-otherwise{ 
                   subst-diverge[T2:Type <- T, x3:Qid <- x]
                  }
                } 
              }               
             )
             or-else
              (channel-cases-subst[cn1:ChannelName <- cn1, cn2:ChannelName <- cn2]{
                  substNF(cn2, cn1), 
                  channel-cases-subst-end-otherwise{ 
                   subst-diverge[T2:Type <- T, x3:Qid <- x]
                  }
                } )
              )                 
 .
 
  strat applyCasesSubsumeDropDivergeOwise : Qid Qid CNameList Qid Type Qid @ ProtocolConfig .
  sd applyCasesSubsumeDropDivergeOwise(C1, C2, ql, ind, T, x) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCasesSubsumeDropDivergeOwise(C1, C2, ql, ind, T, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]
              {
                channel-cases-subst[C:Qid <- C2, aQid:Qid <- C1]{
                     applySubsumeRevChannelsList(C1[ind], C2[ind], ql)
                   ; applyDropNFChannels(C1[ind], C2[ind])
                   , 
                  cases-subst-end-otherwise{ 
                    subst-diverge[T2:Type <- T, x3:Qid <- x] ***TODO: do we need x3?
                  }
                } 
              }               
             )                
 .
 
  strat applyCasesSubsumeDropDivergeOwiseC : 
             Qid ChannelName CNameList Type Qid @ ProtocolConfig .
  sd applyCasesSubsumeDropDivergeOwiseC(C1, q[nt], ql, T, x) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCasesSubsumeDropDivergeOwiseC(C1, q[nt], ql, T, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
             (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 (q[nt]), 
                             P1:Protocol <- keepTwo P C1 (q[nt])]
              {
                fc-cases-subst[cn:ChannelName <- q[nt], aQid:Qid <- C1]{
                     applySubsumeFamilyCasesChannelList(C1, q[nt], ql)
                   ; applyDropNFCF(C1, q[nt])
                   , 
                  fc-cases-subst-end-otherwise{ 
                    subst-diverge-family-channel[T2:Type <- T, x3:Qid <- x]
                  }
                } 
              }               
             )
             or-else
              (fc-cases-subst[cn:ChannelName <- q[nt], aQid:Qid <- C1]{
                     applySubsumeFamilyCasesChannelList(C1, q[nt], ql)
                   ; applyDropNFCF(C1, q[nt])
                   , 
                  fc-cases-subst-end-otherwise{ 
                    subst-diverge-family-channel[T2:Type <- T, x3:Qid <- x]
                  }
                } 
              )  
            )   
             
 .                                      
         
  strat applyCasesSubstFC : 
             Qid ChannelName Reaction Type Qid @ ProtocolConfig .
  sd applyCasesSubstFC(C1, q[nt], R, T, x) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCasesSubstFC(C1, q[nt], R, T, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
             (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 (q[nt]), 
                             P1:Protocol <- keepTwo P C1 (q[nt])]
              {
                fc-cases-subst[cn:ChannelName <- q[nt], aQid:Qid <- C1]{
                     substNFFamilyOne(C1, q[nt], R)
                   , 
                  fc-cases-subst-end-otherwise{ 
                    subst-diverge-family-channel[T2:Type <- T, x3:Qid <- x]
                  }
                } 
              }               
             )
             or-else
              (fc-cases-subst[cn:ChannelName <- q[nt], aQid:Qid <- C1]{
                     substNFFamilyOne(C1, q[nt], R)
                   , 
                  fc-cases-subst-end-otherwise{ 
                    subst-diverge-family-channel[T2:Type <- T, x3:Qid <- x]
                  }
                }
              )  
            )   
             
 .  
 
 *** same cases and only do the substitution on first branch
 *** TODO: can be generalized to try to do on every branch?
 strat applySameCasesSubstFirstBranch : Qid Qid Qid @ ProtocolConfig .
 sd applySameCasesSubstFirstBranch(C1, C2, ind) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySameCasesSubstFirstBranch(C1, C2, ind)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]
              {
                same-cases-subst{
                  substNF(C1[ind], C2[ind]), 
                  idle
                }
              }               
             )                
 .  
 
 strat applySameCasesSubstFC : Qid ChannelName NatTerm @ ProtocolConfig .     
 sd applySameCasesSubstFC(C1, cn, ind) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySameCasesSubstFC(C1, cn, ind)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 cn, 
                             P1:Protocol <- keepTwo P C1 cn]
              { fc-same-cases-subst-end-otherwise{
                  substNF(C1[ind], cn)
                }
                or-else
                fc-same-cases-subst-end-when{
                  substNF(C1[ind], cn)
                }
                or-else
                fc-same-cases-subst{
                  substNF(C1[ind], cn), 
                  applySameCasesSubstFC(C1, cn, ind)
                }
              }               
             ) 
 . 
 
 *** if we can deduce the condition of a branch in a channel
 *** use that to do the substitution
 
 strat applySelectCaseSubst : ChannelName ChannelName BoolTerm @ ProtocolConfig .
 sd applySelectCaseSubst(cn1, cn2, bt) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySelectCaseSubst(cn1, cn2, bt)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P cn1 cn2, 
                             P1:Protocol <- keepTwo P cn1 cn2]
              {select-case-subst[bt:BoolTerm <- bt]{substNF(cn1, cn2)}
              }
             ) or-else
                (select-case-subst[bt:BoolTerm <- bt]{substNF(cn1, cn2)})
             ) 
 .
 
 *** apply subst on every branch using cases-subst
 *** we assume it ends with when
 *** TODO: also try otherwise before recursion
 
 strat applyCasesSubst : Qid Qid Qid @ ProtocolConfig .
 sd applyCasesSubst(C1, C2, ind) := 
   match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCasesSubst(C1, C2, ind)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{applyCasesSubstRec(C1, C2, ind)}
              or-else
              applyCasesSubstRec(C1, C2, ind))
 .
 
 *** this is a helper for the strategy above! 
 strat applyCasesSubstRec : Qid Qid Qid @ ProtocolConfig .
 sd applyCasesSubstRec(C1, C2, ind) :=                            
    *** first try to apply the end case for when
    cases-subst-end-when[aQid:Qid <- C1, C:Qid <- C2]{substNF(C1[ind], C2[ind])}
    *** TODO: we need R2 as argument above
    or-else
    cases-subst-end-otherwise{substNF(C1[ind], C2[ind])}
    or-else *** TODO: we might want to try diverge in both subproofs above!
     cases-subst{
                  substNF(C1[ind], C2[ind]), *** subst on first branch
                  applyCasesSubstRec(C1, C2, ind) *** recursive call for the rest
                }  
 .      
 
 ******************************************
 *** helpers
 ******************************************
 
  *** checks that the protocol in a aConfig starts with new/newfamily or is in new normal form
 op aConfStartsWithNew_ : ApproxEqConfig -> Bool .
 eq aConfStartsWithNew aConfig(S, D, P, I, O, A, width w, length l) =
    startsWithNew pConfig(S, D, P, I, O, A) .
 
 *** checks that the protocol in a pConfig starts with new/newfamily or is in new normal form     
 op startsWithNew_ : ProtocolConfig -> Bool .
 eq startsWithNew pConfig(S, D, emptyProtocol, I, O, A) = false .
 eq startsWithNew pConfig(S, D, P1 || P2, I, O, A) = false .
 eq startsWithNew pConfig(S, D, C ::= R, I, O, A) = false .
 eq startsWithNew pConfig(S, D, new Q : T in P, I, O, A) = true .
 eq startsWithNew pConfig(S, D, newNF(ltq, P, ql), I, O, A) = true .
 eq startsWithNew pConfig(S, D, family Q nlist blist ::= P, I, O, A) = false .
 
endsm

***(

smod UNUSED-STRATS is 
  pr STRATS .
 *** vars
  
 var pConf : ProtocolConfig .
 var rConf : ReactionConfig .
 var S Sigma : Signature .
 var D Delta : ChannelContext .
 var G : TypeContext .
 var P P1 P2 : Protocol .
 var R R1 R2 R3 R4 : Reaction .
 *** var Q Q' C Q1 Q2 x1 x2 y x : Qid .
 var I O : Set{CNameBound} .
 var T T' T1 : Type .
 var flag : Bool .
 var M M1 M2 : Expression .
 var Dis : Distribution .
 var C C1 C2 : ChannelName .
 var Q Q' x1 : Qid .
 var A : Set{BoolTerm} .
 var N w l : Nat .
 var nlist : List{NatTerm} .
 var blist : List{Bounds} .
 var ql : CNameList .                
 var X : ChannelName . 
 var BRL : BRList . 
 var ltq : TypedCNameList .
 var ql' : CNameList .  
 
 *** helpers

 *** older method, should go away
 op isLastNew___ : ProtocolConfig Qid Bool -> Bool .

 eq isLastNew pConfig(S, D, emptyProtocol, I, O, A) Q flag = not flag .
 eq isLastNew pConfig(S, D, P1 || P2, I, O, A) Q flag = not flag .
 eq isLastNew pConfig(S, D, C ::= R, I, O, A) Q flag = not flag .
 eq isLastNew pConfig(S, D, new Q : T in P, I, O, A) Q false = false .
 eq isLastNew pConfig(S, D, new Q : T in P, I, O, A) Q true = 
    isLastNew pConfig(S, D, P, I, O, A) Q false .
 ceq isLastNew pConfig(S, D, new Q' : T in P, I, O, A) Q true = 
     isLastNew pConfig(S, D, P, I, O, A) Q true if Q =/= Q' .
 ceq isLastNew pConfig(S, D, new Q' : T in P, I, O, A) Q false = 
     false if Q =/= Q' .    

 op foundQ__  : ProtocolConfig Qid -> Bool .
 eq foundQ pConfig(S, D, emptyProtocol, I, O, A) Q = false .
 eq foundQ pConfig(S, D, P1 || P2, I, O, A) Q = false .
 eq foundQ pConfig(S, D, C ::= R, I, O, A) Q = false .
 eq foundQ pConfig(S, D, new Q : T in P, I, O, A) Q = true .
 ceq foundQ pConfig(S, D, new Q' : T in P, I, O, A) Q = false if Q' =/= Q . 
 

  strat alphaOverList : QidPairList @ ReactionConfig .
 sd alphaOverList(emptyQidPairList) := idle .
 sd alphaOverList(QP QL) := alpha [x:Qid <- getFst(QP), y:Qid <- getSnd(QP)] ; 
                            cong-bind{idle, alphaOverList(QL)} .     
     
 strat applyAlphaPr : ChannelName QidPairList @ ProtocolConfig .
 sd applyAlphaPr(C, QL) :=                                 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAlphaPr(C, QL) } 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
              CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{alphaOverList(QL)}}
             or-else
             CONG-REACT[o:ChannelName <- C]{alphaOverList(QL)
             ) . 
 

 *** checks that a certain channel is the first in a new/newfamily/newnf
 op startsWithNewC__ : ProtocolConfig ChannelName -> Bool .
 eq startsWithNewC pConfig(S, D, emptyProtocol, I, O, A) C = false .
 eq startsWithNewC pConfig(S, D, P1 || P2, I, O, A) C = false .
 eq startsWithNewC pConfig(S, D, C ::= R, I, O, A) C = false .
 eq startsWithNewC pConfig(S, D, new Q : T in P, I, O, A) C = (Q == C) .
 eq startsWithNewC pConfig(S, D, newNF(ltq, P, Q :: ql), I, O, A) C = (Q == C) .
 
 op startsWithBind : Reaction -> Bool .
 eq startsWithBind(return M) = false .
 eq startsWithBind(samp Dis) = false .
 eq startsWithBind(read M) = false .
 eq startsWithBind(if M then R1 else R2) = false .
 eq startsWithBind(Q : T <- R1 ; R2) = true .
 
 op startsWithBindRead : Reaction -> Bool .
 eq startsWithBindRead(Q : T <- read M ; R2) = true .
 eq startsWithBindRead(R) = false [owise] .
 
 op startsWithIfRead : ReactionConfig -> Bool .
 eq startsWithIfRead(rConfig(S, D, G, if M then x1 : T1 <- R1 ; R2 else 
                                                x1 : T1 <- R1 ; R3, I, A, T)) = true . 
 eq startsWithIfRead(rConfig(S, D, G, R, I, A, T)) = false [owise] .
 
 op rBindRead : ReactionConfig -> Bool .
 eq rBindRead(rConfig(S, D, G, R, I, A, T)) = startsWithBindRead(R) .
 
 op firstBind : ReactionConfig -> Qid .
 eq firstBind(rConfig(S, D, G, Q : T <- R1 ; R2, I, A, T')) = Q .
 
 op rBind : ReactionConfig -> Bool .
 eq rBind(rConfig(S, D, G, R, I, A, T)) = startsWithBind(R) .
 
 *** strategies
 
 *** old, we needed it before normal forms
 strat moveToLast : Qid @ ProtocolConfig . 
 sd moveToLast(Q) := match pConf s.t. (foundQ pConf Q) 
                       ? (match pConf s.t. (isLastNew pConf Q true) 
                         ? idle 
                         : (NEW-EXCH ; CONG-NEW-NF{moveToLast(Q)})) 
                       : CONG-NEW-NF{moveToLast(Q)} .
                       
 *** old                       
 strat nTimesCong : ChannelName @ ProtocolConfig .
 sd nTimesCong(C) := 
      match pConf s.t. startsWithNewC pConf C
      ? COMP-NEW-2 ; ABSORB-RIGHT 
      : CONG-NEW-NF{nTimesCong(C)} .
 
 *** apply bind-ret-2 inside C
 *** if the current P is newNF(..., C ::= R || Q  ,...)
 strat nTimesBindRet2 : ChannelName @ ProtocolConfig .
 sd nTimesBindRet2(C) := 
  match pConf s.t. startsWithNew pConf
  ? CONG-NEW-NF{nTimesBindRet2(C)}
  : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{bind-ret-2[x:Qid <- 'x]}} .
 
 *** old
 *** apply SUBST with the sub-proof read-det
 *** if the current P is newNF(..., P  ,...)
 strat nTimesSubst @ ProtocolConfig .
 sd nTimesSubst := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{nTimesSubst}
    : CONG-COMP-RIGHT{(SUBST [x2:Qid <- 'x2]{read-det})} . 
 
 *** apply bind-ret inside C
 *** if the current P is newNF(..., C ::= R || Q  ,...)   
 *** old
 strat nTimesBindRet @ ProtocolConfig .
 sd nTimesBindRet := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{nTimesBindRet} 
    : CONG-COMP-RIGHT{CONG-REACT{bind-ret}} .
 
 strat liftInnerBinds @ ReactionConfig .
 sd liftInnerBinds := bind-bind ? cong-bind{idle, liftInnerBinds} : idle .
 
 strat liftAllInnerBinds @ ReactionConfig .
 sd liftAllInnerBinds := 
      match rConf s.t. rBind(rConf) 
       ? (liftInnerBinds ; cong-bind{idle, liftAllInnerBinds})
       : idle .  
 
 *** low-level strategy
 strat liftInnerBindsPr : ChannelName @ ProtocolConfig .
 sd liftInnerBindsPr(C) := 
  match pConf s.t. startsWithNew pConf 
  ? CONG-NEW-NF{liftInnerBindsPr(C)}
  : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{liftAllInnerBinds}} .

 *** old, before normal forms
 strat moveBindToLast @ ReactionConfig .
 sd moveBindToLast := exchange ? cong-bind{idle, moveBindToLast} : idle . 
 
 *** old, before normal forms
 strat moveCertainBindToLast : Qid @ ReactionConfig .
 sd moveCertainBindToLast(Q) :=
    match rConf s.t. Q =/= firstBind(rConf)
    ? cong-bind{idle, moveCertainBindToLast(Q)}
    : moveBindToLast . 
 
 *** old, before normal forms 
 strat moveBindToFirst : Qid @ ReactionConfig .
 sd moveBindToFirst(Q) := 
   match rConf s.t. Q =/= firstBind(rConf)
     ? moveBindToLast ; moveBindToFirst(Q)
     : idle .
  
 *** old, before normal forms    
 strat moveBindProtocol : Qid ChannelName @ ProtocolConfig .
 sd moveBindProtocol(Q, C) := CONG-REACT[o:ChannelName <- C]{moveBindToFirst(Q)} . 
 
 *** old, before normal forms
 strat moveCertainBindLastProtocol : Qid ChannelName @ ProtocolConfig .
 sd moveCertainBindLastProtocol(Q, C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveCertainBindLastProtocol(Q, C)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveCertainBindToLast(Q)}} .   

 *** old, before normal forms
 strat moveFirst : Qid ChannelName @ ProtocolConfig .
 sd moveFirst(Q, C) := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveBindToFirst(Q)}} .
 
 *** old, before normal forms       
 strat nTimesMoveFirst : Qid ChannelName @ ProtocolConfig .
 sd nTimesMoveFirst(Q, C) := 
   match pConf s.t. startsWithNew pConf
   ? CONG-NEW-NF{nTimesMoveFirst(Q, C)}
   : moveFirst(Q, C) .
                   
 strat removeDuplicateReadsNF : ChannelName @ ProtocolConfig .
 sd removeDuplicateReadsNF(C1) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{removeDuplicateReadsNF(C1)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C1, 
                        P1:Protocol <- keepOne P C1]{
         CONG-REACT[o:ChannelName <- C1]{read-det-pre !}
       } . 

 
 strat substAll : ChannelName @ ProtocolConfig .
 sd substAll(C) := substNFOne(C) ! .
 
 strat substAllAndAbsorb : ChannelName @ ProtocolConfig .
 sd substAllAndAbsorb(C) := substAll(C) ; absorbChannel(C) .
      
 strat substNFOne : ChannelName @ ProtocolConfig .
 sd substNFOne(C1) := 
     matchrew pConf 
         s.t. pConfig(Sigma, Delta,   
                      newNF(ltq,
                             P || (C1 ::= R1) || 
                                  (C2 ::= nf( (x1 : T1 <- read C1) BRL , R2, ql
                                            )
                                  ),
                       ql'), I, O, A) := pConf 
         by pConf 
       using substNF(C1, C2)
 .         
       
 var Q1 Q2 : Qid .
   
 var cnl : CNameList .
 
 strat moveReadsToR : ChannelName CNameList @ ProtocolConfig .
 sd moveReadsToR(C, emptyCNameList) := idle .
 sd moveReadsToR(C, x :: cnl) := 
   match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveReadsToR(C, x :: cnl)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]{
                              moveReadInnerNf[x:ChannelName <- x]
                              or-else
                              moveReadInnerPreNf[x:ChannelName <- x] 
                             }
             ; moveReadsToR(C, cnl)                
 .
 
 strat applySubstNfRev : ChannelName ChannelName Qid @ ProtocolConfig .
 sd applySubstNfRev(C1, C2, x) := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstNfRev(C1, C2, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{                  
                   SUBST-nf-rev[x:ChannelName <- x]}
 .
 
 strat applySubstNfRevFamily : ChannelName ChannelName Qid @ ProtocolConfig .
 sd applySubstNfRevFamily(C1, C2, x) := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstNfRevFamily(C1, C2, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{                  
                   SUBST-nf-rev[x:ChannelName <- x]}
 .
 
 strat nTimesSubstSampFree : ChannelName ChannelName @ ProtocolConfig .
 sd nTimesSubstSampFree(C1, C2) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstSampFree(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]
                             {SUBST[x2:Qid <- 'x2, 
                             o1:ChannelName <- C1, 
                             o2:ChannelName <- C2]{samp-free}} .
     
 strat nTimesSubst2SampFree : ChannelName ChannelName @ ProtocolConfig .
 sd nTimesSubst2SampFree(C1, C2) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubst2SampFree(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]
                             {SUBST-2[x2:Qid <- 'x2, 
                               o1:ChannelName <- C1, 
                               o2:ChannelName <- C2]{samp-free}} .   
                               
     
 strat ifOverBindAfterBinds @ ReactionConfig .
 sd ifOverBindAfterBinds :=  
     match rConf s.t. rBindRead(rConf) 
      ? cong-bind{idle, ifOverBindAfterBinds}
      : if-over-bind .  
 
 strat nTimesIfOverBind : ChannelName @ ProtocolConfig .
 sd nTimesIfOverBind(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesIfOverBind(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifOverBindAfterBinds}} .
     
 strat ifOverBindInBranch @ ReactionConfig .  
 sd ifOverBindInBranch :=  
     match rConf s.t. rBindRead(rConf) 
      ? cong-bind{idle, ifOverBindInBranch}
      : cong-branch-refl{if-over-bind, if-over-bind} . 
      
 strat ifOverBindInBranch2 @ ReactionConfig .  
 sd ifOverBindInBranch2 :=  
     match rConf s.t. rBindRead(rConf) 
      ? cong-bind{idle, ifOverBindInBranch2}
      : cong-branch-refl{ifOverBindInBranch, ifOverBindInBranch} . 
     
      
 strat ifLeftOverBind @ ReactionConfig .
 sd ifLeftOverBind := 
    match rConf s.t. rBind(rConf) 
    ? cong-bind{idle, ifLeftOverBind}
    : if-left .
    
 strat ifRightOverBind @ ReactionConfig .
 sd ifRightOverBind := 
    match rConf s.t. rBind(rConf) 
    ? cong-bind{idle, ifRightOverBind}
    : if-right .   
     
 strat nTimesIfOverBindBranch : ChannelName @ ProtocolConfig .
 sd nTimesIfOverBindBranch(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesIfOverBindBranch(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifOverBindInBranch}} .    
     
 strat nTimesIfOverBindBranch2 : ChannelName @ ProtocolConfig .
 sd nTimesIfOverBindBranch2(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesIfOverBindBranch2(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifOverBindInBranch2}} .    
     
 strat bindRetInBranchTwiceIOB @ ReactionConfig .
 sd bindRetInBranchTwiceIOB := 
    match rConf s.t. rBindRead(rConf)
    ? cong-bind{idle, bindRetInBranchTwiceIOB}
    : cong-branch-refl
        {cong-branch-refl{ret-bind ; ifRightOverBind, ret-bind ; ifLeftOverBind},
         cong-branch-refl{ret-bind ; ifLeftOverBind, ret-bind ; ifRightOverBind}} .
 
 strat bindRetInBranchTwice @ ReactionConfig .
 sd bindRetInBranchTwice := 
    match rConf s.t. rBindRead(rConf)
    ? cong-bind{idle, bindRetInBranchTwice}
    : cong-branch-refl
        {cong-branch-refl{ret-bind , ret-bind},
         cong-branch-refl{ret-bind , ret-bind}} .
         
 strat moveInsideIf : Qid ChannelName @ ProtocolConfig .
 sd moveInsideIf(Q, C) :=  *** first what var and then the channel
    moveCertainBindLastProtocol(Q, C) ;
    applyReadOverIf(Q, C) .
        
 strat applyReadOverInnerIf : Qid ChannelName @ ProtocolConfig .
 sd applyReadOverInnerIf(Q, C) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReadOverInnerIf(Q, C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]
              {moveLastBindInsideInnerIf(Q)}
             } .
 
 strat applyReadOverIf : Qid ChannelName @ ProtocolConfig .
 sd applyReadOverIf(Q, C) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReadOverIf(Q, C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveLastBindInsideIf(Q)}} .

 
 strat moveLastBindInsideIf : Qid @ ReactionConfig .
 sd moveLastBindInsideIf(Q) :=
    match rConf s.t. Q =/= firstBind(rConf)
    ? cong-bind{idle, moveLastBindInsideIf(Q)}
    : read-inside-if . 
    
 strat moveLastBindInsideInnerIf : Qid @ ReactionConfig .
 sd moveLastBindInsideInnerIf(Q) :=
    match rConf s.t. rBind(rConf)
    ? cong-bind{idle, moveLastBindInsideInnerIf(Q)}
    : cong-branch-refl{read-inside-if, read-inside-if} .   
           
         
 strat bindRetInBranch @ ReactionConfig .
 sd bindRetInBranch :=  
     match rConf s.t. rBindRead(rConf) *** TODO: allow any bind?
    ? cong-bind{idle, bindRetInBranch}
    : cong-branch-refl{ret-bind , ret-bind} . 
    
 strat nTimesBindRetBranch : ChannelName @ ProtocolConfig .
 sd nTimesBindRetBranch(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesBindRetBranch(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{bindRetInBranch}} . 
         
 
 strat nTimesBindRetBranchTwiceIOB : ChannelName @ ProtocolConfig .
 sd nTimesBindRetBranchTwiceIOB(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesBindRetBranchTwiceIOB(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{bindRetInBranchTwiceIOB}} . 
   
 strat nTimesBindRetBranchTwice : ChannelName @ ProtocolConfig .
 sd nTimesBindRetBranchTwice(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesBindRetBranchTwice(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{bindRetInBranchTwice}} . 
  
     
 strat moveAllBindsToFrontIf @ ReactionConfig .
 sd moveAllBindsToFrontIf :=
     match rConf s.t. rBind(rConf)
     ? cong-bind{idle, moveAllBindsToFrontIf}
     : match rConf s.t. startsWithIfRead(rConf) 
       ? if-over-read ; moveAllBindsToFrontIf
       : idle .
        
 strat moveAllBindsTwoIfs @ ReactionConfig .
 sd moveAllBindsTwoIfs := 
    match rConf s.t. rBind(rConf)
     ? cong-bind{idle, moveAllBindsTwoIfs}
     : cong-branch-refl{ moveAllBindsToFrontIf, moveAllBindsToFrontIf} .
    
 strat moveBinds : ChannelName @ ProtocolConfig .
 sd moveBinds(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveBinds(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveAllBindsTwoIfs}} . 

 strat moveBindsOne : ChannelName @ ProtocolConfig .
 sd moveBindsOne(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveBindsOne(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveAllBindsToFrontIf}} .
   
    
 op canApplyIfBindSame : Reaction -> Bool .
 eq canApplyIfBindSame(x1 : T1 <- if M then R1 else R2 ; if M then R3 else R4) = true .
 eq canApplyIfBindSame(R) = false [owise] .  
 

 op canApplyIfBindSameC : ReactionConfig -> Bool .
 eq canApplyIfBindSameC(rConfig(S, D, G, R, I, A, T)) = canApplyIfBindSame(R) .
 
 strat ifBindSame @ ReactionConfig .
 sd ifBindSame :=
  match rConf s.t. canApplyIfBindSameC(rConf) 
  ? if-over-bind-same
  : match rConf s.t. rBind(rConf)
     ? cong-bind{idle, ifBindSame}
     : idle .
     
 strat ifBindSame2 @ ReactionConfig .
 sd ifBindSame2 :=
  match rConf s.t. canApplyIfBindSameC(rConf) 
  ? if-over-bind-same-2
  : match rConf s.t. rBind(rConf)
     ? cong-bind{idle, ifBindSame2}
     : idle .    
     
 strat ifBindSamePr : ChannelName @ ProtocolConfig .
 sd ifBindSamePr(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{ifBindSamePr(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifBindSame}} .
    
 strat ifBindSame2Pr : ChannelName @ ProtocolConfig .
 sd ifBindSame2Pr(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{ifBindSame2Pr(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifBindSame2}} .
     
 strat recursiveReadDet @ ReactionConfig .
 sd recursiveReadDet := 
   match rConf s.t. rBindRead(rConf)
     ? (read-det
          ? recursiveReadDet
          : (exchange ? cong-bind{idle, recursiveReadDet} : idle)) 
     : idle . 
  
 strat recReadDet : ChannelName Nat @ ProtocolConfig .
 sd recReadDet(C, 0) := idle .
 sd recReadDet(C, s(N)) :=
     (match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{recReadDet(C, s(N))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{recursiveReadDet}}) ; recReadDet(C, N) .
    
 strat readOutsideIf2 : ChannelName @ ProtocolConfig .
 sd readOutsideIf2(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{readOutsideIf2(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]
                       {moveAllBindsTwoIfs ; moveAllBindsToFrontIf}} .
 
 strat sameReactionIfAfterBinds @ ReactionConfig .
 sd sameReactionIfAfterBinds := 
   match rConf s.t. rBindRead(rConf)
     ? cong-bind{idle, sameReactionIfAfterBinds} 
     : same-reaction-if .
 
 strat sameReactionIf : ChannelName @ ProtocolConfig .
 sd sameReactionIf(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{sameReactionIf(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{sameReactionIfAfterBinds}} .
     
 strat removeUnused : ChannelName ChannelName @ ProtocolConfig .
 sd removeUnused(C1, C2) := 
 match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{removeUnused(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]
             {UNUSED[o1:ChannelName <- C1, o2:ChannelName <- C2]{samp-pure}} .
            
 strat addNewChannel : Protocol @ ProtocolConfig .
 sd addNewChannel(P) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{addNewChannel(P)}
     : ABSORB-LEFT-2[P2:Protocol <- P] ; COMP-NEW .  
     
     
 var Msg1 Msg2 : Expression .    
      
 var q1 q2 : Qid .  

 var x : Qid .    
     
 strat retBind2OverIf : Type Expression Expression Reaction Qid @ ReactionConfig .
 sd retBind2OverIf(T, M1, M2 , R, x) := 
    match rConf s.t. rBind(rConf) 
    ? cong-bind{idle, retBind2OverIf(T, M1, M2, R, x) }
    : cong-branch-refl{
           ret-bind-2[M1:Expression <- M1 , T1:Type <- T, R2:Reaction <- R , x:Qid <- x],
           ret-bind-2[M1:Expression <- M2 , T1:Type <- T, R2:Reaction <- R , x:Qid <- x]} .
     
 strat applyRetBind2OverIf : ChannelName Type Expression Expression Reaction Qid @ ProtocolConfig .
 sd applyRetBind2OverIf(C, T, M1, M2, R, x) :=                                 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyRetBind2OverIf(C, T, M1, M2, R, x) } 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{retBind2OverIf(T, M1, M2, R, x)}} .
     
 strat symOverIf : Reaction Expression Expression @ ReactionConfig .
 sd symOverIf(R, Msg1, Msg2) :=
    sym[R1:Reaction <- R]
      {liftAllInnerBinds ; 
       ifOverBindAfterBinds ;
       bindRetInBranch ; idle
       *** applyCongRetBranch(Msg1, Msg2)
       } .   
       
 strat applySymOverIf : ChannelName Reaction Expression Expression @ ProtocolConfig .      
 sd applySymOverIf(C, R, Msg1, Msg2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySymOverIf(C, R, Msg1, Msg2) } 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{symOverIf(R, Msg1, Msg2)}} .
             
 *** strategies for families   
 
 var cases : Cases .
 var aP : Protocol .
 
 strat absorbReverseFamily : ChannelName Protocol @ ProtocolConfig .
 sd absorbReverseFamily(C, aP) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{absorbReverseFamily(C, aP)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             { 
              CONG-FAMILY-P{ 
                             ABSORB-LEFT-2[P2:Protocol <- aP]  
                           ; (try (comp-new-families))   
                           ; (try (COMP-NEW-newNF-newfamily)) 
                           }
             }
 .  
 
 strat absorbReverseNewNF : Protocol @ ProtocolConfig .
 sd absorbReverseNewNF(aP) :=
    ABSORB-LEFT-2[P2:Protocol <- aP] ;
    try (comp-new-families)
 . 
  
 var pr : Protocol . 
 var q3 : Qid .
 var nt : NatTerm . 
                       
 var q4 : Qid .
 
endsm
 
 )
