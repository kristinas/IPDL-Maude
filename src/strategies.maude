***( IPDL

  Copyright : (C) 2022-23, Kristina Sojakova, Mihai Codescu
  License   : GNU General Public License v3.0 or later (GPL-3.0-or-later)
  Authors   : Mihai Codescu <mscodescu@gmail.com>
              Kristina Sojakova <sojakova.kristina@gmail.com>

 Strategies for applying the rules. They are grouped by the main rule that is applied,
 e.g. subst or absorb, and they may have several forms to be applied in different context
 e.g. channels, families, groups of families, cases.
 
)

in ../src/syntax

smod STRATS is
 pr APPROX-EQUALITY .
 
 *** vars
  
 var pConf : ProtocolConfig .
 var rConf : ReactionConfig .
 var S Sigma : Signature .
 var D Delta : ChannelContext .
 var G : TypeContext .
 var P P1 P2 pr : Protocol .
 var R R1 R2 R3 R4 : Reaction .
 *** var Q Q' C Q1 Q2 x1 x2 y x : Qid .
 var c' : Qid .        
 var I O : Set{CNameBound} .
 var T T' T1 : Type .
 var flag : Bool .
 var M M1 M2 : Expression .
 var Dis : Distribution .
 var C C1 C2 x : ChannelName .
 var Q Q' x1 Q1 Q2 q1 q2 q3 q4 : Qid .
 var A : Set{BoolTerm} .
 var N w l : Nat .
 var nlist : List{NatTerm} .
 var blist : List{Bounds} .
 var bdlist1 bdlist2 bdlist3 bdlist4 : List{Bounds} .
 var BRL : BRList . 
 var ltq : TypedCNameList .
 var ql ql' cnl ql2 : List{CNameBound} .
 var QL : List{NatTerm} .
 var nt : NatTerm . 
 
 var ns ns1 ns2 ns3 ns4 fns fns1 fns2 : ChannelName .
 
 var cnb1 cnb2 cnb cnb3 : CNameBound .
 
 ***************************************
 *** substitution strategies
 ***************************************
 
 *** try both channel substitution rules
 strat smart-subst-nf : ChannelName ChannelName @ ProtocolConfig . 
 sd smart-subst-nf(C1, C2) :=                        
   substNFRead(C1, C2)
   ? idle
   : substNF(C1, C2) 
   . 
 
 *** substitution
 
 strat substNF : ChannelName ChannelName @ ProtocolConfig .
 sd substNF(C1, C2) :=  
     nTimesSubstNF(C1, C2) 
   ; liftInnerBindsNF(C2)
   ; handleRNF(C2)
   ; try (pre2Nf) 
   .   
 
 *** sub-steps in substitution
 
 *** apply SUBST of C1 in C2
 *** if the current P is newNF(..., C1 ::= R1 || C2 ::= nf( BRL (x <- read C1), R2, order) || Q  ,...) 
 strat nTimesSubstNF : ChannelName ChannelName @ ProtocolConfig .
 sd nTimesSubstNF(C1, C2) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstNF(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
         CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (chn C1) (chn C2), 
                         P1:Protocol <- keepTwo P (chn C1) (chn C2)]{
           SUBST-nf[o1:ChannelName <- C1, 
                    o2:ChannelName <- C2]
         }
         or-else *** deal with the case that Q is empty
         SUBST-nf[o1:ChannelName <- C1, 
                    o2:ChannelName <- C2]
       )            .
                   
 *** similar, but for SUBST-nf-read                               
 strat substNFRead : ChannelName ChannelName @ ProtocolConfig .
 sd substNFRead(C1, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substNFRead(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
         CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (chn C1) (chn C2), 
                         P1:Protocol <- keepTwo P (chn C1) (chn C2)]{
           SUBST-nf-read[cn1:ChannelName <- C1, 
                         cn2:ChannelName <- C2] 
         }
         or-else  
         SUBST-nf-read[cn1:ChannelName <- C1, 
                       cn2:ChannelName <- C2] 
       ).                   
 
 *** after subst we got x <~ nf(binds, R, ...)
 *** this strategy moves the binds outside <~
 strat liftInnerBindsNF : ChannelName @ ProtocolConfig .
 sd liftInnerBindsNF(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{liftInnerBindsNF(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        (  
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn C), 
                        P1:Protocol <- keepOne P (chn C)]{
         CONG-REACT[cn:ChannelName <- C]
         { try (     (bind-bind-pre or-else bind-bind-pre-pre)
                   ; (read-det-pre !)
               )
         }
        }
        )
        or-else
        (CONG-REACT[cn:ChannelName <- C]
         { try (     (bind-bind-pre or-else bind-bind-pre-pre)
                   ; (read-det-pre !)
               )
         }) 
       .
 
 *** this strategy handles the reaction of a pre-normal form, 
 *** applying various reaction-level rules.
 *** the goal is to move binds outside the reaction
 strat handleRNF : ChannelName @ ProtocolConfig .  
 sd handleRNF(C1) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{handleRNF(C1)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
         (
         CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn C1), 
                             P1:Protocol <- keepOne P (chn C1)]{
         CONG-REACT[cn:ChannelName <- C1]
                   {(ret-bind-pre or-else
                    (samp-over-if or-else 
                     (read2Binds or-else
                      (bind-ret-2-pre
                        or-else (merge-pre ; cong-pre-nf{bindFreeS})
                      )
                     )
                    )
                    ) 
                    ; simplifyNF
                   }
       }
       )
       or-else
       (
       CONG-REACT[cn:ChannelName <- C1]
                   {(ret-bind-pre or-else
                    (samp-over-if or-else 
                     (read2Binds or-else
                      (bind-ret-2-pre
                        or-else (merge-pre ; cong-pre-nf{bindFreeS})
                      )
                     )
                    )
                    ) 
                    ; simplifyNF
                   }
       ) .
       
 strat bindFreeS @ ReactionConfig .
 sd bindFreeS := 
     ((smart-ret-bind ; (if-left ? idle : (if-right ? idle : idle)) ) or-else
       (if-over-bind  
        ; cong-branch-refl{bindFreeS, bindFreeS}
       )
       ) or-else idle . 
       
 strat simplifyNF @ ReactionConfig .
 sd simplifyNF :=  
   cong-pre-nf{same-reaction-if} or-else idle 
 .    
 
 strat smart-ret-bind @ ReactionConfig .
 sd smart-ret-bind :=
     if-over-bind-same-2 
     ? (cong-branch-refl
        {cong-branch-refl{ret-bind , ret-bind},
         cong-branch-refl{ret-bind , ret-bind}} 
        ? idle
        : fail)  
     : (if-over-bind-same 
       ? (cong-branch-refl{ret-bind, ret-bind} ? idle : idle) 
       : ret-bind) 
       . 
    
 var fn1 fn2 fn3 : ChannelName .      
       
 *** apply subst-nf-read-rev-families
 strat substNFReadRevFamilies : 
         CNameBound CNameBound CNameBound @ ProtocolConfig .      
 sd substNFReadRevFamilies(fam (fn1[bdlist1]), fam (fn2[bdlist2]), fam (fn3[bdlist3])) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{
        substNFReadRevFamilies(fam (fn1[bdlist1]), fam (fn2[bdlist2]), fam (fn3[bdlist3]))
       } 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[
          Q:Protocol  <- removeThree P (fam (fn1[bdlist1])) 
                                       (fam (fn2[bdlist2])) 
                                       (fam (fn3[bdlist3])), 
          P1:Protocol <- keepThree P (fam (fn1[bdlist1])) 
                                     (fam (fn2[bdlist2])) 
                                     (fam (fn3[bdlist3]))]{
                             subst-nf-read-rev-families
                             }
              ) or-else
              subst-nf-read-rev-families
             )               
 .
 
 *** apply subst-or-diverge
 
 strat applySubstOrDiverge : CNameBound CNameBound Qid Reaction @ ProtocolConfig .
 sd applySubstOrDiverge(fam (C1[bdlist1]), fam (C2[bdlist2]), Q, R) :=
       match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstOrDiverge(fam (C1[bdlist1]), fam (C2[bdlist2]), Q, R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[
             Q:Protocol  <- removeTwo P (fam (C1[bdlist1])) 
                                        (fam (C2[bdlist2])), 
             P1:Protocol <- keepTwo P (fam (C1[bdlist1])) 
                                      (fam (C2[bdlist2]))]{
               subst-or-diverge[q:Qid <- Q]{
                 substNFFamiliesThree(fam (C1[bdlist1]), fam (C2[bdlist2]), R)} 
              }
             )
             or-else
             subst-or-diverge[q:Qid <- Q]{
              substNFFamiliesThree(fam (C1[bdlist1]), fam (C2[bdlist2]), R)} 
             )
 .
       
 *** apply subst-diverge-join-cases
 strat substDivergeJoinCases : CNameBound CNameBound Reaction Reaction @ ProtocolConfig .
 sd substDivergeJoinCases(fam (C1[bdlist1]), fam (C2[bdlist2]), R1, R2) :=
   match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substDivergeJoinCases(fam (C1[bdlist1]), fam (C2[bdlist2]), R1, R2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[
           Q:Protocol  <- removeTwo P (fam (C1[bdlist1])) 
                                      (fam (C2[bdlist2])), 
           P1:Protocol <- keepTwo P (fam (C1[bdlist1])) 
                                    (fam (C2[bdlist2]))]{
               subst-diverge-join-cases[R:Reaction <- R1]{ 
                 substNFFamiliesThree(fam (C1[bdlist1]), fam (C2[bdlist2]), R2)}
              }
             )
             or-else
             subst-diverge-join-cases[R:Reaction <- R1]{ 
              substNFFamiliesThree(fam (C1[bdlist1]), fam (C2[bdlist2]), R2)}  
             )
 .
 
 *** similar to substNF, but for families with one index
 strat substNFFamiliesOne : CNameBound CNameBound Reaction @ ProtocolConfig .
 sd substNFFamiliesOne(cnb1, cnb2, R) :=
     nTimesSubstNFFamiliesOne(cnb1, cnb2, R)
  ; liftInnerBindsNFFamily(cnb2)
  ; handleRNFFamily(cnb2)
  ; (pre2Nf or-else idle)  
 .
 
 *** similar to substNF, but for families with three indices
 strat substNFFamiliesThree : CNameBound CNameBound Reaction @ ProtocolConfig .
 sd substNFFamiliesThree(cnb1, cnb2, R) :=
     nTimesSubstNFFamiliesThree(cnb1, cnb2, R)
  ; liftInnerBindsNFFamily(cnb2)
  ; handleRNFFamily(cnb2)
  ; (pre2Nf or-else idle)  
 .
 
 *** sub-strategies, similar to the ones above
 strat nTimesSubstNFFamiliesOne :  CNameBound CNameBound Reaction @ ProtocolConfig .
 sd nTimesSubstNFFamiliesOne(fam (ns1[bdlist1]), fam (ns2[bdlist2]), R) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstNFFamiliesOne(fam (ns1[bdlist1]), fam (ns2[bdlist2]), R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
        P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]{
          subst-families-one-family[
                   fns2:ChannelName <- ns1, 
                   fns1:ChannelName <- ns2,
                   R2:Reaction <- R
                ]
                   } 
                or-else
                subst-families-one-family[
                   fns2:ChannelName <- ns1, 
                   fns1:ChannelName <- ns2,
                   R2:Reaction <- R
                ]
       )
 .
 
 strat nTimesSubstNFFamiliesThree : CNameBound CNameBound Reaction @ ProtocolConfig .
 sd nTimesSubstNFFamiliesThree(fam (ns1[bdlist1]), fam (ns2[bdlist2]), R) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstNFFamiliesThree(fam (ns1[bdlist1]), fam (ns2[bdlist2]), R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
         Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
         P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]{
          subst-families-three-family[
                   fns2:ChannelName <- ns1, 
                   fns1:ChannelName <- ns2,
                   R2:Reaction <- R
                ]
                   } 
                or-else
                subst-families-three-family[
                   fns2:ChannelName <- ns1, 
                   fns1:ChannelName <- ns2,
                   R2:Reaction <- R
                ]
       )
 .
 
 strat liftInnerBindsNFFamily : CNameBound @ ProtocolConfig .
 sd liftInnerBindsNFFamily(fam (cn[blist])) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{liftInnerBindsNFFamily(fam (cn[blist]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       (
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[blist])), 
                        P1:Protocol <- keepOne P (fam (cn[blist]))]{
         CONG-FAMILY-R[C:Qid <- cn]
         { (  bind-bind-pre 
          ; (read-det-pre !)
           )
           or-else idle
         }
        }
        
        or-else
        CONG-FAMILY-R[C:Qid <- cn]
         { (  bind-bind-pre 
          ; (read-det-pre !)
           )
           or-else idle
         }
         
        )
 .      
         
 strat handleRNFFamily : CNameBound @ ProtocolConfig .  
 sd handleRNFFamily(fam (cn[blist])) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{handleRNFFamily(fam (cn[blist]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[blist])), 
                             P1:Protocol <- keepOne P (fam (cn[blist]))]{
         CONG-FAMILY-R[C:Qid <- cn]
                   {(ret-bind-pre or-else
                    (samp-over-if or-else 
                     (read2Binds or-else
                      (bind-ret-2-pre
                        or-else (merge-pre ; cong-pre-nf{bindFreeS})
                      )
                     )
                    )
                    ) 
                    ; simplifyNF
                   }
       } 
       or-else
       CONG-FAMILY-R[C:Qid <- cn]
                   {(ret-bind-pre or-else
                    (samp-over-if or-else 
                     (read2Binds or-else
                      (bind-ret-2-pre
                        or-else (merge-pre ; cong-pre-nf{bindFreeS})
                      )
                     )
                    )
                    ) 
                    ; simplifyNF
                   }
       ).  
       
 *** under the assumption that the current protocol is of the form
 ***     family q2 ::= P || family q1 ::= when cond1 --> P1 ;; otherwise --> P2
 ***     do a substitution in P || P1               
 strat applyCaseDistSubst : 
   CNameBound CNameBound CNameBound CNameBound Protocol @ ProtocolConfig .
 sd applyCaseDistSubst(fam (ns1[bdlist1]), 
                       fam (ns2[bdlist2]), 
                       fam (ns3[bdlist3]), 
                       fam (ns4[bdlist4]), pr) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyCaseDistSubst(fam (ns1[bdlist1]), 
                       fam (ns2[bdlist2]), 
                       fam (ns3[bdlist3]), 
                       fam (ns4[bdlist4]), pr)}
    : 
       CASE-DISTINCTION-one[fns:ChannelName <- ns1]
         { use-family-p[fns:ChannelName <- ns2]
             { COMP-NEW-newNF
             ; applySubstReadFamilyTwoFamily(fam (ns3[bdlist3]), fam (ns4[bdlist4]))
             ; (SYM[P1:Protocol <- pr]{COMP-NEW-newNF})
             }
         , idle
         } .         
         
  *** sub-strategy
                                               
 strat applySubstReadFamilyTwoFamily : CNameBound CNameBound @ ProtocolConfig .
 sd applySubstReadFamilyTwoFamily(fam (ns1[bdlist1]), fam (ns2[bdlist2])) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstReadFamilyTwoFamily(fam (ns1[bdlist1]), 
                       fam (ns2[bdlist2]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])),
        P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]
             {SUBST-nf-read-family-two-family}                
             or-else
             SUBST-nf-read-family-two-family
             )
 . 
 
 *** do a subst on the first branch of a family
  strat applySubstChannelBranch : CNameBound CNameBound @ ProtocolConfig .
 sd applySubstChannelBranch(fam (ns1[bdlist1]), fam (ns2[bdlist2])) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applySubstChannelBranch(fam (ns1[bdlist1]), fam (ns2[bdlist2]))}
    :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using  
       CASE-DISTINCTION-one-R[fns:ChannelName <- ns1, 
         P:Protocol <- removeOne P (fam (ns1[bdlist1]))]
         {  substChannelFamilyOne(fam (ns2[bdlist2]), fam (ns1[bdlist1]))
           , idle
         } .  
         
  *** substitute a channel in a family
  strat substChannelFamilyOne : CNameBound CNameBound @ ProtocolConfig .
 sd substChannelFamilyOne(fam (ns1[bdlist1]), fam (ns2[bdlist2])) :=
    nTimesSubstChannelFamilyOne(fam (ns1[bdlist1]), fam (ns2[bdlist2]))
  ; liftInnerBindsNFFamily(fam (ns2[bdlist2]))
  ; handleRNFFamily(fam (ns2[bdlist2]))
  ; (pre2Nf or-else idle)  
 . 
 
 *** sub-strategy, similar to subst-nf
 strat nTimesSubstChannelFamilyOne :  CNameBound CNameBound @ ProtocolConfig .
 sd nTimesSubstChannelFamilyOne(fam (ns1[bdlist1]), fam (ns2[bdlist2])) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstChannelFamilyOne(fam (ns1[bdlist1]), fam (ns2[bdlist2]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
        P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]{                  
                   subst-channel-one-family}
               or-else    
               subst-channel-one-family
             )
 .   
 
 *** on the left branch of the right branch of a family, do a substitution
 strat applyCaseDistBranch2 : CNameBound CNameBound @ ProtocolConfig .
 sd applyCaseDistBranch2(fam (ns1[bdlist1]), fam (ns2[bdlist2]) ) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyCaseDistBranch2(fam (ns1[bdlist1]), fam (ns2[bdlist2]) )}
    :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using  
       CASE-DISTINCTION-one-R[fns:ChannelName <- ns1, 
          P:Protocol <- removeOne P (fam (ns1[bdlist1])) ]
         { idle
         , CASE-DISTINCTION-one-R[fns:ChannelName <- ns1]
           { substChannelFamilyOne(fam (ns2[bdlist2]),fam (ns1[bdlist1]))
           , idle}
         } .   
         
   *** on the left branch of a family, do a reverse subst
 strat applyBranch2SubstRev : 
       CNameBound CNameBound NatTerm Qid Type Reaction @ ProtocolConfig .
 sd applyBranch2SubstRev(fam (ns1[bdlist1]), fam (ns2[bdlist2]), nt, x, T, R) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyBranch2SubstRev(fam (ns1[bdlist1]), fam (ns2[bdlist2]), nt, x, T, R)}
    :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using  
       CASE-DISTINCTION-one-R[fns:ChannelName <- ns1, 
        P:Protocol <- removeOne P  (fam (ns1[bdlist1])) ]
         {   applySubstNfRevFamiliesOne(fam (ns1[bdlist1]), fam (ns2[bdlist2]), nt, x, T, R)
           , idle
         } . 
         
  *** does the reverse substitution
  strat applySubstNfRevFamiliesOne : CNameBound CNameBound NatTerm Qid Type Reaction @ ProtocolConfig .
 sd applySubstNfRevFamiliesOne(fam (ns1[bdlist1]), fam (ns2[bdlist2]), nt, x, T, R) := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{
      applySubstNfRevFamiliesOne(fam (ns1[bdlist1]), fam (ns2[bdlist2]), nt, x, T, R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
        P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]{                  
                    SUBST-nf-rev-families-one[
                      x1:ChannelName <- x, 
                      nj:NatTerm <- nt,
                      R2:Reaction <- R,
                      T1:Type <- T]
                     }
                or-else  
                 SUBST-nf-rev-families-one[
                      x1:ChannelName <- x, 
                      nj:NatTerm <- nt,
                      R2:Reaction <- R,
                      T1:Type <- T]    
              )       
 .                     
   
   *** subst-reverse with a case in a family
 strat applySubstRevFamily : CNameBound ChannelName Type @ ProtocolConfig .
 sd applySubstRevFamily(fam (ns[blist]), C2, T) := 
 match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstRevFamily(fam (ns[blist]), C2, T)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
              CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (fam (ns[blist])) (chn C2), 
                             P1:Protocol <- keepTwo P (fam (ns[blist])) (chn C2)]
             {subst-rev-families[fns:ChannelName <- ns, 
                    cn2:ChannelName <- C2,
                    T:Type <- T]} 
              or-else    
              subst-rev-families[fns:ChannelName <- ns,
                    cn2:ChannelName <- C2,
                    T:Type <- T] 
             )        
 .   
                    
 *** subst-nf-read for families with one and two indices
 strat substNFReadFamilyOneChannel : CNameBound ChannelName @ ProtocolConfig .
 sd substNFReadFamilyOneChannel(fam (ns[blist]), C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substNFReadFamilyOneChannel(fam (ns[blist]), C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (fam (ns[blist])) (chn C2), 
                             P1:Protocol <- keepTwo P (fam (ns[blist])) (chn C2)]{
         SUBST-nf-read-family-one
                      [ fns1:ChannelName <- ns,
                       cn2:ChannelName <- C2] } 
               or-else   
               SUBST-nf-read-family-one
                      [ fns1:ChannelName <- ns, 
                       cn2:ChannelName <- C2]     
                       ) 
  . 
                       
 strat substNFReadFamilyTwoChannel : CNameBound ChannelName @ ProtocolConfig .
 sd substNFReadFamilyTwoChannel(fam (ns[blist]), C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substNFReadFamilyTwoChannel(fam (ns[blist]), C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (fam (ns[blist])) (chn C2), 
                             P1:Protocol <- keepTwo P (fam (ns[blist])) (chn C2)]{
         SUBST-nf-read-family-two
                      [ fns1:ChannelName <- ns,  
                       cn2:ChannelName <- C2] } 
             or-else          
         SUBST-nf-read-family-two
                      [ fns1:ChannelName <- ns,  
                       cn2:ChannelName <- C2]         
             )
 .
 
 *** subst-reverse for a family and a channel
 strat substRevFamilyChannel : CNameBound ChannelName NatTerm Type @ ProtocolConfig .
 sd substRevFamilyChannel(fam (ns[blist]), C2, nt, T) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substRevFamilyChannel(fam (ns[blist]), C2, nt, T)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (fam (ns[blist])) (chn C2), 
                             P1:Protocol <- keepTwo P (fam (ns[blist])) (chn C2)]{
         subst-2-families-one
                      [ fns:ChannelName <- ns, 
                        cn2:ChannelName <- C2,
                        nj:NatTerm <- nt,
                        T:Type <- T
                      ]   } 
              or-else 
              subst-2-families-one
                      [ fns:ChannelName <- ns, 
                        cn2:ChannelName <- C2,
                        nj:NatTerm <- nt,
                        T:Type <- T
                      ]       
              )
  .   
                      
 *** subst-nf for families
 strat substNFFamilyOne : CNameBound ChannelName Reaction @ ProtocolConfig .
 sd substNFFamilyOne(cnb1, C2, R) :=
     nTimesSubstNFFamilyOne(cnb1, C2, R)
  ; liftInnerBindsNF(C2)
  ; handleRNF(C2)
  ; (pre2Nf or-else idle)  
 .   
 
 *** similar sub-strategy as for channels
 strat nTimesSubstNFFamilyOne : CNameBound ChannelName Reaction @ ProtocolConfig .
 sd nTimesSubstNFFamilyOne(fam (C1[bdlist1]), C2, R) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstNFFamilyOne(fam (C1[bdlist1]), C2, R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
       Q:Protocol  <- removeTwo P (fam (C1[bdlist1])) (chn C2), 
       P1:Protocol <- keepTwo P (fam (C1[bdlist1])) (chn C2)]{
          subst-families-one[
                   fns:ChannelName <- C1, 
                   cn2:ChannelName <- C2,
                   R2:Reaction <- R
                ]
                   } 
                   or-else
                   subst-families-one[
                   fns:ChannelName <- C1, 
                   cn2:ChannelName <- C2,
                   R2:Reaction <- R
                ]
                   )
 .  
 
*** subst-nf for families with three indices
 strat substNFFamilyThree : CNameBound ChannelName Reaction @ ProtocolConfig .
 sd substNFFamilyThree(cnb1, C2, R) :=
     nTimesSubstNFFamilyThree(cnb1, C2, R)
  ; liftInnerBindsNF(C2)
  ; handleRNF(C2)
  ; (pre2Nf or-else idle)  
 .   
 
 *** similar sub-strategy as for channels
 strat nTimesSubstNFFamilyThree : CNameBound ChannelName Reaction @ ProtocolConfig .
 sd nTimesSubstNFFamilyThree(fam (C1[bdlist1]), C2, R) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstNFFamilyThree(fam (C1[bdlist1]), C2, R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (C1[bdlist1])) (chn C2), 
        P1:Protocol <- keepTwo P (fam (C1[bdlist1])) (chn C2)]{
          subst-families-three[
                   fns:ChannelName <- C1, 
                   cn2:ChannelName <- C2,
                   R2:Reaction <- R
                ]
                   } 
                   or-else
                   subst-families-three[
                   fns:ChannelName <- C1, 
                   cn2:ChannelName <- C2,
                   R2:Reaction <- R
                ]
                   )
 .  
                   
 *** subst on the left branch of a family
 strat applySubstNFLeft : CNameBound CNameBound Reaction @ ProtocolConfig .
 sd applySubstNFLeft(fam (C1[bdlist1]), fam (C2[bdlist2]), R) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applySubstNFLeft(fam (C1[bdlist1]), fam (C2[bdlist2]), R)}
    :    
       CASE-DISTINCTION-one-R[fns:ChannelName <- C1]
         { substNFFamiliesOne(fam (C2[bdlist2]), fam (C1[bdlist1]), R)
         , idle
         } .
                 
   
   ************************
   *** drop
   ************************    
  
  *** drop-nf-family-channel
  strat applyDropNFCF : CNameBound ChannelName @ ProtocolConfig .
  sd applyDropNFCF(fam (ns[blist]), C2) :=
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropNFCF(fam (ns[blist]), C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
         CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (fam (ns[blist])) (chn C2), 
                         P1:Protocol <- keepTwo P (fam (ns[blist])) (chn C2)]{
              DROP-nf-cf[fns:ChannelName <- ns, 
                         cn:ChannelName <- C2]
         }
         or-else DROP-nf-cf[fns:ChannelName <- ns, 
                         cn:ChannelName <- C2]
                                   
       )
  .
  
  *** drop-nf-channel-family with cases
  strat applyDropNFCFCases : CNameBound ChannelName BoolTerm @ ProtocolConfig .
  sd applyDropNFCFCases(fam (ns[blist]), C2, bt) :=
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropNFCFCases(fam (ns[blist]), C2, bt)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
         CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (fam (ns[blist])) (chn C2), 
                         P1:Protocol <- keepTwo P (fam (ns[blist])) (chn C2)]{
              DROP-nf-cf-cases[fns:ChannelName <- ns, 
                         cn:ChannelName <- C2,
                         bt:BoolTerm <- bt]
         }
         or-else DROP-nf-cf-cases[fns:ChannelName <- ns, 
                         cn:ChannelName <- C2,
                         bt:BoolTerm <- bt]
                                   
       )
  .
       
  *** DROP-NF
  
 strat applyDropNF : ChannelName ChannelName @ ProtocolConfig .
 sd applyDropNF(C1, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropNF(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (chn C1) (chn C2), 
                             P1:Protocol <- keepTwo P (chn C1) (chn C2)]{
         DROP-nf[cn1:ChannelName <- C1, 
                   cn2:ChannelName <- C2] 
         or-else
         DROP-nf-copy[
                   cn1:ChannelName <- C1, 
                   cn2:ChannelName <- C2]           } )
          or-else
          (DROP-nf[cn1:ChannelName <- C1, 
                   cn2:ChannelName <- C2] 
         or-else
         DROP-nf-copy[
                   cn1:ChannelName <- C1, 
                   cn2:ChannelName <- C2]  )         
  . 
                   
  *** drop for pre-normal forms
                    
 strat applyDropPreNF : ChannelName ChannelName @ ProtocolConfig .
 sd applyDropPreNF(C1, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropPreNF(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (chn C1) (chn C2), 
                             P1:Protocol <- keepTwo P (chn C1) (chn C2)]{
         DROP-pre-nf[cn1:ChannelName <- C1, 
                     cn2:ChannelName <- C2] } 
              or-else
               DROP-pre-nf[
                   cn1:ChannelName <- C1, 
                   cn2:ChannelName <- C2]
              ) 
                   
 .      
 
 *** apply drop for families
 
 strat applyDropNFFamilies : CNameBound CNameBound @ ProtocolConfig .
 sd applyDropNFFamilies(fam (ns1[bdlist1]), fam (ns2[bdlist2])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropNFFamilies(fam (ns1[bdlist1]), fam (ns2[bdlist2]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
        P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]{
         DROP-nf-families
       }
       or-else  DROP-nf-families
             )
 .       
 
 *** apply drop for channels, several reads before samp
 
  strat applyDropNFChannels : ChannelName ChannelName @ ProtocolConfig .
 sd applyDropNFChannels(C1, C2) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropNFChannels(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (chn C1) (chn C2), 
                             P1:Protocol <- keepTwo P (chn C1) (chn C2)]{
               DROP-nf-channels
              }
              or-else  DROP-nf-channels
             )
 .                     
  
  *********************
  *** subsume
  *********************
  
 strat applyDropSubsumeRevFamilies : CNameBound CNameBound @ ProtocolConfig .
 sd applyDropSubsumeRevFamilies(fam (ns1[bdlist1]), fam (ns2[bdlist2])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropSubsumeRevFamilies(fam (ns1[bdlist1]), fam (ns2[bdlist2]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
         Q:Protocol  <- removeTwo P  (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
         P1:Protocol <- keepTwo P  (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]{
                    DROP-SUBSUME-families
             }
              or-else DROP-SUBSUME-families
             )
 . 
 
 strat applyDropSubsumeRevChannels : Qid Qid @ ProtocolConfig .
 sd applyDropSubsumeRevChannels(C1, C2) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropSubsumeRevChannels(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (chn C1) (chn C2), 
        P1:Protocol <- keepTwo P (chn C1) (chn C2)]{
                             DROP-SUBSUME-channels
                             }
              or-else DROP-SUBSUME-channels
             )
 . 
  
 strat applySubsumeRevFamilies : CNameBound CNameBound Qid @ ProtocolConfig .
 sd applySubsumeRevFamilies(fam (ns1[bdlist1]), fam (ns2[bdlist2]), x) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubsumeRevFamilies(fam (ns1[bdlist1]), fam (ns2[bdlist2]), x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
        P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]{
                             subsume-families-one-rev[x0:ChannelName <- x]
                             }
              or-else  (subsume-families-one-rev[x0:ChannelName <- x])
             )
 . 
 
 strat applySubsumeRevChannels : ChannelName ChannelName Qid @ ProtocolConfig .
 sd applySubsumeRevChannels(C1, C2, x) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubsumeRevChannels(C1, C2, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (chn C1) (chn C2), 
                             P1:Protocol <- keepTwo P (chn C1) (chn C2)]{
                             subsume-channels-one-rev[x0:ChannelName <- x]
                             }
              or-else  (subsume-channels-one-rev[x0:ChannelName <- x])
             )
 . 
 
 strat applySubsumeRevFamilyChannel : CNameBound ChannelName Qid @ ProtocolConfig .
 sd applySubsumeRevFamilyChannel(fam (C1[blist]), C2, x) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubsumeRevFamilyChannel(fam (C1[blist]), C2, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (fam (C1[blist])) (chn C2), 
                             P1:Protocol <- keepTwo P (fam (C1[blist])) (chn C2)]{
                             subsume-channels-family-one-rev[x0:ChannelName <- x]
                             }
              or-else  (subsume-channels-family-one-rev[x0:ChannelName <- x])
             )
 . 
 
 strat applySubsumeRevFamiliesList : CNameBound CNameBound List{NatTerm} @ ProtocolConfig .
 sd applySubsumeRevFamiliesList(cnb1, cnb2, nil) := idle .
 sd applySubsumeRevFamiliesList(cnb1, cnb2, x QL) :=
     applySubsumeRevFamilies(cnb1, cnb2, x)
   ; applySubsumeRevFamiliesList(cnb1, cnb2, QL)
 .  
   
 strat applySubsumeRevChannelsList : ChannelName ChannelName List{NatTerm} @ ProtocolConfig .
 sd applySubsumeRevChannelsList(C1, C2, nil) := idle .
 sd applySubsumeRevChannelsList(C1, C2, x QL) :=
     applySubsumeRevChannels(C1, C2, x)
   ; applySubsumeRevChannelsList(C1, C2, QL)
 .  
 
 strat applySubsumeFamilyCasesChannelList : 
   CNameBound ChannelName List{NatTerm} @ ProtocolConfig .
 sd applySubsumeFamilyCasesChannelList(cnb1, C2, nil) := idle .
 sd applySubsumeFamilyCasesChannelList(cnb1, C2, x QL) :=
     applySubsumeFamilyCasesChannel(cnb1, C2, x)
   ; applySubsumeFamilyCasesChannelList(cnb1, C2, QL)
 .  
 
 strat applySubsumeFamilyCasesChannel : CNameBound ChannelName Qid @ ProtocolConfig .
 sd applySubsumeFamilyCasesChannel(fam (C1[bdlist1]), C2, x) :=
      ( match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubsumeFamilyCasesChannel(fam (C1[bdlist1]), C2, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (fam (C1[bdlist1])) (chn C2), 
                             P1:Protocol <- keepTwo P (fam (C1[bdlist1])) (chn C2)]{
                             subsume-family-cases-channel{
       subsume-channels-one-rev[x0:ChannelName <- x]
       }
                             }
              or-else  (subsume-family-cases-channel{
                          subsume-channels-one-rev[x0:ChannelName <- x]
                        }
                       )
             )
       )
       ; 
       removeDuplicateReadsNF(C2)      
 . 
 
 strat applyDropFamilyCasesChannel : CNameBound ChannelName @ ProtocolConfig .
 sd applyDropFamilyCasesChannel(fam (C1[blist]), C2) :=
      match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropFamilyCasesChannel(fam (C1[blist]), C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (fam (C1[blist])) (chn C2), 
                             P1:Protocol <- keepTwo P (fam (C1[blist])) (chn C2)]{
        subsume-family-cases-channel{
          DROP-nf-channels
        }
                             }
              or-else DROP-nf-channels 
             )
 .

   
  *********************
  *** absorb
  *********************
                   
 *** absorb a channel  
 strat absorbChannel : ChannelName @ ProtocolConfig .
 sd absorbChannel(C) := 
    absorb-new-nf[c:ChannelName <- C] 
 .
 
 *** absorb a family
 strat absorbFamily : CNameBound @ ProtocolConfig .
 sd absorbFamily(fam (ns[blist])) := 
  ***(
    absorb-new-nf-family-one[C:Qid <- Q] 
    or-else
    absorb-new-nf-family-two[C:Qid <- Q]
    or-else
    )
    absorb-new-nf-family[fns:NameWithScripts <- ns, blist:List{Bounds} <- blist]      
 . 
 
 strat absorbFamilyDeleteEmpty : CNameBound @ ProtocolConfig .
 sd absorbFamilyDeleteEmpty(fam (ns[blist])) := 
    absorbFamily(fam (ns[blist])) 
    ; 
    try (delete-empty-newNF)
 .   
  *** add a newfamily to a named group of protocols
 strat addNewFamilyToGroup : Protocol CNameBound CNameBound @ ProtocolConfig .
 sd addNewFamilyToGroup(P, cnb1, cnb2) :=
     applyAbsorbReverse(P)
   ; moveProtocolUnderNewNF
   ; lift-inner-new-nf
   ; applyAddToGroup(cnb1, cnb2)
 .  
 
 *** substrategies
  strat applyAbsorbReverse : Protocol @ ProtocolConfig .
  sd applyAbsorbReverse(P) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAbsorbReverse(P)}
     :  ABSORB-LEFT-2[P2:Protocol <- new2NF(P)] 
     .  
 

 
 *** under the assumption that the current protocol is of the form
 ***     family q2 ::= P || family q1 ::= when cond1 --> P1 ;; otherwise --> P2
 *** do an absorb   
 strat applyCaseDistAbsorb : 
    ChannelName ChannelName CNameBound Protocol @ ProtocolConfig .
 sd applyCaseDistAbsorb(ns1, ns2, fam (ns3[bdlist3]), pr) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyCaseDistAbsorb(ns1, ns2, fam (ns3[bdlist3]), pr)}
    : CASE-DISTINCTION-one[fns:ChannelName <- ns1]
         { use-family-p[fsn:ChannelName <- ns2]
             { COMP-NEW-newNF
             ; absorbFamilyDeleteEmpty(fam (ns3[bdlist3]))
             ; (SYM[P1:Protocol <- pr]{COMP-NEW-newNF})
             }
         , idle
         } .       
 
 *********************
 *** fold
 *********************
 
 *** fold a channel
 strat foldNF : ChannelName ChannelName @ ProtocolConfig .
 sd foldNF(C1, C2) := 
                 (fold-bind-new-nf[c:ChannelName <- C1,
                                   o:ChannelName <- C2] 
                  or-else 
                  fold-bind-new-prenf[c:ChannelName <- C1,
                                      o:ChannelName <- C2] 
                  or-else
                  fold-bind-new-nf-0[c:ChannelName <- C1,
                                   o:ChannelName <- C2]                     )
               ; liftInnerBindsNF(C2) 
               ; handleRNF(C2) 
               ; try (pre2Nf)
               ; try (delete-empty-newNF)
                 .
                 
 *** fold a pre-normal form                
 strat foldNFPre : ChannelName ChannelName @ ProtocolConfig .  
 sd foldNFPre(C1, C2) := 
                 fold-bind-new-prenf[c:ChannelName <- C1,
                                     o:ChannelName <- C2] ;
                 liftInnerBindsNF(C2) ;
                 handleRpreNF(C2) 
                 .  
                 
 strat handleRpreNF : ChannelName @ ProtocolConfig .  
 sd handleRpreNF(C1) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{handleRpreNF(C1)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn C1), 
                        P1:Protocol <- keepOne P (chn C1)]{
         CONG-REACT[o:ChannelName <- C1]
                   {merge-pre}}
          or-else
          CONG-REACT[o:ChannelName <- C1]
                   {merge-pre}        
         )          
        .   
       
 *** fold a family                
 strat foldNFFamily : CNameBound CNameBound @ ProtocolConfig .
 sd foldNFFamily(fam (ns1[bdlist1]), fam (ns2[bdlist2])) := 
                 (fold-bind-new-nf-families[fns1:ChannelName <- ns1,
                                            fns2:ChannelName <- ns2] 
                  or-else  
                  fold-bind-new-nf-families-zero[fns1:ChannelName <- ns1,
                                            fns2:ChannelName <- ns2]
                 )
                 *** these last 2 steps should be reusable from subst!
                 ; liftInnerBindsNFFamily(fam (ns2[bdlist2])) 
                 ; handleRNFFamily(fam (ns2[bdlist2])) 
                 ; try (pre2Nf)
                  ; try (delete-empty-newNF)
                 .                         
 
 *** do a sym-proof
 *** applying if-ext twice in the reaction of a normal form
 *** on the first branch for a family
 
 strat applyIfExt2 : CNameBound Reaction Qid Qid @ ProtocolConfig .
 sd applyIfExt2(fam (ns1[bdlist1]), R, Q1, Q2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyIfExt2(fam (ns1[bdlist1]), R, Q1, Q2)}
     : 
        CASE-DISTINCTION-one-R[fns:ChannelName <- ns1]
         {matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (ns1[bdlist1])), 
                                    P1:Protocol <- keepOne P (fam (ns1[bdlist1]))]{
                       CONG-REACT-family[fns:ChannelName <- ns1] { 
                         cong-nf{
                         sym[R1:Reaction <- R]{
                           if-intro-ext[q:Qid <- Q1] 
              ; cong-branch[M2:Expression <- Q1]{
                   if-intro-ext[q:Qid <- Q2], 
                   if-intro-ext[q:Qid <- Q2]
                }  
                } *** end sym
                         }
                       }
                     }
         , 
          idle
         }
             
 .             
 
 ***********************************
 *** pure syntactic transformations
 ***********************************
 
 strat applyExpandTypeNF : ChannelName @ ProtocolConfig .
 sd applyExpandTypeNF(cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyExpandTypeNF(cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        ( CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                          P1:Protocol <- keepOne P (chn cn)]{
               CONG-REACT{expand-type-nf !}           
                          }
          or-else   
          CONG-REACT{expand-type-nf !}
        )               
 .
 
 strat applyGetChannel : CNameBound @ ProtocolConfig .
 sd applyGetChannel(cnb) :=
    get-channel[cnb:CNameBound <- cnb]
 .    
 
 strat removeDuplicateReadsNF : ChannelName @ ProtocolConfig .
 sd removeDuplicateReadsNF(C1) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{removeDuplicateReadsNF(C1)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn C1), 
                        P1:Protocol <- keepOne P (chn C1)]{
         CONG-REACT[cn:ChannelName <- C1]{read-det-nf !}
       } . 
 
 var bt : BoolTerm .
 
 *** turn a plain family definition to a cases one with same reaction on each branch
 strat applyAddSameCases : CNameBound BoolTerm @ ProtocolConfig .
 sd applyAddSameCases(fam (ns1[bdlist1]), bt) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAddSameCases(fam (ns1[bdlist1]), bt)}
     : matchrew pConf s.t. 
         pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (ns1[bdlist1])), 
                             P1:Protocol <- keepOne P (fam (ns1[bdlist1]))]
              {add-same-cases[bt:BoolTerm <- bt]}                
             or-else add-same-cases[bt:BoolTerm <- bt]
             )                              
 .   
 
 *** get all new declarations in front
 strat moveNewToFront @ ProtocolConfig .
 sd moveNewToFront := 
     *** ((CONG-NEW-NF{CONG-COMP-RIGHT{comp-new-families}}) !) 
     applyCompNewFamilies
   ; (moveProtocolUnderNewNF !)
   ; (lift-inner-new-nf !)
 .  
 
 *** compose new families in a parallel composition
 *** TODO: this strategy is not efficient!
 strat applyCompNewFamilies @ ProtocolConfig .
 sd applyCompNewFamilies :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCompNewFamilies}
     : ((CONG-COMP-RIGHT{comp-new-families} or-else comp-new-families) !)
 .    
 
  *** move the family ns2 inside the group ns1
 strat applyAddToGroup : CNameBound CNameBound @ ProtocolConfig .
 sd applyAddToGroup(fam (ns1[bdlist1]), fam (ns2[bdlist2])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAddToGroup(fam (ns1[bdlist1]), fam (ns2[bdlist2]))}
     : matchrew pConf s.t. 
         pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
       Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
       P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]
             {addToGroup}                
             or-else addToGroup
             )
 . 
 
  *** move the family Q2 on each case inside the group Q1
 strat applyAddToGroupCases : CNameBound CNameBound @ ProtocolConfig .
 sd applyAddToGroupCases(fam (ns1[bdlist1]), fam (ns2[bdlist2])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAddToGroupCases(fam (ns1[bdlist1]), fam (ns2[bdlist2])) }
     : matchrew pConf s.t. 
         pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])) , 
        P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]
             {applyAddToGroupCasesAux}                
             or-else applyAddToGroupCasesAux
             )
 . 
 
 strat applyAddToGroupCasesAux @ ProtocolConfig .
 sd applyAddToGroupCasesAux :=
  addToGroupCases-end
   or-else
  addToGroupCases{applyAddToGroupCasesAux}
 . 
 
 *** change order of reads in a normal form on a branch of a channel
 strat applyChangeOrderBranch : ChannelName BoolTerm List{NatTerm} @ ProtocolConfig .
    sd applyChangeOrderBranch(cn, bt, QL) := 
        match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyChangeOrderBranch(cn, bt, QL)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
          using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                                 P1:Protocol <- keepOne P (chn cn)]{
                                 cong-cases-reaction[cn:ChannelName <- cn, bt:BoolTerm <- bt]{
         
                   CONG-REACT[cn:ChannelName <- cn]{change-order[QL':List{NatTerm} <- QL]}
                 }
                                 }
                )
    .
 
 *** change order of reads in a normal form or a pre-normal form                        
 strat changeOrder : CNameBound List{NatTerm} @ ProtocolConfig .
  sd changeOrder(chn C, QL) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{changeOrder(chn C, QL)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn C), 
                             P1:Protocol <- keepOne P (chn C)]{
         CONG-REACT[o:ChannelName <- C]
         {change-order[QL':List{NatTerm} <- QL]
          or-else
          change-order-pre[QL':List{NatTerm} <- QL]
         }
         
       }
       or-else
        CONG-REACT[o:ChannelName <- C]
         {change-order[QL':List{NatTerm} <- QL]
          or-else
          change-order-pre[QL':List{NatTerm} <- QL]
         }
       
       )
 .
 sd changeOrder(fam (ns[blist]), QL) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{changeOrder(fam (ns[blist]), QL)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (ns[blist])), 
                             P1:Protocol <- keepOne P (fam (ns[blist]))]{
         
         CONG-REACT-family[fns:ChannelName <- ns]
         {change-order[QL':List{NatTerm} <- QL]
          or-else
          change-order-pre[QL':List{NatTerm} <- QL]
         }
       }
       or-else
         CONG-REACT-family[fns:ChannelName <- ns]
         {change-order[QL':List{NatTerm} <- QL]
          or-else
          change-order-pre[QL':List{NatTerm} <- QL]
         }  
       )
 .
 
 *** turn a nf to prenf 
 strat nf2PreNF : ChannelName @ ProtocolConfig .
 sd nf2PreNF(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nf2PreNF(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn C), 
                        P1:Protocol <- keepOne P (chn C)]
        {CONG-REACT[o:ChannelName <- C]{nf2Pre}} 
        or-else
        CONG-REACT[o:ChannelName <- C]{nf2Pre}
        )
 .  
 
  *** group families 
   strat applyGroupFamilies : ChannelName ChannelName @ ProtocolConfig .
   sd applyGroupFamilies(ns1, ns2) :=
   match pConf s.t. startsWithNew pConf
   ? CONG-NEW-NF{applyGroupFamilies(ns1, ns2)}
   : group-families[fns1:ChannelName <- ns1, fns2:ChannelName <- ns2]
 .       
 
 *** ungroup families
 strat applyUngroupFamilies : ChannelName ChannelName @ ProtocolConfig .
 sd applyUngroupFamilies(ns1, ns2) :=
   match pConf s.t. startsWithNew pConf
   ? CONG-NEW-NF{applyUngroupFamilies(ns1, ns2)}
   : ungroup-families[fns1:ChannelName <- ns1, fns2:ChannelName <- ns2]
 .    
 
 *** get a protocol inside a new normal form
 strat moveProtocolUnderNewNF @ ProtocolConfig .
 sd moveProtocolUnderNewNF := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveProtocolUnderNewNF} 
     : COMP-NEW-newNF
 .
 
  *** strategies for bringing a protocol to combined notation
 strat applyDeleteEmptyNF : CNameBound  @ ProtocolConfig .
 sd applyDeleteEmptyNF(fam (ns[blist])) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDeleteEmptyNF(fam (ns[blist]))} 
     :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (ns[blist])), 
                             P1:Protocol <- keepOne P (fam (ns[blist]))]
                             {CONG-FAMILY-WHENLIST-P{ delete-empty-newNF }  }
              or-else   CONG-FAMILY-WHENLIST-P{ delete-empty-newNF }            
             )
 .
 
 strat applyDropName :  CNameBound  @ ProtocolConfig .
 sd applyDropName(fam (ns[blist])) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropName(fam (ns[blist]))} 
     :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (ns[blist])), 
                             P1:Protocol <- keepOne P (fam (ns[blist]))]
                     {drop-group-name[fns:ChannelName <- ns]}
               or-else (drop-group-name[fns:ChannelName <- ns])
             )
 .

***(
 strat applyCombine : ChannelName @ ProtocolConfig .
 sd applyCombine(ns) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCombine(ns)} 
     :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P ns, 
                             P1:Protocol <- keepOne P ns]
                             {convert-combined}
             or-else convert-combined                
             )
 .
)
 
 strat applyNewCombine : CNameBound @ ProtocolConfig .
 sd applyNewCombine(fam (ns[blist])) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyNewCombine(fam (ns[blist]))} 
     :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (ns[blist])), 
                             P1:Protocol <- keepOne P (fam (ns[blist]))]
                             {convert-combined-new}
             or-else convert-combined-new                
             )
 .
 
 var whenCond : WhenCond .
 var q : Qid .
 var cn : ChannelName .
 
 *** do an alpha-renaming on a branch of a family, identified by its condition
 strat applyAlphaBranchCond : CNameBound Qid Qid WhenCond @ ProtocolConfig .
 sd applyAlphaBranchCond(chn cn, q1, q2, whenCond) :=
   match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyAlphaBranchCond(chn cn, q1, q2, whenCond)}
    : 
    alpha-branch-channel[cn:ChannelName <- cn, 
      q1:Qid <- q1, q2:Qid <- q2, whenCond:WhenCond <- whenCond
    ]
 .
 sd applyAlphaBranchCond(fam (cn[blist]), q1, q2, whenCond) :=
   match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyAlphaBranchCond(fam (cn[blist]), q1, q2, whenCond)}
    : 
    alpha-branch[fns:ChannelName <- cn, q1:Qid <- q1, q2:Qid <- q2, whenCond:WhenCond <- whenCond]
 .
 
 *** do an alpha-renaming on the first branch of a family or a channel!
 strat applyBranch1Alpha : CNameBound QidPairList @ ProtocolConfig .
 sd  applyBranch1Alpha(chn cn, QPL) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyBranch1Alpha(chn cn, QPL)}
    : (
       (CASE-DISTINCTION-channel[cn:ChannelName <- cn]
         {matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                                    P1:Protocol <- keepOne P (chn cn)]{
                       CONG-REACT { alphaNFOverList(QPL)}
                     }
         , 
          idle
         }
       )
      )   
    .     
 sd  applyBranch1Alpha(fam (cn[blist]), QPL) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyBranch1Alpha(fam (cn[blist]), QPL)}
    : (
       (CASE-DISTINCTION-one-R[fns:ChannelName <- cn]
         {matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[blist])), 
                                    P1:Protocol <- keepOne P (fam (cn[blist]))]{
                       CONG-FAMILY-R { alphaNFOverList(QPL)}
                     }
         , 
          idle
         }
       )
      
      )   
    .     

  
 *** do an alpha-renaming on the otherwise branch of a family
 strat applyBranch2Alpha : CNameBound QidPairList @ ProtocolConfig .
 sd applyBranch2Alpha(fam (ns1[blist]), QPL) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyBranch2Alpha(fam (ns1[blist]), QPL)}
    : 
       CASE-DISTINCTION-one-R[fns:ChannelName <- ns1]
         {  idle,
            CASE-DISTINCTION-one-R-end
                    [fns:ChannelName <- ns1
                    ]
                  {
                     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (ns1[blist])), 
                                    P1:Protocol <- keepOne P (fam (ns1[blist]))]{
                       CONG-FAMILY-R { alphaNFOverList(QPL)}
                     }       
                  }
         } 
         . 
         
  *** if a channel has same reaction on all branch, remove the branching
  strat applyAllSameCases : CNameBound @ ProtocolConfig .
  sd applyAllSameCases(cnb) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAllSameCases(cnb)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
        using
        (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P cnb, 
                         P1:Protocol <- keepOne P cnb]{
                   all-same-cases or-else all-same-cases-family
         }
         or-else 
         (all-same-cases or-else all-same-cases-family)
        )
     .    
         
  *** substrategy and helpers
   sort QidPair .
 op <<_,_>> : Qid Qid -> QidPair [ctor] .
 op getFst : QidPair -> Qid .
 op getSnd : QidPair -> Qid .
 eq getFst(<< q1, q2 >>) = q1 .
 eq getSnd(<< q1, q2 >>) = q2 .
 
 sort QidPairList .
 subsort QidPair < QidPairList .
 op emptyQidPairList : -> QidPairList [ctor] .
 op __ : QidPair QidPairList -> QidPairList [ctor] . 
 
 var QPL : QidPairList .
 var QP : QidPair .
 
 strat alphaNFOverList : QidPairList @ ReactionConfig .
 sd alphaNFOverList(emptyQidPairList) := idle .
 sd alphaNFOverList(QP QPL) := 
     alpha-nf [vx:Qid <- getFst(QP), vy:Qid <- getSnd(QP)] 
   ; alphaNFOverList(QPL) 
 .   
 
 *** apply bind2R-pre in a newNF protocol
  strat moveBindInPre : ChannelName Qid @ ProtocolConfig .
 sd moveBindInPre(C, Q) :=      
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveBindInPre(C, Q)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn C), 
                             P1:Protocol <- keepOne P (chn C)]
             {CONG-REACT[o:ChannelName <- C]{bind2R-pre[x:Qid <- Q] 
               or-else bind2R-nf[x:Qid <- Q] }}
             or-else
             CONG-REACT[o:ChannelName <- C]{bind2R-pre[x:Qid <- Q] 
              or-else bind2R-nf[x:Qid <- Q] }
              
             )
    .  
 
 *** move reads from bind list of a normal form to the reaction of the normal form
 ***     on the left branch of a family
  strat applyBranch2MoveReads : CNameBound List{NatTerm} @ ProtocolConfig .
 sd applyBranch2MoveReads(fam (ns1[blist]), QL) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyBranch2MoveReads(fam (ns1[blist]), QL)}
    :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using  
       CASE-DISTINCTION-one-R[fns:ChannelName <- ns1, 
                              P:Protocol <- removeOne P (fam (ns1[blist]))]
         {   moveReadsToRFamily(fam (ns1[blist]), QL)
           , idle
         } .
         
  *** move reads from bind list of a normal form to the reaction of the normal form
 strat moveReadsToRFamily : CNameBound List{NatTerm} @ ProtocolConfig .
 sd moveReadsToRFamily(fam (C[blist]), nil) := idle .
 sd moveReadsToRFamily(fam (C[blist]), x1 QL) := 
   match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveReadsToRFamily(fam (C[blist]), x1 QL)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (C[blist])), 
                             P1:Protocol <- keepOne P (fam (C[blist]))]{
                              moveReadInnerNfFamily[x:ChannelName <- x1]
                              or-else
                              moveReadInnerPreNfFamily[x:ChannelName <- x1] 
                             }
               or-else  (moveReadInnerNfFamily[x:ChannelName <- x1]
                              or-else
                              moveReadInnerPreNfFamily[x:ChannelName <- x1] )             
             )
             ; moveReadsToRFamily(fam (C[blist]), QL)                
 .               
  
    
 ***  changes the order in a normal form, on the left branch of a protocol
 strat applyReorderNF : CNameBound List{NatTerm} @ ProtocolConfig .
 sd applyReorderNF(fam (C[blist]), QL) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReorderNF(fam (C[blist]), QL)} 
     : CASE-DISTINCTION-one-R[fns:ChannelName <- C]
       { matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
          using  (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (C[blist])), 
                                 P1:Protocol <- keepOne P (fam (C[blist]))]
                  {CONG-FAMILY-R[fns:ChannelName <- C]{change-order[QL':List{NatTerm} <- QL]}}
                   or-else
                  CONG-FAMILY-R[fns:ChannelName <- C]{change-order[QL':List{NatTerm} <- QL]}
                  )
                  ,
         idle 
       }  
 . 
 
 *** alpha renaming
 strat applyAlphaNFPr : CNameBound QidPairList @ ProtocolConfig .
 sd applyAlphaNFPr(chn C, QPL) :=
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAlphaNFPr(chn C, QPL) } 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn C), 
                             P1:Protocol <- keepOne P (chn C)]
             {CONG-REACT[o:ChannelName <- C]{alphaNFOverList(QPL)}
             } 
             or-else
             CONG-REACT[o:ChannelName <- C]{alphaNFOverList(QPL)}
             )
  .   
 sd applyAlphaNFPr(fam (C[blist]), QPL) :=                                 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAlphaNFPr(fam (C[blist]), QPL) } 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (C[blist])), 
                             P1:Protocol <- keepOne P (fam (C[blist]))]
             {CONG-REACT-family[fns:ChannelName <- C]{alphaNFOverList(QPL)} 
             } 
             or-else
             CONG-REACT-family[fns:ChannelName <- C]{alphaNFOverList(QPL)}             
             )
  .  
 
 *****************************
 *** read-inside-if
 *****************************
    
 *** apply read-inside-if in a newNF protocol 
 strat applyReadInsideIfPre : ChannelName @ ProtocolConfig .
 sd applyReadInsideIfPre(C) :=      
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReadInsideIfPre(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn C), 
                             P1:Protocol <- keepOne P (chn C)]
       {CONG-REACT[o:ChannelName <- C]
        {cong-pre-nf{read-inside-if
                    } 
        }
       }
       or-else
       CONG-REACT[o:ChannelName <- C]
        {cong-pre-nf{read-inside-if
                    } 
        }
       )
    . 
    
    *******************************
    *** congruence for cases
    *******************************
    
    strat applyCongCases : ChannelName BoolTerm @ ProtocolConfig .
    sd applyCongCases(cn, bt) := 
        match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCongCases(cn, bt)} 
     : cong-cases-reaction[cn:ChannelName <- cn, bt:BoolTerm <- bt]{
         idle *** the real reaction goes here, for now just a pattern
       }
    .
    
********************
*** subst with cases
********************
 var cn1 cn2 : ChannelName .

 strat applySubstFamilyCase : CNameBound CNameBound Qid Reaction @ ProtocolConfig .
 sd applySubstFamilyCase(fam (ns1[bdlist1]), fam (ns2[bdlist2]), ind, R) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstFamilyCase(fam (ns1[bdlist1]), fam (ns2[bdlist2]), ind, R)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
        P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]
              {subst-family-case[R':Reaction <- R]{ *** TODO: I need two reactions here???
                substNFFamilyOne(fam (ns1[bdlist1]), ns2[ind], R)
               }
              }
              )
              or-else 
              subst-family-case[R':Reaction <- R]{
                substNFFamilyOne(fam (ns1[bdlist1]), ns2[ind], R)
               }
             ) .
             
 strat applySubstFamilyCase2 : CNameBound CNameBound Qid Reaction Reaction @ ProtocolConfig .
 sd applySubstFamilyCase2(fam (ns1[bdlist1]), fam (ns2[bdlist2]), ind, R1, R2) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstFamilyCase2(fam (ns1[bdlist1]), fam (ns2[bdlist2]), ind, R1, R2)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
        P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]
              {subst-family-case[R':Reaction <- R2]{ *** TODO: I need two reactions here???
                substNFFamilyOne(fam (ns1[bdlist1]), ns2[ind], R1)
               }
              }
              )
              or-else 
              subst-family-case[R':Reaction <- R2]{
                substNFFamilyOne(fam (ns1[bdlist1]), ns2[ind], R1)
               }
             ) .  
             
 strat applySubstFamilyCase3 : CNameBound CNameBound  Qid  
                               Reaction Reaction BoolTerm @ ProtocolConfig .
 sd applySubstFamilyCase3(fam (ns1[bdlist1]), fam (ns2[bdlist2]), ind, R1, R2, bt) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{
      applySubstFamilyCase3(fam (ns1[bdlist1]), fam (ns2[bdlist2]), ind, R1, R2, bt)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
        P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]
              {subst-family-case[R':Reaction <- R2, bt:BoolTerm <- bt]{ 
                 substNFFamilyOne(fam (ns1[bdlist1]), ns2[ind], R1)
               }
              }
              )
              or-else 
              subst-family-case[R':Reaction <- R2, bt:BoolTerm <- bt]{
                substNFFamilyOne(fam (ns1[bdlist1]), ns2[ind], R1)
               }
             ) . 
 
 var i1 i2 i3 : Qid .           
             
 strat applySubstFamily3IdxCase : CNameBound CNameBound Qid Qid Qid 
                               Reaction Reaction BoolTerm @ ProtocolConfig .
 sd applySubstFamily3IdxCase(fam (ns1[bdlist1]), fam (ns2[bdlist2]), i1, i2, i3, R1, R2, bt) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{
      applySubstFamily3IdxCase(fam (ns1[bdlist1]), fam (ns2[bdlist2]), i1, i2, i3, R1, R2, bt)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
        P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]
              {subst-family-case-generic[R':Reaction <- R2, bt:BoolTerm <- bt]{ 
                 substNFFamiliesThree(fam (ns1[bdlist1]), fam(ns2[bdlist2]), R1)
               }
              }
              )
              or-else 
              subst-family-case-generic[R':Reaction <- R2, bt:BoolTerm <- bt]{
                substNFFamiliesThree(fam (ns1[bdlist1]), fam(ns2[bdlist2]), R1)
               }
             ) .                
             
 strat applySubstChannelCase3 : CNameBound ChannelName  
                               Reaction Reaction BoolTerm @ ProtocolConfig .
 sd applySubstChannelCase3(fam (ns1[bdlist1]), cn2, R1, R2, bt) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstChannelCase3(fam (ns1[bdlist1]), cn2, R1, R2, bt)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (chn cn2), 
        P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (chn cn2)]
              {subst-channel-case[R':Reaction <- R2, bt:BoolTerm <- bt]{ 
                 substNFFamilyOne(fam (ns1[bdlist1]), cn2, R1)
               }
              }
              )
              or-else 
              subst-channel-case[R':Reaction <- R2, bt:BoolTerm <- bt]{
                substNFFamilyOne(fam (ns1[bdlist1]), cn2, R1)
               }
             ) .                                            


*** when we diverge on the otherwise branch

 var ind : Qid .
 
 var nns1 nns2 : NameWithScripts .

 strat applyCasesSubstDivergeOwise : 
   CNameBound CNameBound Qid Type Qid @ ProtocolConfig .
 sd applyCasesSubstDivergeOwise(fam (ns1[bdlist1]), fam (ns2[bdlist2]), ind, T, x) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{
      applyCasesSubstDivergeOwise(fam (ns1[bdlist1]), fam (ns2[bdlist2]), ind, T, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
        P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]
              { 
                cases-subst[fns1:NameWithScripts <- ns2, fns2:NameWithScripts <- ns1]{
                  substNF(ns1[ind], ns2[ind]), 
                  ***idle,
                  cases-subst-end-otherwise{ 
                   subst-diverge[T2:Type <- T, x3:ChannelName <- x]
                  }
                  
                } 
              }               
             )                
 .
 
 strat applyCasesSubstChannelDivergeOwise : ChannelName ChannelName Type Qid @ ProtocolConfig .
 sd applyCasesSubstChannelDivergeOwise(cn1, cn2, T, x) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCasesSubstChannelDivergeOwise(cn1, cn2, T, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
              (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (chn cn1) (chn cn2), 
                             P1:Protocol <- keepTwo P (chn cn1) (chn cn2)]
              {
                channel-cases-subst[cn1:ChannelName <- cn1, cn2:ChannelName <- cn2]{
                  substNF(cn2, cn1), 
                  channel-cases-subst-end-otherwise{ 
                   subst-diverge[T2:Type <- T, x3:Qid <- x]
                  }
                } 
              }               
             )
             or-else
              (channel-cases-subst[cn1:ChannelName <- cn1, cn2:ChannelName <- cn2]{
                  substNF(cn2, cn1), 
                  channel-cases-subst-end-otherwise{ 
                   subst-diverge[T2:Type <- T, x3:Qid <- x]
                  }
                } )
              )                 
 .
 
  strat applyCasesSubsumeDropDivergeOwise : 
    Qid Qid List{NatTerm} Qid Type Qid @ ProtocolConfig .
  sd applyCasesSubsumeDropDivergeOwise(C1, C2, QL, ind, T, x) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCasesSubsumeDropDivergeOwise(C1, C2, QL, ind, T, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (chn C1) (chn C2), 
                             P1:Protocol <- keepTwo P (chn C1) (chn C2)]
              {
                channel-cases-subst[C:Qid <- C2, aQid:Qid <- C1]{
                     applySubsumeRevChannelsList(C1[ind], C2[ind], QL)
                   ; applyDropNFChannels(C1[ind], C2[ind])
                   , 
                  cases-subst-end-otherwise{ 
                    subst-diverge[T2:Type <- T, x3:Qid <- x] ***TODO: do we need x3?
                  }
                } 
              }               
             )                
 .
 
 strat applySubstDivergeFamily : CNameBound CNameBound Qid Type @ ProtocolConfig .
 sd applySubstDivergeFamily(fam (ns1[bdlist1]), fam (ns2[bdlist2]), x, T) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstDivergeFamily(fam (ns1[bdlist1]), fam (ns2[bdlist2]), x, T)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
             (CONG-COMP-RIGHT[
              Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
              P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]{
                 subst-diverge-family[x3:ChannelName <- x, T2:Type <- T]            
              }
             ) or-else subst-diverge-family[x3:ChannelName <- x, T2:Type <- T]
             )
 .
  
 strat applyDivergeChannel3FamilyBranch : 
    CNameBound CNameBound BoolTerm Qid Type @ ProtocolConfig .
 sd applyDivergeChannel3FamilyBranch(fam (ns1[bdlist1]), fam (ns2[bdlist2]), bt, x, T) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{
        applyDivergeChannel3FamilyBranch(fam (ns1[bdlist1]), fam (ns2[bdlist2]), bt, x, T)
       }
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
             (CONG-COMP-RIGHT[
         Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
         P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) fam (ns2[bdlist2])]
              {subst-family-case-three[bt:BoolTerm <- bt]{
                subst-diverge-family[x3:ChannelName <- x, T2:Type <- T]
               }
              })
              or-else
              subst-family-case-three[bt:BoolTerm <- bt]{
                subst-diverge-family[x3:ChannelName <- x, T2:Type <- T]
               }
             )
     .
     
  strat applyCasesSubsumeDropDivergeOwiseC : 
            CNameBound ChannelName List{NatTerm} Type Qid @ ProtocolConfig .
  sd applyCasesSubsumeDropDivergeOwiseC(fam (ns1[bdlist1]), ns2[nt], QL, T, x) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCasesSubsumeDropDivergeOwiseC(fam (ns1[bdlist1]), ns2[nt], QL, T, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
             (CONG-COMP-RIGHT[
              Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (chn (ns2[nt])), 
              P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (chn (ns2[nt]))]
              {
                fc-cases-subst[cn:ChannelName <- ns2[nt], fns:ChannelName <- ns1]{
                     applySubsumeFamilyCasesChannelList(fam (ns1[bdlist1]), ns2[nt], QL)
                   ; applyDropNFCF(fam (ns1[bdlist1]), ns2[nt])
                   , 
                  fc-cases-subst-end-otherwise{ 
                    subst-diverge-family-channel[T2:Type <- T, x3:Qid <- x]
                  }
                } 
              }               
             )
             or-else
              (fc-cases-subst[cn:ChannelName <- ns2[nt], fns:ChannelName <- ns1]{
                     applySubsumeFamilyCasesChannelList(fam (ns1[bdlist1]), ns2[nt], QL)
                   ; applyDropNFCF(fam (ns1[bdlist1]), ns2[nt])
                   , 
                  fc-cases-subst-end-otherwise{ 
                    subst-diverge-family-channel[T2:Type <- T, x3:Qid <- x]
                  }
                } 
              )  
            )   
             
 .                                      
         
  strat applyCasesSubstFC : 
              CNameBound ChannelName Reaction Type Qid @ ProtocolConfig .
  sd applyCasesSubstFC(fam (ns1[bdlist1]), ns2[nt], R, T, x) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCasesSubstFC(fam (ns1[bdlist1]), ns2[nt], R, T, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
             (CONG-COMP-RIGHT[
              Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (chn (ns2[nt])), 
              P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (chn (ns2[nt])) ]
              {
                fc-cases-subst[cn:ChannelName <- ns2[nt], fns:ChannelName <- ns1]{
                     substNFFamilyOne(fam (ns1[bdlist1]), ns2[nt], R)
                   , 
                  fc-cases-subst-end-otherwise{ 
                    subst-diverge-family-channel[T2:Type <- T, x3:Qid <- x]
                  }
                } 
              }               
             )
             or-else
              (fc-cases-subst[cn:ChannelName <- ns2[nt], fns:ChannelName <- ns1]{
                     substNFFamilyOne(fam (ns1[bdlist1]), ns2[nt], R)
                   , 
                  fc-cases-subst-end-otherwise{ 
                    subst-diverge-family-channel[T2:Type <- T, x3:Qid <- x]
                  }
                }
              )  
            )   
             
 .  
 
 *** same cases and only do the substitution on first branch
 *** TODO: can be generalized to try to do on every branch?
 strat applySameCasesSubstFirstBranch : CNameBound CNameBound Qid @ ProtocolConfig .
 sd applySameCasesSubstFirstBranch(fam (ns1[bdlist1]), fam (ns2[bdlist2]), ind) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySameCasesSubstFirstBranch(fam (ns1[bdlist1]), fam (ns2[bdlist2]), ind)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
        P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]
              {
                same-cases-subst{
                  substNF(ns1[ind], ns2[ind]), 
                  idle
                }
              }               
             )                
 .  
 
 strat applyGenSameCasesSubstFirstBranch : 
       CNameBound CNameBound Reaction @ ProtocolConfig .
 sd applyGenSameCasesSubstFirstBranch(fam (ns1[bdlist1]), fam (ns2[bdlist2]), R) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyGenSameCasesSubstFirstBranch(fam (ns1[bdlist1]), fam (ns2[bdlist2]), R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
               Q:Protocol  <- removeTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2])), 
               P1:Protocol <- keepTwo P (fam (ns1[bdlist1])) (fam (ns2[bdlist2]))]
              {
                gen-same-cases-subst{
                   substNFFamiliesThree(fam (ns1[bdlist1]), fam (ns2[bdlist2]), R),
                  *** substNF(ns1[ind], ns2[ind]), 
                  idle
                }
              }               
             )                
 .  
 
 strat applySameCasesSubstFC : CNameBound ChannelName NatTerm @ ProtocolConfig .     
 sd applySameCasesSubstFC(fam (ns[blist]), cn, ind) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySameCasesSubstFC(fam (ns[blist]), cn, ind)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (fam (ns[blist])) (chn cn), 
                             P1:Protocol <- keepTwo P (fam (ns[blist])) (chn cn)]
              { fc-same-cases-subst-end-otherwise{
                  substNF(ns[ind], cn)
                }
                or-else
                fc-same-cases-subst-end-when{
                  substNF(ns[ind], cn)
                }
                or-else
                fc-same-cases-subst{
                  substNF(ns[ind], cn), 
                  applySameCasesSubstFC(fam (ns[blist]), cn, ind)
                }
              }               
             ) 
 . 
 
 *** if we can deduce the condition of a branch in a channel
 *** use that to do the substitution
 
 strat applySelectCaseSubst : ChannelName ChannelName BoolTerm @ ProtocolConfig .
 sd applySelectCaseSubst(cn1, cn2, bt) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySelectCaseSubst(cn1, cn2, bt)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P (chn cn1) (chn cn2), 
                             P1:Protocol <- keepTwo P (chn cn1) (chn cn2)]
              {select-case-subst[bt:BoolTerm <- bt]{substNF(cn1, cn2)}
              }
             ) or-else
                (select-case-subst[bt:BoolTerm <- bt]{substNF(cn1, cn2)})
             ) 
 .
 
 *** if we can deduce the condition of a branch in a family
 *** use that to do subst-diverge
 strat applySelectCaseDiverge : CNameBound CNameBound BoolTerm Qid Type @ ProtocolConfig .
 sd applySelectCaseDiverge(fam (cn1[bdlist1]), fam (cn2[bdlist2]), bt, x, T) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySelectCaseDiverge(fam (cn1[bdlist1]), fam (cn2[bdlist2]), bt, x, T)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ((CONG-COMP-RIGHT[
                 Q:Protocol  <- removeTwo P (fam (cn1[bdlist1])) (fam (cn2[bdlist2])), 
                 P1:Protocol <- keepTwo P (fam (cn1[bdlist1])) (fam (cn2[bdlist2]))]
              {select-case-subst-family[bt:BoolTerm <- bt]{
                subst-diverge-family[x3:ChannelName <- x, T2:Type <- T]
                }
              }
             ) or-else
                (select-case-subst-family[bt:BoolTerm <- bt]{
                   subst-diverge-family[x3:ChannelName <- x, T2:Type <- T] })
             ) 
 .
 


 
 *** apply subst on every branch using cases-subst
 *** we assume it ends with when
 *** TODO: also try otherwise before recursion
 
 strat applyCasesSubst : CNameBound CNameBound Qid @ ProtocolConfig .
 sd applyCasesSubst(cnb1, cnb2, ind) := 
   match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCasesSubst(cnb1, cnb2, ind)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P cnb1 cnb2, 
                             P1:Protocol <- keepTwo P cnb1 cnb2]{
                             applyCasesSubstRec(cnb1, cnb2, ind)}
              or-else
              applyCasesSubstRec(cnb1, cnb2, ind))
 .
 
 *** this is a helper for the strategy above! 
 strat applyCasesSubstRec : CNameBound CNameBound Qid @ ProtocolConfig .
 sd applyCasesSubstRec(fam (C1[bdlist1]), fam (C2[bdlist2]), ind) :=         
    *** first try to apply the end case for when
    cases-subst-end-when[aQid:Qid <- C1, C:Qid <- C2]{substNF(C1[ind], C2[ind])}
    *** TODO: we need R2 as argument above
    or-else
    cases-subst-end-otherwise{substNF(C1[ind], C2[ind])}
    or-else *** TODO: we might want to try diverge in both subproofs above!
     cases-subst{
                  substNF(C1[ind], C2[ind]), *** subst on first branch
                  applyCasesSubstRec(fam (C1[bdlist1]), fam (C2[bdlist2]), ind) 
                   *** recursive call for the rest
                }  
 .      
 
 ******************************************
 *** helpers
 ******************************************
 
  *** checks that the protocol in a aConfig starts with new/newfamily or is in new normal form
 op aConfStartsWithNew_ : ApproxEqConfig -> Bool .
 eq aConfStartsWithNew aConfig(S, D, P, I, O, A, width w, length l) =
    startsWithNew pConfig(S, D, P, I, O, A) .
 
 *** checks that the protocol in a pConfig starts with new/newfamily or is in new normal form     
 op startsWithNew_ : ProtocolConfig -> Bool .
 eq startsWithNew pConfig(S, D, emptyProtocol, I, O, A) = false .
 eq startsWithNew pConfig(S, D, P1 || P2, I, O, A) = false .
 eq startsWithNew pConfig(S, D, C ::= R, I, O, A) = false .
 eq startsWithNew pConfig(S, D, new Q : T in P, I, O, A) = true .
 eq startsWithNew pConfig(S, D, newNF(ltq, P, ql), I, O, A) = true .
 eq startsWithNew pConfig(S, D, family (fns[blist]) nlist blist ::= P, I, O, A) = false .
 
endsm

***(

smod UNUSED-STRATS is 
  pr STRATS .
 *** vars
  
 var pConf : ProtocolConfig .
 var rConf : ReactionConfig .
 var S Sigma : Signature .
 var D Delta : ChannelContext .
 var G : TypeContext .
 var P P1 P2 : Protocol .
 var R R1 R2 R3 R4 : Reaction .
 *** var Q Q' C Q1 Q2 x1 x2 y x : Qid .
 var I O : Set{CNameBound} .
 var T T' T1 : Type .
 var flag : Bool .
 var M M1 M2 : Expression .
 var Dis : Distribution .
 var C C1 C2 : ChannelName .
 var Q Q' x1 : Qid .
 var A : Set{BoolTerm} .
 var N w l : Nat .
 var nlist : List{NatTerm} .
 var blist : List{Bounds} .
 var ql : List{NatTerm} .                
 var X : ChannelName . 
 var BRL : BRList . 
 var ltq : TypedList{NatTerm} .
 var ql' : List{NatTerm} .  
 
 *** helpers

 *** older method, should go away
 op isLastNew___ : ProtocolConfig Qid Bool -> Bool .

 eq isLastNew pConfig(S, D, emptyProtocol, I, O, A) Q flag = not flag .
 eq isLastNew pConfig(S, D, P1 || P2, I, O, A) Q flag = not flag .
 eq isLastNew pConfig(S, D, C ::= R, I, O, A) Q flag = not flag .
 eq isLastNew pConfig(S, D, new Q : T in P, I, O, A) Q false = false .
 eq isLastNew pConfig(S, D, new Q : T in P, I, O, A) Q true = 
    isLastNew pConfig(S, D, P, I, O, A) Q false .
 ceq isLastNew pConfig(S, D, new Q' : T in P, I, O, A) Q true = 
     isLastNew pConfig(S, D, P, I, O, A) Q true if Q =/= Q' .
 ceq isLastNew pConfig(S, D, new Q' : T in P, I, O, A) Q false = 
     false if Q =/= Q' .    

 op foundQ__  : ProtocolConfig Qid -> Bool .
 eq foundQ pConfig(S, D, emptyProtocol, I, O, A) Q = false .
 eq foundQ pConfig(S, D, P1 || P2, I, O, A) Q = false .
 eq foundQ pConfig(S, D, C ::= R, I, O, A) Q = false .
 eq foundQ pConfig(S, D, new Q : T in P, I, O, A) Q = true .
 ceq foundQ pConfig(S, D, new Q' : T in P, I, O, A) Q = false if Q' =/= Q . 
 

  strat alphaOverList : QidPairList @ ReactionConfig .
 sd alphaOverList(emptyQidPairList) := idle .
 sd alphaOverList(QP QL) := alpha [x:Qid <- getFst(QP), y:Qid <- getSnd(QP)] ; 
                            cong-bind{idle, alphaOverList(QL)} .     
     
 strat applyAlphaPr : ChannelName QidPairList @ ProtocolConfig .
 sd applyAlphaPr(C, QL) :=                                 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAlphaPr(C, QL) } 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
              CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{alphaOverList(QL)}}
             or-else
             CONG-REACT[o:ChannelName <- C]{alphaOverList(QL)
             ) . 
 

 *** checks that a certain channel is the first in a new/newfamily/newnf
 op startsWithNewC__ : ProtocolConfig ChannelName -> Bool .
 eq startsWithNewC pConfig(S, D, emptyProtocol, I, O, A) C = false .
 eq startsWithNewC pConfig(S, D, P1 || P2, I, O, A) C = false .
 eq startsWithNewC pConfig(S, D, C ::= R, I, O, A) C = false .
 eq startsWithNewC pConfig(S, D, new Q : T in P, I, O, A) C = (Q == C) .
 eq startsWithNewC pConfig(S, D, newNF(ltq, P, Q :: ql), I, O, A) C = (Q == C) .
 
 op startsWithBind : Reaction -> Bool .
 eq startsWithBind(return M) = false .
 eq startsWithBind(samp Dis) = false .
 eq startsWithBind(read M) = false .
 eq startsWithBind(if M then R1 else R2) = false .
 eq startsWithBind(Q : T <- R1 ; R2) = true .
 
 op startsWithBindRead : Reaction -> Bool .
 eq startsWithBindRead(Q : T <- read M ; R2) = true .
 eq startsWithBindRead(R) = false [owise] .
 
 op startsWithIfRead : ReactionConfig -> Bool .
 eq startsWithIfRead(rConfig(S, D, G, if M then x1 : T1 <- R1 ; R2 else 
                                                x1 : T1 <- R1 ; R3, I, A, T)) = true . 
 eq startsWithIfRead(rConfig(S, D, G, R, I, A, T)) = false [owise] .
 
 op rBindRead : ReactionConfig -> Bool .
 eq rBindRead(rConfig(S, D, G, R, I, A, T)) = startsWithBindRead(R) .
 
 op firstBind : ReactionConfig -> Qid .
 eq firstBind(rConfig(S, D, G, Q : T <- R1 ; R2, I, A, T')) = Q .
 
 op rBind : ReactionConfig -> Bool .
 eq rBind(rConfig(S, D, G, R, I, A, T)) = startsWithBind(R) .
 
 *** strategies
 
 *** old, we needed it before normal forms
 strat moveToLast : Qid @ ProtocolConfig . 
 sd moveToLast(Q) := match pConf s.t. (foundQ pConf Q) 
                       ? (match pConf s.t. (isLastNew pConf Q true) 
                         ? idle 
                         : (NEW-EXCH ; CONG-NEW-NF{moveToLast(Q)})) 
                       : CONG-NEW-NF{moveToLast(Q)} .
                       
 *** old                       
 strat nTimesCong : ChannelName @ ProtocolConfig .
 sd nTimesCong(C) := 
      match pConf s.t. startsWithNewC pConf C
      ? COMP-NEW-2 ; ABSORB-RIGHT 
      : CONG-NEW-NF{nTimesCong(C)} .
 
 *** apply bind-ret-2 inside C
 *** if the current P is newNF(..., C ::= R || Q  ,...)
 strat nTimesBindRet2 : ChannelName @ ProtocolConfig .
 sd nTimesBindRet2(C) := 
  match pConf s.t. startsWithNew pConf
  ? CONG-NEW-NF{nTimesBindRet2(C)}
  : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{bind-ret-2[x:Qid <- 'x]}} .
 
 *** old
 *** apply SUBST with the sub-proof read-det
 *** if the current P is newNF(..., P  ,...)
 strat nTimesSubst @ ProtocolConfig .
 sd nTimesSubst := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{nTimesSubst}
    : CONG-COMP-RIGHT{(SUBST [x2:Qid <- 'x2]{read-det})} . 
 
 *** apply bind-ret inside C
 *** if the current P is newNF(..., C ::= R || Q  ,...)   
 *** old
 strat nTimesBindRet @ ProtocolConfig .
 sd nTimesBindRet := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{nTimesBindRet} 
    : CONG-COMP-RIGHT{CONG-REACT{bind-ret}} .
 
 strat liftInnerBinds @ ReactionConfig .
 sd liftInnerBinds := bind-bind ? cong-bind{idle, liftInnerBinds} : idle .
 
 strat liftAllInnerBinds @ ReactionConfig .
 sd liftAllInnerBinds := 
      match rConf s.t. rBind(rConf) 
       ? (liftInnerBinds ; cong-bind{idle, liftAllInnerBinds})
       : idle .  
 
 *** low-level strategy
 strat liftInnerBindsPr : ChannelName @ ProtocolConfig .
 sd liftInnerBindsPr(C) := 
  match pConf s.t. startsWithNew pConf 
  ? CONG-NEW-NF{liftInnerBindsPr(C)}
  : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{liftAllInnerBinds}} .

 *** old, before normal forms
 strat moveBindToLast @ ReactionConfig .
 sd moveBindToLast := exchange ? cong-bind{idle, moveBindToLast} : idle . 
 
 *** old, before normal forms
 strat moveCertainBindToLast : Qid @ ReactionConfig .
 sd moveCertainBindToLast(Q) :=
    match rConf s.t. Q =/= firstBind(rConf)
    ? cong-bind{idle, moveCertainBindToLast(Q)}
    : moveBindToLast . 
 
 *** old, before normal forms 
 strat moveBindToFirst : Qid @ ReactionConfig .
 sd moveBindToFirst(Q) := 
   match rConf s.t. Q =/= firstBind(rConf)
     ? moveBindToLast ; moveBindToFirst(Q)
     : idle .
  
 *** old, before normal forms    
 strat moveBindProtocol : Qid ChannelName @ ProtocolConfig .
 sd moveBindProtocol(Q, C) := CONG-REACT[o:ChannelName <- C]{moveBindToFirst(Q)} . 
 
 *** old, before normal forms
 strat moveCertainBindLastProtocol : Qid ChannelName @ ProtocolConfig .
 sd moveCertainBindLastProtocol(Q, C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveCertainBindLastProtocol(Q, C)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveCertainBindToLast(Q)}} .   

 *** old, before normal forms
 strat moveFirst : Qid ChannelName @ ProtocolConfig .
 sd moveFirst(Q, C) := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveBindToFirst(Q)}} .
 
 *** old, before normal forms       
 strat nTimesMoveFirst : Qid ChannelName @ ProtocolConfig .
 sd nTimesMoveFirst(Q, C) := 
   match pConf s.t. startsWithNew pConf
   ? CONG-NEW-NF{nTimesMoveFirst(Q, C)}
   : moveFirst(Q, C) .
                   
 strat removeDuplicateReadsNF : ChannelName @ ProtocolConfig .
 sd removeDuplicateReadsNF(C1) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{removeDuplicateReadsNF(C1)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C1, 
                        P1:Protocol <- keepOne P C1]{
         CONG-REACT[o:ChannelName <- C1]{read-det-pre !}
       } . 

 
 strat substAll : ChannelName @ ProtocolConfig .
 sd substAll(C) := substNFOne(C) ! .
 
 strat substAllAndAbsorb : ChannelName @ ProtocolConfig .
 sd substAllAndAbsorb(C) := substAll(C) ; absorbChannel(C) .
      
 strat substNFOne : ChannelName @ ProtocolConfig .
 sd substNFOne(C1) := 
     matchrew pConf 
         s.t. pConfig(Sigma, Delta,   
                      newNF(ltq,
                             P || (C1 ::= R1) || 
                                  (C2 ::= nf( (x1 : T1 <- read C1) BRL , R2, ql
                                            )
                                  ),
                       ql'), I, O, A) := pConf 
         by pConf 
       using substNF(C1, C2)
 .         
       
 var Q1 Q2 : Qid .
   
 var cnl : List{NatTerm} .
 
 strat moveReadsToR : ChannelName List{NatTerm} @ ProtocolConfig .
 sd moveReadsToR(C, nil) := idle .
 sd moveReadsToR(C, x cnl) := 
   match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveReadsToR(C, x :: cnl)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]{
                              moveReadInnerNf[x:ChannelName <- x]
                              or-else
                              moveReadInnerPreNf[x:ChannelName <- x] 
                             }
             ; moveReadsToR(C, cnl)                
 .
 
 strat applySubstNfRev : ChannelName ChannelName Qid @ ProtocolConfig .
 sd applySubstNfRev(C1, C2, x) := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstNfRev(C1, C2, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{                  
                   SUBST-nf-rev[x:ChannelName <- x]}
 .
 
 strat applySubstNfRevFamily : ChannelName ChannelName Qid @ ProtocolConfig .
 sd applySubstNfRevFamily(C1, C2, x) := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstNfRevFamily(C1, C2, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{                  
                   SUBST-nf-rev[x:ChannelName <- x]}
 .
 
 strat nTimesSubstSampFree : ChannelName ChannelName @ ProtocolConfig .
 sd nTimesSubstSampFree(C1, C2) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstSampFree(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]
                             {SUBST[x2:Qid <- 'x2, 
                             o1:ChannelName <- C1, 
                             o2:ChannelName <- C2]{samp-free}} .
     
 strat nTimesSubst2SampFree : ChannelName ChannelName @ ProtocolConfig .
 sd nTimesSubst2SampFree(C1, C2) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubst2SampFree(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]
                             {SUBST-2[x2:Qid <- 'x2, 
                               o1:ChannelName <- C1, 
                               o2:ChannelName <- C2]{samp-free}} .   
                               
     
 strat ifOverBindAfterBinds @ ReactionConfig .
 sd ifOverBindAfterBinds :=  
     match rConf s.t. rBindRead(rConf) 
      ? cong-bind{idle, ifOverBindAfterBinds}
      : if-over-bind .  
 
 strat nTimesIfOverBind : ChannelName @ ProtocolConfig .
 sd nTimesIfOverBind(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesIfOverBind(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifOverBindAfterBinds}} .
     
 strat ifOverBindInBranch @ ReactionConfig .  
 sd ifOverBindInBranch :=  
     match rConf s.t. rBindRead(rConf) 
      ? cong-bind{idle, ifOverBindInBranch}
      : cong-branch-refl{if-over-bind, if-over-bind} . 
      
 strat ifOverBindInBranch2 @ ReactionConfig .  
 sd ifOverBindInBranch2 :=  
     match rConf s.t. rBindRead(rConf) 
      ? cong-bind{idle, ifOverBindInBranch2}
      : cong-branch-refl{ifOverBindInBranch, ifOverBindInBranch} . 
     
      
 strat ifLeftOverBind @ ReactionConfig .
 sd ifLeftOverBind := 
    match rConf s.t. rBind(rConf) 
    ? cong-bind{idle, ifLeftOverBind}
    : if-left .
    
 strat ifRightOverBind @ ReactionConfig .
 sd ifRightOverBind := 
    match rConf s.t. rBind(rConf) 
    ? cong-bind{idle, ifRightOverBind}
    : if-right .   
     
 strat nTimesIfOverBindBranch : ChannelName @ ProtocolConfig .
 sd nTimesIfOverBindBranch(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesIfOverBindBranch(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifOverBindInBranch}} .    
     
 strat nTimesIfOverBindBranch2 : ChannelName @ ProtocolConfig .
 sd nTimesIfOverBindBranch2(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesIfOverBindBranch2(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifOverBindInBranch2}} .    
     
 strat bindRetInBranchTwiceIOB @ ReactionConfig .
 sd bindRetInBranchTwiceIOB := 
    match rConf s.t. rBindRead(rConf)
    ? cong-bind{idle, bindRetInBranchTwiceIOB}
    : cong-branch-refl
        {cong-branch-refl{ret-bind ; ifRightOverBind, ret-bind ; ifLeftOverBind},
         cong-branch-refl{ret-bind ; ifLeftOverBind, ret-bind ; ifRightOverBind}} .
 
 strat bindRetInBranchTwice @ ReactionConfig .
 sd bindRetInBranchTwice := 
    match rConf s.t. rBindRead(rConf)
    ? cong-bind{idle, bindRetInBranchTwice}
    : cong-branch-refl
        {cong-branch-refl{ret-bind , ret-bind},
         cong-branch-refl{ret-bind , ret-bind}} .
         
 strat moveInsideIf : Qid ChannelName @ ProtocolConfig .
 sd moveInsideIf(Q, C) :=  *** first what var and then the channel
    moveCertainBindLastProtocol(Q, C) ;
    applyReadOverIf(Q, C) .
        
 strat applyReadOverInnerIf : Qid ChannelName @ ProtocolConfig .
 sd applyReadOverInnerIf(Q, C) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReadOverInnerIf(Q, C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]
              {moveLastBindInsideInnerIf(Q)}
             } .
 
 strat applyReadOverIf : Qid ChannelName @ ProtocolConfig .
 sd applyReadOverIf(Q, C) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReadOverIf(Q, C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveLastBindInsideIf(Q)}} .

 
 strat moveLastBindInsideIf : Qid @ ReactionConfig .
 sd moveLastBindInsideIf(Q) :=
    match rConf s.t. Q =/= firstBind(rConf)
    ? cong-bind{idle, moveLastBindInsideIf(Q)}
    : read-inside-if . 
    
 strat moveLastBindInsideInnerIf : Qid @ ReactionConfig .
 sd moveLastBindInsideInnerIf(Q) :=
    match rConf s.t. rBind(rConf)
    ? cong-bind{idle, moveLastBindInsideInnerIf(Q)}
    : cong-branch-refl{read-inside-if, read-inside-if} .   
           
         
 strat bindRetInBranch @ ReactionConfig .
 sd bindRetInBranch :=  
     match rConf s.t. rBindRead(rConf) *** TODO: allow any bind?
    ? cong-bind{idle, bindRetInBranch}
    : cong-branch-refl{ret-bind , ret-bind} . 
    
 strat nTimesBindRetBranch : ChannelName @ ProtocolConfig .
 sd nTimesBindRetBranch(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesBindRetBranch(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{bindRetInBranch}} . 
         
 
 strat nTimesBindRetBranchTwiceIOB : ChannelName @ ProtocolConfig .
 sd nTimesBindRetBranchTwiceIOB(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesBindRetBranchTwiceIOB(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{bindRetInBranchTwiceIOB}} . 
   
 strat nTimesBindRetBranchTwice : ChannelName @ ProtocolConfig .
 sd nTimesBindRetBranchTwice(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesBindRetBranchTwice(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{bindRetInBranchTwice}} . 
  
     
 strat moveAllBindsToFrontIf @ ReactionConfig .
 sd moveAllBindsToFrontIf :=
     match rConf s.t. rBind(rConf)
     ? cong-bind{idle, moveAllBindsToFrontIf}
     : match rConf s.t. startsWithIfRead(rConf) 
       ? if-over-read ; moveAllBindsToFrontIf
       : idle .
        
 strat moveAllBindsTwoIfs @ ReactionConfig .
 sd moveAllBindsTwoIfs := 
    match rConf s.t. rBind(rConf)
     ? cong-bind{idle, moveAllBindsTwoIfs}
     : cong-branch-refl{ moveAllBindsToFrontIf, moveAllBindsToFrontIf} .
    
 strat moveBinds : ChannelName @ ProtocolConfig .
 sd moveBinds(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveBinds(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveAllBindsTwoIfs}} . 

 strat moveBindsOne : ChannelName @ ProtocolConfig .
 sd moveBindsOne(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveBindsOne(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveAllBindsToFrontIf}} .
   
    
 op canApplyIfBindSame : Reaction -> Bool .
 eq canApplyIfBindSame(x1 : T1 <- if M then R1 else R2 ; if M then R3 else R4) = true .
 eq canApplyIfBindSame(R) = false [owise] .  
 

 op canApplyIfBindSameC : ReactionConfig -> Bool .
 eq canApplyIfBindSameC(rConfig(S, D, G, R, I, A, T)) = canApplyIfBindSame(R) .
 
 strat ifBindSame @ ReactionConfig .
 sd ifBindSame :=
  match rConf s.t. canApplyIfBindSameC(rConf) 
  ? if-over-bind-same
  : match rConf s.t. rBind(rConf)
     ? cong-bind{idle, ifBindSame}
     : idle .
     
 strat ifBindSame2 @ ReactionConfig .
 sd ifBindSame2 :=
  match rConf s.t. canApplyIfBindSameC(rConf) 
  ? if-over-bind-same-2
  : match rConf s.t. rBind(rConf)
     ? cong-bind{idle, ifBindSame2}
     : idle .    
     
 strat ifBindSamePr : ChannelName @ ProtocolConfig .
 sd ifBindSamePr(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{ifBindSamePr(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifBindSame}} .
    
 strat ifBindSame2Pr : ChannelName @ ProtocolConfig .
 sd ifBindSame2Pr(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{ifBindSame2Pr(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifBindSame2}} .
     
 strat recursiveReadDet @ ReactionConfig .
 sd recursiveReadDet := 
   match rConf s.t. rBindRead(rConf)
     ? (read-det
          ? recursiveReadDet
          : (exchange ? cong-bind{idle, recursiveReadDet} : idle)) 
     : idle . 
  
 strat recReadDet : ChannelName Nat @ ProtocolConfig .
 sd recReadDet(C, 0) := idle .
 sd recReadDet(C, s(N)) :=
     (match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{recReadDet(C, s(N))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{recursiveReadDet}}) ; recReadDet(C, N) .
    
 strat readOutsideIf2 : ChannelName @ ProtocolConfig .
 sd readOutsideIf2(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{readOutsideIf2(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]
                       {moveAllBindsTwoIfs ; moveAllBindsToFrontIf}} .
 
 strat sameReactionIfAfterBinds @ ReactionConfig .
 sd sameReactionIfAfterBinds := 
   match rConf s.t. rBindRead(rConf)
     ? cong-bind{idle, sameReactionIfAfterBinds} 
     : same-reaction-if .
 
 strat sameReactionIf : ChannelName @ ProtocolConfig .
 sd sameReactionIf(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{sameReactionIf(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{sameReactionIfAfterBinds}} .
     
 strat removeUnused : ChannelName ChannelName @ ProtocolConfig .
 sd removeUnused(C1, C2) := 
 match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{removeUnused(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]
             {UNUSED[o1:ChannelName <- C1, o2:ChannelName <- C2]{samp-pure}} .
            
 strat addNewChannel : Protocol @ ProtocolConfig .
 sd addNewChannel(P) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{addNewChannel(P)}
     : ABSORB-LEFT-2[P2:Protocol <- P] ; COMP-NEW .  
     
     
 var Msg1 Msg2 : Expression .    
      
 var q1 q2 : Qid .  

 var x : Qid .    
     
 strat retBind2OverIf : Type Expression Expression Reaction Qid @ ReactionConfig .
 sd retBind2OverIf(T, M1, M2 , R, x) := 
    match rConf s.t. rBind(rConf) 
    ? cong-bind{idle, retBind2OverIf(T, M1, M2, R, x) }
    : cong-branch-refl{
           ret-bind-2[M1:Expression <- M1 , T1:Type <- T, R2:Reaction <- R , x:Qid <- x],
           ret-bind-2[M1:Expression <- M2 , T1:Type <- T, R2:Reaction <- R , x:Qid <- x]} .
     
 strat applyRetBind2OverIf : ChannelName Type Expression Expression Reaction Qid @ ProtocolConfig .
 sd applyRetBind2OverIf(C, T, M1, M2, R, x) :=                                 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyRetBind2OverIf(C, T, M1, M2, R, x) } 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{retBind2OverIf(T, M1, M2, R, x)}} .
     
 strat symOverIf : Reaction Expression Expression @ ReactionConfig .
 sd symOverIf(R, Msg1, Msg2) :=
    sym[R1:Reaction <- R]
      {liftAllInnerBinds ; 
       ifOverBindAfterBinds ;
       bindRetInBranch ; idle
       *** applyCongRetBranch(Msg1, Msg2)
       } .   
       
 strat applySymOverIf : ChannelName Reaction Expression Expression @ ProtocolConfig .      
 sd applySymOverIf(C, R, Msg1, Msg2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySymOverIf(C, R, Msg1, Msg2) } 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{symOverIf(R, Msg1, Msg2)}} .
             
 *** strategies for families   
 
 var cases : Cases .
 var aP : Protocol .
 
 strat absorbReverseFamily : ChannelName Protocol @ ProtocolConfig .
 sd absorbReverseFamily(C, aP) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{absorbReverseFamily(C, aP)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             { 
              CONG-FAMILY-P{ 
                             ABSORB-LEFT-2[P2:Protocol <- aP]  
                           ; (try (comp-new-families))   
                           ; (try (COMP-NEW-newNF-newfamily)) 
                           }
             }
 .  
 
 strat absorbReverseNewNF : Protocol @ ProtocolConfig .
 sd absorbReverseNewNF(aP) :=
    ABSORB-LEFT-2[P2:Protocol <- aP] ;
    try (comp-new-families)
 . 
  
 var pr : Protocol . 
 var q3 : Qid .
 var nt : NatTerm . 
                       
 var q4 : Qid .
 
endsm
 
 )
