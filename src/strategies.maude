***( IPDL

  Copyright : (C) 2022-23, Kristina Sojakova
  License   : GNU General Public License v3.0 or later (GPL-3.0-or-later)
  Authors   : Mihai Codescu <mscodescu@gmail.com>
              Kristina Sojakova <sojakova.kristina@gmail.com>

 Strategies for applying the rules. They are grouped by the main rule that is applied,
 e.g. subst or absorb, and they may have several forms to be applied in different context
 e.g. channels, families, groups of families, cases.
 
)

in ../src/syntax

smod STRATS is
 pr APPROX-EQUALITY .
 
 *** vars
  
 var pConf : ProtocolConfig .
 var rConf : ReactionConfig .
 var S Sigma : Signature .
 var D Delta : ChannelContext .
 var G : TypeContext .
 var P P1 P2 pr : Protocol .
 var R R1 R2 R3 R4 : Reaction .
 *** var Q Q' C Q1 Q2 x1 x2 y x : Qid .
 var c' : Qid .        
 var I O : Set{CNameBound} .
 var T T' T1 : Type .
 var flag : Bool .
 var M M1 M2 : Expression .
 var Dis : Distribution .
 var C C1 C2 x : ChannelName .
 var Q Q' x1 Q1 Q2 q1 q2 q3 q4 : Qid .
 var A : Set{BoolTerm} .
 var N w l : Nat .
 var nlist : List{NatTerm} .
 var blist : List{Bounds} .
 var BRL : BRList . 
 var ltq : TypedCNameList .
 var ql ql' cnl ql2 : CNameList .
 var nt : NatTerm . 
 
 ***************************************
 *** substitution strategies
 ***************************************
 
 *** try both channel substitution rules
 strat smart-subst-nf : ChannelName ChannelName @ ProtocolConfig . 
 sd smart-subst-nf(C1, C2) :=                        
   substNFRead(C1, C2)
   ? idle
   : substNF(C1, C2) 
   . 
 
 *** substitution
 
 strat substNF : ChannelName ChannelName @ ProtocolConfig .
 sd substNF(C1, C2) :=  
     nTimesSubstNF(C1, C2) 
   ; liftInnerBindsNF(C2)
   ; handleRNF(C2)
   ; try (pre2Nf) 
   .   
 
 *** sub-steps in substitution
 
 *** apply SUBST of C1 in C2
 *** if the current P is newNF(..., C1 ::= R1 || C2 ::= nf( BRL (x <- read C1), R2, order) || Q  ,...) 
 strat nTimesSubstNF : ChannelName ChannelName @ ProtocolConfig .
 sd nTimesSubstNF(C1, C2) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstNF(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
         CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                         P1:Protocol <- keepTwo P C1 C2]{
           SUBST-nf[o1:ChannelName <- C1, 
                    o2:ChannelName <- C2]
         }
         or-else *** deal with the case that Q is empty
         SUBST-nf[o1:ChannelName <- C1, 
                    o2:ChannelName <- C2]
       )            .
                   
 *** similar, but for SUBST-nf-read                               
 strat substNFRead : ChannelName ChannelName @ ProtocolConfig .
 sd substNFRead(C1, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substNFRead(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
         CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                         P1:Protocol <- keepTwo P C1 C2]{
           SUBST-nf-read[o1:ChannelName <- C1, 
                         o2:ChannelName <- C2] 
         }
         or-else  
         SUBST-nf-read[o1:ChannelName <- C1, 
                         o2:ChannelName <- C2] 
       ).                   
 
 *** after subst we got x <~ nf(binds, R, ...)
 *** this strategy moves the binds outside <~
 strat liftInnerBindsNF : ChannelName @ ProtocolConfig .
 sd liftInnerBindsNF(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{liftInnerBindsNF(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        (  
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                        P1:Protocol <- keepOne P C]{
         CONG-REACT[cn:ChannelName <- C]
         { try (     (bind-bind-pre or-else bind-bind-pre-pre)
                   ; (read-det-pre !)
               )
         }
        }
        )
        or-else
        (CONG-REACT[cn:ChannelName <- C]
         { try (     (bind-bind-pre or-else bind-bind-pre-pre)
                   ; (read-det-pre !)
               )
         }) 
       .
 
 *** this strategy handles the reaction of a pre-normal form, 
 *** applying various reaction-level rules.
 *** the goal is to move binds outside the reaction
 strat handleRNF : ChannelName @ ProtocolConfig .  
 sd handleRNF(C1) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{handleRNF(C1)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
         (
         CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C1, 
                             P1:Protocol <- keepOne P C1]{
         CONG-REACT[cn:ChannelName <- C1]
                   {(ret-bind-pre or-else
                    (samp-over-if or-else 
                     (read2Binds or-else
                      (bind-ret-2-pre
                        or-else (merge-pre ; cong-pre-nf{bindFreeS})
                      )
                     )
                    )
                    ) 
                    ; simplifyNF
                   }
       }
       )
       or-else
       (
       CONG-REACT[cn:ChannelName <- C1]
                   {(ret-bind-pre or-else
                    (samp-over-if or-else 
                     (read2Binds or-else
                      (bind-ret-2-pre
                        or-else (merge-pre ; cong-pre-nf{bindFreeS})
                      )
                     )
                    )
                    ) 
                    ; simplifyNF
                   }
       ) .
       
 strat bindFreeS @ ReactionConfig .
 sd bindFreeS := 
     ((smart-ret-bind ; (if-left ? idle : (if-right ? idle : idle)) ) or-else
       (if-over-bind  
        ; cong-branch-refl{bindFreeS, bindFreeS}
       )
       ) or-else idle . 
       
 strat simplifyNF @ ReactionConfig .
 sd simplifyNF :=  
   cong-pre-nf{same-reaction-if} or-else idle 
 .    
 
 strat smart-ret-bind @ ReactionConfig .
 sd smart-ret-bind :=
     if-over-bind-same-2 
     ? (cong-branch-refl
        {cong-branch-refl{ret-bind , ret-bind},
         cong-branch-refl{ret-bind , ret-bind}} 
        ? idle
        : fail)  
     : (if-over-bind-same 
       ? (cong-branch-refl{ret-bind, ret-bind} ? idle : idle) 
       : ret-bind) 
       .   
   
 *** similar to substNF, but for families with one index
 strat substNFFamiliesOne : ChannelName ChannelName Reaction @ ProtocolConfig .
 sd substNFFamiliesOne(C1, C2, R) :=
     nTimesSubstNFFamiliesOne(C1, C2, R)
  ; liftInnerBindsNFFamily(C2)
  ; handleRNFFamily(C2)
  ; (pre2Nf or-else idle)  
 .
 
 *** sub-strategies, similar to the ones above
 strat nTimesSubstNFFamiliesOne :  Qid Qid Reaction @ ProtocolConfig .
 sd nTimesSubstNFFamiliesOne(Q1, Q2, R) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstNFFamiliesOne(Q1, Q2, R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P Q1 Q2, 
                             P1:Protocol <- keepTwo P Q1 Q2]{
          subst-families-one-family[
                   C:Qid <- Q1, 
                   C1:Qid <- Q2,
                   R2:Reaction <- R
                ]
                   } 
                or-else
                subst-families-one-family[
                   C:Qid <- Q1, 
                   C1:Qid <- Q2,
                   R2:Reaction <- R
                ]
       )
 .
 
 strat liftInnerBindsNFFamily : Qid @ ProtocolConfig .
 sd liftInnerBindsNFFamily(Q) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{liftInnerBindsNFFamily(Q)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       (
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P Q, 
                        P1:Protocol <- keepOne P Q]{
         CONG-FAMILY-R[C:Qid <- Q]
         { (  bind-bind-pre 
          ; (read-det-pre !)
           )
           or-else idle
         }
        }
        
        or-else
        CONG-FAMILY-R[C:Qid <- Q]
         { (  bind-bind-pre 
          ; (read-det-pre !)
           )
           or-else idle
         }
         
        )
 . 
      
         
 strat handleRNFFamily : Qid @ ProtocolConfig .  
 sd handleRNFFamily(Q) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{handleRNFFamily(Q)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P Q, 
                             P1:Protocol <- keepOne P Q]{
         CONG-FAMILY-R[C:Qid <- Q]
                   {(ret-bind-pre or-else
                    (samp-over-if or-else 
                     (read2Binds or-else
                      (bind-ret-2-pre
                        or-else (merge-pre ; cong-pre-nf{bindFreeS})
                      )
                     )
                    )
                    ) 
                    ; simplifyNF
                   }
       } 
       or-else
       CONG-FAMILY-R[C:Qid <- Q]
                   {(ret-bind-pre or-else
                    (samp-over-if or-else 
                     (read2Binds or-else
                      (bind-ret-2-pre
                        or-else (merge-pre ; cong-pre-nf{bindFreeS})
                      )
                     )
                    )
                    ) 
                    ; simplifyNF
                   }
       ).  
       
 *** under the assumption that the current protocol is of the form
 ***     family q2 ::= P || family q1 ::= when cond1 --> P1 ;; otherwise --> P2
 ***     do a substitution in P || P1               
 strat applyCaseDistSubst : Qid Qid Qid Qid Protocol @ ProtocolConfig .
 sd applyCaseDistSubst(q1, q2, q3, q4, pr) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyCaseDistSubst(q1, q2, q3, q4, pr)}
    : 
       CASE-DISTINCTION-one[aQid:Qid <- q1]
         { use-family-p[C:Qid <- q2]
             { COMP-NEW-newNF
             ; applySubstReadFamilyTwoFamily(q3, q4)
             ; (SYM[P1:Protocol <- pr]{COMP-NEW-newNF})
             }
         , idle
         } . 
         
  *** sub-strategy
                                               
 strat applySubstReadFamilyTwoFamily : Qid Qid @ ProtocolConfig .
 sd applySubstReadFamilyTwoFamily(q3, q4) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstReadFamilyTwoFamily(q3, q4)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P q3 q4, 
                             P1:Protocol <- keepTwo P q3 q4]
             {SUBST-nf-read-family-two-family}                
             or-else
             SUBST-nf-read-family-two-family
             )
 . 
 
 *** do a subst on the first branch of a family
  strat applySubstChannelBranch : Qid Qid @ ProtocolConfig .
 sd applySubstChannelBranch(q1, q2) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applySubstChannelBranch(q1, q2)}
    :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using  
       CASE-DISTINCTION-one-R[aQid:Qid <- q1, P:Protocol <- removeOne P q1]
         {  substChannelFamilyOne(q2, q1)
           , idle
         } .  
         
  *** substitute a channel in a family
  strat substChannelFamilyOne : ChannelName ChannelName @ ProtocolConfig .
 sd substChannelFamilyOne(C1, C2) :=
    nTimesSubstChannelFamilyOne(C1, C2)
  ; liftInnerBindsNFFamily(C2)
  ; handleRNFFamily(C2)
  ; (pre2Nf or-else idle)  
 . 
 
 *** sub-strategy, similar to subst-nf
 strat nTimesSubstChannelFamilyOne :  ChannelName ChannelName @ ProtocolConfig .
 sd nTimesSubstChannelFamilyOne(C1, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstChannelFamilyOne(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{                  
                   subst-channel-one-family}
               or-else    
               subst-channel-one-family
             )
 .   
 
 *** on the left branch of the right branch of a family, do a substitution
 strat applyCaseDistBranch2 : Qid Qid @ ProtocolConfig .
 sd applyCaseDistBranch2(q1, q2) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyCaseDistBranch2(q1, q2)}
    :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using  
       CASE-DISTINCTION-one-R[aQid:Qid <- q1, P:Protocol <- removeOne P q1]
         { idle
         , CASE-DISTINCTION-one-R[aQid:Qid <- q1]
           { substChannelFamilyOne(q2, q1)
           , idle}
         } .   
         
   *** on the left branch of a family, do a reverse subst
 strat applyBranch2SubstRev : Qid Qid NatTerm Qid Type Reaction @ ProtocolConfig .
 sd applyBranch2SubstRev(q1, q2, nt, x, T, R) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyBranch2SubstRev(q1, q2, nt, x, T, R)}
    :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using  
       CASE-DISTINCTION-one-R[aQid:Qid <- q1, P:Protocol <- removeOne P q1]
         {   applySubstNfRevFamiliesOne(q1, q2, nt, x, T, R)
           , idle
         } . 
         
  *** does the reverse substitution
  strat applySubstNfRevFamiliesOne : ChannelName ChannelName NatTerm Qid Type Reaction @ ProtocolConfig .
 sd applySubstNfRevFamiliesOne(C1, C2, nt, x, T, R) := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstNfRevFamiliesOne(C1, C2, nt, x, T, R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{                  
                    SUBST-nf-rev-families-one[
                      x1:ChannelName <- x, 
                      nj:NatTerm <- nt,
                      R2:Reaction <- R,
                      T1:Type <- T]
                     }
                or-else  
                 SUBST-nf-rev-families-one[
                      x1:ChannelName <- x, 
                      nj:NatTerm <- nt,
                      R2:Reaction <- R,
                      T1:Type <- T]    
              )       
 .                     
   
   *** subst-reverse with a case in a family
 strat applySubstRevFamily : Qid ChannelName Type @ ProtocolConfig .
 sd applySubstRevFamily(Q, C2, T) := 
 match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstRevFamily(Q, C2, T)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
              CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P Q C2, 
                             P1:Protocol <- keepTwo P Q C2]
             {subst-rev-families[C:Qid <- Q, 
                    cn2:ChannelName <- C2,
                    T:Type <- T]} 
              or-else    
              subst-rev-families[C:Qid <- Q, 
                    cn2:ChannelName <- C2,
                    T:Type <- T] 
             )        
 .   
                    
 *** subst-nf-read for families with one and two indices
 strat substNFReadFamilyOneChannel : Qid ChannelName @ ProtocolConfig .
 sd substNFReadFamilyOneChannel(Q, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substNFReadFamilyOneChannel(Q, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P Q C2, 
                             P1:Protocol <- keepTwo P Q C2]{
         SUBST-nf-read-family-one
                      [ q1:ChannelName <-  Q, 
                       cn2:ChannelName <- C2] } 
               or-else   
               SUBST-nf-read-family-one
                      [ q1:ChannelName <-  Q, 
                       cn2:ChannelName <- C2]     
                       ) 
  . 
                       
 strat substNFReadFamilyTwoChannel : Qid ChannelName @ ProtocolConfig .
 sd substNFReadFamilyTwoChannel(Q, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substNFReadFamilyTwoChannel(Q, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P Q C2, 
                             P1:Protocol <- keepTwo P Q C2]{
         SUBST-nf-read-family-two
                      [ q1:ChannelName <-  Q, 
                       cn2:ChannelName <- C2] } 
             or-else          
         SUBST-nf-read-family-two
                      [ q1:ChannelName <-  Q, 
                       cn2:ChannelName <- C2]         
             )
 .
 
 *** subst-reverse for a family and a channel
 strat substRevFamilyChannel : Qid ChannelName NatTerm Type @ ProtocolConfig .
 sd substRevFamilyChannel(Q, C2, nt, T) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substRevFamilyChannel(Q, C2, nt, T)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P Q C2, 
                             P1:Protocol <- keepTwo P Q C2]{
         subst-2-families-one
                      [ C:Qid <-  Q, 
                        cn2:ChannelName <- C2,
                        nj:NatTerm <- nt,
                        T:Type <- T
                      ]   } 
              or-else 
              subst-2-families-one
                      [ C:Qid <-  Q, 
                        cn2:ChannelName <- C2,
                        nj:NatTerm <- nt,
                        T:Type <- T
                      ]       
              )
  .   
                      
 *** subst-nf for families
 strat substNFFamilyOne : ChannelName ChannelName Reaction @ ProtocolConfig .
 sd substNFFamilyOne(C1, C2, R) :=
     nTimesSubstNFFamilyOne(C1, C2, R)
  ; liftInnerBindsNF(C2)
  ; handleRNF(C2)
  ; (pre2Nf or-else idle)  
 .   
 
 *** similar sub-strategy as for channels
 strat nTimesSubstNFFamilyOne : ChannelName ChannelName Reaction @ ProtocolConfig .
 sd nTimesSubstNFFamilyOne(C1, C2, R) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstNFFamilyOne(C1, C2, R)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{
          subst-families-one[
                   C:ChannelName <- C1, 
                   cn2:ChannelName <- C2,
                   R2:Reaction <- R
                ]
                   } 
                   or-else
                   subst-families-one[
                   C:ChannelName <- C1, 
                   cn2:ChannelName <- C2,
                   R2:Reaction <- R
                ]
                   )
 .  
                   
 *** subst on the left branch of a family
 strat applySubstNFLeft : Qid Qid Reaction @ ProtocolConfig .
 sd applySubstNFLeft(q1, q2, R) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applySubstNFLeft(q1, q2, R)}
    :    
       CASE-DISTINCTION-one-R[aQid:Qid <- q1]
         { substNFFamiliesOne(q2, q1, R)
         , idle
         } .
                 
   
   ************************
   *** drop
   ************************    
       
  *** DROP-NF
  
 strat applyDropNF : ChannelName ChannelName @ ProtocolConfig .
 sd applyDropNF(C1, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropNF(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{
         DROP-nf[cn1:ChannelName <- C1, 
                   cn2:ChannelName <- C2] 
         or-else
         DROP-nf-copy[
                   cn1:ChannelName <- C1, 
                   cn2:ChannelName <- C2]           } )
          or-else
          (DROP-nf[cn1:ChannelName <- C1, 
                   cn2:ChannelName <- C2] 
         or-else
         DROP-nf-copy[
                   cn1:ChannelName <- C1, 
                   cn2:ChannelName <- C2]  )         
  . 
                   
  *** drop for pre-normal forms
                    
 strat applyDropPreNF : ChannelName ChannelName @ ProtocolConfig .
 sd applyDropPreNF(C1, C2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropPreNF(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{
         DROP-pre-nf[o1:ChannelName <- C1, 
                   o2:ChannelName <- C2] } 
              or-else
               DROP-pre-nf[o1:ChannelName <- C1, 
                   o2:ChannelName <- C2]
              ) 
                   
 .                        
  
  *********************
  *** absorb
  *********************
                   
 *** absorb a channel  
 strat absorbChannel : ChannelName @ ProtocolConfig .
 sd absorbChannel(C) := 
    absorb-new-nf[c:ChannelName <- C] 
 .
 
 *** absorb a family
 strat absorbFamily : Qid @ ProtocolConfig .
 sd absorbFamily(Q) := 
    absorb-new-nf-family-one[C:Qid <- Q] 
    or-else
    absorb-new-nf-family-two[C:Qid <- Q] 
 .   
 
  *** add a newfamily to a named group of protocols
 strat addNewFamilyToGroup : Protocol Qid Qid @ ProtocolConfig .
 sd addNewFamilyToGroup(P, Q1, Q2) :=
     applyAbsorbReverse(P)
   ; moveProtocolUnderNewNF
   ; lift-inner-new-nf
   ; applyAddToGroup(Q1, Q2)
 .  
 
 *** substrategies
  strat applyAbsorbReverse : Protocol @ ProtocolConfig .
  sd applyAbsorbReverse(P) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAbsorbReverse(P)}
     :  ABSORB-LEFT-2[P2:Protocol <- new2NF(P)] 
     .  
 

 
 *** under the assumption that the current protocol is of the form
 ***     family q2 ::= P || family q1 ::= when cond1 --> P1 ;; otherwise --> P2
 *** do an absorb   
 strat applyCaseDistAbsorb : Qid Qid Qid Protocol @ ProtocolConfig .
 sd applyCaseDistAbsorb(q1, q2, q3, pr) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyCaseDistAbsorb(q1, q2, q3, pr)}
    : CASE-DISTINCTION-one[aQid:Qid <- q1]
         { use-family-p[C:Qid <- q2]
             { COMP-NEW-newNF
             ; absorbFamily(q3)
             ; (SYM[P1:Protocol <- pr]{COMP-NEW-newNF})
             }
         , idle
         } .       
 
 *********************
 *** fold
 *********************
 
 *** fold a channel
 strat foldNF : ChannelName ChannelName @ ProtocolConfig .
 sd foldNF(C1, C2) := 
                 (fold-bind-new-nf[c:ChannelName <- C1,
                                   o:ChannelName <- C2] 
                  or-else 
                  fold-bind-new-prenf[c:ChannelName <- C1,
                                      o:ChannelName <- C2] 
                  or-else
                  fold-bind-new-nf-0[c:ChannelName <- C1,
                                   o:ChannelName <- C2]                     )
               ; liftInnerBindsNF(C2) 
               ; handleRNF(C2) 
               ; try (pre2Nf)
               ; try (delete-empty-newNF)
                 .
                 
 *** fold a pre-normal form                
 strat foldNFPre : ChannelName ChannelName @ ProtocolConfig .  
 sd foldNFPre(C1, C2) := 
                 fold-bind-new-prenf[c:ChannelName <- C1,
                                     o:ChannelName <- C2] ;
                 liftInnerBindsNF(C2) ;
                 handleRpreNF(C2) 
                 .  
                 
 strat handleRpreNF : ChannelName @ ProtocolConfig .  
 sd handleRpreNF(C1) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{handleRpreNF(C1)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C1, 
                        P1:Protocol <- keepOne P C1]{
         CONG-REACT[o:ChannelName <- C1]
                   {merge-pre}}
          or-else
          CONG-REACT[o:ChannelName <- C1]
                   {merge-pre}        
         )          
        .   
       
 *** fold a family                
 strat foldNFFamily : Qid Qid @ ProtocolConfig .
 sd foldNFFamily(Q1, Q2) := 
                 (fold-bind-new-nf-families[C:Qid  <- Q1,
                                            C':Qid <- Q2] 
                 )
                 *** these last 2 steps should be reusable from subst!
                 ; liftInnerBindsNFFamily(Q2) 
                 ; handleRNFFamily(Q2) 
                 ; try (pre2Nf)
                 .                         
 
 ***********************************
 *** pure syntactic transformations
 ***********************************
 
  *** move the family Q2 inside the group Q1
 strat applyAddToGroup : Qid Qid @ ProtocolConfig .
 sd applyAddToGroup(Q1, Q2) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAddToGroup(Q1, Q2)}
     : matchrew pConf s.t. 
         pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P Q1 Q2, 
                             P1:Protocol <- keepTwo P Q1 Q2]
             {addToGroup}                
             or-else addToGroup
             )
 . 
 
 *** change order of reads in a normal form or a pre-normal form                        
 strat changeOrder : ChannelName CNameList @ ProtocolConfig .
 sd changeOrder(C, ql) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{changeOrder(C, ql)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]{
         CONG-REACT[o:ChannelName <- C]
         {change-order[QL':CNameList <- ql]
          or-else
          change-order-pre[QL':CNameList <- ql]
         }
       }
       or-else
        CONG-REACT[o:ChannelName <- C]
         {change-order[QL':CNameList <- ql]
          or-else
          change-order-pre[QL':CNameList <- ql]
         }
       )
 .
 
 *** turn a nf to prenf 
 strat nf2PreNF : ChannelName @ ProtocolConfig .
 sd nf2PreNF(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nf2PreNF(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                        P1:Protocol <- keepOne P C]
        {CONG-REACT[o:ChannelName <- C]{nf2Pre}} 
        or-else
        CONG-REACT[o:ChannelName <- C]{nf2Pre}
        )
 .  
 
  *** group families 
   strat applyGroupFamilies : Qid Qid @ ProtocolConfig .
   sd applyGroupFamilies(Q1, Q2) :=
   match pConf s.t. startsWithNew pConf
   ? CONG-NEW-NF{applyGroupFamilies(Q1, Q2)}
   : group-families[C:Qid <- Q1, C':Qid <- Q2]
 .       
 
 *** ungroup families
 strat applyUngroupFamilies : Qid Qid @ ProtocolConfig .
 sd applyUngroupFamilies(Q1, Q2) :=
   match pConf s.t. startsWithNew pConf
   ? CONG-NEW-NF{applyUngroupFamilies(Q1, Q2)}
   : ungroup-families[C:Qid <- Q1, C':Qid <- Q2]
 .    
 
 *** get a protocol inside a new normal form
 strat moveProtocolUnderNewNF @ ProtocolConfig .
 sd moveProtocolUnderNewNF := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveProtocolUnderNewNF} 
     : COMP-NEW-newNF
 .
 
  *** strategies for bringing a protocol to combined notation
 strat applyDeleteEmptyNF : Qid @ ProtocolConfig .
 sd applyDeleteEmptyNF(Q) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDeleteEmptyNF(Q)} 
     :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P Q, 
                             P1:Protocol <- keepOne P Q]
                             {CONG-FAMILY-WHENLIST-P{ delete-empty-newNF }  }
              or-else   CONG-FAMILY-WHENLIST-P{ delete-empty-newNF }            
             )
 .
 
 strat applyDropName : Qid @ ProtocolConfig .
 sd applyDropName(Q) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDropName(Q)} 
     :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P Q, 
                             P1:Protocol <- keepOne P Q]
                             {drop-group-name}
               or-else drop-group-name
             )
 .
 
 strat applyCombine : Qid @ ProtocolConfig .
 sd applyCombine(Q) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyCombine(Q)} 
     :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P Q, 
                             P1:Protocol <- keepOne P Q]
                             {convert-combined}
             or-else convert-combined                
             )
 .
  
 *** do an alpha-renaming on the otherwise branch of a family
 strat applyBranch2Alpha : Qid QidPairList @ ProtocolConfig .
 sd applyBranch2Alpha(q1, QL) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyBranch2Alpha(q1, QL)}
    : 
       CASE-DISTINCTION-one-R[aQid:Qid <- q1]
         {  idle,
            CASE-DISTINCTION-one-R-end
                    [C:Qid <- q1
                    ]
                  {
                     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
            using
                    CONG-COMP-RIGHT[Q:Protocol  <- removeOne P q1, 
                                    P1:Protocol <- keepOne P q1]{
                       CONG-FAMILY-R { alphaNFOverList(QL)}
                     }       
                  }
         } 
         . 
         
  *** substrategy and helpers
   sort QidPair .
 op <<_,_>> : Qid Qid -> QidPair [ctor] .
 op getFst : QidPair -> Qid .
 op getSnd : QidPair -> Qid .
 eq getFst(<< q1, q2 >>) = q1 .
 eq getSnd(<< q1, q2 >>) = q2 .
 
 sort QidPairList .
 subsort QidPair < QidPairList .
 op emptyQidPairList : -> QidPairList [ctor] .
 op __ : QidPair QidPairList -> QidPairList [ctor] . 
 
 var QL : QidPairList .
 var QP : QidPair .
 
 strat alphaNFOverList : QidPairList @ ReactionConfig .
 sd alphaNFOverList(emptyQidPairList) := idle .
 sd alphaNFOverList(QP QL) := 
     alpha-nf [vx:Qid <- getFst(QP), vy:Qid <- getSnd(QP)] 
   ; alphaNFOverList(QL) 
 .   
 
 *** apply bind2R-pre in a newNF protocol
  strat moveBindInPre : ChannelName Qid @ ProtocolConfig .
 sd moveBindInPre(C, Q) :=      
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveBindInPre(C, Q)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{bind2R-pre[x:Qid <- Q] or-else bind2R-nf[x:Qid <- Q] }}
             or-else
             CONG-REACT[o:ChannelName <- C]{bind2R-pre[x:Qid <- Q] or-else bind2R-nf[x:Qid <- Q] }
             )
    .  
 
 *** move reads from bind list of a normal form to the reaction of the normal form
 ***     on the left branch of a family
  strat applyBranch2MoveReads : Qid CNameList @ ProtocolConfig .
 sd applyBranch2MoveReads(q1, cnl) := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{applyBranch2MoveReads(q1, cnl)}
    :  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using  
       CASE-DISTINCTION-one-R[aQid:Qid <- q1, P:Protocol <- removeOne P q1]
         {   moveReadsToRFamily(q1, cnl)
           , idle
         } .
         
  *** move reads from bind list of a normal form to the reaction of the normal form
 strat moveReadsToRFamily : ChannelName CNameList @ ProtocolConfig .
 sd moveReadsToRFamily(C, emptyCNameList) := idle .
 sd moveReadsToRFamily(C, x :: cnl) := 
   match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveReadsToRFamily(C, x :: cnl)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]{
                              moveReadInnerNfFamily[x:ChannelName <- x]
                              or-else
                              moveReadInnerPreNfFamily[x:ChannelName <- x] 
                             }
               or-else  (moveReadInnerNfFamily[x:ChannelName <- x]
                              or-else
                              moveReadInnerPreNfFamily[x:ChannelName <- x] )             
             )
             ; moveReadsToRFamily(C, cnl)                
 .               
  
    
 ***  changes the order in a normal form, on the left branch of a protocol
 strat applyReorderNF : Qid CNameList @ ProtocolConfig .
 sd applyReorderNF(Q, ql2) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReorderNF(Q, ql2)} 
     : CASE-DISTINCTION-one-R[aQid:Qid <- Q]
       { matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
          using  (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P Q, 
                                 P1:Protocol <- keepOne P Q]
                  {CONG-FAMILY-R[C:Qid <- Q]{change-order[QL':CNameList <- ql2]}}
                   or-else
                  CONG-FAMILY-R[C:Qid <- Q]{change-order[QL':CNameList <- ql2]}
                  )
                  ,
         idle 
       }  
 . 
 
 *** alpha renaming
  strat applyAlphaNFPr : ChannelName QidPairList @ ProtocolConfig .
 sd applyAlphaNFPr(C, QL) :=                                 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAlphaNFPr(C, QL) } 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{alphaNFOverList(QL)}} 
             or-else
             CONG-REACT[o:ChannelName <- C]{alphaNFOverList(QL)}
             )
  .  
 
 *****************************
 *** read-inside-if
 *****************************
    
 *** apply read-inside-if in a newNF protocol 
 strat applyReadInsideIfPre : ChannelName @ ProtocolConfig .
 sd applyReadInsideIfPre(C) :=      
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReadInsideIfPre(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
       {CONG-REACT[o:ChannelName <- C]
        {cong-pre-nf{read-inside-if
                    } 
        }
       }
       or-else
       CONG-REACT[o:ChannelName <- C]
        {cong-pre-nf{read-inside-if
                    } 
        }
       )
    .    
 
 ******************************************
 *** helpers
 ******************************************
 
  *** checks that the protocol in a aConfig starts with new/newfamily or is in new normal form
 op aConfStartsWithNew_ : ApproxEqConfig -> Bool .
 eq aConfStartsWithNew aConfig(S, D, P, I, O, A, width w, length l) =
    startsWithNew pConfig(S, D, P, I, O, A) .
 
 *** checks that the protocol in a pConfig starts with new/newfamily or is in new normal form     
 op startsWithNew_ : ProtocolConfig -> Bool .
 eq startsWithNew pConfig(S, D, emptyProtocol, I, O, A) = false .
 eq startsWithNew pConfig(S, D, P1 || P2, I, O, A) = false .
 eq startsWithNew pConfig(S, D, C ::= R, I, O, A) = false .
 eq startsWithNew pConfig(S, D, new Q : T in P, I, O, A) = true .
 eq startsWithNew pConfig(S, D, newNF(ltq, P, ql), I, O, A) = true .
 eq startsWithNew pConfig(S, D, family Q nlist blist ::= P, I, O, A) = false .
 
endsm

***(

smod UNUSED-STRATS is 
  pr STRATS .
 *** vars
  
 var pConf : ProtocolConfig .
 var rConf : ReactionConfig .
 var S Sigma : Signature .
 var D Delta : ChannelContext .
 var G : TypeContext .
 var P P1 P2 : Protocol .
 var R R1 R2 R3 R4 : Reaction .
 *** var Q Q' C Q1 Q2 x1 x2 y x : Qid .
 var I O : Set{CNameBound} .
 var T T' T1 : Type .
 var flag : Bool .
 var M M1 M2 : Expression .
 var Dis : Distribution .
 var C C1 C2 : ChannelName .
 var Q Q' x1 : Qid .
 var A : Set{BoolTerm} .
 var N w l : Nat .
 var nlist : List{NatTerm} .
 var blist : List{Bounds} .
 var ql : CNameList .                
 var X : ChannelName . 
 var BRL : BRList . 
 var ltq : TypedCNameList .
 var ql' : CNameList .  
 
 *** helpers

 *** older method, should go away
 op isLastNew___ : ProtocolConfig Qid Bool -> Bool .

 eq isLastNew pConfig(S, D, emptyProtocol, I, O, A) Q flag = not flag .
 eq isLastNew pConfig(S, D, P1 || P2, I, O, A) Q flag = not flag .
 eq isLastNew pConfig(S, D, C ::= R, I, O, A) Q flag = not flag .
 eq isLastNew pConfig(S, D, new Q : T in P, I, O, A) Q false = false .
 eq isLastNew pConfig(S, D, new Q : T in P, I, O, A) Q true = 
    isLastNew pConfig(S, D, P, I, O, A) Q false .
 ceq isLastNew pConfig(S, D, new Q' : T in P, I, O, A) Q true = 
     isLastNew pConfig(S, D, P, I, O, A) Q true if Q =/= Q' .
 ceq isLastNew pConfig(S, D, new Q' : T in P, I, O, A) Q false = 
     false if Q =/= Q' .    

 op foundQ__  : ProtocolConfig Qid -> Bool .
 eq foundQ pConfig(S, D, emptyProtocol, I, O, A) Q = false .
 eq foundQ pConfig(S, D, P1 || P2, I, O, A) Q = false .
 eq foundQ pConfig(S, D, C ::= R, I, O, A) Q = false .
 eq foundQ pConfig(S, D, new Q : T in P, I, O, A) Q = true .
 ceq foundQ pConfig(S, D, new Q' : T in P, I, O, A) Q = false if Q' =/= Q . 
 

  strat alphaOverList : QidPairList @ ReactionConfig .
 sd alphaOverList(emptyQidPairList) := idle .
 sd alphaOverList(QP QL) := alpha [x:Qid <- getFst(QP), y:Qid <- getSnd(QP)] ; 
                            cong-bind{idle, alphaOverList(QL)} .     
     
 strat applyAlphaPr : ChannelName QidPairList @ ProtocolConfig .
 sd applyAlphaPr(C, QL) :=                                 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyAlphaPr(C, QL) } 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{alphaOverList(QL)}} . 
 

 *** checks that a certain channel is the first in a new/newfamily/newnf
 op startsWithNewC__ : ProtocolConfig ChannelName -> Bool .
 eq startsWithNewC pConfig(S, D, emptyProtocol, I, O, A) C = false .
 eq startsWithNewC pConfig(S, D, P1 || P2, I, O, A) C = false .
 eq startsWithNewC pConfig(S, D, C ::= R, I, O, A) C = false .
 eq startsWithNewC pConfig(S, D, new Q : T in P, I, O, A) C = (Q == C) .
 eq startsWithNewC pConfig(S, D, newNF(ltq, P, Q :: ql), I, O, A) C = (Q == C) .
 
 op startsWithBind : Reaction -> Bool .
 eq startsWithBind(return M) = false .
 eq startsWithBind(samp Dis) = false .
 eq startsWithBind(read M) = false .
 eq startsWithBind(if M then R1 else R2) = false .
 eq startsWithBind(Q : T <- R1 ; R2) = true .
 
 op startsWithBindRead : Reaction -> Bool .
 eq startsWithBindRead(Q : T <- read M ; R2) = true .
 eq startsWithBindRead(R) = false [owise] .
 
 op startsWithIfRead : ReactionConfig -> Bool .
 eq startsWithIfRead(rConfig(S, D, G, if M then x1 : T1 <- R1 ; R2 else 
                                                x1 : T1 <- R1 ; R3, I, A, T)) = true . 
 eq startsWithIfRead(rConfig(S, D, G, R, I, A, T)) = false [owise] .
 
 op rBindRead : ReactionConfig -> Bool .
 eq rBindRead(rConfig(S, D, G, R, I, A, T)) = startsWithBindRead(R) .
 
 op firstBind : ReactionConfig -> Qid .
 eq firstBind(rConfig(S, D, G, Q : T <- R1 ; R2, I, A, T')) = Q .
 
 op rBind : ReactionConfig -> Bool .
 eq rBind(rConfig(S, D, G, R, I, A, T)) = startsWithBind(R) .
 
 *** strategies
 
 *** old, we needed it before normal forms
 strat moveToLast : Qid @ ProtocolConfig . 
 sd moveToLast(Q) := match pConf s.t. (foundQ pConf Q) 
                       ? (match pConf s.t. (isLastNew pConf Q true) 
                         ? idle 
                         : (NEW-EXCH ; CONG-NEW-NF{moveToLast(Q)})) 
                       : CONG-NEW-NF{moveToLast(Q)} .
                       
 *** old                       
 strat nTimesCong : ChannelName @ ProtocolConfig .
 sd nTimesCong(C) := 
      match pConf s.t. startsWithNewC pConf C
      ? COMP-NEW-2 ; ABSORB-RIGHT 
      : CONG-NEW-NF{nTimesCong(C)} .
 
 *** apply bind-ret-2 inside C
 *** if the current P is newNF(..., C ::= R || Q  ,...)
 strat nTimesBindRet2 : ChannelName @ ProtocolConfig .
 sd nTimesBindRet2(C) := 
  match pConf s.t. startsWithNew pConf
  ? CONG-NEW-NF{nTimesBindRet2(C)}
  : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{bind-ret-2[x:Qid <- 'x]}} .
 
 *** old
 *** apply SUBST with the sub-proof read-det
 *** if the current P is newNF(..., P  ,...)
 strat nTimesSubst @ ProtocolConfig .
 sd nTimesSubst := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{nTimesSubst}
    : CONG-COMP-RIGHT{(SUBST [x2:Qid <- 'x2]{read-det})} . 
 
 *** apply bind-ret inside C
 *** if the current P is newNF(..., C ::= R || Q  ,...)   
 *** old
 strat nTimesBindRet @ ProtocolConfig .
 sd nTimesBindRet := 
    match pConf s.t. startsWithNew pConf
    ? CONG-NEW-NF{nTimesBindRet} 
    : CONG-COMP-RIGHT{CONG-REACT{bind-ret}} .
 
 strat liftInnerBinds @ ReactionConfig .
 sd liftInnerBinds := bind-bind ? cong-bind{idle, liftInnerBinds} : idle .
 
 strat liftAllInnerBinds @ ReactionConfig .
 sd liftAllInnerBinds := 
      match rConf s.t. rBind(rConf) 
       ? (liftInnerBinds ; cong-bind{idle, liftAllInnerBinds})
       : idle .  
 
 *** low-level strategy
 strat liftInnerBindsPr : ChannelName @ ProtocolConfig .
 sd liftInnerBindsPr(C) := 
  match pConf s.t. startsWithNew pConf 
  ? CONG-NEW-NF{liftInnerBindsPr(C)}
  : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{liftAllInnerBinds}} .

 *** old, before normal forms
 strat moveBindToLast @ ReactionConfig .
 sd moveBindToLast := exchange ? cong-bind{idle, moveBindToLast} : idle . 
 
 *** old, before normal forms
 strat moveCertainBindToLast : Qid @ ReactionConfig .
 sd moveCertainBindToLast(Q) :=
    match rConf s.t. Q =/= firstBind(rConf)
    ? cong-bind{idle, moveCertainBindToLast(Q)}
    : moveBindToLast . 
 
 *** old, before normal forms 
 strat moveBindToFirst : Qid @ ReactionConfig .
 sd moveBindToFirst(Q) := 
   match rConf s.t. Q =/= firstBind(rConf)
     ? moveBindToLast ; moveBindToFirst(Q)
     : idle .
  
 *** old, before normal forms    
 strat moveBindProtocol : Qid ChannelName @ ProtocolConfig .
 sd moveBindProtocol(Q, C) := CONG-REACT[o:ChannelName <- C]{moveBindToFirst(Q)} . 
 
 *** old, before normal forms
 strat moveCertainBindLastProtocol : Qid ChannelName @ ProtocolConfig .
 sd moveCertainBindLastProtocol(Q, C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveCertainBindLastProtocol(Q, C)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveCertainBindToLast(Q)}} .   

 *** old, before normal forms
 strat moveFirst : Qid ChannelName @ ProtocolConfig .
 sd moveFirst(Q, C) := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveBindToFirst(Q)}} .
 
 *** old, before normal forms       
 strat nTimesMoveFirst : Qid ChannelName @ ProtocolConfig .
 sd nTimesMoveFirst(Q, C) := 
   match pConf s.t. startsWithNew pConf
   ? CONG-NEW-NF{nTimesMoveFirst(Q, C)}
   : moveFirst(Q, C) .
                   
 strat removeDuplicateReadsNF : ChannelName @ ProtocolConfig .
 sd removeDuplicateReadsNF(C1) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{removeDuplicateReadsNF(C1)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C1, 
                        P1:Protocol <- keepOne P C1]{
         CONG-REACT[o:ChannelName <- C1]{read-det-pre !}
       } . 

 
 strat substAll : ChannelName @ ProtocolConfig .
 sd substAll(C) := substNFOne(C) ! .
 
 strat substAllAndAbsorb : ChannelName @ ProtocolConfig .
 sd substAllAndAbsorb(C) := substAll(C) ; absorbChannel(C) .
      
 strat substNFOne : ChannelName @ ProtocolConfig .
 sd substNFOne(C1) := 
     matchrew pConf 
         s.t. pConfig(Sigma, Delta,   
                      newNF(ltq,
                             P || (C1 ::= R1) || 
                                  (C2 ::= nf( (x1 : T1 <- read C1) BRL , R2, ql
                                            )
                                  ),
                       ql'), I, O, A) := pConf 
         by pConf 
       using substNF(C1, C2)
 .         
       
 var Q1 Q2 : Qid .
   
 var cnl : CNameList .
 
 strat moveReadsToR : ChannelName CNameList @ ProtocolConfig .
 sd moveReadsToR(C, emptyCNameList) := idle .
 sd moveReadsToR(C, x :: cnl) := 
   match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveReadsToR(C, x :: cnl)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]{
                              moveReadInnerNf[x:ChannelName <- x]
                              or-else
                              moveReadInnerPreNf[x:ChannelName <- x] 
                             }
             ; moveReadsToR(C, cnl)                
 .
 
 strat applySubstNfRev : ChannelName ChannelName Qid @ ProtocolConfig .
 sd applySubstNfRev(C1, C2, x) := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstNfRev(C1, C2, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{                  
                   SUBST-nf-rev[x:ChannelName <- x]}
 .
 
 strat applySubstNfRevFamily : ChannelName ChannelName Qid @ ProtocolConfig .
 sd applySubstNfRevFamily(C1, C2, x) := 
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySubstNfRevFamily(C1, C2, x)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]{                  
                   SUBST-nf-rev[x:ChannelName <- x]}
 .
 
 strat nTimesSubstSampFree : ChannelName ChannelName @ ProtocolConfig .
 sd nTimesSubstSampFree(C1, C2) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubstSampFree(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]
                             {SUBST[x2:Qid <- 'x2, 
                             o1:ChannelName <- C1, 
                             o2:ChannelName <- C2]{samp-free}} .
     
 strat nTimesSubst2SampFree : ChannelName ChannelName @ ProtocolConfig .
 sd nTimesSubst2SampFree(C1, C2) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesSubst2SampFree(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]
                             {SUBST-2[x2:Qid <- 'x2, 
                               o1:ChannelName <- C1, 
                               o2:ChannelName <- C2]{samp-free}} .   
                               
     
 strat ifOverBindAfterBinds @ ReactionConfig .
 sd ifOverBindAfterBinds :=  
     match rConf s.t. rBindRead(rConf) 
      ? cong-bind{idle, ifOverBindAfterBinds}
      : if-over-bind .  
 
 strat nTimesIfOverBind : ChannelName @ ProtocolConfig .
 sd nTimesIfOverBind(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesIfOverBind(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifOverBindAfterBinds}} .
     
 strat ifOverBindInBranch @ ReactionConfig .  
 sd ifOverBindInBranch :=  
     match rConf s.t. rBindRead(rConf) 
      ? cong-bind{idle, ifOverBindInBranch}
      : cong-branch-refl{if-over-bind, if-over-bind} . 
      
 strat ifOverBindInBranch2 @ ReactionConfig .  
 sd ifOverBindInBranch2 :=  
     match rConf s.t. rBindRead(rConf) 
      ? cong-bind{idle, ifOverBindInBranch2}
      : cong-branch-refl{ifOverBindInBranch, ifOverBindInBranch} . 
     
      
 strat ifLeftOverBind @ ReactionConfig .
 sd ifLeftOverBind := 
    match rConf s.t. rBind(rConf) 
    ? cong-bind{idle, ifLeftOverBind}
    : if-left .
    
 strat ifRightOverBind @ ReactionConfig .
 sd ifRightOverBind := 
    match rConf s.t. rBind(rConf) 
    ? cong-bind{idle, ifRightOverBind}
    : if-right .   
     
 strat nTimesIfOverBindBranch : ChannelName @ ProtocolConfig .
 sd nTimesIfOverBindBranch(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesIfOverBindBranch(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifOverBindInBranch}} .    
     
 strat nTimesIfOverBindBranch2 : ChannelName @ ProtocolConfig .
 sd nTimesIfOverBindBranch2(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesIfOverBindBranch2(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifOverBindInBranch2}} .    
     
 strat bindRetInBranchTwiceIOB @ ReactionConfig .
 sd bindRetInBranchTwiceIOB := 
    match rConf s.t. rBindRead(rConf)
    ? cong-bind{idle, bindRetInBranchTwiceIOB}
    : cong-branch-refl
        {cong-branch-refl{ret-bind ; ifRightOverBind, ret-bind ; ifLeftOverBind},
         cong-branch-refl{ret-bind ; ifLeftOverBind, ret-bind ; ifRightOverBind}} .
 
 strat bindRetInBranchTwice @ ReactionConfig .
 sd bindRetInBranchTwice := 
    match rConf s.t. rBindRead(rConf)
    ? cong-bind{idle, bindRetInBranchTwice}
    : cong-branch-refl
        {cong-branch-refl{ret-bind , ret-bind},
         cong-branch-refl{ret-bind , ret-bind}} .
         
 strat moveInsideIf : Qid ChannelName @ ProtocolConfig .
 sd moveInsideIf(Q, C) :=  *** first what var and then the channel
    moveCertainBindLastProtocol(Q, C) ;
    applyReadOverIf(Q, C) .
        
 strat applyReadOverInnerIf : Qid ChannelName @ ProtocolConfig .
 sd applyReadOverInnerIf(Q, C) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReadOverInnerIf(Q, C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]
              {moveLastBindInsideInnerIf(Q)}
             } .
 
 strat applyReadOverIf : Qid ChannelName @ ProtocolConfig .
 sd applyReadOverIf(Q, C) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReadOverIf(Q, C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveLastBindInsideIf(Q)}} .

 
 strat moveLastBindInsideIf : Qid @ ReactionConfig .
 sd moveLastBindInsideIf(Q) :=
    match rConf s.t. Q =/= firstBind(rConf)
    ? cong-bind{idle, moveLastBindInsideIf(Q)}
    : read-inside-if . 
    
 strat moveLastBindInsideInnerIf : Qid @ ReactionConfig .
 sd moveLastBindInsideInnerIf(Q) :=
    match rConf s.t. rBind(rConf)
    ? cong-bind{idle, moveLastBindInsideInnerIf(Q)}
    : cong-branch-refl{read-inside-if, read-inside-if} .   
           
         
 strat bindRetInBranch @ ReactionConfig .
 sd bindRetInBranch :=  
     match rConf s.t. rBindRead(rConf) *** TODO: allow any bind?
    ? cong-bind{idle, bindRetInBranch}
    : cong-branch-refl{ret-bind , ret-bind} . 
    
 strat nTimesBindRetBranch : ChannelName @ ProtocolConfig .
 sd nTimesBindRetBranch(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesBindRetBranch(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{bindRetInBranch}} . 
         
 
 strat nTimesBindRetBranchTwiceIOB : ChannelName @ ProtocolConfig .
 sd nTimesBindRetBranchTwiceIOB(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesBindRetBranchTwiceIOB(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{bindRetInBranchTwiceIOB}} . 
   
 strat nTimesBindRetBranchTwice : ChannelName @ ProtocolConfig .
 sd nTimesBindRetBranchTwice(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{nTimesBindRetBranchTwice(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{bindRetInBranchTwice}} . 
  
     
 strat moveAllBindsToFrontIf @ ReactionConfig .
 sd moveAllBindsToFrontIf :=
     match rConf s.t. rBind(rConf)
     ? cong-bind{idle, moveAllBindsToFrontIf}
     : match rConf s.t. startsWithIfRead(rConf) 
       ? if-over-read ; moveAllBindsToFrontIf
       : idle .
        
 strat moveAllBindsTwoIfs @ ReactionConfig .
 sd moveAllBindsTwoIfs := 
    match rConf s.t. rBind(rConf)
     ? cong-bind{idle, moveAllBindsTwoIfs}
     : cong-branch-refl{ moveAllBindsToFrontIf, moveAllBindsToFrontIf} .
    
 strat moveBinds : ChannelName @ ProtocolConfig .
 sd moveBinds(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveBinds(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveAllBindsTwoIfs}} . 

 strat moveBindsOne : ChannelName @ ProtocolConfig .
 sd moveBindsOne(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{moveBindsOne(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{moveAllBindsToFrontIf}} .
   
    
 op canApplyIfBindSame : Reaction -> Bool .
 eq canApplyIfBindSame(x1 : T1 <- if M then R1 else R2 ; if M then R3 else R4) = true .
 eq canApplyIfBindSame(R) = false [owise] .  
 

 op canApplyIfBindSameC : ReactionConfig -> Bool .
 eq canApplyIfBindSameC(rConfig(S, D, G, R, I, A, T)) = canApplyIfBindSame(R) .
 
 strat ifBindSame @ ReactionConfig .
 sd ifBindSame :=
  match rConf s.t. canApplyIfBindSameC(rConf) 
  ? if-over-bind-same
  : match rConf s.t. rBind(rConf)
     ? cong-bind{idle, ifBindSame}
     : idle .
     
 strat ifBindSame2 @ ReactionConfig .
 sd ifBindSame2 :=
  match rConf s.t. canApplyIfBindSameC(rConf) 
  ? if-over-bind-same-2
  : match rConf s.t. rBind(rConf)
     ? cong-bind{idle, ifBindSame2}
     : idle .    
     
 strat ifBindSamePr : ChannelName @ ProtocolConfig .
 sd ifBindSamePr(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{ifBindSamePr(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifBindSame}} .
    
 strat ifBindSame2Pr : ChannelName @ ProtocolConfig .
 sd ifBindSame2Pr(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{ifBindSame2Pr(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{ifBindSame2}} .
     
 strat recursiveReadDet @ ReactionConfig .
 sd recursiveReadDet := 
   match rConf s.t. rBindRead(rConf)
     ? (read-det
          ? recursiveReadDet
          : (exchange ? cong-bind{idle, recursiveReadDet} : idle)) 
     : idle . 
  
 strat recReadDet : ChannelName Nat @ ProtocolConfig .
 sd recReadDet(C, 0) := idle .
 sd recReadDet(C, s(N)) :=
     (match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{recReadDet(C, s(N))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{recursiveReadDet}}) ; recReadDet(C, N) .
    
 strat readOutsideIf2 : ChannelName @ ProtocolConfig .
 sd readOutsideIf2(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{readOutsideIf2(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]
                       {moveAllBindsTwoIfs ; moveAllBindsToFrontIf}} .
 
 strat sameReactionIfAfterBinds @ ReactionConfig .
 sd sameReactionIfAfterBinds := 
   match rConf s.t. rBindRead(rConf)
     ? cong-bind{idle, sameReactionIfAfterBinds} 
     : same-reaction-if .
 
 strat sameReactionIf : ChannelName @ ProtocolConfig .
 sd sameReactionIf(C) := 
     match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{sameReactionIf(C)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{sameReactionIfAfterBinds}} .
     
 strat removeUnused : ChannelName ChannelName @ ProtocolConfig .
 sd removeUnused(C1, C2) := 
 match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{removeUnused(C1, C2)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeTwo P C1 C2, 
                             P1:Protocol <- keepTwo P C1 C2]
             {UNUSED[o1:ChannelName <- C1, o2:ChannelName <- C2]{samp-pure}} .
            
 strat addNewChannel : Protocol @ ProtocolConfig .
 sd addNewChannel(P) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{addNewChannel(P)}
     : ABSORB-LEFT-2[P2:Protocol <- P] ; COMP-NEW .  
     
     
 var Msg1 Msg2 : Expression .    
      
 var q1 q2 : Qid .  

 var x : Qid .    
     
 strat retBind2OverIf : Type Expression Expression Reaction Qid @ ReactionConfig .
 sd retBind2OverIf(T, M1, M2 , R, x) := 
    match rConf s.t. rBind(rConf) 
    ? cong-bind{idle, retBind2OverIf(T, M1, M2, R, x) }
    : cong-branch-refl{
           ret-bind-2[M1:Expression <- M1 , T1:Type <- T, R2:Reaction <- R , x:Qid <- x],
           ret-bind-2[M1:Expression <- M2 , T1:Type <- T, R2:Reaction <- R , x:Qid <- x]} .
     
 strat applyRetBind2OverIf : ChannelName Type Expression Expression Reaction Qid @ ProtocolConfig .
 sd applyRetBind2OverIf(C, T, M1, M2, R, x) :=                                 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyRetBind2OverIf(C, T, M1, M2, R, x) } 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{retBind2OverIf(T, M1, M2, R, x)}} .
     
 strat symOverIf : Reaction Expression Expression @ ReactionConfig .
 sd symOverIf(R, Msg1, Msg2) :=
    sym[R1:Reaction <- R]
      {liftAllInnerBinds ; 
       ifOverBindAfterBinds ;
       bindRetInBranch ; idle
       *** applyCongRetBranch(Msg1, Msg2)
       } .   
       
 strat applySymOverIf : ChannelName Reaction Expression Expression @ ProtocolConfig .      
 sd applySymOverIf(C, R, Msg1, Msg2) := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applySymOverIf(C, R, Msg1, Msg2) } 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             {CONG-REACT[o:ChannelName <- C]{symOverIf(R, Msg1, Msg2)}} .
             
 *** strategies for families   
 
 var cases : Cases .
 var aP : Protocol .
 
 strat absorbReverseFamily : ChannelName Protocol @ ProtocolConfig .
 sd absorbReverseFamily(C, aP) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{absorbReverseFamily(C, aP)}
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P C, 
                             P1:Protocol <- keepOne P C]
             { 
              CONG-FAMILY-P{ 
                             ABSORB-LEFT-2[P2:Protocol <- aP]  
                           ; (try (comp-new-families))   
                           ; (try (COMP-NEW-newNF-newfamily)) 
                           }
             }
 .  
 
 strat absorbReverseNewNF : Protocol @ ProtocolConfig .
 sd absorbReverseNewNF(aP) :=
    ABSORB-LEFT-2[P2:Protocol <- aP] ;
    try (comp-new-families)
 . 
  
 var pr : Protocol . 
 var q3 : Qid .
 var nt : NatTerm . 
                       
 var q4 : Qid .
 
endsm
 
 )
