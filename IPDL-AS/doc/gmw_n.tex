\renewcommand{\flip}{\mathsf{flip}}
\renewcommand{\circuit}{\mathsf{circuit}}
\renewcommand{\inputgate}{\textit{input-gate}}
\renewcommand{\xorgate}{\textit{xor-gate}}
\renewcommand{\andgate}{\textit{and-gate}}
\renewcommand{\notgate}{\textit{not-gate}}
\renewcommand{\id}{\mathsf{id}}
\renewcommand{\adv}{\mathsf{adv}}
\renewcommand{\party}{\mathsf{party}}
\renewcommand{\ot}{\mathsf{ot}}
\renewcommand{\Wires}{\mathsf{Wires}}
\renewcommand{\Init}{\mathsf{Init}}
\renewcommand{\Circ}{\mathsf{Circ}}
\renewcommand{\Fin}{\mathsf{Fin}}
\renewcommand{\Shares}{\mathsf{Shares}}
\renewcommand{\OT}{\mathsf{1OutOf4OT}}
\renewcommand{\Adv}{\mathsf{Adv}}
\newcommand{\Ctrbs}{\mathsf{Ctrbs}}
\renewcommand{\Sim}{\mathsf{Sim}}
\renewcommand{\In}{\mathsf{In}}
\renewcommand{\Wire}{\mathsf{Wire}}
\renewcommand{\Out}{\mathsf{Out}}
\renewcommand{\SendInShare}{\mathsf{SendInShare}}
\renewcommand{\SendOutShare}{\mathsf{SendOutShare}}
\renewcommand{\InShareGen}{\mathsf{InShare}\textsf{-}\$}
\newcommand{\SumInShareGen}{\mathsf{InShare}\textsf{-}\$\textsf{-}\Sigma}
\renewcommand{\InShare}{\mathsf{InShare}}
\renewcommand{\SendBit}{\mathsf{SendBit}}
\renewcommand{\RcvdBit}{\mathsf{RcvdBit}}
\newcommand{\Ctrb}{\mathsf{Ctrb}}
\newcommand{\SumCtrb}{\mathsf{Ctrb}\textsf{-}\Sigma}
\renewcommand{\Share}{\mathsf{Share}}
\renewcommand{\OutShare}{\mathsf{OutShare}}
\newcommand{\SumInShare}{\mathsf{InShare}\textsf{-}\Sigma}
\renewcommand{\SumShare}{\mathsf{Share}\textsf{-}\Sigma}
\newcommand{\SumOutShare}{\mathsf{OutShare}\textsf{-}\Sigma}
\renewcommand{\OTMsg}{\mathsf{OTMsg}}
\renewcommand{\OTChc}{\mathsf{OTChc}}
\renewcommand{\OTOut}{\mathsf{OTOut}}
\newcommand{\Col}{\mathsf{Col}}
\newcommand{\Row}{\mathsf{Row}}
\newcommand{\SumCol}{\mathsf{Col}\textsf{-}\Sigma}
\newcommand{\SumRow}{\mathsf{Row}\textsf{-}\Sigma}
\newcommand{\Sqr}{\mathsf{Sqr}}
\newcommand{\DiagRefl}{\mathsf{DiagRefl}}
\newcommand{\RowCol}{\mathsf{RowCol}}
\renewcommand{\LeakInRcvd}{\mathsf{InRcvd}}
\renewcommand{\LeakIn}{\mathsf{In}}
\renewcommand{\LeakOut}{\mathsf{Out}}
\renewcommand{\LeakRcvdInShare}{\mathsf{RcvdInShare}}
\renewcommand{\LeakSendInShare}{\mathsf{SendInShare}}
\renewcommand{\LeakRcvdOutShare}{\mathsf{RcvdOutShare}}
\renewcommand{\LeakSendOutShare}{\mathsf{SendOutShare}}
\renewcommand{\LeakInShareGen}{\mathsf{InShare}\textsf{-}\$}
\newcommand{\LeakSumInShareGen}{\mathsf{InShare}\textsf{-}\$\textsf{-}\Sigma}
\renewcommand{\LeakInShare}{\mathsf{InShare}}
\renewcommand{\LeakSendBit}{\mathsf{SendBit}}
\renewcommand{\LeakRcvdBit}{\mathsf{RcvdBit}}
\newcommand{\LeakCtrb}{\mathsf{Ctrb}}
\newcommand{\LeakSumCtrb}{\mathsf{Ctrb}\textsf{-}\Sigma}
\renewcommand{\LeakShare}{\mathsf{Share}}
\renewcommand{\LeakOutShare}{\mathsf{OutShare}}
\newcommand{\LeakSumOutShare}{\mathsf{OutShare}\textsf{-}\Sigma}
\renewcommand{\LeakOTMsg}{\mathsf{OTMsg}}
\renewcommand{\LeakOTMsgRcvd}{\mathsf{OTMsgRcvd}}
\renewcommand{\LeakOTChc}{\mathsf{OTChc}}
\renewcommand{\LeakOTChcRcvd}{\mathsf{OTChcRcvd}}
\renewcommand{\InitOk}{\mathsf{Init}\textsf{-}\checkmark}
\renewcommand{\WiresOk}{\mathsf{Wires}\textsf{-}\checkmark}
\renewcommand{\SharesOk}{\mathsf{Shares}\textsf{-}\checkmark}
\newcommand{\CtrbsOk}{\mathsf{Ctrbs}\textsf{-}\checkmark}
\renewcommand{\InOk}{\mathsf{In}\textsf{-}\checkmark}
\renewcommand{\WireOk}{\mathsf{Wire}\textsf{-}\checkmark}
\renewcommand{\InShareGenOk}{\mathsf{InShare}\textsf{-}\$\textsf{-}\checkmark}
\newcommand{\SumInShareGenOk}{\mathsf{InShare}\textsf{-}\$\textsf{-}\Sigma\textsf{-}\checkmark}
\renewcommand{\InShareOk}{\mathsf{InShare}\textsf{-}\checkmark}
\renewcommand{\SendBitOk}{\mathsf{SendBit}\textsf{-}\checkmark}
\renewcommand{\RcvdBitOk}{\mathsf{RcvdBit}\textsf{-}\checkmark}
\newcommand{\CtrbOk}{\mathsf{Ctrb}\textsf{-}\checkmark}
\newcommand{\SumCtrbOk}{\mathsf{Ctrb}\textsf{-}\Sigma\textsf{-}\checkmark}
\renewcommand{\ShareOk}{\mathsf{Share}\textsf{-}\checkmark}
\newcommand{\SumShareOk}{\mathsf{Share}\textsf{-}\Sigma\textsf{-}\checkmark}

In the multi-party GMW protocol, $N+2$ parties labeled $0,\ldots,N+1$ jointly compute the value of a given Boolean circuit built out of \emph{xor-}, \emph{and-}, and \emph{not} gates. The inputs to the circuit are divided among the parties, and no party has access to the inputs of any other. Analogously to the two-party case, party $n$ maintains its share of the actual value $v$ computed by each gate, and summing up the shares $n \coloneqq 0, \ldots, N+1$ yields back $v$. We prove the protocol secure in the case when party $N$ is semi-honest, party $N+1$ is honest, and any other party is arbitrarily honest or semi-honest. When carrying out the 1-Out-Of-4 Oblivious Transfer between parties $n < m$, we assume $n$ is the sender and $m$ is the receiver.

Formally, we assume a coin-flip distribution $\flip : \one \twoheadrightarrow \Bool$; a Boolean sum function $\oplus : \Bool \times \Bool \rightarrow \Bool$, where we write $x \oplus y$ in place of $\oplus \ (x,y)$; a Boolean multiplication function $* : \Bool \times \Bool \rightarrow \Bool$, where we write $x * y$ in place of $* \ (x,y)$; and a Boolean negation function $\neg : \Bool \rightarrow \Bool$, where we write $\neg x$ in place of $\neg \ x$.

We represent Boolean circuits using the syntax below, where we assume that party $p \coloneqq 0,\ldots,N+1$ has $I_p \geq 0$ inputs labeled $\{0,\ldots,I_p-1\}$. Starting from the empty circuit $\epsilon$, we add one gate at a time: an \emph{input} gate allows us to plug into a specified input $i$ of party $p$; a \emph{not} gate negates the value carried on wire $k$; an \emph{xor} gate computes the Boolean sum of the two values carried on wires $k$ and $l$; and an \emph{and} gate does the same for Boolean product.

\begin{syntax}
  \abstractCategory[Parties]{p \in \nat}
	\abstractCategory[Inputs]{i \in \nat}
  \abstractCategory[Wires]{k,l \in \nat}
	
  \category[Circuits]{C}
    \alternative{\epsilon}
		\alternative{C; \, \inputgate(p,i)}
    \alternative{C; \, \notgate(k)}
		\alternative{C; \, \xorgate(k,l)}
		\alternative{C; \, \andgate(k,l)}
\end{syntax}

\noindent A circuit $C$ with $n \in \nat$ wires is considered well-formed if each logical gate combines previously defined wires only:

\begin{mathpar}
\inferrule*{ }{\epsilon \ \circuit(0)}\and
\inferrule*{C \ \circuit(n) \\ 0 \leq p \leq N+1 \\ i < I_p}{C; \, \inputgate(p,i) \ \circuit(n+1)}\and
\inferrule*{C \ \circuit(n) \\ k < n}{C; \, \notgate(k) \ \circuit(n+1)}\and
\inferrule*{C \ \circuit(n) \\ k < n \\ 0 \leq l < n}{C; \, \xorgate(k,l) \ \circuit(n+1)}\and
\inferrule*{C \ \circuit(n) \\ k < n \\ 0 \leq l < n}{C; \, \andgate(k,l) \ \circuit(n+1)}
\end{mathpar}

\noindent We now fix an ambient Boolean circuit $C$ with $K$ wires $\{0,\ldots,K-1\}$, a subset of which is designated as outputs.

\subsection{The Assumptions}
At the expression level, we assume that the Boolean sum and product operations are commutative and associative:
\begin{itemize}
\item $x : \Bool, y : \Bool \vdash x \oplus y = y \oplus x : \Bool$,
\item $x : \Bool, y : \Bool \vdash x * y = y * x : \Bool$,
\item $x : \Bool, y : \Bool, z : \Bool \vdash (x \oplus y) \oplus z = x \oplus (y \oplus z) : \Bool$, and
\item $x : \Bool, y : \Bool, z : \Bool \vdash (x * y) * z = x * (y * z) : \Bool$.
\end{itemize}
Furthermore, Boolean multiplication distributes over Boolean sum:
\begin{itemize}
\item $x : \Bool, y : \Bool, z : \Bool \vdash (x \oplus y) * z = (x * z) \oplus (y * z) : \Bool$.
\end{itemize}
Summing up a Boolean with itself yields $\false$ and summing up a Boolean with $\false$ yields the original Boolean:
\begin{itemize}
\item $x : \Bool \vdash x \oplus x = \false : \Bool$, and
\item $x : \Bool \vdash x \oplus \false = x : \Bool$.
\end{itemize}
Negating a Boolean equals summing it up with $\true$:
\begin{itemize}
\item $x : \Bool \vdash x \oplus \true = \neg x : \Bool$.
\end{itemize}
Finally, multiplying a Boolean with $\false$ or $\true$ yields $\false$ or the original Boolean, respectively:
\begin{itemize}
\item $x : \Bool \vdash x * \false = \false : \Bool$, and
\item $x : \Bool \vdash x * \true = x : \Bool$.
\end{itemize}
At the distribution level, we assume that the distribution $\flip$ on Booleans is invariant under the operation of Boolean sum with a fixed Boolean (as is indeed the case when $\flip$ is uniform):
\begin{itemize}
\item $x : \Bool \vdash \big(y \leftarrow \flip; \ \ret{x \oplus y}\big) = \flip : \Bool$
\end{itemize}

\subsection{The Ideal Protocol}
The leakage from the ideal functionality includes the value of each input $i$ belonging to a semi-honest party $n$, plus the timing information for each input $i$ belonging to an honest party $n$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakIn(n,i)^\id_\adv \coloneqq \read{\In(n,i)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakIn(n,i)^\id_\adv \coloneqq \read{\LeakIn(n,i)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakInRcvd(n,i)^\id_\adv \coloneqq x \leftarrow \In(n,i); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \\ \LeakInRcvd(n,i)^\id_\adv \coloneqq \read{\LeakInRcvd(n,i)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \end{cases*}$}
\end{itemize}

\noindent In the inductive phase, the functionality computes the value carried by each wire $k < K$ of the ambient circuit by induction on the circuit:

\begin{itemize}
\item $\Wires(\epsilon,0)$ is the protocol $\zero$
\item $\Wires\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Wires(C,K)$ with the protocol
\begin{itemize}
\item $\Wire(K) \coloneqq \read{\In(p,i)}$
\end{itemize}
\item $\Wires\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Wires(C,K)$ with the protocol
\begin{itemize}
\item $\Wire(K) \coloneqq x \leftarrow \Wire(k); \ \ret{\neg x}$
\end{itemize}
\item $\Wires\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Wires(C,K)$ with the protocol
\begin{itemize}
\item $\Wire(K) \coloneqq x \leftarrow \Wire(k); \ y \leftarrow \Wire(l); \ \ret{x \oplus y}$
\end{itemize}
\item $\Wires\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Wires(C,K)$ with the protocol
\begin{itemize}
\item $\Wire(K) \coloneqq x \leftarrow \Wire(k); \ y \leftarrow \Wire(l); \ \ret{x * y}$
\end{itemize}
\end{itemize}

\noindent After performing the above computation, the ideal functionality outputs the computed value for each wire marked as an output, and leaks the outputs to the adversary on behalf of each semi-honest party:

\begin{itemize}
\item $\begin{cases*} \Out(n,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $n \leq n+1$ and $k < K$ if wire $k$ an output} \\ \Out(n,k) \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq n+1$ and $k < K$ if wire $k$ not an output} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakOut(n,k)^\id_\adv \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOut(n,k)^\id_\adv \coloneqq \read{\LeakOut(n,k)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}

\noindent Finally, the channels
\begin{itemize}
\item $\Wire(k)$ for $k < K$
\end{itemize}
coming from the inductive protocol $\Wires(C,K)$ are designated as internal.

\subsection{The Real Protocol}
The real protocol consists of the $N+2$ parties, plus an instance of the ideal 1-Out-Of-4 Oblivious Transfer (OT) functionality for each gate and each pair of parties $m,n \leq N+1$. The code for each party is separated into three parts: in the initial phase, each party computes and distributes everyone's shares for each of its inputs. In the inductive phase, each party computes their share of each wire by induction on the ambient circuit. At last, in the final phase, parties send their shares of each output wire to one another and add them up to compute the result. We now describe the code for party $n$.

\subsubsection{Initial Phase}
A semi-honest party $n$ leaks the value of each of its inputs, whereas an honest party only leaks the fact that an input has been received:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\In(n,i)} \\ \hspace{10pt} \text{for $i < I_n$ if $n$ semi-honest} \\ \LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakIn(n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq x \leftarrow \In(n,i); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $i < I_n$ if $n$ honest} \\ \LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInRcvd(n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $i < I_n$ if $n$ semi-honest} \end{cases*}$}
\end{itemize}
We next randomly generate shares for every party except party $N+1$:
\begin{itemize}
\item $\InShareGen(m,n,i) \coloneqq x \leftarrow \In(n,i); \ \samp{\flip}$ for $m \leq N$ and $i < I_n$
\item {\color{blue} $\begin{cases*} \LeakInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt}
 \text{for $m \leq N$ and $i < I_n$ if $n$ semi-honest} \\ \LeakInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShareGen(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\end{itemize}
To determine the share of party $N+1$, we inductively compute the sum of all the shares we generated above:
\begin{itemize}
\item $\begin{cases*} \SumInShareGen(0,n,i) \coloneqq \read{\InShareGen(0,n,i)} \\ \hspace{10pt} \text{for $i < I_n$} \\ \SumInShareGen(m+1,n,i) \coloneqq x_\Sigma \leftarrow \SumInShareGen(m,n,i); \ x_{m+1} \leftarrow \InShareGen(m+1,n,i); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$ and $i < I_n$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSumInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\SumInShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSumInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq  \read{\LeakSumInShareGen(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\end{itemize}
We compute the share of party $N+1$ by summing up the input $i$ with the shares of all the other parties:
\begin{itemize}
\item $\InShareGen(N+1,n,i) \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \In(n,i); \ \ret{x_\Sigma \oplus x}$ for $i < I_n$
\item {\color{blue} $\begin{cases*} \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(N+1,n,i)} \\ \hspace{10pt} \text{for $i < I_n$ if $n$ semi-honest} \\ \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShareGen(N+1,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $i < I_n$ if $n$ honest} \end{cases*}$}
\end{itemize}
This concludes the computation of shares for inputs belonging to party $n$. We next send each computed share to the respective party:
\begin{itemize}
\item $\SendInShare(m,n,i) \coloneqq \read{\InShareGen(m,n,i)}$ for $m \leq N+1$ and $i < I_n$
\item {\color{blue} $\begin{cases*} \LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\SendInShare(m,n,i)}\\ \hspace{10pt} \text{for $m \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSendInShare(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\end{itemize}
If party $n$ is semi-honest, each input share received for an input $i$ belonging to party $m$ is forwarded to the adversary:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakRcvdInShare(n,m,i)^{\party(n)}_\adv \coloneqq \read{\SendInShare(n,m,i)} \\ \hspace{10pt} \text{for $m \leq N+1$ and $i < I_m$ if $n$ semi-honest} \\ \LeakRcvdInShare(n,m,i)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdInShare(n,m,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ and $i < I_m$ if $n$ honest} \end{cases*}$}
\end{itemize}
Finally, the incoming input shares are recorded:
\begin{itemize}
\item $\InShare(n,m,i) \coloneqq \read{\SendInShare(n,m,i)}$ for $m \leq N+1$ and $i < I_m$
\item {\color{blue} $\begin{cases*} \LeakInShare(n,m,i)^{\party(n)}_\adv \coloneqq \read{\InShare(n,m,i)} \\ \hspace{10pt} \text{for $m \leq N+1$ and $i < I_m$ if $n$ semi-honest} \\ \LeakInShare(n,m,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShare(n,m,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ and $i < I_m$ if $n$ honest} \end{cases*}$}
\end{itemize}
The channels
\begin{itemize}
\item $\InShareGen(m,n,i)$ for $m \leq N+1$ and $i < I_n$,
\item $\SumInShareGen(m,n,i)$ for $m \leq N$ and $i < I_n$
\end{itemize}
are declared as internal.

\subsubsection{Inductive Phase}
In the case of an \emph{input} gate, we use the corresponding input share from the initial phase. In the case of a \emph{not} gate, parties $0,\ldots,N$ simply copy their share of the incoming wire, whereas party $N+1$ negates its share. If the gate is an \emph{xor} gate, the resulting share is the sum of the shares of the incoming two wires. The case of an \emph{and} gate is the most complex. The sum of everybody's shares must equal $\big(x_0 \oplus \ldots \oplus x_{N+1}\big) * \big(y_0 \oplus \ldots \oplus y_{N+1}\big)$, where $x_n,y_n$ are the respective shares of party $n$ on the incoming two wires. We have
\[\big(x_0 \oplus \ldots \oplus x_{N+1}\big) * \big(y_0 \oplus \ldots \oplus y_{N+1}\big) = \bigoplus_i \bigoplus_j x_i * y_j\]
As in the two-party case, parties $n$ and $m$ engage in an idealized 1-Out-Of-4 OT exchange to compute the quantity $(x_n * y_m) \oplus (x_m * y_n)$, again appropriately masked by a random Boolean.\medskip

We again set up our protocol so that each gate induces the same set of outputs, even though some of these channels may not be relevant to the specific gate in question. For wire $K$, the relevant non-adversarial outputs are among the following:
\begin{itemize}
\item $\SendBit(n,m,K)$ for storing the masking Boolean is relevant for an \emph{and} gate when $n < m$,
\item $\RcvdBit(n,m,K)$ for receiving the result of the OT exchange is relevant for an \emph{and} gate when $n < m$,
\item $\Ctrb(n,m,K)$ for storing the contribution of party $m$ to the share of party $n$ is relevant for an \emph{and} gate,
\item $\SumCtrb(n,m,K)$ for summing up the contributions of parties $0,\ldots,m$ to the share of party $n$ is relevant for an \emph{and} gate,
\item $\Share(n,K)$ for storing the share of party $n$ is always relevant
\item $\OTMsg_0(n,m,K)$, $\OTMsg_1(n,m,K)$, $\OTMsg_2(n,m,K)$, $\OTMsg_3(n,m,K)$ for the OT exchange from $n$ to $m$ are relevant for an \emph{and} gate if $n < m$
\item $\OTChc_0(n,m,K)$, $\OTChc_1(n,m,K)$ for the OT exchange from $m$ to $n$ are relevant for an \emph{and} gate if $n > m$.
\end{itemize}

\noindent We define the inductive part of the real protocol a follows:

\begin{itemize}
\item $\Circ_n(\epsilon,0)$ is the protocol $\zero$

\item $\Circ_n\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Circ_n(C,K)$ with the following protocol. Our share is the input share as determined in the initial part of the protocol:
\begin{itemize}
\item $\Share(n,K) \coloneqq \read{\InShare(n,p,i)}$
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{if $n$ honest} \end{cases*}$}
\end{itemize}
As we said earlier, the 1-Out-Of-4 OT exchange with every other party is vacuous -- party $n$ does not function as a sender,
\begin{itemize}
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$ for $m \leq N+1$
\item $\OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)}$ for $m \leq N+1$
\item $\OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)}$ for $m \leq N+1$
\item $\OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)}$ for $m \leq N+1$
\end{itemize}
nor as a receiver:
\begin{itemize}
\item $\OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)}$ for $m \leq N+1$
\item $\OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)}$ for $m \leq N+1$
\end{itemize}
Since no OT exchange is taking place, no masking Boolean is needed:
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $m \leq N+1$
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $m \leq N+1$}
\end{itemize}
There is nothing to receive from the OT functionality:
\begin{itemize}
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $m \leq N+1$
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $m \leq N+1$}
\end{itemize}
The individual contributions of each party to our share are likewise not needed:
\begin{itemize}
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $m \leq N+1$
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $m \leq N+1$}
\end{itemize}
There is thus nothing to sum up:
\begin{itemize}
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $m \leq N+1$
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $m \leq N+1$}
\end{itemize}

\item $\Circ_n\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Circ_n(C,K)$ with the following protocol. Our share is either the share on wire $k$ (for parties $n \leq N$) or its negation (for party $N+1$):
\begin{itemize}
\item $\begin{cases*} \Share(n,K) \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \Share(N+1,K) \coloneqq x_{N+1} \leftarrow \Share(N+1,k); \ \ret{\neg x_{N+1}} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{if $n$ honest} \end{cases*}$}
\end{itemize}
The 1-Out-Of-4 OT exchange with every other party is again vacuous -- party $n$ does not function as a sender,
\begin{itemize}
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$ for $m \leq N+1$
\item $\OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)}$ for $m \leq N+1$
\item $\OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)}$ for $m \leq N+1$
\item $\OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)}$ for $m \leq N+1$
\end{itemize}
nor as a receiver:
\begin{itemize}
\item $\OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)}$ for $m \leq N+1$
\item $\OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)}$ for $m \leq N+1$
\end{itemize}
Since no OT exchange is taking place, no masking Boolean is needed:
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $m \leq N+1$
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $m \leq N+1$}
\end{itemize}
There is nothing to receive from the OT functionality:
\begin{itemize}
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $m \leq N+1$
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $m \leq N+1$}
\end{itemize}
The individual contributions of each party to our share are likewise not needed:
\begin{itemize}
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $m \leq N+1$
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $m \leq N+1$}
\end{itemize}
There is thus nothing to sum up:
\begin{itemize}
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $m \leq N+1$
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $m \leq N+1$}
\end{itemize}

\item $\Circ_n\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Circ_n(C,K)$ with the following protocol. Our share is the sum of shares on wires $k$ and $l$:
\begin{itemize}
\item $\Share(n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n \oplus y_n}$
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{if $n$ honest} \end{cases*}$}
\end{itemize}
The 1-Out-Of-4 OT exchange with every other party is once more vacuous -- party $n$ does not function as a sender,
\begin{itemize}
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$ for $m \leq N+1$
\item $\OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)}$ for $m \leq N+1$
\item $\OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)}$ for $m \leq N+1$
\item $\OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)}$ for $m \leq N+1$
\end{itemize}
nor as a receiver:
\begin{itemize}
\item $\OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)}$ for $m \leq N+1$
\item $\OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)}$ for $m \leq N+1$
\end{itemize}
Since no OT exchange is taking place, no masking Boolean is needed:
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $m \leq N+1$
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $m \leq N+1$}
\end{itemize}
There is nothing to receive from the OT functionality:
\begin{itemize}
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $m \leq N+1$
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $m \leq N+1$}
\end{itemize}
The individual contributions of each party to our share are likewise not needed:
\begin{itemize}
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $m \leq N+1$
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $m \leq N+1$}
\end{itemize}
There is thus nothing to sum up:
\begin{itemize}
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $m \leq N+1$
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $m \leq N+1$}
\end{itemize}

\item $\Circ_n\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Circ_n(C,K)$ with the following protocol. First, for each party $m$ with $n < m$ we generate the masking Boolean for the OT exchange where $n$ is a sender and $m$ is a receiver:
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n \geq m$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n$ semi-honest} \\ \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n$ honest} \end{cases*}$}
\end{itemize}
We now carry out the 1-Out-Of-4 OT exchanges where $n$ is the sender:
\begin{itemize}
\item $\begin{cases*} \OTMsg_0(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n < m$} \\ \OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n \geq m$} \end{cases*}$
\item $\begin{cases*} \OTMsg_1(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n < m$} \\ \OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n \geq m$} \end{cases*}$
\item $\begin{cases*} \OTMsg_2(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus y_n} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n < m$} \\ \OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n \geq m$} \end{cases*}$
\item $\begin{cases*} \OTMsg_3(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n \oplus y_n} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n < m$} \\ \OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n \geq m$} \end{cases*}$
\end{itemize}
Next we carry out the 1-Out-Of-4 OT exchanges where $n$ is the receiver:
\begin{itemize}
\item $\begin{cases*} \OTChc_0(m,n,K) \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $m < n$} \\ \OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $m \geq n$} \end{cases*}$
\item $\begin{cases*} \OTChc_1(m,n,K) \coloneqq \read{\Share(n,l)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $m < n$} \\ \OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $m \geq n$} \end{cases*}$
\end{itemize}
We now record the bits we received from the 1-Out-Of-4 OT exchanges:
\begin{itemize}
\item $\RcvdBit(n,m,K) \coloneqq \OTOut(m,n,K)$ for $m \leq N+1$
\item {\color{blue} $\begin{cases*} \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n$ semi-honest} \\ \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n$ honest} \end{cases*}$}
\end{itemize}
For each party $m$, we compute its contribution to our share as follows:
\begin{itemize}
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\Ctrb(n,m,K)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n$ semi-honest} \\ \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n$ honest} \end{cases*}$}
\end{itemize}
We now inductively sum up the individual contributions we generated above:
\begin{itemize}
\item $\begin{cases*} \SumCtrb(n,0,K) \coloneqq \read{\Ctrb(n,0,K)} \smallskip \\ \SumCtrb(n,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(n,m,K); \ b \leftarrow \Ctrb(n,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $m \leq N$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SumCtrb(n,m,K)} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n$ semi-honest} \\ \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ if $n$ honest} \end{cases*}$}
\end{itemize}
At last, we declare our share to be the total sum of the contributions:
\begin{itemize}
\item $\Share(n,K) \coloneqq \read{\SumCtrb(n,N+1,K)}$
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{if $n$ honest} \end{cases*}$}
\end{itemize}
\end{itemize}
Finally, the channels
\begin{itemize}
\item $\SendBit(n,m,k)$ for $m \leq N+1$ and $k < K$,
\item $\RcvdBit(n,m,k)$ for $m \leq N+1$ and $k < K$,
\item $\Ctrb(n,m,k)$ for $m \leq N+1$ and $k < K$,
\item $\SumCtrb(n,m,k)$ for $m \leq N+1$ and $k < K$
\end{itemize}
are declared as internal.

\subsubsection{The Final Phase}
For each output wire, we broadcast our share:
\begin{itemize}
\item $\begin{cases*} \SendOutShare(m,n,k) \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m \leq N+1$ and $k < K$ if wire $k$ an output} \\ \SendOutShare(m,n,k) \coloneqq \read{\SendOutShare(m,n,k)} \\ \hspace{10pt} \text{for $m \leq N+1$ and $k < K$ if wire $k$ not an output} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\SendOutShare(m,n,k)} \\ \hspace{10pt} \text{for $m \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\LeakSendOutShare(m,n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}
If party $n$ is semi-honest, each output share received is forwarded to the adversary:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SendOutShare(n,m,k)} \\ \hspace{10pt} \text{for $m \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}
The incoming output shares are recorded:
\begin{itemize}
\item $\OutShare(n,m,k) \coloneqq \read{\SendOutShare(n,m,k)}$ for $m \leq N+1$ and $k < K$
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\OutShare(n,m,k)} \\ \hspace{10pt} \text{for $m \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}
We now inductively sum up the output shares we recorded above:
\begin{itemize}
\item $\begin{cases*} \SumOutShare(n,0,k) \coloneqq \read{\OutShare(n,0,k)} \\ \hspace{10pt} \text{for $k < K$} \\ \SumOutShare(n,m+1,k) \coloneqq x_\Sigma \leftarrow \SumOutShare(n,m,k); \ x_{m+1} \leftarrow \OutShare(n,m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m \leq N$ and $k < K$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SumOutShare(n,m,k)} \\ \hspace{10pt} \text{for $m \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}
Finally, we declare the output to be the total sum of the output shares:
\begin{itemize}
\item $\Out(n,k) \coloneqq \read{\SumOutShare(n,N+1,k)}$ for $k < K$
\item {\color{blue} $\begin{cases*} \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $k < K$ if $n$ semi-honest} \\ \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}
Finally, the channels
\begin{itemize}
\item $\OutShare(n,m,k)$ for $m \leq N+1$ and $k < K$,
\item $\SumOutShare(n,-,-)$ for $m \leq N+1$ and $k < K$
\end{itemize}
are declared as internal.

\subsubsection{1-Out-Of-4 Oblivious Transfer Functionality}
For each wire $k < K$ and parties $n,m$ we have a separate idealized 1-Out-Of-4 Oblivious Transfer functionality $\OT(n,m,k)$, where party $n$ is the sender and party $m$ is the receiver.\smallskip

\noindent If the sender is semi-honest, the functionality leaks the value of all messages received from the sender:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,k)^\ot_\adv \coloneqq \read{\OTMsg_0(n,m,k)} \\ \hspace{10pt} \text{if $n$ semi-honest} \\ \LeakOTMsg_0(n,m,k)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,k)^\ot_\adv} \\ \hspace{10pt} \text{if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,k)^\ot_\adv \coloneqq \read{\OTMsg_1(n,m,k)} \\ \hspace{10pt} \text{if $n$ semi-honest} \\ \LeakOTMsg_1(n,m,k)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,k)^\ot_\adv} \\ \hspace{10pt} \text{if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,k)^\ot_\adv \coloneqq \read{\OTMsg_2(n,m,k)} \\ \hspace{10pt} \text{if $n$ semi-honest} \\ \LeakOTMsg_2(n,m,k)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,k)^\ot_\adv} \\ \hspace{10pt} \text{if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,k)^\ot_\adv \coloneqq \read{\OTMsg_3(n,m,k)} \\ \hspace{10pt} \text{if $n$ semi-honest} \\ \LeakOTMsg_3(n,m,k)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,k)^\ot_\adv} \\ \hspace{10pt} \text{if $n$ honest} \end{cases*}$}
\end{itemize}
Otherwise the functionality only lets the adversary know that a message from the sender has been received:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,k)^\ot_\adv \coloneqq m_0 \leftarrow \OTMsg_0(n,m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{if $n$ honest} \\ \LeakOTMsgRcvd_0(n,m,k)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,k)^\ot_\adv} \\ \hspace{10pt} \text{if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,k)^\ot_\adv \coloneqq m_1 \leftarrow \OTMsg_1(n,m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{if $n$ honest} \\ \LeakOTMsgRcvd_1(n,m,k)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,k)^\ot_\adv} \\ \hspace{10pt} \text{if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,k)^\ot_\adv \coloneqq m_2 \leftarrow \OTMsg_2(n,m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{if $n$ honest} \\ \LeakOTMsgRcvd_2(n,m,k)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,k)^\ot_\adv} \\ \hspace{10pt} \text{if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,k)^\ot_\adv \coloneqq m_3 \leftarrow \OTMsg_3(n,m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{if $n$ honest} \\ \LeakOTMsgRcvd_3(n,m,k)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,k)^\ot_\adv} \\ \hspace{10pt} \text{if $n$ semi-honest} \end{cases*}$}
\end{itemize}
Analogously, if the receiver is semi-honest, the functionality leaks the value of all messages from the receiver:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,k)^\ot_\adv \coloneqq \read{\OTChc_0(n,m,k)} \\ \hspace{10pt} \text{if $m$ semi-honest} \\ \LeakOTChc_0(n,m,k)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,k)^\ot_\adv} \\ \hspace{10pt} \text{if $m$ honest}\end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,k)^\ot_\adv \coloneqq \read{\OTChc_1(n,m,k)} \\ \hspace{10pt} \text{if $m$ semi-honest} \\ \LeakOTChc_1(n,m,k)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,k)^\ot_\adv} \\ \hspace{10pt} \text{if $m$ honest} \end{cases*}$}
\end{itemize}
Otherwise the functionality only lets the adversary know that a message from the receiver has been received:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,k)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(n,m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{if $m$ honest} \\ \LeakOTChcRcvd_0(n,m,k)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,k)^\ot_\adv} \\ \hspace{10pt} \text{if $m$ semi-honest}\end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,m,k)^\ot_\adv \coloneqq c_1 \leftarrow \OTChc_1(n,m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{if $m$ honest} \\ \LeakOTChcRcvd_1(n,m,k)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,k)^\ot_\adv} \\ \hspace{10pt} \text{if $m$ semi-honest}\end{cases*}$}
\end{itemize}
The functionality then selects the appropriate message:
\begin{itemize}
\item $\OTOut(n,m,k) \coloneqq m_0 \leftarrow \OTMsg_0(n,m,k); \ m_1 \leftarrow \OTMsg_1(n,m,k); \ m_2 \leftarrow \OTMsg_2(n,m,k); \\ m_3 \leftarrow \OTMsg_3(n,m,k); \ c_0 \leftarrow \OTChc_0(n,m,k); \ c_1 \leftarrow \OTChc_1(n,m,k); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}
If the receiver is semi-honest, the functionality leaks the selected message to the adversary:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,k)^\ot_\adv \coloneqq \read{\OTOut(n,m,k)} \\ \hspace{10pt} \text{if $m$ semi-honest} \\ \LeakOTOut(n,m,k)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,k)^\ot_\adv} \\ \hspace{10pt} \text{if $m$ honest} \end{cases*}$}
\end{itemize}

\subsubsection{The Real Protocol}
The complete code for party $n$ arises as the composition of its initial, inductive, and final phases, followed by the hiding of the communication internal to party $n$ - namely, the channels
\begin{itemize}
\item $\InShare(n,m,i)$ for $m \leq N+1$ and $i < I_m$,
\item $\Share(n,k)$ for $k < K$.
\end{itemize}
The real protocol is a composition of the $N+2$ parties, plus an instance of the circuit-wide OT functionality for each pair of parties $n,m \leq N+1$,
\begin{itemize}
\item $\OT(n,m,k)$ for $k < K$,
\end{itemize}
all followed by the hiding of the internal communication among the two parties and the functionalities -- namely the channels
\begin{itemize}
\item $\SendInShare(m,n,i)$ for $m,n \leq N+1$ and $i < I_n$,
\item $\OTMsg_0(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\OTMsg_1(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\OTMsg_2(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\OTMsg_3(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\OTChc_0(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\OTChc_1(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\OTOut(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\SendOutShare(m,n,k)$ for $m,n \leq N+1$ and $k < K$.
\end{itemize}

\subsection{Real = Ideal + Simulator}
Our goal is to keep simplifying the real protocol until it becomes clear how to extract out a suitable simulator. We first restructure the entire protocol as a composition of an initial part, an inductive part, and a final part, all followed by the hiding of the channels
\begin{itemize}
\item $\InShare(m,n,i)$ for $m,n \leq N+1$ and $i < I_n$,
\item $\Share(n,k)$ for $n \leq N+1$ and $k < K$.
\end{itemize}

\noindent The initial part of the real protocol arises by composing together the respective initial parts for each party, and declaring their communication as internal. Specifically, we have the following protocol $\Init$:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\In(n,i)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakIn(n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq x \leftarrow \In(n,i); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \\ \LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInRcvd(n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \end{cases*}$}
\item $\InShareGen(m,n,i) \coloneqq x \leftarrow \In(n,i); \ \samp{\flip}$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$
\item {\color{blue} $\begin{cases*} \LeakInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShareGen(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item $\begin{cases*} \SumInShareGen(0,n,i) \coloneqq \read{\InShareGen(0,n,i)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$} \\ \SumInShareGen(m+1,n,i) \coloneqq x_\Sigma \leftarrow \SumInShareGen(m,n,i); \ x_{m+1} \leftarrow \InShareGen(m+1,n,i); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$ and $n \leq N+1$ and $i < I_n$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSumInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\SumInShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSumInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSumInShareGen(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item $\InShareGen(N+1,n,i) \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \In(n,i); \ \ret{x_\Sigma \oplus x}$ for $n \leq N+1$ and $i < I_n$ 
\item {\color{blue} $\begin{cases*} \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(N+1,n,i)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShareGen(N+1,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item $\SendInShare(m,n,i) \coloneqq \read{\InShareGen(m,n,i)}$ for $m,n \leq N+1$ and $i < I_n$
\item {\color{blue} $\begin{cases*} \LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\SendInShare(m,n,i)}\\ \hspace{10pt} \text{for $m,n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSendInShare(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\SendInShare(m,n,i)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $i < I_n$ if $m$ semi-honest} \\ \LeakRcvdInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\LeakRcvdInShare(m,n,i)^{\party(m)}_\adv} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $i < I_n$ if $m$ honest} \end{cases*}$}
\item $\InShare(m,n,i) \coloneqq \read{\SendInShare(m,n,i)}$ for $m,n \leq N+1$ and $i < I_n$
\item {\color{blue} $\begin{cases*} \LeakInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\InShare(m,n,i)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $i < I_n$ if $m$ semi-honest} \\ \LeakInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\LeakInShare(m,n,i)^{\party(m)}_\adv} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $i < I_n$ if $m$ honest} \end{cases*}$}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\InShareGen(m,n,i)$ for $m,n \leq N+1$ and $i < I_n$,
\item $\SumInShareGen(m,n,i)$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$,
\item $\SendInShare(m,n,i)$ for $m,n \leq N+1$ and $i < I_n$.
\end{itemize}

\noindent The inductive part of the real protocol arises by composing together the respective inductive parts for each party plus the circuit-wide OT functionalities, and declaring the communication with the OT functionalities as internal. Specifically, we have the following protocol $\Circ(C,K)$:

\begin{itemize}
\item $\Circ(\epsilon,0)$ is the protocol $\zero$

\item $\Circ\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Share(n,K) \coloneqq \read{\InShare(n,p,i)}$ for $n \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)}$ for $n,m \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_0(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_1(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_2(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_3(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq m_0 \leftarrow \OTMsg_0(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq m_1 \leftarrow \OTMsg_1(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq m_2 \leftarrow \OTMsg_2(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq m_3 \leftarrow \OTMsg_3(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}\smallskip
\item $\OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)}$ for $m,n \leq N+1$
\item $\OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)}$ for $m,n \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\OTChc_0(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest}\end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\OTChc_1(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest}\end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(m,n,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_1(m,n,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $m,n \leq N+1$ if $m$ honest} \\ \LeakOTChcRcvd_1(m,n,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(m,n,K)^\ot_\adv} \\ \hspace{10pt} \text{for $m,n \leq N+1$ if $m$ semi-honest}\end{cases*}$}\smallskip
\item $\OTOut(n,m,K) \coloneqq m_0 \leftarrow \OTMsg_0(n,m,K); \ m_1 \leftarrow \OTMsg_1(n,m,K); \ m_2 \leftarrow \OTMsg_2(n,m,K); \\ m_3 \leftarrow \OTMsg_3(n,m,K); \ c_0 \leftarrow \OTChc_0(n,m,K); \ c_1 \leftarrow \OTChc_1(n,m,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$ for $n,m \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\OTOut(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}
\end{itemize}

\item $\Circ\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\begin{cases*} \Share(n,K) \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \Share(N+1,K) \coloneqq x_{N+1} \leftarrow \Share(N+1,k); \ \ret{\neg x_{N+1}} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)}$ for $n,m \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_0(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_1(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_2(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_3(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq m_0 \leftarrow \OTMsg_0(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq m_1 \leftarrow \OTMsg_1(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq m_2 \leftarrow \OTMsg_2(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq m_3 \leftarrow \OTMsg_3(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}\smallskip
\item $\OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)}$ for $m,n \leq N+1$
\item $\OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)}$ for $m,n \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\OTChc_0(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest}\end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\OTChc_1(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \\ \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest}\end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_1(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \\ \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest}\end{cases*}$}\smallskip
\item $\OTOut(n,m,K) \coloneqq m_0 \leftarrow \OTMsg_0(n,m,K); \ m_1 \leftarrow \OTMsg_1(n,m,K); \ m_2 \leftarrow \OTMsg_2(n,m,K); \\ m_3 \leftarrow \OTMsg_3(n,m,K); \ c_0 \leftarrow \OTChc_0(n,m,K); \ c_1 \leftarrow \OTChc_1(n,m,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$ for $n,m \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\OTOut(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}
\end{itemize}

\item $\Circ\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Share(n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n \oplus y_n}$ for $n \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)}$ for $n,m \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_0(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_1(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_2(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_3(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq m_0 \leftarrow \OTMsg_0(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq m_1 \leftarrow \OTMsg_1(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq m_2 \leftarrow \OTMsg_2(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq m_3 \leftarrow \OTMsg_3(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}\smallskip
\item $\OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)}$ for $m,n \leq N+1$
\item $\OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)}$ for $m,n \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\OTChc_0(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest}\end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\OTChc_1(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \\ \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest}\end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_1(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \\ \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest}\end{cases*}$}\smallskip
\item $\OTOut(n,m,K) \coloneqq m_0 \leftarrow \OTMsg_0(n,m,K); \ m_1 \leftarrow \OTMsg_1(n,m,K); \ m_2 \leftarrow \OTMsg_2(n,m,K); \\ m_3 \leftarrow \OTMsg_3(n,m,K); \ c_0 \leftarrow \OTChc_0(n,m,K); \ c_1 \leftarrow \OTChc_1(n,m,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$ for $n,m \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\OTOut(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}
\end{itemize}

\item $\Circ\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\RcvdBit(n,m,K) \coloneqq \OTOut(n,m,K)$ for $n,m \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\Ctrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\begin{cases*} \SumCtrb(n,0,K) \coloneqq \read{\Ctrb(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N+1$} \\ \SumCtrb(n,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(n,m,K); \ b \leftarrow \Ctrb(n,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SumCtrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\Share(n,K) \coloneqq \read{\SumCtrb(n,N+1,K)}$ for $n \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\begin{cases*} \OTMsg_0(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$
\item $\begin{cases*} \OTMsg_1(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$
\item $\begin{cases*} \OTMsg_2(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$
\item $\begin{cases*} \OTMsg_3(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_0(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_1(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_2(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_3(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq m_0 \leftarrow \OTMsg_0(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq m_1 \leftarrow \OTMsg_1(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq m_2 \leftarrow \OTMsg_2(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq m_3 \leftarrow \OTMsg_3(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \\ \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \end{cases*}$}\smallskip
\item $\begin{cases*} \OTChc_0(m,n,K) \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ if $m < n$} \\ \OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ if $m \geq n$} \end{cases*}$
\item $\begin{cases*} \OTChc_1(m,n,K) \coloneqq \read{\Share(n,l)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ if $m \geq n$} \end{cases*}$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\OTChc_0(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest}\end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\OTChc_1(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \\ \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest}\end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq c_1 \leftarrow \OTChc_1(n,m,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \\ \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest}\end{cases*}$}\smallskip
\item $\OTOut(n,m,K) \coloneqq m_0 \leftarrow \OTMsg_0(n,m,K); \ m_1 \leftarrow \OTMsg_1(n,m,K); \ m_2 \leftarrow \OTMsg_2(n,m,K); \\ m_3 \leftarrow \OTMsg_3(n,m,K); \ c_0 \leftarrow \OTChc_0(n,m,K); \ c_1 \leftarrow \OTChc_1(n,m,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$ for $n,m \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\OTOut(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}
\end{itemize}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\SendBit(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\RcvdBit(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\Ctrb(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\SumCtrb(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\OTMsg_0(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\OTMsg_1(n,m,k)$ for $n,m \leq N+1$ and $k < K$
\item $\OTMsg_2(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\OTMsg_3(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\OTChc_0(m,n,k)$ for $m,n \leq N+1$ and $k < K$,
\item $\OTChc_1(m,n,k)$ for $m,n \leq N+1$ and $k < K$,
\item $\OTOut(n,m,k)$ for $n,m \leq N+1$ and $k < K$.
\end{itemize}

\noindent The final part of the real protocol arises by composing together the respective final parts for each party, and declaring their communication as internal. Specifically, we have the following protocol $\Fin$:

\begin{itemize}
\item $\begin{cases*} \SendOutShare(m,n,k) \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $k < K$ if wire $k$ an output} \\ \SendOutShare(m,n,k) \coloneqq \read{\SendOutShare(m,n,k)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $k < K$ if wire $k$ not an output} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\SendOutShare(m,n,k)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\LeakSendOutShare(m,n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SendOutShare(n,m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\item $\OutShare(n,m,k) \coloneqq \read{\SendOutShare(n,m,k)}$ for $n,m \leq N+1$ and $k < K$
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\OutShare(n,m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\item $\begin{cases*} \SumOutShare(n,0,k) \coloneqq \ret{\OutShare(n,0,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$} \\ \SumOutShare(n,m+1,k) \coloneqq x_\Sigma \leftarrow \SumOutShare(n,m,k); \ x_{m+1} \leftarrow \OutShare(n,m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SumOutShare(n,m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\item $\Out(n,k) \coloneqq \read{\SumOutShare(n,N+1,k)}$ for $n \leq N+1$ and $k < K$
\item {\color{blue} $\begin{cases*} \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\OutShare(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\SumOutShare(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\SendOutShare(m,n,k)$ for $m,n \leq N+1$ and $k < K$.
\end{itemize}

\subsubsection{Simplifying The Real Protocol: Initial Phase}
If party $n$ is semi-honest, then for any party $m$ and input $i < I_n$ the channel 
\begin{itemize}
\item {\color{blue} $\LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\SendInShare(m,n,i)}$}
\end{itemize}
reads from the channel
\begin{itemize}
\item $\SendInShare(m,n,i) \coloneqq \read{\InShareGen(m,n,i)}$
\end{itemize}
so we can substitute:
\begin{itemize}
\item {\color{blue} $\LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(m,n,i)}$}
\end{itemize}
We thus get the following for channels $\LeakSendInShare(-,-,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSendInShare(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\end{itemize}
If party $n$ is semi-honest, then for any party $m$ and input $i < I_m$ the channel 
\begin{itemize}
\item {\color{blue} $\LeakRcvdInShare(n,m,i)^{\party(n)}_\adv \coloneqq \read{\SendInShare(n,m,i)}$}
\end{itemize}
reads from the channel
\begin{itemize}
\item $\SendInShare(n,m,i) \coloneqq \read{\InShareGen(n,m,i)}$
\end{itemize}
so we can substitute:
\begin{itemize}
\item {\color{blue} $\LeakRcvdInShare(n,m,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(n,m,i)}$}
\end{itemize}
We thus get the following for channels $\LeakRcvdInShare(-,-,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakRcvdInShare(n,m,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(n,m,i)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $i < I_m$ if $n$ semi-honest} \\ \LeakRcvdInShare(n,m,i)^{\party(n)}_\adv \coloneqq \read{\LeakSendInShare(n,m,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $i < I_m$ if $n$ honest} \end{cases*}$}
\end{itemize}
Finally, substituting the channels
\begin{itemize}
\item $\SendInShare(m,n,i) \coloneqq \read{\InShareGen(m,n,i)}$ for $m,n \leq N+1$ and $i < I_n$
\end{itemize}
into the respective channels
\begin{itemize}
\item $\InShare(m,n,i) \coloneqq \read{\SendInShare(m,n,i)}$ for $m,n \leq N+1$ and $i < I_n$
\end{itemize}
yields the definition below:
\begin{itemize}
\item $\InShare(m,n,i) \coloneqq \read{\InShareGen(m,n,i)}$ for $m,n \leq N+1$ and $i < I_n$
\end{itemize}
At this point, the internal channels $\SendInShare(-,-,-)$ are unused and can be eliminated. The simplified version $\Init$ of the initial part of the real protocol is therefore as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\In(n,i)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakIn(n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq x \leftarrow \In(n,i); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \\ \LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInRcvd(n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \end{cases*}$}
\item $\InShareGen(m,n,i) \coloneqq x \leftarrow \In(n,i); \ \samp{\flip}$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$
\item {\color{blue} $\begin{cases*} \LeakInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShareGen(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item $\begin{cases*} \SumInShareGen(0,n,i) \coloneqq \read{\InShareGen(0,n,i)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$} \\ \SumInShareGen(m+1,n,i) \coloneqq x_\Sigma \leftarrow \SumInShareGen(m,n,i); \ x_{m+1} \leftarrow \InShareGen(m+1,n,i); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$ and $n \leq N+1$ and $i < I_n$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSumInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\SumInShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSumInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSumInShareGen(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item $\InShareGen(N+1,n,i) \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \In(n,i); \ \ret{x_\Sigma \oplus x}$ for $n \leq N+1$ and $i < I_n$ 
\item {\color{blue} $\begin{cases*} \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(N+1,n,i)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShareGen(N+1,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSendInShare(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $i < I_n$ if $m$ semi-honest} \\ \LeakRcvdInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\LeakRcvdInShare(m,n,i)^{\party(m)}_\adv} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $i < I_n$ if $m$ honest} \end{cases*}$}
\item $\InShare(m,n,i) \coloneqq \read{\InShareGen(m,n,i)}$ for $m,n \leq N+1$ and $i < I_n$
\item {\color{blue} $\begin{cases*} \LeakInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\InShare(m,n,i)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $i < I_n$ if $m$ semi-honest} \\ \LeakInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\LeakInShare(m,n,i)^{\party(m)}_\adv} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $i < I_n$ if $m$ honest} \end{cases*}$}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\InShareGen(m,n,i)$ for $m,n \leq N+1$ and $i < I_n$,
\item $\SumInShareGen(m,n,i)$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$.
\end{itemize}

\subsubsection{Simplifying The Real Protocol: Inductive Phase}
Our next order of business is to eliminate all channels interacting with the OT functionalities. In the case of \emph{input-}, \emph{not-}, and \emph{xor} gates, the OT channels are divergent and only appear in the corresponding leakage channels. The leakage channels themselves are therefore divergent. For instance, if party $n$ is semi-honest, for any party $m$ the channel
\begin{itemize}
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_0(n,m,K)}$}
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$
\end{itemize}
and so we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$}
\end{itemize}
The simplified definition for channels $\LeakOTMsg_0(-,-,K)^\ot_\adv$ is thus as follows:
\begin{itemize}
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}
If party $n$ is honest, for any party $m$ the channel
\begin{itemize}
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq m_0 \leftarrow \OTMsg_0(n,m,K); \ \ret{\checkmark}$}
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$
\end{itemize}
and so we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$}
\end{itemize}
The simplified definition for channels $\LeakOTMsgRcvd_0(-,-,K)^\ot_\adv$ is thus as follows:
\begin{itemize}
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}
We treat the receiver channels analogously. For instance, if party $m$ is semi-honest, then for any party $n$ the channel
\begin{itemize}
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\OTChc_0(n,m,K)}$}
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\OTChc_0(n,m,K) \coloneqq \read{\OTChc_0(n,m,K)}$
\end{itemize}
and so we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$}
\end{itemize}
The simplified definition for channels $\LeakOTChc_0(-,-,K)^\ot_\adv$ is thus as follows:
\begin{itemize}
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}
If party $m$ is honest, for any party $n$ the channel
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(n,m,K); \ \ret{\checkmark}$}
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\OTChc_0(n,m,K) \coloneqq \read{\OTChc_0(n,m,K)}$
\end{itemize}
and so we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$}
\end{itemize}
The simplified definition for channels $\LeakOTChcRcvd_0(-,-,K)^\ot_\adv$ is thus as follows:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}
Finally, for any parties $n,m$ the channel
\begin{itemize}
\item $\OTOut(n,m,K) \coloneqq m_0 \leftarrow \OTMsg_0(n,m,K); \ m_1 \leftarrow \OTMsg_1(n,m,K); \ m_2 \leftarrow \OTMsg_2(n,m,K); \\ m_3 \leftarrow \OTMsg_3(n,m,K); \ c_0 \leftarrow \OTChc_0(n,m,K); \ c_1 \leftarrow \OTChc_1(n,m,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$
\end{itemize}
and so we may equivalently write the following:
\begin{itemize}
\item $\OTOut(n,m,K) \coloneqq \read{\OTOut(n,m,K)}$
\end{itemize}
If party $m$ is semi-honest, this in turn means that the channel
\begin{itemize}
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\OTOut(n,m,K)}$}
\end{itemize}
reads from a divergent channel, and so we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$}
\end{itemize}
The simplified definition for channels $\LeakOTOut(-,-,K)^\ot_\adv$ is thus as follows:
\begin{itemize}
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}
In the case of an \emph{and} gate, we start by eliminating any mention of the OT channels from the leakage channels. For instance, if party $n$ is semi-honest, for any party $m$ with $n \geq m$ the channel
\begin{itemize}
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_0(n,m,K)}$}
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$
\end{itemize}
and so we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$}
\end{itemize}
On the other hand, if $n < m$ then the channel
\begin{itemize}
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\OTMsg_0(n,m,K)}$}
\end{itemize}
reads from the channel
\begin{itemize}
\item $\OTMsg_0(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b}$}
\end{itemize}
Summarizing the above, we get the following for channels $\LeakOTMsg_0(-,-,K)^\ot_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\end{itemize}
Analogously for channels $\LeakOTMsg_1(-,-,K)^\ot_\adv$, $\LeakOTMsg_2(-,-,K)^\ot_\adv$, $\LeakOTMsg_3(-,-,K)^\ot_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\end{itemize}
If party $n$ is honest, for any party $m$ with $n \geq m$ the channel
\begin{itemize}
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq m_0 \leftarrow \OTMsg_0(n,m,K); \ \ret{\checkmark}$}
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$
\end{itemize}
and so we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$}
\end{itemize}
On the other hand, if $n < m$ then the channel
\begin{itemize}
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq m_0 \leftarrow \OTMsg_0(n,m,K); \ \ret{\checkmark}$}
\end{itemize}
reads from the channel
\begin{itemize}
\item $\OTMsg_0(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark}$}
\end{itemize}
Summarizing the above, we get the following for channels $\LeakOTMsgRcvd_0(-,-,K)^\ot_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\end{itemize}
Analogously for channels $\LeakOTMsgRcvd_1(-,-,K)^\ot_\adv$, $\LeakOTMsgRcvd_2(-,-,K)^\ot_\adv$, $\LeakOTMsgRcvd_3(-,-,K)^\ot_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\end{itemize}
We treat the receiver channels similarly. For instance, if party $m$ is semi-honest, then for any party $n$ with $n \geq m$ the channel
\begin{itemize}
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\OTChc_0(n,m,K)}$}
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\OTChc_0(n,m,K) \coloneqq \read{\OTChc_0(n,m,K)}$
\end{itemize}
and so we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$}
\end{itemize}
On the other hand, if $n < m$ then the channel
\begin{itemize}
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\OTChc_0(n,m,K)}$}
\end{itemize}
reads from the channel
\begin{itemize}
\item $\OTChc_0(n,m,K) \coloneqq \read{\Share(m,k)}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,k)}$}
\end{itemize}
Summarizing the above, we get the following for channels $\LeakOTChc_0(-,-,K)^\ot_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}
\end{itemize}
Analogously for channels $\LeakOTChc_1(-,-,K)^\ot_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,l)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}
\end{itemize}
If party $m$ is honest, for any party $n$ with $n \geq m$ the channel
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(n,m,K); \ \ret{\checkmark}$}
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\OTChc_0(n,m,K) \coloneqq \read{\OTChc_0(n,m,K)}$
\end{itemize}
and so we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$}
\end{itemize}
On the other hand, if $n < m$ then the channel
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq c_0 \leftarrow \OTChc_0(n,m,K); \ \ret{\checkmark}$}
\end{itemize}
reads from the channel
\begin{itemize}
\item $\OTChc_0(n,m,K) \coloneqq \read{\Share(m,k)}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq x_m \leftarrow \Share(m,k); \ \ret{\checkmark}$}
\end{itemize}
Summarizing the above, we get the following for channels $\LeakOTChcRcvd_0(-,-,K)^\ot_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq x_m \leftarrow \Share(m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\end{itemize}
Analogously for channels $\LeakOTChcRcvd_1(-,-,K)^\ot_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq y_m \leftarrow \Share(m,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\end{itemize}
At last, if party $m$ is semi-honest, for any party $n$ the channel
\begin{itemize}
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\OTOut(n,m,K)}$}
\end{itemize}
has the same definition as the channel
\begin{itemize}
\item $\RcvdBit(m,n,K) \coloneqq \read{\OTOut(n,m,K)}$
\end{itemize}
so we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\RcvdBit(m,n,K)}$}
\end{itemize}
We thus get the following for channels $\LeakOTOut(-,-,K)^\ot_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\RcvdBit(m,n,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}
\end{itemize}
At this point, none of the leakage channels refer to any of the OT channels anymore. So outside of the OT channels themselves, the only place where we still refer to an OT channel is in the channel
\begin{itemize}
\item $\RcvdBit(n,m,K) \coloneqq \OTOut(m,n,K)$
\end{itemize}
that stores the result of the OT exchange between parties $m,n$ with $m$ as a sender and $n$ as a receiver. Substituting the channel
\begin{itemize}
\item $\OTOut(m,n,K) \coloneqq m_0 \leftarrow \OTMsg_0(m,n,K); \ m_1 \leftarrow \OTMsg_1(m,n,K); \ m_2 \leftarrow \OTMsg_2(m,n,K); \\ m_3 \leftarrow \OTMsg_3(m,n,K); \ c_0 \leftarrow \OTChc_0(m,n,K); \ c_1 \leftarrow \OTChc_1(m,n,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}
into the above thus yields the somewhat more verbose
\begin{itemize}
\item $\RcvdBit(n,m,K) \coloneqq m_0 \leftarrow \OTMsg_0(m,n,K); \ m_1 \leftarrow \OTMsg_1(m,n,K); \ m_2 \leftarrow \OTMsg_2(m,n,K); \\ m_3 \leftarrow \OTMsg_3(m,n,K); \ c_0 \leftarrow \OTChc_0(m,n,K); \ c_1 \leftarrow \OTChc_1(m,n,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}
with the advantage that it no longer mentions $\OTOut(m,n,K)$. If $m < n$ we may further substitute the channels
\begin{itemize}
\item $\OTMsg_0(m,n,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \ \ret{b}$
\item $\OTMsg_1(m,n,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \ \ret{b \oplus x_m}$
\item $\OTMsg_2(m,n,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \ \ret{b \oplus y_m}$
\item $\OTMsg_3(m,n,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \ \ret{b \oplus x_m \oplus y_m}$
\end{itemize}
as well as the channels
\begin{itemize}
\item $\OTChc_0(m,n,K) \coloneqq \read{\Share(n,k)}$
\item $\OTChc_1(m,n,K) \coloneqq \read{\Share(n,l)}$
\end{itemize}
to obtain the following:
\begin{itemize}
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \ x_n \leftarrow \Share(n,k); \\ y_n \leftarrow \Share(n,l); \ \ifte{x_n}{\big(\ifte{y_n}{\ret{b \oplus x_m \oplus y_m}}{\ret{b \oplus y_m}}\big)}{\big(\ifte{y_n}{\ret{b \oplus x_m}}{\ret{b}}\big)}$
\end{itemize}
Here we no longer refer to any of the OT channels. We can express the above more concisely as follows:
\begin{itemize}
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$
\end{itemize}
Finally, if $m \geq n$ the channel
\begin{itemize}
\item $\RcvdBit(n,m,K) \coloneqq m_0 \leftarrow \OTMsg_0(m,n,K); \ m_1 \leftarrow \OTMsg_1(m,n,K); \ m_2 \leftarrow \OTMsg_2(m,n,K); \\ m_3 \leftarrow \OTMsg_3(m,n,K); \ c_0 \leftarrow \OTChc_0(m,n,K); \ c_1 \leftarrow \OTChc_1(m,n,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\OTMsg_0(m,n,K) \coloneqq \read{\OTMsg_0(m,n,K)}$
\end{itemize}
so we may equivalently write
\begin{itemize}
\item $\RcvdBit(n,m,K) \coloneqq \RcvdBit(n,m,K)$
\end{itemize}
and further expand the above to
\begin{itemize}
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$
\end{itemize}
since the channel
\begin{itemize}
\item $\SendBit(m,n,K) \coloneqq \read{\SendBit(m,n,K)}$
\end{itemize}
is likewise divergent. Summarizing, we get the following for channels $\RcvdBit(-,-,K)$:
\begin{itemize}
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$ for $n,m \leq N+1$
\end{itemize}
All in all, we can rewrite the inductive part $\Circ(C,K)$ of the real protocol as follows:

\begin{itemize}
\item $\Circ(\epsilon,0)$ is the protocol $\zero$

\item $\Circ\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Share(n,K) \coloneqq \read{\InShare(n,p,i)}$ for $n \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)}$ for $n,m \leq N+1$\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)}$ for $m,n \leq N+1$
\item $\OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)}$ for $m,n \leq N+1$\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\OTOut(n,m,K) \coloneqq \read{\OTOut(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Circ\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\begin{cases*} \Share(n,K) \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \Share(N+1,K) \coloneqq x_{N+1} \leftarrow \Share(N+1,k); \ \ret{\neg x_{N+1}} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)}$ for $n,m \leq N+1$\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)}$ for $m,n \leq N+1$
\item $\OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)}$ for $m,n \leq N+1$\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\OTOut(n,m,K) \coloneqq \read{\OTOut(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Circ\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Share(n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n \oplus y_n}$ for $n \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)}$ for $n,m \leq N+1$\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)}$ for $m,n \leq N+1$
\item $\OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)}$ for $m,n \leq N+1$\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\OTOut(n,m,K) \coloneqq \read{\OTOut(n,m,K)}$ for $n,m \leq N+1$
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Circ\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$ for $n,m \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\Ctrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\begin{cases*} \SumCtrb(n,0,K) \coloneqq \ret{\Ctrb(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N+1$} \\ \SumCtrb(n,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(n,m,K); \ b \leftarrow \Ctrb(n,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SumCtrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\Share(n,K) \coloneqq \read{\SumCtrb(n,N+1,K)}$ for $n \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item $\begin{cases*} \OTMsg_0(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$
\item $\begin{cases*} \OTMsg_1(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$
\item $\begin{cases*} \OTMsg_2(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$
\item $\begin{cases*} \OTMsg_3(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item $\begin{cases*} \OTChc_0(m,n,K) \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ if $m < n$} \\ \OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ if $m \geq n$} \end{cases*}$
\item $\begin{cases*} \OTChc_1(m,n,K) \coloneqq \read{\Share(n,l)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ if $m < n$} \\ \OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)} \\ \hspace{10pt}
 \text{for $m,n \leq N+1$ if $m \geq n$} \end{cases*}$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,l)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq x_m \leftarrow \Share(m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq y_m \leftarrow \Share(m,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item $\OTOut(n,m,K) \coloneqq m_0 \leftarrow \OTMsg_0(n,m,K); \ m_1 \leftarrow \OTMsg_1(n,m,K); \ m_2 \leftarrow \OTMsg_2(n,m,K); \\ m_3 \leftarrow \OTMsg_3(n,m,K); \ c_0 \leftarrow \OTChc_0(n,m,K); \ c_1 \leftarrow \OTChc_1(n,m,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$ for $n,m \leq N+1$\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\RcvdBit(m,n,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}
\end{itemize}
\end{itemize}

\noindent We now split the protocol $\Circ(C,K)$ into three parts. The first protocol $\Shares(C,K)$ performs the computation of shares and is defined as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\InShare(n,p,i)}$ for $n \leq N+1$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$\smallskip
\item $\begin{cases*} \Share(n,K) \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \Share(N+1,K) \coloneqq x_{N+1} \leftarrow \Share(N+1,k); \ \ret{\neg x_{N+1}} \end{cases*}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n \oplus y_n}$ for $n \leq N+1$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$\smallskip
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$ for $n,m \leq N+1$\smallskip
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$
\item $\begin{cases*} \SumCtrb(n,0,K) \coloneqq \read{\Ctrb(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N+1$} \\ \SumCtrb(n,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(n,m,K); \ b \leftarrow \Ctrb(n,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$} \end{cases*}$\smallskip
\item $\Share(n,K) \coloneqq \read{\SumCtrb(n,N+1,K)}$ for $n \leq N+1$
\end{itemize}
\end{itemize}

\noindent The second protocol $\Adv(C,K)$ performs all leakages and is defined as follows:

\begin{itemize}
\item $\Adv(\epsilon,0)$ is the protocol $\zero$

\item $\Adv\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\Ctrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SumCtrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,l)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq x_m \leftarrow \Share(m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq y_m \leftarrow \Share(m,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\RcvdBit(m,n,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}
\end{itemize}
\end{itemize}

\noindent The third protocol $\OT(C,K)$ performs all Oblivious Transfer exchanges and is defined as follows:

\begin{itemize}
\item $\OT(\epsilon,0)$ is the protocol $\zero$

\item $\OT\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\OT(C,K)$ with the protocol
\begin{itemize}
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)}$ for $n,m \leq N+1$\smallskip
\item $\OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)}$ for $m,n \leq N+1$
\item $\OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)}$ for $m,n \leq N+1$\smallskip
\item $\OTOut(n,m,K) \coloneqq \read{\OTOut(n,m,K)}$ for $n,m \leq N+1$
\end{itemize}

\item $\OT\big(C; \, \notgate(k),K+1\big)$ is the composition of $\OT(C,K)$ with the protocol
\begin{itemize}
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)}$ for $n,m \leq N+1$\smallskip
\item $\OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)}$ for $m,n \leq N+1$
\item $\OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)}$ for $m,n \leq N+1$\smallskip
\item $\OTOut(n,m,K) \coloneqq \read{\OTOut(n,m,K)}$ for $n,m \leq N+1$
\end{itemize}

\item $\OT\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\OT(C,K)$ with the protocol
\begin{itemize}
\item $\OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)}$ for $n,m \leq N+1$
\item $\OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)}$ for $n,m \leq N+1$\smallskip
\item $\OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)}$ for $m,n \leq N+1$
\item $\OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)}$ for $m,n \leq N+1$\smallskip
\item $\OTOut(n,m,K) \coloneqq \read{\OTOut(n,m,K)}$ for $n,m \leq N+1$
\end{itemize}

\item $\OT\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\OT(C,K)$ with the protocol
\begin{itemize}
\item $\begin{cases*} \OTMsg_0(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \OTMsg_0(n,m,K) \coloneqq \read{\OTMsg_0(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$
\item $\begin{cases*} \OTMsg_1(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \OTMsg_1(n,m,K) \coloneqq \read{\OTMsg_1(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$
\item $\begin{cases*} \OTMsg_2(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \OTMsg_2(n,m,K) \coloneqq \read{\OTMsg_2(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$
\item $\begin{cases*} \OTMsg_3(n,m,K) \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \OTMsg_3(n,m,K) \coloneqq \read{\OTMsg_3(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$\smallskip
\item $\begin{cases*} \OTChc_0(m,n,K) \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ if $m < n$} \\ \OTChc_0(m,n,K) \coloneqq \read{\OTChc_0(m,n,K)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ if $m \geq n$} \end{cases*}$
\item $\begin{cases*} \OTChc_1(m,n,K) \coloneqq \read{\Share(n,l)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ if $m < n$} \\ \OTChc_1(m,n,K) \coloneqq \read{\OTChc_1(m,n,K)} \\ \hspace{10pt}
 \text{for $m,n \leq N+1$ if $m \geq n$} \end{cases*}$\smallskip
\item $\OTOut(n,m,K) \coloneqq m_0 \leftarrow \OTMsg_0(n,m,K); \ m_1 \leftarrow \OTMsg_1(n,m,K); \ m_2 \leftarrow \OTMsg_2(n,m,K); \\ m_3 \leftarrow \OTMsg_3(n,m,K); \ c_0 \leftarrow \OTChc_0(n,m,K); \ c_1 \leftarrow \OTChc_1(n,m,K); \\ \ifte{c_0}{\big(\ifte{c_1}{\ret{m_3}}{\ret{m_2}}\big)}{\big(\ifte{c_1}{\ret{m_1}}{\ret{m_0}}\big)}$ for $n,m \leq N+1$
\end{itemize}
\end{itemize}

\noindent At this point, none of the channels defined by $\OT(C,K)$ are utilized anywhere outside of $\OT(C,K)$ and as such we may discard this protocol entirely. The inductive part of the real protocol therefore consists of the protocols $\Shares(C,K)$ and $\Adv(C,K)$, followed by the hiding of the channels
\begin{itemize}
\item $\SendBit(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\RcvdBit(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\Ctrb(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\SumCtrb(n,m,k)$ for $n,m \leq N+1$ and $k < K$.
\end{itemize}

\subsubsection{Simplifying The Real Protocol: Final Phase}
If party $n$ is semi-honest and wire $k$ is not an output, then for any party $m$ the channel
\begin{itemize}
\item {\color{blue} $\LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\SendOutShare(m,n,k)}$}
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\SendOutShare(m,n,k) \coloneqq \read{\SendOutShare(m,n,k)}$
\end{itemize}
and thus we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\LeakSendOutShare(m,n,k)^{\party(n)}_\adv}$}
\end{itemize}
If party $n$ is semi-honest and wire $k$ is an output, then for any party $m$ the channel
\begin{itemize}
\item {\color{blue} $\LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\SendOutShare(m,n,k)}$}
\end{itemize}
reads from the channel
\begin{itemize}
\item $\SendOutShare(m,n,k) \coloneqq \read{\Share(n,k)}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item {\color{blue} $\LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\Share(n,k)}$}
\end{itemize}
Summarizing the above, we get the following for channels $\LeakSendOutShare(-,-,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\LeakSendOutShare(m,n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\end{itemize}
If party $n$ is semi-honest and wire $k$ is not an output, then for any party $m$ the channel
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SendOutShare(n,m,k)}$}
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\SendOutShare(n,m,k) \coloneqq \read{\SendOutShare(n,m,k)}$
\end{itemize}
and thus we may again write the following:
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv}$}
\end{itemize}
If party $n$ is semi-honest and wire $k$ is an output, then for any party $m$ the channel
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SendOutShare(n,m,k)}$}
\end{itemize}
reads from the channel
\begin{itemize}
\item $\SendOutShare(n,m,k) \coloneqq \read{\Share(m,k)}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)}$}
\end{itemize}
Summarizing the above, we get the following for channels $\LeakRcvdOutShare(-,-,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SendOutShare(n,m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\end{itemize}
If wire $k < K$ is not an output, then for any parties $n,m$ the channel
\begin{itemize}
\item $\OutShare(n,m,k) \coloneqq \read{\SendOutShare(n,m,k)}$
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\SendOutShare(n,m,k) \coloneqq \read{\SendOutShare(n,m,k)}$
\end{itemize}
and thus we may equivalently write the following:
\begin{itemize}
\item $\OutShare(n,m,k) \coloneqq \read{\OutShare(n,m,k)}$
\end{itemize}
If wire $k < K$ is an output, then for any parties $n,m$ the channel
\begin{itemize}
\item $\OutShare(n,m,k) \coloneqq \read{\SendOutShare(n,m,k)}$
\end{itemize}
reads from the channel
\begin{itemize}
\item $\SendOutShare(n,m,k) \coloneqq \read{\Share(m,k)}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item $\OutShare(n,m,k) \coloneqq \read{\Share(m,k)}$
\end{itemize}
Summarizing the above, we get the following for channels $\OutShare(-,-,-)$:
\begin{itemize}
\item $\begin{cases*} \OutShare(n,m,k) \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if wire $k$ an output} \\ \OutShare(n,m,k) \coloneqq \read{\OutShare(n,m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if wire $k$ not an output} \end{cases*}$
\end{itemize}
At this point, the internal channels $\SendOutShare(-,-,-)$ are unused and can be eliminated. The simplified version $\Fin$ of the final part of the real protocol is therefore as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\LeakSendOutShare(m,n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item $\begin{cases*} \OutShare(n,m,k) \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if wire $k$ an output} \\ \OutShare(n,m,k) \coloneqq \read{\OutShare(n,m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if wire $k$ not an output} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\OutShare(n,m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\item $\begin{cases*} \SumOutShare(n,0,k) \coloneqq \read{\OutShare(n,0,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$} \\ \SumOutShare(n,m+1,k) \coloneqq x_\Sigma \leftarrow \SumOutShare(n,m,k); \ x_{m+1} \leftarrow \OutShare(n,m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SumOutShare(n,m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\item $\Out(n,k) \coloneqq \read{\SumOutShare(n,N+1,k)}$ for $n \leq N+1$ and $k < K$
\item {\color{blue} $\begin{cases*} \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\OutShare(n,m,k)$ for $n,m \leq N+1$ and $k < K$,
\item $\SumOutShare(n,m,k)$ for $n,m \leq N+1$ and $k < K$.
\end{itemize}

\subsubsection{Timing of Shares I}\label{sect:gmwn_timing_1}
Since the last party $N+1$ is by assumption honest, the simulator does not have access to its inputs. Therefore, any computation that depends on the value of the inputs belonging to party $N+1$ must be eliminated. In particular, all shares of party $N+1$ must be eliminated.

By design, summing up the respective shares $\bigoplus_{i \leq N+1} x_i$ of each party on a given wire yields the actual value $x$ carried by the wire. If we got our hands on $x$, for example by inductively computing the circuit the same way the ideal functionality does, we could replace the share $x_{N+1}$ of the last party by the sum $x \oplus \big(\bigoplus_{i \leq N} x_i\big)$ of $x$ and the shares $x_0,\ldots,x_N$. To this end, we introduce new internal channels
\begin{itemize}
\item $\begin{cases*} \SumShare(0,k) \coloneqq \read{\Share(0,k)} \\ \hspace{10pt} \text{for $k < K$} \\ \SumShare(m+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ x_{m+1} \leftarrow \Share(m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$ and $k < K$} \end{cases*}$
\end{itemize}
that inductively compute the the sum of shares for parties $0,\ldots,N$ on each wire $k < K$. For our strategy to work, however, we need to arrange the timing so that party $N+1$ computes its shares after everybody else.\medskip

\noindent To this end, we introduce new internal channels
\begin{itemize}
\item {\color{teal} $\InShareOk(m,n,i) \coloneqq \_ \leftarrow \read{\InShare(m,n,i)}; \ \ret{\checkmark}$ for $m,n \leq N+1$ and $i < I_n$}
\end{itemize}
for the timing of input shares in the initial part of the protocol and
\begin{itemize}
\item {\color{teal} $\ShareOk(n,k) \coloneqq \_ \leftarrow \read{\Share(n,k)}; \ \ret{\checkmark}$ for $n \leq N+1$ and $k < K$}
\end{itemize}
for the timing of shares in the inductive part of the protocol.\medskip

Since the primary job of the simulator is to construct the appropriate leakage, we start by eliminating any mention of the last party's shares from the leakage channels. Upon carefully examining the inductive part of the real protocol, we see that the only place where we leak information depending on the shares of party $N+1$ is when we leak the timing of the party's shares on behalf of the OT functionality in the case of an \emph{and} gate. But even in this case, the \emph{value} of the shares is immaterial - it is only the timing information that matters.\medskip

\noindent Specifically, take the protocol $\Adv(C,K)$ in the case of an \emph{and} gate. For any party $n$ with $n \leq N$ we can write the channels
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq x_{N+1} \leftarrow \Share(N+1,k); \ \ret{\checkmark}$ for $n \leq N$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq y_{N+1} \leftarrow \Share(N+1,l); \ \ret{\checkmark}$ for $n \leq N$}
\end{itemize}
equivalently as follows:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq \read{\ShareOk(N+1,k)}$ for $n \leq N$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq \read{\ShareOk(N+1,l)}$ for $n \leq N$}
\end{itemize}
We thus have the following for channels $\LeakOTChcRcvd_0(-,N+1,K)^\ot_\adv$ and $\LeakOTChcRcvd_1(-,N+1,K)^\ot_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq \read{\ShareOk(N+1,k)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq \read{\ShareOk(N+1,l)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv} \end{cases*}$}
\end{itemize}
So the inductive part of the real protocol now has $\Adv(C,K)$ looking like so:

\begin{itemize}
\item $\Adv(\epsilon,0)$ is the protocol $\zero$

\item $\Adv\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\Ctrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SumCtrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,l)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq x_m \leftarrow \Share(m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq \read{\ShareOk(N+1,k)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq y_m \leftarrow \Share(m,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq \read{\ShareOk(N+1,l)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\RcvdBit(m,n,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}
\end{itemize}
\end{itemize}

\noindent We now amend the shares of party $N+1$ with a gratuitous dependency on timing, which we will later convert into a dependency on the sum of shares of parties $0,\ldots,N$. To this end, we introduce new internal channels
\begin{itemize}
\item {\color{teal} $\InShareGenOk(m,n,i) \coloneqq \_ \leftarrow \read{\InShareGen(m,n,i)}; \ \ret{\checkmark}$ for $m,n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\SumInShareGenOk(m,n,i) \coloneqq \_ \leftarrow \read{\SumInShareGen(m,n,i)}; \ \ret{\checkmark}$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$}
\end{itemize}
to keep track of the timing information in the protocol $\Init$ and
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,k) \coloneqq \_ \leftarrow \SendBit(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\item {\color{teal} $\RcvdBitOk(n,m,k) \coloneqq \_ \leftarrow \RcvdBit(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\item {\color{teal} $\CtrbOk(n,m,k) \coloneqq \_ \leftarrow \Ctrb(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\item {\color{teal} $\SumCtrbOk(n,m,k) \coloneqq \_ \leftarrow \SumCtrb(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\end{itemize}
to keep track of the timing information in the protocol $\Shares(C,K)$. Call the following protocol fragment $\InitOk$:
\begin{itemize}
\item {\color{teal} $\InShareGenOk(m,n,i) \coloneqq \_ \leftarrow \read{\InShareGen(m,n,i)}; \ \ret{\checkmark}$ for $m,n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\SumInShareGenOk(m,n,i) \coloneqq \_ \leftarrow \read{\SumInShareGen(m,n,i)}; \ \ret{\checkmark}$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\InShareOk(m,n,i) \coloneqq \_ \leftarrow \read{\InShare(m,n,i)}; \ \ret{\checkmark}$ for $m,n \leq N+1$ and $i < I_n$}
\end{itemize}
Call the following protocol fragment $\SharesOk(C,K)$:
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,k) \coloneqq \_ \leftarrow \SendBit(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\item {\color{teal} $\RcvdBitOk(n,m,k) \coloneqq \_ \leftarrow \RcvdBit(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\item {\color{teal} $\CtrbOk(n,m,k) \coloneqq \_ \leftarrow \Ctrb(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\item {\color{teal} $\SumCtrbOk(n,m,k) \coloneqq \_ \leftarrow \SumCtrb(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\item {\color{teal} $\ShareOk(n,k) \coloneqq \_ \leftarrow \read{\Share(n,k)}; \ \ret{\checkmark}$ for $n \leq N+1$ and $k < K$}
\end{itemize}

\noindent In the presence of the channels $\InShare(-,-,-)$ as well as the protocol $\SharesOk(C,K)$ we can express the protocol $\Shares(C,K)$ equivalently as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\InShare(n,p,i)}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \InShareOk(N+1,p,i); \ \read{\InShare(N+1,p,i)}$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\Share(n,k)}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \ShareOk(N+1,k); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{\neg x_{N+1}}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n \oplus y_n}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \ShareOk(N+1,k); \ \_ \leftarrow \ShareOk(N+1,l); \ x_{N+1} \leftarrow \Share(N+1,k); \\ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{x_{N+1} \oplus y_{N+1}}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$\smallskip
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$ for $n,m \leq N+1$\smallskip
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$
\item $\begin{cases*} \SumCtrb(n,0,K) \coloneqq \read{\Ctrb(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N+1$} \\ \SumCtrb(n,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(n,m,K); \ b \leftarrow \Ctrb(n,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$} \end{cases*}$\smallskip
\item $\Share(n,K) \coloneqq \read{\SumCtrb(n,N+1,K)}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \SumCtrbOk(N+1,N+1,K); \ \read{\SumCtrb(N+1,N+1,K)}$
\end{itemize}
\end{itemize}

\noindent Clearly, we can make the timing of shares independent of their value; this was the point of introducing the timing channels in the first place. For input shares, the timing only depends on the timing of the corresponding input, so we introduce new internal channels
\begin{itemize}
\item {\color{teal} $\InOk(n,i) \coloneqq \_ \leftarrow \read{\In(n,i)}; \ \ret{\checkmark}$ for $n \leq N+1$ and $i < I_n$}
\end{itemize}
to keep track of whether an input has arrived. For a wire share, the timing depends on the timing of every input that recursively feeds into the wire. We can easily compute this in a new protocol $\WiresOk(C,K)$:

\begin{itemize}
\item $\WiresOk(\epsilon,0)$ is the protocol $\zero$
\item $\WiresOk\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \read{\InOk(p,i)}$}
\end{itemize}
\item $\WiresOk\big(C; \, \notgate(k),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \_ \leftarrow \WireOk(k); \ \ret{\checkmark}$}
\end{itemize}
\item $\WiresOk\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$}
\end{itemize}
\item $\WiresOk\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$}
\end{itemize}
\end{itemize}

\noindent Our goal now is to show that the timing channels can be equivalently characterized as follows:
\begin{itemize}
\item {\color{teal} $\InShareOk(m,n,i) \coloneqq \read{\InOk(n,i)}$ for $m,n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\ShareOk(n,k) \coloneqq \read{\WireOk(k)}$ for $n \leq N+1$ and $k < K$}
\end{itemize}

\noindent In the presence of the channels $\InShareOk(-,-,-)$ as well as the protocol $\Shares(C,K)$ we can define the protocol $\SharesOk(C,K)$ equivalently as follows:

\begin{itemize}
\item $\SharesOk(\epsilon,0)$ is the protocol $\zero$

\item $\SharesOk\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\ShareOk(n,K) \coloneqq \read{\InShareOk(n,p,i)}$ for $n \leq N+1$}
\end{itemize}

\item $\SharesOk\big(C; \, \notgate(k),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\ShareOk(n,K) \coloneqq \read{\ShareOk(n,k)}$ for $n \leq N$}
\item {\color{teal} $\ShareOk(N+1,K) \coloneqq \_ \leftarrow \ShareOk(N+1,k); \ \ret{\checkmark}$}
\end{itemize}

\item $\SharesOk\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\ShareOk(n,K) \coloneqq \_ \leftarrow \ShareOk(n,k); \ \_ \leftarrow \ShareOk(n,l); \ \ret{\checkmark}$ for $n \leq N+1$}
\end{itemize}

\item $\SharesOk\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\begin{cases*} \SendBitOk(n,m,K) \coloneqq \_ \leftarrow \ShareOk(n,k); \ \_ \leftarrow \ShareOk(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$}\smallskip
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \_ \leftarrow \SendBitOk(m,n,K); \ \_ \leftarrow \ShareOk(m,k); \ \_ \leftarrow \ShareOk(m,l); \\ \_ \leftarrow \ShareOk(n,k); \ \_ \leftarrow \ShareOk(n,l); \ \ret{\checkmark}$ for $n,m \leq N+1$}\smallskip
\item {\color{teal} $\begin{cases*}
\CtrbOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \CtrbOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \CtrbOk(n,n,K) \coloneqq \_ \leftarrow \ShareOk(n,k); \ \_ \leftarrow \ShareOk(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$}\smallskip
\item {\color{teal} $\begin{cases*} \SumCtrbOk(n,0,K) \coloneqq \read{\CtrbOk(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N+1$} \\ \SumCtrbOk(n,m+1,K) \coloneqq \_ \leftarrow \SumCtrbOk(n,m,K); \ \_ \leftarrow \CtrbOk(n,m+1,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$} \end{cases*}$}\smallskip
\item {\color{teal} $\ShareOk(n,K) \coloneqq \read{\SumCtrbOk(n,N+1,K)}$ for $n \leq N+1$}
\end{itemize}
\end{itemize}

\noindent We also observe that in the presence of the protocol $\Init$ we can define the protocol $\InitOk$ equivalently as follows:

\begin{itemize}
\item {\color{teal} $\InShareGenOk(m,n,i) \coloneqq \_ \leftarrow \InOk(n,i); \ \ret{\checkmark}$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\begin{cases*} \SumInShareGenOk(0,n,i) \coloneqq \read{\InShareGenOk(0,n,i)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$} \\ \SumInShareGenOk(m+1,n,i) \coloneqq \_ \leftarrow \SumInShareGenOk(m,n,i); \ \_ \leftarrow \InShareGenOk(m+1,n,i); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $m < N$ and $n \leq N+1$ and $i < I_n$} \end{cases*}$}
\item {\color{teal} $\InShareGenOk(N+1,n,i) \coloneqq \_ \leftarrow \SumInShareGenOk(N,n,i); \ \_ \leftarrow \InOk(n,i); \ \ret{\checkmark}$ for $n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\InShareOk(m,n,i) \coloneqq \read{\InShareGenOk(m,n,i)}$ for $m,n \leq N+1$ and $i < I_n$}
\end{itemize}

\noindent Furthermore, in the presence of the channels $\InOk(-,-)$ we can express the protocol $\InitOk$ equivalently as follows:

\begin{itemize}
\item {\color{teal} $\InShareGenOk(m,n,i) \coloneqq \read{\InOk(n,i)}$ for $m,n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\SumInShareGenOk(m,n,i) \coloneqq \read{\InOk(n,i)}$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\InShareOk(m,n,i) \coloneqq \read{\InOk(n,i)}$ for $m,n \leq N+1$ and $i < I_n$}
\end{itemize}

\noindent Lastly, in the presence of the channels $\InShareOk(-,-,-)$ as well as the protocol $\WiresOk(C,K)$ we can express the protocol $\SharesOk(C,K)$ equivalently as the channels
\begin{itemize}
\item {\color{teal} $\ShareOk(n,k) \coloneqq \read{\WireOk(k)}$ for $n \leq N+1$ and $k < K$}
\end{itemize}
together with the following protocol $\CtrbsOk(C,K)$:

\begin{itemize}
\item $\CtrbsOk(\epsilon,0)$ is the protocol $\zero$

\item $\CtrbsOk\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\CtrbsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\end{itemize}

\item $\CtrbsOk\big(C; \, \notgate(k),K+1\big)$ is the composition of $\CtrbsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\end{itemize}

\item $\CtrbsOk\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\CtrbsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\end{itemize}

\item $\CtrbsOk\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\CtrbsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\begin{cases*} \SendBitOk(n,m,K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$}
\item {\color{teal} $\begin{cases*} \RcvdBitOk(n,m,K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m \geq n$} \end{cases*}$}\smallskip
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$ for $n,m \leq N+1$}
\end{itemize}
\end{itemize}

\noindent We now revisit the case of an \emph{and} gate in the protocol $\Adv(C,K)$. For any party $n$ with $n \leq N$ we can write the channels
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq \read{\ShareOk(N+1,k)}$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq \read{\ShareOk(N+1,l)}$}
\end{itemize}
equivalently as follows:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq \read{\WireOk(k)}$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq \read{\WireOk(l)}$}
\end{itemize}
We thus have the following for channels $\LeakOTChcRcvd_0(-,N+1,K)^\ot_\adv$ and $\LeakOTChcRcvd_1(-,N+1,K)^\ot_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq \read{\WireOk(k)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq \read{\WireOk(l)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv} \end{cases*}$}
\end{itemize}
So the inductive part of the real protocol now has $\Adv(C,K)$ looking like so:

\begin{itemize}
\item $\Adv(\epsilon,0)$ is the protocol $\zero$

\item $\Adv\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(m,n,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(m,n,K)^{\party(n)}_\adv}$ for $m,n \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\Ctrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SumCtrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,l)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq x_m \leftarrow \Share(m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq \read{\WireOk(k)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq y_m \leftarrow \Share(m,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq \read{\WireOk(l)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\RcvdBit(m,n,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}
\end{itemize}
\end{itemize}

\noindent Finally, in the presence of the channels $\InShareOk(-,-,-)$, $\ShareOk(-,-)$ and the protocols $\SharesOk$ and $\WiresOk$ we can express the protocol $\Shares(C,K)$ equivalently as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\InShare(n,p,i)}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \WireOk(K); \ \read{\InShare(N+1,p,i)}$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\Share(n,k)}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \WireOk(K); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{\neg x_{N+1}}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n \oplus y_n}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \WireOk(K); \ x_{N+1} \leftarrow \Share(N+1,k); \ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{x_{N+1} \oplus y_{N+1}}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$\smallskip
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$ for $n,m \leq N+1$\smallskip
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$
\item $\begin{cases*} \SumCtrb(n,0,K) \coloneqq \read{\Ctrb(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N+1$} \\ \SumCtrb(n,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(n,m,K); \ b \leftarrow \Ctrb(n,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$} \end{cases*}$\smallskip
\item $\Share(n,K) \coloneqq \read{\SumCtrb(n,N+1,K)}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \WireOk(K); \ \read{\SumCtrb(N+1,N+1,K)}$
\end{itemize}
\end{itemize}

\subsubsection{Timing of Shares II}\label{sect:gmwn_timing_2}
We now revisit the real protocol in the form we had at the beginning of Section \ref{sect:gmwn_timing_1}. We again start by introducing new internal channels
\begin{itemize}
\item $\begin{cases*} \SumShare(0,k) \coloneqq \read{\Share(0,k)} \\ \hspace{10pt} \text{for $k < K$} \\ \SumShare(m+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ x_{m+1} \leftarrow \Share(m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$ and $k < K$} \end{cases*}$
\end{itemize}
that inductively compute the the sum of shares for parties $0,\ldots,N$ on each wire $k < K$.\medskip

\noindent We first consider the protocol $\Adv(C,K)$ in the case of an \emph{and} gate. For any party $n$ with $n \leq N$ we want to write the channels
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq x_{N+1} \leftarrow \Share(N+1,k); \ \ret{\checkmark}$ for $n \leq N$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq y_{N+1} \leftarrow \Share(N+1,l); \ \ret{\checkmark}$ for $n \leq N$}
\end{itemize}
in the form below:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ \ret{\checkmark}$ for $n \leq N$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq y_\Sigma \leftarrow \SumShare(N,l); \ \ret{\checkmark}$ for $n \leq N$}
\end{itemize}
We thus have the following for channels $\LeakOTChcRcvd_0(-,N+1,K)^\ot_\adv$ and $\LeakOTChcRcvd_1(-,N+1,K)^\ot_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq y_\Sigma \leftarrow \SumShare(N,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv} \end{cases*}$}
\end{itemize}
So the inductive part of the real protocol now has $\Adv(C,K)$ looking like so:

\begin{itemize}
\item $\Adv(\epsilon,0)$ is the protocol $\zero$

\item $\Adv\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\Ctrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SumCtrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,l)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq x_m \leftarrow \Share(m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq y_m \leftarrow \Share(m,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq y_\Sigma \leftarrow \SumShare(N,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\RcvdBit(m,n,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}
\end{itemize}
\end{itemize}

\noindent We now amend the shares of party $N+1$ with a gratuitous dependency on the sum of shares of parties $0,\ldots,N$. Specifically, we modify the protocol $\Shares(C,K)$ as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\InShare(n,p,i)}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ \read{\InShare(N+1,p,i)}$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\Share(n,k)}$
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{\neg x_{N+1}}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n \oplus y_n}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \Share(N+1,k); \\ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{x_{N+1} \oplus y_{N+1}}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$\smallskip
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$ for $n,m \leq N+1$\smallskip
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$
\item $\begin{cases*} \SumCtrb(n,0,K) \coloneqq \read{\Ctrb(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N+1$} \\ \SumCtrb(n,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(n,m,K); \ b \leftarrow \Ctrb(n,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$} \end{cases*}$\smallskip
\item $\Share(n,K) \coloneqq \read{\SumCtrb(n,N+1,K)}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ \read{\SumCtrb(N+1,N+1,K)}$
\end{itemize}
\end{itemize}

\noindent It is not at all clear that the aforementioned amendments of $\Adv(C,K)$ and $\Shares(C,K)$ are sound. In the rest of this section we justify their soundness. We start by introducing the channels
\begin{itemize}
\item {\color{teal} $\InShareOk(m,n,i) \coloneqq \_ \leftarrow \read{\InShare(m,n,i)}; \ \ret{\checkmark}$ for $m,n \leq N+1$ and $i < I_n$}
\end{itemize}
for the timing of input shares in the initial part of the protocol and
\begin{itemize}
\item {\color{teal} $\ShareOk(n,k) \coloneqq \_ \leftarrow \read{\Share(n,k)}; \ \ret{\checkmark}$ for $n \leq N+1$ and $k < K$}
\end{itemize}
for the timing of shares in the inductive part of the protocol. In addition, we introduce the channels
\begin{itemize}
\item {\color{teal} $\SumShareOk(m,k) \coloneqq \_ \leftarrow \read{\SumShare(m,k)}; \ \ret{\checkmark}$ for $m \leq N$ and $k < K$}
\end{itemize}
for the timing of the sum of shares.\medskip

\noindent Take the protocol $\Adv(C,K)$ in the case of an \emph{and} gate. For any party $n$ with $n \leq N$ we can write the channels
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ \ret{\checkmark}$ for $n \leq N$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq y_\Sigma \leftarrow \SumShare(N,l); \ \ret{\checkmark}$ for $n \leq N$}
\end{itemize}
equivalently as follows:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq \read{\SumShareOk(N,k)}$ for $n \leq N$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq \read{\SumShareOk(N,l)}$ for $n \leq N$}
\end{itemize}
We thus have the following for channels $\LeakOTChcRcvd_0(-,N+1,K)^\ot_\adv$ and $\LeakOTChcRcvd_1(-,N+1,K)^\ot_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq \read{\SumShareOk(N,k)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq \read{\SumShareOk(N,l)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv} \end{cases*}$}
\end{itemize}
So the inductive part of the real protocol now has $\Adv(C,K)$ looking like so:

\begin{itemize}
\item $\Adv(\epsilon,0)$ is the protocol $\zero$

\item $\Adv\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\Ctrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SumCtrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,l)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq x_m \leftarrow \Share(m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq \read{\SumShareOk(N,k)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq y_m \leftarrow \Share(m,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq \read{\SumShareOk(N,l)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\RcvdBit(m,n,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}
\end{itemize}
\end{itemize}

We now amend the shares of party $N+1$ further: in the presence of the channels $\SumShareOk(-,-)$ we can turn the gratuitous dependency on the sum of shares of parties $0,\ldots, N$ into a dependency on the corresponding timing channel. Specifically, we can express the protocol $\Shares(C,K)$ equivalently as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\InShare(n,p,i)}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \SumShareOk(N,K); \ \read{\InShare(N+1,p,i)}$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\Share(n,k)}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \SumShareOk(N,K); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{\neg x_{N+1}}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n \oplus y_n}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \SumShareOk(N,K); \ x_{N+1} \leftarrow \Share(N+1,k); \\ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{x_{N+1} \oplus y_{N+1}}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$\smallskip
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$ for $n,m \leq N+1$\smallskip
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$
\item $\begin{cases*} \SumCtrb(n,0,K) \coloneqq \read{\Ctrb(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N+1$} \\ \SumCtrb(n,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(n,m,K); \ b \leftarrow \Ctrb(n,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$} \end{cases*}$\smallskip
\item $\Share(n,K) \coloneqq \read{\SumCtrb(n,N+1,K)}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \SumShareOk(N,K); \ \read{\SumCtrb(N+1,N+1,K)}$
\end{itemize}
\end{itemize}

\noindent We now carry out largely the same steps as before to make the timing of shares independent of their value. To this end, we introduce new internal channels
 \begin{itemize}
\item {\color{teal} $\InOk(n,i) \coloneqq \_ \leftarrow \read{\In(n,i)}; \ \ret{\checkmark}$ for $n \leq N+1$ and $i < I_n$}
\end{itemize}
to keep track of whether an input has arrived, and a new protocol $\WiresOk(C,K)$ that keeps track of the timing of wire shares:

\begin{itemize}
\item $\WiresOk(\epsilon,0)$ is the protocol $\zero$
\item $\WiresOk\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \read{\InOk(p,i)}$}
\end{itemize}
\item $\WiresOk\big(C; \, \notgate(k),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \_ \leftarrow \WireOk(k); \ \ret{\checkmark}$}
\end{itemize}
\item $\WiresOk\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$}
\end{itemize}
\item $\WiresOk\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\WiresOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\WireOk(K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$}
\end{itemize}
\end{itemize}

\noindent Our goal is again to show that the timing channels can be equivalently characterized as follows:
\begin{itemize}
\item {\color{teal} $\InShareOk(m,n,i) \coloneqq \read{\InOk(n,i)}$ for $m,n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\ShareOk(n,k) \coloneqq \read{\WireOk(k)}$ for $n \leq N+1$ and $k < K$}
\end{itemize}
To this end, we introduce new internal channels
\begin{itemize}
\item {\color{teal} $\InShareGenOk(m,n,i) \coloneqq \_ \leftarrow \read{\InShareGen(m,n,i)}; \ \ret{\checkmark}$ for $m,n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\SumInShareGenOk(m,n,i) \coloneqq \_ \leftarrow \read{\SumInShareGen(m,n,i)}; \ \ret{\checkmark}$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$}
\end{itemize}
to keep track of the timing information in the protocol $\Init$ and
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,k) \coloneqq \_ \leftarrow \SendBit(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\item {\color{teal} $\RcvdBitOk(n,m,k) \coloneqq \_ \leftarrow \RcvdBit(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\item {\color{teal} $\CtrbOk(n,m,k) \coloneqq \_ \leftarrow \Ctrb(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\item {\color{teal} $\SumCtrbOk(n,m,k) \coloneqq \_ \leftarrow \SumCtrb(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\end{itemize}
to keep track of the timing information in the protocol $\Shares(C,K)$. Call the following protocol fragment $\InitOk$:
\begin{itemize}
\item {\color{teal} $\InShareGenOk(m,n,i) \coloneqq \_ \leftarrow \read{\InShareGen(m,n,i)}; \ \ret{\checkmark}$ for $m,n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\SumInShareGenOk(m,n,i) \coloneqq \_ \leftarrow \read{\SumInShareGen(m,n,i)}; \ \ret{\checkmark}$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\InShareOk(m,n,i) \coloneqq \_ \leftarrow \read{\InShare(m,n,i)}; \ \ret{\checkmark}$ for $m,n \leq N+1$ and $i < I_n$}
\end{itemize}
Call the following protocol fragment $\SharesOk(C,K)$:
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,k) \coloneqq \_ \leftarrow \SendBit(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\item {\color{teal} $\RcvdBitOk(n,m,k) \coloneqq \_ \leftarrow \RcvdBit(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\item {\color{teal} $\CtrbOk(n,m,k) \coloneqq \_ \leftarrow \Ctrb(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\item {\color{teal} $\SumCtrbOk(n,m,k) \coloneqq \_ \leftarrow \SumCtrb(n,m,k); \ \ret{\checkmark}$ for $n,m \leq N+1$ and $k < K$}
\item {\color{teal} $\ShareOk(n,k) \coloneqq \_ \leftarrow \read{\Share(n,k)}; \ \ret{\checkmark}$ for $n \leq N+1$ and $k < K$}
\end{itemize}

\noindent First we observe that in the presence of the channels $\SumShare(-,-)$ and $\ShareOk(-,-)$ we can express the channels
\begin{itemize}
\item {\color{teal} $\SumShareOk(m,k) \coloneqq \_ \leftarrow \read{\SumShare(m,k)}; \ \ret{\checkmark}$ for $m \leq N$ and $k < K$}
\end{itemize}
equivalently as follows:
\begin{itemize}
\item {\color{teal} $\begin{cases*} \SumShareOk(0,k) \coloneqq \read{\ShareOk(0,k)} \\ \hspace{10pt} \text{for $k < K$} \\ \SumShareOk(m+1,k) \coloneqq \_ \leftarrow \SumShareOk(m,k); \ \_ \leftarrow \ShareOk(m+1,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $m < N$ and $k < K$} \end{cases*}$}
\end{itemize}

\noindent We further observe that in the presence of the channels $\InShareOk(-,-,-)$ and the protocol $\Shares(C,K)$ we can express the protocol $\SharesOk(C,K)$ equivalently as follows:

\begin{itemize}
\item $\SharesOk(\epsilon,0)$ is the protocol $\zero$

\item $\SharesOk\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\ShareOk(n,K) \coloneqq \read{\InShareOk(n,p,i)}$ for $n \leq N$}
\item {\color{teal} $\ShareOk(N+1,K) \coloneqq \_ \leftarrow \SumShareOk(N,K); \ \read{\InShareOk(N+1,p,i)}$}
\end{itemize}

\item $\SharesOk\big(C; \, \notgate(k),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal}$\ShareOk(n,K) \coloneqq \read{\ShareOk(n,k)}$ for $n \leq N$}
\item {\color{teal}$\ShareOk(N+1,K) \coloneqq \_ \leftarrow \SumShareOk(N,K); \ \_ \leftarrow \ShareOk(N+1,k); \ \ret{\checkmark}$}
\end{itemize}

\item $\SharesOk\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\ShareOk(n,K) \coloneqq \_ \leftarrow \ShareOk(n,k); \ \_ \leftarrow \ShareOk(n,l); \ \ret{\checkmark}$ for $n \leq N$}
\item {\color{teal} $\ShareOk(N+1,K) \coloneqq \_ \leftarrow \SumShareOk(N,K); \ \_ \leftarrow \ShareOk(N+1,k); \ \_ \leftarrow \ShareOk(N+1,l); \ \ret{\checkmark}$}
\end{itemize}

\item $\SharesOk\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\begin{cases*} \SendBitOk(n,m,K) \coloneqq \_ \leftarrow \ShareOk(n,k); \ \_ \leftarrow \ShareOk(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$}\smallskip
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \_ \leftarrow \SendBitOk(m,n,K); \ \_ \leftarrow \ShareOk(m,k); \ \_ \leftarrow \ShareOk(m,l); \\ \_ \leftarrow \ShareOk(n,k); \ \_ \leftarrow \ShareOk(n,l); \ \ret{\checkmark}$ for $n,m \leq N+1$}\smallskip
\item {\color{teal} $\begin{cases*} \CtrbOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \CtrbOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \CtrbOk(n,n,K) \coloneqq \_ \leftarrow \ShareOk(n,k); \ \_ \leftarrow \ShareOk(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$}
\item {\color{teal} $\begin{cases*} \SumCtrbOk(n,0,K) \coloneqq \read{\CtrbOk(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N+1$} \\ \SumCtrbOk(n,m+1,K) \coloneqq \_ \leftarrow \SumCtrbOk(n,m,K); \ \_ \leftarrow \CtrbOk(n,m+1,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$} \end{cases*}$}\smallskip
\item {\color{teal} $\ShareOk(n,K) \coloneqq \read{\SumCtrbOk(n,N+1,K)}$ for $n \leq N$}
\item {\color{teal} $\ShareOk(N+1,K) \coloneqq \_ \leftarrow \SumShareOk(N,K); \ \read{\SumCtrbOk(N+1,N+1,K)}$}
\end{itemize}
\end{itemize}

\noindent We also observe that in the presence of the protocol $\Init$ we can define the protocol $\InitOk$ equivalently as follows:

\begin{itemize}
\item {\color{teal} $\InShareGenOk(m,n,i) \coloneqq \_ \leftarrow \InOk(n,i); \ \ret{\checkmark}$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\begin{cases*} \SumInShareGenOk(0,n,i) \coloneqq \read{\InShareGenOk(0,n,i)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$} \\ \SumInShareGenOk(m+1,n,i) \coloneqq \_ \leftarrow \SumInShareGenOk(m,n,i); \ \_ \leftarrow \InShareGenOk(m+1,n,i); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $m < N$ and $n \leq N+1$ and $i < I_n$} \end{cases*}$}
\item {\color{teal} $\InShareGenOk(N+1,n,i) \coloneqq \_ \leftarrow \SumInShareGenOk(N,n,i); \ \_ \leftarrow \InOk(n,i); \ \ret{\checkmark}$ for $n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\InShareOk(m,n,i) \coloneqq \read{\InShareGenOk(m,n,i)}$ for $m,n \leq N+1$ and $i < I_n$}
\end{itemize}

\noindent Furthermore, in the presence of the channels $\InOk(-,-)$ we can express the protocol $\InitOk$ equivalently as follows:

\begin{itemize}
\item {\color{teal} $\InShareGenOk(m,n,i) \coloneqq \read{\InOk(n,i)}$ for $m,n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\SumInShareGenOk(m,n,i) \coloneqq \read{\InOk(n,i)}$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$}
\item {\color{teal} $\InShareOk(m,n,i) \coloneqq \read{\InOk(n,i)}$ for $m,n \leq N+1$ and $i < I_n$}
\end{itemize}

\noindent We can now merge the channels
\begin{itemize}
\item {\color{teal} $\begin{cases*} \SumShareOk(0,k) \coloneqq \read{\ShareOk(0,k)} \\ \hspace{10pt} \text{for $k < K$} \\ \SumShareOk(m+1,k) \coloneqq \_ \leftarrow \SumShareOk(m,k); \ \_ \leftarrow \ShareOk(m+1,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $m < N$ and $k < K$} \end{cases*}$}
\end{itemize}
with the protocol $\SharesOk(C,K)$ to obtain the following new form of the protocol $\SharesOk(C,K)$:

\begin{itemize}
\item $\SharesOk(\epsilon,0)$ is the protocol $\zero$

\item $\SharesOk\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\ShareOk(n,K) \coloneqq \read{\InShareOk(n,p,i)}$ for $n \leq N$}\smallskip
\item {\color{teal} $\begin{cases*} \SumShareOk(0,k) \coloneqq \read{\ShareOk(0,k)} \\ \hspace{10pt} \text{for $k < K$} \\ \SumShareOk(m+1,k) \coloneqq \_ \leftarrow \SumShareOk(m,k); \ \_ \leftarrow \ShareOk(m+1,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $m < N$ and $k < K$} \end{cases*}$}\smallskip
\item {\color{teal} $\ShareOk(N+1,K) \coloneqq \_ \leftarrow \SumShareOk(N,K); \ \read{\InShareOk(N+1,p,i)}$}
\end{itemize}

\item $\SharesOk\big(C; \, \notgate(k),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal}$\ShareOk(n,K) \coloneqq \read{\ShareOk(n,k)}$ for $n \leq N$}\smallskip
\item {\color{teal} $\begin{cases*} \SumShareOk(0,k) \coloneqq \read{\ShareOk(0,k)} \\ \hspace{10pt} \text{for $k < K$} \\ \SumShareOk(m+1,k) \coloneqq \_ \leftarrow \SumShareOk(m,k); \ \_ \leftarrow \ShareOk(m+1,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $m < N$ and $k < K$} \end{cases*}$}\smallskip
\item {\color{teal}$\ShareOk(N+1,K) \coloneqq \_ \leftarrow \SumShareOk(N,K); \ \_ \leftarrow \ShareOk(N+1,k); \ \ret{\checkmark}$}
\end{itemize}

\item $\SharesOk\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\ShareOk(n,K) \coloneqq \_ \leftarrow \ShareOk(n,k); \ \_ \leftarrow \ShareOk(n,l); \ \ret{\checkmark}$ for $n \leq N$}\smallskip
\item {\color{teal} $\begin{cases*} \SumShareOk(0,k) \coloneqq \read{\ShareOk(0,k)} \\ \hspace{10pt} \text{for $k < K$} \\ \SumShareOk(m+1,k) \coloneqq \_ \leftarrow \SumShareOk(m,k); \ \_ \leftarrow \ShareOk(m+1,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $m < N$ and $k < K$} \end{cases*}$}\smallskip
\item {\color{teal} $\ShareOk(N+1,K) \coloneqq \_ \leftarrow \SumShareOk(N,K); \ \_ \leftarrow \ShareOk(N+1,k); \ \_ \leftarrow \ShareOk(N+1,l); \ \ret{\checkmark}$}
\end{itemize}

\item $\SharesOk\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\SharesOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\begin{cases*} \SendBitOk(n,m,K) \coloneqq \_ \leftarrow \ShareOk(n,k); \ \_ \leftarrow \ShareOk(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$}\smallskip
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \_ \leftarrow \SendBitOk(m,n,K); \ \_ \leftarrow \ShareOk(m,k); \ \_ \leftarrow \ShareOk(m,l); \\ \_ \leftarrow \ShareOk(n,k); \ \_ \leftarrow \ShareOk(n,l); \ \ret{\checkmark}$ for $n,m \leq N+1$}\smallskip
\item {\color{teal} $\begin{cases*} \CtrbOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \CtrbOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \CtrbOk(n,n,K) \coloneqq \_ \leftarrow \ShareOk(n,k); \ \_ \leftarrow \ShareOk(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$}
\item {\color{teal} $\begin{cases*} \SumCtrbOk(n,0,K) \coloneqq \read{\CtrbOk(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N+1$} \\ \SumCtrbOk(n,m+1,K) \coloneqq \_ \leftarrow \SumCtrbOk(n,m,K); \ \_ \leftarrow \CtrbOk(n,m+1,K); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$} \end{cases*}$}\smallskip
\item {\color{teal} $\ShareOk(n,K) \coloneqq \read{\SumCtrbOk(n,N+1,K)}$ for $n \leq N$}\smallskip
\item {\color{teal} $\begin{cases*} \SumShareOk(0,k) \coloneqq \read{\ShareOk(0,k)} \\ \hspace{10pt} \text{for $k < K$} \\ \SumShareOk(m+1,k) \coloneqq \_ \leftarrow \SumShareOk(m,k); \ \_ \leftarrow \ShareOk(m+1,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $m < N$ and $k < K$} \end{cases*}$}\smallskip
\item {\color{teal} $\ShareOk(N+1,K) \coloneqq \_ \leftarrow \SumShareOk(N,K); \ \read{\SumCtrbOk(N+1,N+1,K)}$}
\end{itemize}
\end{itemize}

\noindent In the presence of the channels $\InShareOk(-,-,-)$ as well as the protocol $\WiresOk(C,K)$ we can express the protocol $\SharesOk(C,K)$ equivalently as the channels
\begin{itemize}
\item {\color{teal} $\ShareOk(n,k) \coloneqq \read{\WireOk(k)}$ for $n \leq N+1$ and $k < K$}
\item {\color{teal} $\SumShareOk(m,k) \coloneqq \read{\WireOk(k)}$ for $m \leq N$ and $k < K$}
\end{itemize}
together with the following protocol $\CtrbsOk(C,K)$:

\begin{itemize}
\item $\CtrbsOk(\epsilon,0)$ is the protocol $\zero$

\item $\CtrbsOk\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\CtrbsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\end{itemize}

\item $\CtrbsOk\big(C; \, \notgate(k),K+1\big)$ is the composition of $\CtrbsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $m,n \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\end{itemize}

\item $\CtrbsOk\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\CtrbsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)}$ for $m,n \leq N+1$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \read{\CtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \read{\SumCtrbOk(n,m,K)}$ for $n,m \leq N+1$}
\end{itemize}

\item $\CtrbsOk\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\CtrbsOk(C,K)$ with the protocol
\begin{itemize}
\item {\color{teal} $\begin{cases*} \SendBitOk(n,m,K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBitOk(n,m,K) \coloneqq \read{\SendBitOk(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$}
\item {\color{teal} $\begin{cases*} \RcvdBitOk(n,m,K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \RcvdBitOk(n,m,K) \coloneqq \read{\RcvdBitOk(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m \geq n$} \end{cases*}$}
\item {\color{teal} $\CtrbOk(n,m,K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$ for $n,m \leq N+1$}
\item {\color{teal} $\SumCtrbOk(n,m,K) \coloneqq \_ \leftarrow \WireOk(k); \ \_ \leftarrow \WireOk(l); \ \ret{\checkmark}$ for $n,m \leq N+1$}
\end{itemize}
\end{itemize}

\noindent We now revisit the case of an \emph{and} gate in the protocol $\Adv(C,K)$. For any party $n$ with $n \leq N$ we can write the channels
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq \read{\SumShareOk(N,k)}$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq \read{\SumShareOk(N,l)}$}
\end{itemize}
equivalently as follows:
\begin{itemize}
\item {\color{blue} $\LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq \read{\WireOk(k)}$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq \read{\WireOk(l)}$}
\end{itemize}
We thus have the following for channels $\LeakOTChcRcvd_0(-,N+1,K)^\ot_\adv$ and $\LeakOTChcRcvd_1(-,N+1,K)^\ot_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq \read{\WireOk(k)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq \read{\WireOk(l)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv} \end{cases*}$}
\end{itemize}
So the inductive part of the real protocol now has $\Adv(C,K)$ looking like so:

\begin{itemize}
\item $\Adv(\epsilon,0)$ is the protocol $\zero$

\item $\Adv\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\Ctrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SumCtrb(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest} \\ \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n \oplus y_n} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,l)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq x_m \leftarrow \Share(m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq \read{\WireOk(k)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq y_m \leftarrow \Share(m,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq \read{\WireOk(l)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\RcvdBit(m,n,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ semi-honest} \\ \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m$ honest} \end{cases*}$}
\end{itemize}
\end{itemize}

\noindent Finally, in the presence of the channels $\SumShareOk(-,-)$ we can characterize the protocol $\Shares(C,K)$ equivalently as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\InShare(n,p,i)}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \WireOk(K); \ \read{\InShare(N+1,p,i)}$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\Share(n,k)}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \WireOk(K); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{\neg x_{N+1}}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n \oplus y_n}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \WireOk(K); \ x_{N+1} \leftarrow \Share(N+1,k); \ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{x_{N+1} \oplus y_{N+1}}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$\smallskip
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$ for $n,m \leq N+1$\smallskip
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$
\item $\begin{cases*} \SumCtrb(n,0,K) \coloneqq \read{\Ctrb(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N+1$} \\ \SumCtrb(n,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(n,m,K); \ b \leftarrow \Ctrb(n,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$} \end{cases*}$\smallskip
\item $\Share(n,K) \coloneqq \read{\SumCtrb(n,N+1,K)}$ for $n \leq N$
\item $\Share(N+1,K) \coloneqq \_ \leftarrow \WireOk(K); \ \read{\SumCtrb(N+1,N+1,K)}$
\end{itemize}
\end{itemize}

\noindent At this point, the channels $\SumShareOk(-,-)$ are unused and we can eliminate them. The resulting real protocol is identical to the form of the real protocol we had at the end of Section \ref{sect:gmwn_timing_1}, which justifies the amendments to $\Adv(C,K)$ and $\Shares(C,K)$ we made at the beginning of this section.

\subsubsection{Sum Of Shares}
We continue to simplify the real protocol after amending $\Adv(C,K)$ and $\Shares(C,K)$ as indicated in Section \ref{sect:gmwn_timing_2}.

\noindent Recall the channels
\begin{itemize}
\item $\begin{cases*} \SumShare(0,k) \coloneqq \read{\Share(0,k)} \\ \hspace{10pt} \text{for $k < K$} \\ \SumShare(m+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ x_{m+1} \leftarrow \Share(m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$ and $k < K$} \end{cases*}$
\end{itemize}
that inductively compute the the sum of shares for parties $0,\ldots,N$ on each wire $k < K$. To also include the shares of party $N+1$, we add new internal channels as follows:
\begin{itemize}
\item $\SumShare(N+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{x_\Sigma \oplus x_{N+1}}$ for $k < K$
\end{itemize}

\noindent We now revisit the final part of the real protocol. If party $n$ is semi-honest and wire $k$ is not an output, then for any party $m$ the channel
\begin{itemize}
\item {\color{blue} $\LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\OutShare(n,m,k)}$}
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\OutShare(n,m,k) \coloneqq \read{\OutShare(n,m,k)}$
\end{itemize}
and thus we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,m,k)^{\party(n)}_\adv}$}
\end{itemize}
If party $n$ is semi-honest and wire $k$ is an output, then for any party $m$ the channel
\begin{itemize}
\item {\color{blue} $\LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\OutShare(n,m,k)}$}
\end{itemize}
reads from the channel
\begin{itemize}
\item $\OutShare(n,m,k) \coloneqq \read{\Share(m,k)}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item {\color{blue} $\LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)}$}
\end{itemize}
Summarizing the above, we get the following for channels $\LeakOutShare(-,-,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\end{itemize}
If wire $k$ is not an output, then we can rewrite the channels
\begin{itemize}
\item $\begin{cases*} \SumOutShare(n,0,k) \coloneqq \read{\OutShare(n,0,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$} \\ \SumOutShare(n,m+1,k) \coloneqq x_\Sigma \leftarrow \SumOutShare(n,m,k); \ x_{m+1} \leftarrow \OutShare(n,m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$} \end{cases*}$
\end{itemize}
to the following:
\begin{itemize}
\item $\SumOutShare(n,m,k) \coloneqq \read{\SumOutShare(n,m,k)}$ for $n,m \leq N+1$
\end{itemize}
If wire $k$ is an output, then we can rewrite the channels
\begin{itemize}
\item $\begin{cases*} \SumOutShare(n,0,k) \coloneqq \read{\OutShare(n,0,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$} \\ \SumOutShare(n,m+1,k) \coloneqq x_\Sigma \leftarrow \SumOutShare(n,m,k); \ x_{m+1} \leftarrow \OutShare(n,m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$} \end{cases*}$
\end{itemize}
to the following:
\begin{itemize}
\item $\SumOutShare(n,m,k) \coloneqq \read{\SumShare(m,k)}$ for $n,m \leq N+1$
\end{itemize}
Summarizing the above, we get the following for channels $\SumOutShare(-,-,-)$:
\begin{itemize}
\item $\begin{cases*} \SumOutShare(n,m,k) \coloneqq \read{\SumShare(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $k$ an output} \\ \SumOutShare(n,m,k) \coloneqq \read{\SumOutShare(n,m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $k$ not an output} \end{cases*}$
\end{itemize}
If party $n$ is semi-honest and wire $k$ is not an output, then for any party $m$ the channel
\begin{itemize}
\item {\color{blue} $\LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SumOutShare(n,m,k)}$}
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\SumOutShare(n,m,k) \coloneqq \read{\SumOutShare(n,m,k)}$
\end{itemize}
and thus we may equivalently write the following:
\begin{itemize}
\item {\color{blue} $\LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,m,k)^{\party(n)}_\adv}$}
\end{itemize}
If party $n$ is semi-honest and wire $k$ is an output, then for any party $m$ the channel
\begin{itemize}
\item {\color{blue} $\LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SumOutShare(n,m,k)}$}
\end{itemize}
reads from the channel
\begin{itemize}
\item $\SumOutShare(n,m,k) \coloneqq \read{\SumShare(m,k)}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item {\color{blue} $\LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SumShare(m,k)}$}
\end{itemize}
Summarizing the above, we get the following for channels $\LeakSumOutShare(-,-,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SumShare(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\end{itemize}
Finally, we can express the channels
\begin{itemize}
\item $\Out(n,k) \coloneqq \read{\SumOutShare(n,N+1,k)}$ for $n \leq N+1$
\end{itemize}
equivalently as follows:
\begin{itemize}
\item $\begin{cases*} \Out(n,k) \coloneqq \read{\SumShare(N+1,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $k$ an output} \\ \Out(n,k) \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $k$ not an output} \end{cases*}$
\end{itemize}
At this point, the internal channels $\OutShare(-,-,-)$ and $\SumOutShare(-,-,-)$ are unused and can be eliminated. The simplified version $\Fin$ of the final part of the real protocol is therefore as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\LeakSendOutShare(m,n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m,n \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SumShare(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item $\begin{cases*} \Out(n,k) \coloneqq \read{\SumShare(N+1,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $k$ an output} \\ \Out(n,k) \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $k$ not an output} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}

\noindent We now show that for each wire, the respective shares of all parties add up to the value carried by the wire. At the same time we express the shares of party $N+1$ in a closed form, as the sum of shares of parties $0,\ldots,N$ plus the value on the wire. We proceed by an induction on circuits: in the presence of the protocol $\Init$ and the channels
\begin{itemize}
\item $\begin{cases*} \SumShare(0,k) \coloneqq \read{\Share(0,k)} \\ \hspace{10pt} \text{for $k < K$} \\ \SumShare(m+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ x_{m+1} \leftarrow \Share(m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$ and $k < K$} \end{cases*}$
\end{itemize}
we can express the channels
\begin{itemize}
\item $\SumShare(N+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{x_\Sigma \oplus x_{N+1}}$ for $k < K$
\end{itemize}
together with the protocol $\Shares(C,K)$ equivalently as the channels
\begin{itemize}
\item $\Share(N+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \SumShare(N+1,k); \ \ret{x_\Sigma \oplus x}$ for $k < K$
\end{itemize}
together with the following new form of the protocol $\Shares(C,K)$:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\InShare(n,p,i)}$ for $n \leq N$
\item $\SumShare(N+1,K) \coloneqq \read{\In(p,i)}$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\Share(n,k)}$ for $n \leq N$
\item $\SumShare(N+1,K) \coloneqq x \leftarrow \SumShare(N+1,k); \ \ret{\neg x}$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n \oplus y_n}$ for $n \leq N$
\item $\SumShare(N+1,K) \coloneqq x \leftarrow \SumShare(N+1,k); \ y \leftarrow \SumShare(N+1,l); \ \ret{x \oplus y}$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$\smallskip
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$ for $n,m \leq N+1$\smallskip
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$
\item $\begin{cases*} \SumCtrb(n,0,K) \coloneqq \read{\Ctrb(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N+1$} \\ \SumCtrb(n,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(n,m,K); \ b \leftarrow \Ctrb(n,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$} \end{cases*}$\smallskip
\item $\Share(n,K) \coloneqq \read{\SumCtrb(n,N+1,K)}$ for $n \leq N$
\item $\SumShare(N+1,K) \coloneqq x \leftarrow \SumShare(N+1,k); \ y \leftarrow \SumShare(N+1,l); \ \ret{x * y}$
\end{itemize}
\end{itemize}

\noindent To see why this works, we consider each gate in turn.
\begin{itemize}
\item In the case of an \emph{input} gate, we start by substituting the inductive form of the channel
\begin{itemize}
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ \read{\InShare(N+1,p,i)}$
\end{itemize}
into the closed form of the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \Share(N+1,K); \ \ret{x_\Sigma \oplus x_{N+1}}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \InShare(N+1,p,i); \ \ret{x_\Sigma \oplus x_{N+1}}$
\end{itemize}
By canceling out two applications of $x_\Sigma \oplus -$ we can reformulate the channel $\Share(N+1,K)$ as follows:
\begin{itemize}
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \InShare(N+1,p,i); \ \ret{x_\Sigma \oplus (x_\Sigma \oplus x_{N+1})}$
\end{itemize}
The above can be expressed more concisely as
\begin{itemize}
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x \leftarrow \SumShare(N+1,K); \ \ret{x_\Sigma \oplus x}$
\end{itemize}
and this is the desired closed form of the channel $\Share(N+1,K)$.

We can now turn our attention to the sum of shares. In the presence of the  channels
\begin{itemize}
\item $\Share(m,K) \coloneqq \read{\InShare(m,p,i)}$ for $m \leq N$
\end{itemize}
and the channels
\begin{itemize}
\item $\InShare(m,p,i) \coloneqq \read{\InShareGen(m,p,i)}$ for $m \leq N$\smallskip
\item $\begin{cases*} \SumInShareGen(0,p,i) \coloneqq \read{\InShareGen(0,p,i)} \smallskip \\ \SumInShareGen(m+1,p,i) \coloneqq x_\Sigma \leftarrow \SumInShareGen(m,p,i); \ x_{m+1} \leftarrow \InShareGen(m+1,p,i); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\end{itemize}
from the protocol $\Init$ we can rewrite the inductive form of the channels
\begin{itemize}
\item $\begin{cases*} \SumShare(0,K) \coloneqq \read{\Share(0,K)}\smallskip \\ \SumShare(m+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(m,K); \ x_{m+1} \leftarrow \Share(m+1,K); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\end{itemize}
to the following closed form:
\begin{itemize}
\item $\SumShare(m,K) \coloneqq \read{\SumInShareGen(m,p,i)}$ for $m \leq N$
\end{itemize}
Substituting the channel $\SumShare(N,K)$ into the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \InShare(N+1,p,i); \ \ret{x_\Sigma \oplus x_{N+1}}$
\end{itemize}
thus yields the following:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,p,i); \ x_{N+1} \leftarrow \InShare(N+1,p,i); \ \ret{x_\Sigma \oplus x_{N+1}}$
\end{itemize}
At this point, we rewrite the closed form of the channels
\begin{itemize}
\item $\SumShare(m,K) \coloneqq \read{\SumInShareGen(m,p,i)}$ for $m \leq N$
\end{itemize}
back to their original inductive form:
\begin{itemize}
\item $\begin{cases*} \SumShare(0,K) \coloneqq \read{\Share(0,K)}\smallskip \\ \SumShare(m+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(m,K); \ x_{m+1} \leftarrow \Share(m+1,K); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\end{itemize}
In the presence of the channels
\begin{itemize}
\item $\InShare(N+1,p,i) \coloneqq \read{\InShareGen(N+1,p,i)}$
\item $\InShareGen(N+1,p,i) \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,p,i); \ x \leftarrow \In(p,i); \ \ret{x_\Sigma \oplus x}$
\end{itemize}
from the protocol $\Init$ we can further write the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,p,i); \ x_{N+1} \leftarrow \InShare(N+1,p,i); \ \ret{x_\Sigma \oplus x_{N+1}}$
\end{itemize}
equivalently as follows:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,p,i); \ x \leftarrow \In(p,i); \ \ret{x_\Sigma \oplus (x_\Sigma \oplus x)}$
\end{itemize}
We can cancel out the two applications of $x_\Sigma \oplus -$:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,p,i); \ \read{\In(p,i)}$
\end{itemize}
This is almost what we want except for the extra dependency on the channel $\SumInShareGen(N,p,i)$. To remove this dependency, we introduce new internal channels as follows:
\begin{itemize}
\item {\color{teal} $\InOk(p,i) \coloneqq \_ \leftarrow \read{\In(p,i)}; \ \ret{\checkmark}$}
\item {\color{teal} $\InShareGenOk(m,p,i) \coloneqq \_ \leftarrow \read{\InShareGen(m,p,i)}; \ \ret{\checkmark}$ for $m \leq N$}
\item {\color{teal} $\SumInShareGenOk(m,p,i) \coloneqq \_ \leftarrow \read{\SumInShareGen(m,p,i)}; \ \ret{\checkmark}$ for $m \leq N$}
\end{itemize}
In the presence of the channel $\SumInShareGenOk(N,p,i)$ we can write the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,p,i); \ \read{\In(p,i)}$
\end{itemize}
equivalently as follows:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq \_ \leftarrow \SumInShareGenOk(N,p,i); \ 
\read{\In(p,i)}$
\end{itemize}
We can characterize the timing channels $\InShareGenOk(-,p,i)$, $\SumInShareGenOk(-,p,i)$ equivalently as follows:
\begin{itemize}
\item {\color{teal} $\InShareGenOk(m,p,i) \coloneqq \_ \leftarrow \InOk(p,i); \ \ret{\checkmark}$ for $m \leq N$}\smallskip
\item {\color{teal} $\begin{cases*} \SumInShareGenOk(0,p,i) \coloneqq \read{\InShareGenOk(0,p,i)} \smallskip \\ \SumInShareGenOk(m+1,p,i) \coloneqq \_ \leftarrow \SumInShareGenOk(m,p,i); \ \_ \leftarrow \InShareGenOk(m+1,p,i); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$}
\end{itemize}
Furthermore, we can write the above form of the timing channels equivalently as follows:
\begin{itemize}
\item {\color{teal} $\InShareGenOk(m,p,i) \coloneqq \read{\InOk(p,i)}$ for $m \leq N$}
\item {\color{teal} $\SumInShareGenOk(m,p,i) \coloneqq \read{\InOk(p,i)}$ for $m \leq N$}
\end{itemize}
In the presence of the channel $\SumInShareGenOk(N,p,i)$ we can thus write the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq \_ \leftarrow \SumInShareGenOk(N,p,i); \ 
\read{\In(p,i)}$
\end{itemize}
equivalently as follows:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq \_ \leftarrow \InOk(p,i); \ 
\read{\In(p,i)}$
\end{itemize}
In the presence of the channel $\InOk(p,i)$ we can rewrite the above to the following:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq \read{\In(p,i)}$
\end{itemize}
But this is precisely the desired inductive form of the channel $\SumShare(N+1,K)$.

The channels $\InOk(p,i)$, $\InShareGenOk(-,p,i)$, $\SumInShareGenOk(-,p,i)$ are now unused and can be discarded.

\item In the case of a \emph{not} gate, we start by substituting the inductive form of the channel
\begin{itemize}
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{\neg x_{N+1}}$
\end{itemize}
into the closed form of the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \Share(N+1,K); \ \ret{x_\Sigma \oplus x_{N+1}}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{x_\Sigma \oplus (\neg x_{N+1})}$
\end{itemize}
By canceling out two applications of $x_\Sigma \oplus -$ we can reformulate the channel $\Share(N+1,K)$ as follows:
\begin{itemize}
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{x_\Sigma \oplus (x_\Sigma \oplus (\neg x_{N+1}))}$
\end{itemize}
The above can be expressed more concisely as
\begin{itemize}
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x \leftarrow \SumShare(N+1,K); \ \ret{x_\Sigma \oplus x}$
\end{itemize}
and this is the desired closed form of the channel $\Share(N+1,K)$.

We can now turn our attention to the sum of shares. In the presence of the channels
\begin{itemize}
\item $\Share(m,K) \coloneqq \read{\Share(m,k)}$ for $m \leq N$
\end{itemize}
and the channels
\begin{itemize}
\item $\begin{cases*} \SumShare(0,k) \coloneqq \read{\Share(0,k)} \smallskip \\ \SumShare(m+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ x_{m+1} \leftarrow \Share(m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\end{itemize}
we can rewrite the inductive form of the channels
\begin{itemize}
\item $\begin{cases*} \SumShare(0,K) \coloneqq \read{\Share(0,K)}\smallskip \\ \SumShare(m+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(m,K); \ x_{m+1} \leftarrow \Share(m+1,K); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\end{itemize}
to the following closed form:
\begin{itemize}
\item $\SumShare(m,K) \coloneqq \read{\SumShare(m,k)}$ for $m \leq N$
\end{itemize}
Substituting the channel $\SumShare(N,K)$ into the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{x_\Sigma \oplus (\neg x_{N+1})}$
\end{itemize}
thus yields the following:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{x_\Sigma \oplus (\neg x_{N+1})}$
\end{itemize}
At this point, we rewrite the closed form of the channels
\begin{itemize}
\item $\SumShare(m,K) \coloneqq \read{\SumShare(m,k)}$ for $m \leq N$
\end{itemize}
back to their original inductive form:
\begin{itemize}
\item $\begin{cases*} \SumShare(0,K) \coloneqq \read{\Share(0,K)}\smallskip \\ \SumShare(m+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(m,K); \ x_{m+1} \leftarrow \Share(m+1,K); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\end{itemize}
The negation in the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{x_\Sigma \oplus (\neg x_{N+1})}$
\end{itemize}
can be brought to the top level:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{\neg (x_\Sigma \oplus x_{N+1})}$
\end{itemize}
But this is precisely what we get if we substitute the channel
\begin{itemize}
\item $\SumShare(N+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{x_\Sigma \oplus x_{N+1}}$ \emph{(inductive hypothesis)}
\end{itemize}
into the desired inductive form of the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x \leftarrow \SumShare(N+1,k); \ \ret{\neg x}$
\end{itemize}
so we are done.

\item In the case of an \emph{xor} gate, we start by substituting the inductive form of the channel
\begin{itemize}
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \Share(N+1,k); \\ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{x_{N+1} \oplus y_{N+1}}$
\end{itemize}
into the closed form of the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \Share(N+1,K); \ \ret{x_\Sigma \oplus x_{N+1}}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \Share(N+1,k); \\ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{x_\Sigma \oplus (x_{N+1} \oplus y_{N+1})}$
\end{itemize}
By canceling out two applications of $x_\Sigma \oplus -$ we can reformulate the channel $\Share(N+1,K)$ as follows:
\begin{itemize}
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \Share(N+1,k); \\ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{x_\Sigma \oplus \big(x_\Sigma \oplus (x_{N+1} \oplus y_{N+1})\big)}$
\end{itemize}
The above can be expressed more concisely as
\begin{itemize}
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x \leftarrow \SumShare(N+1,K); \ \ret{x_\Sigma \oplus x}$
\end{itemize}
and this is the desired closed form of the channel $\Share(N+1,K)$.

We can now turn our attention to the sum of shares. In the presence of the channels
\begin{itemize}
\item $\Share(m,K) \coloneqq x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \ \ret{x_m \oplus y_m}$ for $m \leq N$
\end{itemize}
and the channels
\begin{itemize}
\item $\begin{cases*} \SumShare(0,k) \coloneqq \read{\Share(0,k)} \smallskip \\ \SumShare(m+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ x_{m+1} \leftarrow \Share(m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\item $\begin{cases*} \SumShare(0,l) \coloneqq \read{\Share(0,l)} \smallskip \\ \SumShare(m+1,l) \coloneqq y_\Sigma \leftarrow \SumShare(m,l); \ y_{m+1} \leftarrow \Share(m+1,l); \ \ret{y_\Sigma \oplus y_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\end{itemize}
we can rewrite the inductive form of the channels
\begin{itemize}
\item $\begin{cases*} \SumShare(0,K) \coloneqq \read{\Share(0,K)}\smallskip \\ \SumShare(m+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(m,K); \ x_{m+1} \leftarrow \Share(m+1,K); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\end{itemize}
to the following closed form:
\begin{itemize}
\item $\SumShare(m,K) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ y_\Sigma \leftarrow \SumShare(m,l); \ \ret{x_\Sigma \oplus y_\Sigma}$ for $m \leq N$
\end{itemize}
In the base case, we substitute the channel
\begin{itemize}
\item $\Share(0,K) \coloneqq x_0 \leftarrow \Share(0,k); \ y_0 \leftarrow \Share(0,l); \ \ret{x_0 \oplus y_0}$
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\SumShare(0,K) \coloneqq \Share(0,K)$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\SumShare(0,K) \coloneqq x_0 \leftarrow \Share(0,k); \ y_0 \leftarrow \Share(0,l); \ \ret{x_0 \oplus y_0}$
\end{itemize}
But this is precisely what we get if we substitute the channels
\begin{itemize}
\item $\SumShare(0,k) \coloneqq x_0 \leftarrow \Share(0,k); \ \ret{x_0}$
\item $\SumShare(0,l) \coloneqq y_0 \leftarrow \Share(0,l); \ \ret{y_0}$
\end{itemize}
into the closed form of the channel
\begin{itemize}
\item $\SumShare(0,K) \coloneqq x_\Sigma \leftarrow \SumShare(0,k); \ y_\Sigma \leftarrow \SumShare(0,l); \ \ret{x_\Sigma \oplus y_\Sigma}$
\end{itemize}
Hence the inductive form and the closed form of the channel $\SumShare(0,K)$ are equivalent.

In the inductive case, we substitute the channels
\begin{itemize}
\item $\SumShare(m,K) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ y_\Sigma \leftarrow \SumShare(m,l); \ \ret{x_\Sigma \oplus y_\Sigma}$ \emph{(inductive hypothesis)}
\item $\Share(m+1,K) \coloneqq x_{m+1} \leftarrow \Share(m+1,k); \ y_{m+1} \leftarrow \Share(m+1,l); \ \ret{x_{m+1} \oplus y_{m+1}}$
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\SumShare(m+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(m,K); \ x_{m+1} \leftarrow \Share(m+1,K); \ \ret{x_\Sigma \oplus x_{m+1}}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\SumShare(m+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ y_\Sigma \leftarrow \SumShare(m,l); \\ x_{m+1} \leftarrow \Share(m+1,k); \ y_{m+1} \leftarrow \Share(m+1,l); \ \ret{(x_\Sigma \oplus y_\Sigma) \oplus (x_{m+1} \oplus y_{m+1})}$
\end{itemize}
After a slight rearrangement we get the following:
\begin{itemize}
\item $\SumShare(m+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ x_{m+1} \leftarrow \Share(m+1,k); \\ y_\Sigma \leftarrow \SumShare(m,l); \ y_{m+1} \leftarrow \Share(m+1,l); \ \ret{(x_\Sigma \oplus x_{m+1}) \oplus (y_\Sigma \oplus y_{m+1})}$
\end{itemize}
But this is precisely what we get if we substitute the channels
\begin{itemize}
\item $\SumShare(m+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ x_{m+1} \leftarrow \Share(m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}}$
\item $\SumShare(m+1,l) \coloneqq y_\Sigma \leftarrow \SumShare(m,l); \ y_{m+1} \leftarrow \Share(m+1,l); \ \ret{y_\Sigma \oplus y_{m+1}}$
\end{itemize}
into the closed form of the channel
\begin{itemize}
\item $\SumShare(m+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(m+1,k); \ y_\Sigma \leftarrow \SumShare(m+1,l); \ \ret{x_\Sigma \oplus y_\Sigma}$
\end{itemize}
Hence the inductive form and the closed form of the channel $\SumShare(m+1,K)$ are equivalent.

Substituting the channel
\begin{itemize}
\item $\SumShare(N,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ y_\Sigma \leftarrow \SumShare(N,l); \ \ret{x_\Sigma \oplus y_\Sigma}$
\end{itemize}
into the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \Share(N+1,k); \\ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{x_\Sigma \oplus (x_{N+1} \oplus y_{N+1})}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ y_\Sigma \leftarrow \SumShare(N,l); \\ x_{N+1} \leftarrow \Share(N+1,k); \ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{(x_\Sigma \oplus y_\Sigma) \oplus (x_{N+1} \oplus y_{N+1})}$
\end{itemize}
At this point, we rewrite the closed form of the channels
\begin{itemize}
\item $\SumShare(m,K) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ y_\Sigma \leftarrow \SumShare(m,l); \ \ret{x_\Sigma \oplus y_\Sigma}$ for $m \leq N$
\end{itemize}
back to their original inductive form:
\begin{itemize}
\item $\begin{cases*} \SumShare(0,K) \coloneqq \read{\Share(0,K)}\smallskip \\ \SumShare(m+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(m,K); \ x_{m+1} \leftarrow \Share(m+1,K); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\end{itemize}
After a slight rearrangement of the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ y_\Sigma \leftarrow \SumShare(N,l); \\ x_{N+1} \leftarrow \Share(N+1,k); \ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{(x_\Sigma \oplus y_\Sigma) \oplus (x_{N+1} \oplus y_{N+1})}$
\end{itemize}
we get the following:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x_{N+1} \leftarrow \Share(N+1,k); \\ y_\Sigma \leftarrow \SumShare(N,l); \ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{(x_\Sigma \oplus x_{N+1}) \oplus (y_\Sigma \oplus y_{N+1})}$
\end{itemize}
But this is precisely what we get if we substitute the channels
\begin{itemize}
\item $\SumShare(N+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{x_\Sigma \oplus x_{N+1}}$ \emph{(inductive hypothesis)}
\item $\SumShare(N+1,l) \coloneqq y_\Sigma \leftarrow \SumShare(N,l); \ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{y_\Sigma \oplus y_{N+1}}$ \emph{(inductive hypothesis)}
\end{itemize}
into the desired inductive form of the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x \leftarrow \SumShare(N+1,k); \ y \leftarrow \SumShare(N+1,l); \ \ret{x \oplus y}$
\end{itemize}
so we are done.

\item In the case of an \emph{and} gate, we start by substituting the inductive form of the channel
\begin{itemize}
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ \read{\SumCtrb(N+1,N+1,K)}$
\end{itemize}
into the closed form of the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \Share(N+1,K); \ \ret{x_\Sigma \oplus x_{N+1}}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \SumCtrb(N+1,N+1,K); \ \ret{x_\Sigma \oplus x_{N+1}}$
\end{itemize}
By canceling out two applications of $x_\Sigma \oplus -$ we can reformulate the channel $\Share(N+1,K)$ as follows:
\begin{itemize}
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \SumCtrb(N+1,N+1,K); \ \ret{x_\Sigma \oplus (x_\Sigma \oplus x_{N+1})}$
\end{itemize}
The above can be expressed more concisely as
\begin{itemize}
\item $\Share(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x \leftarrow \SumShare(N+1,K); \ \ret{x_\Sigma \oplus x}$
\end{itemize}
and this is the desired closed form of the channel $\Share(N+1,K)$.

We can now turn our attention to the sum of shares. For each party $n$, the share $\Share(n,K)$ is a sum of the $N+2$ contributions $\Ctrb(n,0,K),\ldots,\Ctrb(n,N+1,K)$. So when performing the sum of shares, we are summing up the table of contributions $\{\Ctrb(i,j,K) \}_{i,j \leq N+1}$ by columns. To make this structure explicit, we introduce new internal channels
\begin{itemize}
\item $\Col(i,j) \coloneqq \SumCtrb(i,j,K)$ for $i,j \leq N+1$
\end{itemize}
that record the sum of the $j+1$ contributions $\Ctrb(i,0,K),\ldots,\Ctrb(i,j,K)$. Additionally, we introduce new internal channels
\begin{itemize}
\item $\begin{cases*} \SumCol(0,j) \coloneqq \read{\Col(0,j)} \\ \hspace{10pt} \text{for $j \leq N+1$} \\ \SumCol(i+1,j) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_{i+1} \leftarrow \Col(i+1,j); \ \ret{b_\Sigma \oplus b_{i+1}} \\ \hspace{10pt} \text{for $i \leq N$ and $j \leq N+1$} \end{cases*}$
\end{itemize}
that record the sum of the $i+1$ columns $\Col(0,j),\ldots,\Col(i,j)$ of length $j+1$.

In the presence of the channels
\begin{itemize}
\item $\Share(m,K) \coloneqq \read{\SumCtrb(m,N+1,K)}$ for $m \leq N$
\end{itemize}
and the channels
\begin{itemize}
\item $\Col(m,N+1) \coloneqq \SumCtrb(m,N+1,K)$ for $m \leq N$\smallskip
\item $\begin{cases*} \SumCol(0,N+1) \coloneqq \read{\Col(0,N+1)} \smallskip \\ \SumCol(m+1,N+1) \coloneqq x_\Sigma \leftarrow \SumCol(m,N+1); \ x_{m+1} \leftarrow \Col(m+1,N+1); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\end{itemize}
we can rewrite the inductive form of the channels
\begin{itemize}
\item $\begin{cases*} \SumShare(0,K) \coloneqq \read{\Share(0,K)}\smallskip \\ \SumShare(m+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(m,K); \ x_{m+1} \leftarrow \Share(m+1,K); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\end{itemize}
to the following closed form:
\begin{itemize}
\item $\SumShare(m,K) \coloneqq \read{\SumCol(m,N+1)}$ for $m \leq N$
\end{itemize}
Substituting the channel $\SumShare(N,K)$ into the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(N,K); \ x_{N+1} \leftarrow \SumCtrb(N+1,N+1,K); \ \ret{x_\Sigma \oplus x_{N+1}}$
\end{itemize}
thus yields the following:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumCol(N,N+1); \ x_{N+1} \leftarrow \SumCtrb(N+1,N+1,K); \ \ret{x_\Sigma \oplus x_{N+1}}$
\end{itemize}
At this point, we rewrite the closed form of the channels
\begin{itemize}
\item $\SumShare(m,K) \coloneqq \read{\SumCol(m,N+1)}$ for $m \leq N$
\end{itemize}
back to their original inductive form:
\begin{itemize}
\item $\begin{cases*} \SumShare(0,K) \coloneqq \read{\Share(0,K)}\smallskip \\ \SumShare(m+1,K) \coloneqq x_\Sigma \leftarrow \SumShare(m,K); \ x_{m+1} \leftarrow \Share(m+1,K); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\end{itemize}
In the presence of the channels
\begin{itemize}
\item $\Col(N+1,N+1) \coloneqq \SumCtrb(N+1,N+1,K)$
\item $\SumCol(N+1,N+1) \coloneqq x_\Sigma \leftarrow \SumCol(N,N+1); \ x_{N+1} \leftarrow \Col(N+1,N+1); \ \ret{x_\Sigma \oplus x_{N+1}}$
\end{itemize}
we can further write the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x_\Sigma \leftarrow \SumCol(N,N+1); \ x_{N+1} \leftarrow \SumCtrb(N+1,N+1,K); \ \ret{x_\Sigma \oplus x_{N+1}}$
\end{itemize}
equivalently as follows:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq \read{\SumCol(N+1,N+1)}$
\end{itemize}
In the presence of the channels
\begin{itemize}
\item $\begin{cases*} \SumCtrb(i,0,K) \coloneqq \read{\Ctrb(i,0,K)} \\ \hspace{10pt} \text{for $i \leq N+1$} \\ \SumCtrb(i,j+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(i,j,K); \ b_{j+1} \leftarrow \Ctrb(i,j+1,K); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $i \leq N+1$ and $j \leq N$} \end{cases*}$
\end{itemize}
we can rewrite the closed form of the channels
\begin{itemize}
\item $\Col(i,j) \coloneqq \SumCtrb(i,j,K)$ for $i,j \leq N+1$
\end{itemize}
to the following inductive form:
\begin{itemize}
\item $\begin{cases*} \Col(i,0) \coloneqq \read{\Ctrb(i,0,K)} \\ \hspace{10pt} \text{for $i \leq N+1$} \\ \Col(i,j+1) \coloneqq b_\Sigma \leftarrow \Col(i,j); \ b_{j+1} \leftarrow \Ctrb(i,j+1,K); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $i \leq N+1$ and $j \leq N$} \end{cases*}$
\end{itemize}
Instead of summing up the table of contributions $\{\Ctrb(i,j,K) \}_{i,j \leq N+1}$ by columns, we can sum it up by rows. To this end, we introduce new internal channels
\begin{itemize}
\item $\begin{cases*} \Row(0,j) \coloneqq \read{\Ctrb(0,j,K)} \\ \hspace{10pt} \text{for $j \leq N+1$} \\ \Row(i+1,j) \coloneqq b_\Sigma \leftarrow \Row(i,j); \ b_{i+1} \leftarrow \Ctrb(i+1,j,K); \ \ret{b_\Sigma \oplus b_{i+1}} \\ \hspace{10pt} \text{for $i \leq N$ and $j \leq N+1$} \end{cases*}$
\end{itemize}
that record the sum of the $i+1$ contributions $\Ctrb(0,j,K),\ldots,\Ctrb(i,j,K)$. Additionally, we introduce new internal channels
\begin{itemize}
\item $\begin{cases*} \SumRow(i,0) \coloneqq \read{\Row(i,0)} \\ \hspace{10pt} \text{for $i \leq N+1$} \\ \SumRow(i,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i,j); \ b_{j+1} \leftarrow \Row(i,j+1); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $i \leq N+1$ and $j \leq N$} \end{cases*}$
\end{itemize}
that record the sum of the $j+1$ rows $\Row(i,0),\ldots,\Row(i,j)$ of length $i+1$.

Of course, summing up the contributions by columns is equivalent to summing them up by rows: in the presence of the channels
\begin{itemize}
\item $\begin{cases*} \Row(0,j) \coloneqq \read{\Ctrb(0,j,K)} \\ \hspace{10pt} \text{for $j \leq N+1$} \\ \Row(i+1,j) \coloneqq b_\Sigma \leftarrow \Row(i,j); \ b_{i+1} \leftarrow \Ctrb(i+1,j,K); \ \ret{b_\Sigma \oplus b_{i+1}} \\ \hspace{10pt} \text{for $i \leq N$ and $j \leq N+1$} \end{cases*}$
\item $\begin{cases*} \Col(i,0) \coloneqq \read{\Ctrb(i,0,K)} \\ \hspace{10pt} \text{for $i \leq N+1$} \\ \Col(i,j+1) \coloneqq b_\Sigma \leftarrow \Col(i,j); \ b_{j+1} \leftarrow \Ctrb(i,j+1,K); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $i \leq N+1$ and $j \leq N$} \end{cases*}$
\end{itemize}
we can express the protocol
\begin{itemize}
\item $\begin{cases*} \SumCol(0,j) \coloneqq \read{\Col(0,j)} \\ \hspace{10pt} \text{for $j \leq N+1$} \\ \SumCol(i+1,j) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_{i+1} \leftarrow \Col(i+1,j); \ \ret{b_\Sigma \oplus b_{i+1}} \\ \hspace{10pt} \text{for $i \leq N$ and $j \leq N+1$} \end{cases*}$
\item $\begin{cases*} \SumRow(i,0) \coloneqq \read{\Row(i,0)} \\ \hspace{10pt} \text{for $i \leq N+1$} \\ \SumRow(i,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i,j); \ b_{j+1} \leftarrow \Row(i,j+1); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $i \leq N+1$ and $j \leq N$} \end{cases*}$
\end{itemize}
where the channels $\SumCol(-,-)$ have an inductive form equivalently as the protocol
\begin{itemize}
\item $\SumCol(i,j) \coloneqq \read{\SumRow(i,j)}$ for $i,j \leq N+1$\smallskip
\item $\begin{cases*} \SumRow(i,0) \coloneqq \read{\Row(i,0)} \\ \hspace{10pt} \text{for $i \leq N+1$} \\ \SumRow(i,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i,j); \ b_{j+1} \leftarrow \Row(i,j+1); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $i \leq N+1$ and $j \leq N$} \end{cases*}$
\end{itemize}
where the channels $\SumCol(-,-)$ have a closed form.

To show this, we proceed by induction on $i$. In the base case $i = 0$, we need to show that the channels
\begin{itemize}
\item $\SumCol(0,j) \coloneqq \read{\Col(0,j)}$ for $j \leq N+1$\smallskip
\item $\begin{cases*} \SumRow(0,0) \coloneqq \read{\Row(0,0)} \smallskip \\ \SumRow(0,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(0,j); \ b_{j+1} \leftarrow \Row(0,j+1); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $j \leq N$} \end{cases*}$
\end{itemize}
can be expressed equivalently as the channels below:
\begin{itemize}
\item $\SumCol(0,j) \coloneqq \read{\SumRow(0,j)}$ for $j \leq N+1$\smallskip
\item $\begin{cases*} \SumRow(0,0) \coloneqq \read{\Row(0,0)} \smallskip \\ \SumRow(0,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(0,j); \ b_{j+1} \leftarrow \Row(0,j+1); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $j \leq N$} \end{cases*}$
\end{itemize}
We split the proof into two parts. In the first part of the base case $i = 0$, we show that the protocol
\begin{itemize}
\item $\SumCol(0,j) \coloneqq \read{\Col(0,j)}$ for $j \leq N+1$\smallskip
\item $\begin{cases*} \SumRow(0,0) \coloneqq \read{\Row(0,0)} \smallskip \\ \SumRow(0,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(0,j); \ b_{j+1} \leftarrow \Row(0,j+1); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $j \leq N$} \end{cases*}$
\end{itemize}
where the channels $\SumRow(0,-)$ have an inductive form can be expressed equivalently as the protocol
\begin{itemize}
\item $\SumCol(0,j) \coloneqq \read{\Col(0,j)}$ for $j \leq N+1$
\item $\SumRow(0,j) \coloneqq \read{\SumCol(0,j)}$ for $j \leq N+1$
\end{itemize}
where the channels $\SumRow(0,-)$ have a closed form.

We proceed by induction on $j$. In the base case $j = 0$, we need to show that the channels
\begin{itemize}
\item $\SumCol(0,0) \coloneqq \read{\Col(0,0)}$
\item $\SumRow(0,0) \coloneqq \read{\Row(0,0)}$
\end{itemize}
can be expressed equivalently as the channels below:
\begin{itemize}
\item $\SumCol(0,0) \coloneqq \read{\Col(0,0)}$
\item $\SumRow(0,0) \coloneqq \read{\SumCol(0,0)}$
\end{itemize}
Substituting the channel
\begin{itemize}
\item $\Row(0,0) \coloneqq \read{\Ctrb(0,0,K)}$
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\SumRow(0,0) \coloneqq \read{\Row(0,0)}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumRow(0,0) \coloneqq \read{\Ctrb(0,0,K)}$
\end{itemize}
In the presence of the channel
\begin{itemize}
\item $\Col(0,0) \coloneqq \read{\Ctrb(0,0,K)}$
\end{itemize}
we can express the channel $\SumRow(0,0)$ equivalently as follows:
\begin{itemize}
\item $\SumRow(0,0) \coloneqq \read{\Col(0,0)}$
\end{itemize}
In the presence of the channel
\begin{itemize}
\item $\SumCol(0,0) \coloneqq \read{\Col(0,0)}$
\end{itemize}
we can express the channel $\SumRow(0,0)$ equivalently as follows:
\begin{itemize}
\item $\SumRow(0,0) \coloneqq \read{\SumCol(0,0)}$
\end{itemize}
This is precisely the desired closed form of the channel $\SumRow(0,0)$, which finishes the base case $j = 0$.

In the inductive case $j+1$, we need to show that the channels
\begin{itemize}
\item $\SumCol(0,j+1) \coloneqq \read{\Col(0,j+1)}$
\item $\SumRow(0,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(0,j); \ b_{j+1} \leftarrow \Row(0,j+1); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
can be expressed equivalently as the channels below:
\begin{itemize}
\item $\SumCol(0,j+1) \coloneqq \read{\Col(0,j+1)}$
\item $\SumRow(0,j+1) \coloneqq \read{\SumCol(0,j+1)}$
\end{itemize}
Substituting the channel
\begin{itemize}
\item $\SumRow(0,j) \coloneqq \read{\SumCol(0,j)}$ \emph{(inductive hypothesis)}
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\SumRow(0,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(0,j); \ b_{j+1} \leftarrow \Row(0,j+1); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumRow(0,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(0,j); \ b_{j+1} \leftarrow \Row(0,j+1); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
Further substituting the channels
\begin{itemize}
\item $\SumCol(0,j) \coloneqq \read{\Col(0,j)}$
\item $\Row(0,j+1) \coloneqq \read{\Ctrb(0,j+1,K)}$
\end{itemize}
into the channel $\SumRow(0,j+1)$ yields the following:
\begin{itemize}
\item $\SumRow(0,j+1) \coloneqq b_\Sigma \leftarrow \Col(0,j); \ b_{j+1} \leftarrow \Ctrb(0,j+1,K); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
In the presence of the channel
\begin{itemize}
\item $\Col(0,j+1) \coloneqq b_\Sigma \leftarrow \Col(0,j); \ b_{j+1} \leftarrow \Ctrb(0,j+1,K); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
we can express the channel $\SumRow(0,j+1)$ more concisely as follows:
\begin{itemize}
\item $\SumRow(0,j+1) \coloneqq \read{\Col(0,j+1)}$
\end{itemize}
In the presence of the channel
\begin{itemize}
\item $\SumCol(0,j+1) \coloneqq \read{\Col(0,j+1)}$
\end{itemize}
we can further write the channel $\SumRow(0,j+1)$ as follows:
\begin{itemize}
\item $\SumRow(0,j+1) \coloneqq \SumCol(0,j+1)$
\end{itemize}
This is precisely the desired closed form of the channel $\SumRow(0,j+1)$, which finishes the inductive case $j+1$. The first part of the base case $i = 0$ is now complete.

In the second part of the base case $i = 0$, we show that the protocol
\begin{itemize}
\item $\SumCol(0,j) \coloneqq \read{\Col(0,j)}$ for $j \leq N+1$
\item $\SumRow(0,j) \coloneqq \read{\SumCol(0,j)}$ for $j \leq N+1$
\end{itemize}
where the channels $\SumCol(0,-)$ have an inductive form while the channels $\SumRow(0,-)$ have a closed form can be expressed equivalently as the protocol
\begin{itemize}
\item $\SumCol(0,j) \coloneqq \read{\SumRow(0,j)}$ for $j \leq N+1$\smallskip
\item $\begin{cases*} \SumRow(0,0) \coloneqq \read{\Row(0,0)} \smallskip \\ \SumRow(0,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(0,j); \ b_{j+1} \leftarrow \Row(0,j+1); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $j \leq N$} \end{cases*}$
\end{itemize}
where the channels $\SumCol(0,-)$ have a closed form while the channels $\SumRow(0,-)$ have an inductive form.

We proceed by induction on $j$. In the base case $j = 0$, we need to show that the channels below:
\begin{itemize}
\item $\SumCol(0,0) \coloneqq \read{\Col(0,0)}$
\item $\SumRow(0,0) \coloneqq \read{\SumCol(0,0)}$
\end{itemize}
can be expressed equivalently as the channels
\begin{itemize}
\item $\SumCol(0,0) \coloneqq \read{\SumRow(0,0)}$
\item $\SumRow(0,0) \coloneqq \read{\Row(0,0)}$
\end{itemize}
Substituting the channel
\begin{itemize}
\item $\Row(0,0) \coloneqq \read{\Ctrb(0,0,K)}$
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\SumRow(0,0) \coloneqq \read{\Row(0,0)}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumRow(0,0) \coloneqq \read{\Ctrb(0,0,K)}$
\end{itemize}
In the presence of the channel
\begin{itemize}
\item $\Col(0,0) \coloneqq \read{\Ctrb(0,0,K)}$
\end{itemize}
we can express the channel $\SumRow(0,0)$ equivalently as follows:
\begin{itemize}
\item $\SumRow(0,0) \coloneqq \read{\Col(0,0)}$
\end{itemize}
Substituting the channel $\SumRow(0,0)$ into the closed form of the channel
\begin{itemize}
\item $\SumCol(0,0) \coloneqq \read{\SumRow(0,0)}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumCol(0,0) \coloneqq \read{\Col(0,0)}$
\end{itemize}
This is precisely the desired inductive form of the channel $\SumCol(0,0)$, in the presence of which we can write the channel
\begin{itemize}
\item $\SumRow(0,0) \coloneqq \read{\Col(0,0)}$
\end{itemize}
equivalently as follows:
\begin{itemize}
\item $\SumRow(0,0) \coloneqq \read{\SumCol(0,0)}$
\end{itemize}
This is precisely the desired closed form of the channel $\SumRow(0,0)$, which finishes the base case $j = 0$.

In the inductive case $j+1$, we need to show that the channels
\begin{itemize}
\item $\SumCol(0,j+1) \coloneqq \read{\Col(0,j+1)}$
\item $\SumRow(0,j+1) \coloneqq \read{\SumCol(0,j+1)}$
\end{itemize}
can be expressed equivalently as the channels below:
\begin{itemize}
\item $\SumCol(0,j+1) \coloneqq \read{\SumRow(0,j+1)}$
\item $\SumRow(0,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(0,j); \ b_{j+1} \leftarrow \Row(0,j+1); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
Substituting the channel
\begin{itemize}
\item $\SumRow(0,j) \coloneqq \read{\SumCol(0,j)}$ \emph{(inductive hypothesis)}
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\SumRow(0,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(0,j); \ b_{j+1} \leftarrow \Row(0,j+1); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumRow(0,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(0,j); \ b_{j+1} \leftarrow \Row(0,j+1); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
Further substituting the channels
\begin{itemize}
\item $\SumCol(0,j) \coloneqq \read{\Col(0,j)}$ \emph{(inductive hypothesis)}
\item $\Row(0,j+1) \coloneqq \read{\Ctrb(0,j+1,K)}$
\end{itemize}
into the channel $\SumRow(0,j+1)$ yields the following:
\begin{itemize}
\item $\SumRow(0,j+1) \coloneqq b_\Sigma \leftarrow \Col(0,j); \ b_{j+1} \leftarrow \Ctrb(0,j+1,K); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
In the presence of the channel
\begin{itemize}
\item $\Col(0,j+1) \coloneqq b_\Sigma \leftarrow \Col(0,j); \ b_{j+1} \leftarrow \Ctrb(0,j+1,K); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
we can express the channel $\SumRow(0,j+1)$ more concisely as follows:
\begin{itemize}
\item $\SumRow(0,j+1) \coloneqq \read{\Col(0,j+1)}$
\end{itemize}
Substituting the channel $\SumRow(0,j+1)$ into the closed form of the channel
\begin{itemize}
\item $\SumCol(0,j+1) \coloneqq \read{\SumRow(0,j+1)}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumCol(0,j+1) \coloneqq \read{\Col(0,j+1)}$
\end{itemize}
But this is precisely the desired inductive form of the channel $\SumCol(0,j+1)$, in the presence of which we can write the channel
\begin{itemize}
\item $\SumRow(0,j+1) \coloneqq \read{\Col(0,j+1)}$
\end{itemize}
equivalently as follows:
\begin{itemize}
\item $\SumRow(0,j+1) \coloneqq \read{\SumCol(0,j+1)}$
\end{itemize}
This is precisely the desired closed form of the channel $\SumRow(0,j+1)$, which finishes the inductive case $j+1$. The second part of the base case $i = 0$ is now complete.

In the inductive case $i+1$, we need to show that the channels
\begin{itemize}
\item $\SumCol(i+1,j) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_{i+1} \leftarrow \Col(i+1,j); \ \ret{b_\Sigma \oplus b_{i+1}}$ for $j \leq N+1$\smallskip
\item $\begin{cases*} \SumRow(i+1,0) \coloneqq \read{\Row(i+1,0)} \smallskip \\ \SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i+1,j); \ b_{j+1} \leftarrow \Row(i+1,j+1); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $j \leq N$} \end{cases*}$
\end{itemize}
can be expressed equivalently as the channels below:
\begin{itemize}
\item $\SumCol(i+1,j) \coloneqq \read{\SumRow(i+1,j)}$ for $j \leq N+1$\smallskip
\item $\begin{cases*} \SumRow(i+1,0) \coloneqq \read{\Row(i+1,0)} \smallskip \\ \SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i+1,j); \ b_{j+1} \leftarrow \Row(i+1,j+1); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $j \leq N$} \end{cases*}$
\end{itemize}
We split the proof into two parts. In the first part of the inductive case $i+1$, we show that the protocol
\begin{itemize}
\item $\SumCol(i+1,j) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_{i+1} \leftarrow \Col(i+1,j); \ \ret{b_\Sigma \oplus b_{i+1}}$ for $j \leq N+1$\smallskip
\item $\begin{cases*} \SumRow(i+1,0) \coloneqq \read{\Row(i+1,0)} \smallskip \\ \SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i+1,j); \ b_{j+1} \leftarrow \Row(i+1,j+1); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $j \leq N$} \end{cases*}$
\end{itemize}
where the channels $\SumRow(i+1,-)$ have an inductive form can be expressed equivalently as the protocol
\begin{itemize}
\item $\SumCol(i+1,j) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_{i+1} \leftarrow \Col(i+1,j); \ \ret{b_\Sigma \oplus b_{i+1}}$ for $j \leq N+1$
\item $\SumRow(i+1,j) \coloneqq \read{\SumCol(i+1,j)}$ for $j \leq N+1$
\end{itemize}
where the channels $\SumRow(i+1,-)$ have a closed form.

We proceed by induction on $j$. In the base case $j = 0$, we need to show that the channels
\begin{itemize}
\item $\SumCol(i+1,0) \coloneqq b_\Sigma \leftarrow \SumCol(i,0); \ b_{i+1} \leftarrow \Col(i+1,0); \ \ret{b_\Sigma \oplus b_{i+1}}$
\item $\SumRow(i+1,0) \coloneqq \read{\Row(i+1,0)}$
\end{itemize}
can be expressed equivalently as the channels below:
\begin{itemize}
\item $\SumCol(i+1,0) \coloneqq b_\Sigma \leftarrow \SumCol(i,0); \ b_{i+1} \leftarrow \Col(i+1,0); \ \ret{b_\Sigma \oplus b_{i+1}}$
\item $\SumRow(i+1,0) \coloneqq \read{\SumCol(i+1,0)}$
\end{itemize}
Substituting the channel
\begin{itemize}
\item $\Row(i+1,0) \coloneqq b_\Sigma \leftarrow \Row(i,0); \ b_{i+1} \leftarrow \Ctrb(i+1,0,K); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\SumRow(i+1,0) \coloneqq \read{\Row(i+1,0)}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumRow(i+1,0) \coloneqq b_\Sigma \leftarrow \Row(i,0); \ b_{i+1} \leftarrow \Ctrb(i+1,0,K); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
In the presence of the channels
\begin{itemize}
\item $\SumRow(i,0) \coloneqq \read{\Row(i,0)}$
\item $\Col(i+1,0) \coloneqq \read{\Ctrb(i+1,0,K)}$
\end{itemize}
we can express the channel $\SumRow(i+1,0)$ equivalently as follows:
\begin{itemize}
\item $\SumRow(i+1,0) \coloneqq b_\Sigma \leftarrow \SumRow(i,0); \ b_{i+1} \leftarrow \Col(i+1,0); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
In the presence of the channel
\begin{itemize}
\item $\SumCol(i,0) \coloneqq \SumRow(i,0)$ \emph{(inductive hypothesis)}
\end{itemize}
we can further write the channel $\SumRow(i+1,0)$ as follows:
\begin{itemize}
\item $\SumRow(i+1,0) \coloneqq b_\Sigma \leftarrow \SumCol(i,0); \ b_{i+1} \leftarrow \Col(i+1,0); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
Finally, in the presence of the channel
\begin{itemize}
\item $\SumCol(i+1,0) \coloneqq b_\Sigma \leftarrow \SumCol(i,0); \ b_{i+1} \leftarrow \Col(i+1,0); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
we can write the channel $\SumRow(i+1,0)$ equivalently as follows:
\begin{itemize}
\item $\SumRow(i+1,0) \coloneqq \read{\SumCol(i+1,0)}$
\end{itemize}
This is precisely the desired closed form of the channel $\SumRow(i+1,0)$, which finishes the base case $j = 0$.

In the inductive case $j+1$, we need to show that the channels
\begin{itemize}
\item $\SumCol(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(i,j+1); \ b_{i+1} \leftarrow \Col(i+1,j+1); \ \ret{b_\Sigma \oplus b_{i+1}}$
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i+1,j); \ b_{j+1} \leftarrow \Row(i+1,j+1); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
can be expressed equivalently as the channels below:
\begin{itemize}
\item $\SumCol(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(i,j+1); \ b_{i+1} \leftarrow \Col(i+1,j+1); \ \ret{b_\Sigma \oplus b_{i+1}}$
\item $\SumRow(i+1,j+1) \coloneqq \read{\SumCol(i+1,j+1)}$
\end{itemize}
Substituting the channel
\begin{itemize}
\item $\SumRow(i+1,j) \coloneqq \read{\SumCol(i+1,j)}$ \emph{(inductive hypothesis)}
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i+1,j); \ b_{j+1} \leftarrow \Row(i+1,j+1); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(i+1,j); \ b_{j+1} \leftarrow \Row(i+1,j+1); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
Further substituting the channels
\begin{itemize}
\item $\SumCol(i+1,j) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_\mathsf{C} \leftarrow \Col(i+1,j); \ \ret{b_\Sigma \oplus b_\mathsf{C}}$
\item $\Row(i+1,j+1) \coloneqq b_\mathsf{R} \leftarrow \Row(i,j+1); \ b \leftarrow \Ctrb(i+1,j+1,K); \ \ret{b_\mathsf{R} \oplus b}$
\end{itemize}
into the channel $\SumRow(i+1,j+1)$ yields the following:
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_\mathsf{C} \leftarrow \Col(i+1,j); \\ b_\mathsf{R} \leftarrow \Row(i,j+1); \ b \leftarrow \Ctrb(i+1,j+1,K); \ \ret{(b_\Sigma \oplus b_\mathsf{C}) \oplus (b_\mathsf{R} \oplus b)}$
\end{itemize}
After a slight rearrangement we get the following:
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_\mathsf{R} \leftarrow \Row(i,j+1); \\ b_\mathsf{C} \leftarrow \Col(i+1,j); \  b \leftarrow \Ctrb(i+1,j+1,K); \ \ret{(b_\Sigma \oplus b_\mathsf{R}) \oplus (b_\mathsf{C} \oplus b)}$
\end{itemize}
A final substitution of the channel
\begin{itemize}
\item $\SumCol(i,j) \coloneqq \read{\SumRow(i,j)}$ \emph{(inductive hypothesis)}
\end{itemize}
into the channel $\SumRow(i+1,j+1)$ yields the following:
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i,j); \ b_\mathsf{R} \leftarrow \Row(i,j+1); \\ b_\mathsf{C} \leftarrow \Col(i+1,j); \  b \leftarrow \Ctrb(i+1,j+1,K); \ \ret{(b_\Sigma \oplus b_\mathsf{R}) \oplus (b_\mathsf{C} \oplus b)}$
\end{itemize}
In the presence of the channels
\begin{itemize}
\item $\SumRow(i,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i,j); \ b_\mathsf{R} \leftarrow \Row(i,j+1); \ \ret{b_\Sigma \oplus b_\mathsf{R}}$
\item $\Col(i+1,j+1) \coloneqq b_\mathsf{C} \leftarrow \Col(i+1,j); \ b \leftarrow \Ctrb(i+1,j+1,K); \ \ret{b_\mathsf{C} \oplus b}$
\end{itemize}
we can express the channel $\SumRow(i+1,j+1)$ more concisely as follows:
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i,j+1); \ b_{i+1} \leftarrow \Col(i+1,j+1); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
In the presence of the channel
\begin{itemize}
\item $\SumCol(i,j+1) \coloneqq \read{\SumRow(i,j+1)}$ \emph{(inductive hypothesis)}
\end{itemize}
we can further write the channel $\SumRow(i+1,j+1)$ equivalently as follows:
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(i,j+1); \ b_{i+1} \leftarrow \Col(i+1,j+1); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
Finally, in the presence of the channel
\begin{itemize}
\item $\SumCol(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(i,j+1); \ b_{i+1} \leftarrow \Col(i+1,j+1); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
we can write the channel $\SumRow(i+1,j+1)$ equivalently as follows:
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq \read{\SumCol(i+1,j+1)}$
\end{itemize}
This is precisely the desired closed form of the channel $\SumRow(i+1,j+1)$, which finishes the inductive case $j+1$. The first part of the inductive case $i+1$ is now complete.

In the second part of the inductive case $i+1$, we show that the protocol
\begin{itemize}
\item $\SumCol(i+1,j) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_{i+1} \leftarrow \Col(i+1,j); \ \ret{b_\Sigma \oplus b_{i+1}}$ for $j \leq N+1$
\item $\SumRow(i+1,j) \coloneqq \read{\SumCol(i+1,j)}$ for $j \leq N+1$
\end{itemize}
where the channels $\SumCol(i+1,-)$ have an inductive form while the channels $\SumRow(i+1,-)$ have a closed form can be expressed equivalently as the protocol
\begin{itemize}
\item $\SumCol(i+1,j) \coloneqq \read{\SumRow(i+1,j)}$ for $j \leq N+1$\smallskip
\item $\begin{cases*} \SumRow(i+1,0) \coloneqq \read{\Row(i+1,0)} \smallskip \\ \SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i+1,j); \ b_{j+1} \leftarrow \Row(i+1,j+1); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $j \leq N$} \end{cases*}$
\end{itemize}
where the channels $\SumCol(i+1,-)$ have a closed form while the channels $\SumRow(i+1,-)$ have an inductive form.

We proceed by induction on $j$. In the base case $j = 0$, we need to show that the channels
\begin{itemize}
\item $\SumCol(i+1,0) \coloneqq b_\Sigma \leftarrow \SumCol(i,0); \ b_{i+1} \leftarrow \Col(i+1,0); \ \ret{b_\Sigma \oplus b_{i+1}}$
\item $\SumRow(i+1,0) \coloneqq \read{\SumCol(i+1,0)}$
\end{itemize}
can be expressed equivalently as the channels below:
\begin{itemize}
\item $\SumCol(i+1,0) \coloneqq \read{\SumRow(i+1,0)}$
\item $\SumRow(i+1,0) \coloneqq \read{\Row(i+1,0)}$
\end{itemize}
Substituting the channel
\begin{itemize}
\item $\Row(i+1,0) \coloneqq b_\Sigma \leftarrow \Row(i,0); \ b_{i+1} \leftarrow \Ctrb(i+1,0,K); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\SumRow(i+1,0) \coloneqq \read{\Row(i+1,0)}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumRow(i+1,0) \coloneqq b_\Sigma \leftarrow \Row(i,0); \ b_{i+1} \leftarrow \Ctrb(i+1,0,K); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
In the presence of the channels
\begin{itemize}
\item $\SumRow(i,0) \coloneqq \read{\Row(i,0)}$
\item $\Col(i+1,0) \coloneqq \read{\Ctrb(i+1,0,K)}$
\end{itemize}
we can express the channel $\SumRow(i+1,0)$ equivalently as follows:
\begin{itemize}
\item $\SumRow(i+1,0) \coloneqq b_\Sigma \leftarrow \SumRow(i,0); \ b_{i+1} \leftarrow \Col(i+1,0); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
In the presence of the channel
\begin{itemize}
\item $\SumCol(i,0) \coloneqq \SumRow(i,0)$ \emph{(inductive hypothesis)}
\end{itemize}
we can further write the channel $\SumRow(i+1,0)$ as follows:
\begin{itemize}
\item $\SumRow(i+1,0) \coloneqq b_\Sigma \leftarrow \SumCol(i,0); \ b_{i+1} \leftarrow \Col(i+1,0); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
Substituting the channel $\SumRow(i+1,0)$ into the closed form of the channel
\begin{itemize}
\item $\SumCol(i+1,0) \coloneqq \read{\SumRow(i+1,0)}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumCol(i+1,0) \coloneqq b_\Sigma \leftarrow \SumCol(i,0); \ b_{i+1} \leftarrow \Col(i+1,0); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
But this is precisely the desired inductive form of the channel $\SumCol(i+1,0)$, in the presence of which we can write the channel
\begin{itemize}
\item $\SumRow(i+1,0) \coloneqq b_\Sigma \leftarrow \SumCol(i,0); \ b_{i+1} \leftarrow \Col(i+1,0); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
equivalently as follows:
\begin{itemize}
\item $\SumRow(i+1,0) \coloneqq \read{\SumCol(i+1,0)}$
\end{itemize}
This is precisely the desired closed form of the channel $\SumRow(i+1,0)$, which finishes the base case $j = 0$. 

In the inductive case $j+1$, we need to show that the channels
\begin{itemize}
\item $\SumCol(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(i,j+1); \ b_{i+1} \leftarrow \Col(i+1,j+1); \ \ret{b_\Sigma \oplus b_{i+1}}$
\item $\SumRow(i+1,j+1) \coloneqq \read{\SumCol(i+1,j+1)}$
\end{itemize}
can be expressed equivalently as the channels below:
\begin{itemize}
\item $\SumCol(i+1,j+1) \coloneqq \read{\SumRow(i+1,j+1)}$
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i+1,j); \ b_{j+1} \leftarrow \Row(i+1,j+1); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
Substituting the channel
\begin{itemize}
\item $\SumRow(i+1,j) \coloneqq \read{\SumCol(i+1,j)}$ \emph{(inductive hypothesis)}
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i+1,j); \ b_{j+1} \leftarrow \Row(i+1,j+1); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(i+1,j); \ b_{j+1} \leftarrow \Row(i+1,j+1); \ \ret{b_\Sigma \oplus b_{j+1}}$
\end{itemize}
Further substituting the channels
\begin{itemize}
\item $\SumCol(i+1,j) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_\mathsf{C} \leftarrow \Col(i+1,j); \ \ret{b_\Sigma \oplus b_\mathsf{C}}$ \emph{(inductive hypothesis)}
\item $\Row(i+1,j+1) \coloneqq b_\mathsf{R} \leftarrow \Row(i,j+1); \ b \leftarrow \Ctrb(i+1,j+1,K); \ \ret{b_\mathsf{R} \oplus b}$
\end{itemize}
into the channel $\SumRow(i+1,j+1)$ yields the following:
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_\mathsf{C} \leftarrow \Col(i+1,j); \\ b_\mathsf{R} \leftarrow \Row(i,j+1); \ b \leftarrow \Ctrb(i+1,j+1,K); \ \ret{(b_\Sigma \oplus b_\mathsf{C}) \oplus (b_\mathsf{R} \oplus b)}$
\end{itemize}
After a slight rearrangement we get the following:
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_\mathsf{R} \leftarrow \Row(i,j+1); \\ b_\mathsf{C} \leftarrow \Col(i+1,j); \  b \leftarrow \Ctrb(i+1,j+1,K); \ \ret{(b_\Sigma \oplus b_\mathsf{R}) \oplus (b_\mathsf{C} \oplus b)}$
\end{itemize}
A final substitution of the channel
\begin{itemize}
\item $\SumCol(i,j) \coloneqq \read{\SumRow(i,j)}$ \emph{(inductive hypothesis)}
\end{itemize}
into the channel $\SumRow(i+1,j+1)$ yields the following:
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i,j); \ b_\mathsf{R} \leftarrow \Row(i,j+1); \\ b_\mathsf{C} \leftarrow \Col(i+1,j); \  b \leftarrow \Ctrb(i+1,j+1,K); \ \ret{(b_\Sigma \oplus b_\mathsf{R}) \oplus (b_\mathsf{C} \oplus b)}$
\end{itemize}
In the presence of the channels
\begin{itemize}
\item $\SumRow(i,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i,j); \ b_\mathsf{R} \leftarrow \Row(i,j+1); \ \ret{b_\Sigma \oplus b_\mathsf{R}}$
\item $\Col(i+1,j+1) \coloneqq b_\mathsf{C} \leftarrow \Col(i+1,j); \ b \leftarrow \Ctrb(i+1,j+1,K); \ \ret{b_\mathsf{C} \oplus b}$
\end{itemize}
we can express the channel $\SumRow(i+1,j+1)$ more concisely as follows:
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i,j+1); \ b_{i+1} \leftarrow \Col(i+1,j+1); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
In the presence of the channel
\begin{itemize}
\item $\SumCol(i,j+1) \coloneqq \read{\SumRow(i,j+1)}$ \emph{(inductive hypothesis)}
\end{itemize}
we can further write the channel $\SumRow(i+1,j+1)$ equivalently as follows:
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(i,j+1); \ b_{i+1} \leftarrow \Col(i+1,j+1); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
Substituting the channel $\SumRow(i+1,j+1)$ into the closed form of the channel
\begin{itemize}
\item $\SumCol(i+1,j+1) \coloneqq \read{\SumRow(i+1,j+1)}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\SumCol(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(i,j+1); \ b_{i+1} \leftarrow \Col(i+1,j+1); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
But this is precisely the desired inductive form of the channel $\SumCol(i+1,j+1)$, in the presence of which we can write the channel
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq b_\Sigma \leftarrow \SumCol(i,j+1); \ b_{i+1} \leftarrow \Col(i+1,j+1); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
equivalently as follows:
\begin{itemize}
\item $\SumRow(i+1,j+1) \coloneqq \read{\SumCol(i+1,j+1)}$
\end{itemize}
This is precisely the desired closed form of the channel $\SumRow(i+1,j+1)$, which finishes the inductive case $j+1$. The second part of the inductive case $i+1$ is now complete.

We have thus shown that summing up the contributions by columns is equivalent to summing them up by rows. We will use this fact shortly.

We are ultimately interested in summing up $N+2$ columns of length $N+2$ (or equivalently, $N+2$ rows of length $N+2$). The summation of $n+1$ columns of length $n+1$ is therefore a special case that deserves its own name: we add new internal channels
\begin{itemize}
\item $\Sqr(n) \coloneqq \read{\SumCol(n,n)}$ for $n \leq N+1$
\end{itemize}
that record the sum of the $n+1$ columns $\Col(0,n),\ldots,\Col(n,n)$ of length $n+1$.

In the presence of the channels $\Sqr(-)$ we can write the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq \read{\SumCol(N+1,N+1)}$
\end{itemize}
equivalently as follows:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq \read{\Sqr(N+1)}$
\end{itemize}
Our next goal is to show that in the presence of the channels
\begin{itemize}
\item $\begin{cases*} \Row(0,j) \coloneqq \read{\Ctrb(0,j,K)} \\ \hspace{10pt} \text{for $j \leq N+1$} \\ \Row(i+1,j) \coloneqq b_\Sigma \leftarrow \Row(i,j); \ b_{i+1} \leftarrow \Ctrb(i+1,j,K); \ \ret{b_\Sigma \oplus b_{i+1}} \\ \hspace{10pt} \text{for $i \leq N$ and $j \leq N+1$} \end{cases*}$
\item $\begin{cases*} \Col(i,0) \coloneqq \read{\Ctrb(i,0,K)} \\ \hspace{10pt} \text{for $i \leq N+1$} \\ \Col(i,j+1) \coloneqq b_\Sigma \leftarrow \Col(i,j); \ b_{j+1} \leftarrow \Ctrb(i,j+1,K); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $i \leq N+1$ and $j \leq N$} \end{cases*}$
\end{itemize}
as well as the channels
\begin{itemize}
\item $\begin{cases*} \SumCol(0,j) \coloneqq \read{\Col(0,j)} \\ \hspace{10pt} \text{for $j \leq N+1$} \\ \SumCol(i+1,j) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_{i+1} \leftarrow \Col(i+1,j); \ \ret{b_\Sigma \oplus b_{i+1}} \\ \hspace{10pt} \text{for $i \leq N$ and $j \leq N+1$} \end{cases*}$
\item $\begin{cases*} \SumRow(i,0) \coloneqq \read{\Row(i,0)} \\ \hspace{10pt} \text{for $i \leq N+1$} \\ \SumRow(i,j+1) \coloneqq b_\Sigma \leftarrow \SumRow(i,j); \ b_{j+1} \leftarrow \Row(i,j+1); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $i \leq N+1$ and $j \leq N$} \end{cases*}$
\end{itemize}
we can express the closed form of the channels
\begin{itemize}
\item $\Sqr(n) \coloneqq \read{\SumCol(n,n)}$ for $n \leq N+1$
\end{itemize}
equivalently by induction:
\begin{itemize}
\item $\begin{cases*} \Sqr(0) \coloneqq \read{\Col(0,0)} \smallskip \\ \Sqr(n+1) \coloneqq b_\mathsf{S} \leftarrow \Sqr(n); \ b_\mathsf{R} \leftarrow \Row(n,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,n+1); \ \ret{(b_\mathsf{S} \oplus b_\mathsf{R}) \oplus b_\mathsf{C}} \\ \hspace{10pt} \text{for $n \leq N$} \end{cases*}$
\end{itemize}
In the base case, substituting the channel
\begin{itemize}
\item $\SumCol(0,0) \coloneqq \read{\Col(0,0)}$
\end{itemize}
into the closed form of the channel
\begin{itemize}
\item $\Sqr(0) \coloneqq \read{\SumCol(0,0)}$
\end{itemize}
yields precisely the desired inductive form:
\begin{itemize}
\item $\Sqr(0) \coloneqq \read{\Col(0,0)}$
\end{itemize}
In the inductive case, substituting the channel
\begin{itemize}
\item $\SumCol(n+1,n+1) \coloneqq b_\Sigma \leftarrow \SumCol(n,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,n+1); \ \ret{b_\Sigma \oplus b_\mathsf{C}}$
\end{itemize}
into the closed form of the channel
\begin{itemize}
\item $\Sqr(n+1) \coloneqq \read{\SumCol(n+1,n+1)}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\Sqr(n+1) \coloneqq b_\Sigma \leftarrow \SumCol(n,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,n+1); \ \ret{b_\Sigma \oplus b_\mathsf{C}}$
\end{itemize}
We now appeal to our earlier observation that the inductive form of the channels
\begin{itemize}
\item $\begin{cases*} \SumCol(0,j) \coloneqq \read{\Col(0,j)} \\ \hspace{10pt} \text{for $j \leq N+1$} \\ \SumCol(i+1,j) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_{i+1} \leftarrow \Col(i+1,j); \ \ret{b_\Sigma \oplus b_{i+1}} \\ \hspace{10pt} \text{for $i \leq N$ and $j \leq N+1$} \end{cases*}$
\end{itemize}
is equivalent to the following closed form:
\begin{itemize}
\item $\SumCol(i,j) \coloneqq \read{\SumRow(i,j)}$ for $i,j \leq N+1$
\end{itemize}
Substituting the channel
\begin{itemize}
\item $\SumCol(n,n+1) \coloneqq \read{\SumRow(n,n+1)}$
\end{itemize}
into the channel
\begin{itemize}
\item $\Sqr(n+1) \coloneqq b_\Sigma \leftarrow \SumCol(n,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,n+1); \ \ret{b_\Sigma \oplus b_\mathsf{C}}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\Sqr(n+1) \coloneqq b_\Sigma \leftarrow \SumRow(n,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,n+1); \ \ret{b_\Sigma \oplus b_\mathsf{C}}$
\end{itemize}
Further substituting the channel
\begin{itemize}
\item $\SumRow(n,n+1) \coloneqq b_\mathsf{S} \leftarrow \SumRow(n,n); \ b_\mathsf{R} \leftarrow \Row(n,n+1); \ \ret{b_\mathsf{S} \oplus b_\mathsf{R}}$
\end{itemize}
into the channel $\Sqr(n+1)$ yields the following:
\begin{itemize}
\item $\Sqr(n+1) \coloneqq b_\mathsf{S} \leftarrow \SumRow(n,n); \ b_\mathsf{R} \leftarrow \Row(n,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,n+1); \ \ret{(b_\mathsf{S} \oplus b_\mathsf{R}) \oplus b_\mathsf{C}}$
\end{itemize}
In the presence of the channel
\begin{itemize}
\item $\SumCol(n,n) \coloneqq \read{\SumRow(n,n)}$
\end{itemize}
we can write the channel $\Sqr(n+1)$ equivalently as follows:
\begin{itemize}
\item $\Sqr(n+1) \coloneqq b_\mathsf{S} \leftarrow \SumCol(n,n); \ b_\mathsf{R} \leftarrow \Row(n,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,n+1); \ \ret{(b_\mathsf{S} \oplus b_\mathsf{R}) \oplus b_\mathsf{C}}$
\end{itemize}
At this point, we rewrite the closed form of the channels
\begin{itemize}
\item $\SumCol(i,j) \coloneqq \read{\SumRow(i,j)}$ for $i,j \leq N+1$
\end{itemize}
back to their original inductive form:
\begin{itemize}
\item $\begin{cases*} \SumCol(0,j) \coloneqq \read{\Col(0,j)} \\ \hspace{10pt} \text{for $j \leq N+1$} \\ \SumCol(i+1,j) \coloneqq b_\Sigma \leftarrow \SumCol(i,j); \ b_{i+1} \leftarrow \Col(i+1,j); \ \ret{b_\Sigma \oplus b_{i+1}} \\ \hspace{10pt} \text{for $i \leq N$ and $j \leq N+1$} \end{cases*}$
\end{itemize}
In the presence of the channel
\begin{itemize}
\item $\Sqr(n) \coloneqq \read{\SumCol(n,n)}$ \emph{(inductive hypothesis)}
\end{itemize}
we can further write the channel $\Sqr(n+1)$ as follows:
\begin{itemize}
\item $\Sqr(n+1) \coloneqq b_\mathsf{S} \leftarrow \Sqr(n); \ b_\mathsf{R} \leftarrow \Row(n,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,n+1); \ \ret{(b_\mathsf{S} \oplus b_\mathsf{R}) \oplus b_\mathsf{C}}$
\end{itemize}
This is precisely the desired inductive form of the channel $\Sqr(n+1)$.

The channels $\SumRow(-,-)$, $\SumCol(-,-)$ are now unused and can be discarded.

We now recall the channels below:
\begin{itemize}
\item $\begin{cases*} \SumShare(0,k) \coloneqq \read{\Share(0,k)} \smallskip \\ \SumShare(m+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ x_{m+1} \leftarrow \Share(m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\item $\begin{cases*} \SumShare(0,l) \coloneqq \read{\Share(0,l)} \smallskip \\ \SumShare(m+1,l) \coloneqq y_\Sigma \leftarrow \SumShare(m,l); \ y_{m+1} \leftarrow \Share(m+1,l); \ \ret{y_\Sigma \oplus y_{m+1}} \\ \hspace{10pt} \text{for $m < N$} \end{cases*}$
\end{itemize}
We also recall the following channels:
\begin{itemize}
\item $\SumShare(N+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x_{N+1} \leftarrow \Share(N+1,k); \ \ret{x_\Sigma \oplus x_{N+1}}$ \emph{(inductive hypothesis)}
\item $\SumShare(N+1,l) \coloneqq y_\Sigma \leftarrow \SumShare(N,l); \ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{y_\Sigma \oplus y_{N+1}}$ \emph{(inductive hypothesis)}
\end{itemize}
Altogether we thus have the following:
\begin{itemize}
\item $\begin{cases*} \SumShare(0,k) \coloneqq \read{\Share(0,k)} \smallskip \\ \SumShare(m+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ x_{m+1} \leftarrow \Share(m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m \leq N$} \end{cases*}$
\item $\begin{cases*} \SumShare(0,l) \coloneqq \read{\Share(0,l)} \smallskip \\ \SumShare(m+1,l) \coloneqq y_\Sigma \leftarrow \SumShare(m,l); \ y_{m+1} \leftarrow \Share(m+1,l); \ \ret{y_\Sigma \oplus y_{m+1}} \\ \hspace{10pt} \text{for $m \leq N$} \end{cases*}$
\end{itemize}
Our final goal is to show that in the presence of the channels
\begin{itemize}
\item $\begin{cases*} \Row(0,j) \coloneqq \read{\Ctrb(0,j,K)} \\ \hspace{10pt} \text{for $j \leq N+1$} \\ \Row(i+1,j) \coloneqq b_\Sigma \leftarrow \Row(i,j); \ b_{i+1} \leftarrow \Ctrb(i+1,j,K); \ \ret{b_\Sigma \oplus b_{i+1}} \\ \hspace{10pt} \text{for $i \leq N$ and $j \leq N+1$} \end{cases*}$
\item $\begin{cases*} \Col(i,0) \coloneqq \read{\Ctrb(i,0,K)} \\ \hspace{10pt} \text{for $i \leq N+1$} \\ \Col(i,j+1) \coloneqq b_\Sigma \leftarrow \Col(i,j); \ b_{j+1} \leftarrow \Ctrb(i,j+1,K); \ \ret{b_\Sigma \oplus b_{j+1}} \\ \hspace{10pt} \text{for $i \leq N+1$ and $j \leq N$} \end{cases*}$
\end{itemize}
as well as the channels
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$\smallskip
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$ for $n,m \leq N+1$\smallskip
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$
\end{itemize}
together with the channels
\begin{itemize}
\item $\begin{cases*} \SumShare(0,k) \coloneqq \read{\Share(0,k)} \smallskip \\ \SumShare(m+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ x_{m+1} \leftarrow \Share(m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m \leq N$} \end{cases*}$
\item $\begin{cases*} \SumShare(0,l) \coloneqq \read{\Share(0,l)} \smallskip  \\ \SumShare(m+1,l) \coloneqq y_\Sigma \leftarrow \SumShare(m,l); \ y_{m+1} \leftarrow \Share(m+1,l); \ \ret{y_\Sigma \oplus y_{m+1}} \\ \hspace{10pt} \text{for $m \leq N$} \end{cases*}$
\end{itemize}
we can express the inductive form of the channels
\begin{itemize}
\item $\begin{cases*} \Sqr(0) \coloneqq \read{\Col(0,0)} \smallskip \\ \Sqr(n+1) \coloneqq b_\mathsf{S} \leftarrow \Sqr(n); \ b_\mathsf{R} \leftarrow \Row(n,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,n+1); \ \ret{(b_\mathsf{S} \oplus b_\mathsf{R}) \oplus b_\mathsf{C}} \\ \hspace{10pt} \text{for $n \leq N$} \end{cases*}$
\end{itemize}
equivalently using the following closed form:
\begin{itemize}
\item $\Sqr(n) \coloneqq x_\Sigma \leftarrow \SumShare(n,k); \ y_\Sigma \leftarrow \SumShare(n,l); \ \ret{x_\Sigma * y_\Sigma}$ for $n \leq N+1$
\end{itemize}
In the base case $n = 0$, substituting the channel
\begin{itemize}
\item $\Col(0,0) \coloneqq \read{\Ctrb(0,0,K)}$
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\Sqr(0) \coloneqq \read{\Col(0,0)}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\Sqr(0) \coloneqq \read{\Ctrb(0,0,K)}$
\end{itemize}
Further substituting the channel
\begin{itemize}
\item $\Ctrb(0,0,K) \coloneqq x_0 \leftarrow \Share(0,k); \ y_0 \leftarrow \Share(0,l); \ \ret{x_0 * y_0}$
\end{itemize}
into the channel $\Sqr(0)$ yields the following:
\begin{itemize}
\item $\Sqr(0) \coloneqq x_0 \leftarrow \Share(0,k); \ y_0 \leftarrow \Share(0,l); \ \ret{x_0 * y_0}$
\end{itemize}
But this is precisely what we get if we substitute the channels
\begin{itemize}
\item $\SumShare(0,k) \coloneqq x_0 \leftarrow \Share(0,k); \ \ret{x_0}$
\item $\SumShare(0,l) \coloneqq y_0 \leftarrow \Share(0,l); \ \ret{y_0}$
\end{itemize}
into the closed form of the channel below:
\begin{itemize}
\item $\Sqr(0) \coloneqq x_\Sigma \leftarrow \SumShare(0,k); \ y_\Sigma \leftarrow \SumShare(0,l); \ \ret{x_\Sigma * y_\Sigma}$
\end{itemize}
Hence the inductive form and the closed form of the channel $\Sqr(0)$ are equivalent.

In the inductive case $n+1$, we substitute the channel
\begin{itemize}
\item $\Col(n+1,n+1) \coloneqq b_\mathsf{C} \leftarrow \Col(n+1,n); \ b \leftarrow \Ctrb(n+1,n+1,K); \ \ret{b_\mathsf{C} \oplus b}$
\end{itemize}
into the channel
\begin{itemize}
\item $\Sqr(n+1) \coloneqq b_\mathsf{S} \leftarrow \Sqr(n); \ b_\mathsf{R} \leftarrow \Row(n,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,n+1); \ \ret{(b_\mathsf{S} \oplus b_\mathsf{R}) \oplus b_\mathsf{C}}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\Sqr(n+1) \coloneqq b_\mathsf{S} \leftarrow \Sqr(n); \ b_\mathsf{R} \leftarrow \Row(n,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,n); \\ b \leftarrow \Ctrb(n+1,n+1,K); \ \ret{(b_\mathsf{S} \oplus b_\mathsf{R}) \oplus(b_\mathsf{C} \oplus b)}$
\end{itemize}
After a slight rearrangement we get the following:
\begin{itemize}
\item $\Sqr(n+1) \coloneqq b_\mathsf{S} \leftarrow \Sqr(n); \ b_\mathsf{R} \leftarrow \Row(n,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,n); \\ b \leftarrow \Ctrb(n+1,n+1,K); \ \ret{b_\mathsf{S} \oplus (b_\mathsf{R} \oplus b_\mathsf{C}) \oplus b}$
\end{itemize}
We now introduce new internal channels 
\begin{itemize}
\item $\DiagRefl(i) \coloneqq b \leftarrow \Ctrb(i,n+1,K); \ b_* \leftarrow \Ctrb(n+1,i,K); \ \ret{b \oplus b_*}$ for $i \leq n$
\item $\RowCol(i) \coloneqq b_\mathsf{R} \leftarrow \Row(i,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,i); \ \ret{b_\mathsf{R} \oplus b_\mathsf{C}}$ for $i \leq n$
\end{itemize}
that sum up a single contribution,  respectively a row of contributions, with its reflection (a single contribution, respectively a column of contributions) along the bottom left-top right diagonal.

In the presence of the channel
\begin{itemize}
\item $\RowCol(n) \coloneqq b_\mathsf{R} \leftarrow \Row(n,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,n); \ \ret{b_\mathsf{R} \oplus b_\mathsf{C}}$
\end{itemize}
we can express the channel $\Sqr(n+1)$ more concisely as follows:
\begin{itemize}
\item $\Sqr(n+1) \coloneqq b_\mathsf{S} \leftarrow \Sqr(n); \ b_\mathsf{RC} \leftarrow \RowCol(n); \ b \leftarrow \Ctrb(n+1,n+1,K); \ \ret{b_\mathsf{S} \oplus b_\mathsf{RC} \oplus b}$
\end{itemize}
We now observe that we can express the closed form of the channels
\begin{itemize}
\item $\RowCol(i) \coloneqq b_\mathsf{R} \leftarrow \Row(i,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,i); \ \ret{b_\mathsf{R} \oplus b_\mathsf{C}}$ for $i \leq n$
\end{itemize}
equivalently by induction:
\begin{itemize}
\item $\begin{cases*} \RowCol(0) \coloneqq \read{\DiagRefl(0)} \smallskip \\ \RowCol(i+1) \coloneqq b_\Sigma \leftarrow \RowCol(i); \ b_{i+1} \leftarrow \DiagRefl(i+1); \ \ret{b_\Sigma \oplus b_{i+1}} \\ \hspace{10pt} \text{for $i < n$} \end{cases*}$
\end{itemize}
In the base case $i = 0$, we substitute the channel
\begin{itemize}
\item $\DiagRefl(0) \coloneqq b \leftarrow \Ctrb(0,n+1,K); \ b_* \leftarrow \Ctrb(n+1,0,K); \ \ret{b \oplus b_*}$
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\RowCol(0) \coloneqq \read{\DiagRefl(0)}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\RowCol(0) \coloneqq b \leftarrow \Ctrb(0,n+1,K); \ b_* \leftarrow \Ctrb(n+1,0,K); \ \ret{b \oplus b_*}$
\end{itemize}
But this is precisely what we get if we substitute the channels
\begin{itemize}
\item $\Row(0,n+1) \coloneqq b \leftarrow \Ctrb(0,n+1,K); \ \ret{b}$
\item $\Col(n+1,0) \coloneqq b_* \leftarrow \Ctrb(n+1,0,K); \ \ret{b_*}$
\end{itemize}
into the closed form of the channel below:
\begin{itemize}
\item $\RowCol(0) \coloneqq b_\mathsf{R} \leftarrow \Row(0,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,0); \ \ret{b_\mathsf{R} \oplus b_\mathsf{C}}$
\end{itemize}
Hence the closed form and the inductive form of the channel $\RowCol(0)$ are equivalent.

In the inductive case $i+1$, we substitute the channels
\begin{itemize}
\item $\RowCol(i) \coloneqq b_\mathsf{R} \leftarrow \Row(i,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,i); \ \ret{b_\mathsf{R} \oplus b_\mathsf{C}}$ \emph{(inductive hypothesis)}
\item $\DiagRefl(i+1) \coloneqq b \leftarrow \Ctrb(i+1,n+1,K); \ b_* \leftarrow \Ctrb(n+1,i+1,K); \ \ret{b \oplus b_*}$
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\RowCol(i+1) \coloneqq b_\Sigma \leftarrow \RowCol(i); \ b_{i+1} \leftarrow \DiagRefl(i+1); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\RowCol(i+1) \coloneqq b_\mathsf{R} \leftarrow \Row(i,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,i); \\ b \leftarrow \Ctrb(i+1,n+1,K); \ b_* \leftarrow \Ctrb(n+1,i+1,K); \ \ret{(b_\mathsf{R} \oplus b_\mathsf{C}) \oplus (b \oplus b_*)}$
\end{itemize}
After a slight rearrangement we get the following:
\begin{itemize}
\item $\RowCol(i+1) \coloneqq b_\mathsf{R} \leftarrow \Row(i,n+1); \ b \leftarrow \Ctrb(i+1,n+1,K); \\ b_\mathsf{C} \leftarrow \Col(n+1,i); \ b_* \leftarrow \Ctrb(n+1,i+1,K); \ \ret{(b_\mathsf{R} \oplus b) \oplus (b_\mathsf{C} \oplus b_*)}$
\end{itemize}
But this is precisely what we get if we substitute the channels
\begin{itemize}
\item $\Row(i+1,n+1) \coloneqq b_\mathsf{R} \leftarrow \Row(i,n+1); \ b \leftarrow \Ctrb(i+1,n+1,K); \ \ret{b_\mathsf{R} \oplus b}$
\item $\Col(n+1,i+1) \coloneqq b_\mathsf{C} \leftarrow \Col(n+1,i); \ b_* \leftarrow \Ctrb(n+1,i+1,K); \ \ret{b_\mathsf{C} \oplus b_*}$
\end{itemize}
into the closed form of the channel below:
\begin{itemize}
\item $\RowCol(i+1) \coloneqq b_\mathsf{R} \leftarrow \Row(i+1,n+1); \ b_\mathsf{C} \leftarrow \Col(n+1,i+1); \ \ret{b_\mathsf{R} \oplus b_\mathsf{C}}$
\end{itemize}
Hence the closed form and the inductive form of the channel $\RowCol(i+1)$ are equivalent.

We next observe that we can express the channels
\begin{itemize}
\item $\DiagRefl(i) \coloneqq b \leftarrow \Ctrb(i,n+1,K); \ b_* \leftarrow \Ctrb(n+1,i,K); \ \ret{b \oplus b_*}$ for $i \leq n$
\end{itemize}
equivalently as follows:
\begin{itemize}
\item $\DiagRefl(i) \coloneqq x_i \leftarrow \Share(i,k); \ y_i \leftarrow \Share(i,l); \ x_{n+1} \leftarrow \Share(n+1,k); \\ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{(x_i * y_{n+1}) \oplus (x_{n+1} * y_i)}$ for $i \leq n$
\end{itemize}
For any party $i \leq n$, substituting the channels
\begin{itemize}
\item $\Ctrb(i,n+1,K) \coloneqq \read{\SendBit(i,n+1,K)}$
\item $\Ctrb(n+1,i,K) \coloneqq \read{\RcvdBit(n+1,i,K)}$
\end{itemize}
into the channel
\begin{itemize}
\item $\DiagRefl(i) \coloneqq b  \leftarrow \Ctrb(i,n+1,K); \ b_* \leftarrow \Ctrb(n+1,i,K); \ \ret{b  \oplus b_*}$
\end{itemize}
yields the following:
\begin{itemize}
\item $\DiagRefl(i) \coloneqq b \leftarrow \SendBit(i,n+1,K); \ b_* \leftarrow \RcvdBit(n+1,i,K); \ \ret{b \oplus b_*}$
\end{itemize}
Further substituting the channel
\begin{itemize}
\item $\RcvdBit(n+1,i,K) \coloneqq b \leftarrow \SendBit(i,n+1,K); \ x_i \leftarrow \Share(i,k); \ y_i \leftarrow \Share(i,l); \\ x_{n+1} \leftarrow \Share(n+1,k); \ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{b \oplus (x_i * y_{n+1}) \oplus (x_{n+1} * y_i)}$
\end{itemize}
into the channel $\DiagRefl(i)$ yields the following:
\begin{itemize}
\item $\DiagRefl(i) \coloneqq b \leftarrow \SendBit(i,n+1,K); \ x_i \leftarrow \Share(i,k); \ y_i \leftarrow \Share(i,l); \\ x_{n+1} \leftarrow \Share(n+1,k); \ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{b \oplus \big(b \oplus (x_i * y_{n+1}) \oplus (x_{n+1} * y_i)\big)}$
\end{itemize}
Canceling out the two applications of $b \oplus -$ yields the following:
\begin{itemize}
\item $\DiagRefl(i) \coloneqq b \leftarrow \SendBit(i,n+1,K); \ x_i \leftarrow \Share(i,k); \ y_i \leftarrow \Share(i,l); \\ x_{n+1} \leftarrow \Share(n+1,k); \ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{(x_i * y_{n+1}) \oplus (x_{n+1} * y_i)}$
\end{itemize}
We can drop the dependency on the unused channel
\begin{itemize}
\item $\SendBit(i,n+1,K) \coloneqq x_i \leftarrow \Share(i,k); \ y_i \leftarrow \Share(i,l); \ \samp{\flip}$
\end{itemize}
because it only reads from the channels $\Share(i,k)$ and $\Share(i,l)$, which $\DiagRefl(i)$ reads from as well:
\begin{itemize}
\item $\DiagRefl(i) \coloneqq x_i \leftarrow \Share(i,k); \ y_i \leftarrow \Share(i,l); \ x_{n+1} \leftarrow \Share(n+1,k); \\ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{(x_i * y_{n+1}) \oplus (x_{n+1} * y_i)}$
\end{itemize}
But this is precisely the desired form of $\DiagRefl(i)$.

We now observe that we can express the inductive form of the channels
\begin{itemize}
\item $\begin{cases*} \RowCol(0) \coloneqq \read{\DiagRefl(0)} \smallskip \\ \RowCol(i+1) \coloneqq b_\Sigma \leftarrow \RowCol(i); \ b_{i+1} \leftarrow \DiagRefl(i+1); \ \ret{b_\Sigma \oplus b_{i+1}} \\ \hspace{10pt} \text{for $i < n$} \end{cases*}$
\end{itemize}
equivalently using the following closed form:
\begin{itemize}
\item $\RowCol(i) \coloneqq x_\Sigma \leftarrow \SumShare(i,k); \ y_\Sigma \leftarrow \SumShare(i,l); \ x_{n+1} \leftarrow \Share(n+1,k); \\ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{(x_\Sigma * y_{n+1}) \oplus (x_{n+1} * y_\Sigma)}$ for $i \leq n$
\end{itemize}
In the base case $i = 0$, we substitute the channel
\begin{itemize}
\item $\DiagRefl(0) \coloneqq x_0 \leftarrow \Share(0,k); \ y_0 \leftarrow \Share(0,l); \ x_{n+1} \leftarrow \Share(n+1,k); \\ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{(x_0 * y_{n+1}) \oplus (x_{n+1} * y_0)}$
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\RowCol(0) \coloneqq \read{\DiagRefl(0)}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\RowCol(0) \coloneqq x_0 \leftarrow \Share(0,k); \ y_0 \leftarrow \Share(0,l); \ x_{n+1} \leftarrow \Share(n+1,k); \\ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{(x_0 * y_{n+1}) \oplus (x_{n+1} * y_0)}$
\end{itemize}
But this is precisely what we get if we substitute the channels
\begin{itemize}
\item $\SumShare(0,k) \coloneqq x_0 \leftarrow \Share(0,k); \ \ret{x_0}$
\item $\SumShare(0,l) \coloneqq y_0 \leftarrow \Share(0,l); \ \ret{y_0}$
\end{itemize}
into the closed form of the channel below:
\begin{itemize}
\item $\RowCol(0) \coloneqq x_\Sigma \leftarrow \SumShare(0,k); \ y_\Sigma \leftarrow \SumShare(0,l); \ x_{n+1} \leftarrow \Share(n+1,k); \\ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{(x_\Sigma * y_{n+1}) \oplus (x_{n+1} * y_\Sigma)}$
\end{itemize}
Hence the inductive form and the closed form of the channel $\RowCol(0)$ are equivalent.

In the inductive case $i+1$, we substitute the channels
\begin{itemize}
\item $\RowCol(i) \coloneqq x_\Sigma \leftarrow \SumShare(i,k); \ y_\Sigma \leftarrow \SumShare(i,l); \ x_{n+1} \leftarrow \Share(n+1,k); \\ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{(x_\Sigma * y_{n+1}) \oplus (x_{n+1} * y_\Sigma)}$ \emph{(inductive hypothesis)}
\item $\DiagRefl(i+1) \coloneqq x_{i+1} \leftarrow \Share(i+1,k); \ y_{i+1} \leftarrow \Share(i+1,l); \\ x_{n+1} \leftarrow \Share(n+1,k); \ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{(x_{i+1} * y_{n+1}) \oplus (x_{n+1} * y_{i+1})}$
\end{itemize}
into the inductive form of the channel
\begin{itemize}
\item $\RowCol(i+1) \coloneqq b_\Sigma \leftarrow \RowCol(i); \ b_{i+1} \leftarrow \DiagRefl(i+1); \ \ret{b_\Sigma \oplus b_{i+1}}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\RowCol(i+1) \coloneqq x_\Sigma \leftarrow \SumShare(i,k); \ y_\Sigma \leftarrow \SumShare(i,l); \ x_{n+1} \leftarrow \Share(n+1,k); \\ y_{n+1} \leftarrow \Share(n+1,l); \ x_{i+1} \leftarrow \Share(i+1,k); \ y_{i+1} \leftarrow \Share(i+1,l); \\ \ret{(x_\Sigma * y_{n+1}) \oplus (x_{n+1} * y_\Sigma) \oplus (x_{i+1} * y_{n+1}) \oplus (x_{n+1} * y_{i+1})}$
\end{itemize}
After a slight rearrangement we get the following:
\begin{itemize}
\item $\RowCol(i+1) \coloneqq x_\Sigma \leftarrow \SumShare(i,k); \ x_{i+1} \leftarrow \Share(i+1,k); \ y_\Sigma \leftarrow \SumShare(i,l); \\ y_{i+1} \leftarrow \Share(i+1,l); \ x_{n+1} \leftarrow \Share(n+1,k); \ y_{n+1} \leftarrow \Share(n+1,l); \\ \ret{(x_\Sigma * y_{n+1}) \oplus (x_{i+1} * y_{n+1}) \oplus (x_{n+1} * y_\Sigma) \oplus (x_{n+1} * y_{i+1})}$
\end{itemize}
The above is equivalent to the following:
\begin{itemize}
\item $\RowCol(i+1) \coloneqq x_\Sigma \leftarrow \SumShare(i,k); \ x_{i+1} \leftarrow \Share(i+1,k); \ y_\Sigma \leftarrow \SumShare(i,l); \\ y_{i+1} \leftarrow \Share(i+1,l); \ x_{n+1} \leftarrow \Share(n+1,k); \ y_{n+1} \leftarrow \Share(n+1,l); \\ \ret{\big((x_\Sigma \oplus x_{i+1}) * y_{n+1}) \oplus \big(x_{n+1} * (y_\Sigma \oplus y_{i+1})\big)}$
\end{itemize}
But this is precisely what we get if we substitute the channels
\begin{itemize}
\item $\SumShare(i+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(i,k); \ x_{i+1} \leftarrow \Share(i+1,k); \ \ret{x_\Sigma \oplus x_{i+1}}$
\item $\SumShare(i+1,l) \coloneqq y_\Sigma \leftarrow \SumShare(i,l); \ y_{i+1} \leftarrow \Share(i+1,l); \ \ret{y_\Sigma \oplus y_{i+1}}$
\end{itemize}
into the closed form of the channel below:
\begin{itemize}
\item $\RowCol(i+1) \coloneqq x_\Sigma \leftarrow \SumShare(i+1,k); \ y_\Sigma \leftarrow \SumShare(i+1,l); \\ x_{n+1} \leftarrow \Share(n+1,k); \ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{(x_\Sigma * y_{n+1}) \oplus (x_{n+1} * y_\Sigma)}$
\end{itemize}
Hence the inductive form and the closed form of the channel $\RowCol(i+1)$ are equivalent.

The channels $\DiagRefl(-)$ are now unused and can be discarded.

We now substitute the channels
\begin{itemize}
\item $\Sqr(n) \coloneqq x_\Sigma \leftarrow \SumShare(n,k); \ y_\Sigma \leftarrow \SumShare(n,l); \ \ret{x_\Sigma * y_\Sigma}$ \emph{(inductive hypothesis)}
\item $\RowCol(n) \coloneqq x_\Sigma \leftarrow \SumShare(n,k); \ y_\Sigma \leftarrow \SumShare(n,l); \ x_{n+1} \leftarrow \Share(n+1,k); \\ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{(x_\Sigma * y_{n+1}) \oplus (x_{n+1} * y_\Sigma)}$
\item $\Ctrb(n+1,n+1,K) \coloneqq x_{n+1} \leftarrow \Share(n+1,k); \ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{x_{n+1} * y_{n+1}}$
\end{itemize}
into the channel
\begin{itemize}
\item $\Sqr(n+1) \coloneqq b_\mathsf{S} \leftarrow \Sqr(n); \ b_\mathsf{RC} \leftarrow \RowCol(n); \ b \leftarrow \Ctrb(n+1,n+1,K); \ \ret{b_\mathsf{S} \oplus b_\mathsf{RC} \oplus b}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\Sqr(n+1) \coloneqq x_\Sigma \leftarrow \SumShare(n,k); \ y_\Sigma \leftarrow \SumShare(n,l); \ x_{n+1} \leftarrow \Share(n+1,k); \\ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{(x_\Sigma * y_\Sigma) \oplus (x_\Sigma * y_{n+1}) \oplus (x_{n+1} * y_\Sigma) \oplus (x_{n+1} * y_{n+1})}$
\end{itemize}
The channels $\RowCol(-)$ are now unused and can be discarded.

After a slight rearrangement of the channel $\Sqr(n+1)$ we get the following:
\begin{itemize}
\item $\Sqr(n+1) \coloneqq x_\Sigma \leftarrow \SumShare(n,k); \ x_{n+1} \leftarrow \Share(n+1,k); \ y_\Sigma \leftarrow \SumShare(n,l); \\ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{(x_\Sigma * y_\Sigma) \oplus (x_\Sigma * y_{n+1}) \oplus (x_{n+1} * y_\Sigma) \oplus (x_{n+1} * y_{n+1})}$
\end{itemize}
The above is equivalent to the following:
\begin{itemize}
\item $\Sqr(n+1) \coloneqq x_\Sigma \leftarrow \SumShare(n,k); \ x_{n+1} \leftarrow \Share(n+1,k); \ y_\Sigma \leftarrow \SumShare(n,l); \\ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{(x_\Sigma \oplus x_{n+1}) * (y_\Sigma \oplus y_{n+1})}$
\end{itemize}
But this is precisely what we get if we substitute the channels
\begin{itemize}
\item $\SumShare(n+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(n,k); \ x_{n+1} \leftarrow \Share(n+1,k); \ \ret{x_\Sigma \oplus x_{n+1}}$
\item $\SumShare(n+1,l) \coloneqq y_\Sigma \leftarrow \SumShare(n,l); \ y_{n+1} \leftarrow \Share(n+1,l); \ \ret{y_\Sigma \oplus y_{n+1}}$
\end{itemize}
into the closed form of the channel below:
\begin{itemize}
\item $\Sqr(n+1) \coloneqq x_\Sigma \leftarrow \SumShare(n+1,k); \ y_\Sigma \leftarrow \SumShare(n+1,l); \ \ret{x_\Sigma * y_\Sigma}$
\end{itemize}
Hence the inductive form and the closed form of the channel $\Sqr(n+1)$ are equivalent.

The channels $\Row(-,-)$, $\Col(-,-)$ are now unused and can be discarded.

Finally, we substitute the channel
\begin{itemize}
\item $\Sqr(N+1) \coloneqq x \leftarrow \SumShare(N+1,k); \ y \leftarrow \SumShare(N+1,l); \ \ret{x * y}$
\end{itemize}
into the channel
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq \read{\Sqr(N+1)}$
\end{itemize}
which yields the following:
\begin{itemize}
\item $\SumShare(N+1,K) \coloneqq x\leftarrow \SumShare(N+1,k); \ y \leftarrow \SumShare(N+1,l); \ \ret{x * y}$
\end{itemize}
But this is precisely the desired inductive form of the channel $\SumShare(N+1,K)$.

The channels $\Sqr(-,-)$ are now unused and can be discarded.
\end{itemize}

We have now shown that summing up the respective shares $\bigoplus_{i \leq N+1} x_i$ of each party on a given wire yields the actual value $x$ carried by the wire. Currently the computation is performed by the channels $\SumShare(N+1,-)$ but we can extract it out into a separate protocol $\Wires(C,K)$ as defined in the ideal functionality. Specifically, we introduce new internal channels
\begin{itemize}
\item $\Wire(k) \coloneqq \read{\SumShare(N+1,k)}$ for $k < K$
\end{itemize}
and observe that together with the protocol $\Shares(C,K)$ we can express them equivalently as the channels
\begin{itemize}
\item $\SumShare(N+1,k) \coloneqq \read{\Wire(k)}$ for $k < K$
\end{itemize}
together with the aforementioned protocol $\Wires(C,K)$ and the following new form of the protocol $\Shares(C,K)$:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\InShare(n,p,i)}$ for $n \leq N$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\Share(n,k)}$ for $n \leq N$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n \oplus y_n}$ for $n \leq N$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$\smallskip
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$ for $n,m \leq N+1$\smallskip
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$
\item $\begin{cases*} \SumCtrb(n,0,K) \coloneqq \read{\Ctrb(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N+1$} \\ \SumCtrb(n,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(n,m,K); \ b \leftarrow \Ctrb(n,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$} \end{cases*}$\smallskip
\item $\Share(n,K) \coloneqq \read{\SumCtrb(n,N+1,K)}$ for $n \leq N$
\end{itemize}
\end{itemize}

\subsubsection{Eliminating Shares of Party \texorpdfstring{$N+1$}{N+1}}\label{sect:gmwn_eliminating_shares}
We start by eliminating the channels $\InShareGen(N+1,-,-)$, $\InShare(N+1,-,-)$ from the initial part of the protocol. If party $n$ is semi-honest, then for any input $i < I_n$ the channels
\begin{itemize}
\item {\color{blue} $\LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(N+1,n,i)}$}
\item {\color{blue} $\LeakSendInShare(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(N+1,n,i)}$}
\end{itemize}
read from the channel
\begin{itemize}
\item $\InShareGen(N+1,n,i) \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \In(n,i); \ \ret{x_\Sigma \oplus x}$
\end{itemize}
so we can substitute:
\begin{itemize}
\item {\color{blue} $\LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \In(n,i); \ \ret{x_\Sigma \oplus x}$}
\item {\color{blue} $\LeakSendInShare(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \In(n,i); \ \ret{x_\Sigma \oplus x}$}
\end{itemize}
We thus get the following for channels $\LeakInShareGen(N+1,-,-)^{\party(-)}_\adv$ and $\LeakSendInShare(N+1,-,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \In(n,i); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShareGen(N+1,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSendInShare(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \In(n,i); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSendInShare(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSendInShare(N+1,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\end{itemize}
The leakages
\begin{itemize}
\item {\color{blue} $\LeakRcvdInShare(N+1,n,i)^{\party(N+1)}_\adv \coloneqq \read{\LeakRcvdInShare(N+1,n,i)^{\party(N+1)}_\adv}$ for $n \leq N+1$ and $i < I_n$}
\end{itemize}
are vacuous since party $N+1$ is by assumption honest. Finally, substituting the channels
\begin{itemize}
\item $\InShareGen(N+1,n,i) \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \In(n,i); \ \ret{x_\Sigma \oplus x}$ for $n \leq N+1$ and $i < I_n$ 
\end{itemize}
into the channels
\begin{itemize}
\item $\InShare(N+1,n,i) \coloneqq \read{\InShareGen(N+1,n,i)}$ for $n \leq N+1$ and $i < I_n$
\end{itemize}
yields the following:
\begin{itemize}
\item $\InShare(N+1,n,i) \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \In(n,i); \ \ret{x_\Sigma \oplus x}$ for $n \leq N+1$ and $i < I_n$ 
\end{itemize}
At this point, the internal channels $\InShareGen(N+1,-,-)$ are unused and can be eliminated.\smallskip

\noindent The leakages
\begin{itemize}
\item {\color{blue} $\LeakInShare(N+1,n,i)^{\party(N+1)}_\adv \coloneqq \read{\LeakInShare(N+1,n,i)^{\party(N+1)}_\adv}$ for $n \leq N+1$ and $i < I_n$}
\end{itemize}
are again vacuous since party $N+1$ is by assumption honest. The top-level internal channels $\InShare(N+1,-,-)$ are now unused by the rest of the protocol and can also be eliminated. The resulting version $\Init$ of the initial part of the real protocol is therefore as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\In(n,i)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakIn(n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq x \leftarrow \In(n,i); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \\ \LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInRcvd(n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \end{cases*}$}
\item $\InShareGen(m,n,i) \coloneqq x \leftarrow \In(n,i); \ \samp{\flip}$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$
\item {\color{blue} $\begin{cases*} \LeakInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShareGen(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item $\begin{cases*} \SumInShareGen(0,n,i) \coloneqq \read{\InShareGen(0,n,i)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$} \\ \SumInShareGen(m+1,n,i) \coloneqq x_\Sigma \leftarrow \SumInShareGen(m,n,i); \ x_{m+1} \leftarrow \InShareGen(m+1,n,i); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$ and $n \leq N+1$ and $i < I_n$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSumInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\SumInShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSumInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSumInShareGen(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \In(n,i); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShareGen(N+1,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSendInShare(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSendInShare(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \In(n,i); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSendInShare(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSendInShare(N+1,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $m$ semi-honest} \\ \LeakRcvdInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\LeakRcvdInShare(m,n,i)^{\party(m)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $m$ honest} \end{cases*}$}
\item {\color{blue} $\LeakRcvdInShare(N+1,n,i)^{\party(N+1)}_\adv \coloneqq \read{\LeakRcvdInShare(N+1,n,i)^{\party(N+1)}_\adv}$ for $n \leq N+1$ and $i < I_n$}
\item $\InShare(m,n,i) \coloneqq \read{\InShareGen(m,n,i)}$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$
\item {\color{blue} $\begin{cases*} \LeakInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\InShare(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $m$ semi-honest} \\ \LeakInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\LeakInShare(m,n,i)^{\party(m)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $m$ honest} \end{cases*}$}
\item {\color{blue} $\LeakInShare(N+1,n,i)^{\party(N+1)}_\adv \coloneqq \read{\LeakInShare(N+1,n,i)^{\party(N+1)}_\adv}$ for $n \leq N+1$ and $i < I_n$}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\InShareGen(m,n,i)$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$,
\item $\SumInShareGen(m,n,i)$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$.
\end{itemize}

We now eliminate the channels $\SendBit(N+1,-,-)$, $\RcvdBit(N+1,-,-)$, $\Ctrb(N+1,-,-)$, $\SumCtrb(N+1,-,-)$, $\Share(N+1,-)$ from the inductive part of the real protocol. To this end, we first revisit the protocol $\Adv(C,K)$. In the case of \emph{input-}, \emph{not-}, and \emph{xor} gates, the leakage
\begin{itemize}
\item {\color{blue} $\LeakShare(N+1,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakShare(N+1,K)^{\party(N+1)}_\adv}$}
\end{itemize}
is vacuous since party $N+1$ is by assumption honest. In the case of an \emph{and} gate, the leakages
\begin{itemize}
\item {\color{blue} $\LeakSendBit(N+1,m,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakSendBit(N+1,m,K)^{\party(N+1)}_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(N+1,m,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakRcvdBit(N+1,m,K)^{\party(N+1)}_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\LeakCtrb(N+1,m,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakCtrb(N+1,m,K)^{\party(N+1)}_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(N+1,m,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakSumCtrb(N+1,m,K)^{\party(N+1)}_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\LeakShare(N+1,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakShare(N+1,K)^{\party(N+1)}_\adv}$}
\end{itemize}
are likewise vacuous since party $N+1$ is by assumption honest, and so are the leakages below:
\begin{itemize}
\item {\color{blue} $\LeakOTMsg_0(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}
\end{itemize}
On the other hand, the leakages
\begin{itemize}
\item {\color{blue} $\LeakOTMsgRcvd_0(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}
\end{itemize}
are vacuous because $N+1 \geq m$ for each party $m$, so party $N+1$ cannot ever function as a sender. The leakages
\begin{itemize}
\item {\color{blue} $\LeakOTChc_0(n,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,N+1,K)^\ot_\adv}$ for $n \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,N+1,K)^\ot_\adv}$ for $n \leq N+1$}
\end{itemize}
are again vacuous because party $N+1$ is honest, and so are the leakages below:
\begin{itemize}
\item {\color{blue} $\LeakOTOut(n,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,N+1,K)^\ot_\adv}$ for $n \leq N+1$}
\end{itemize}
The latest version of the protocol $\Adv(C,K)$ is therefore as follows:

\begin{itemize}
\item $\Adv(\epsilon,0)$ is the protocol $\zero$

\item $\Adv\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\LeakShare(N+1,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakShare(N+1,K)^{\party(N+1)}_\adv}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\LeakShare(N+1,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakShare(N+1,K)^{\party(N+1)}_\adv}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\LeakShare(N+1,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakShare(N+1,K)^{\party(N+1)}_\adv}$}
\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Adv\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Adv(C,K)$ with the protocol
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest} \\ \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakSendBit(N+1,m,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakSendBit(N+1,m,K)^{\party(N+1)}_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest} \\ \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakRcvdBit(N+1,m,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakRcvdBit(N+1,m,K)^{\party(N+1)}_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\Ctrb(n,m,K)} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest} \\ \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakCtrb(N+1,m,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakCtrb(N+1,m,K)^{\party(N+1)}_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SumCtrb(n,m,K)} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest} \\ \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakSumCtrb(N+1,m,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakSumCtrb(N+1,m,K)^{\party(N+1)}_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ honest} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakShare(N+1,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakShare(N+1,K)^{\party(N+1)}_\adv}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_1(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus y_n} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_2(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n \oplus y_n} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_3(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_1(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_2(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_3(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,N+1,K)^\ot_\adv}$ for $n \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,l)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTChc_1(n,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,N+1,K)^\ot_\adv}$ for $n \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq x_m \leftarrow \Share(m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq y_m \leftarrow \Share(m,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq y_\Sigma \leftarrow \SumShare(N,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\RcvdBit(m,n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest} \\ \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest} \end{cases*}$}
\item {\color{blue} $\LeakOTOut(n,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,N+1,K)^\ot_\adv}$ for $n \leq N+1$}
\end{itemize}
\end{itemize}

\noindent We now revisit the protocol $\Shares(C,K)$, the case of an \emph{and} gate. For any party $n$ the channel
\begin{itemize}
\item $\RcvdBit(n,N+1,K) \coloneqq b \leftarrow \SendBit(N+1,n,K); \ x_{N+1} \leftarrow \Share(N+1,k); \\ y_{N+1} \leftarrow \Share(N+1,l); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_{N+1} * y_n) \oplus (x_n * y_{N+1})}$
\end{itemize}
reads from the divergent channel
\begin{itemize}
\item $\SendBit(N+1,n,K) \coloneqq \read{\SendBit(N+1,n,K)}$
\end{itemize}
and so we may equivalently write the following:
\begin{itemize}
\item $\RcvdBit(n,N+1,K) \coloneqq \read{\RcvdBit(n,N+1,K)}$
\end{itemize}
The simplified definition for channels $\RcvdBit(-,N+1,K)$ is thus as follows:
\begin{itemize}
\item $\RcvdBit(n,N+1,K) \coloneqq \read{\RcvdBit(n,N+1,K)}$ for $n \leq N+1$
\end{itemize}
The latest version of the protocol $\Shares(C,K)$ is therefore as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\InShare(n,p,i)}$ for $n \leq N$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\Share(n,k)}$ for $n \leq N$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n,m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n,m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n,m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n,m \leq N+1$
\item $\Share(n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n \oplus y_n}$ for $n \leq N$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n \geq m$} \end{cases*}$\smallskip
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$ for $n \leq N+1$ and $m \leq N$
\item $\RcvdBit(n,N+1,K) \coloneqq \read{\RcvdBit(n,N+1,K)}$ for $n \leq N+1$\smallskip
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \\ \hspace{10pt} \text{for $n \leq N+1$} \end{cases*}$
\item $\begin{cases*} \SumCtrb(n,0,K) \coloneqq \read{\Ctrb(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N+1$} \\ \SumCtrb(n,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(n,m,K); \ b \leftarrow \Ctrb(n,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$} \end{cases*}$\smallskip
\item $\Share(n,K) \coloneqq \read{\SumCtrb(n,N+1,K)}$ for $n \leq N$
\end{itemize}
\end{itemize}

\noindent At this point, we can extract all computation carried out by party $N+1$ into a separate protocol $\Ctrbs_{N+1}(C,K)$:

\begin{itemize}
\item $\Ctrbs_{N+1}(\epsilon,0)$ is the protocol $\zero$

\item $\Ctrbs_{N+1}\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Ctrbs_{N+1}(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(N+1,m,K) \coloneqq \read{\SendBit(N+1,m,K)}$ for $m \leq N+1$
\item $\RcvdBit(N+1,m,K) \coloneqq \read{\RcvdBit(N+1,m,K)}$ for $m \leq N+1$
\item $\Ctrb(N+1,m,K) \coloneqq \read{\Ctrb(N+1,m,K)}$ for $m \leq N+1$
\item $\SumCtrb(N+1,m,K) \coloneqq \read{\SumCtrb(N+1,m,K)}$ for $m \leq N+1$
\end{itemize}

\item $\Ctrbs_{N+1}\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Ctrbs_{N+1}(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(N+1,m,K) \coloneqq \read{\SendBit(N+1,m,K)}$ for $m \leq N+1$
\item $\RcvdBit(N+1,m,K) \coloneqq \read{\RcvdBit(N+1,m,K)}$ for $m \leq N+1$
\item $\Ctrb(N+1,m,K) \coloneqq \read{\Ctrb(N+1,m,K)}$ for $m \leq N+1$
\item $\SumCtrb(N+1,m,K) \coloneqq \read{\SumCtrb(N+1,m,K)}$ for $m \leq N+1$
\end{itemize}

\item $\Ctrbs_{N+1}\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Ctrbs_{N+1}(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(N+1,m,K) \coloneqq \read{\SendBit(N+1,m,K)}$ for $m \leq N+1$
\item $\RcvdBit(N+1,m,K) \coloneqq \read{\RcvdBit(N+1,m,K)}$ for $m \leq N+1$
\item $\Ctrb(N+1,m,K) \coloneqq \read{\Ctrb(N+1,m,K)}$ for $m \leq N+1$
\item $\SumCtrb(N+1,m,K) \coloneqq \read{\SumCtrb(N+1,m,K)}$ for $m \leq N+1$
\end{itemize}

\item $\Ctrbs_{N+1}\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Ctrbs_{N+1}(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(N+1,m,K) \coloneqq \read{\SendBit(N+1,m,K)}$ for $m \leq N+1$
\item $\RcvdBit(N+1,m,K) \coloneqq b \leftarrow \SendBit(m,N+1,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_{N+1} \leftarrow \Share(N+1,k); \ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{b \oplus (x_m * y_{N+1}) \oplus (x_{N+1} * y_m)}$ for $m \leq N$
\item $\RcvdBit(N+1,N+1,K) \coloneqq \read{\RcvdBit(N+1,N+1,K)}$\smallskip
\item $\begin{cases*} \Ctrb(N+1,m,K) \coloneqq \read{\RcvdBit(N+1,m,K)} \\ \hspace{10pt} \text{for $m \leq N$} \\ \Ctrb(N+1,N+1,K) \coloneqq x_{N+1} \leftarrow \Share(N+1,k); \ y_{N+1} \leftarrow \Share(N+1,l); \ \ret{x_{N+1} * y_{N+1}}\end{cases*}$\smallskip
\item $\begin{cases*} \SumCtrb(N+1,0,K) \coloneqq \read{\Ctrb(N+1,0,K)} \smallskip \\ \SumCtrb(N+1,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(N+1,m,K); \ b \leftarrow \Ctrb(N+1,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $m \leq N$} \end{cases*}$
\end{itemize}
\end{itemize}

\noindent After the extraction, the protocol $\Shares(C,K)$ is left looking as follows:

\begin{itemize}
\item $\Shares(\epsilon,0)$ is the protocol $\zero$

\item $\Shares\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\InShare(n,p,i)}$ for $n \leq N$
\end{itemize}

\item $\Shares\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item $\Share(n,K) \coloneqq \read{\Share(n,k)}$ for $n \leq N$
\end{itemize}

\item $\Shares\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item $\Share(n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n \oplus y_n}$ for $n \leq N$
\end{itemize}

\item $\Shares\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Shares(C,K)$ with the protocol
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n \geq m$} \end{cases*}$\smallskip
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$ for $n,m \leq N$
\item $\RcvdBit(n,N+1,K) \coloneqq \read{\RcvdBit(n,N+1,K)}$ for $n \leq N$\smallskip
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \\ \hspace{10pt} \text{for $n \leq N$} \end{cases*}$
\item $\begin{cases*} \SumCtrb(n,0,K) \coloneqq \read{\Ctrb(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \SumCtrb(n,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(n,m,K); \ b \leftarrow \Ctrb(n,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $n,m \leq N$} \end{cases*}$\smallskip
\item $\Share(n,K) \coloneqq \read{\SumCtrb(n,N+1,K)}$ for $n \leq N$
\end{itemize}
\end{itemize}

None of the channels defined by $\Ctrbs_{N+1}(C,K)$ are utilized anywhere outside of $\Ctrbs_{N+1}(C,K)$ and as such we may discard this protocol fragment entirely. This in particular eliminates all references to the channels $\Share(N+1,-)$ from the inductive part of the protocol. To summarize, the inductive part of the real protocol now consists of the protocols $\Shares(C,K)$ and $\Adv(C,K)$, followed by the hiding of the channels
\begin{itemize}
\item $\SendBit(n,m,k)$ for $n \leq N$ and $m \leq N+1$ and $k < K$,
\item $\RcvdBit(n,m,k)$ for $n \leq N$ and $m \leq N+1$ and $k < K$,
\item $\Ctrb(n,m,k)$ for $n \leq N$ and $m \leq N+1$ and $k < K$,
\item $\SumCtrb(n,m,k)$ for $n \leq N$ and $m \leq N+1$ and $k < K$.
\end{itemize}
We recall that on the top level we also have the protocol $\Wires(C,K)$ and the channels
\begin{itemize}
\item $\begin{cases*} \SumShare(0,k) \coloneqq \read{\Share(0,k)} \\ \hspace{10pt} \text{for $k < K$} \\ \SumShare(m+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ x_{m+1} \leftarrow \Share(m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$ and $k < K$} \end{cases*}$
\end{itemize}
together with the channels below:
\begin{itemize}
\item $\SumShare(N+1,k) \coloneqq \read{\Wire(k)}$ for $k < K$
\item $\Share(N+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \SumShare(N+1,k); \ \ret{x_\Sigma \oplus x}$ for $k < K$
\end{itemize}

\noindent We now eliminate all references to the shares of party $N+1$ from the final part of the protocol. The leakages
\begin{itemize}
\item {\color{blue} $\LeakSendOutShare(m,N+1,k)^{\party(N+1)}_\adv \coloneqq \read{\LeakSendOutShare(m,N+1,k)^{\party(N+1)}_\adv}$ for $m \leq N+1$}
\end{itemize}
are vacuous since party $N+1$ is honest. If party $n$ is semi-honest and wire $k$ is an output, then the channels
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\Share(N+1,k)}$}
\item {\color{blue} $\LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\Share(N+1,k)}$}
\end{itemize}
read from the channel
\begin{itemize}
\item $\Share(N+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \SumShare(N+1,k); \ \ret{x_\Sigma \oplus x}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \SumShare(N+1,k); \ \ret{x_\Sigma \oplus x}$}
\item {\color{blue} $\LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \SumShare(N+1,k); \ \ret{x_\Sigma \oplus x}$}
\end{itemize}
We thus get the following for channels $\LeakRcvdOutShare(-,N+1,-)^{\party(-)}_\adv$ and $\LeakOutShare(-,N+1,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \SumShare(N+1,k); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \SumShare(N+1,k); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\end{itemize}
The top-level internal channels $\Share(N+1,-)$ are now unused by the rest of the protocol and can be eliminated. The resulting version $\Fin$ of the final part of the real protocol is as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m \leq N+1$ and $n \leq N$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\LeakSendOutShare(m,n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ and $n \leq N$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\LeakSendOutShare(m,N+1,k)^{\party(N+1)}_\adv \coloneqq \read{\LeakSendOutShare(m,N+1,k)^{\party(N+1)}_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \SumShare(N+1,k); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \SumShare(N+1,k); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SumShare(m,k)} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n,m \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item $\begin{cases*} \Out(n,k) \coloneqq \read{\SumShare(N+1,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $k$ an output} \\ \Out(n,k) \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $k$ not an output} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}

As a final step before the extraction of the simulator, we eliminate any reference to the channels $\SumShare(N+1,-)$ from the final part of the real protocol. If party $n$ is semi-honest and wire $k$ is an output, then we can substitute the channel
\begin{itemize}
\item $\SumShare(N+1,k) \coloneqq \read{\Wire(k)}$
\end{itemize}
into the channels
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \SumShare(N+1,k); \ \ret{x_\Sigma \oplus x}$}
\item {\color{blue} $\LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \SumShare(N+1,k); \ \ret{x_\Sigma \oplus x}$}
\end{itemize}
which yields the following:
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Wire(k); \ \ret{x_\Sigma \oplus x}$}
\item {\color{blue} $\LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Wire(k); \ \ret{x_\Sigma \oplus x}$}
\end{itemize}
We thus get the following for channels $\LeakRcvdOutShare(-,N+1,-)^{\party(-)}_\adv$ and $\LeakOutShare(-,N+1,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Wire(k); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Wire(k); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\end{itemize}
If party $n$ is semi-honest and wire $k$ is an output, then the channel
\begin{itemize}
\item {\color{blue} $\LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\SumShare(N+1,k)}$}
\end{itemize}
reads from the channel
\begin{itemize}
\item $\SumShare(N+1,k) \coloneqq \read{\Wire(k)}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item {\color{blue} $\LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\Wire(k)}$}
\end{itemize}
We thus get the following for channels $\LeakSumOutShare(-,N+1,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\end{itemize}
Finally, if wire $k$ is an output, then for any party $n$ the channel
\begin{itemize}
\item $\Out(n,k) \coloneqq \read{\SumShare(N+1,k)}$
\end{itemize}
reads from the channel
\begin{itemize}
\item $\SumShare(N+1,k) \coloneqq \read{\Wire(k)}$
\end{itemize}
so we may substitute:
\begin{itemize}
\item $\Out(n,k) \coloneqq \read{\Wire(k)}$
\end{itemize}
We thus get the following for channels $\Out(-,-)$:
\begin{itemize}
\item $\begin{cases*} \Out(n,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $k$ an output} \\ \Out(n,k) \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $k$ not an output} \end{cases*}$
\end{itemize}
The top-level internal channels $\SumShare(N+1,-)$ are now unused by the rest of the protocol and can be eliminated. The resulting version $\Fin$ of the final part of the real protocol is as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m \leq N+1$ and $n \leq N$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\LeakSendOutShare(m,n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ and $n \leq N$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\LeakSendOutShare(m,N+1,k)^{\party(N+1)}_\adv \coloneqq \read{\LeakSendOutShare(m,N+1,k)^{\party(N+1)}_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Wire(k); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Wire(k); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SumShare(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item $\begin{cases*} \Out(n,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $k$ an output} \\ \Out(n,k) \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $k$ not an output} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}

\subsubsection{Extracting The Simulator}\label{sect:gmwn_extracting_simulator}
We are now ready to extract the simulator. The internal protocol $\Wires(C,K)$ together with the output channels
\begin{itemize}
\item $\begin{cases*} \Out(n,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $k$ an output} \\ \Out(n,k) \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $k$ not an output} \end{cases*}$
\end{itemize}
will be factored out as coming from the ideal functionality. In particular, this leaves us with following version $\Fin$ of the final part of the soon-to-be simulator:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m \leq N+1$ and $n \leq N$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\LeakSendOutShare(m,n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ and $n \leq N$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\LeakSendOutShare(m,N+1,k)^{\party(N+1)}_\adv \coloneqq \read{\LeakSendOutShare(m,N+1,k)^{\party(N+1)}_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Wire(k); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Wire(k); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SumShare(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}

\noindent In the remainder of the soon-to-be simulator, we must eliminate any references to the channels $\In(-,-)$, $\Wire(-)$, $\Out(-,-)$. We begin with the initial part of the real protocol. Recall the leakage
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakIn(n,i)^\id_\adv \coloneqq \read{\In(n,i)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakIn(n,i)^\id_\adv \coloneqq \read{\LeakIn(n,i)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakInRcvd(n,i)^\id_\adv \coloneqq x \leftarrow \In(n,i); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \\ \LeakInRcvd(n,i)^\id_\adv \coloneqq \read{\LeakInRcvd(n,i)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \end{cases*}$}
\end{itemize}
from the ideal functionality. If party $n$ is semi-honest, then for any input $i < I_n$ the channel
\begin{itemize}
\item {\color{blue} $\LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\In(n,i)}$}
\end{itemize}
can be expressed equivalently as
\begin{itemize}
\item {\color{blue} $\LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakIn(n,i)^\id_\adv}$}
\end{itemize}
since we have the leakage below:
\begin{itemize}
\item {\color{blue} $\LeakIn(n,i)^\id_\adv \coloneqq \read{\In(n,i)}$}
\end{itemize}
We thus get the following for channels $\LeakIn(-,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakIn(n,i)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakIn(n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\end{itemize}
If party $n$ is honest, then for any input $i < I_n$ the channel
\begin{itemize}
\item {\color{blue} $\LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq x \leftarrow \In(n,i); \ \ret{\checkmark}$}
\end{itemize}
can be expressed equivalently as
\begin{itemize}
\item {\color{blue} $\LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInRcvd(n,i)^\id_\adv}$}
\end{itemize}
since we have the leakage below:
\begin{itemize}
\item {\color{blue} $\LeakInRcvd(n,i)^\id_\adv \coloneqq x \leftarrow \In(n,i); \ \ret{\checkmark}$}
\end{itemize}
We thus get the following for channels $ \LeakInRcvd(-,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInRcvd(n,i)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \\ \LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInRcvd(n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \end{cases*}$}
\end{itemize}
If party $n$ is semi-honest, then for any party $m$ and any input $i < I_n$ the channel
\begin{itemize}
\item $\InShareGen(m,n,i) \coloneqq x \leftarrow \In(n,i); \ \samp{\flip}$
\end{itemize}
can be expressed equivalently as
\begin{itemize}
\item $\InShareGen(m,n,i) \coloneqq x \leftarrow \LeakIn(n,i)^\id_\adv; \ \samp{\flip}$
\end{itemize}
since we have the leakage below:
\begin{itemize}
\item {\color{blue} $\LeakIn(n,i)^\id_\adv \coloneqq \read{\In(n,i)}$}
\end{itemize}
If party $n$ is honest, then for any party $m$ and any input $i < I_n$ the channel
\begin{itemize}
\item $\InShareGen(m,n,i) \coloneqq x \leftarrow \In(n,i); \ \samp{\flip}$
\end{itemize}
can be expressed equivalently as
\begin{itemize}
\item $\InShareGen(m,n,i) \coloneqq \_ \leftarrow \LeakInRcvd(n,i)^\id_\adv; \ \samp{\flip}$
\end{itemize}
since we have the leakage below:
\begin{itemize}
\item {\color{blue} $\LeakInRcvd(n,i)^\id_\adv \coloneqq x \leftarrow \In(n,i); \ \ret{\checkmark}$}
\end{itemize}
We thus get the following for channels $\InShareGen(-,-,-)$:
\begin{itemize}
\item $\begin{cases*} \InShareGen(m,n,i) \coloneqq x \leftarrow \LeakIn(n,i)^\id_\adv; \ \samp{\flip} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \InShareGen(m,n,i) \coloneqq \_ \leftarrow \LeakInRcvd(n,i)^\id_\adv; \ \samp{\flip} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$
\end{itemize}
If party $n$ is semi-honest, then for any input $i < I_n$ the channels
\begin{itemize}
\item {\color{blue} $\LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \In(n,i); \ \ret{x_\Sigma \oplus x}$}
\item {\color{blue} $\LeakSendInShare(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \In(n,i); \ \ret{x_\Sigma \oplus x}$}
\end{itemize}
can be expressed equivalently as
\begin{itemize}
\item {\color{blue} $\LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \LeakIn(n,i)^\id_\adv; \ \ret{x_\Sigma \oplus x}$}
\item {\color{blue} $\LeakSendInShare(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \LeakIn(n,i)^\id_\adv; \ \ret{x_\Sigma \oplus x}$}
\end{itemize}
since we have the leakage below:
\begin{itemize}
\item {\color{blue} $\LeakIn(n,i)^\id_\adv \coloneqq \read{\In(n,i)}$}
\end{itemize}
We thus get the following for channels $\LeakInShareGen(N+1,-,-)^{\party(-)}_\adv$ and $\LeakSendInShare(N+1,-,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \LeakIn(n,i)^\id_\adv; \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShareGen(N+1,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSendInShare(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \LeakIn(n,i)^\id_\adv; \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSendInShare(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSendInShare(N+1,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\end{itemize}
The final version $\Init$ of the initial part of the simulator is therefore as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakIn(n,i)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakIn(n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInRcvd(n,i)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \\ \LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInRcvd(n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \end{cases*}$}
\item $\begin{cases*} \InShareGen(m,n,i) \coloneqq x \leftarrow \LeakIn(n,i)^\id_\adv; \ \samp{\flip} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \InShareGen(m,n,i) \coloneqq \_ \leftarrow \LeakInRcvd(n,i)^\id_\adv; \ \samp{\flip} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShareGen(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item $\begin{cases*} \SumInShareGen(0,n,i) \coloneqq \read{\InShareGen(0,n,i)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$} \\ \SumInShareGen(m+1,n,i) \coloneqq x_\Sigma \leftarrow \SumInShareGen(m,n,i); \ x_{m+1} \leftarrow \InShareGen(m+1,n,i); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$ and $n \leq N+1$ and $i < I_n$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSumInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\SumInShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSumInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSumInShareGen(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \LeakIn(n,i)^\id_\adv; \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShareGen(N+1,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSendInShare(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSendInShare(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \LeakIn(n,i)^\id_\adv; \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSendInShare(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSendInShare(N+1,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $m$ semi-honest} \\ \LeakRcvdInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\LeakRcvdInShare(m,n,i)^{\party(m)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $m$ honest} \end{cases*}$}
\item {\color{blue} $\LeakRcvdInShare(N+1,n,i)^{\party(N+1)}_\adv \coloneqq \read{\LeakRcvdInShare(N+1,n,i)^{\party(N+1)}_\adv}$ for $n \leq N+1$ and $i < I_n$}
\item $\InShare(m,n,i) \coloneqq \read{\InShareGen(m,n,i)}$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$
\item {\color{blue} $\begin{cases*} \LeakInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\InShare(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $m$ semi-honest} \\ \LeakInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\LeakInShare(m,n,i)^{\party(m)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $m$ honest} \end{cases*}$}
\item {\color{blue} $\LeakInShare(N+1,n,i)^{\party(N+1)}_\adv \coloneqq \read{\LeakInShare(N+1,n,i)^{\party(N+1)}_\adv}$ for $n \leq N+1$ and $i < I_n$}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\InShareGen(m,n,i)$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$,
\item $\SumInShareGen(m,n,i)$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$.
\end{itemize}

\noindent We continue with the final part of the soon-to-be simulator. Recall the definition of the output channels
\begin{itemize}
\item $\begin{cases*} \Out(n,k) \coloneqq \read{\Wire(k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $k$ an output} \\ \Out(n,k) \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $k$ not an output} \end{cases*}$
\end{itemize}
in the ideal functionality. If party $n$ is semi-honest and wire $k$ is an output, then the channels
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Wire(k); \ \ret{x_\Sigma \oplus x}$}
\item {\color{blue} $\LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Wire(k); \ \ret{x_\Sigma \oplus x}$}
\end{itemize}
can be expressed equivalently as
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Out(n,k); \ \ret{x_\Sigma \oplus x}$}
\item {\color{blue} $\LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Out(n,k); \ \ret{x_\Sigma \oplus x}$}
\end{itemize}
since we have the definition below:
\begin{itemize}
\item $\Out(n,k) \coloneqq \read{\Wire(k)}$
\end{itemize}
We thus get the following for channels $\LeakRcvdOutShare(-,N+1,-)^{\party(-)}_\adv$ and $\LeakOutShare(-,N+1,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Out(n,k); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Out(n,k); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\end{itemize}
If party $n$ is semi-honest and wire $k$ is an output, then the channel
\begin{itemize}
\item {\color{blue} $\LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\Wire(k)}$}
\end{itemize}
can be expressed equivalently as
\begin{itemize}
\item {\color{blue} $\LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\Out(n,k)}$}
\end{itemize}
since we have the definition below:
\begin{itemize}
\item $\Out(n,k) \coloneqq \read{\Wire(k)}$
\end{itemize}
We thus get the following for channels $\LeakSumOutShare(-,N+1,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\end{itemize}
The latest version $\Fin$ of the final part of the soon-to-be simulator is therefore as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m \leq N+1$ and $n \leq N$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\LeakSendOutShare(m,n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ and $n \leq N$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\LeakSendOutShare(m,N+1,k)^{\party(N+1)}_\adv \coloneqq \read{\LeakSendOutShare(m,N+1,k)^{\party(N+1)}_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Out(n,k); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Out(n,k); \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SumShare(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}

\noindent We now recall the leakage
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOut(n,k)^\id_\adv \coloneqq \read{\Out(n,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOut(n,k)^\id_\adv \coloneqq \read{\LeakOut(n,k)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}
from the ideal functionality. If party $n$ is semi-honest and wire $k$ is an output, then the channels
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Out(n,k); \ \ret{x_\Sigma \oplus x}$}
\item {\color{blue} $\LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \Out(n,k); \ \ret{x_\Sigma \oplus x}$}
\end{itemize}
can be expressed equivalently as
\begin{itemize}
\item {\color{blue} $\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \LeakOut(n,k)^\id_\adv; \ \ret{x_\Sigma \oplus x}$}
\item {\color{blue} $\LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \LeakOut(n,k)^\id_\adv; \ \ret{x_\Sigma \oplus x}$}
\end{itemize}
since we have the leakage below:
\begin{itemize}
\item {\color{blue} $\LeakOut(n,k)^\id_\adv \coloneqq \read{\Out(n,k)}$}
\end{itemize}
We thus get the following for channels $\LeakRcvdOutShare(-,N+1,-)^{\party(-)}_\adv$ and $\LeakOutShare(-,N+1,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \LeakOut(n,k)^\id_\adv; \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \LeakOut(n,k)^\id_\adv; \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\end{itemize}
If party $n$ is semi-honest and wire $k$ is an output, then the channel
\begin{itemize}
\item {\color{blue} $\LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\Out(n,k)}$}
\end{itemize}
can be expressed equivalently as
\begin{itemize}
\item {\color{blue} $\LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^\id_\adv}$}
\end{itemize}
since we have the leakage below:
\begin{itemize}
\item {\color{blue} $\LeakOut(n,k)^\id_\adv \coloneqq \read{\Out(n,k)}$}
\end{itemize}
We thus get the following for channels $\LeakSumOutShare(-,N+1,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\end{itemize}
Finally, if party $n$ is semi-honest, then for any wire $k$ the channel
\begin{itemize}
\item {\color{blue} $\LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\Out(n,k)}$}
\end{itemize}
can be expressed equivalently as
\begin{itemize}
\item {\color{blue} $\LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^\id_\adv}$}
\end{itemize}
since we have the leakage below:
\begin{itemize}
\item {\color{blue} $\LeakOut(n,k)^\id_\adv \coloneqq \read{\Out(n,k)}$}
\end{itemize}
We thus get the following for channels $\LeakOut(-,-)^{\party(-)}_\adv$:
\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}
The final version $\Fin$ of the final part of the simulator is therefore as follows:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m \leq N+1$ and $n \leq N$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\LeakSendOutShare(m,n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ and $n \leq N$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\LeakSendOutShare(m,N+1,k)^{\party(N+1)}_\adv \coloneqq \read{\LeakSendOutShare(m,N+1,k)^{\party(N+1)}_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \LeakOut(n,k)^\id_\adv; \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \LeakOut(n,k)^\id_\adv; \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SumShare(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}

\subsubsection{The Simulator}
The simulator consists of four parts. In the initial phase, we have the protocol $\Init$:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakIn(n,i)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakIn(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakIn(n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInRcvd(n,i)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \\ \LeakInRcvd(n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInRcvd(n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \end{cases*}$}
\item $\begin{cases*} \InShareGen(m,n,i) \coloneqq x \leftarrow \LeakIn(n,i)^\id_\adv; \ \samp{\flip} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \InShareGen(m,n,i) \coloneqq \_ \leftarrow \LeakInRcvd(n,i)^\id_\adv; \ \samp{\flip} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShareGen(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item $\begin{cases*} \SumInShareGen(0,n,i) \coloneqq \read{\InShareGen(0,n,i)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$} \\ \SumInShareGen(m+1,n,i) \coloneqq x_\Sigma \leftarrow \SumInShareGen(m,n,i); \ x_{m+1} \leftarrow \InShareGen(m+1,n,i); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$ and $n \leq N+1$ and $i < I_n$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSumInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\SumInShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSumInShareGen(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSumInShareGen(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \LeakIn(n,i)^\id_\adv; \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakInShareGen(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakInShareGen(N+1,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSendInShare(m,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSendInShare(m,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSendInShare(N+1,n,i)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumInShareGen(N,n,i); \ x \leftarrow \LeakIn(n,i)^\id_\adv; \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ semi-honest} \\ \LeakSendInShare(N+1,n,i)^{\party(n)}_\adv \coloneqq \read{\LeakSendInShare(N+1,n,i)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $i < I_n$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\InShareGen(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $m$ semi-honest} \\ \LeakRcvdInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\LeakRcvdInShare(m,n,i)^{\party(m)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $m$ honest} \end{cases*}$}
\item {\color{blue} $\LeakRcvdInShare(N+1,n,i)^{\party(N+1)}_\adv \coloneqq \read{\LeakRcvdInShare(N+1,n,i)^{\party(N+1)}_\adv}$ for $n \leq N+1$ and $i < I_n$}
\item $\InShare(m,n,i) \coloneqq \read{\InShareGen(m,n,i)}$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$
\item {\color{blue} $\begin{cases*} \LeakInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\InShare(m,n,i)} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $m$ semi-honest} \\ \LeakInShare(m,n,i)^{\party(m)}_\adv \coloneqq \read{\LeakInShare(m,n,i)^{\party(m)}_\adv} \\ \hspace{10pt} \text{for $m \leq N$ and $n \leq N+1$ and $i < I_n$ if $m$ honest} \end{cases*}$}
\item {\color{blue} $\LeakInShare(N+1,n,i)^{\party(N+1)}_\adv \coloneqq \read{\LeakInShare(N+1,n,i)^{\party(N+1)}_\adv}$ for $n \leq N+1$ and $i < I_n$}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\InShareGen(m,n,i)$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$,
\item $\SumInShareGen(m,n,i)$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$.
\end{itemize}

\noindent In the inductive phase, we have the protocol $\Circ(C,K)$, obtained by merging the two protocols $\Shares(C,K)$ and $\Adv(C,K)$ from earlier:

\begin{itemize}
\item $\Circ(\epsilon,0)$ is the protocol $\zero$

\item $\Circ\big(C; \, \inputgate(p,i),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Share(n,K) \coloneqq \read{\InShare(n,p,i)}$ for $n \leq N$\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\LeakShare(N+1,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakShare(N+1,K)^{\party(N+1)}_\adv}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Circ\big(C; \, \notgate(k),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Share(n,K) \coloneqq \read{\Share(n,k)}$ for $n \leq N$\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\LeakShare(N+1,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakShare(N+1,K)^{\party(N+1)}_\adv}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Circ\big(C; \, \xorgate(k,l),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item {\color{blue} $\LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\RcvdBit(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item {\color{blue} $\LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Ctrb(n,m,K) \coloneqq \read{\Ctrb(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item {\color{blue} $\LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\SumCtrb(n,m,K) \coloneqq \read{\SumCtrb(n,m,K)}$ for $n \leq N$ and $m \leq N+1$
\item {\color{blue} $\LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv}$ for $n,m \leq N+1$}\smallskip
\item $\Share(n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n \oplus y_n}$ for $n \leq N$\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\LeakShare(N+1,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakShare(N+1,K)^{\party(N+1)}_\adv}$}
\smallskip
\item {\color{blue} $\LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\item {\color{blue} $\LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}\smallskip
\item {\color{blue} $\LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv}$ for $n,m \leq N+1$}
\end{itemize}

\item $\Circ\big(C; \, \andgate(k,l),K+1\big)$ is the composition of $\Circ(C,K)$ with the protocol
\begin{itemize}
\item $\begin{cases*} \SendBit(n,m,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \samp{\flip} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n < m$} \\ \SendBit(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n \geq m$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest} \\ \LeakSendBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSendBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\LeakSendBit(N+1,m,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakSendBit(N+1,m,K)^{\party(N+1)}_\adv}$ for $m \leq N+1$}\smallskip
\item $\RcvdBit(n,m,K) \coloneqq b \leftarrow \SendBit(m,n,K); \ x_m \leftarrow \Share(m,k); \ y_m \leftarrow \Share(m,l); \\ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus (x_m * y_n) \oplus (x_n * y_m)}$ for $n,m \leq N$
\item $\RcvdBit(n,N+1,K) \coloneqq \read{\RcvdBit(n,N+1,K)}$ for $n \leq N$\smallskip
\item {\color{blue} $\begin{cases*} \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest} \\ \LeakRcvdBit(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdBit(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\LeakRcvdBit(N+1,m,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakRcvdBit(N+1,m,K)^{\party(N+1)}_\adv}$ for $m \leq N+1$}\smallskip
\item $\begin{cases*} \Ctrb(n,m,K) \coloneqq \read{\SendBit(n,m,K)} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n < m$} \\ \Ctrb(n,m,K) \coloneqq \read{\RcvdBit(n,m,K)} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $m < n$} \\ \Ctrb(n,n,K) \coloneqq x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{x_n * y_n} \\ \hspace{10pt} \text{for $n \leq N$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\Ctrb(n,m,K)} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest} \\ \LeakCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\LeakCtrb(N+1,m,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakCtrb(N+1,m,K)^{\party(N+1)}_\adv}$ for $m \leq N+1$}\smallskip
\item $\begin{cases*} \SumCtrb(n,0,K) \coloneqq \read{\Ctrb(n,0,K)} \\ \hspace{10pt} \text{for $n \leq N$} \\ \SumCtrb(n,m+1,K) \coloneqq b_\Sigma \leftarrow \SumCtrb(n,m,K); \ b \leftarrow \Ctrb(n,m+1,K); \ \ret{b_\Sigma \oplus b} \\ \hspace{10pt} \text{for $n,m \leq N$} \end{cases*}$
\item {\color{blue} $\begin{cases*} \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\SumCtrb(n,m,K)} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest} \\ \LeakSumCtrb(n,m,K)^{\party(n)}_\adv \coloneqq \read{\LeakSumCtrb(n,m,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\LeakSumCtrb(N+1,m,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakSumCtrb(N+1,m,K)^{\party(N+1)}_\adv}$ for $m \leq N+1$}\smallskip
\item $\Share(n,K) \coloneqq \read{\SumCtrb(n,N+1,K)}$ for $n \leq N$\smallskip
\item {\color{blue} $\begin{cases*} \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\Share(n,K)} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ semi-honest} \\ \LeakShare(n,K)^{\party(n)}_\adv \coloneqq \read{\LeakShare(n,K)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N$ if $n$ honest} \end{cases*}$}
\item {\color{blue} $\LeakShare(N+1,K)^{\party(N+1)}_\adv \coloneqq \read{\LeakShare(N+1,K)^{\party(N+1)}_\adv}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_0(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_0(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_1(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_1(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus y_n} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_2(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_2(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{b \oplus x_n \oplus y_n} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest and $n < m$} \\ \LeakOTMsg_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsg_3(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsg_3(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_0(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_0(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_1(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_1(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_2(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_2(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_2(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq b \leftarrow \SendBit(n,m,K); \ x_n \leftarrow \Share(n,k); \ y_n \leftarrow \Share(n,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ honest and $n < m$} \\ \LeakOTMsgRcvd_3(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N$ and $m \leq N+1$ if $n$ semi-honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTMsgRcvd_3(N+1,m,K)^\ot_\adv \coloneqq \read{\LeakOTMsgRcvd_3(N+1,m,K)^\ot_\adv}$ for $m \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTChc_0(n,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChc_0(n,N+1,K)^\ot_\adv}$ for $n \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\Share(m,l)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest and $n < m$} \\ \LeakOTChc_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest or $n \geq m$} \end{cases*}$}\smallskip
\item {\color{blue} $\LeakOTChc_1(n,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChc_1(n,N+1,K)^\ot_\adv}$ for $n \leq N+1$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq x_m \leftarrow \Share(m,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_0(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_0(n,N+1,K)^\ot_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_0(N+1,N+1,K)^\ot_\adv} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq y_m \leftarrow \Share(m,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest and $n < m$} \\ \LeakOTChcRcvd_1(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest or $n \geq m$} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOTChcRcvd_1(n,N+1,K)^\ot_\adv \coloneqq y_\Sigma \leftarrow \SumShare(N,l); \ \ret{\checkmark} \\ \hspace{10pt} \text{for $n \leq N$} \\ \LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTChcRcvd_1(N+1,N+1,K)^\ot_\adv} \end{cases*}$}\smallskip
\item {\color{blue} $\begin{cases*} \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\RcvdBit(m,n,K)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ semi-honest} \\ \LeakOTOut(n,m,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,m,K)^\ot_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ if $m$ honest} \end{cases*}$}
\item {\color{blue} $\LeakOTOut(n,N+1,K)^\ot_\adv \coloneqq \read{\LeakOTOut(n,N+1,K)^\ot_\adv}$ for $n \leq N+1$}
\end{itemize}
\end{itemize}
This is followed by the hiding of the channels
\begin{itemize}
\item $\SendBit(n,m,k)$ for $n \leq N$ and $m \leq N+1$ and $k < K$,
\item $\RcvdBit(n,m,k)$ for $n \leq N$ and $m \leq N+1$ and $k < K$,
\item $\Ctrb(n,m,k)$ for $n \leq N$ and $m \leq N+1$ and $k < K$,
\item $\SumCtrb(n,m,k)$ for $n \leq N$ and $m \leq N+1$ and $k < K$.
\end{itemize}

\noindent In the final phase, we have the protocol $\Fin$:

\begin{itemize}
\item {\color{blue} $\begin{cases*} \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\Share(n,k)} \\ \hspace{10pt} \text{for $m \leq N+1$ and $n \leq N$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakSendOutShare(m,n,k)^{\party(n)}_\adv \coloneqq \read{\LeakSendOutShare(m,n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $m \leq N+1$ and $n \leq N$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\LeakSendOutShare(m,N+1,k)^{\party(N+1)}_\adv \coloneqq \read{\LeakSendOutShare(m,N+1,k)^{\party(N+1)}_\adv}$ for $m \leq N+1$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \LeakOut(n,k)^\id_\adv; \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and wire $k$ an output} \\ \LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakRcvdOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or wire $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\Share(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq x_\Sigma \leftarrow \SumShare(N,k); \ x \leftarrow \LeakOut(n,k)^\id_\adv; \ \ret{x_\Sigma \oplus x} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\SumShare(m,k)} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,m,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,m,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $m \leq N$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest and $k$ an output} \\ \LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv \coloneqq \read{\LeakSumOutShare(n,N+1,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest or $k$ not an output} \end{cases*}$}
\item {\color{blue} $\begin{cases*} \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^\id_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ semi-honest} \\ \LeakOut(n,k)^{\party(n)}_\adv \coloneqq \read{\LeakOut(n,k)^{\party(n)}_\adv} \\ \hspace{10pt} \text{for $n \leq N+1$ and $k < K$ if $n$ honest} \end{cases*}$}
\end{itemize}

\noindent At last, we have the channels
\begin{itemize}
\item $\begin{cases*} \SumShare(0,k) \coloneqq \read{\Share(0,k)} \\ \hspace{10pt} \text{for $k < K$} \\ \SumShare(m+1,k) \coloneqq x_\Sigma \leftarrow \SumShare(m,k); \ x_{m+1} \leftarrow \Share(m+1,k); \ \ret{x_\Sigma \oplus x_{m+1}} \\ \hspace{10pt} \text{for $m < N$ and $k < K$} \end{cases*}$
\end{itemize}
that keep track of the sum of shares of parties $0,\ldots,N$.\medskip

\noindent The composition of the four parts is followed by the hiding of the channels
\begin{itemize}
\item $\InShare(m,n,i)$ for $m \leq N$ and $n \leq N+1$ and $i < I_n$,
\item $\Share(n,k)$ for $n \leq N$ and $k < K$,
\item $\SumShare(m,k)$ for $m \leq N$ and $k < K$.
\end{itemize}

\noindent Composing the ideal protocol with the simulator, and substituting away the ideal leakage
\begin{itemize}
\item $\LeakIn(n,i)^\id_\adv$ for $n \leq N+1$ and $i < I_n$,
\item $\LeakInRcvd(n,i)^\id_\adv$ for $n \leq N+1$ and $i < I_n$,
\item $\Out(n,k)^\id_\adv$ for $n \leq N+1$ and $k < K$
\end{itemize}
as indicated in Section \ref{sect:gmwn_extracting_simulator} yields precisely the version of the real protocol we had at the end of Section \ref{sect:gmwn_eliminating_shares}.