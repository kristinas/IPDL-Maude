***( IPDL
  Copyright : (C) 2022-24
  License   : GNU General Public License v3.0 or later (GPL-3.0-or-later)
  Authors   : ipdlmaude@gmail.com
Multi-Party GMW Protocol
)

load ../src/strategies
mod GMWN is
 including APPROX-EQUALITY .
 protecting LIST{NatPairs} .
 
 op sumF : -> SigElem .
 eq sumF = 'xor : (bool * bool) ~> bool .
 *** xor is +
 op mulF : -> SigElem .
 eq mulF = 'and : (bool * bool) ~> bool .
 *** and is *
 op negF : -> SigElem .
 eq negF = 'neg : bool ~> bool .
 op flipF : -> SigElem .
 eq flipF = 'flip : unit ~>> bool .
 op sig : -> Signature .
 eq sig = sumF mulF negF flipF .
 var i j l k n : Nat .
 *** global parameters
 op N : -> Nat . 
 op K : -> Nat .
 *** for each party p, I(p) is the number of inputs for p
 op I : Nat -> Nat . 
 op C : -> Circuit . *** the circuit acting as parameter
 *** gates and circuits
 sort Gate .
 op input-gate : Nat Nat -> Gate [ctor] . *** first nat is the party
 op not-gate : Nat -> Gate [ctor] .
 op xor-gate : Nat Nat -> Gate [ctor] .
 op and-gate : Nat Nat -> Gate [ctor] .
 sort Circuit . *** list of gates
 subsort Gate < Circuit .
 op emptyCircuit : -> Circuit [ctor] .
 op __ : Circuit Circuit -> Circuit [ctor assoc id: emptyCircuit] .
 op wellFormed : Circuit Nat -> Bool .
 var circuit : Circuit .
 eq wellFormed(emptyCircuit, 0) = true .
 ceq wellFormed(circuit input-gate(i, j), s(n)) = true 
  if wellFormed(circuit, n) /\ i <= N + 1 /\ j < I(i) .
 ceq wellFormed(circuit not-gate(k), s(n)) = true
  if wellFormed(circuit, n) /\ k < n . 
 ceq wellFormed(circuit and-gate(k, l), s(n)) = true
  if wellFormed(circuit, n) /\ k < n /\ l < n .
 ceq wellFormed(circuit xor-gate(k, l), s(n)) = true
  if wellFormed(circuit, n) /\ k < n /\ l < n .
  
 *** helpers
 *** get the gate at the start of the circuit, after i pops
 *** i must be at most the length of circuit
 *** the circuit must be non-empty
 var gate : Gate .
 op gateAt : Circuit Nat -> Gate .
 eq gateAt(gate circuit, 0) = gate .
 eq gateAt(gate circuit, s(n)) = gateAt(circuit, n) .
 *** the wires of a gate, as a list
 op wiresOf : Gate -> List{NatPairs} .
 eq wiresOf(input-gate(i, j)) = (0 ;; i) (1 ;; j) .
 eq wiresOf(not-gate(i)) = (0 ;; i) .
 eq wiresOf(and-gate(k, l)) = (0 ;; k) (1 ;; l) .
 eq wiresOf(xor-gate(k, l)) = (0 ;; k) (1 ;; l) .
 *** list as an unsafe map
 var natPairs : List{NatPairs} .
 op _@@_ : List{NatPairs} Nat -> Nat .
 eq ( (i ;; k) natPairs) @@ i = k .
 ceq ( (l ;; k) natPairs) @@ i = natPairs @@ i if l =/= i .
 *** wire 0 of the circuit C at a given gate
 op wire0 : Nat -> Nat .
 eq wire0(i) = wiresOf(gateAt(C, i)) @@ 0 .
 *** wire 1 of the circuit C at a given gate
 op wire1 : Nat -> Nat .
 eq wire1(i) = wiresOf(gateAt(C, i)) @@ 1 .
  *** here we connect 'wire0 with wire0 
 var nt nt1 nt2 : NatTerm .
 var f : Map{Qid, NatTerm} .
 ceq evalTerm (fun 'wire0 nt) f = wire0(evalTerm nt f) 
  if (evalTerm nt f) : Nat .
 eq evalTerm (fun 'wire0 nt) f = fun 'wire0 nt [owise] . 
 ceq evalTerm (fun 'wire1 nt) f = wire1(evalTerm nt f) 
  if (evalTerm nt f) : Nat .
 eq evalTerm (fun 'wire1 nt) f = fun 'wire1 nt [owise] .
 *** for I
 eq evalTerm (fun 'I nt) f = fun 'I (evalTerm nt f) . 
 *** here we record the assumptions on indices
 var q : Qid .
 var A : Set{BoolTerm} .
 ceq A |= fun 'wire0 nt <T (N + 2) with f = true 
   if (apply 'isInputGate (evalTerm nt f)) in A .
 ceq A |= fun 'wire0 nt <T K with f = true 
    if (apply 'isNotGate (evalTerm nt f)) in A .
 ceq A |= fun 'wire0 nt <T K with f = true 
    if (apply 'isXorGate (evalTerm nt f)) in A .
 ceq A |= fun 'wire1 nt <T K with f = true 
    if (apply 'isXorGate (evalTerm nt f)) in A .   
 ceq A |= fun 'wire0 nt <T K with f = true 
    if (apply 'isAndGate (evalTerm nt f)) in A .
 ceq A |= fun 'wire1 nt <T K with f = true 
    if (apply 'isAndGate (evalTerm nt f)) in A .
 
 ceq A |= fun 'wire0 nt <T nt with f = true  *** was N + 2
   if (apply 'isInputGate (evalTerm nt f)) in A .
 ceq A |= (fun 'wire1 nt <T fun 'I (fun 'wire0 nt)) with f = true 
    if (apply 'isInputGate (evalTerm nt f)) in A [label depBounds] .
 ceq A |= fun 'wire0 nt <T nt with f = true  *** was K here and below
    if (apply 'isNotGate (evalTerm nt f)) in A [label notIndex].
 ceq A |= fun 'wire0 nt <T nt with f = true 
    if (apply 'isXorGate (evalTerm nt f)) in A .
 ceq A |= fun 'wire1 nt <T nt with f = true 
    if (apply 'isXorGate (evalTerm nt f)) in A .   
 ceq A |= fun 'wire0 nt <T nt with f = true 
    if (apply 'isAndGate (evalTerm nt f)) in A [label andIndex] .
 ceq A |= fun 'wire1 nt <T nt with f = true 
    if (apply 'isAndGate (evalTerm nt f)) in A .
    
 ceq A |= fun 'wire0 nt1 <T nt2 with f = true 
  if A |= nt1 <T nt2 with f [label wireSmallThen0] .
 ceq A |= fun 'wire1 nt1 <T nt2 with f = true 
  if A |= nt1 <T nt2 with f [label wireSmallThen1] . 
  *** generic assumptions shared by both proofs
 op genA : -> Set{BoolTerm} .
 eq genA = ( neg (apply 'isXorGate 0), 
             neg (apply 'isAndGate 0), 
             neg (apply 'isNotGate 0),
             0 <T K,
             0 <T N + 2,
             N <T N + 1,
             N <T N + 2,
             N + 1 <T N + 2, 
             apply 'isHonest (N + 1) )
 . 
 eq (A, apply 'isHonest nt) |= neg (apply 'isSemiHonest nt) with f = true .
 eq (A, apply 'isSemiHonest nt) |= neg (apply 'isHonest nt) with f = true .
 eq (apply 'isHonest nt) disj (apply 'isSemiHonest nt) = trueBT .
  
 *** delta
 op deltaIdealPlusSim : -> ChannelContext .
 eq deltaIdealPlusSim =
  (fam (('InRcvd ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) :: unit) 
             (fam (('InShare$-Sum ^^ 'party .. 'adv)[(bound (N + 1))((bound (N + 2))(dependentBound 'I))]) :: bool)
             (fam (('InShare$ ^^ 'party .. 'adv)[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]):: bool)
             (fam (('InShare$ ^^ 'party .. 'adv)[((fixedBound (N + 1)) (bound (N + 2)) (dependentBound 'I))]):: bool)
             (fam (('InShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) :: bool)
             (fam (('In ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) :: bool)  
             (fam (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 1))(bound K) )]) :: unit) 
             (fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (fixedBound (N + 1))(bound K) )]) :: unit) 
             (fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 1))(bound K) )]) :: unit)
             (fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (fixedBound (N + 1))(bound K) )]) :: unit) 
             (fam (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit)
             (fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: unit) 
             (fam (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam ('Out[((bound (N + 2))(bound K))]) :: bool)    
             (fam (('OutShareSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 1))(bound K) )]) :: bool)
             (fam (('OutShareSum ^^ 'party .. 'adv)[((bound (N + 2)) (fixedBound (N + 1))(bound K) )]) :: bool) 
             (fam (('OutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 1))(bound K) )]) :: bool)
             (fam (('OutShare ^^ 'party .. 'adv)[((bound (N + 2)) (fixedBound (N + 1))(bound K) )]) :: bool)
             (fam (('Out ^^ 'party .. 'adv)[((bound (N + 2))(bound K))]) :: bool)  
             (fam (('RcvdInShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) :: bool)  
             (fam (('RcvdOutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 1))(bound K) )]) :: bool) 
             (fam (('RcvdOutShare ^^ 'party .. 'adv)[((bound (N + 2)) (fixedBound (N + 1))(bound K) )]) :: bool) 
             (fam (('SendInShare ^^ 'party .. 'adv)[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) :: bool) 
             (fam (('SendInShare ^^ 'party .. 'adv)[((fixedBound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) :: bool) 
             (fam (('SendOutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool)  
             (fam (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))]) :: bool)
             (fam (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool) 
             (fam (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool)
             (fam (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2))(bound K) )]) :: bool)  
             (fam ('In[(bound (N + 2)) (dependentBound 'I)]) :: bool)
 . 
 
 op delta : -> ChannelContext .
 eq delta = 
  (fam (('InRcvd ^^ 'party .. 'adv)[(bound (N + 2)) (dependentBound 'I)]) :: unit) 
  (fam (('InShare$-Sum ^^ 'party .. 'adv)[(bound (N + 1)) (bound (N + 2)) (dependentBound 'I)]) :: bool)
  (fam (('InShare$ ^^ 'party .. 'adv)
         [(bound (N + 2)) (bound (N + 2)) (dependentBound 'I)]
       ) :: bool)
  (fam (('InShare ^^ 'party .. 'adv)
        [(bound (N + 2)) (bound (N + 2)) (dependentBound 'I)]
       ) :: bool)
  (fam (('In ^^ 'party .. 'adv)
        [(bound (N + 2)) (dependentBound 'I)]
       ) :: bool)  
  (fam (('OTChc-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('OTChc-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: unit) 
  (fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: unit) 
  (fam (('OTMsg-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('OTMsg-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('OTMsg-2 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('OTMsg-3 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: unit)
  (fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: unit) 
  (fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: unit) 
  (fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: unit) 
  (fam (('OTOut ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam ('Out[(bound (N + 2)) (bound K)]) :: bool)    
  (fam (('OutShareSum ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('OutShare ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool)
  (fam (('Out ^^ 'party .. 'adv)[(bound (N + 2)) (bound K)]) :: bool)  
  (fam (('RcvdInShare ^^ 'party .. 'adv)
        [(bound (N + 2)) (bound (N + 2)) (dependentBound 'I)]
       ) :: bool)  
  (fam (('RcvdOutShare ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('SendInShare ^^ 'party .. 'adv)
        [(bound (N + 2)) (bound (N + 2)) (dependentBound 'I)]
       ) :: bool) 
  (fam (('SendOutShare ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool)  
  (fam (('Share ^^ 'party .. 'adv)[(bound (N + 2)) (bound K)]) :: bool)
  (fam (('Ctrb ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('RcvdBit ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool) 
  (fam (('SendBit ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool)
  (fam (('CtrbSum ^^ 'party .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]) :: bool)  
  (fam ('In[(bound (N + 2)) (dependentBound 'I)]) :: bool)
   .
      
     *** ideal protocol
  
  op ideal : -> Protocol .
  eq ideal =
   newfamily ('Wire[bound K]) 'k (bound K) : bool in
   leakageIdeal || wiresIdeal || finalIdeal
  .
  
  op leakageIdeal : -> Protocol .
  eq leakageIdeal = 
     (family ('In ^^ 'id .. 'adv[((bound (N + 2))(dependentBound 'I))]) 
      ('n 'i) ((bound (N + 2))(dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('in : bool <- read ('In['n 'i]), return 'in)
       )
       ;;
       (when (apply 'isHonest 'n) --> 
         nf('in : bool <- read (('In ^^ 'id .. 'adv)['n 'i]), return 'in)
       )
     ) 
     ||
     (family ('InRcvd ^^ 'id .. 'adv[((bound (N + 2))(dependentBound 'I))]) 
       ('n 'i) ((bound (N + 2))(dependentBound 'I)) ::=
       (when (apply 'isHonest 'n) --> 
         nf('in : bool <- read ('In['n 'i]), return ())
       )
       ;;
       (when (apply 'isSemiHonest 'n) --> 
         nf('in : unit <- read (('InRcvd ^^ 'id .. 'adv)['n 'i]), 
            return 'in)
       )
     ) 
       
  .
  
  op wiresIdeal : -> Protocol .
  eq wiresIdeal = 
     family ('Wires[bound K]) 'k (bound K) ::= 
       (
        family ('Wire[bound K]) 'k (bound K) ::=
         (when (apply 'isInputGate 'k) --> 
           nf( 'i : bool <- read ('In[(fun 'wire0 'k) (fun 'wire1 'k)]), 
               return 'i)
         )
         ;;
         (when (apply 'isNotGate 'k) --> 
          nf('x : bool <- read ('Wire[fun 'wire0 'k]),
             return (ap 'neg 'x))
         )
         ;;
         (when (apply 'isXorGate 'k) --> 
          nf(('x : bool <- read ('Wire[fun 'wire0 'k]))
             ('y : bool <- read ('Wire[fun 'wire1 'k])),
             return (ap 'xor pair('x, 'y)))
         )
         ;;
         (when (apply 'isAndGate 'k) --> 
          nf(('x : bool <- read ('Wire[fun 'wire0 'k]))
             ('y : bool <- read ('Wire[fun 'wire1 'k])),
             return (ap 'and pair('x, 'y)))
         )
       )
  .
  
  op finalIdeal : -> Protocol .
  eq finalIdeal =
     (family (('Out ^^ 'id .. 'adv)[((bound (N + 2))(bound K))]) 
        ('n 'k) ((bound (N + 2))(bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('out : bool <- read ('Out['n 'k]), return 'out)
       )
       ;;
       (when (apply 'isHonest 'n) --> 
         nf('out : bool <- read (('Out ^^ 'id .. 'adv)['n 'k]), return 'out)
       )
     )
     ||
     (family ('Out[((bound (N + 2))(bound K))]) ('n 'k) ((bound (N + 2))(bound K)) ::=
       (when (apply 'isOutputWire 'k) --> 
         nf('out : bool <- read ('Wire['k]), return 'out)
       )
       ;;
       (when (neg (apply 'isOutputWire 'k)) --> 
         nf('o : bool <- read ('Out['n 'k]), return 'o)
       )
     
     )
  .
  
  *** sim protocol
  
  op sim : -> Protocol .
  eq sim = 
     newfamily ('InShare[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) 
               ('m 'n 'i) 
               ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) : bool in
     newfamily ('Share[((bound (N + 1))(bound K))]) 
               ('n 'k) ((bound (N + 1))(bound K)) : bool in
     newfamily ('ShareSum[((bound (N + 1))(bound K))]) 
               ('m 'k) ((bound (N + 1))(bound K)) : bool in          
     initialSim || inductiveSim || finalSim || shareSim  
  . 
  
  op initialSim : -> Protocol .
  eq initialSim = 
     newfamily ('InShare$[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]) ('m 'n 'i) 
                ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) : bool in
     newfamily ('InShare$-Sum[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]) 
                ('m 'n 'i) 
                ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) : bool in
     (
     (family (('In ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) ('n 'i)
             ((bound (N + 2))(dependentBound 'I)) ::=
        ( (when (apply 'isSemiHonest 'n) -->
           nf('in : bool <- read (('In ^^ 'id .. 'adv) ['n 'i]), 
               return 'in)  
         ) 
         ;;
         (when (apply 'isHonest 'n) --> *** diverge
           nf('in : bool <- read (('In ^^ 'party .. 'adv) ['n 'i]), 
               return 'in)  
         )
       
       )      
     )
     ||
     (family (('InRcvd ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) ('n 'i)
             ((bound (N + 2))(dependentBound 'I)) ::=
             
       (when (apply 'isHonest 'n) -->
nf('x : unit <- read (('InRcvd ^^ 'id .. 'adv) ['n 'i]), return ()))
;;
when (apply 'isSemiHonest 'n) -->
nf('in : unit <- read (('InRcvd ^^ 'party .. 'adv)['n 'i]), return 'in)
      
     )
     ||
     (family ('InShare$[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]) ('m 'n 'i) 
             ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) ::= 
       ( (when (apply 'isSemiHonest 'n) -->
           nf('x : bool <- read (('In ^^ 'id .. 'adv) ['n 'i]), 
              samp ('flip < () >))  
         ) 
         ;;
         (when (apply 'isHonest 'n) -->
           nf('x : unit <- read (('InRcvd ^^ 'id .. 'adv) ['n 'i]), 
              samp ('flip < () >))  
         )
       
       )         
     ) 
     ||
     (  
family ('InShare$ ^^ 'party ..
    'adv)[bound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 1) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in))
;;
when (apply 'isHonest 'n) -->
nf('in : bool <- read (('InShare$ ^^ 'party .. 'adv)['m 'n 'i]), return 'in)
)
||
(
family ('InShare$ ^^ 'party ..
    'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
fixedBound (N + 1) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf(('s : bool <- read ('InShare$-Sum[N 'n 'i])) 
    'x : bool <- read (('In ^^ 'id .. 'adv)['n 'i]), 
    return (ap 'xor pair('x, 's))))
;;
when (apply 'isHonest 'n) -->
nf('in : bool <- read (('InShare$ ^^ 'party .. 'adv)[(N + 1) 'n 'i]), return 'in)
 )    
     ||
     (family ('InShare$-Sum[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]) 
             ('m 'n 'i) 
             ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) ::=             
       ( (when ('m =T= 0) --> 
           nf('in : bool <- read ('InShare$ [0 'n 'i]), return 'in)
         ) 
         ;; 
         (otherwise --> 
          nf( ('s : bool <- read ('InShare$-Sum [('m -- 1) 'n 'i]) )
              ('x : bool <- read ('InShare$ ['m 'n 'i])) ,
             return (ap 'xor pair('s, 'x))) 
         )
       )      
     )
     ||
     (
       family ('InShare$-Sum ^^ 'party .. 'adv)[bound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 1) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('InShare$-Sum['m 'n 'i]), return 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('InShare$-Sum ^^ 'party .. 'adv)['m 'n 'i]), return 's)      
             
       
     ) 
     ||
     (
      family ('SendInShare ^^ 'party ..
    'adv)[bound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 1) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('SendInShare ^^ 'party .. 'adv)['m 'n 'i]), return 's)
      )
      ||
      (
      family ('SendInShare ^^ 'party ..
    'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
fixedBound (N + 1) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf(('s : bool <- read ('InShare$-Sum[N 'n 'i])) 
    'x : bool <- read (('In ^^ 'id .. 'adv)['n 'i]), 
    return (ap 'xor  pair('x, 's))))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('SendInShare ^^ 'party .. 'adv)[(N + 1) 'n 'i]), return 's)
      )
     || 
     (family ('RcvdInShare ^^ 'party ..
    'adv)[bound (N + 2) bound (N + 2) dependentBound 'I] 'n 'm 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('in : bool <- read ('InShare$['n 'm 'i]), return 'in))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdInShare ^^ 'party .. 'adv)['n 'm 'i]), return 's)
     )    
     ||
     (family ('InShare[((bound (N + 1))(bound (N + 2))(dependentBound 'I))])
             ('m 'n 'i) 
             ((bound (N + 1))(bound (N + 2))(dependentBound 'I)) ::= 
        nf('in : bool <- read ('InShare$ ['m 'n 'i]), return 'in)     
     ) 
     ||
     (family ('InShare ^^ 'party ..
    'adv)[bound (N + 2) bound (N + 2) dependentBound 'I] 'n 'm 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('InShare['n 'm 'i]), return 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('InShare ^^ 'party .. 'adv)['n 'm 'i]), return 's)
     ) 
    ) *** end new 
  .   
  
  op inductiveSim : -> Protocol .
  eq inductiveSim = 
      newfamily ('SendBit[((bound (N + 1))(bound (N + 2))(bound K))]) ('n 'm 'k) 
                 ((bound (N + 1))(bound (N + 2))(bound K)) : bool in
      newfamily ('RcvdBit[((bound (N + 1))(bound (N + 1))(bound K))]) ('n 'm 'k)
                 ((bound (N + 1))(bound (N + 1))(bound K)) : bool in 
      newfamily ('RcvdBit[((bound (N + 1))(fixedBound (N + 1))(bound K))]) ('n 'm 'k)
                 ((bound (N + 1))(fixedBound (N + 1))(bound K)) : bool in            
      newfamily ('Ctrb[((bound (N + 1))(bound (N + 2))(bound K))]) ('n 'm 'k) 
                 ((bound (N + 1))(bound (N + 2))(bound K)) : bool in
      newfamily ('CtrbSum[((bound (N + 1))(bound (N + 2))(bound K))]) ('n 'm 'k) 
                 ((bound (N + 1))(bound (N + 2))(bound K)) : bool in
      family ('Circ[bound K]) 'k (bound K) ::=
      ( *** start circuit
      ( *** start when input gate
      when (apply 'isInputGate 'k) --> 
( *** start when
 (family 'Ctrb[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 1) bound (N + 1) bound K] 'n 'm 'k
bound (N + 1) bound (N + 1) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 1) fixedBound (N + 1) bound K
::=
nf('rb : bool <- read ('RcvdBit['n (N + 1) 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in)
)
||
(family ('Ctrb ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b)
)
||
(family ('CtrbSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b)
)
||
(family ('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc)
)
||
(family ('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out)
)
||
(family ('RcvdBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb)
)
||
(family ('SendBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb)
)
||
(family ('Share ^^ 'party .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's)
)
   ) *** end when
   ) *** end when input gate
   ;;
   ( *** start when not gate
      when (apply 'isNotGate 'k) --> 
( *** start when
(family 'Ctrb[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 1) bound (N + 1) bound K] 'n 'm 'k
bound (N + 1) bound (N + 1) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 1) fixedBound (N + 1) bound K
::=
nf('rb : bool <- read ('RcvdBit['n (N + 1) 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's)
)
||
(family ('Ctrb ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b)
)
||
(family ('CtrbSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b)
)
||
(family ('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc)
)
||
(family ('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out)
)
||
(family ('RcvdBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb)
)
||
(family ('SendBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb)
)
||
(family ('Share ^^ 'party .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's)
)
) *** end when
   ) *** end when not gate
   ;;
   ( *** start when xor gate
      when (apply 'isXorGate 'k) --> 
( *** start when
(family 'Ctrb[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 1) bound (N + 1) bound K] 'n 'm 'k
bound (N + 1) bound (N + 1) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 1) fixedBound (N + 1) bound K
::=
nf('rb : bool <- read ('RcvdBit['n (N + 1) 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)))
)
||
(family ('Ctrb ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b)
)
||
(family ('CtrbSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b)
)
||
(family ('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc)
)
||
(family ('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out)
)
||
(family ('RcvdBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb)
)
||
(family ('SendBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb)
)
||
(family ('Share ^^ 'party .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's)
)
) *** end when
   ) *** end when xor gate 
   ;;
   ( *** start when and gate
when (apply 'isAndGate 'k) --> 
( *** start when
(family 'Ctrb[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y))))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r)
)
||
(family 'CtrbSum[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 
    's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), 
     return (ap 'xor pair('s, 'b)))
)
||
(family 'RcvdBit[bound (N + 1) bound (N + 1) bound K] 'n 'm 'k
bound (N + 1) bound (N + 1) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) 
   ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) 
   ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) 
   ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 
    'yn : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn), 
                         ap 'and pair('xn, 'ym)), 'b)))
)
||
(family 'RcvdBit[bound (N + 1) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 1) fixedBound (N + 1) bound K
::=
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r)
)
||
(family 'SendBit[bound (N + 1) bound (N + 2) bound K] 'n 'm 'k
bound (N + 1) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >)))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs)
)
||
(family ('Ctrb ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Ctrb['n 'm 'k]), return 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 's)
)
||
(family ('CtrbSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('CtrbSum['n 'm 'k]), return 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 's)
)
||
(family ('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), return 'x))
;;
when ((apply 'isHonest 'm) disj 'm <=T 'n) -->
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), return 'x))
;;
when ((apply 'isHonest 'm) disj 'm <=T 'n) -->
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
(when ((apply 'isHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), return ()))
;;
when ((apply 'isSemiHonest 'm) disj 'm <=T 'n) -->
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
(when ('n <T N + 1) -->
nf('x : bool <- read ('ShareSum[N (fun 'wire0 'k)]), return ()))
;;
when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
(when ((apply 'isHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), return ()))
;;
when ((apply 'isSemiHonest 'm) disj 'm <=T 'n) -->
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family ('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
(when ('n <T N + 1) -->
nf('x : bool <- read ('ShareSum[N (fun 'wire1 'k)]), return ()))
;;
when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc)
)
||
(family ('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
    ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), return 'b))
;;
when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y :
    bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair('x, 'b))))
;;
when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y :
    bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair('y, 'b))))
;;
when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair(ap 'xor pair('x, 'y), 'b))
    ))
;;
when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y :
    bool <- read ('Share['n (fun 'wire1 'k)]), return ()))
;;
when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y :
    bool <- read ('Share['n (fun 'wire1 'k)]), return ()))
;;
when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y :
    bool <- read ('Share['n (fun 'wire1 'k)]), return ()))
;;
when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y :
    bool <- read ('Share['n (fun 'wire1 'k)]), return ()))
;;
when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family ('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'm) -->
nf('out : bool <- read ('RcvdBit['m 'n 'k]), return 'out))
;;
when (apply 'isHonest 'm) -->
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out)
)
||
(family ('RcvdBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('RcvdBit['n 'm 'k]), return 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 's)
)
||
(family ('SendBit ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 's)
)
||
(family ('Share ^^ 'party .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K
::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's)
)
) *** end when
) *** end when and gate
      ) *** end circuit
  . 
  
  op finalSim : -> Protocol .
  eq finalSim = 
    ( *** start 'Fin
      (family ('SendOutShare ^^ 'party ..
    'adv)[bound (N + 2) bound (N + 2) bound K] 'm 'n 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('SendOutShare ^^ 'party .. 'adv)['m 'n 'k]), return 's)
       )
       ||
       (family ('RcvdOutShare ^^ 'party ..
    'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['m 'k]), return 's))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdOutShare ^^ 'party .. 'adv)['n 'm 'k]), return 's)
)      
 ||
 (
 family ('RcvdOutShare ^^ 'party ..
    'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf(('w : bool <- read (('Out ^^ 'id .. 'adv)['n 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor pair('xs,
    'w)) ))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdOutShare ^^ 'party .. 'adv)['n (N + 1) 'k]), return 's)
 ) 
       ||
      (family ('OutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['m 'k]), return 's))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('OutShare ^^ 'party .. 'adv)['n 'm 'k]), return 's)
)
||
(
family ('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf(('w : bool <- read (('Out ^^ 'id .. 'adv)['n 'k]))  'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor pair('xs,
    'w)) ))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('OutShare ^^ 'party .. 'adv)['n (N + 1) 'k]), return 's)
) 
       ||
        (
 family ('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 1) bound K] 'n 'm 'k
bound (N + 2) bound (N + 1) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('ShareSum['m 'k]), return 's))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('OutShareSum ^^ 'party .. 'adv)['n 'm 'k]), return 's)
 )    
 ||
 (
 family ('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] 'n 'm 'k
bound (N + 2) fixedBound (N + 1) bound K
::=
(when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf('w : bool <- read (('Out ^^ 'id .. 'adv)['n 'k]), return 'w))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('OutShareSum ^^ 'party .. 'adv)['n (N + 1) 'k]), return 's)
 ) 
       ||
       (family (('Out ^^ 'party .. 'adv)[((bound (N + 2))(bound K))]) ('n 'k)
          ((bound (N + 2))(bound K)) ::=
          
          
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read (('Out ^^ 'id .. 'adv)['n 'k]), return 's))
;;
when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Out ^^ 'party .. 'adv)['n 'k]), return 's)
         
       )
    ) *** end 'Fin    
  .
  
  op shareSim : -> Protocol .
  eq shareSim = 
     family ('ShareSum[((bound (N + 1))(bound K))]) 
            ('m 'k) ((bound (N + 1))(bound K)) ::=
     (
      (when ('m =T= 0) --> 
        nf('s : bool <- read ('Share[0 'k]), return 's)
      )
      ;;
      (when (neg ('m =T= 0)) --> 
        nf( ('xs : bool <- read ('ShareSum[('m -- 1) 'k])) 
            ('xm : bool <- read ('Share['m 'k])),
            return (ap 'xor pair('xs, 'xm))
          )
      )
     )
  .
  
  *** idealplussim
  
  op idealPlusSim : -> Protocol .
  eq idealPlusSim =
   newfamily ('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I] 
     ('n 'i) (bound (N + 2) dependentBound 'I) : bool in
   newfamily ('InRcvd ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I] 'n 'i
bound (N + 2) dependentBound 'I : unit in
   newfamily ('Out ^^ 'id .. 'adv)[bound (N + 2) bound K] 'n 'k
bound (N + 2) bound K : bool in  
   (ideal || sim)
  .
  
  op deltaSRW : -> ChannelContext .
  eq deltaSRW = 
  (chn ('OTMsg-0['s 'r 'w]) :: bool)
  (chn ('OTMsg-1['s 'r 'w]) :: bool)
  (chn ('OTMsg-2['s 'r 'w]) :: bool)
  (chn ('OTMsg-3['s 'r 'w]) :: bool)
  
  (chn (('OTMsg-0 ^^ 'ot .. 'adv)['s 'r 'w]) :: bool)
  (chn (('OTMsg-1 ^^ 'ot .. 'adv)['s 'r 'w]) :: bool)
  (chn (('OTMsg-2 ^^ 'ot .. 'adv)['s 'r 'w]) :: bool)
  (chn (('OTMsg-3 ^^ 'ot .. 'adv)['s 'r 'w]) :: bool)
  
  (chn (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w]) :: unit)
  (chn (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w]) :: unit)
  (chn (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['s 'r 'w]) :: unit)
  (chn (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['s 'r 'w]) :: unit)
  
  (chn ('OTChc-0['s 'r 'w]) :: bool)
  (chn ('OTChc-1['s 'r 'w]) :: bool)
  
  (chn (('OTChc-0 ^^ 'ot .. 'adv)['s 'r 'w]) :: bool)
  (chn (('OTChc-1 ^^ 'ot .. 'adv)['s 'r 'w]) :: bool)
  
  (chn (('OTChcRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w]) :: unit)
  (chn (('OTChcRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w]) :: unit)
  
  (chn ('OTOut['s 'r 'w]) :: bool)
  (chn (('OTOut ^^ 'ot .. 'adv)['s 'r 'w]) :: bool)  
  .
  
   op deltaNMK : -> ChannelContext .
  eq deltaNMK = 
  (chn ('OTMsg-0['n 'm 'k]) :: bool)
  (chn ('OTMsg-1['n 'm 'k]) :: bool)
  (chn ('OTMsg-2['n 'm 'k]) :: bool)
  (chn ('OTMsg-3['n 'm 'k]) :: bool)
  
  (chn (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]) :: bool)
  (chn (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]) :: bool)
  (chn (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]) :: bool)
  (chn (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]) :: bool)
  
  (chn (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]) :: unit)
  (chn (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]) :: unit)
  (chn (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]) :: unit)
  (chn (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]) :: unit)
  
  (chn ('OTChc-0['n 'm 'k]) :: bool)
  (chn ('OTChc-1['n 'm 'k]) :: bool)
  
  (chn (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]) :: bool)
  (chn (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]) :: bool)
  
  (chn (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]) :: unit)
  (chn (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]) :: unit)
  
  (chn ('OTOut['n 'm 'k]) :: bool)
  (chn (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]) :: bool)  
  .
  
    op deltaNMKfam : -> ChannelContext .
  eq deltaNMKfam = 
  (fam ('OTMsg-0[bound (N + 2) bound (N + 2) bound K]) :: bool)
  (fam ('OTMsg-1[bound (N + 2) bound (N + 2) bound K]) :: bool)
  (fam ('OTMsg-2[bound (N + 2) bound (N + 2) bound K]) :: bool)
  (fam ('OTMsg-3[bound (N + 2) bound (N + 2) bound K]) :: bool)
  
  (fam (('OTMsg-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
  (fam (('OTMsg-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
  (fam (('OTMsg-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
  (fam (('OTMsg-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
  
  (fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: unit)
  (fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: unit)
  (fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: unit)
  (fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: unit)
  
  (fam ('OTChc-0[bound (N + 2) bound (N + 2) bound K]) :: bool)
  (fam ('OTChc-1[bound (N + 2) bound (N + 2) bound K]) :: bool)
  
  (fam (('OTChc-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
  (fam (('OTChc-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)
  
  (fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: unit)
  (fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: unit)
  
  (fam ('OTOut[bound (N + 2) bound (N + 2) bound K]) :: bool)
  (fam (('OTOut ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K]) :: bool)  
  .
  
  
  *** embedding
 
 op phi : -> IPDLEmbedding .
 eq phi = 
   'phi from deltaSRW to deltaNMK is 
   (('OTMsg-0['s 'r 'w]) to ('OTMsg-0['n 'm 'k])) ;
    (('OTMsg-1['s 'r 'w]) to ('OTMsg-1['n 'm 'k])) ;
     (('OTMsg-2['s 'r 'w]) to ('OTMsg-2['n 'm 'k])) ;
      (('OTMsg-3['s 'r 'w]) to ('OTMsg-3['n 'm 'k])) ;
  ( (('OTMsg-0 ^^ 'ot .. 'adv)['s 'r 'w]) to (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]) )    ;
  ( (('OTMsg-1 ^^ 'ot .. 'adv)['s 'r 'w]) to (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]) )    ;
  ( (('OTMsg-2 ^^ 'ot .. 'adv)['s 'r 'w]) to (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]) )    ;
  ( (('OTMsg-3 ^^ 'ot .. 'adv)['s 'r 'w]) to (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]) )    ;      
  ( (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w]) to (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k])) ;
  ( (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w]) to (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k])) ;
  ( (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['s 'r 'w]) to (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k])) ;
  ( (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['s 'r 'w]) to (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k])) ;
  ( ('OTChc-0['s 'r 'w]) to ('OTChc-0['n 'm 'k])  ) ;
    ( ('OTChc-1['s 'r 'w]) to ('OTChc-1['n 'm 'k])  ) ;
  ( (('OTChc-0 ^^ 'ot .. 'adv)['s 'r 'w]) to (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]) ) ;   
  ( (('OTChc-1 ^^ 'ot .. 'adv)['s 'r 'w]) to (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]) ) ; 
   ( (('OTChcRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w]) to 
       (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]) ) ;         
   ( (('OTChcRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w]) to 
       (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]) ) ; 
   ( ('OTOut['s 'r 'w]) to ('OTOut['n 'm 'k])  ) ;
   ( (('OTOut  ^^ 'ot .. 'adv)['s 'r 'w]) 
     to (('OTOut  ^^ 'ot .. 'adv)['n 'm 'k])  )                 
   .
  
  op 1OutOf4OTIdeal-Honest-Honest : -> Protocol .
  eq 1OutOf4OTIdeal-Honest-Honest =
   ( ('OTMsg-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsg-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsg-2 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsg-3 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   )  ||
      ( ('OTMsgRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('m0 : bool <- read ('OTMsg-0['s 'r 'w]), return ())
   ) ||
      ( ('OTMsgRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('m1 : bool <- read ('OTMsg-1['s 'r 'w]), return ())
   ) ||
      ( ('OTMsgRcvd-2 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('m2 : bool <- read ('OTMsg-2['s 'r 'w]), return ())
   ) ||
      ( ('OTMsgRcvd-3 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('m3 : bool <- read ('OTMsg-3['s 'r 'w]), return ())
   ) || 
      ( ('OTChc-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['s 'r 'w]), return 'oc)
   ) ||
      ( ('OTChc-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['s 'r 'w]), return 'oc)
   ) || 
      ( ('OTChcRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('c0 : bool <- read ('OTChc-0['s 'r 'w]), return ())
   ) ||
      ( ('OTChcRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('c1 : bool <- read ('OTChc-1['s 'r 'w]), return ())
   ) || 
     ( 'OTOut['s 'r 'w] ::=
       nf(
           ('m0 : bool <- read ('OTMsg-0['s 'r 'w]))
           ('m1 : bool <- read ('OTMsg-1['s 'r 'w]))
           ('m2 : bool <- read ('OTMsg-2['s 'r 'w]))
           ('m3 : bool <- read ('OTMsg-3['s 'r 'w]))
           ('c0 : bool <- read ('OTChc-0['s 'r 'w]))
            'c1 : bool <- read ('OTChc-1['s 'r 'w]) ,
            
           if 'c0
            then
             if 'c1 then return 'm3 else return 'm2
            else 
             if 'c1 then return 'm1 else return 'm0
       ) 
   ) || 
      ( ('OTOut ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['s 'r 'w]), return 'out)
   )
  .
  
    op 1OutOf4OTIdeal-Honest-SemiHonest : -> Protocol .
  eq 1OutOf4OTIdeal-Honest-SemiHonest =
   ( ('OTMsg-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsg-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsg-2 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsg-3 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   )  ||
      ( ('OTMsgRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('m0 : bool <- read ('OTMsg-0['s 'r 'w]), return ())
   ) ||
      ( ('OTMsgRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('m1 : bool <- read ('OTMsg-1['s 'r 'w]), return ())
   ) ||
      ( ('OTMsgRcvd-2 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('m2 : bool <- read ('OTMsg-2['s 'r 'w]), return ())
   ) ||
      ( ('OTMsgRcvd-3 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('m3 : bool <- read ('OTMsg-3['s 'r 'w]), return ())
   ) || 
      ( ('OTChc-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
      nf('oc : bool <- read ('OTChc-0['s 'r 'w]), return 'oc)
   ) ||
      ( ('OTChc-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
      nf('oc : bool <- read ('OTChc-1['s 'r 'w]), return 'oc)
   ) || 
      ( ('OTChcRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w]), return 'oc)
   ) ||
      ( ('OTChcRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w]), return 'oc)
   ) || 
     ( 'OTOut['s 'r 'w] ::=
       nf(
           ('m0 : bool <- read ('OTMsg-0['s 'r 'w]))
           ('m1 : bool <- read ('OTMsg-1['s 'r 'w]))
           ('m2 : bool <- read ('OTMsg-2['s 'r 'w]))
           ('m3 : bool <- read ('OTMsg-3['s 'r 'w]))
           ('c0 : bool <- read ('OTChc-0['s 'r 'w]))
            'c1 : bool <- read ('OTChc-1['s 'r 'w]) ,
            
           if 'c0
            then
             if 'c1 then return 'm3 else return 'm2
            else 
             if 'c1 then return 'm1 else return 'm0
       ) 
   ) || 
      ( ('OTOut ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('out : bool <- read ('OTOut['s 'r 'w]), return 'out)
   )
  .
  
    op 1OutOf4OTIdeal-SemiHonest-Honest : -> Protocol .
  eq 1OutOf4OTIdeal-SemiHonest-Honest =
   ( ('OTMsg-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
      nf('om : bool <- read ('OTMsg-0['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsg-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : bool <- read ('OTMsg-1['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsg-2 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
      nf('om : bool <- read ('OTMsg-2['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsg-3 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : bool <- read ('OTMsg-3['s 'r 'w]), return 'om)
   )  ||
      ( ('OTMsgRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsgRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsgRcvd-2 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
      nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsgRcvd-3 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   ) || 
      ( ('OTChc-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
      nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['s 'r 'w]), return 'oc)
   ) ||
      ( ('OTChc-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
      nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['s 'r 'w]), return 'oc)
   ) || 
      ( ('OTChcRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('c0 : bool <- read ('OTChc-0['s 'r 'w]), return ())
   ) ||
      ( ('OTChcRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('c1 : bool <- read ('OTChc-1['s 'r 'w]), return ())
   ) || 
     ( 'OTOut['s 'r 'w] ::=
       nf(
           ('m0 : bool <- read ('OTMsg-0['s 'r 'w]))
           ('m1 : bool <- read ('OTMsg-1['s 'r 'w]))
           ('m2 : bool <- read ('OTMsg-2['s 'r 'w]))
           ('m3 : bool <- read ('OTMsg-3['s 'r 'w]))
           ('c0 : bool <- read ('OTChc-0['s 'r 'w]))
            'c1 : bool <- read ('OTChc-1['s 'r 'w]) ,
            
           if 'c0
            then
             if 'c1 then return 'm3 else return 'm2
            else 
             if 'c1 then return 'm1 else return 'm0
       ) 
   ) || 
      ( ('OTOut ^^ 'ot .. 'adv)['s 'r 'w] ::= 
      nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['s 'r 'w]), return 'out)
   )
  .
  
    op 1OutOf4OTIdeal-SemiHonest-SemiHonest : -> Protocol .
  eq 1OutOf4OTIdeal-SemiHonest-SemiHonest =
   ( ('OTMsg-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
      nf('om : bool <- read ('OTMsg-0['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsg-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : bool <- read ('OTMsg-1['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsg-2 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
      nf('om : bool <- read ('OTMsg-2['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsg-3 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : bool <- read ('OTMsg-3['s 'r 'w]), return 'om)
   )  ||
      ( ('OTMsgRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsgRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsgRcvd-2 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
      nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   ) ||
      ( ('OTMsgRcvd-3 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['s 'r 'w]), return 'om)
   ) || 
     ( ('OTChc-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
      nf('oc : bool <- read ('OTChc-0['s 'r 'w]), return 'oc)
   ) ||
      ( ('OTChc-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
      nf('oc : bool <- read ('OTChc-1['s 'r 'w]), return 'oc)
   ) || 
      ( ('OTChcRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['s 'r 'w]), return 'oc)
   ) ||
      ( ('OTChcRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w] ::= 
       nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['s 'r 'w]), return 'oc)
   ) || 
     ( 'OTOut['s 'r 'w] ::=
       nf(
           ('m0 : bool <- read ('OTMsg-0['s 'r 'w]))
           ('m1 : bool <- read ('OTMsg-1['s 'r 'w]))
           ('m2 : bool <- read ('OTMsg-2['s 'r 'w]))
           ('m3 : bool <- read ('OTMsg-3['s 'r 'w]))
           ('c0 : bool <- read ('OTChc-0['s 'r 'w]))
            'c1 : bool <- read ('OTChc-1['s 'r 'w]) ,
           if 'c0
            then
             if 'c1 then return 'm3 else return 'm2
            else 
             if 'c1 then return 'm1 else return 'm0
       ) 
   ) || 
      ( ('OTOut ^^ 'ot .. 'adv)['s 'r 'w] ::= 
      nf('out : bool <- read ('OTOut['s 'r 'w]), return 'out)
   )
  .
  
    *** real protocol
    
  op 1OutOf4OTReal-Honest-Honest : -> Protocol . 
  op 1OutOf4OTReal-Honest-SemiHonest : -> Protocol . 
  op 1OutOf4OTReal-SemiHonest-Honest : -> Protocol . 
  op 1OutOf4OTReal-SemiHonest-SemiHonest : -> Protocol . 
  
  eq getOutputs(1OutOf4OTReal-Honest-Honest)
   = getOutputs(1OutOf4OTIdeal-Honest-Honest) .
   
  eq getOutputs(1OutOf4OTReal-Honest-SemiHonest)
   = getOutputs(1OutOf4OTIdeal-Honest-SemiHonest) .
   
   eq getOutputs(1OutOf4OTReal-SemiHonest-Honest)
   = getOutputs(1OutOf4OTIdeal-SemiHonest-Honest) .
   
   eq getOutputs(1OutOf4OTReal-SemiHonest-SemiHonest)
   = getOutputs(1OutOf4OTIdeal-SemiHonest-SemiHonest) .   
    
  op 1OutOf4OTReal : -> Protocol .
  eq 1OutOf4OTReal = 
     family '1OutOf4OTReal[bound (N + 2) bound (N + 2) bound K] 
     ('n 'm 'k) (bound (N + 2) bound (N + 2) bound K) ::=
   (when ( (apply 'isHonest 'n) conj (apply 'isHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTReal-Honest-Honest, phi)
   ) ;;
      (when ( (apply 'isSemiHonest 'n) conj (apply 'isHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTReal-SemiHonest-Honest, phi)) ;;
         (when ( (apply 'isHonest 'n) conj (apply 'isSemiHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTReal-Honest-SemiHonest, phi)) ;;
            (when ( (apply 'isSemiHonest 'n) conj (apply 'isSemiHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTReal-SemiHonest-SemiHonest, phi)) 
  .  
  
  op 1OutOf4OTIdeal : -> Protocol .
  eq 1OutOf4OTIdeal = 
     family '1OutOf4OTIdeal[bound (N + 2) bound (N + 2) bound K] 
     ('n 'm 'k) (bound (N + 2) bound (N + 2) bound K) ::=
   (when ( (apply 'isHonest 'n) conj (apply 'isHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTIdeal-Honest-Honest, phi)
   ) ;;
      (when ( (apply 'isSemiHonest 'n) conj (apply 'isHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTIdeal-SemiHonest-Honest, phi)) ;;
         (when ( (apply 'isHonest 'n) conj (apply 'isSemiHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTIdeal-Honest-SemiHonest, phi)) ;;
            (when ( (apply 'isSemiHonest 'n) conj (apply 'isSemiHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTIdeal-SemiHonest-SemiHonest, phi)) 
  .         
     
  op 1OutOf4OTRealNMK : -> Protocol .
  eq 1OutOf4OTRealNMK = 
     '1OutOf4OTReal['n 'm 'k] ::=
   (when ( (apply 'isHonest 'n) conj (apply 'isHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTReal-Honest-Honest, phi)
   ) ;;
      (when ( (apply 'isSemiHonest 'n) conj (apply 'isHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTReal-SemiHonest-Honest, phi)) ;;
         (when ( (apply 'isHonest 'n) conj (apply 'isSemiHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTReal-Honest-SemiHonest, phi)) ;;
            (when ( (apply 'isSemiHonest 'n) conj (apply 'isSemiHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTReal-SemiHonest-SemiHonest, phi)) 
  .  
  
  op 1OutOf4OTIdealNMK : -> Protocol .
  eq 1OutOf4OTIdealNMK = 
     '1OutOf4OTIdeal['n 'm 'k] ::=
   (when ( (apply 'isHonest 'n) conj (apply 'isHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTIdeal-Honest-Honest, phi)
   ) ;;
      (when ( (apply 'isSemiHonest 'n) conj (apply 'isHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTIdeal-SemiHonest-Honest, phi)) ;;
         (when ( (apply 'isHonest 'n) conj (apply 'isSemiHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTIdeal-Honest-SemiHonest, phi)) ;;
            (when ( (apply 'isSemiHonest 'n) conj (apply 'isSemiHonest 'm)  ) --> 
      embedProtocol(1OutOf4OTIdeal-SemiHonest-SemiHonest, phi)) 
  .             
  
  op real : -> Protocol .
  eq real = 
   newfamily ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))])
             ('m 'n 'i) 
             ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in
   newfamily ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in  
   newfamily ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   newfamily ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   newfamily ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))])
             ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   newfamily ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in  
   newfamily ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))])
             ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in                             
   newfamily ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in          
   newfamily ('SendOutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in          
   parties || 1OutOf4OTReal *** 1OutOf4
  .
  
  op parties : -> Protocol .
  eq parties = 
   newfamily ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
             ('n 'm 'i) 
             ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in   
   newfamily ('Share[((bound (N + 2)) (bound K) )]) ('n 'k) 
             ((bound (N + 2)) (bound K) ) : bool in
   partyInitial || partyInductive || partyFinal           
  . 
  
  op partyInitial : -> Protocol .
  eq partyInitial = 
  newfamily ('InShare$[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
            ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in
  newfamily ('InShare$-Sum[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) 
            ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) : bool in
  ( *** start new
    (family (('In ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) ('n 'i)
             ( (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('in : bool <- read ('In['n 'i]), return 'in)
       ) 
       ;; 
       (when (apply 'isHonest 'n) --> 
         nf('in : bool <- read (('In ^^ 'party .. 'adv)['n 'i]), return 'in)
       )       
     )
     ||
     (family ('InRcvd ^^ 'party .. 'adv[((bound (N + 2)) (dependentBound 'I))]) ('n 'i)
             ((bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isHonest 'n) --> 
         nf('x : bool <- read ('In['n 'i]), return ())
       ) 
       ;; 
       (when (apply 'isSemiHonest 'n)  --> 
         nf('in : unit <- read (('InRcvd ^^ 'party .. 'adv)['n 'i]), return 'in)
       )       
     )
     ||
     (family ('InShare$[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
            ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when ('m =T= N + 1) --> 
          nf(('x : bool <- read ('In['n 'i]))
             ('s : bool <- read ('InShare$-Sum[N 'n 'i])), 
             return (ap 'xor pair('x, 's)) )
       )
       ;;
       (otherwise --> 
         nf('x : bool <- read ('In['n 'i]), samp ('flip < () >))
       )      
     )
     ||
      (family (('InShare$ ^^ 'party .. 'adv)
               [((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
            ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
          nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in)
       )
       ;;
       (when (apply 'isHonest 'n)  --> 
         nf('in : bool <- read (('InShare$ ^^ 'party .. 'adv)['m 'n 'i]), 
            return 'in)
       )      
     )
     ||
     (family ('InShare$-Sum[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) 
            ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) ::=
        (when ('m =T= 0) --> 
          nf('in : bool <- read ('InShare$[0 'n 'i]), 
             return 'in)
        )
        ;;
        (otherwise --> 
          nf(('x : bool <- read ('InShare$['m 'n 'i]))
             ('s : bool <- read ('InShare$-Sum[('m -- 1) 'n 'i])), 
             return (ap 'xor pair('s, 'x)) )
        )    
     )
     ||
     (family (('InShare$-Sum ^^ 'party .. 'adv)
              [((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) 
            ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('InShare$-Sum['m 'n 'i]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('InShare$-Sum ^^ 'party .. 'adv)['m 'n 'i]), 
            return 's)
       )       
     )
     ||
     (family ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
            ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
        nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in)    
     )  
     ||
     (family (('SendInShare ^^ 'party .. 'adv)
              [((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))])  
            ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendInShare['m 'n 'i]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('SendInShare ^^ 'party .. 'adv)['m 'n 'i]), 
            return 's)
       )        
     )   
     ||
     (family (('RcvdInShare ^^ 'party .. 'adv)
              [((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
            ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendInShare['n 'm 'i]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('RcvdInShare ^^ 'party .. 'adv)['n 'm 'i]), 
            return 's)
       )        
     ) 
     ||
     (family ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
            ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
        nf('s : bool <- read ('SendInShare['n 'm 'i]), return 's)    
     )        
     ||
     (family (('InShare ^^ 'party .. 'adv)
              [((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) 
            ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('InShare['n 'm 'i]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('InShare ^^ 'party .. 'adv)['n 'm 'i]), 
            return 's)
       )        
     )  
  ) *** end new
  .
  
  op partyInductive : -> Protocol .
  eq partyInductive =
   newfamily ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in   
  family ('Circuit[((bound (N + 2)) (bound K))])  
         ('n 'k) ((bound (N + 2)) (bound K)) ::= 
   (when (apply 'isInputGate 'k) -->          
      ( *** start new
       ( family ('SendBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
                ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
 )
 ||
 (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
       return 'sb) 
 )               
 ||
 ( family ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
          ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
 )
 ||
 (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
         ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
      return 'rb)          
 ) 
 ||
 ( family ('Ctrb[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
          ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)           
 )
 ||
 (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
          ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b)           
 )  
 ||
 (family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
         ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)  
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
           ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b)           
 )  
 ||
     ( family ('Share[ (bound (N + 2)) (bound K)]) 
        ('n 'k) ((bound (N + 2)) (bound K)) ::= 
       nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]),
          return 'in)
     )
     ||
     (family (('Share ^^ 'party .. 'adv)[ (bound (N + 2)) (bound K)]) ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's)
       )        
     )
     ||
     ( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
              ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om)
     )
     ||
     ( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om)
     )
     ||
     ( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om)
     )
     ||
     ( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om)
     )
     ||
     ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc)
     )
     ||
     ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc)
     )
     ) *** end new
   )
   ;;
   (when (apply 'isNotGate 'k) -->    
      ( *** start new
       ( family ('SendBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
 )
 ||
 (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
       return 'sb) 
 )               
 ||
 ( family ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
 )
 ||
 (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
      return 'rb)          
 ) 
 ||
 ( family ('Ctrb[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)           
 )
 ||
 (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b)           
 )  
 ||
 (family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)  
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b)           
 )  
 ||
     ( family ('Share[ (bound (N + 2)) (bound K)]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
        (when ('n =T= N + 1) --> 
          nf( ('x : bool <- read ('Share['n (fun 'wire0 'k)])),
               return (ap 'neg 'x)
          )
        )
        ;;
        (when (neg('n =T= N + 1))--> 
          nf('s : bool <- read ('Share['n (fun 'wire0 'k)]),
          return 's)
        )
          
     )
     ||
     (family (('Share ^^ 'party .. 'adv)[ (bound (N + 2)) (bound K)]) ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's)
       )        
     )
     ||
     ( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om)
     )
     ||
     ( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om)
     )
     ||
     ( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om)
     )
     ||
     ( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om)
     )
     ||
     ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc)
     )
     ||
     ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc)
     )
     ) *** end new
   )
   ;;
   (when (apply 'isXorGate 'k) --> 
      ( *** start new
       ( family ('SendBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
 )
 ||
 (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
       return 'sb) 
 )               
 ||
 ( family ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
 )
 ||
 (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
      return 'rb)          
 ) 
 ||
 ( family ('Ctrb[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)           
 )
 ||
 (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b)           
 )  
 ||
 (family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)  
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b)           
 )          
 ||
     ( family ('Share[ (bound (N + 2)) (bound K)]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
       nf(('x : bool <- read ('Share['n (fun 'wire0 'k)]))
          ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair('x, 'y)) )
     )
     ||
     (family (('Share ^^ 'party .. 'adv)[ (bound (N + 2)) (bound K)]) ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's)
       )        
     )
     ||
     ( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om)
     )
     ||
     ( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om)
     )
     ||
     ( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om)
     )
     ||
     ( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om)
     )
     ||
     ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc)
     )
     ||
     ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc)
     )   
   ) *** end new
   )
      ;;
   (when (apply 'isAndGate 'k) -->
     ( *** start new
     ( family ('SendBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( 
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          samp ('flip < () >)
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('sb : bool <- read ('SendBit['n 'm 'k]),
          return 'sb)
       )   
     )
     ||
      (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendBit['n 'm 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's)
       )        
     )
     ||
     ( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return 'b
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om)
       )   
     )
     ||
     ( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair('x, 'b)) 
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om)
       )   
     )
     ||
     ( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair('y, 'b)) 
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om)
       )   
     )
     ||
     ( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair(ap 'xor pair('x, 'y), 'b))
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om)
       )   
     )
     ||
     ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
      (when ('m <T 'n) --> 
         nf( ('x : bool <- read ('Share['n (fun 'wire0 'k)])),
          return 'x
          )
       )
       ;;
       (when ('n <=T 'm) --> 
         nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc)
       )   
     )
     ||
     ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('m <T 'n) --> 
         nf( ('x : bool <- read ('Share['n (fun 'wire1 'k)])),
          return 'x
          )
       )
       ;;
       (when ('n <=T 'm) --> 
         nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc)
       )   
     )
     ||
     ( family ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
          nf( ('out : bool <- read ('OTOut['m 'n 'k])),
              return 'out
          )     
    )
    ||
     (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('RcvdBit['n 'm 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's)
       )        
     )
      ||
      ( family ('Ctrb[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
      (when ('n <T 'm) --> 
         nf( ('s : bool <- read ('SendBit['n 'm 'k])),
          return 's
          )
       )
       ;;
       (when ('n =T= 'm) --> 
         nf( ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'and pair('x, 'y))
          )
       )
       ;;
       (when ('m <T 'n) --> 
         nf( ('r : bool <- read ('RcvdBit['n 'm 'k])),
          return 'r
          )
       )   
     )
     ||
 (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Ctrb['n 'm 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's)
       )               
 )  
      ||
      (family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   (when ('m =T= 0) --> 
     nf( ('b : bool <- read ('Ctrb['n 0 'k])),
          return 'b
          ) 
   )
   ;;
   (when (neg ('m =T= 0)) --> 
     nf( ('s : bool <- read ('CtrbSum['n ('m -- 1) 'k]))
         ('b : bool <- read ('Ctrb['n 'm 'k])),
          return (ap 'xor pair('s, 'b)) 
          ) 
   )
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('CtrbSum['n 'm 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's)
       )        
     )
      ||   
 ( family ('Share[ (bound (N + 2)) (bound K)]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
          nf( ('bs : bool <- read ('CtrbSum['n (N + 1) 'k])),
              return 'bs
          )     
 )   
 ||
     (family (('Share ^^ 'party .. 'adv)[ (bound (N + 2)) (bound K)]) ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's)
       )        
     ) 
     ) *** end new
   )
  . 
  
  op partyFinal : -> Protocol .
  eq partyFinal = 
   newfamily ('OutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k)
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('OutShareSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k)
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   ( *** start new
     (family ('SendOutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k)
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isOutputWire 'k) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's)
       ) 
       ;; 
       (when (neg (apply 'isOutputWire 'k)) --> 
         nf('s : bool <- read ('SendOutShare['m 'n 'k]), return 's)
       )       
     )
     ||
     (family (('SendOutShare ^^ 'party .. 'adv)
               [((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('m 'n 'k)
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendOutShare['m 'n 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('SendOutShare ^^ 'party .. 'adv)['m 'n 'k]), 
            return 's)
       )       
     )
     ||
     (family (('RcvdOutShare ^^ 'party .. 'adv)
               [((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendOutShare['n 'm 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('RcvdOutShare ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's)
       )       
     )
     || 
     (family ('OutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
      nf('s : bool <- read ('SendOutShare['n 'm 'k]), return 's)       
     )
     ||
     (family (('OutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('OutShare['n 'm 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('OutShare ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's)
       )       
     )
     ||
     (family ('OutShareSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when ('m =T= 0) --> 
         nf('s : bool <- read ('OutShare['n 0 'k]), 
            return 's)
       )
       ;;
       (otherwise -->
         nf( ('s : bool <- read ('OutShareSum['n ('m -- 1) 'k]))
             ('x : bool <- read ('OutShare['n 'm 'k])),
             return (ap 'xor pair('s, 'x))
         )
       )
     )        
     ||
     (family (('OutShareSum ^^ 'party .. 'adv)
              [((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('OutShareSum['n 'm 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('OutShareSum ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's)
       )       
     )
     ||
     (family ('Out[((bound (N + 2)) (bound K))]) ('n 'k)
             ((bound (N + 2)) (bound K)) ::=
      nf('s : bool <- read ('OutShareSum['n (N + 1) 'k]),
         return 's)       
     )
     ||
     (family (('Out ^^ 'party .. 'adv)[((bound (N + 2)) (bound K))]) ('n 'k)
             (bound (N + 2) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Out['n 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Out ^^ 'party .. 'adv)['n 'k]), 
            return 's)
       )       
     )
   ) *** end new
  .
  
    op 1OutOf4 : -> Protocol .
  eq 1OutOf4 =
   ( family (('OTMsg-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   ( family (('OTMsg-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   ( family (('OTMsg-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   ( family (('OTMsg-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m0 : bool <- read ('OTMsg-0['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m1 : bool <- read ('OTMsg-1['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m2 : bool <- read ('OTMsg-2['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m3 : bool <- read ('OTMsg-3['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTChc-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-0['n 'm 'k]), return 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
     )   
   )
   ||
   (family (('OTChc-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-1['n 'm 'k]), return 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c0 : bool <- read ('OTChc-0['n 'm 'k]),  return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
             ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c1 : bool <- read ('OTChc-1['n 'm 'k]),  return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc)
     )   
   )
   ||
   (family (('OTOut ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('out : bool <- read ('OTOut['n 'm 'k]), return 'out)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out)
     )   
   )
   ||
   (family ('OTOut[(bound (N + 2) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     nf( ('m0 : bool <- read ('OTMsg-0['n 'm 'k]))
         ('m1 : bool <- read ('OTMsg-1['n 'm 'k]))
         ('m2 : bool <- read ('OTMsg-2['n 'm 'k]))
         ('m3 : bool <- read ('OTMsg-3['n 'm 'k]))
         ('c0 : bool <- read ('OTChc-0['n 'm 'k]))
         ('c1 : bool <- read ('OTChc-1['n 'm 'k])),
         if 'c0 
         then (if 'c1 then return 'm3 else return 'm2)
         else (if 'c1 then return 'm1 else return 'm0)
      )        
   )  
  .
  
endm

mod PROTOCOLS is
 pr GMWN .
 
 *** restr, 10.4
 
 
  
    *** the restructured protocol
  
  op restr : -> Protocol .
  eq restr =
   newfamily ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i) 
             ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in   
   newfamily ('Share[((bound (N + 2)) (bound K) )]) ('n 'k) 
             ((bound (N + 2)) (bound K) ) : bool in
     restrInitial || restrInductive || restrFinal
  .
  op restrInitial : -> Protocol . 
  eq restrInitial = 
   newfamily ('InShare$[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in
   newfamily ('InShare$-Sum[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) : bool in         
   newfamily ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i) 
             ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in
   ( *** start new
     (family (('In ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) ('n 'i) ((bound (N + 2)) (dependentBound 'I)) ::=
        (when (apply 'isSemiHonest 'n) -->
           nf('in : bool <- read ('In['n 'i]), 
              return 'in)
        )
       ;;
       (when (apply 'isHonest 'n) -->
           nf('in : bool <- read (('In ^^ 'party .. 'adv)['n 'i]), 
              return 'in)
       )
    )
    ||
     (family (('InRcvd ^^ 'party .. 'adv)[( (bound (N + 2)) (dependentBound 'I))]) ('n 'i)
             ( (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isHonest 'n) --> 
         nf('x : bool <- read ('In['n 'i]), return ())
       ) 
       ;; 
       (when (apply 'isSemiHonest 'n)  --> 
         nf('in : unit <- read (('InRcvd ^^ 'party .. 'adv)['n 'i]), return 'in)
       )       
     )
    ||
     (family ('InShare$[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when ('m =T= N + 1) --> 
          nf(('x : bool <- read ('In['n 'i]))
             ('s : bool <- read ('InShare$-Sum[N 'n 'i])), 
             return (ap 'xor pair('x, 's)) )
       )
       ;;
       (otherwise --> 
         nf('x : bool <- read ('In['n 'i]), samp ('flip < () >))
       )      
     )
     ||
     (family ('InShare$-Sum[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) ::=
        (when ('m =T= 0) --> 
          nf('in : bool <- read ('InShare$[0 'n 'i]), 
             return 'in)
        )
        ;;
        (otherwise --> 
          nf(('x : bool <- read ('InShare$['m 'n 'i]))
             ('s : bool <- read ('InShare$-Sum[('m -- 1) 'n 'i])), 
             return (ap 'xor pair('s, 'x)) )
        )    
     )
     ||
      (family (('InShare$ ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
          nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in)
       )
       ;;
       (when (apply 'isHonest 'n)  --> 
         nf('in : bool <- read (('InShare$ ^^ 'party .. 'adv)['m 'n 'i]), 
            return 'in)
       )      
     )
     ||
     (family (('InShare$-Sum ^^ 'party .. 'adv)[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('InShare$-Sum['m 'n 'i]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('InShare$-Sum ^^ 'party .. 'adv)['m 'n 'i]), 
            return 's)
       )       
     ) 
     ||
     (family ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
        nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in)    
     )  
     ||
     (family (('SendInShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendInShare['m 'n 'i]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('SendInShare ^^ 'party .. 'adv)['m 'n 'i]), 
            return 's)
       )        
     )
     ||
     (family (('RcvdInShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendInShare['n 'm 'i]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('RcvdInShare ^^ 'party .. 'adv)['n 'm 'i]), 
            return 's)
       )        
     )
     ||
     (family ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
        nf('s : bool <- read ('SendInShare['n 'm 'i]), return 's)    
     )        
     ||
     (family (('InShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('InShare['n 'm 'i]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('InShare ^^ 'party .. 'adv)['n 'm 'i]), 
            return 's)
       )        
     )
     ) *** end new    
  .
  
    op restrInductive : -> Protocol .
  
  eq restrInductive = 
   newfamily ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in  
   newfamily ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   newfamily ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   newfamily ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   newfamily ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in  
   newfamily ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in                             
   newfamily ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   ( *** start new
   
   family ('Circuit[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
   (when (apply 'isInputGate 'k) --> 
   *** for input gate
 ( family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
 )
 ||
 (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
       return 'sb) 
 )               
 ||
 ( family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
 )
 ||
 (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
      return 'rb)          
 ) 
 ||
 ( family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)           
 )
 ||
 (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b)           
 )  
 ||
 ( family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)  
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b)           
 )  
 ||
     ( family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
       nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]),
          return 'in)
     )
     ||
     (family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's)
       )        
     )
     ||
     (  family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om)
     )
     ||
     (  family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om)
     )
     ||
     (  family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om)
     )
     ||
     (  family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om)
     )
     ||
     (  family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc)
     )
     ||
     (  family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc)
     )
     ||
     (family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
     )
||
   (family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m0 : bool <- read ('OTMsg-0['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m1 : bool <- read ('OTMsg-1['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m2 : bool <- read ('OTMsg-2['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m3 : bool <- read ('OTMsg-3['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-0['n 'm 'k]), return 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
     )   
   )
   ||
   (family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-1['n 'm 'k]), return 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c0 : bool <- read ('OTChc-0['n 'm 'k]),  return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c1 : bool <- read ('OTChc-1['n 'm 'k]),  return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc)
     )   
   )
   ||
   (family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('out : bool <- read ('OTOut['n 'm 'k]), return 'out)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out)
     )   
   )
   ||
   ( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     nf( ('m0 : bool <- read ('OTMsg-0['n 'm 'k]))
         ('m1 : bool <- read ('OTMsg-1['n 'm 'k]))
         ('m2 : bool <- read ('OTMsg-2['n 'm 'k]))
         ('m3 : bool <- read ('OTMsg-3['n 'm 'k]))
         ('c0 : bool <- read ('OTChc-0['n 'm 'k]))
         ('c1 : bool <- read ('OTChc-1['n 'm 'k])),
         if 'c0 
         then (if 'c1 then return 'm3 else return 'm2)
         else (if 'c1 then return 'm1 else return 'm0)
      )        
   )  
   ) *** end when
   ;;
   (when (apply 'isNotGate 'k) -->
  *** for not gate   
 ( family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
 )
 ||
 (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
       return 'sb) 
 )               
 ||
 ( family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
 )
 ||
 (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
      return 'rb)          
 ) 
 ||
 ( family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)           
 )
 ||
 (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b)           
 )  
 ||
 ( family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)  
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b)           
 )  
 ||
     ( family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
        (when ('n =T= N + 1) --> 
          nf( ('x : bool <- read ('Share['n (fun 'wire0 'k)])),
               return (ap 'neg 'x)
          )
        )
        ;;
        (when (neg ('n =T= N + 1)) --> 
          nf('s : bool <- read ('Share['n (fun 'wire0 'k)]),
          return 's)
        )
          
     )
     ||
     (family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's)
       )        
     )
     ||
     (  family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om)
     )
     ||
     (  family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om)
     )
     ||
     (  family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om)
     )
     ||
     (  family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om)
     )
     ||
     (  family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc)
     )
     ||
     (  family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc)
     )
     ||  
  (family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m0 : bool <- read ('OTMsg-0['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m1 : bool <- read ('OTMsg-1['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m2 : bool <- read ('OTMsg-2['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m3 : bool <- read ('OTMsg-3['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-0['n 'm 'k]), return 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
     )   
   )
   ||
   (family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-1['n 'm 'k]), return 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c0 : bool <- read ('OTChc-0['n 'm 'k]),  return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c1 : bool <- read ('OTChc-1['n 'm 'k]),  return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc)
     )   
   )
   ||
   (family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('out : bool <- read ('OTOut['n 'm 'k]), return 'out)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out)
     )   
   )
   ||
   ( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     nf( ('m0 : bool <- read ('OTMsg-0['n 'm 'k]))
         ('m1 : bool <- read ('OTMsg-1['n 'm 'k]))
         ('m2 : bool <- read ('OTMsg-2['n 'm 'k]))
         ('m3 : bool <- read ('OTMsg-3['n 'm 'k]))
         ('c0 : bool <- read ('OTChc-0['n 'm 'k]))
         ('c1 : bool <- read ('OTChc-1['n 'm 'k])),
         if 'c0 
         then (if 'c1 then return 'm3 else return 'm2)
         else (if 'c1 then return 'm1 else return 'm0)
      )        
   )
   )*** end when
   ;;
   (when (apply 'isXorGate 'k) --> 
    *** for xor gate 
 ( family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
 )
 ||
 (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
       return 'sb) 
 )               
 ||
 ( family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
 )
 ||
 (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
      return 'rb)          
 ) 
 ||
 ( family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
    nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)           
 )
 ||
 (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b)           
 )  
 ||
 ( family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)  
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
  nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b)           
 )          
 ||
     ( family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
       nf(('x : bool <- read ('Share['n (fun 'wire0 'k)]))
          ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair('x, 'y)) )
     )
     ||
     (family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's)
       )        
     )
     ||
     (  family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om)
     )
     ||
     (  family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om)
     )
     ||
     (  family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om)
     )
     ||
     (  family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om)
     )
     ||
     (  family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc)
     )
     ||
     (  family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc)
     )
      ||  
  (family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m0 : bool <- read ('OTMsg-0['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m1 : bool <- read ('OTMsg-1['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m2 : bool <- read ('OTMsg-2['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m3 : bool <- read ('OTMsg-3['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-0['n 'm 'k]), return 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
     )   
   )
   ||
   (family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-1['n 'm 'k]), return 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c0 : bool <- read ('OTChc-0['n 'm 'k]),  return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c1 : bool <- read ('OTChc-1['n 'm 'k]),  return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc)
     )   
   )
   ||
   (family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('out : bool <- read ('OTOut['n 'm 'k]), return 'out)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out)
     )   
   )
   ||
   ( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     nf( ('m0 : bool <- read ('OTMsg-0['n 'm 'k]))
         ('m1 : bool <- read ('OTMsg-1['n 'm 'k]))
         ('m2 : bool <- read ('OTMsg-2['n 'm 'k]))
         ('m3 : bool <- read ('OTMsg-3['n 'm 'k]))
         ('c0 : bool <- read ('OTChc-0['n 'm 'k]))
         ('c1 : bool <- read ('OTChc-1['n 'm 'k])),
         if 'c0 
         then (if 'c1 then return 'm3 else return 'm2)
         else (if 'c1 then return 'm1 else return 'm0)
      )        
   )
   ) *** end when
   ;;
   (when (apply 'isAndGate 'k) -->
     *** for and gate
     ( family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( 
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          samp ('flip < () >)
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('sb : bool <- read ('SendBit['n 'm 'k]),
          return 'sb)
       )   
     )
     ||
      (family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendBit['n 'm 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's)
       )        
     )
     ||
     (  family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return 'b
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-0['n 'm 'k]),
          return 'om)
       )   
     )
     ||
     (  family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair('x, 'b)) 
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-1['n 'm 'k]),
          return 'om)
       )   
     )
     ||
     (  family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair('y, 'b)) 
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-2['n 'm 'k]),
          return 'om)
       )   
     )
     ||
     (  family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('n <T 'm) --> 
         nf( ('b : bool <- read ('SendBit['n 'm 'k]))
             ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'xor pair(ap 'xor pair('x, 'y), 'b))
          )
       )
       ;;
       (when ('m <=T 'n) --> 
         nf('om : bool <- read ('OTMsg-3['n 'm 'k]),
          return 'om)
       )   
     )
     ||
     (  family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
      (when ('m <T 'n) --> 
         nf( ('x : bool <- read ('Share['n (fun 'wire0 'k)])),
          return 'x
          )
       )
       ;;
       (when ('n <=T 'm) --> 
         nf('oc : bool <- read ('OTChc-0['m 'n 'k]),
          return 'oc)
       )   
     )
     ||
     (  family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when ('m <T 'n) --> 
         nf( ('x : bool <- read ('Share['n (fun 'wire1 'k)])),
          return 'x
          )
       )
       ;;
       (when ('n <=T 'm) --> 
         nf('oc : bool <- read ('OTChc-1['m 'n 'k]),
          return 'oc)
       )   
     )
     ||
     ( family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
          nf( ('out : bool <- read ('OTOut['m 'n 'k])),
              return 'out
          )     
    )
    ||
     (family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('RcvdBit['n 'm 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's)
       )        
     )
      ||
      ( family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
      (when ('n <T 'm) --> 
         nf( ('s : bool <- read ('SendBit['n 'm 'k])),
          return 's
          )
       )
       ;;
       (when ('n =T= 'm) --> 
         nf( ('x : bool <- read ('Share['n (fun 'wire0 'k)]))
             ('y : bool <- read ('Share['n (fun 'wire1 'k)])),
          return (ap 'and pair('x, 'y))
          )
       )
       ;;
       (when ('m <T 'n) --> 
         nf( ('r : bool <- read ('RcvdBit['n 'm 'k])),
          return 'r
          )
       )   
     )
     ||
     (family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) -->
             nf('s : bool <- read ('Ctrb['n 'm 'k]), return 's)
       )
       ;;
       (when (apply 'isHonest 'n) -->
             nf('s : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 's)
       ) 
     )
      ||
      ( family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
   (when ('m =T= 0) --> 
     nf( ('b : bool <- read ('Ctrb['n 0 'k])),
          return 'b
          ) 
   )
   ;;
   (when (neg ('m =T= 0)) --> 
     nf( ('s : bool <- read ('CtrbSum['n ('m -- 1) 'k]))
         ('b : bool <- read ('Ctrb['n 'm 'k])),
          return (ap 'xor pair('s, 'b)) 
          ) 
   )
 )
 ||
 (family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
           ((bound (N + 2)) (bound (N + 2)) (bound K)) ::= 
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('CtrbSum['n 'm 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's)
       )        
     )
      ||   
 ( family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::= 
          nf( ('bs : bool <- read ('CtrbSum['n (N + 1) 'k])),
              return 'bs
          )     
 )   
 ||
     (family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k)  
             ((bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), 
            return 's)
       )        
     )
     ||
     (family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om)
     ) 
     ;;
     (when (apply 'isHonest 'n) --> 
       nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m0 : bool <- read ('OTMsg-0['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m1 : bool <- read ('OTMsg-1['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m2 : bool <- read ('OTMsg-2['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'n) --> 
       nf('m3 : bool <- read ('OTMsg-3['n 'm 'k]), return  () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'n) --> 
       nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
     )   
   )
   ||
   (family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-0['n 'm 'k]), return 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
     )   
   )
   ||
   (family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : bool <- read ('OTChc-1['n 'm 'k]), return 'oc)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c0 : bool <- read ('OTChc-0['n 'm 'k]),  return () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc)
     )   
   )
   ||
   (family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isHonest 'm) --> 
       nf('c1 : bool <- read ('OTChc-1['n 'm 'k]),  return () )
     ) 
     ;;
     (when (apply 'isSemiHonest 'm) --> 
       nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), 
          return 'oc)
     )   
   )
   ||
   (family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     (when (apply 'isSemiHonest 'm) --> 
       nf('out : bool <- read ('OTOut['n 'm 'k]), return 'out)
     ) 
     ;;
     (when (apply 'isHonest 'm) --> 
       nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out)
     )   
   )
   ||
   ( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
     nf( ('m0 : bool <- read ('OTMsg-0['n 'm 'k]))
         ('m1 : bool <- read ('OTMsg-1['n 'm 'k]))
         ('m2 : bool <- read ('OTMsg-2['n 'm 'k]))
         ('m3 : bool <- read ('OTMsg-3['n 'm 'k]))
         ('c0 : bool <- read ('OTChc-0['n 'm 'k]))
         ('c1 : bool <- read ('OTChc-1['n 'm 'k])),
         if 'c0 
         then (if 'c1 then return 'm3 else return 'm2)
         else (if 'c1 then return 'm1 else return 'm0)
      )        
   ) 
   )
   ) *** end new
  . 
     
  op restrFinal : -> Protocol .  
  
  eq restrFinal = 
   newfamily ('SendOutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in          
   newfamily ('OutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) : bool in
   newfamily ('OutShareSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) : bool in
   ( *** start new
     (family ('SendOutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isOutputWire 'k) --> 
         nf('s : bool <- read ('Share['n 'k]), return 's)
       ) 
       ;; 
       (when (neg (apply 'isOutputWire 'k)) --> 
         nf('s : bool <- read ('SendOutShare['m 'n 'k]), return 's)
       )       
     )
     ||
     (family (('SendOutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendOutShare['m 'n 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('SendOutShare ^^ 'party .. 'adv)['m 'n 'k]), 
            return 's)
       )       
     )
     ||
     (family (('RcvdOutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('SendOutShare['n 'm 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('RcvdOutShare ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's)
       )       
     )
     || 
     (family ('OutShare[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
      nf('s : bool <- read ('SendOutShare['n 'm 'k]), return 's)       
     )
     ||
     (family (('OutShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('OutShare['n 'm 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('OutShare ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's)
       )       
     )
     ||
     (family ('OutShareSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when ('m =T= 0) --> 
         nf('s : bool <- read ('OutShare['n 0 'k]), 
            return 's)
       )
       ;;
       (otherwise -->
         nf( ('s : bool <- read ('OutShareSum['n ('m -- 1) 'k]))
             ('x : bool <- read ('OutShare['n 'm 'k])),
             return (ap 'xor pair('s, 'x))
         )
       )
     )        
     ||
     (family (('OutShareSum ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k)
             (bound (N + 2) (bound (N + 2)) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('OutShareSum['n 'm 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('OutShareSum ^^ 'party .. 'adv)['n 'm 'k]), 
            return 's)
       )       
     )
     ||
     (family ('Out[((bound (N + 2)) (bound K))]) ('n 'k)
             ((bound (N + 2)) (bound K)) ::=
      nf('s : bool <- read ('OutShareSum['n (N + 1) 'k]),
         return 's)       
     )
     ||
     (family (('Out ^^ 'party .. 'adv)[((bound (N + 2)) (bound K))]) ('n 'k)
             (bound (N + 2) (bound K)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('Out['n 'k]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('Out ^^ 'party .. 'adv)['n 'k]), 
            return 's)
       )       
     )
   ) *** end new
.

 op pInt0 : -> Protocol .
 eq pInt0 = 
    newfamily ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i) 
             ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in   
    newfamily ('Share[((bound (N + 2)) (bound K) )]) ('n 'k) 
             ((bound (N + 2)) (bound K) ) : bool in
    restrFinal || splitCirc || simplRestrInitial
 .
 
  *** before restructuring Circuit, store the results
 op simplRestrInitial : -> Protocol .
  
 eq simplRestrInitial = 
   newfamily ('InShare$[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in
   newfamily ('InShare$-Sum[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) : bool in         
   ( *** start new
     (family (('In ^^ 'party .. 'adv)[((bound (N + 2))(dependentBound 'I))]) ('n 'i) ((bound (N + 2)) (dependentBound 'I)) ::=
        (when (apply 'isSemiHonest 'n) -->
           nf('in : bool <- read ('In['n 'i]), 
              return 'in)
        )
       ;;
       (when (apply 'isHonest 'n) -->
           nf('in : bool <- read (('In ^^ 'party .. 'adv)['n 'i]), 
              return 'in)
       )
    )
    ||
     (family (('InRcvd ^^ 'party .. 'adv)[( (bound (N + 2)) (dependentBound 'I))]) ('n 'i)
             ( (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isHonest 'n) --> 
         nf('x : bool <- read ('In['n 'i]), return ())
       ) 
       ;; 
       (when (apply 'isSemiHonest 'n)  --> 
         nf('in : unit <- read (('InRcvd ^^ 'party .. 'adv)['n 'i]), return 'in)
       )       
     )
    ||
     (family ('InShare$[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when ('m =T= N + 1) --> 
          nf(('x : bool <- read ('In['n 'i]))
             ('s : bool <- read ('InShare$-Sum[N 'n 'i])), 
             return (ap 'xor pair('x, 's)) )
       )
       ;;
       (otherwise --> 
         nf('x : bool <- read ('In['n 'i]), samp ('flip < () >))
       )      
     )
     ||
     (family ('InShare$-Sum[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) ::=
        (when ('m =T= 0) --> 
          nf('in : bool <- read ('InShare$[0 'n 'i]), 
             return 'in)
        )
        ;;
        (otherwise --> 
          nf(('x : bool <- read ('InShare$['m 'n 'i]))
             ('s : bool <- read ('InShare$-Sum[('m -- 1) 'n 'i])), 
             return (ap 'xor pair('s, 'x)) )
        )    
     )
     ||
      (family (('InShare$ ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
          nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in)
       )
       ;;
       (when (apply 'isHonest 'n)  --> 
         nf('in : bool <- read (('InShare$ ^^ 'party .. 'adv)['m 'n 'i]), 
            return 'in)
       )      
     )
     ||
     (family (('InShare$-Sum ^^ 'party .. 'adv)[((bound (N + 1)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 1)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('InShare$-Sum['m 'n 'i]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('InShare$-Sum ^^ 'party .. 'adv)['m 'n 'i]), 
            return 's)
       )       
     ) 
     ||
     (family (('SendInShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('m 'n 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('in : bool <- read ('InShare$['m 'n 'i]), return 'in)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('SendInShare ^^ 'party .. 'adv)['m 'n 'i]), 
            return 's)
       )        
     )
     ||
     (family (('RcvdInShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('in : bool <- read ('InShare$['n 'm 'i]), return 'in)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('RcvdInShare ^^ 'party .. 'adv)['n 'm 'i]), 
            return 's)
       )        
     )
     ||
     (family ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
        nf('in : bool <- read ('InShare$['n 'm 'i]), return 'in)   
     )        
     ||
     (family (('InShare ^^ 'party .. 'adv)[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i)  
            ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) ::=
       (when (apply 'isSemiHonest 'n) --> 
         nf('s : bool <- read ('InShare['n 'm 'i]), return 's)
       ) 
       ;; 
       (when (apply 'isHonest 'n)  --> 
         nf('s : bool <- read (('InShare ^^ 'party .. 'adv)['n 'm 'i]), 
            return 's)
       )        
     )
     ) *** end new    
  . 
 
 op splitCirc : -> Protocol .
 eq splitCirc = 
    newfamily ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
    newfamily ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   (adv || shares || 1OutOf4OT)          
 .
 
  *** restructuring Circuit
  
  *** 1. Shares
  op shares : -> Protocol .
eq shares = 
 family ('Shares[bound K]) 'k (bound K) ::=
 ( *** start family
  (when (apply 'isInputGate 'k) --> 
    (family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
      nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
    )
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
    ||
    (family ('Ctrb[((bound (N + 2))(bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
    ||
    (family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::=
      nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), 
         return 'in)
    )
  ) *** end when input gate
  ;;
   (when (apply 'isNotGate 'k) --> 
    (family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
      nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
    )
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
    ||
    (family ('Ctrb[((bound (N + 2))(bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
    ||
    (family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::=
      (when ('n =T= N + 1) -->
 nf('x : bool <- read ('Share['n (fun 'wire0 'k)]), 
  return (ap 'neg 'x)))
;;
(when (neg ('n =T= N + 1)) -->
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's)
)
    )
  ) *** end when not gate
  ;;
   (when (apply 'isXorGate 'k) --> 
    (family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
      nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
    )
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
    ||
    (family ('Ctrb[((bound (N + 2))(bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
    ||
    (family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::=
      nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
          'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
         return (ap 'xor pair('x, 'y)))
    )
  ) *** end when xor gate
  ;;
   (when (apply 'isAndGate 'k) --> 
    (family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
      nf(('b : bool <- read ('SendBit['m 'n 'k])) 
         ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) 
         ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) 
         ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 
          'yn : bool <- read ('Share['n (fun 'wire1 'k)]), 
          return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn), 
                                            ap 'and pair('xn, 'ym)), 
                               'b)))
    )
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    samp ('flip < () >)))
;;
(when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
)
    ||
    (family ('Ctrb[((bound (N + 2))(bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'and pair('x, 'y)) ))
;;
(when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r)
)
)
||
( family ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b))
;;
(when (neg (0 =T= 'm)) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k]))  
    's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), 
    return (ap 'xor pair('s, 'b)))
)
)
    ||
    (family ('Share[((bound (N + 2)) (bound K))]) ('n 'k) ((bound (N + 2)) (bound K)) ::=
      nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs)
    )
  ) *** end when and gate
  
 ) *** end family
. 
  *** 2. Adv
  op adv : -> Protocol .
eq adv = 
 family ('Adv[bound K]) 'k (bound K) ::=
 ( *** start family
(when (apply 'isInputGate 'k) -->
(family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b)
)
||
(family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b)
)
||
(family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])   ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out)
)
||
(family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb)
)
||
(family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb)
)
||
(
family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k) ((bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's)
)
)
) *** end when input gate        
;;
(when (apply 'isNotGate 'k) -->
(family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b)
)
||
(family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b)
)
||
(family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out)
)
||
(family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb)
)
||
(family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb)
)
||
(family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k)
((bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's)
)
)
) *** end when not gate
;;
(when (apply 'isXorGate 'k) -->
(family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 'b)
)
||
(family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('b : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 'b)
)
||
(family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
||
(family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
||
(family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out)
)
||
(family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('rb : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 'rb)
)
||
(family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf('sb : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 'sb)
)
||
(family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k)
((bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's)
)
)
)
;;
(when (apply 'isAndGate 'k) -->
(family (('Ctrb ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Ctrb['n 'm 'k]), return 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Ctrb ^^ 'party .. 'adv)['n 'm 'k]), return 's)
)
)
||
(family (('CtrbSum ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('CtrbSum['n 'm 'k]), return 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('CtrbSum ^^ 'party .. 'adv)['n 'm 'k]), return 's)
)
)
||
(family (('OTChc-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isSemiHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), return 'x))
;;
(when ((apply 'isHonest 'm) disj 'm <=T 'n) -->
nf('oc : bool <- read (('OTChc-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
)
||
(family (('OTChc-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isSemiHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), return 'x))
;;
(when ((apply 'isHonest 'm) disj 'm <=T 'n) -->
nf('oc : bool <- read (('OTChc-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
)
||
(family (('OTChcRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire0 'k)]), return ()))
;;
(when ((apply 'isSemiHonest 'm) disj 'm <=T 'n) -->
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
)
||
(family (('OTChcRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isHonest 'm) conj 'n <T 'm) -->
nf('x : bool <- read ('Share['m (fun 'wire1 'k)]), return ()))
;;
(when ((apply 'isSemiHonest 'm) disj 'm <=T 'n) -->
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'oc)
)
)
||
(family (('OTMsg-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return 'b ))
;;
(when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
)
||
(family (('OTMsg-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair('x, 'b)) ))
;;
(when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
)
||
(family (('OTMsg-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair('y, 'b)) )
)
;;
(when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
)
||
(family (('OTMsg-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isSemiHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)))
)
;;
(when ((apply 'isHonest 'n) disj 'm <=T 'n) -->
nf('om : bool <- read (('OTMsg-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
)
||
(family (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return ()))
;;
(when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-0 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
)
||
(family (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return ()))
;;
(when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-1 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
)
||
(family (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return ()))
;;
(when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-2 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
)
||
(family (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ((apply 'isHonest 'n) conj 'n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return ()))
;;
(when ((apply 'isSemiHonest 'n) disj 'm <=T 'n) -->
nf('om : unit <- read (('OTMsgRcvd-3 ^^ 'ot .. 'adv)['n 'm 'k]), return 'om)
)
)
||
(family (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'm) -->
nf('out : bool <- read ('RcvdBit['m 'n 'k]), return 'out))
;;
(when (apply 'isHonest 'm) -->
nf('out : bool <- read (('OTOut ^^ 'ot .. 'adv)['n 'm 'k]), return 'out)
)
)
||
(family (('RcvdBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('RcvdBit['n 'm 'k]), return 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdBit ^^ 'party .. 'adv)['n 'm 'k]), return 's)
)
)
||
(family (('SendBit ^^ 'party .. 'adv)[((bound (N + 2))(bound (N + 2))(bound K))])  ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('SendBit ^^ 'party .. 'adv)['n 'm 'k]), return 's)
)
)
||
family (('Share ^^ 'party .. 'adv)[((bound (N + 2))(bound K))])  ('n 'k)
((bound (N + 2)) (bound K)) ::=
(when (apply 'isSemiHonest 'n) -->
nf('s : bool <- read ('Share['n 'k]), return 's))
;;
(when (apply 'isHonest 'n) -->
nf('s : bool <- read (('Share ^^ 'party .. 'adv)['n 'k]), return 's)
)
) *** end when and gate
 ) *** end family
.
  *** 3. 1OutOf4OT
  op 1OutOf4OT : -> Protocol .
  
  eq 1OutOf4OT =
    newfamily ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in  
    newfamily ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
    newfamily ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
    newfamily ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
    newfamily ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in  
    newfamily ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in                             
    newfamily ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   family ('1OutOf4OT[bound K]) 'k (bound K) ::=
    ( *** start family
      (when (apply 'isInputGate 'k) -->
      ( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om)
      )
      ||
      ( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om)
      )
      ||
      ( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om)
      ) 
      ||
      ( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om)
      )
      ||
      ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('oc : bool <- read ('OTChc-0['m 'n 'k]), return 'oc)
      )
      ||
      ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('oc : bool <- read ('OTChc-1['m 'n 'k]), return 'oc)
      )
      ||
      ( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('o : bool <- read ('OTOut['n 'm 'k]), return 'o)
      ) 
    ) *** end when input gate
    ;;
    (when (apply 'isNotGate 'k) -->
      ( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om)
      )
      ||
      ( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om)
      )
      ||
      ( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om)
      ) 
      ||
      ( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om)
      )
      ||
      ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('oc : bool <- read ('OTChc-0['m 'n 'k]), return 'oc)
      )
      ||
      ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('oc : bool <- read ('OTChc-1['m 'n 'k]), return 'oc)
      )
      ||
      ( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('o : bool <- read ('OTOut['n 'm 'k]), return 'o)
      ) 
    ) *** end when not gate
    ;;
    (when (apply 'isXorGate 'k) -->
      ( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om)
      )
      ||
      ( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om)
      )
      ||
      ( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om)
      ) 
      ||
      ( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om)
      )
      ||
      ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('oc : bool <- read ('OTChc-0['m 'n 'k]), return 'oc)
      )
      ||
      ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('oc : bool <- read ('OTChc-1['m 'n 'k]), return 'oc)
      )
      ||
      ( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        nf('o : bool <- read ('OTOut['n 'm 'k]), return 'o)
      ) 
    ) *** end when xor gate
    ;;
    
    
    (when (apply 'isAndGate 'k) -->
( family ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ('n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return 'b )
)
;;
(when ('m <=T 'n) -->
nf('om : bool <- read ('OTMsg-0['n 'm 'k]), return 'om)
)
)
||
( family ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ('n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair('x, 'b)) ))
;;
(when ('m <=T 'n) -->
nf('om : bool <- read ('OTMsg-1['n 'm 'k]), return 'om)
)
)
||
( family ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ('n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair('y, 'b))))
;;
(when ('m <=T 'n) -->
nf('om : bool <- read ('OTMsg-2['n 'm 'k]), return 'om)
)
)
||
( family ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
(when ('n <T 'm) -->
nf(('b : bool <- read ('SendBit['n 'm 'k])) 
   ('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair(ap 'xor pair('x, 'y), 'b)) )
)
;;
(when ('m <=T 'n) -->
nf('om : bool <- read ('OTMsg-3['n 'm 'k]), return 'om)
)
)
      ||
      ( family ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        (when ('m <T 'n) --> 
          nf('x : bool <- read ('Share['n (fun 'wire0 'k)]), 
             return 'x))
        ;;
        (when ('n <=T 'm) -->
          nf('oc : bool <- read ('OTChc-0['m 'n 'k]), return 'oc)
        )
      )
      ||
      ( family ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('m 'n 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
        (when ('m <T 'n) --> 
          nf('x : bool <- read ('Share['n (fun 'wire1 'k)]), 
             return 'x))
        ;;
        (when ('n <=T 'm) -->
          nf('oc : bool <- read ('OTChc-1['m 'n 'k]), return 'oc)
        )
      )
      ||
( family ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) ((bound (N + 2)) (bound (N + 2)) (bound K)) ::=
nf(('c0 : bool <- read ('OTChc-0['n 'm 'k])) 
   ('c1 : bool <- read ('OTChc-1['n 'm 'k])) 
   ('m0 : bool <- read ('OTMsg-0['n 'm 'k])) 
   ('m1 : bool <- read ('OTMsg-1['n 'm 'k])) 
   ('m2 : bool <- read ('OTMsg-2['n 'm 'k])) 
    'm3 : bool <- read ('OTMsg-3['n 'm 'k]), 
   if 'c0 then if 'c1 then return 'm3 else return 'm2 
          else if 'c1 then return 'm1 else return 'm0)
)
    ) *** end when and gate  
    
    ) *** end family
. 

 op pInt1 : -> Protocol .
 eq pInt1 = 
    newfamily ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]) ('n 'm 'i) 
             ((bound (N + 2)) (bound (N + 2)) (dependentBound 'I)) : bool in   
    newfamily ('Share[((bound (N + 2)) (bound K) )]) ('n 'k) 
             ((bound (N + 2)) (bound K) ) : bool in
    restrFinal || splitCirc1 || simplRestrInitial
 .
 
   op splitCirc1 : -> Protocol .
 eq splitCirc1 = 
    newfamily ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
   newfamily ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in
    newfamily ('CtrbSum[((bound (N + 2)) (bound (N + 2)) (bound K))]) ('n 'm 'k) 
             ((bound (N + 2)) (bound (N + 2)) (bound K)) : bool in 
   (adv || shares)          
 .   

endm

smod GMWN-STRATS is
 pr STRATS .
 pr PROTOCOLS . 
 
 var e1 e2 e3 e4 e5 e6 : Expression . 
 var Sigma Sigma' : Signature .
 var Delta Delta' : ChannelContext .
 var Gamma : TypeContext .
 var I O I' O' : Set{CNameBound} .
 var A : Set{BoolTerm} .
 var x y : Qid .
 var pConf pConf' : ProtocolConfig .
 var P P' : Protocol .
 var T : Type .
 var cn : ChannelName .
 var bounds : List{Bounds} .
 var fns1 fns2 : NameWithScripts .
 var q : Qid .
 var bt : BoolTerm .
 var A' : Set{BoolTerm} .
 
 var nw nl : Nat .
 
 rl [HH2HH] : 
  aCongrConfig(pConfig(Sigma, Delta, 1OutOf4OTReal-Honest-Honest, I, O, A), 
               length nl )
  =>
  aCongrConfig(pConfig(Sigma, Delta, 1OutOf4OTIdeal-Honest-Honest, I, O, A), 
               length nl) 
  .   
 
 rl [SHH2SHH] : 
  aCongrConfig(pConfig(Sigma, Delta, 1OutOf4OTReal-SemiHonest-Honest, I, O, A), 
               length nl )
  =>
  aCongrConfig(pConfig(Sigma, Delta, 1OutOf4OTIdeal-SemiHonest-Honest, I, O, A), 
               length nl) 
 . 
 
 rl [HSH2HSH] : 
  aCongrConfig(pConfig(Sigma, Delta, 1OutOf4OTReal-Honest-SemiHonest, I, O, A), 
               length nl )
  =>
  aCongrConfig(pConfig(Sigma, Delta, 1OutOf4OTIdeal-Honest-SemiHonest, I, O, A), 
               length nl)  
 . 
 
 rl [SHSH2SHSH] : 
  aCongrConfig(pConfig(Sigma, Delta, 1OutOf4OTReal-SemiHonest-SemiHonest, I, O, A), 
               length nl )
  =>
  aCongrConfig(pConfig(Sigma, Delta, 1OutOf4OTIdeal-SemiHonest-SemiHonest, I, O, A), 
               length nl) 
 . 
 
 strat eliminateOTDivergent @ ProtocolConfig .
 sd eliminateOTDivergent := 
           applyDivergeChannel3FamilyBranch(
            fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
            apply 'isSemiHonest 'n, 'om, bool)
         ; applyAllSameCases(
            fam (('OTMsg-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
           )
         
         ; applyDivergeChannel3FamilyBranch(
           fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
           fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
           apply 'isHonest 'n, 'om, unit)
           
         ; applyAllSameCases(
            fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv) 
              [(bound (N + 2) (bound (N + 2)) (bound K))])   
           )
         ; applyDivergeChannel3FamilyBranch(
            fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
            apply 'isSemiHonest 'n, 'om, bool)
            
         ; applyAllSameCases(
            fam (('OTMsg-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
           )
         
         ; applyDivergeChannel3FamilyBranch(
           fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
           fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
           apply 'isHonest 'n, 'om, unit)
           
         ; applyAllSameCases(
            fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv) 
              [(bound (N + 2) (bound (N + 2)) (bound K))])   
           )
         
         ; applyDivergeChannel3FamilyBranch(
            fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
            apply 'isSemiHonest 'n, 'om, bool)
            
         ; applyAllSameCases(
            fam (('OTMsg-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
           )
         
         ; applyDivergeChannel3FamilyBranch(
           fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
           fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
           apply 'isHonest 'n, 'om, unit)
           
         ; applyAllSameCases(
            fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv) 
              [(bound (N + 2) (bound (N + 2)) (bound K))])   
           )
         
         ; applyDivergeChannel3FamilyBranch(
            fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
            apply 'isSemiHonest 'n, 'om, bool)
            
         ; applyAllSameCases(
            fam (('OTMsg-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
           )
         
         ; applyDivergeChannel3FamilyBranch(
           fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
           fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) , 
           apply 'isHonest 'n, 'om, unit)
           
         ; applyAllSameCases(
            fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv) 
              [(bound (N + 2) (bound (N + 2)) (bound K))])   
           )
                                  
         ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-0, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k]  
           
          ; applyDivergeChannel3FamilyBranch(
             fam ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam (('OTChc-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]), 
             apply 'isSemiHonest 'm, 'oc, bool
            )
            
          ; applyAllSameCases(
             fam (('OTChc-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
            )
           
          ; applyDivergeChannel3FamilyBranch(
             fam ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]), 
              apply 'isHonest 'm, 'oc, unit)
              
          ; applyAllSameCases(
              fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
            )
          ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-0, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k] 
           
          ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-1, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k]  
        
          ; applyDivergeChannel3FamilyBranch(
             fam ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam (('OTChc-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]), 
             apply 'isSemiHonest 'm, 'oc, bool
            )
            
          ; applyAllSameCases(
             fam (('OTChc-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
            )
          
          ; applyDivergeChannel3FamilyBranch(
             fam ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]), 
              apply 'isHonest 'm, 'oc, unit)
              
          ; applyAllSameCases(
              fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
            )
          
          ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-1, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]  
              
          ; applySubstDivergeFamily(
             fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam ('OTOut[(bound (N + 2) (bound (N + 2)) (bound K))]), 'o, bool)
       
          ; applyDivergeChannel3FamilyBranch(
             fam ('OTOut[(bound (N + 2) (bound (N + 2)) (bound K))]), 
             fam (('OTOut ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]), 
             apply 'isSemiHonest 'm, 'out, bool)
          ; applyAllSameCases(
             fam (('OTOut ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
            )  
               
 .    
 
 strat sym1 @ ProtocolConfig .
 sd sym1 := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{sym1} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change (fam ('RcvdBit[((bound (N + 2)) (bound (N + 2))(bound K) )]))
        with ( (when ('m <T 'n) -->
           nf(('b : bool <- read ('SendBit['m 'n 'k])) 
    ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) 
    ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) 
    ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 
     'yn : bool <- read ('Share['n (fun 'wire1 'k)]),  
           return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn),
                                             ap 'and pair('xn, 'ym)), 
                           'b))
            )
 )          
  ;;  
 (
 when ('n <=T 'm) -->
   nf('z : bool <- read ('RcvdBit['n 'm 'k]),  return 'z)
 )         
 )
        in P
       ]
       {auxSym1}
       )
 .
 strat auxSym1 @ ProtocolConfig .
 sd auxSym1 := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{auxSym1} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
        CONG-COMP-RIGHT[
         Q:Protocol  <- removeOne P (fam ('RcvdBit[((bound (N + 2)) (bound (N + 2))(bound K) )])), 
         P1:Protocol <- keepOne P (fam ('RcvdBit[((bound (N + 2)) (bound (N + 2))(bound K) )]))]{ 
        CONG-FAMILY-WHENLIST-R[bt:BoolTerm <- ('m <T 'n),
     R2:Reaction <- 
     nf(('b : bool <- read ('SendBit['m 'n 'k])) 
    ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) 
    ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) 
    ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 
     'yn : bool <- read ('Share['n (fun 'wire1 'k)]),  
           if 'xn then 
          if 'yn then return (ap 'xor pair(ap 'xor pair('xm, 'ym), 'b)) 
                 else return (ap 'xor pair('ym, 'b)) 
               else 
          if 'yn then return (ap 'xor pair('xm, 'b)) 
                 else return 'b
                 )]{ 
           
    cong-nf[R2:Reaction <- 
   
        if 'xn then 
          if 'yn then return (ap 'xor pair(ap 'xor pair('xm, 'ym), 'b)) 
                 else return (ap 'xor pair('ym, 'b)) 
               else 
          if 'yn then return (ap 'xor pair('xm, 'b)) 
                 else return 'b
     ]{
        if-intro-ext[q:Qid <- 'yn] ; 
        if-intro-ext[q:Qid <- 'xn]
       } *** cong-nf
       
       
       } *** cong-whenlist
       
       
       
        } *** cong-comp
       )
  .  
  
   strat sym2 @ ProtocolConfig .
 sd sym2 := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{sym2} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        *** was P
        change (fam ('RcvdBit[((bound (N + 2)) (bound (N + 2))(bound K) )]))
        with ( (when ('m <T 'n) -->
           nf(('b : bool <- read ('SendBit['m 'n 'k])) 
    ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) 
    ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) 
    ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 
     'yn : bool <- read ('Share['n (fun 'wire1 'k)]),  
           return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn),
                                             ap 'and pair('xn, 'ym)), 
                           'b)))
 )          
  ;;  
 (
 when ('n <=T 'm) -->
    nf(('b : bool <- read ('SendBit['m 'n 'k])) 
    ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) 
    ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) 
    ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 
     'yn : bool <- read ('Share['n (fun 'wire1 'k)]),  
           return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn),
                                             ap 'and pair('xn, 'ym)), 
                           'b)))
 )         
 )
        in P
       ]{
          auxSym2
        } ***sym
       )
 .
 strat auxSym2 @ ProtocolConfig .
 sd auxSym2 := 
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{auxSym2} 
     : select-branch-family-r[fns:NameWithScripts <- 'RcvdBit,
                              bt:BoolTerm <- ('n <=T 'm)]{
       matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
        CONG-COMP-RIGHT[
          Q:Protocol  <- removeTwo P 
                          (fam ('RcvdBit[((bound (N + 2)) (bound (N + 2))(bound K) )])) 
                          (fam ('SendBit[((bound (N + 2)) (bound (N + 2))(bound K) )])), 
          P1:Protocol <- keepTwo P 
                          (fam ('RcvdBit[((bound (N + 2)) (bound (N + 2))(bound K) )])) 
                          (fam ('SendBit[((bound (N + 2)) (bound (N + 2))(bound K) )]))
                       ]{
              ***    idle
               applySelectCaseDiverge( 
                (fam ('SendBit[((bound (N + 2)) (bound (N + 2))(bound K) )])), 
                (fam ('RcvdBit[((bound (N + 2)) (bound (N + 2))(bound K) )])), 
                ('n <=T 'm), 'z, bool)         
                       }
             )          
       }                
             
     .   

 strat slowSym @ ProtocolConfig .
 sd slowSym := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- pInt0]
       {   
               sugar-newNF
       ; ((COMP-NEW-newNF-inside-new ; lift-inner-new-nf) !)        
              
       ; applyNewCombine(fam ('Adv[bound K]))
       ; applyNewCombine(fam ('Shares[bound K]))
       ; applyNewCombine(fam ('1OutOf4OT[bound K]))
         
       }
         . 
         
 strat addShareSum @ ProtocolConfig .
 sd addShareSum := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'ShareSum
         typed bool
         params ('m 'k)
                ( (bound (N + 2))(bound K) )  
         assigned
          (when ('m =T= 0) -->
            nf('s : bool <- read ('Share[0 'k]), return 's )
          )
          ;;
          (when (neg ('m =T= 0)) -->
            nf(('xs : bool <- read ('ShareSum[('m -- 1) 'k]))
               ('xm : bool <- read ('Share['m 'k])), 
               return (ap 'xor pair('xs, 'xm))  )
          )
         in P
       ]
       {
          absorbFamily( fam ('ShareSum[(bound (N + 2))(bound K)]) )
       } ***sym
       )
 .        
 
 strat sym3 @ ProtocolConfig .
 sd sym3 := 
    *** match pConf s.t. startsWithNew pConf
    ***  ? CONG-NEW-NF{sym3} 
    ***  : 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'InShareOK
         typed unit
         params ('m 'n 'i)
                ((bound (N + 2))(bound (N + 2))(dependentBound 'I))  
         assigned
          nf('is : bool  <- read ('InShare['m 'n 'i]),
              return ())
         in (
         addInternalFamily
           'ShareOK
         typed unit
         params ('n 'k)
                ((bound (N + 2))(bound K))  
         assigned
          nf('x : bool  <- read ('Share['n 'k]),
             return ())
         in P
         )        
       ]{
          absorbFamily(fam ('ShareOK[((bound (N + 2))(bound K))]))
        ; absorbFamily(fam ('InShareOK[((bound (N + 2))(bound (N + 2))(dependentBound 'I))]))
        } ***sym
       )
 .   
 strat sym4 @ ProtocolConfig .
 sd sym4 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         change 
         (
         fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (fixedBound (N + 1)) (bound K)])
         )
         with
         (
         (when ('n <T N + 1) -->
nf('x : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)]), return ())
)
;;
(when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc)
) 
         )
         in 
         (
         change 
         (
         fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (fixedBound (N + 1)) (bound K)])
         )
         with
         (
         (when ('n <T N + 1) -->
nf('x : unit <- read ('ShareOK[(N + 1) (fun 'wire1 'k)]), return ())
)
;;
(when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc)
) 
         )
         in
         P )
       ]{
          applySubstFamilyGenCase(
  fam ('ShareOK[(bound (N + 2)) (bound K)]),
 fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (fixedBound (N + 1)) (bound K)]),
 ('n <T N + 1)
 ) 
 ; 
 applySubstFamilyGenCase(
  fam ('ShareOK[(bound (N + 2)) (bound K)]),
 fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (fixedBound (N + 1)) (bound K)]),
 ('n <T N + 1)
 )
        } ***sym
       )
 .  
 strat sym5 @ ProtocolConfig .
 sd sym5 := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'InShare$-OK
         typed unit
         params ('m 'n 'i)
                ((bound (N + 2))(bound (N + 2))(dependentBound 'I))  
         assigned
          nf('is : bool  <- read ('InShare$['m 'n 'i]),
              return ())
         in (
         addInternalFamily
           'InShare$Sum-OK
         typed unit
         params ('m 'n 'i)
                ((bound (N + 1))(bound (N + 2))(dependentBound 'I))  
         assigned
          nf('is : bool  <- read ('InShare$-Sum['m 'n 'i]),
              return ())
         in (  
         addInternalFamily
           'SendBit-OK
         typed unit
         params ('n 'm 'k)
                ((bound (N + 2))(bound (N + 2))(bound K))  
         assigned
          nf('s : bool  <- read ('SendBit['n 'm 'k]),
              return ())
         in (  
         addInternalFamily
           'RcvdBit-OK
         typed unit
         params ('n 'm 'k)
                ((bound (N + 2))(bound (N + 2))(bound K)) 
         assigned
          nf('r : bool  <- read ('RcvdBit['n 'm 'k]),
              return ())
         in (  
         addInternalFamily
           'Ctrb-OK
         typed unit
         params ('n 'm 'k)
                ((bound (N + 2))(bound (N + 2))(bound K)) 
         assigned
          nf('c : bool  <- read ('Ctrb['n 'm 'k]),
              return ())
         in (   
         addInternalFamily
           'CtrbSum-OK
         typed unit
         params ('n 'm 'k)
                ((bound (N + 2))(bound (N + 2))(bound K)) 
         assigned
          nf('c : bool  <- read ('CtrbSum['n 'm 'k]),
              return ())
         in P
         )))))       
       ]{
          absorbFamily(
            fam ('InShare$Sum-OK[((bound (N + 1))(bound (N + 2))(dependentBound 'I))])
          )
        ; absorbFamily(
            fam ('InShare$-OK[((bound (N + 2))(bound (N + 2))(dependentBound 'I))])
          )
        ; absorbFamily(fam ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
        ; absorbFamily(fam ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
        ; absorbFamily(fam ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
        ; absorbFamily(fam ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
        } ***sym
       )
 .  
 strat sym6 @ ProtocolConfig .
 sd sym6 := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           (fam ('InShareOK[((bound (N + 2))(bound (N + 2))(dependentBound 'I))]))
           (fam ('InShare$-OK[((bound (N + 2))(bound (N + 2))(dependentBound 'I))]))
           (fam ('InShare$Sum-OK[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]))
         named 'InitOK 
         params ('m 'n 'i) ((bound (N + 2))(bound (N + 2))(dependentBound 'I))
         in P
       ]
       {
        applyDropName(fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)])
        )
       } ***sym
       )
 . 
 strat sym7 @ ProtocolConfig .
 sd sym7 := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           (fam ('ShareOK[(bound (N + 2)) (bound K)]))
           (fam ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
           (fam ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
           (fam ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
           (fam ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]))
         named 'SharesOK 
         params 'k (bound K)
         in P
       ]
       {
        applyDropName(fam ('SharesOK[bound K]) ) 
       } ***sym
       )
 .
 strat sym8 @ ProtocolConfig .
 sd sym8 := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using ( 
        applyDropName(fam ('SharesOK[bound K]) )
      ; applyDropName(fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)]))  
      ; SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
        P1:Protocol <- 
         branch
           (when (apply 'isInputGate 'k)) 
         of 
         (fam ('Shares[bound K]) ) 
         change 
          (fam ('Share[(fixedBound (N + 1)) (bound K)]) )
         with 
          nf(('x : unit <- read ('InShareOK[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]))
             'in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]),  
              return 'in)
         in 
         (branch
           (when (apply 'isNotGate 'k)) 
         of 
         (fam ('Shares[bound K]) ) 
         change 
          (fam ('Share[(fixedBound (N + 1)) (bound K)]) )
         with 
          nf( ('s : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)]))
              'x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)]), return (ap 'neg 'x) )
         in 
         ( (branch
           (when (apply 'isXorGate 'k)) 
         of 
         (fam ('Shares[bound K]) ) 
         change 
          (fam ('Share[(fixedBound (N + 1)) (bound K)]) )
         with 
          nf( ('a : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)]))
              ('b : unit <- read ('ShareOK[(N + 1) (fun 'wire1 'k)]))
              ('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 
               'y : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), 
              return (ap 'xor pair('x, 'y)) )
         in 
          (branch
           (when (apply 'isAndGate 'k)) 
         of 
         (fam ('Shares[bound K]) ) 
         change 
          (fam ('Share[(fixedBound (N + 1)) (bound K)]) )
         with 
          nf(('x : unit <- read ('CtrbSum-OK[(N + 1) (N + 1) 'k]))
              'bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k]),  return 'bs)
         in P
          ) ) ) )
       ]{
        applyDropName(fam ('SharesOK[bound K]) )
      ; applyDropName(fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)]))  
      ; select-branch-family-p[fns:NameWithScripts <- 'Shares,
                               bt:BoolTerm <- apply 'isInputGate 'k]
         {
          substNFFamiliesGen(
            fam ('InShareOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)]), 
            fam ('Share[(fixedBound (N + 1)) (bound K)])
          )
         }
      ; select-branch-family-p[fns:NameWithScripts <- 'Shares,
                               bt:BoolTerm <- apply 'isNotGate 'k]
         {
          substNFFamiliesGen(
            fam ('ShareOK[(bound (N + 2)) (bound K)]), 
            fam ('Share[(fixedBound (N + 1)) (bound K)])
          )
         }
      ; select-branch-family-p[fns:NameWithScripts <- 'Shares,
                               bt:BoolTerm <- apply 'isXorGate 'k]
         {
          substNFFamiliesGen(
            fam ('ShareOK[(bound (N + 2)) (bound K)]), 
            fam ('Share[(fixedBound (N + 1)) (bound K)])
          )
         ; applyAlphaNFPr(
            fam ('Share[(fixedBound (N + 1)) (bound K)]), 
            << 'x, 'inA >> emptyQidPairList)
         ; substNFFamiliesGen(
            fam ('ShareOK[(bound (N + 2)) (bound K)]), 
            fam ('Share[(fixedBound (N + 1)) (bound K)])
          )  
         ; applyAlphaNFPr(
            fam ('Share[(fixedBound (N + 1)) (bound K)]), 
            << 'x, 'y >> << 'inA, 'x >> emptyQidPairList)   
         }   
         ; select-branch-family-p[fns:NameWithScripts <- 'Shares,
                               bt:BoolTerm <- apply 'isAndGate 'k]
         {
          substNFFamiliesGen(
            fam ('CtrbSum-OK[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
            fam ('Share[(fixedBound (N + 1)) (bound K)])
          )
         }
       }
       
    )
 .
   
   
 strat sym9 @ ProtocolConfig .
 sd sym9 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'In-OK
         typed unit
         params ('n 'i)
                ((bound (N + 2))(dependentBound 'I))  
         assigned
          nf('in : bool  <- read ('In['n 'i]),
              return () )
         in P
       ]
       {
          absorbFamily( fam ('In-OK[(bound (N + 2))(dependentBound 'I)]) )
       } ***sym
       )
 . 
 *** dummy family to create groups
 strat addHidden @ ProtocolConfig .
 sd addHidden := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       *** I':Set{CNameBound} <- I,
       P1:Protocol <- 
         addInternalFamily
           'Hidden
         typed unit
         params 'k (bound K)
         assigned
          return ()
         in P
       *** A':Set{BoolTerm} <- A        
       ]
       {    sugar-newNF
         ;  absorbFamilyDeleteEmpty( fam ('Hidden[bound K]) )
       } ***sym
       )
 . 
 *** hidden group
 strat addHiddenGroup @ ProtocolConfig .
 sd addHiddenGroup := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           (fam ('Hidden[bound K]))
           
         named 'HiddenGroup 
         params ('k) (bound K) 
         in P
       ]
       {
        applyDropName(fam ('HiddenGroup[bound K]) )
        
       } ***sym
       )
 . 
 strat sym10 @ ProtocolConfig .
 sd sym10 := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           ( fam ('Wire-OK[bound K]) )
         named 'Wires-OK 
         params ('k) (bound K)
         in 
         (addInternalFamily
           'Wire-OK
         typed unit
         params ('k)
                (bound K)  
         assigned
         (
          (when (apply 'isInputGate 'k) --> 
            nf('in : unit <- read ('In-OK[(fun 'wire0 'k) (fun 'wire1 'k)]),
               return 'in
            )
          )
          ;;
          (when (apply 'isNotGate 'k) --> 
            nf('w : unit <- read ('Wire-OK[(fun 'wire0 'k)]),
               return ()
            )
          )
          ;;
          (when (apply 'isXorGate 'k) --> 
            nf( ('w0 : unit <- read ('Wire-OK[(fun 'wire0 'k)]))
                 'w1 : unit <- read ('Wire-OK[(fun 'wire1 'k)]),
               return () 
            )
          )
          ;;
          (when (apply 'isAndGate 'k) --> 
            nf( ('w0 : unit <- read ('Wire-OK[(fun 'wire0 'k)]))
                 'w1 : unit <- read ('Wire-OK[(fun 'wire1 'k)]),
               return () 
            )
          )
          )
         in P
         
         )
       ]
       {
          applyDropName( fam ('Wires-OK[bound K]) )
        ; absorbFamily( fam ('Wire-OK[bound K]) )
        
       } ***sym
       
       
       )
 . 
 
 op cases0 : -> Cases .
eq cases0 = 
(when (apply 'isInputGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's)
)
||
(
family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('i : unit <- read ('InShareOK['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'i)
)
||
(
family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf('i : unit <- read ('InShareOK[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]), return 'i)
)
) *** end when input gate
;;
(when (apply 'isNotGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's)
)
||
(
family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('x : unit <- read ('ShareOK['n (fun 'wire0 'k)]), return 'x)
)
||
(
family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf('x : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)]), return 'x)
)
) *** end when not gate
;;
(when (apply 'isXorGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's)
)
||
(
family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 
    'y : unit <- read ('ShareOK['n (fun 'wire1 'k)]), 
    return ())
)
||
(
family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf(('x : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)])) 
    'y : unit <- read ('ShareOK[(N + 1) (fun 'wire1 'k)]), 
    return ())
)
) *** end when xor gate
;;
(when (apply 'isAndGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) -->
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's))
;;
(when ('m <T 'n) -->
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r))
;;
when ('m =T= 'n) -->
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 'y : unit <- read ('ShareOK['n (fun 'wire1
    'k)]), return ())
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (0 =T= 'm) -->
nf('c : unit <- read ('Ctrb-OK['n 0 'k]), return 'c))
;;
(when (neg (0 =T= 'm)) -->
nf(('x : unit <- read ('CtrbSum-OK['n ('m -- 1) 'k])) 
    'y : unit <- read ('Ctrb-OK['n 'm 'k]), 
     return ())
)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf(('sb : unit <- read ('SendBit-OK['m 'n 'k])) 
   ('xm : unit <- read ('ShareOK['m (fun 'wire0 'k)]))
   ('xn : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 
   ('ym : unit <- read ('ShareOK['m (fun 'wire1 'k)])) 
    'yn : unit <- read ('ShareOK['n (fun 'wire1 'k)]), 
     return ())
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) -->
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 
    'y : unit <- read ('ShareOK['n (fun 'wire1 'k)]), 
    return ()))
;;
(when ('m <=T 'n) -->
nf('sb : unit <- read ('SendBit-OK['n 'm 'k]), return 'sb)
)
)
||
(family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n (N + 1) 'k]), return 'c)
)
||
(family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf('c : unit <- read ('CtrbSum-OK[(N + 1) (N + 1) 'k]), return 'c)
)
) *** end when and gate
.
    
 strat changeComp @ ProtocolConfig .
 sd changeComp :=
 *** sym proof for 'SharesOK
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf 
            by pConf 
            using 
            SYM[
            Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       *** I':Set{CNameBound} <- I,
       *** A':Set{BoolTerm} <- A,   
            P1:Protocol <- 
             change (fam ('SharesOK[bound K]))
             with 
              cases0
             in P
            ]
            *** by the induction
      { indSharedOK 
      }
 .     
 
 op know0 : -> Protocol .
 eq know0 =
(family 'Shares[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family ('Share[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in)
)
||
(family ('Share[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)])) 
    'x : unit <- read ('InShareOK[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]), 
     return 'in)
)
) *** end when input gate
;;
(when (apply 'isNotGate 'k) -->
(family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family ('Share[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's)
)
||
(family ('Share[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf(('s : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)])) 
    'x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)]), 
    return (ap 'neg 'x) )
)
) *** end when not gate
;;
(when (apply 'isXorGate 'k) -->
(family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family ('Share[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)) )
)
||
(family ('Share[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf(('a : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)])) 
   ('b : unit <- read ('ShareOK[(N + 1) (fun 'wire1 'k)])) 
   ('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 
   'y : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), 
   return (ap 'xor pair('x, 'y)) )
)
) *** end when xor gate
;;
(when (apply 'isAndGate 'k) -->
(family ('Ctrb[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)) ))
;;
(when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r)
)
)
||
(family ('CtrbSum[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b))
;;
(when (neg (0 =T= 'm)) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 
    's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), 
    return (ap 'xor pair('s, 'b)) )
)
)
||
(family ('RcvdBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) 
   ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) 
   ('xn : bool <- read ('Share['n (fun 'wire0 'k)])) 
   ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 
    'yn : bool <- read ('Share['n (fun 'wire1 'k)]), 
    return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn), 
                         ap 'and pair('xn, 'ym)), 'b)))
)
||
(family ('SendBit[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 
    'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >) ))
;;
(when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
)
||
(family ('Share[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs)
)
||
(family ('Share[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k])) 
    'x : unit <- read ('CtrbSum-OK[(N + 1) (N + 1) 'k]), 
     return 'bs)
)
) *** end when and gate
)
||
(family 'SharesOK[bound K] 'k
bound K
::=
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : bool <- read ('Ctrb['n 'm 'k]),  return ())
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : bool <- read ('CtrbSum['n 'm 'k]),  return ())
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : bool <- read ('RcvdBit['n 'm 'k]),  return ())
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : bool <- read ('SendBit['n 'm 'k]),  return ())
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('x : bool <- read ('Share['n 'k]), return ())
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('x : bool <- read ('Share[(N + 1) 'k]), return ())
)
.

 
 strat indSharedOK @ ProtocolConfig .
 sd indSharedOK :=
 CONG-NEW-NF{ 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
    CONG-COMP-RIGHT[
        Q:Protocol  <- 
         removeTwo P 
          (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I]))
          (fam ('Comp['Shares 'SharesOK][bound K])), 
        P1:Protocol <- 
          keepTwo P 
           (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
           (fam ('Comp['Shares 'SharesOK][bound K]))                      
        ]
        {
 matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
 SINGLE-INDUCTION-new[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- 'Comp['Shares 'SharesOK],
  blist:List{Bounds} <- bound K,
  P2:Protocol <- know0
 ]{ setIndConfSymProof
 }
 }      
 }
 .
  
 strat setIndConfSymProof @ ProtocolConfig .
 sd setIndConfSymProof := 
         applyDropName(fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
      ; 
       CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]{
          *** for input gate
          select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isInputGate 'B
           ]
           { 
           symSubstDiverge(
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)
          ; symSubstDiverge(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)   
          ; symSubstDiverge(
             fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'r, 'r) 
          ; symSubstDiverge(
             fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 's, 's)   
          *** first the channel       
          ; applyReturnUnit(chn ('ShareOK[(N + 1) 'B]))
          ; substNFFamilyOne(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              'ShareOK[(N + 1) 'B]
              )   
           ; inIndSym1   
           *** now the family
           ; applyReturnUnit(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]))
       ; alpha-family-two-top[fns:NameWithScripts <- 'ShareOK,
          bd1:Bounds <- (bound (N + 1)),
          bd2:Bounds <- (fixedBound 'B),
          q3:Qid <- 'x,
          q4:Qid <- 'y
         ]
       ; substNFFamiliesGen(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              ) 
       ; alpha-family-two-top[fns:NameWithScripts <- 'ShareOK,
          bd1:Bounds <- (bound (N + 1)),
          bd2:Bounds <- (fixedBound 'B),
          q3:Qid <- 'n,
          q4:Qid <- 'k
         ]  
       ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 'is, 'in >> emptyQidPairList)
           
           *** and the sym proof for the family 'Share[bound (N + 1) fixedBound 'B]
       ; inIndSym2
           
           },
           CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]{
          *** for not gate
          select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isNotGate 'B
           ]
           { 
           symSubstDiverge(
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)
          ; symSubstDiverge(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)   
          ; symSubstDiverge(
             fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'r, 'r) 
          ; symSubstDiverge(
             fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 's, 's)   
           *** first the channel
           ;
           use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { 
             substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B]
              )   
            
           }
           ; inIndSym3       
          
           *** now the family
           ; applyReturnUnit(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]))
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              ) 
           } 
           ; inIndSym4
           }
           ,
           CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]{
          *** for xor gate
          select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isXorGate 'B
           ]
           { 
           symSubstDiverge(
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)
          ; symSubstDiverge(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)   
          ; symSubstDiverge(
             fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'r, 'r) 
          ; symSubstDiverge(
             fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 's, 's)   
          *** first the channel
           ;
           use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { 
             substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B]
              )   
           ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                 << 'x, 'a >> emptyQidPairList)  
           ; substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B]
              )   
           ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)  
                 
                 
           }  
           ; inIndSym5     
          
           *** now the family
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              ) 
              ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 'x, 'a >> emptyQidPairList)
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              )  
              ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)   
           } 
           ; inIndSym6
           
           },
           CASE-DISTINCTION-one-end-when{
           *** for and gate
           
           CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'SendBit-OK,
           blist:List{Bounds} <-(bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )
              ; applyAlphaNFPr(fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList)
                 ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )
              ; applyAlphaNFPr(fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)  
           }, 
             idle}
           ; inIndSym7  
          
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { 
             substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList)
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )  
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'yn >> << 'a, 'xn >> emptyQidPairList) 
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList)
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )  
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'ym >> << 'a, 'xm >> emptyQidPairList) 
              ; alpha-family-three-top[fns:NameWithScripts <- 'SendBit-OK,
              bd3:Bounds <- fixedBound 'B,
     q4:Qid <- 'x,
     q5:Qid <- 'y,
     q6:Qid <- 'z
      ]   
              ; substNFFamiliesGen(
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )
              ; alpha-family-three-top[fns:NameWithScripts <- 'SendBit-OK,
              bd3:Bounds <- fixedBound 'B,
     q4:Qid <- 'n,
     q5:Qid <- 'm,
     q6:Qid <- 'k
      ]   
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 's, 'b >> emptyQidPairList)      
              
           }
           ; inIndSym8
           
           ; select-branch-family-r[
             fns:NameWithScripts <- 'Ctrb-OK,
             blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
             bt:BoolTerm <- 'n <T 'm 
           ]{substNFFamiliesGen(
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )}
              
           ; select-branch-family-r[
             fns:NameWithScripts <- 'Ctrb-OK,
             blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
             bt:BoolTerm <- 'm <T 'n 
           ]{substNFFamiliesGen(
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )}   
              
           *** we need to unsplit 'ShareOK on bound 'B
           
           *** TRACE HERE
           
           ; applyUnsplitGroup(fam ('SharesOK[bound 'B]), 
               fam ('ShareOK[bound (N + 1) bound 'B]), 
               fam ('ShareOK[fixedBound (N + 1) bound 'B])
             ) 
           
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           {   
             select-branch-family-r[
             fns:NameWithScripts <- 'Ctrb-OK,
             blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
             bt:BoolTerm <- 'm =T= 'n 
           ]{substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )
             ; applyAlphaNFPr(fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList) 
             ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )
             ; applyAlphaNFPr(fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)      
              }   
           }
            
           ; applySplitInsideGroup(fam ('SharesOK[bound 'B]), 
               fam ('ShareOK[bound (N + 2) bound 'B])
             )   
                       
           *** now the sym proof
           
           ; inIndSym9
            
           *** for CtrbSum-OK we must do induction
           ; inIndSym10 
           
           *** for ShareOK, first the family
           ; substNFFamiliesGen(
              fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('ShareOK[bound (N + 1) fixedBound 'B])
             )  
           
           ; inIndSym11  
           
           *** then the channel
           
           ; substNFFamilyOne(
              fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              'ShareOK[(N + 1) 'B]
              )  
           ; inIndSym12
           
           
           
          }}}}
          *** now we got same thing on all branches, we can merge
          ; applyAllSameCases(
            fam ('SharesOK[fixedBound 'B])
           )
                  
 .      

 ***********************************************
  
 strat inIndSym1 @ ProtocolConfig .
 sd inIndSym1 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareOK[(N + 1) 'B])
        with
         nf('x : bool <- read ('Share[(N + 1) 'B]), return ())
        in P
       ]
       {
        substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B]) 
       ; substNFFamilyOne(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              'ShareOK[(N + 1) 'B]
              )
       ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                         << 'in, 'is >> emptyQidPairList)        
       } 
       
 .
 strat inIndSym2 @ ProtocolConfig .
 sd inIndSym2 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
        with
         nf('x : bool <- read ('Share['n 'B]), return ())
        in P
       ]
       {
         substNFFamiliesGen(
             fam ('Share[bound (N + 1) fixedBound 'B]),
             fam ('ShareOK[bound (N + 1) fixedBound 'B])
            )
       }          
 .
 strat inIndSym3 @ ProtocolConfig .
 sd inIndSym3 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       
       P1:Protocol <- change 
        chn ('ShareOK[(N + 1) 'B])
        with
         nf('x : bool <- read ('Share[(N + 1) 'B]), return ())
        in P
       ]
       {
        substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B])
       ;
           use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { 
             substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B]
              )   
           } 
        }   
 .  
 strat inIndSym4 @ ProtocolConfig .
 sd inIndSym4 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
        with
         nf('x : bool <- read ('Share['n 'B]), return ())
        in P
       ]
       {
       substNFFamiliesGen(
             fam ('Share[bound (N + 1) fixedBound 'B]),
             fam ('ShareOK[bound (N + 1) fixedBound 'B])
            )
      ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 's, 'x >> emptyQidPairList)      
      }    
             
 .  
 strat inIndSym5 @ ProtocolConfig .
 sd inIndSym5 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareOK[(N + 1) 'B])
        with
         nf('x : bool <- read ('Share[(N + 1) 'B]), return ())
        in P
       ]
       {
        substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B])
       ;
           use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { 
             substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B]
              )   
              ;  applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                 << 'x, 'a >> emptyQidPairList) 
              ; substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B]
              )   
              ;  applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)  
  
           } 
        }  
 .  
 strat inIndSym6 @ ProtocolConfig .
 sd inIndSym6 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
        with
         nf('x : bool <- read ('Share['n 'B]), return ())
        in P
       ]
       {
       substNFFamiliesGen(
             fam ('Share[bound (N + 1) fixedBound 'B]),
             fam ('ShareOK[bound (N + 1) fixedBound 'B])
            )
      
       }
                     
 .   
 strat inIndSym7 @ ProtocolConfig .
 sd inIndSym7 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
        with
         nf('s : bool <- read ('SendBit['n 'm 'B]),  return ())
        in P
       ]
       {
       (matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
       SYM[
       Delta1:ChannelContext <- Delta',
       O1:Set{CNameBound} <- O',
       P1:Protocol <- change 
        fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
        with
         (when ('n <T 'm) --> 
           nf('s : bool <- read ('SendBit['n 'm 'B]),  return ())
         )
         ;;
         (when ('m <=T 'n) --> 
           nf('s : bool <- read ('SendBit['n 'm 'B]),  return ())
         )
        in P'
       ] 
        {
        applyAllSameCases(
           fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]) 
        )
        }
       )
       ;
       CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'SendBit-OK,
           blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]
       {
           *** for 'n <T 'm 
           select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]{
           select-case-family-r[
           fns1:NameWithScripts <- 'SendBit,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'n <T 'm]{
           applyDropSubsumeRevFamilies(
             fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
           )
           }
           }
           ,
           *** for 'm <=T 'n
            CASE-DISTINCTION-one-R-end-when[
           fns:NameWithScripts <- 'SendBit-OK,
           blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{     
select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]
{ 
select-case-family-r[
           fns1:NameWithScripts <- 'SendBit,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'm <=T 'n]{
   applySubstDivergeFamily(
     fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     'sb, unit)           
           } 
           }
           }
       } 
   }    
 .  
 strat inIndSym8 @ ProtocolConfig .
 sd inIndSym8 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
        with
         nf('r : bool <- read ('RcvdBit['n 'm 'B]),  return ())
        in P
       ]
       {
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]
{ 
       substNFFamiliesGen(
             fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
            )
            
}       
  }    
                     
 .  
 strat inIndSym9 @ ProtocolConfig .
 sd inIndSym9 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       
       P1:Protocol <- change 
        fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
        with
         nf('c : bool <- read ('Ctrb['n 'm 'B]),  return ())
        in P
       ] 
       {
       (matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
       SYM[
       Delta1:ChannelContext <- Delta',
       O1:Set{CNameBound} <- O',
       P1:Protocol <- change 
        fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
        with
         (when ('n <T 'm) --> 
          nf('c : bool <- read ('Ctrb['n 'm 'B]),  return ())
         )
         ;;
         (when ('m <T 'n) --> 
           nf('c : bool <- read ('Ctrb['n 'm 'B]),  return ())
         )
         ;;
         (when ('m =T= 'n) --> 
           nf('c : bool <- read ('Ctrb['n 'm 'B]),  return ())
         )
        in P'
       ] 
        {
        applyAllSameCases(
           fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]) 
        )
        }
       )
       ; CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'Ctrb-OK,
           blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]
       { *** for 'n <T 'm 
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]{
           select-case-family-r[
           fns1:NameWithScripts <- 'Ctrb,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'n <T 'm]{
           substNFFamiliesGen(
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
            )
           }
           
           }
           
       , 
        CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'Ctrb-OK,
           blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]
       { *** for 'm <T 'n 
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]{
           select-case-family-r[
           fns1:NameWithScripts <- 'Ctrb,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'm <T 'n]{
           substNFFamiliesGen(
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
            )
           }
           
           }
           
       , CASE-DISTINCTION-one-R-end-when[
           fns:NameWithScripts <- 'Ctrb-OK,
           blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]
        { select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]{
           select-case-family-r[
           fns1:NameWithScripts <- 'Ctrb,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'm =T= 'n]{
           substNFFamiliesGen(
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
            )
          }
         }
       }
       
       }
       }
 }    
 . 
 strat inIndSym10 @ ProtocolConfig .
 sd inIndSym10 :=
  SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'CtrbSum-OK,
  blist:List{Bounds} <- bound (N + 2) bound (N + 2) fixedBound 'B,
  cases':Cases <- 
   nf('c : bool <- read ('CtrbSum['n 'm 'B]),  return ())
 ]
 {
 CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'CtrbSum-OK,
           blist:List{Bounds} <- (bound (N + 2) fixedBound 'M fixedBound 'B)
           ]{
           *** for m = 0
           substNFFamiliesGen(
             fam ('Ctrb-OK[(bound (N + 2))(bound (N + 2))(fixedBound 'B)]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
            ) 
           ; inIndSym13    
            , 
           *** for m =/= 0
           CASE-DISTINCTION-one-R-end-when[
           fns:NameWithScripts <- 'CtrbSum-OK,
           blist:List{Bounds} <- (bound (N + 2) fixedBound 'M fixedBound 'B)
           ]{
           substNFFamiliesGen(
             fam ('Ctrb-OK[(bound (N + 2))(bound (N + 2))(fixedBound 'B)]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
            ) 
            ; applyAlphaNFPr(fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
                 << 'c, 'b >> emptyQidPairList)    
            ; 
            substNFFamiliesGen(
             fam ('CtrbSum-OK[bound (N + 2) bound 'M fixedBound 'B]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
            )
            ; applyAlphaNFPr(fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
                 << 'c, 's >> emptyQidPairList)
            ; inIndSym14     
            }
           } 
           ; applyAllSameCases(
           fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]) 
           )
 }
 .   
 strat inIndSym11 @ ProtocolConfig .
 sd inIndSym11 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       
       P1:Protocol <- change 
        fam ('ShareOK[bound (N + 1) fixedBound 'B])
        with
         nf('x : bool <- read ('Share['n 'B]), return ())
        in P
       ]
 {
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]
{ 
         substNFFamiliesGen(
             fam ('Share[bound (N + 1) fixedBound 'B]),
             fam ('ShareOK[bound (N + 1) fixedBound 'B])
            )
       ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 'bs, 'c >> emptyQidPairList)       
         
}       
}    
                        
 .  
 strat inIndSym12 @ ProtocolConfig .
 sd inIndSym12 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       
       P1:Protocol <- change 
        chn ('ShareOK[(N + 1) 'B])
        with
         nf('x : bool <- read ('Share[(N + 1) 'B]), return ())
        in P
       ]
       {
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]{
       substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B])
       }
       ; substNFFamilyOne(
              fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              'ShareOK[(N + 1) 'B]
              ) 
       ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                 << 'bs, 'c >> emptyQidPairList)   
     }      
  . 
  
   strat inIndSym13 @ ProtocolConfig .
 sd inIndSym13 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
             with 
              nf('c : bool <- read ('CtrbSum['n 'M 'B]),  return ())
             in P
            ]
       { select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]{
         substNFFamiliesGen(
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
            )
          }  
       ; applyAlphaNFPr(fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]), 
                 << 'b, 'c >> emptyQidPairList)          
       }
 . 
 strat inIndSym14 @ ProtocolConfig .
 sd inIndSym14 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
             with 
              nf('c : bool <- read ('CtrbSum['n 'M 'B]),  return ())
             in P
            ]
       { select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isAndGate 'B
           ]{
       substNFFamiliesGen(
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
            ) }
       }     
 .                        
   
   
  var tlist : List{NatTerm} .
 var blist1 blist2 : List{Bounds} .
 var q1 q2 : Qid .
 strat symSubstDiverge : CNameBound CNameBound List{NatTerm} Qid Qid @ ProtocolConfig .
 sd symSubstDiverge(fam (fns1[blist1]), fam (fns2[blist2]), tlist, q1, q2) :=          
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       P1:Protocol <- 
        change fam (fns1[blist1])
        with nf(q1 : bool <- read (fns2[tlist]), return ())
        in P,
        Delta1:ChannelContext <- Delta,
        O1:Set{CNameBound} <- O
       ]
       {
           applySubstDivergeFamily(
            fam (fns2[blist2]), 
            fam (fns1[blist1]), 
            q2, unit)   
       }   
    .       


*************************
*** assumptions

*** xor & and are comm and assoc
 rl [comm-xor] : 
    ap 'xor pair(e1, e2) => ap 'xor pair(e2, e1) . 
    
 rl [return-comm-xor] : 
    return(ap 'xor pair(e1, e2)) => return (ap 'xor pair(e2, e1)) .
    
 strat applyReturnCommXor : CNameBound @ ProtocolConfig .
 sd applyReturnCommXor(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnCommXor(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-comm-xor}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-comm-xor}}
                      )
             )
 .     
 sd applyReturnCommXor(fam (cn[bounds])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnCommXor(fam (cn[bounds]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[bounds])), 
                             P1:Protocol <- keepOne P (fam (cn[bounds]))]{
               CONG-REACT-family{cong-nf{return-comm-xor}}
                             }
              or-else (CONG-REACT-family{cong-nf{return-comm-xor}}
                      )
             )
 .
 rl [comm-and] : 
    ap 'and pair(e1, e2) => ap 'and pair(e2, e1) . 
    
 rl [assoc-1-xor] :
    ap 'xor pair(e1, ap 'xor pair(e2, e3)) => 
    ap 'xor pair(ap 'xor pair(e1, e2), e3) .
    
 rl [assoc-2-xor] :
    ap 'xor pair(ap 'xor pair(e1, e2), e3) 
    => 
    ap 'xor pair(e1, ap 'xor pair(e2, e3)) 
    .   
    
 rl [assoc-1-and] :
    ap 'and pair(e1, ap 'and pair(e2, e3)) => 
    ap 'and pair(ap 'and pair(e1, e2), e3) .
    
 rl [assoc-2-and] :
    ap 'and pair(ap 'and pair(e1, e2), e3) 
    => 
    ap 'and pair(e1, ap 'and pair(e2, e3)) 
    .  
 *** xor axioms
 eq ap 'xor pair(e1, e1) = False .
 eq ap 'xor pair(e1, False) = e1 .
 eq ap 'xor pair(False, e2) = e2 .
 *** neg axioms
 rl [neg-xor-1] : 
    ap 'neg e1 => ap 'xor pair(e1, True) .
    
 rl [neg-xor-2] : 
    ap 'xor pair(e1, True) => ap 'neg e1 .   
    
 *** and axioms   
 eq ap 'and pair(e1, True) = e1 .
 eq ap 'and pair(e1, False) = False .   
 eq ap 'and pair(True, e2) = e2 .
 eq ap 'and pair(False, e2) = False .
          
 *** flip
  rl [flip-invar-xor-r] : rConfig(Sigma, Delta, Gamma (x : bool),
            y : bool <- samp ('flip < () >) ; 
            return (ap 'xor pair(x, y)), I, A, bool
            )
            => 
            rConfig(Sigma, Delta , Gamma (x : bool),
            samp ('flip < () >), I, A, bool) . 
  
  *** neg over xor
  rl [neg-over-xor] :
    return (ap 'xor pair(e1, ap 'neg e2)) 
    =>
    return (ap 'neg (ap 'xor pair(e1, e2))) .
    
 strat applyReturnNegOverXor : CNameBound @ ProtocolConfig .
 sd applyReturnNegOverXor(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnNegOverXor(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{neg-over-xor}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{neg-over-xor}}
                      )
             )
 .  
            
  *** until we do expression equality we need this
   *** x = () if x : unit
 rl [return-unit] :
   rConfig(Sigma, Delta, Gamma (x : unit), return x, I, A, T)
   => 
   rConfig(Sigma, Delta, Gamma (x : unit), return (), I, A, T)
 .
 strat applyReturnUnit : CNameBound @ ProtocolConfig .
 sd applyReturnUnit(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnUnit(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-unit}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-unit}}
                      )
             )
 .
  sd applyReturnUnit(fam (cn[bounds])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnUnit(fam (cn[bounds]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[bounds])), 
                             P1:Protocol <- keepOne P (fam (cn[bounds]))]{
                             CONG-REACT-family{cong-nf{return-unit}}
                             }
              or-else (CONG-REACT-family{cong-nf{return-unit}}
                      )
             )
 .  
 rl [return-idem-rev] :
   return (ap 'xor pair(ap 'xor pair(e1, e2), e2) )
   => 
   return e1
 .
 strat applyReturnIdemRev : CNameBound @ ProtocolConfig .
 sd applyReturnIdemRev(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnIdemRev(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-idem-rev}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-idem-rev}}
                      )
             )
 .
  sd applyReturnIdemRev(fam (cn[bounds])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnIdemRev(fam (cn[bounds]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[bounds])), 
                             P1:Protocol <- keepOne P (fam (cn[bounds]))]{
                             CONG-REACT-family{cong-nf{return-idem-rev}}
                             }
              or-else (CONG-REACT-family{cong-nf{return-idem-rev}}
                      )
             )
 .  
 rl [return-idem] :
   return (ap 'xor pair(e1, ap 'xor pair(e1, e2)))
   => 
   return e2
 .
 strat applyReturnIdem : CNameBound @ ProtocolConfig .
 sd applyReturnIdem(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnIdem(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-idem}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-idem}}
                      )
             )
 .
  sd applyReturnIdem(fam (cn[bounds])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnIdem(fam (cn[bounds]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[bounds])), 
                             P1:Protocol <- keepOne P (fam (cn[bounds]))]{
                             CONG-REACT-family{cong-nf{return-idem}}
                             }
              or-else (CONG-REACT-family{cong-nf{return-idem}}
                      )
             )
 .  
  rl [return-idem-2] :
   return (ap 'xor pair(e1, ap 'xor pair(e2, e1)))
   => 
   return e2
 .
 strat applyReturnIdem2 : CNameBound @ ProtocolConfig .
 sd applyReturnIdem2(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnIdem(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-idem-2}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{return-idem-2}}
                      )
             )
 .
  sd applyReturnIdem2(fam (cn[bounds])) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyReturnIdem2(fam (cn[bounds]))} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam (cn[bounds])), 
                             P1:Protocol <- keepOne P (fam (cn[bounds]))]{
                             CONG-REACT-family{cong-nf{return-idem-2}}
                             }
              or-else (CONG-REACT-family{cong-nf{return-idem-2}}
                      )
             )
 .  
  rl [rearrange-xor] :
   return (ap 'xor pair(
              ap 'xor pair(e1, e2)
            , ap 'xor pair(e3, e4)
            )
          )
   => 
   return (ap 'xor pair(
              ap 'xor pair(e1, e3)
            , ap 'xor pair(e2, e4)
            )
          )
 .
 strat applyRearrangeXor : CNameBound @ ProtocolConfig .
 sd applyRearrangeXor(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyRearrangeXor(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{rearrange-xor}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{rearrange-xor}}
                      )
             )
 .
  rl [middle-xor] :
   return (ap 'xor pair(
              ap 'xor pair(e1, e2)
            , ap 'xor pair(e3, e4)
            )
          )
   => 
   return (ap 'xor pair( 
              ap 'xor pair(e1, ap 'xor pair(e2, e3))
            , e4
            )
          )
 .
 strat applyMiddleXor : CNameBound @ ProtocolConfig .
 sd applyMiddleXor(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyMiddleXor(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{middle-xor}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{middle-xor}}
                      )
             )
 .
  
 *** a derived rule, distributivity twice
 rl [derived-xor-and-rule] :
    return (
    ap 'xor 
       pair(
         ap 'xor pair(ap 'and pair(e1, e2), 
                      ap 'and pair(e3, e2)),
         ap 'xor pair(ap 'and pair(e4, e5), 
                      ap 'and pair(e4, e6))             
       ) 
    ) 
    =>
    return (
     ap 'xor 
        pair(
        ap 'and pair(ap 'xor pair(e1, e3), e2),
        ap 'and pair(e4, ap 'xor pair(e5, e6))
        )
    )    
 .   
  
 strat applyDerivedXorAndRule : CNameBound @ ProtocolConfig .
 sd applyDerivedXorAndRule(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDerivedXorAndRule(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{derived-xor-and-rule}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{derived-xor-and-rule}}
                      )
             )
 .        
  *** another derived rule based on assoc
 rl [derived-xor-rule] :
    return (
    ap 'xor 
       pair(
         ap 'xor pair(e1, 
                      ap 'xor pair(e2, e3)),
         e4           
       ) 
    ) 
    =>
    return (
     ap 'xor 
        pair(
        ap 'xor pair(e1, e2),
        ap 'xor pair(e3, e4)
        )
    )    
 .   
  
 strat applyDerivedXorRule : CNameBound @ ProtocolConfig .
 sd applyDerivedXorRule(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDerivedXorRule(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{derived-xor-rule}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{derived-xor-rule}}
                      )
             )
 . 
 rl [distrib-twice]:
 return (
   ap 'and pair(ap 'xor pair(e1, e2),
                ap 'xor pair(e3, e4)
               )
 )
 =>
 return (
  ap 'xor 
   pair(
     ap 'xor pair(ap 'and pair(e1, e3), ap 'and pair(e1, e4)),
     ap 'xor pair(ap 'and pair(e2, e3), ap 'and pair(e2, e4))
   )
 )
 .
 strat applyDistribTwice : CNameBound @ ProtocolConfig .
 sd applyDistribTwice(chn cn) :=
    match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{applyDistribTwice(chn cn)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (chn cn), 
                             P1:Protocol <- keepOne P (chn cn)]{
                             CONG-REACT[cn:ChannelName <- cn]{cong-nf{distrib-twice}}
                             }
              or-else (CONG-REACT[cn:ChannelName <- cn]{cong-nf{distrib-twice}}
                      )
             )
 . 
 
 ***************************
 *** more strategies that will be derived
 strat asym0 @ ProtocolConfig .
 sd asym0 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I])
        with
        nf('is : unit <- read ('InShare$-OK['m 'n 'i]),  return ())
        in P
       ] 
       {
         substNFFamiliesGen(
             fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I])
            )
       }         
 .  
  
 strat asym1 @ ProtocolConfig .
 sd asym1 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
        with
        nf(('s : unit <- read ('InShare$Sum-OK[N 'n 'i])) 
            'x : unit <- read ('In-OK['n 'i]), return () )
        in P
       ] 
       {
       substNFFamiliesGen(
             fam ('In-OK[bound (N + 2) dependentBound 'I]),
             fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
            )
       ;
       substNFFamiliesGen(
             fam ('InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I]),
             fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
            ) 
       }  
           
 . 
 strat asym2 @ ProtocolConfig .
 sd asym2 := 
  matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
       SYM[
       Delta1:ChannelContext <- Delta',
       O1:Set{CNameBound} <- O',
       P1:Protocol <- change 
        fam ('InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I])
        with
        (when (0 =T= 'm) -->
           nf('in : unit <- read ('InShare$-OK[0 'n 'i]), return () )
        )
        ;;
        (otherwise -->
           nf(('s : unit <- read ('InShare$Sum-OK[('m -- 1) 'n 'i])) 
               'x : unit <- read ('InShare$-OK['m 'n 'i]),
              return () ))
        in P']
  {
   CONG-NEW-NF{
   SINGLE-INDUCTION-new-R[
     idx:Qid <- 'M,
     q:Qid <- 'm,
     cn:ChannelName <- 'InShare$Sum-OK,
     blist:List{Bounds} <- bound (N + 1) bound (N + 2) dependentBound 'I,
     cases':Cases <- 
           nf('is : bool <- read ('InShare$-Sum['m 'n 'i]),  return ())
        
    ]{
    applyOtherwiseToNeg(
      fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
    )
  ; CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'InShare$Sum-OK,
           blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
           ]{
           *** for M = 0
           matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
         Q:Protocol  <- 
           removeTwo P 
            (fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])), 
         P1:Protocol <- 
           keepTwo P 
            (fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
          ]{
            select-case-subst-family-r[
            bt:BoolTerm <- neg ('m =T= N + 1)
           ]{ 
           substNFFamiliesGen(
             fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
             ) 
             
             }
             
             
         }      
            ,
            *** for neg M =T= 0
                  
            CASE-DISTINCTION-one-R-end-when[
         fns:NameWithScripts <- 'InShare$Sum-OK,
           blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
       ]{
            substNFFamiliesGen(
             fam ('InShare$Sum-OK[bound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
             ) 
            ;
           matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
         Q:Protocol  <- 
           removeTwo P 
            (fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])), 
         P1:Protocol <- 
           keepTwo P 
            (fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
          ]{
            select-case-subst-family-r[
            bt:BoolTerm <- neg ('m =T= N + 1)
           ]{substNFFamiliesGen(
             fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
             )}
             }  
           ; applyAlphaNFPr(
              fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
                 << 'is, 's >> emptyQidPairList)  
          }   
           
            
            } 
 ; asym3
    } 
  }  
}       
 . 
 strat asym3 @ ProtocolConfig .
 sd asym3 := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
             with 
              nf('is : bool <- read ('InShare$-Sum['M 'n 'i]),  return ())
             in P
            ]
     { matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
     SYM[Delta1:ChannelContext <- Delta', 
           O1:Set{CNameBound} <- O',
           P1:Protocol <- 
             change 
              (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
             with 
              ( when ('M =T= 0) --> 
              nf('is : bool <- read ('InShare$-Sum['M 'n 'i]),  return ())
              )
              ;;
              ( when (neg ('M =T= 0)) --> 
              nf('is : bool <- read ('InShare$-Sum['M 'n 'i]),  return ())
              )
             in P'
           ]{applyAllSameCases(fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))}  
           
     ; applyOtherwiseToNeg(fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]))         
          
     ; CASE-DISTINCTION-one-R[
   fns:NameWithScripts <- 'InShare$Sum-OK,
   blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
 ]{
 *** case M = 0
            asym4
           ; 
           applyDropSubsumeCase(
       fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
       fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]), 
       neg ('m =T= N + 1)) 
      
   ,
   *** otherwise
   CASE-DISTINCTION-one-R-end-when[
         fns:NameWithScripts <- 'InShare$Sum-OK,
           blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
       ]{
             asym5
           ; applyDropSubsumeCase(
       fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]), 
       fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]), 
       neg ('m =T= N + 1))    
          
   }         
 }
 ; applyNegToOtherwise(fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])) 
} 
. 
strat asym4 @ ProtocolConfig .
sd asym4 := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
         Q:Protocol  <- 
           removeTwo P 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])), 
         P1:Protocol <- 
           keepTwo P 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
          ]{
            select-case-subst-family-r[
            bt:BoolTerm <- ('m =T= 0)
           ]{ 
           substNFFamiliesGen(
             fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
             )
             
             }
             
           }
.
 
strat asym5 @ ProtocolConfig .
sd asym5 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
         Q:Protocol  <- 
           removeTwo P 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])), 
         P1:Protocol <- 
           keepTwo P 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])) 
            (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
          ]{
            select-case-subst-family-r[
            bt:BoolTerm <- neg ('m =T= 0)
           ]{ 
           substNFFamiliesGen(
             fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
             )
             
             }
           }
. 
  
strat asym01 @ ProtocolConfig .
 sd asym01 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I])
        with
        (when ('m =T= N + 1) -->
            nf(('s : unit <- read ('InShare$Sum-OK[N 'n 'i])) 
                'x : unit <- read ('In-OK['n 'i]), 
                 return () )
        )
        ;;
        (when (neg ('m =T= N + 1)) -->
            nf( 'x : unit <- read ('In-OK['n 'i]), return ())
        )
        in P
       ] 
    {
   
       applySubstFamilyGenCase(
  fam ('In-OK[bound (N + 2) dependentBound 'I]),
 fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]),
 (neg ('m =T= N + 1))
 ) 
       ; applyAlphaBranchCond(
           fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
           'in, 'x, 
           when (neg ('m =T= N + 1)))
 }
 . 
  strat indProofInitOK @ ProtocolConfig .
 sd indProofInitOK := 
   
  CONG-NEW-NF{
     SINGLE-INDUCTION-new[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'InitOK,
  blist:List{Bounds} <- bound (N + 2) bound (N + 2) dependentBound 'I,
  P2:Protocol <-
  
  (family 'InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return ())
)
||
(family 'InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 1) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return ())
)
||
family 'InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I] 'm 'n 'i
bound (N + 2) bound (N + 2) dependentBound 'I
::=
nf('x : unit <- read ('In-OK['n 'i]), return ())
  
  ]
  {applyDropName(fam ('InitOK[fixedBound 'M bound (N + 2) dependentBound 'I]))
   
   *** first  'InShare$-OK  
       ; CASE-DISTINCTION-one-R[
   fns:NameWithScripts <- 'InShare$-OK,
   blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
 ]{ *** M = N + 1
    substNFFamiliesGen(
             fam ('InShare$Sum-OK[bound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
             )
   , *** here we already have what we want
     idle
   } 
   ; applyAllSameCases(fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
   
   *** then 'InShareOK
   ; substNFFamiliesGen(
             fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShareOK[fixedBound 'M bound (N + 2) dependentBound 'I])
             )
   
   *** then  'InShare$Sum-OK 
   
   ; applyOtherwiseToNeg(fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
   
   ; CASE-DISTINCTION-one-R[
   fns:NameWithScripts <- 'InShare$Sum-OK,
   blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
 ]{ *** M = 0
    substNFFamiliesGen(
             fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
             )
            
   , CASE-DISTINCTION-one-R-end-when[
   fns:NameWithScripts <- 'InShare$Sum-OK,
   blist:List{Bounds} <- (fixedBound 'M bound (N + 2) dependentBound 'I)
   ]{
          substNFFamiliesGen(
             fam ('InShare$Sum-OK[bound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
             )
         ; substNFFamiliesGen(
             fam ('InShare$-OK[fixedBound 'M bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
             )    
   }          
     }
  ; applyAllSameCases(fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]))
        
  ; regroupInitOK 
  
  
  }  
  }
  . 
  
 strat regroupInitOK @ ProtocolConfig .
 sd regroupInitOK := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           (fam ('InShareOK[(bound 'M)(bound (N + 2))(dependentBound 'I)  ] ))
           (fam ('InShare$-OK[(bound 'M)(bound (N + 2))(dependentBound 'I)  ] ))
           (fam ('InShare$Sum-OK[(bound 'M)(bound (N + 2))(dependentBound 'I)  ] ))
         named 'InitOK 
         params ('m 'n 'i) (bound 'M (bound (N + 2))(dependentBound 'I))
         in P
       ]
       {
        applyDropName(
          fam ('InitOK[bound 'M (bound (N + 2))(dependentBound 'I)])
        )
       } ***sym   
      
 .  

 strat indWiresShares @ ProtocolConfig .
 sd indWiresShares := 
 CONG-NEW-NF{ 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
    CONG-COMP-RIGHT[
        Q:Protocol  <- 
         removeTwo P 
          (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I]))
          (fam ('Comp['Wires-OK 'SharesOK][bound K])), 
        P1:Protocol <- 
          keepTwo P 
           (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
           (fam ('Comp['Wires-OK 'SharesOK][bound K]))                      
        ]
        {
 matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
 SINGLE-INDUCTION-new[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- 'Comp['Wires-OK 'SharesOK],
  blist:List{Bounds} <- bound K,
  P2:Protocol <- want1
 ]{ setIndWiresShares
 }
 }      
 }
 .  
 
 op want1 : -> Protocol .
 eq want1 = 
 (family 'SharesOK[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
;;
(when (apply 'isAndGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return () )
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return () )
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('m <T 'n) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return () ))
;;
when ('n <=T 'm) -->
nf('rb : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'rb)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return () ))
;;
when ('m <=T 'n) -->
nf('sb : unit <- read ('SendBit-OK['n 'm 'k]), return 'sb)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
)
||
family 'Wires-OK[bound K] 'k
bound K
::=
family 'Wire-OK[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
nf('in : unit <- read ('In-OK[(fun 'wire0 'k) (fun 'wire1 'k)]), return 'in))
;;
(when (apply 'isNotGate 'k) -->
nf('w : unit <- read ('Wire-OK[fun 'wire0 'k]), return ()))
;;
(when (apply 'isXorGate 'k) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return () ))
;;
(when (apply 'isAndGate 'k) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return () )
)
.
 
 strat setIndWiresShares @ ProtocolConfig .
 sd setIndWiresShares :=
         applyDropName(fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I]))
        
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound 'B]),
           fam ('ShareOK[bound (N + 1) bound 'B]))  
       ; applyAllSameCases(fam ('ShareOK[bound (N + 1) bound 'B]))
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound 'B]),
           fam ('ShareOK[fixedBound (N + 1) bound 'B]) )  
       ; applyAllSameCases(fam ('ShareOK[fixedBound (N + 1) bound 'B]))
       
       
       ; applyUnsplitTop(
          fam ('ShareOK[bound (N + 1) bound 'B]), 
          fam ('ShareOK[fixedBound (N + 1) bound 'B])
       )
       
     
       ; CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for input gate
         substNFFamiliesGen(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              )
              
           
        ; symInput  
        
        *** now for the channel
        ; substNFFamilyOne(
            fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
                ('ShareOK[(N + 1) 'B])
          )   
                   
         ; symInputC           
               , 
               CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for not gate
              substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              )
         ; applyReturnUnit( fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]) )     
         ; wireSymNot
         
         ***  now the channel
         
         ; substNFFamilyOne(
            fam ('ShareOK[bound (N + 2) bound 'B]), 
                ('ShareOK[(N + 1) 'B])
           )
         ; applyReturnUnit( chn ('ShareOK[(N + 1) 'B]) ) 
         ; wireSymNotC
              ,
       CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for xor gate
       substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              )
       ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
       ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              ) 
       ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList)  
       ; wireSymXor    
       
        ***  now the channel
         
         ; substNFFamilyOne(
            fam ('ShareOK[bound (N + 2) bound 'B]), 
                ('ShareOK[(N + 1) 'B])
           )
         ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                     << 'w, 'w0 >> emptyQidPairList) 
       ; substNFFamilyOne(
            fam ('ShareOK[bound (N + 2) bound 'B]), 
                ('ShareOK[(N + 1) 'B])
           )
       ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]),
                     << 'w, 'w1 >> emptyQidPairList)   
         
        ; wireSymXorC
                            
       , CASE-DISTINCTION-one-end-when[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
          { *** for and gate
            *** SendBit-OK
             CASE-DISTINCTION-one-R[
          fns:NameWithScripts <- 'SendBit-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
          ]{ substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)])
              )
              ; applyAlphaNFPr(fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
       ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)])
              ) 
       ; applyAlphaNFPr(fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList)  , 
            *** here nothing to do
             idle}
           *** rename vars in SendBit-OK  
           ; alpha-family-three-top[
           fns:NameWithScripts <- 'SendBit-OK,
           bd3:Bounds <- fixedBound 'B,
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]  
          *** for RcvdBit we must first add two cases
          ; symRcvdBit
          *** then we can do case distinction
          ; CASE-DISTINCTION-one-R[
             fns:NameWithScripts <- 'RcvdBit-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{  *** here we do 5 substs
              select-case-family-r[
           fns1:NameWithScripts <- 'SendBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'm <T 'n]{
   substNFFamiliesGen(
     fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
   )           
           }
           
           ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
      )  
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
      ) 
      ; applyAlphaNFPr(fam ('RcvdBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
      )  
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
      ) 
      ; applyAlphaNFPr(fam ('RcvdBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList) 
           
           
            , *** here we diverge
            CASE-DISTINCTION-one-R-end-when[
             fns:NameWithScripts <- 'RcvdBit-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{
            select-case-family-r[
           fns1:NameWithScripts <- 'SendBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'n <=T 'm]{
   applySubstDivergeFamily(
     fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     'rb, unit)           
           }
           }
            
          }
          
          *** revert the alpha  
          ; alpha-family-three-top[
           fns:NameWithScripts <- 'SendBit-OK,
           bd3:Bounds <- fixedBound 'B,
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k]
           
           *** case dist for Ctrb-OK   
           ; CASE-DISTINCTION-one-R[
             fns:NameWithScripts <- 'Ctrb-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ select-case-family-r[
           fns1:NameWithScripts <- 'SendBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'n <T 'm]{
   substNFFamiliesGen(
     fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
     )           
           }, 
              CASE-DISTINCTION-one-R[
             fns:NameWithScripts <- 'Ctrb-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ select-case-family-r[
           fns1:NameWithScripts <- 'RcvdBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- ('m <T 'n)]{
   substNFFamiliesGen(
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
    )} , 
              CASE-DISTINCTION-one-R-end-when[
             fns:NameWithScripts <- 'Ctrb-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
      ) 
      ; applyAlphaNFPr(fam ('Ctrb-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
      ) 
      ; applyAlphaNFPr(fam ('Ctrb-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList)  
           
           
           }}}
      ; applyAllSameCases(fam ('Ctrb-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]))
      
      *** induction for CtrbSum-OK
      ; SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'CtrbSum-OK,
  blist:List{Bounds} <- bound (N + 2) bound (N + 2) fixedBound 'B,
  cases':Cases <- 
   nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 'w1 : unit <- read ('Wire-OK[
    fun 'wire1 'B]), return () )
 ]{
  CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'CtrbSum-OK,
           blist:List{Bounds} <- (bound (N + 2) fixedBound 'M fixedBound 'B)
           ]
           {
           *** for m = 0
           substNFFamiliesGen(
             fam ('Ctrb-OK[(bound (N + 2))(bound (N + 2))(fixedBound 'B)]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
            ),
            CASE-DISTINCTION-one-R-end-when[
           fns:NameWithScripts <- 'CtrbSum-OK,
           blist:List{Bounds} <- (bound (N + 2) fixedBound 'M fixedBound 'B)
           ]{
            substNFFamiliesGen(
             fam ('Ctrb-OK[(bound (N + 2))(bound (N + 2))(fixedBound 'B)]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
            ) 
            ; 
            substNFFamiliesGen(
             fam ('CtrbSum-OK[bound (N + 2) bound 'M fixedBound 'B]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
            )
            }
            
            }
  ; applyAllSameCases(fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]))         
  }
          *** and finally subst for ShareOK 
           
          ; substNFFamiliesGen(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('ShareOK[bound (N + 1) fixedBound 'B])
            ) 
           ; wireSymAnd 
           
          *** and the channel 
          ; substNFFamilyOne(
            fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                ('ShareOK[(N + 1) 'B])
           ) 
           
            ; wireSymAndC  
                      
          }
       }
       }
       }
     *** put back InitOK  
     ; sym6  
     
     *** then split ShareOK and put it back in SharesOK
     ; applySplit(fam ('ShareOK[bound (N + 2) bound 'B]))
     ; applyAddToGroupCases(
         fam ('ShareOK[bound (N + 1) bound 'B]),
         fam ('SharesOK[bound 'B])
         )
     ; applyAddToGroupCases(
         fam ('ShareOK[fixedBound (N + 1) bound 'B]),
         fam ('SharesOK[bound 'B])
         )    
 .  
 
 strat symInput @ ProtocolConfig .
 sd symInput :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w)
             in P
            ]
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isInputGate 'B)]{
                 
                 substChannelFamilyOne(
                   chn ('Wire-OK['B]), 
                   fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
                 )
                 ; applyReturnUnit( fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]) )
                 ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                     << 'in, 'x >> emptyQidPairList)    
                 }
             }
           }     
              
            .  
 strat symInputC @ ProtocolConfig .
 sd symInputC :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('ShareOK[(N + 1) 'B] )
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w)
             in P
            ]
            {
             use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isInputGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])
                 
                 
                 ; applyReturnUnit( chn ('ShareOK[(N + 1) 'B] ) )
                 ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B] ), 
                     << 'in, 'x >> emptyQidPairList)  
                       
                 }
             }
          }  
           
  .   
   strat wireSymNot @ ProtocolConfig .
 sd wireSymNot :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w)
             in P
            ]
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isNotGate 'B)]{
                 
                 substChannelFamilyOne(
                   chn ('Wire-OK['B]), 
                   fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
                 )}}
            }     
 .
 strat wireSymNotC @ ProtocolConfig .
 sd wireSymNotC :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('ShareOK[(N + 1) 'B])
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w)
             in P
            ]
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isNotGate 'B)]{
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])
                 }}
            }     
 .
  strat wireSymXor @ ProtocolConfig .
 sd wireSymXor :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w)
             in P
            ]
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isXorGate 'B)]{
                 
                 substChannelFamilyOne(
                   chn ('Wire-OK['B]), 
                   fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
                 )}}
            }  
 .
 strat wireSymXorC @ ProtocolConfig .
 sd wireSymXorC :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('ShareOK[(N + 1) 'B])
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w)
             in P
            ]
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isXorGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])
                 }}
            }  
 .
  strat wireSymAnd @ ProtocolConfig .
 sd wireSymAnd :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w)
             in P
            ]
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isAndGate 'B)]{
                 
                 substChannelFamilyOne(
                   chn ('Wire-OK['B]), 
                   fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
                 )}}
            }  
 .
 strat wireSymAndC @ ProtocolConfig .
 sd wireSymAndC :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('ShareOK[(N + 1) 'B])
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w)
             in P
            ]
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isAndGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])
                 }}
            }  
 .

  strat symRcvdBit @ ProtocolConfig .
 sd symRcvdBit :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
             with 
              (when ('m <T 'n) --> 
                nf(('sb : unit <- read ('SendBit-OK['m 'n 'B])) 
                   ('xm : unit <- read ('ShareOK['m (fun 'wire0 'B)]))
                   ('xn : unit <- read ('ShareOK['n (fun 'wire0 'B)])) 
                   ('ym : unit <- read ('ShareOK['m (fun 'wire1 'B)])) 
                    'yn : unit <- read ('ShareOK['n (fun 'wire1 'B)]), 
                     return () )
              ) ;;
              (when ('n <=T 'm) --> 
                nf(('sb : unit <- read ('SendBit-OK['m 'n 'B])) 
                   ('xm : unit <- read ('ShareOK['m (fun 'wire0 'B)]))
                   ('xn : unit <- read ('ShareOK['n (fun 'wire0 'B)])) 
                   ('ym : unit <- read ('ShareOK['m (fun 'wire1 'B)])) 
                    'yn : unit <- read ('ShareOK['n (fun 'wire1 'B)]), 
                     return () )
              )
             in P
            ]
            {applyAllSameCases(fam ('RcvdBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]) )
            }
            .

strat indSharesT1 @ ProtocolConfig .
 sd indSharesT1 := 
 CONG-NEW-NF{ 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 SINGLE-INDUCTION-new[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- ('Comp['HiddenGroup 'Shares]),
  blist:List{Bounds} <- bound K,
  P2:Protocol <- want2
 ]{ indSharesTiming1(Delta, P, O, A)
  }
     
 }
 .  
 op want2 : -> Protocol .
 eq want2 = 
(family 'HiddenGroup[bound K] 'k
bound K
::=
family 'Hidden[bound K] 'k
bound K
::=
return ()
)
||
 (
    family 'Shares[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)])) 
    'w : unit <- read ('Wire-OK['k]), 
      return 'in)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('w : unit <- read ('Wire-OK['k])) 
    'x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)]), 
    return (ap 'neg 'x))
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(
    'x, 'y)) )
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('w : unit <- read ('Wire-OK['k])) 
   ('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 
    'y : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), 
    return (ap 'xor  pair('x, 'y)))
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'and pair(
    'x, 'y)) ))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap 'xor pair('s, 'b)) )
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn : bool <- read (
    'Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn : bool <- read ('Share['n (fun
    'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm, 'yn), ap 'and pair('xn, 'ym)), 'b)) )
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]), samp ('flip < () >)))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k])) 
    'w : unit <- read ('Wire-OK['k]), return 'bs )
) 
.
strat indSharesTiming1
    : ChannelContext Protocol Set{CNameBound} Set{BoolTerm} 
  @ ProtocolConfig .
 sd indSharesTiming1(Delta, P, O, A) 
   :=
        applyDropName(fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)]))
      ; applyNewCombine(fam ('Ctrbs-OK[bound K]))
      
      ;  CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** input
          substNFFamilyOne(
             fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
             'Share[(N + 1) 'B]
             )
         ; symSharesInput   
             , 
          CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** not
          substNFFamilyOne(
             fam ('ShareOK[fixedBound (N + 1) bound K]), 
             'Share[(N + 1) 'B]
             )
          ; symSharesNot   
             ,
             
             CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** xor
             substNFFamilyOne(
             fam ('ShareOK[fixedBound (N + 1) bound K]), 
             'Share[(N + 1) 'B]
             )
             ; applyAlphaNFPr(chn ('Share[(N + 1) 'B]), 
                     << 'w, 'w0 >> emptyQidPairList)
             ; substNFFamilyOne(
             fam ('ShareOK[fixedBound (N + 1) bound K]), 
             'Share[(N + 1) 'B]
             )  
             ; applyAlphaNFPr(chn ('Share[(N + 1) 'B]), 
                     << 'w, 'w1 >> emptyQidPairList)       
             ; symSharesXor
             ,
             CASE-DISTINCTION-one-end-when[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** and
             substNFFamilyOne(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) bound K]), 
             'Share[(N + 1) 'B]
             )
            
             ; symSharesAnd
             }}
         }}
         
        ; *** undo structural operations by performing them on the expected result
       SYM[
       Delta1:ChannelContext <- 
        deltaInd
          (addInternalChannels Delta P)
          want2 'k 'B,
       O1:Set{CNameBound} <- 
        getOutputs(
          getInductionBase P ('Comp['HiddenGroup 'Shares]) 'k 'B A want2
        ),
       P1:Protocol <- getInductionEnd P ('Comp['HiddenGroup 'Shares]) 'k 'B A want2
       ] 
        { applyDropName(fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)]))
     ; applyNewCombine(fam ('Ctrbs-OK[bound K]))
     }
         
 .
 strat symSharesInput @ ProtocolConfig .
 sd symSharesInput := 
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('Share[(N + 1) 'B])
             with 
              nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'B) (fun 'wire1 'B)])) 
                  'w : unit <- read ('Wire-OK['B]), 
                  return 'in)
             in P
            ] 
            { applyAlphaNFPr(chn ('Share[(N + 1) 'B]), 
                     << 'in, 'is >> emptyQidPairList) 
           
            ; use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- bound K]{
                 substNFFamilyOne(
                 fam ('Wire-OK[bound K]), 
                 'Share[(N + 1) 'B]
                 )
                }
            ;  applyAlphaNFPr(chn ('Share[(N + 1) 'B]), 
                     << 'in, 'x >> << 'is, 'in >>
                      emptyQidPairList)  
            }             
 .
  strat symSharesNot @ ProtocolConfig .
 sd symSharesNot := 
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('Share[(N + 1) 'B])
             with 
             nf(('w : unit <- read ('Wire-OK['B])) 
                 'x : bool <- read ('Share[(N + 1) (fun 'wire0 'B)]), 
                return (ap 'neg 'x))
              
             in P
            ] 
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- bound K]{
                 substNFFamilyOne(
                 fam ('Wire-OK[bound K]), 
                 'Share[(N + 1) 'B]
                 )
                }
           }   
 .
  strat symSharesXor @ ProtocolConfig .
 sd symSharesXor := 
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('Share[(N + 1) 'B])
             with 
              nf(('w : unit <- read ('Wire-OK['B])) 
                 ('x : bool <- read ('Share[(N + 1) (fun 'wire0 'B)])) 
                  'y : bool <- read ('Share[(N + 1) (fun 'wire1 'B)]), 
                 return (ap 'xor pair('x, 'y)))
             in P
            ] 
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- bound K]{
                 substNFFamilyOne(
                 fam ('Wire-OK[bound K]), 
                 'Share[(N + 1) 'B]
                 )
                }
           }   
 .
  strat symSharesAnd @ ProtocolConfig .
 sd symSharesAnd := 
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('Share[(N + 1) 'B])
             with 
              nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'B])) 
                  'w : unit <- read ('Wire-OK['B]), return 'bs)
             in P
            ] 
            { use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- bound K]{
                 substNFFamilyOne(
                 fam ('Wire-OK[bound K]), 
                 'Share[(N + 1) 'B]
                 )
                }
           }   
 .

*** 10.4.5 timing 2
strat timing2 : ChannelContext Protocol 
                Set{CNameBound} Set{CNameBound} Set{BoolTerm} 
                @ ProtocolConfig .
sd timing2(Delta, P, I, O, A) :=
 SYM[
        Delta1:ChannelContext <- Delta,
        O1:Set{CNameBound} <- O,
        P1:Protocol <-
         branch 
          (when (apply 'isInputGate 'k ))
         of
          (fam ('Shares[bound K]))
         change
          (fam ('Share[fixedBound (N + 1) bound K]) )
         with
          nf( ('xs : bool <- read('ShareSum[N 'k]))
              'in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]), 
              return 'in)
          in 
          (
          branch 
          (when (apply 'isNotGate 'k ))
         of
          (fam ('Shares[bound K]))
         change
          (fam ('Share[fixedBound (N + 1) bound K]) )
         with
          nf(('xs : bool <- read('ShareSum[N 'k]))
             'x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)]), 
             return (ap 'neg 'x) )
          in 
          (
          branch 
          (when (apply 'isXorGate 'k ))
         of
          (fam ('Shares[bound K]))
         change
          (fam ('Share[fixedBound (N + 1) bound K]) )
         with
          nf(('xs : bool <- read('ShareSum[N 'k]))
             ('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 
              'y : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), 
              return (ap 'xor pair('x, 'y)))
          in 
          (branch 
          (when (apply 'isAndGate 'k ))
         of
          (fam ('Shares[bound K]))
         change
          (fam ('Share[fixedBound (N + 1) bound K]) )
         with
          nf(('xs : bool <- read('ShareSum[N 'k]))
             'bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k]), 
             return 'bs )
          in 
          (branch 
          (when (apply 'isAndGate 'k ))
         of
          (fam ('Adv[bound K]))
         change
          (fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]) )
         with
          (when ('n <T N + 1) -->
nf('x : bool <- read ('ShareSum[N (fun 'wire1 'k)]), return ()))
;;
(when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc)
)
          in
          (
          branch 
          (when (apply 'isAndGate 'k ))
         of
          (fam ('Adv[bound K]))
         change
          (fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]) )
         with
          (when ('n <T N + 1) -->
nf('x : bool <- read ('ShareSum[N (fun 'wire0 'k)]), return ()))
;;
(when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc)
)
          in
          P
          ))
          )
          )
          )
         ]  
     {   *** start of sym proof
         
      *** introduce InShare-OK, ShareOK  
        sym3 
      
      *** introduce ShareSum-OK  
      ; introShareSumOK
      
      *** use ShareSum-OK in Adv
      ; sym20
      
      *** turn dependency on sum shares to dependency on corresponding timing channel
      
      ; timingShares
        
      *** we introduce 'In-OK
      ; sym9
      
      *** and 'Wires-OK
      ; sym10
      
      *** add internal channels   
      ; sym5
      
      *** introduce InitOK
      ; sym6 
      
      *** introduce SharesOK
      ; sym7 
      
   
      *** rewrite ShareSum-OK      
      
      ; indShareSum-OK
       *** we split 'ShareOK
      ; applySplitInsideGroup(fam ('SharesOK[bound K]), 
           fam ('ShareOK[bound (N + 2) bound K]))
      
         
      *** then we group Shares with SharesOK
      ; applyGroupFamiliesNew(fam ('Shares[bound K]), fam ('SharesOK[bound K]))
      
      *** and we do the big induction for SharesOK
      ; changeComp'
      
      *** then we ungroup Shares with SharesOK
      ; applyUngroupFamiliesNew(fam ('Shares[bound K]), fam ('SharesOK[bound K]))
      
      *** this part repeated from timing 1
      
       ; applyDropName(
         fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)])
        )
      
       
      ; alpha-family-three[fns:NameWithScripts <- 'InShare,
     q4:Qid <- 'm,
     q5:Qid <- 'n,
     q6:Qid <- 'i
      ]   
      ; substNFFamiliesGen(
             fam ('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I])
            ) 
      ; applyAlphaNFPr(fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
                 << 'in, 'is >> emptyQidPairList)         
      ; alpha-family-three[fns:NameWithScripts <- 'InShare,
     q4:Qid <- 'n,
     q5:Qid <- 'm,
     q6:Qid <- 'i
      ]  
      ; asym0   
       
      *** first we split
      
      ; applySplitFst(fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]))
      
      *** for up to N + 1 in 'InShare$-OK
      ; applyOtherwiseToNeg(fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]))
      ; applyDropSubsumeFromBranchP(
         fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]), 
         fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]), 
         neg ('m =T= N + 1)
        )
        
        
     
      *** for N + 1 in 'InShare$-OK 
      ; substNFFamiliesGen(
             fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
        )
      ; applyAlphaNFPr(fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I]), 
                 << 's, 'is >> << 'x, 'in >> emptyQidPairList)   
      ; asym1 
      ; applyUnsplitFstNewNF(
      fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]),
      fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
     )  
  
       *** for 'InShare$Sum-OK we need an induction proof
       
       ; asym2
     
       *** and now we can deal with the missing bit on 'InShare$-OK
        *** ; applySplitFst(fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I]))
       ; asym01  
       
      
      
      *** here we put back InitOK
      ; sym6 
      
      *** we can furthermore make all channels from InitOK read In-OK 
      
      ; indProofInitOK
      
      *** here ends the repeated proofs for InitOK
      
      *** we move ShareSum-OK in SharesOK
      ; applyAddToGroupCases(
         fam ('ShareSum-OK[bound (N + 1) bound K]), fam ('SharesOK[bound K])
        )
        
      *** here we introduce Ctrbs-OK by induction   
      
      *** we can group Wires-OK and SharesOK
      ; applyGroupFamiliesNew(fam ('Wires-OK[bound K]), fam ('SharesOK[bound K]))
      
      *** before set the induction up and test things
      ; indWiresShares'
      
      *** now we ungroup
      
      ; applyUngroupFamiliesNew(fam ('Wires-OK[bound K]), fam ('SharesOK[bound K]))
      
      *** we need to take out ShareOK
      
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound K]),
           fam ('ShareOK[bound (N + 1) bound K]))  
       ; applyAllSameCases(fam ('ShareOK[bound (N + 1) bound K]))
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound K]),
           fam ('ShareOK[fixedBound (N + 1) bound K]) )  
       ; applyAllSameCases(fam ('ShareOK[fixedBound (N + 1) bound K]))
       
       *** then ShareSum-OK
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound K]),
           fam ('ShareSum-OK[bound (N + 1) bound K]))  
       ; applyAllSameCases(fam ('ShareSum-OK[bound (N + 1) bound K]))       
       *** and rename SharesOK to Ctrbs-Ok
       
       ; applyRenameGroup(fam ('SharesOK[bound K]), 'Ctrbs-OK)  
      
      *** now we do some substs in Adv
       
       ; select-branch-family-p[
          fns:NameWithScripts <- 'Adv,
          bt:BoolTerm <- apply 'isAndGate 'k
         ]{ 
          CONG-NEW-NF{
          select-branch-family-r[
          fns:NameWithScripts <- 'OTChcRcvd-0 ^^ 'ot .. 'adv,
          blist:List{Bounds} <- bound (N + 2) fixedBound (N + 1) bound K,
          bt:BoolTerm <- 'n <T N + 1 
          ]
          { 
            substNFFamiliesGen(
             fam ('ShareSum-OK[(bound (N + 1)) (bound K)] ),
             fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
            )
          }
          ; 
          select-branch-family-r[
          fns:NameWithScripts <- 'OTChcRcvd-1 ^^ 'ot .. 'adv,
          blist:List{Bounds} <- bound (N + 2) fixedBound (N + 1) bound K,
          bt:BoolTerm <- 'n <T N + 1 
          ]
          { 
            substNFFamiliesGen(
             fam ('ShareSum-OK[(bound (N + 1)) (bound K)] ),
             fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
            )
          }
          }
         }   
         
      *** now induction for Shares
      
      *** group with a new dummy group
      
      ; addHidden
      ; addHiddenGroup
      
      ; applyGroupFamiliesNew(fam ('HiddenGroup[bound K]), fam ('Shares[bound K]))   
      
      *** ; indSharesTiming2
      ; indSharesT2
         
           
      ; applyUngroupFamiliesNew(fam ('HiddenGroup[bound K]), fam ('Shares[bound K]))
      ; applyDropName(fam ('HiddenGroup[bound K]) )
      ; absorbFamilyDeleteEmpty( fam ('Hidden[bound K]) )
      
      ; absorbFamily(fam ('ShareSum-OK[bound (N + 1) bound K]))
          
    *** end of timing2
 }
.

strat introShareSumOK @ ProtocolConfig .
 sd introShareSumOK := 
    
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'ShareSum-OK
         typed unit
         params ('m 'k )
                ((bound (N + 1))(bound K))  
         assigned
          nf('s : bool  <- read ('ShareSum['m 'k]),
              return ())
         in P  
       ]{
          absorbFamily(
           fam ( 'ShareSum-OK[((bound (N + 1))(bound K))] )
          )
        } ***sym
       )
       .
       
  strat sym20 @ ProtocolConfig .
  sd sym20 :=
      matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
        Delta1:ChannelContext <- Delta,
        O1:Set{CNameBound} <- O,
        P1:Protocol <-
              
         branch 
          (when (apply 'isAndGate 'k ))
         of
          (fam ('Adv[bound K]))
         change
          (fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]) )
         with
          (when ('n <T N + 1) -->
nf('x : unit <- read ('ShareSum-OK[N (fun 'wire1 'k)]), return ()))
;;
(when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-1 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc)
)
          in
          (
          branch 
          (when (apply 'isAndGate 'k ))
         of
          (fam ('Adv[bound K]))
         change
          (fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]) )
         with
          (when ('n <T N + 1) -->
nf('x : unit <- read ('ShareSum-OK[N (fun 'wire0 'k)]), return ()))
;;
(when ('n =T= N + 1) -->
nf('oc : unit <- read (('OTChcRcvd-0 ^^ 'ot .. 'adv)['n (N + 1) 'k]), return 'oc)
)
          in
          P
          )
         ]
       {
         select-branch-family-p[
            fns:NameWithScripts <- 'Adv,
            bt:BoolTerm <- apply 'isAndGate 'k
         ]{
         
         CONG-NEW-NF{
          
           select-branch-family-r[
           fns:NameWithScripts <- ('OTChcRcvd-1 ^^ 'ot .. 'adv),
           blist:List{Bounds} <- bound (N + 2) fixedBound (N + 1) bound K,
           bt:BoolTerm <- ('n <T N + 1)
          ]{
          
           
           substNFFamiliesGen(
                 fam ('ShareSum-OK[bound (N + 1) bound K]), 
                 fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
                 )
           ; 
           applyAlphaNFPr(
            fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]), 
            << 's, 'x >> emptyQidPairList)       
                          
          
         }
         
         ;
         
         select-branch-family-r[
           fns:NameWithScripts <- ('OTChcRcvd-0 ^^ 'ot .. 'adv),
           blist:List{Bounds} <- bound (N + 2) fixedBound (N + 1) bound K,
           bt:BoolTerm <- ('n <T N + 1)
          ]{
          
           
           substNFFamiliesGen(
                 fam ('ShareSum-OK[bound (N + 1) bound K]), 
                 fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
                 )
           ; 
           applyAlphaNFPr(
            fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K]), 
            << 's, 'x >> emptyQidPairList)       
                          
          
         }
         
         }
         
         }
         
    }     
   .      
strat timingShares @ ProtocolConfig .
 sd timingShares := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         change 
           (fam ('Shares[bound K]))
        
    with
    (when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)])) 'xs : unit <- read (
    'ShareSum-OK[N 'k]), return 'in)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 'xs : unit <- read ('ShareSum-OK[N 'k]),
    return (ap 'neg 'x) )
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)) )
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) ('xs : unit <- read ('ShareSum-OK[N 'k])) 'y :
    bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), return (ap 'xor pair('x, 'y)) )
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)) ))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)) )
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)) )
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >) ))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k])) 'xs : unit <- read ('ShareSum-OK[N 'k]), return
    'bs )
    in P]
{
   
   select-branch-family-p[
    fns:NameWithScripts <- 'Shares,
    bt:BoolTerm <- apply 'isInputGate 'k
   ]
   {
     substNFFamiliesGen(
                 fam ('ShareSum-OK[bound (N + 1) bound K]), 
                 fam ('Share[fixedBound (N + 1) bound K])
                 )
     ; 
           applyAlphaNFPr(
            fam ('Share[fixedBound (N + 1) bound K]), 
            << 's, 'xs >> emptyQidPairList)                
   }
   ;
   select-branch-family-p[
    fns:NameWithScripts <- 'Shares,
    bt:BoolTerm <- apply 'isNotGate 'k
   ]
   {
     substNFFamiliesGen(
                 fam ('ShareSum-OK[bound (N + 1) bound K]), 
                 fam ('Share[fixedBound (N + 1) bound K])
                 )
     ; 
           applyAlphaNFPr(
            fam ('Share[fixedBound (N + 1) bound K]), 
            << 's, 'xs >> emptyQidPairList)                
   }
   ;
   select-branch-family-p[
    fns:NameWithScripts <- 'Shares,
    bt:BoolTerm <- apply 'isXorGate 'k
   ]
   {
     substNFFamiliesGen(
                 fam ('ShareSum-OK[bound (N + 1) bound K]), 
                 fam ('Share[fixedBound (N + 1) bound K])
                 )
     ; 
           applyAlphaNFPr(
            fam ('Share[fixedBound (N + 1) bound K]), 
            << 's, 'xs >> emptyQidPairList)                
   }
   ;
   select-branch-family-p[
    fns:NameWithScripts <- 'Shares,
    bt:BoolTerm <- apply 'isAndGate 'k
   ]
   {
     substNFFamiliesGen(
                 fam ('ShareSum-OK[bound (N + 1) bound K]), 
                 fam ('Share[fixedBound (N + 1) bound K])
                 )
     ; 
           applyAlphaNFPr(
            fam ('Share[fixedBound (N + 1) bound K]), 
            << 's, 'xs >> emptyQidPairList)                
   }
}   
 .
strat indShareSum-OK @ ProtocolConfig .
 sd indShareSum-OK :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change
          fam ('ShareSum-OK[bound (N + 1) bound K])
         with
          (when ('m =T= 0) -->
    nf('s : unit <- read ('ShareOK[0 'k]),  return ()))
;;
(when (neg ('m =T= 0)) -->
   nf(
        ('ss : unit <- read ('ShareSum-OK[('m -- 1) 'k]))
        ('s : unit <- read ('ShareOK['m 'k])),
        return ()
   )   
)
          in
          P
       ] 
      {
       
       CONG-NEW-NF{
       
        SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'ShareSum-OK,
  blist:List{Bounds} <- bound (N + 1) bound K,
  cases':Cases <- 
   nf('s : bool <- read ('ShareSum['m 'k]),  return ())
  ]     
       {       
       CASE-DISTINCTION-one-R[
        fns:NameWithScripts <- 'ShareSum-OK
       ]{
        *** for m = 0
        
        use-family-p[fns:NameWithScripts <- 'SharesOK]{
        
        substNFFamiliesGen(
                 fam ('ShareOK[bound (N + 2) bound K]), 
                 fam ('ShareSum-OK[fixedBound 'M bound K])
                 )
        ; symShareSumOK0
        }
        ,
        *** for m /= 0
        CASE-DISTINCTION-one-R-end-when[
        fns:NameWithScripts <- 'ShareSum-OK
       ]{
        use-family-p[fns:NameWithScripts <- 'SharesOK]{
        
        
        substNFFamiliesGen(
                 fam ('ShareOK[bound (N + 2) bound K]), 
                 fam ('ShareSum-OK[fixedBound 'M bound K])
                 )
       
       }
       
       ; 
        substNFFamiliesGen(
                 fam ('ShareSum-OK[bound 'M bound K]), 
                 fam ('ShareSum-OK[fixedBound 'M bound K])
                 )  
       ; symShareSumOKM                 
        }
       }
       ; applyAllSameCases( fam ('ShareSum-OK[fixedBound 'M bound K]) )
}       
}
}  
 .   
 strat symShareSumOK0 @ ProtocolConfig .
 sd symShareSumOK0 := 
      matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change 
         fam ('ShareSum-OK[fixedBound 'M bound K])
        with
         nf('s : bool <- read ('ShareSum['M 'k]),  return ())
        in 
        P
       ] 
       { subst1
       ; applyAlphaNFPr(
            fam ('ShareSum-OK[fixedBound 'M bound K]), 
            << 's, 'x >> emptyQidPairList)                
       }     
       
             
 .
 strat subst1 @ ProtocolConfig .
 sd subst1 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P (fam ('ShareSum[bound (N + 2) bound K])) 
                  (fam ('ShareSum-OK[fixedBound 'M bound K])), 
                 P1:Protocol <- keepTwo P (fam ('ShareSum[bound (N + 2) bound K])) 
                  (fam ('ShareSum-OK[fixedBound 'M bound K]))
                ]
              {
                select-case-subst-family-r[
           fns1:NameWithScripts <- 'ShareSum,
           fns2:NameWithScripts <- 'ShareSum-OK,
           bt:BoolTerm <- 0 =T= 'm
          ]{ 
            substNFFamiliesGen(
                 fam ('ShareSum[bound (N + 2) bound K]), 
                 fam ('ShareSum-OK[fixedBound 'M bound K])
                 )
            
           }
              }
       )       
 . 
 ***
 strat symShareSumOKM @ ProtocolConfig .
 sd symShareSumOKM := 
      matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change 
         fam ('ShareSum-OK[fixedBound 'M bound K])
        with
         nf('s : bool <- read ('ShareSum['M 'k]),  return ())
        in 
        P
       ] 
       { subst2
       ; applyAlphaNFPr(
            fam ('ShareSum-OK[fixedBound 'M bound K]), 
            << 'xm, 'x >> << 'xs, 's >>  emptyQidPairList)                
       }     
       
             
 .
 strat subst2 @ ProtocolConfig .
 sd subst2 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P (fam ('ShareSum[bound (N + 2) bound K])) 
                  (fam ('ShareSum-OK[fixedBound 'M bound K])), 
                 P1:Protocol <- keepTwo P (fam ('ShareSum[bound (N + 2) bound K])) 
                  (fam ('ShareSum-OK[fixedBound 'M bound K]))
                ]
              {
                select-case-subst-family-r[
           fns1:NameWithScripts <- 'ShareSum,
           fns2:NameWithScripts <- 'ShareSum-OK,
           bt:BoolTerm <- neg (0 =T= 'm)
          ]{ 
            substNFFamiliesGen(
                 fam ('ShareSum[bound (N + 2) bound K]), 
                 fam ('ShareSum-OK[fixedBound 'M bound K])
                 )
            
           }
              }
       )       
 . 
  strat changeComp' @ ProtocolConfig .
 sd changeComp' :=
 *** sym proof for 'SharesOK
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf 
            by pConf 
            using 
            SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change (fam ('SharesOK[bound K]))
             with 
              cases0'
             in P
            ]
         {  CONG-NEW-NF{ 
 matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
 SINGLE-INDUCTION-new[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- 'Comp['Shares 'SharesOK],
  blist:List{Bounds} <- bound K,
  P2:Protocol <- know0'
 ]{ setIndConfSymProof'(Delta', P', I', O', A')
 } 
     
 }
 }
 .
  *** induction in timing 2
 op know0' : -> Protocol .
 eq know0' = 
(family 'Shares[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)])) 'xs : unit <- read (
    'ShareSum-OK[N 'k]), return 'in)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 'xs : unit <- read ('ShareSum-OK[N 'k]),
    return (ap 'neg 'x) )
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)) )
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) ('xs : unit <- read ('ShareSum-OK[N 'k]))
    'y : bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), return (ap 'xor pair('x, 'y)) )
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)) ))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)) )
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)) )
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >) ))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs)
)
||
family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k])) 'xs : unit <- read ('ShareSum-OK[N 'k]),
    return 'bs )
)
||
family 'SharesOK[bound K] 'k
bound K
::=
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : bool <- read ('Ctrb['n 'm 'k]),  return ())
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : bool <- read ('CtrbSum['n 'm 'k]),  return ())
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : bool <- read ('RcvdBit['n 'm 'k]),  return ())
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : bool <- read ('SendBit['n 'm 'k]),  return ())
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('x : bool <- read ('Share['n 'k]), return ())
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('x : bool <- read ('Share[(N + 1) 'k]), return ())
 .
 op cases0' : -> Cases .
 eq cases0' =
   (when (apply 'isInputGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's)
)
||
(
family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('i : unit <- read ('InShareOK['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'i)
)
||
(
family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf( ('i : unit <- read ('InShareOK[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)]) )
    ('ss : unit <- read ('ShareSum-OK[N 'k])),  return 'i)
)
) *** end when input gate
;;
(when (apply 'isNotGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's)
)
||
(
family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('x : unit <- read ('ShareOK['n (fun 'wire0 'k)]), return 'x)
)
||
(
family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf( ('x : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)]))
    ('ss : unit <- read ('ShareSum-OK[N 'k])) ,  return 'x)
)
) *** end when not gate
;;
(when (apply 'isXorGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c)
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r)
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's)
)
||
(
family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 
    'y : unit <- read ('ShareOK['n (fun 'wire1 'k)]), 
    return ()
    )
)
||
(
family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf( ('ss : unit <- read ('ShareSum-OK[N 'k])) 
   ('x : unit <- read ('ShareOK[(N + 1) (fun 'wire0 'k)])) 
    'y : unit <- read ('ShareOK[(N + 1) (fun 'wire1 'k)]), 
     return ())
)
) *** end when xor gate
;;
(when (apply 'isAndGate 'k) -->
(family ('Ctrb-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) -->
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's))
;;
(when ('m <T 'n) -->
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r))
;;
when ('m =T= 'n) -->
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 'y : unit <- read ('ShareOK['n (fun 'wire1
    'k)]), return () )
)
||
(family ('CtrbSum-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when (0 =T= 'm) -->
nf('c : unit <- read ('Ctrb-OK['n 0 'k]), return 'c))
;;
(when (neg (0 =T= 'm)) -->
nf(('x : unit <- read ('CtrbSum-OK['n ('m -- 1) 'k])) 
    'y : unit <- read ('Ctrb-OK['n 'm 'k]), 
     return () )
)
)
||
(family ('RcvdBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
nf(('sb : unit <- read ('SendBit-OK['m 'n 'k])) 
   ('xm : unit <- read ('ShareOK['m (fun 'wire0 'k)]))
   ('xn : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 
   ('ym : unit <- read ('ShareOK['m (fun 'wire1 'k)])) 
    'yn : unit <- read ('ShareOK['n (fun 'wire1 'k)]), 
     return ())
)
||
(family ('SendBit-OK[((bound (N + 2))(bound (N + 2))(bound K))]) ('n 'm 'k)
((bound (N + 2))(bound (N + 2))(bound K))
::=
(when ('n <T 'm) -->
nf(('x : unit <- read ('ShareOK['n (fun 'wire0 'k)])) 
    'y : unit <- read ('ShareOK['n (fun 'wire1 'k)]), 
    return ()
   )
)
;;
(when ('m <=T 'n) -->
nf('sb : unit <- read ('SendBit-OK['n 'm 'k]), return 'sb)
)
)
||
(family ('ShareOK[(bound (N + 1)) (bound K)]) ('n 'k)
((bound (N + 1)) (bound K))
::=
nf('c : unit <- read ('CtrbSum-OK['n (N + 1) 'k]), return 'c)
)
||
(family ('ShareOK[(fixedBound (N + 1)) (bound K)]) ('n 'k)
((fixedBound (N + 1)) (bound K))
::=
nf( ('c : unit <- read ('CtrbSum-OK[(N + 1) (N + 1) 'k]))
      ('ss : unit <- read ('ShareSum-OK[N 'k])), return 'c )
)
) *** end when and gate
. 
 strat setIndConfSymProof' : 
       ChannelContext Protocol Set{CNameBound} Set{CNameBound} Set{BoolTerm} @ ProtocolConfig .
 sd setIndConfSymProof'(Delta, P, I, O, A) := 
   
   (
    
       *** ind proof starts here
        applyDropName(
         fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)])
        )
       ; CASE-DISTINCTION-one[
        fns:NameWithScripts <- 'SharesOK,
        blist:List{Bounds} <- fixedBound 'B
       ]{
       *** for input gate
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isInputGate 'B
           ]
           { 
           symSubstDiverge(
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)
          ; symSubstDiverge(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)   
          ; symSubstDiverge(
             fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'r, 'r) 
          ; symSubstDiverge(
             fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 's, 's)   
           *** for the family
       ; alpha-family-two-top[fns:NameWithScripts <- 'ShareOK,
          bd1:Bounds <- (bound (N + 1)),
          bd2:Bounds <- (fixedBound 'B),
          q3:Qid <- 'x,
          q4:Qid <- 'y
         ]
       ; substNFFamiliesGen(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              ) 
       ; alpha-family-two-top[fns:NameWithScripts <- 'ShareOK,
          bd1:Bounds <- (bound (N + 1)),
          bd2:Bounds <- (fixedBound 'B),
          q3:Qid <- 'n,
          q4:Qid <- 'k
         ]  
       ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 'is, 'in >> emptyQidPairList)
        *** and the sym proof for the family 'Share[bound (N + 1) fixedBound 'B]
       ; inIndSym2    
       
           
           }
           *** for the channel
       ; substNFFamilyOne(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              'ShareOK[(N + 1) 'B]
              )
       ; iSymInput
       
       , CASE-DISTINCTION-one[
        fns:NameWithScripts <- 'SharesOK,
        blist:List{Bounds} <- fixedBound 'B
       ]{
       *** for not gate
       
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isNotGate 'B
           ]
           { symSubstDiverge(
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)
          ; symSubstDiverge(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)   
          ; symSubstDiverge(
             fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'r, 'r) 
          ; symSubstDiverge(
             fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 's, 's)   
            *** now the family
           ; applyReturnUnit(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]))  
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              ) 
           } 
           ; inIndSym4
          } 
       ;
       use-family-p[
         fns1:NameWithScripts <- 'SharesOK,
         blist1:List{Bounds} <- bound 'B,
         bt:BoolTerm <- apply 'isNotGate 'B
       ]{
       substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B]
              )
       }
       ; iSymNot
       ,
        CASE-DISTINCTION-one[
        fns:NameWithScripts <- 'SharesOK,
        blist:List{Bounds} <- fixedBound 'B
       ]{
       *** for xor gate
       select-case-family-p[
           fns1:NameWithScripts <- 'Shares,
           blist1:List{Bounds} <- fixedBound 'B,
           bt:BoolTerm <- apply 'isXorGate 'B
           ]
           { 
           symSubstDiverge(
             fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)
          ; symSubstDiverge(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'c, 'c)   
          ; symSubstDiverge(
             fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 'r, 'r) 
          ; symSubstDiverge(
             fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
             fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]),  
             ('n 'm 'B), 's, 's)   
          
          
           *** now the family
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              ) 
              ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 'x, 'a >> emptyQidPairList)
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              )  
              ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)   
           } 
           ; inIndSym6
           
           }
       ;
       use-family-p[
         fns1:NameWithScripts <- 'SharesOK,
         blist1:List{Bounds} <- bound 'B,
         bt:BoolTerm <- apply 'isXorGate 'B
       ]{
       substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B]
              )
       ; applyAlphaNFPr(
            chn ('ShareOK[(N + 1) 'B]), 
            << 'x, 'x0 >>  emptyQidPairList) 
                   
       ; substNFFamilyOne(
              fam ('ShareOK[fixedBound (N + 1) bound 'B]),
              'ShareOK[(N + 1) 'B]
              )     
       ; applyAlphaNFPr(
            chn ('ShareOK[(N + 1) 'B]), 
            << 'x, 'x1 >>  emptyQidPairList)        
       ; iSymXor     
       },
         CASE-DISTINCTION-one-end-when[
        fns:NameWithScripts <- 'SharesOK,
        blist:List{Bounds} <- fixedBound 'B
       ]{ *** for and gate
       
           CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'SendBit-OK,
           blist:List{Bounds} <-(bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )
              ; applyAlphaNFPr(fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList)
                 ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )
              ; applyAlphaNFPr(fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)  
           }, 
             idle}
           ; inIndSym7  
          
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           { 
             substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList)
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )  
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'yn >> << 'a, 'xn >> emptyQidPairList) 
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList)
              ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 1) bound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )  
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'ym >> << 'a, 'xm >> emptyQidPairList) 
              ; alpha-family-three-top[fns:NameWithScripts <- 'SendBit-OK,
              bd3:Bounds <- fixedBound 'B,
     q4:Qid <- 'x,
     q5:Qid <- 'y,
     q6:Qid <- 'z
      ]   
              ; substNFFamiliesGen(
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )
              ; alpha-family-three-top[fns:NameWithScripts <- 'SendBit-OK,
              bd3:Bounds <- fixedBound 'B,
     q4:Qid <- 'n,
     q5:Qid <- 'm,
     q6:Qid <- 'k
      ]   
              ; applyAlphaNFPr(fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 's, 'b >> emptyQidPairList)      
              
           }
           ; inIndSym8
           
           ; select-branch-family-r[
             fns:NameWithScripts <- 'Ctrb-OK,
             blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
             bt:BoolTerm <- 'n <T 'm 
           ]{substNFFamiliesGen(
              fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )}
              
           ; select-branch-family-r[
             fns:NameWithScripts <- 'Ctrb-OK,
             blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
             bt:BoolTerm <- 'm <T 'n 
           ]{substNFFamiliesGen(
              fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )}   
              
           *** we need to unsplit 'ShareOK on bound 'B
           
           *** TRACE HERE
           
           ; applyUnsplitGroup(fam ('SharesOK[bound 'B]), 
               fam ('ShareOK[bound (N + 1) bound 'B]), 
               fam ('ShareOK[fixedBound (N + 1) bound 'B])
             ) 
           
           ; use-family-p[
           fns1:NameWithScripts <- 'SharesOK,
           blist1:List{Bounds} <- bound 'B
           ]
           {   
             select-branch-family-r[
             fns:NameWithScripts <- 'Ctrb-OK,
             blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
             bt:BoolTerm <- 'm =T= 'n 
           ]{substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )
             ; applyAlphaNFPr(fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'a >> emptyQidPairList) 
             ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
              )
             ; applyAlphaNFPr(fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                 << 'x, 'y >> << 'a, 'x >> emptyQidPairList)      
              }   
           }
            
           ; applySplitInsideGroup(fam ('SharesOK[bound 'B]), 
               fam ('ShareOK[bound (N + 2) bound 'B])
             )   
                       
           *** now the sym proof
           
           ; inIndSym9
            
           *** for CtrbSum-OK we must do induction
           ; inIndSym10 
           
           *** for ShareOK, first the family
           ; substNFFamiliesGen(
              fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              fam ('ShareOK[bound (N + 1) fixedBound 'B])
             )  
           
           ; inIndSym11  
           *** now the channel
           ; substNFFamilyOne(
              fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
              'ShareOK[(N + 1) 'B]
             )
           ; iSymAnd
         }}
       }}
   ; applyAllSameCases(fam ('SharesOK[fixedBound 'B]))    
   ;
    SYM[
       Delta1:ChannelContext <- getInductionDelta
          (addInternalChannels Delta P)
          know0' 'k 'B,
       O1:Set{CNameBound} <-
         getOutputs(getInductionBase P ('Comp['Shares 'SharesOK]) 
                      'k 'B A know0'),
       P1:Protocol <- getInductionEnd 
                      P 
                      ('Comp['Shares 'SharesOK]) 
                      'k 'B A know0'
       ]   
     {
     applyDropName(
         fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)])
        )
     }
)
 .
 strat iSymInput @ ProtocolConfig .
 sd iSymInput :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         change 
          chn ('ShareOK[(N + 1) 'B])
         with
          nf('x : bool <- read ('Share[(N + 1) 'B]), return ())
         in P
       ] 
       {
       select-case-family-p[
         fns1:NameWithScripts <- 'Shares,
         blist1:List{Bounds} <- fixedBound 'B,
         bt:BoolTerm <- apply 'isInputGate 'B
       ]{substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B])}
       ; applyAlphaNFPr(
            chn ('ShareOK[(N + 1) 'B]), 
            << 'in, 'is >> << 'xs, 'ss >>  emptyQidPairList) 
            }
  .     
 strat iSymNot @ ProtocolConfig .
 sd iSymNot :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         change 
          chn ('ShareOK[(N + 1) 'B])
         with
          nf('x : bool <- read ('Share[(N + 1) 'B]), return ())
         in P
       ] 
       {
       select-case-family-p[
         fns1:NameWithScripts <- 'Shares,
         blist1:List{Bounds} <- fixedBound 'B,
         bt:BoolTerm <- apply 'isNotGate 'B
       ]{substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B])}
        ; applyAlphaNFPr(
            chn ('ShareOK[(N + 1) 'B]), 
            << 'xs, 'ss >>  emptyQidPairList) 
            }
            
  .     
 strat iSymXor @ ProtocolConfig .
 sd iSymXor :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         change 
          chn ('ShareOK[(N + 1) 'B])
         with
          nf('x : bool <- read ('Share[(N + 1) 'B]), return ())
         in P
       ] 
       {
       select-case-family-p[
         fns1:NameWithScripts <- 'Shares,
         blist1:List{Bounds} <- fixedBound 'B,
         bt:BoolTerm <- apply 'isXorGate 'B
       ]{substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B])}
        ; applyAlphaNFPr(
            chn ('ShareOK[(N + 1) 'B]), 
            << 'xs, 'ss  >> << 'x, 'x0 >> << 'y, 'x1 >>  emptyQidPairList)       
        }    
  .     
  
 strat iSymAnd @ ProtocolConfig .
 sd iSymAnd :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         change 
          chn ('ShareOK[(N + 1) 'B])
         with
          nf('x : bool <- read ('Share[(N + 1) 'B]), return ())
         in P
       ] 
       {
       select-case-family-p[
         fns1:NameWithScripts <- 'Shares,
         blist1:List{Bounds} <- fixedBound 'B,
         bt:BoolTerm <- apply 'isAndGate 'B
       ]{substNF('Share[(N + 1) 'B], 'ShareOK[(N + 1) 'B])}
       ; applyAlphaNFPr(
            chn ('ShareOK[(N + 1) 'B]), 
            << 'xs, 'ss  >> << 'bs, 'c >>  emptyQidPairList) 
       } 
  .
  
 *************************************************************** 
 *** induction on SharesOK to Ctrbs-OK with ShareSum-OK
 strat indWiresShares' @ ProtocolConfig .
 sd indWiresShares' := 
 CONG-NEW-NF{ 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
    CONG-COMP-RIGHT[
        Q:Protocol  <- 
         removeTwo P 
          (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I]))
          (fam ('Comp['Wires-OK 'SharesOK][bound K])), 
        P1:Protocol <- 
          keepTwo P 
           (fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
           (fam ('Comp['Wires-OK 'SharesOK][bound K]))                      
        ]
        {
 matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
 SINGLE-INDUCTION-new[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- 'Comp['Wires-OK 'SharesOK],
  blist:List{Bounds} <- bound K,
  P2:Protocol <- want1'
 ]{ setIndWiresShares'
 }
 }      
 }
 . 
 strat symInputC' @ ProtocolConfig .
 sd symInputC' :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
            Delta1:ChannelContext <- Delta,
            O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change 
              chn ('ShareOK[(N + 1) 'B] )
             with 
              nf('w : unit <- read ('Wire-OK['B]), return 'w)
             in P
            ]
          {
             use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isInputGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])
                 
                 
                 ; applyReturnUnit( chn ('ShareOK[(N + 1) 'B] ) )
                 
                       
                 }
             }
          }
           
  .        
 strat iSymSumSharesOK @ ProtocolConfig .
 sd iSymSumSharesOK :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         change 
          chn ('ShareSum-OK['M 'B])
         with
          nf('w : unit <- read ('Wire-OK['B]), return 'w)
         in P
       ] 
       {
       applyReturnUnit(chn ('ShareSum-OK['M 'B]))
       } 
  .
  
 strat setIndWiresShares' @ ProtocolConfig .
 sd setIndWiresShares' :=
         applyDropName(fam ('InitOK[bound (N + 2) bound (N + 2) dependentBound 'I]))
        
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound 'B]),
           fam ('ShareOK[bound (N + 1) bound 'B]))  
       ; applyAllSameCases(fam ('ShareOK[bound (N + 1) bound 'B]))
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound 'B]),
           fam ('ShareOK[fixedBound (N + 1) bound 'B]) )  
       ; applyAllSameCases(fam ('ShareOK[fixedBound (N + 1) bound 'B]))
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound 'B]),
           fam ('ShareSum-OK[bound (N + 1) bound 'B]))  
       ; applyAllSameCases(fam ('ShareSum-OK[bound (N + 1) bound 'B]))
       
       ; applyRemoveMergeFromGroupCases(
           fam ('SharesOK[fixedBound 'B]),
           fam ('ShareSum-OK[bound (N + 1) fixedBound 'B]))  
       
       ; applyUnsplitTop(
          fam ('ShareOK[bound (N + 1) bound 'B]), 
          fam ('ShareOK[fixedBound (N + 1) bound 'B])
       )
       
      ; CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for input gate
         substNFFamiliesGen(
              fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              )
              
           
        ; symInput  
        
            
               , 
               CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for not gate
              substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              )
         ; applyReturnUnit( fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]) )     
         ; wireSymNot
         
         
              ,
       CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for xor gate
       substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              )
       ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
       ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)])
              ) 
       ; applyAlphaNFPr(fam ('ShareOK[(bound (N + 1)) (fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList)  
       ; wireSymXor    
       
        
       , CASE-DISTINCTION-one-end-when[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
          { *** for and gate
            *** SendBit-OK
             CASE-DISTINCTION-one-R[
          fns:NameWithScripts <- 'SendBit-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
          ]{ substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)])
              )
              ; applyAlphaNFPr(fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
       ; substNFFamiliesGen(
              fam ('ShareOK[bound (N + 2) bound 'B]),
              fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)])
              ) 
       ; applyAlphaNFPr(fam ('SendBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList)  , 
            *** here nothing to do
             idle}
           *** rename vars in SendBit-OK  
           ; alpha-family-three-top[
           fns:NameWithScripts <- 'SendBit-OK,
           bd3:Bounds <- fixedBound 'B,
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]  
          *** for RcvdBit we must first add two cases
          ; symRcvdBit
          *** then we can do case distinction
          ; CASE-DISTINCTION-one-R[
             fns:NameWithScripts <- 'RcvdBit-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{  *** here we do 5 substs
              select-case-family-r[
           fns1:NameWithScripts <- 'SendBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'm <T 'n]{
   substNFFamiliesGen(
     fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
   )           
           }
           
           ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
      )  
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
      ) 
      ; applyAlphaNFPr(fam ('RcvdBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
      )  
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
      ) 
      ; applyAlphaNFPr(fam ('RcvdBit-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList) 
           
           
            , *** here we diverge
            CASE-DISTINCTION-one-R-end-when[
             fns:NameWithScripts <- 'RcvdBit-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{
            select-case-family-r[
           fns1:NameWithScripts <- 'SendBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'n <=T 'm]{
   applySubstDivergeFamily(
     fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     'rb, unit)           
           }
           }
            
          }
          
          *** revert the alpha  
          ; alpha-family-three-top[
           fns:NameWithScripts <- 'SendBit-OK,
           bd3:Bounds <- fixedBound 'B,
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k]
           
           *** case dist for Ctrb-OK   
           ; CASE-DISTINCTION-one-R[
             fns:NameWithScripts <- 'Ctrb-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ select-case-family-r[
           fns1:NameWithScripts <- 'SendBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- 'n <T 'm]{
   substNFFamiliesGen(
     fam ('SendBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
   )           
           }, 
              CASE-DISTINCTION-one-R[
             fns:NameWithScripts <- 'Ctrb-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ select-case-family-r[
           fns1:NameWithScripts <- 'RcvdBit-OK,
           blist1:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B),
           bt:BoolTerm <- ('m <T 'n)]{
   substNFFamiliesGen(
     fam ('RcvdBit-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
    )} , 
              CASE-DISTINCTION-one-R-end-when[
             fns:NameWithScripts <- 'Ctrb-OK,
          blist:List{Bounds} <- (bound (N + 2) bound (N + 2) fixedBound 'B)
           ]{ substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
      ) 
      ; applyAlphaNFPr(fam ('Ctrb-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w0 >> emptyQidPairList) 
      ; substNFFamiliesGen(
     fam ('ShareOK[bound (N + 2) bound 'B]), 
     fam ('Ctrb-OK[bound (N + 2) bound (N + 2) fixedBound 'B])
      ) 
      ; applyAlphaNFPr(fam ('Ctrb-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]), 
                     << 'w, 'w1 >> emptyQidPairList)  
           
           
           }}}
      ; applyAllSameCases(fam ('Ctrb-OK[(bound (N + 2) bound (N + 2) fixedBound 'B)]))
      
      *** induction for CtrbSum-OK
      ; SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'CtrbSum-OK,
  blist:List{Bounds} <- bound (N + 2) bound (N + 2) fixedBound 'B,
  cases':Cases <- 
   nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'B])) 'w1 : unit <- read ('Wire-OK[
    fun 'wire1 'B]), return () )
 ]{
  CASE-DISTINCTION-one-R[
           fns:NameWithScripts <- 'CtrbSum-OK,
           blist:List{Bounds} <- (bound (N + 2) fixedBound 'M fixedBound 'B)
           ]
           {
           *** for m = 0
           substNFFamiliesGen(
             fam ('Ctrb-OK[(bound (N + 2))(bound (N + 2))(fixedBound 'B)]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
            ),
            CASE-DISTINCTION-one-R-end-when[
           fns:NameWithScripts <- 'CtrbSum-OK,
           blist:List{Bounds} <- (bound (N + 2) fixedBound 'M fixedBound 'B)
           ]{
            substNFFamiliesGen(
             fam ('Ctrb-OK[(bound (N + 2))(bound (N + 2))(fixedBound 'B)]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
            ) 
            ; 
            substNFFamiliesGen(
             fam ('CtrbSum-OK[bound (N + 2) bound 'M fixedBound 'B]),
             fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)])
            )
            }
            
            }
  ; applyAllSameCases(fam ('CtrbSum-OK[(bound (N + 2) fixedBound 'M fixedBound 'B)]))         
  }
          *** and finally subst for ShareOK 
           
          ; substNFFamiliesGen(
             fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]),
             fam ('ShareOK[bound (N + 1) fixedBound 'B])
            ) 
           ; wireSymAnd 
          }
       }
       }
       }
       
       ; applyRemoveMergeFromGroupCases(
           fam ('SharesOK[fixedBound 'B]),
           fam ('ShareOK[bound (N + 1) fixedBound 'B]))  
           
       *** induction for ShareSumOK
       
       ;    SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'ShareSum-OK,
  blist:List{Bounds} <- bound (N + 1) fixedBound 'B,
  cases':Cases <- 
   nf('w : unit <- read ('Wire-OK['B]), return 'w)
 ]{
       
       *** ind proof starts here
       
       CASE-DISTINCTION-channel[
           fns:NameWithScripts <- 'ShareSum-OK['M 'B]
           ]{
           *** for m = 0 
           substNFFamilyOne(
              fam ('ShareOK[bound (N + 1) fixedBound 'B]),
              'ShareSum-OK['M 'B]
              ),
           *** m /= 0
           CASE-DISTINCTION-channel-end-when[
           fns:NameWithScripts <- 'ShareSum-OK['M 'B]
           ]{
           substNFFamilyOne(
              fam ('ShareOK[bound (N + 1) fixedBound 'B]),
              'ShareSum-OK['M 'B]
              )
           ;
           substNFFamilyOne(
              fam ('ShareSum-OK[bound 'M fixedBound 'B]),
              'ShareSum-OK['M 'B]
              )   
           }
           } 
           ; applyAllSameCases(chn ('ShareSum-OK['M 'B]))
           ; iSymSumSharesOK 
           } 
           *** put things back
           ; applyAddToGroupCases(
           fam ('SharesOK[fixedBound 'B]),
           fam ('ShareOK[bound (N + 1) fixedBound 'B]))      
           ; applyAddToGroupCases(
           fam ('SharesOK[fixedBound 'B]),
           fam ('ShareSum-OK[bound (N + 1) fixedBound 'B])
           )   
           *** now case distinction for the channel 
           ; CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for input gate
       *** now for the channel
         substNFFamilyOne(
            fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
                ('ShareOK[(N + 1) 'B])
            )  
         ; substNFFamilyOne(
            fam ('ShareSum-OK[bound (N + 1) fixedBound 'B]), 
                ('ShareOK[(N + 1) 'B])
               ) 
         ; use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isInputGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])    
                  }} 
         ; symInputC'
                   ,
                   CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for not gate  
       ***  now the channel
         
            substNFFamilyOne(
            fam ('ShareSum-OK[bound (N + 1) fixedBound 'B]), 
                ('ShareOK[(N + 1) 'B])
               ) 
          ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                     << 'w, 'w0 >> emptyQidPairList)      
         ; substNFFamilyOne(
            fam ('ShareOK[bound (N + 2) bound 'B]), 
                ('ShareOK[(N + 1) 'B])
           )  
           ; use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isNotGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])    
                  }} 
          ; applyReturnUnit( chn ('ShareOK[(N + 1) 'B]) )          
          ;  wireSymNotC
         ,
         CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
       { *** for xor gate
       ***  now the channel
         
         substNFFamilyOne(
            fam ('ShareOK[bound (N + 2) bound 'B]), 
                ('ShareOK[(N + 1) 'B])
           )
         ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]), 
                     << 'w, 'w0 >> emptyQidPairList) 
       ; substNFFamilyOne(
            fam ('ShareOK[bound (N + 2) bound 'B]), 
                ('ShareOK[(N + 1) 'B])
           )
       ; applyAlphaNFPr(chn ('ShareOK[(N + 1) 'B]),
                     << 'w, 'w1 >> emptyQidPairList)  
       ; substNFFamilyOne(
            fam ('ShareSum-OK[bound (N + 1) fixedBound 'B]), 
                ('ShareOK[(N + 1) 'B])
               ) 
       ; use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isXorGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])    
                  }} 
       ; wireSymXorC                    
 ,
                   CASE-DISTINCTION-one-end-when[
          fns:NameWithScripts <- 'SharesOK,
          blist:List{Bounds} <- fixedBound 'B]
          { *** for and gate
           *** and the channel 
            substNFFamilyOne(
            fam ('CtrbSum-OK[bound (N + 2) bound (N + 2) fixedBound 'B]), 
                ('ShareOK[(N + 1) 'B])
           ) 
           ; substNFFamilyOne(
            fam ('ShareSum-OK[bound (N + 1) fixedBound 'B]), 
                ('ShareOK[(N + 1) 'B])
               ) 
           ; use-family-p[
                fns:NameWithScripts <- 'Wires-OK,
                blist:List{Bounds} <- fixedBound 'B]{
            select-case-channel-r[
                 cn:ChannelName <- 'Wire-OK['B],
                 bt:BoolTerm <- (apply 'isAndGate 'B)]{
                 
                 substNF(
                  'Wire-OK['B], 
                   'ShareOK[(N + 1) 'B])    
                  }} 
            ; wireSymAndC
            }}}} 
            *** now we put back initOk
            ; sym6 
            *** then split ShareOK and put it back in SharesOK
     ; applySplit(fam ('ShareOK[bound (N + 2) bound 'B]))
     ; applyAddToGroupCases(
         fam ('ShareOK[bound (N + 1) bound 'B]),
         fam ('SharesOK[bound 'B])
         )
     ; applyAddToGroupCases(
         fam ('ShareOK[fixedBound (N + 1) bound 'B]),
         fam ('SharesOK[bound 'B])
         ) 
          
     ; applyAddToGroupCases(
         fam ('ShareSum-OK[bound (N + 1) bound 'B]),
         fam ('SharesOK[bound 'B])
         )           
 .
  strat indSharesT2 @ ProtocolConfig .
 sd indSharesT2 := 
 CONG-NEW-NF{ 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 SINGLE-INDUCTION-new[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- ('Comp['HiddenGroup 'Shares]),
  blist:List{Bounds} <- bound K,
  P2:Protocol <- want2
 ]{ indSharesTiming2
  }
     
 }
 . 
 strat indSharesTiming2 @ ProtocolConfig .
 sd indSharesTiming2 :=   
        CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** input
          substNFFamilyOne(
             fam ('ShareSum-OK[bound (N + 1) bound K]), 
             'Share[(N + 1) 'B]
             )
             ,
             CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** not
          substNFFamilyOne(
             fam ('ShareSum-OK[bound (N + 1) bound K]), 
             'Share[(N + 1) 'B]
             ),
             CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** xor
             substNFFamilyOne(
             fam ('ShareSum-OK[bound (N + 1) bound K]), 
             'Share[(N + 1) 'B]
             ),
             CASE-DISTINCTION-one-end-when[
          fns:NameWithScripts <- 'Shares,
          blist:List{Bounds} <- fixedBound 'B]{
          *** and
           substNFFamilyOne(
             fam ('ShareSum-OK[bound (N + 1) bound K]), 
             'Share[(N + 1) 'B]
             )}}}}
     
        
 .
 
   op want1' : -> Protocol .
 eq want1' = 
 (family 'SharesOK[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
||
(family 'ShareSum-OK[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
||
(family 'ShareSum-OK[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('Ctrb-OK['n 'm 'k]), return 'c)
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('c : unit <- read ('CtrbSum-OK['n 'm 'k]), return 'c)
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('r : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'r)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('s : unit <- read ('SendBit-OK['n 'm 'k]), return 's)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
||
(family 'ShareSum-OK[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
;;
(when (apply 'isAndGate 'k) -->
(family 'Ctrb-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return () )
)
||
(family 'CtrbSum-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return () )
)
||
(family 'RcvdBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('m <T 'n) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return () ))
;;
when ('n <=T 'm) -->
nf('rb : unit <- read ('RcvdBit-OK['n 'm 'k]), return 'rb)
)
||
(family 'SendBit-OK[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return () ))
;;
when ('m <=T 'n) -->
nf('sb : unit <- read ('SendBit-OK['n 'm 'k]), return 'sb)
)
||
(family 'ShareOK[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
||
(family 'ShareSum-OK[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
||
family 'ShareOK[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf('w : unit <- read ('Wire-OK['k]), return 'w)
)
)
||
family 'Wires-OK[bound K] 'k
bound K
::=
family 'Wire-OK[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
nf('in : unit <- read ('In-OK[(fun 'wire0 'k) (fun 'wire1 'k)]), return 'in))
;;
(when (apply 'isNotGate 'k) -->
nf('w : unit <- read ('Wire-OK[fun 'wire0 'k]), return ()))
;;
(when (apply 'isXorGate 'k) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return () ))
;;
(when (apply 'isAndGate 'k) -->
nf(('w0 : unit <- read ('Wire-OK[fun 'wire0 'k])) 'w1 : unit <- read ('Wire-OK[fun 'wire1 'k]),
    return () )
)
.
strat addGroupOS @ ProtocolConfig .
 sd addGroupOS := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K])
           
         named 'GroupOS
         params ('n 'm 'k) (bound (N + 2) bound (N + 2) bound K)
         in P
       ]
       {
        applyDropName(fam ('GroupOS[bound (N + 2) bound (N + 2) bound K])
        )
       } ***sym
       )
 . 
 strat addBranchGroupOS @ ProtocolConfig .
 sd addBranchGroupOS := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change 
        fam ('GroupOS[bound (N + 2) bound (N + 2) bound K])
        with
         (when (apply 'isOutputWire 'k)  --> 
  family 'OutShareSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('OutShare['n 0 'k]), return 's))
;;
otherwise -->
nf(('s : bool <- read ('OutShareSum['n ('m -- 1) 'k])) 'x : bool <- read ('OutShare['n 'm 'k]),
    return (ap 'xor pair('s, 'x)) )
)
         ;;
(when (neg (apply 'isOutputWire 'k) ) --> 
family 'OutShareSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('OutShare['n 0 'k]), return 's))
;;
otherwise -->
nf(('s : bool <- read ('OutShareSum['n ('m -- 1) 'k])) 'x : bool <- read ('OutShare['n 'm 'k]),
    return (ap 'xor pair('s, 'x)) )
)
        in P
       ]
       {
        applyAllSameCases(fam ('GroupOS[bound (N + 2) bound (N + 2) bound K])
        )
       } ***sym
       )
 .
 
  strat subst3 @ ProtocolConfig .
 sd subst3 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('OutShare[bound (N + 2) bound (N + 2) bound K]) ), 
                 P1:Protocol <- keepTwo P 
                  (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('OutShare[bound (N + 2) bound (N + 2) bound K]) )
                ]
              {
                select-case-subst-family-r[
           bt:BoolTerm <- apply 'isOutputWire 'k
          ]{ 
            substNFFamiliesGen(
                 fam ('OutShare[bound (N + 2) bound (N + 2) bound K]), 
                 fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])
                 )
            
           }
              }
       )       
 . 
 strat subst3sym @ ProtocolConfig .
 sd subst3sym :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])
        with
         nf('s : bool <- read ('ShareSum['M 'k]), return 's)
        in P
       ]
{ matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P' (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('ShareSum[bound (N + 2) bound K]) ), 
                 P1:Protocol <- keepTwo P' 
                  (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('ShareSum[bound (N + 2) bound K]) )
                ]
              {
                select-case-subst-family-r[
           fns1:NameWithScripts <- 'ShareSum,
           bt:BoolTerm <- (0 =T= 'm)]{
   substNFFamiliesGen(
     fam ('ShareSum[bound (N + 2) bound K]), 
     fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])
   )  
           }
            
           
              }
       )       
 }
 . 
 
 strat subst4 @ ProtocolConfig .
 sd subst4 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('OutShare[bound (N + 2) bound (N + 2) bound K]) ), 
                 P1:Protocol <- keepTwo P 
                  (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('OutShare[bound (N + 2) bound (N + 2) bound K]) )
                ]
              {
                select-case-subst-family-r[
           bt:BoolTerm <- apply 'isOutputWire 'k
          ]{ 
            substNFFamiliesGen(
                 fam ('OutShare[bound (N + 2) bound (N + 2) bound K]), 
                 fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])
                 )
            
           }
              }
       )       
 . 

 strat subst4sym @ ProtocolConfig .
 sd subst4sym :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])
        with
         nf('s : bool <- read ('ShareSum['M 'k]), return 's)
        in P
       ]
{ matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P' (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('ShareSum[bound (N + 2) bound K]) ), 
                 P1:Protocol <- keepTwo P' 
                  (fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])) 
                  ( fam ('ShareSum[bound (N + 2) bound K]) )
                ]
              {
                select-case-subst-family-r[
           fns1:NameWithScripts <- 'ShareSum,
           bt:BoolTerm <- neg (0 =T= 'm)]{
   substNFFamiliesGen(
     fam ('ShareSum[bound (N + 2) bound K]), 
     fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])
     )       
           }
            
           
              }
       )       
 }
 .   
 
 strat addBranchOut @ ProtocolConfig .
 sd addBranchOut := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change 
       fam ('Out[bound (N + 2) bound K])
        with
         (when (apply 'isOutputWire 'k)  --> 
  nf('s : bool <- read ('OutShareSum['n (N + 1) 'k]), return 's)
)
         ;;
(when (neg (apply 'isOutputWire 'k) ) --> 
nf('s : bool <- read ('OutShareSum['n (N + 1) 'k]), return 's)
)
        in P
       ]
       {
        applyAllSameCases( fam ('Out[bound (N + 2) bound K])  )
  
       } ***sym
       )
 . 
 strat subst5 @ ProtocolConfig .
 sd subst5 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P (fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K])) 
                  ( fam ('Out[bound (N + 2) bound K]) ), 
                 P1:Protocol <- keepTwo P 
                  (fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K])) 
                  ( fam ('Out[bound (N + 2) bound K]) )
                ]
              {
                select-case-subst-family-r[
           bt:BoolTerm <- apply 'isOutputWire 'k
          ]{ 
            substNFFamiliesGen(
                 fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]), 
                 fam ('Out[bound (N + 2) bound K])
                 )
            
           }
              }
       )       
 .    
 strat subst6 @ ProtocolConfig .
 sd subst6 := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
 ( CONG-COMP-RIGHT[
                 Q:Protocol  <- 
                 removeTwo P (fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K])) 
                  ( fam ('Out[bound (N + 2) bound K]) ), 
                 P1:Protocol <- keepTwo P 
                  (fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K])) 
                  ( fam ('Out[bound (N + 2) bound K]) )
                ]
              {
                select-case-subst-family-r[
           bt:BoolTerm <- neg(apply 'isOutputWire 'k)
          ]{ 
            subst-diverge-family[x3:ChannelName <- 'o, T2:Type <- bool] 
            
           }
              }
       )       
 .  
 
 *** the huge induction
 strat setupIndSumShares @ ProtocolConfig .
 sd setupIndSumShares := 
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('Shares[bound K])
        with
         want3
        in P
       ] 
{     
    
    CONG-NEW-NF{
    SINGLE-INDUCTION-new-R[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- 'Shares,
  blist:List{Bounds} <- bound K,
  cases':Cases <- know3
 ]{ 
    *** change otherwise to neg in 'InShare$-Sum
       applyOtherwiseToNeg( 
          fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]) 
         )
       ; applyOtherwiseToNeg( 
          fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]) 
         )  
       
    ; CASE-DISTINCTION-one[
       fns:NameWithScripts <- 'Shares,
       blist:List{Bounds} <- fixedBound 'B
    ]{ *** for input gate
         setupSymInput
         
       ,
       CASE-DISTINCTION-one[
       fns:NameWithScripts <- 'Shares,
       blist:List{Bounds} <- fixedBound 'B
    ]{ *** for not gate
         setupSymNot,
         CASE-DISTINCTION-one[
       fns:NameWithScripts <- 'Shares,
       blist:List{Bounds} <- fixedBound 'B
    ]{ *** for xor gate
       setupSymXor,
       
       CASE-DISTINCTION-one-end-when[
       fns:NameWithScripts <- 'Shares,
       blist:List{Bounds} <- fixedBound 'B
    ]{ *** for and gate
       setupSymAnd   
       }}
     }  
    }
    *** change neg to otherwise in 'InShare$-Sum
       ; 
       applyNegToOtherwise( 
          fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]) 
         )
       ; applyNegToOtherwise( 
          fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]) 
         )  
 } *** induction end  
 } *** cong new end
} *** sym end
.   
 
*** for the induction in sum of shares
 op know3 : -> Protocol .
eq know3 = 
(when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'k) (fun 'wire1 'k)])) 'xs : bool <- read (
    'ShareSum[N 'k]), return 'in)
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('xm : bool <- read ('Share[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'xm)) )
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) 'xs : bool <- read ('ShareSum[N 'k]),
    return (ap 'neg 'x) )
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('xm : bool <- read ('Share[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'xm)) )
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)) )
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'k)])) ('xs : bool <- read ('ShareSum[N 'k])) 'y :
    bool <- read ('Share[(N + 1) (fun 'wire1 'k)]), return (ap 'xor pair('x, 'y)) )
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('xm : bool <- read ('Share[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'xm)) )
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)) ))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)) )
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)) )
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >) ))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return
    'bs )
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('xm : bool <- read ('Share[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'xm)) )
.    
op want3 : -> WhenList .
eq want3 = 
(when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
    'xs : bool <- read ('ShareSum[N 'k]), 
    return (ap 'xor pair('xs, 'x)) )
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('i : bool <- read ('In[(fun 'wire0 'k) (fun 'wire1 'k)]), 
    return 'i)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
    'xs : bool <- read ('ShareSum[N 'k]), 
    return (ap 'xor pair('xs, 'x)) )
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)])),
    return (ap 'neg 'x))
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)) )
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
    'xs : bool <- read ('ShareSum[N 'k]), 
    return (ap 'xor pair('xs, 'x)) )
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)])) 
    'y : bool <- read ('ShareSum[(N + 1) (fun 'wire1 'k)]), 
    return (ap 'xor pair('x, 'y)) )
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)) ))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)) )
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)) )
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >) ))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
    'xs : bool <- read ('ShareSum[N 'k]), 
    return (ap 'xor pair('xs, 'x)) )    
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)])) 
    'y : bool <- read ('ShareSum[(N + 1) (fun 'wire1 'k)]), 
    return (ap 'and pair('x, 'y)) )
.
 
op want3 : -> WhenList .
eq want3 = 
(when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
    'xs : bool <- read ('ShareSum[N 'k]), 
    return (ap 'xor pair('xs, 'x)) )
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('i : bool <- read ('In[(fun 'wire0 'k) (fun 'wire1 'k)]), 
    return 'i)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
    'xs : bool <- read ('ShareSum[N 'k]), 
    return (ap 'xor pair('xs, 'x)) )
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)])),
    return (ap 'neg 'x))
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)) )
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
    'xs : bool <- read ('ShareSum[N 'k]), 
    return (ap 'xor pair('xs, 'x)) )
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)])) 
    'y : bool <- read ('ShareSum[(N + 1) (fun 'wire1 'k)]), 
    return (ap 'xor pair('x, 'y)) )
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)) ))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)) )
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)) )
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >) ))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 
    'xs : bool <- read ('ShareSum[N 'k]), 
    return (ap 'xor pair('xs, 'x)) )    
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)])) 
    'y : bool <- read ('ShareSum[(N + 1) (fun 'wire1 'k)]), 
    return (ap 'and pair('x, 'y)) )
.

strat setupSymInput @ ProtocolConfig .
 sd setupSymInput :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('Share[(N + 1) 'B])
        with
         nf(('in : bool <- read ('InShare[(N + 1) (fun 'wire0 'B) (fun 'wire1 'B)])) 
             'xs : bool <- read ('ShareSum[N 'B]), return 'in)
        in (
        change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf(('xm : bool <- read ('Share[(N + 1) 'B])) 
             'xs : bool <- read ('ShareSum[N 'B]), 
             return (ap 'xor pair('xs, 'xm)))
        in 
        P)
       ]{
         substNF('Share[(N + 1) 'B], 'ShareSum[(N + 1) 'B])
         *** Share
       ; setupSymInput2
       
         *** ShareSum
        ; indShareSum 
        ; substNFFamilyOne(
           fam ('ShareSum[bound (N + 1) fixedBound 'B]), 
           'ShareSum[(N + 1) 'B]
        )
        ; revertShareSum
        
        ; substNFFamilyOne(
           fam ('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]), 
           'ShareSum[(N + 1) 'B]
        )
        ; substNFFamilyOne(
           fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]), 
           'ShareSum[(N + 1) 'B]
        )
        ; applyReturnIdem2(chn ('ShareSum[(N + 1) 'B]))
       ; addInternalsInputBranch
       *** from here until remove we work in a newNF
       
       ; sym$SumOK
       
       
       *** must happen before InShare$-OK changes
       ; pSymInd0
       
       *** now we do that change
       
       ; dropInShare$
       ; symInShare$
       
       ; CONG-NEW-NF{pSetupInd1}
       
       ; substNFFamilyOne(
      fam ('InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I]) ,
      'ShareSum[(N + 1) 'B]
      ) 
      
      ; substNFFamilyOne(
      fam ('In-OK[bound (N + 2) dependentBound 'I]) ,
      'ShareSum[(N + 1) 'B]
      ) 
      ; applyAlphaNFPr(
           chn ('ShareSum[(N + 1) 'B]), 
                         << 'x, 'i >> emptyQidPairList)
      ; removeInternalsInputBranch 
      }
 .   
 strat setupSymInput2 @ ProtocolConfig .
 sd setupSymInput2 :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('Share[(N + 1) 'B])
        with
         nf(('x : bool <- read ('ShareSum[(N + 1) 'B])) 
             'xs : bool <- read ('ShareSum[N 'B]), 
            return (ap 'xor pair('xs, 'x)))
        in P
       ] 
       { substNF('ShareSum[(N + 1) 'B], 'Share[(N + 1) 'B])
       ; applyReturnIdem( chn ('Share[(N + 1) 'B]) )
       }
 .
 
  strat setupSymNot @ ProtocolConfig .
 sd setupSymNot :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('Share[(N + 1) 'B])
        with
         nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'B)])) 
             'xs : bool <- read ('ShareSum[N 'B]), return (ap 'neg 'x))
         
        in (
        change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf(('xm : bool <- read ('Share[(N + 1) 'B])) 
             'xs : bool <- read ('ShareSum[N 'B]), 
             return (ap 'xor pair('xs, 'xm)))
        in 
        P)
       ]
       *** this is from notSS, turn to sym
       {
     
     substNF('Share[(N + 1) 'B], 'ShareSum[(N + 1) 'B])
   ; revertShareNot
    
   ; rewriteSharesBoundNotAux
   
   ; substNFFamilyOne(
      fam ('ShareSum[bound (N + 1) fixedBound 'B]),
      'ShareSum[(N + 1) 'B]
    )
    
   ; revertSharesBoundNotAux 
    
   ; applyReturnNegOverXor(chn ('ShareSum[(N + 1) 'B]))  
   
  ; applyRemoveFromGroupCases(
       fam ('Shares[bound 'B]),
       fam ('ShareSum[fixedBound (N + 1) bound 'B])
       )
   
  ; applyAllSameCases(fam ('ShareSum[fixedBound (N + 1) bound 'B]))  
   
  ; psymNot
    
  ; applyAddToGroupCases( 
       fam ('ShareSum[fixedBound (N + 1) bound 'B]), 
       fam ('Shares[bound 'B]) )
  }
 .      

 strat revertShareNot @ ProtocolConfig . 
 sd revertShareNot := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('Share[(N + 1) 'B])
        with
        nf(('x : bool <- read ('ShareSum[(N + 1) 'B])) 
            'xs : bool <- read ('ShareSum[N 'B]), 
            return (ap 'xor pair('xs, 'x)))
        in P
       ]
       {  substNF('ShareSum[(N + 1) 'B], 'Share[(N + 1) 'B])
       ; applyReturnIdem(chn ('Share[(N + 1) 'B]))
       }
       .

strat rewriteSharesBoundNotAux @ ProtocolConfig .
 sd rewriteSharesBoundNotAux := 
      SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'ShareSum,
  blist:List{Bounds} <- bound (N + 1) fixedBound 'B,
  cases':Cases <- 
   nf('s : bool <- read ('ShareSum['m (fun 'wire0 'B)]), return 's) 
   ] {
       *** ind proof starts here
        applyRemoveMergeFromGroupCases(
       fam ('Shares[bound 'B]),
       fam ('ShareSum[bound (N + 1) bound 'B])
      )
      ; CASE-DISTINCTION-channel[
       cn:ChannelName <- 'ShareSum['M 'B]
      ]
      {
      substNFFamilyOne(
        fam ('Share[bound (N + 1) fixedBound 'B]),
        'ShareSum['M 'B]
       )
     
       , 
       CASE-DISTINCTION-channel-end-when[
       cn:ChannelName <- 'ShareSum['M 'B]
      ]
      {substNFFamilyOne(
        fam ('Share[bound (N + 1) fixedBound 'B]),
        'ShareSum['M 'B]
       )
       ; applyAlphaNFPr(
            chn ('ShareSum['M 'B]), 
                         << 's, 'new >> emptyQidPairList)
        
       ; substNFFamilyOne(
        fam ('ShareSum[bound 'M fixedBound 'B]),
        'ShareSum['M 'B]
       )
       }
      }
     ; symWithCasesSS
     ; applyAllSameCases( chn ('ShareSum['M 'B]) )
     ; applyAddToGroupCases(
       fam ('Shares[bound 'B]),
       fam ('ShareSum[bound (N + 1) bound 'B])
      )
   }  
 .  
 strat symWithCasesSS @ ProtocolConfig .
 sd symWithCasesSS :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change chn ('ShareSum['M 'B])
       with
        (when (0 =T= 'M) -->
nf('s : bool <- read ('ShareSum['M (fun 'wire0 'B)]), return 's)
)
;;
(when neg (0 =T= 'M) -->
nf('s : bool <- read ('ShareSum['M (fun 'wire0 'B)]), return 's)
)
       in P
       ] 
       {
       CASE-DISTINCTION-channel[
       cn:ChannelName <- 'ShareSum['M 'B]
      ]
      { pSubstFamCaseChnSSNot(  0 =T= 'm
        )
        , 
       CASE-DISTINCTION-channel-end-when[
       cn:ChannelName <- 'ShareSum['M 'B]
      ]{
      pSubstFamCaseChnSSNot( neg( 0 =T= 'm))
      ; applyAlphaNFPr(
            chn ('ShareSum['M 'B]), 
                         << 'xm, 'new >> << 'xs, 's >>  emptyQidPairList)   
      }
      }
      }
 .
  
 strat pSubstFamCaseChnSSNot : BoolTerm @ ProtocolConfig .
sd pSubstFamCaseChnSSNot(bt) :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{pSubstFamCaseChnSSNot(bt)} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('ShareSum[bound (N + 1) bound 'B]) ) 
          (chn ('ShareSum['M 'B])), 
        P1:Protocol <- keepTwo P 
          (fam ('ShareSum[bound (N + 1) bound 'B]) ) 
          (chn ('ShareSum['M 'B]))
        ]{
 select-case-subst-family-r-gen[
          bt:BoolTerm <- bt 
        ]{substNFFamilyOne(
           fam ('ShareSum[bound (N + 1) bound 'B]), 'ShareSum['M 'B]
          )
         }
         }) 
 .        
 strat revertSharesBoundNotAux @ ProtocolConfig .
 sd revertSharesBoundNotAux := 
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
         fam ('ShareSum[bound (N + 1) fixedBound 'B])
        with
         (when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'B]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'B])) 'xs : bool <- read ('ShareSum[('m -- 1)
    'B]), return (ap 'xor pair('xs, 'xm)))
        in
        P
       ] 
       { rewriteSharesBoundNotAux }
       
 .   
 
 **** strategies for not
 strat psymNot @ ProtocolConfig .
  sd psymNot :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum[(N + 1) 'B])
        with
        nf('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'B)]), return (ap 'neg 'x))
        in P
        ]
        { substNFFamilyOne(
            fam ('ShareSum[fixedBound (N + 1) bound 'B]),
            'ShareSum[(N + 1) 'B]
        )
        ; applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 'xm, 'x >> << 'xs, 's >> emptyQidPairList)
        }
  .
 strat rewriteSharesBoundNot @ ProtocolConfig .
 sd rewriteSharesBoundNot :=
 match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{rewriteSharesBoundNot} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[Q:Protocol  <- removeOne P (fam ('Shares[bound 'B])), 
                             P1:Protocol <- keepOne P (fam ('Shares[bound 'B]))]{
       CONG-FAMILY-WHENLIST-P[
        bt:BoolTerm <- apply 'isNotGate 'k]{
        rewriteSharesBoundNotAux
       }
                             }           
 .    
 
  strat indShareSum @ ProtocolConfig .
 sd indShareSum := 
 SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'ShareSum,
  blist:List{Bounds} <- bound (N + 1) fixedBound 'B,
  cases':Cases <- 
   nf('i : bool <- read ('InShare$-Sum['m (fun 'wire0 'B) (fun 'wire1 'B)]), 
              return 'i)
   ] 
       {
        CASE-DISTINCTION-channel[
         cn:ChannelName <- 'ShareSum['M 'B]
        ]{substNFFamilyOne(
           fam ('Share[bound (N + 1) fixedBound 'B]),
           'ShareSum['M 'B]
          )
          ;
          substNFFamilyOne(
           fam ('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]),
           'ShareSum['M 'B]
          )
          ; symSS
          , CASE-DISTINCTION-channel-end-when[
         cn:ChannelName <- 'ShareSum['M 'B]
        ]{substNFFamilyOne(
           fam ('Share[bound (N + 1) fixedBound 'B]),
           'ShareSum['M 'B]
              
          )
          ; substNFFamilyOne(
           fam ('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]),
           'ShareSum['M 'B]
          )  
          ;
          substNFFamilyOne(
           fam ('ShareSum[bound 'M fixedBound 'B]),
           'ShareSum['M 'B]
          )
          ; applyAlphaNFPr(chn ('ShareSum['M 'B]), 
                             << 'i, 's >> << 'in, 'x >>
                            emptyQidPairList )
          ; symSS2                   
          }
        }
       ; applyAllSameCases(chn ('ShareSum['M 'B]))
       ; applyAlphaNFPr(chn ('ShareSum['M 'B]), 
                             << 'in, 'i >>
                            emptyQidPairList )
  }
 . 
 strat symSS @ ProtocolConfig .
 sd symSS := matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum['M 'B])
        with
         nf('in : bool <- read ('InShare$-Sum['M (fun 'wire0 'B) (fun 'wire1 'B)]), 
            return 'in)
        in P
       ]
       {
        matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using CONG-COMP-RIGHT[
         Q:Protocol  <- 
           removeTwo P' 
            (chn ('ShareSum['M 'B])) 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])), 
         P1:Protocol <- 
           keepTwo P' 
            (chn ('ShareSum['M 'B])) 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]))
          ]{
            select-case-subst-family-r-gen[
            bt:BoolTerm <- (0 =T= 'm)
           ]{ 
           substNFFamilyOne(
             (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])),
             'ShareSum['M 'B]
             ) 
               
             }
            
             
             
         }   
       
       }
 .
 strat symSS2 @ ProtocolConfig .
 sd symSS2 := matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum['M 'B])
        with
         nf('in : bool <- read ('InShare$-Sum['M (fun 'wire0 'B) (fun 'wire1 'B)]), 
            return 'in)
        in P
       ] 
       {
        matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using CONG-COMP-RIGHT[
         Q:Protocol  <- 
           removeTwo P' 
            (chn ('ShareSum['M 'B])) 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])), 
         P1:Protocol <- 
           keepTwo P' 
            (chn ('ShareSum['M 'B])) 
            (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]))
          ]{
            select-case-subst-family-r-gen[
            bt:BoolTerm <- neg (0 =T= 'm)
           ]{ 
           substNFFamilyOne(
             (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])),
             'ShareSum['M 'B]
             ) 
               
             }
          
             
             
         } 
         }
      
 .
 
 strat revertShareSum @ ProtocolConfig . 
 sd revertShareSum := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('ShareSum[bound (N + 1) fixedBound 'B])
        with
        (when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'B]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'B])) 
    'xs : bool <- read ('ShareSum[('m -- 1) 'B]), 
    return (ap 'xor pair('xs, 'xm)))
        in P
       ]{
          indShareSum
       }
 .
 strat addInternalsInputBranch @ ProtocolConfig .
 sd addInternalsInputBranch := 
    
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'In-OK
         typed unit
         params ('p 'i)
                ((bound (N + 2))(dependentBound 'I))  
         assigned
          nf('i : bool  <- read ('In['p 'i]),
             return ())
         in (
         addInternalFamily
           'InShare$-OK
         typed unit
         params ('m 'p 'i)
                ((bound (N + 1))(bound (N + 2))(dependentBound 'I) )  
         assigned
          nf('i : bool  <- read ('InShare$['m 'p 'i]),
             return ())
         in (
         addInternalFamily
           'InShare$Sum-OK
         typed unit
         params ('m 'p 'i)
                ((bound (N + 1))(bound (N + 2))(dependentBound 'I) )  
         assigned
          nf('i : bool  <- read ('InShare$-Sum['m 'p 'i]),
             return ())
         in P
         )
         )        
       ]{ sugar-newNF
        ; absorbFamily(fam ('In-OK[((bound (N + 2))(dependentBound 'I))]))
        ; absorbFamily(fam ('InShare$-OK[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]))
        ; absorbFamilyDeleteEmpty(
            fam ('InShare$Sum-OK[((bound (N + 1))(bound (N + 2))(dependentBound 'I))])
          )
        } ***sym
       )
 .   

  strat sym$SumOK @ ProtocolConfig .
 sd sym$SumOK :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf(('s : unit <- read ('InShare$Sum-OK[N (fun 'wire0 'B) (fun 'wire1 'B)]))
             'x : bool <- read ('In[(fun 'wire0 'B) (fun 'wire1 'B)]), return 'x)
        in P
       ]
       {
       substNFFamilyOne(
              fam ('InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I]),
              'ShareSum[(N + 1) 'B]
              )
           
       ; applyAlphaNFPr(chn ('ShareSum[(N + 1) 'B]), 
                         << 'i, 's >> emptyQidPairList)        
       }
 .
 strat pSymInd0 @ ProtocolConfig .
 sd pSymInd0 :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('InShare$Sum-OK[bound (N + 1) bound (N + 2) dependentBound 'I])
        with
         (when (0 =T= 'm) -->
nf('in : unit <- read ('InShare$-OK[0 'p 'i]), return ()))
;;
when neg (0 =T= 'm) -->
nf(('s : unit <- read ('InShare$Sum-OK[('m -- 1) 'p 'i])) 
    'x : unit <- read ('InShare$-OK['m 'p 'i]),
    return ())
        in P
        ]
      { 
        CONG-NEW-NF{
        alpha-family-three-top[
           fns:NameWithScripts <- 'InShare$-Sum, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'i,
           q4:Qid <- 'm,
           q5:Qid <- 'p,
           q6:Qid <- 'i] 
           
   ; alpha-family-three-top[
           fns:NameWithScripts <- 'InShare$, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'i,
           q4:Qid <- 'm,
           q5:Qid <- 'p,
           q6:Qid <- 'i]
           }
          
  ; CONG-NEW-NF{pSetupInd0
  ; alpha-family-three-top[
           fns:NameWithScripts <- 'InShare$-Sum, 
           q1:Qid <- 'm,
           q2:Qid <- 'p,
           q3:Qid <- 'i,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'i] 
   ; alpha-family-three-top[
           fns:NameWithScripts <- 'InShare$, 
           q1:Qid <- 'm,
           q2:Qid <- 'p,
           q3:Qid <- 'i,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'i]
        }    
        }                    
 . 
 strat pSetupInd1 @ ProtocolConfig .
 sd pSetupInd1 := 
      SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'InShare$Sum-OK,
  blist:List{Bounds} <- (bound (N + 1)) bound (N + 2) dependentBound 'I,
  cases':Cases <- 
   nf('i : unit  <- read ('In-OK['p 'i]),
             return ())
   ]{
       *** induction proof here
       CASE-DISTINCTION-one-R[
     fns:NameWithScripts <- 'InShare$Sum-OK,
     blist:List{Bounds} <- fixedBound 'M bound (N + 2) dependentBound 'I  
     ] {substNFFamiliesGen(
      fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]) ,
      fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
     ), 
     CASE-DISTINCTION-one-R-end-when[
     fns:NameWithScripts <- 'InShare$Sum-OK,
     blist:List{Bounds} <- fixedBound 'M bound (N + 2) dependentBound 'I  
     ] {
     substNFFamiliesGen(
      fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]) ,
      fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
      ) 
      ;
      substNFFamiliesGen(
      fam ('InShare$Sum-OK[bound 'M bound (N + 2) dependentBound 'I]) ,
      fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
     )  
     }
     }
     ; applyAllSameCases( 
        fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I]) 
       )
    }   
 .
 
 strat pSetupInd0 @ ProtocolConfig .
 sd pSetupInd0 :=
       SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'InShare$Sum-OK,
  blist:List{Bounds} <- (bound (N + 1)) bound (N + 2) dependentBound 'I,
  cases':Cases <- 
   nf('i : bool  <- read ('InShare$-Sum['m 'p 'i]),
             return ())
   ]
       {
       CASE-DISTINCTION-one-R[
     fns:NameWithScripts <- 'InShare$Sum-OK,
     blist:List{Bounds} <- fixedBound 'M bound (N + 2) dependentBound 'I  
     ] {
     
     substNFFamiliesGen(
      fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]) ,
      fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
     )
     
     ; sym1$SumOK
     , CASE-DISTINCTION-one-R-end-when[
     fns:NameWithScripts <- 'InShare$Sum-OK,
     blist:List{Bounds} <- fixedBound 'M bound (N + 2) dependentBound 'I  
     ] {
     substNFFamiliesGen(
      fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]) ,
      fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
     )
     ; applyAlphaNFPr(
            fam ('InShare$Sum-OK[fixedBound 'M (bound (N + 2))(dependentBound 'I)]), 
                         << 'i, 'x >> emptyQidPairList) 
                         
     ; substNFFamiliesGen(
      fam ('InShare$Sum-OK[bound 'M bound (N + 2) dependentBound 'I]) ,
      fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
     )  
     ; applyAlphaNFPr(
            fam ('InShare$Sum-OK[fixedBound 'M (bound (N + 2))(dependentBound 'I)]), 
                         << 'i, 's >> emptyQidPairList) 
     ; sym2$SumOK                                       
     }
     } 
     ; applyAllSameCases( fam ('InShare$Sum-OK[fixedBound 'M (bound (N + 2))(dependentBound 'I)]) )  
     }  
.
  strat sym2$SumOK @ ProtocolConfig .
  sd sym2$SumOK :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('InShare$Sum-OK[fixedBound 'M (bound (N + 2))(dependentBound 'I)])
        with
         nf('i : bool  <- read ('InShare$-Sum['M 'p 'i]),
             return ())
        in P
        ]
        { substSym2$SumOK
        }                 
        
  .
  
 strat substSym2$SumOK @ ProtocolConfig .
 sd substSym2$SumOK :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substSym1$SumOK} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])) 
          (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])), 
        P1:Protocol <- keepTwo P 
          (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])) 
          (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]))
        ]{
         select-case-subst-family-r[
           bt:BoolTerm <- neg ('m =T= 0)
         ]{substNFFamiliesGen(
             fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
           )}
       }
             )
 . 
  
  strat sym1$SumOK @ ProtocolConfig .
  sd sym1$SumOK :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('InShare$Sum-OK[fixedBound 'M (bound (N + 2))(dependentBound 'I)])
        with
         nf('i : bool  <- read ('InShare$-Sum['M 'p 'i]),
             return ())
        in P
        ]
        { substSym1$SumOK
        ; applyAlphaNFPr(
            fam ('InShare$Sum-OK[fixedBound 'M (bound (N + 2))(dependentBound 'I)]), 
                         << 'in, 'i >> emptyQidPairList)
        }                 
        
  .
  
  
 strat substSym1$SumOK @ ProtocolConfig .
 sd substSym1$SumOK :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substSym1$SumOK} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])) 
          (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I])), 
        P1:Protocol <- keepTwo P 
          (fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])) 
          (fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]))
        ]{
         select-case-subst-family-r[
           bt:BoolTerm <- ('m =T= 0)
         ]{substNFFamiliesGen(
             fam ('InShare$-Sum[bound (N + 1) bound (N + 2) dependentBound 'I]),
             fam ('InShare$Sum-OK[fixedBound 'M bound (N + 2) dependentBound 'I])
           )}
       }
             )
 .
 
  strat dropInShare$ @ ProtocolConfig .
 sd dropInShare$ :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{dropInShare$} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I])) 
          (fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I])), 
        P1:Protocol <- keepTwo P 
          (fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I])) 
          (fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]))
        ]{
        
         alpha-family-three-top[
           fns:NameWithScripts <- 'InShare$, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'i,
           q4:Qid <- 'm,
           q5:Qid <- 'p,
           q6:Qid <- 'i]  
        ;
         select-case-subst-family-r[
           bt:BoolTerm <- neg ('m =T= N + 1)
         ]{DROP-SUBSUME-families-gen}
        ;
         alpha-family-three-top[
           fns:NameWithScripts <- 'InShare$, 
           q1:Qid <- 'm,
           q2:Qid <- 'p,
           q3:Qid <- 'i,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'i]  
       }
             )
 .     
  strat symInShare$ @ ProtocolConfig .
 sd symInShare$ :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I])
        with
         nf(('i : unit <- read ('In-OK['p 'i]) )
             , return ())
        in P
        ]
        { substNFFamiliesGen(
             fam ('In-OK[((bound (N + 2))(dependentBound 'I))]),
             fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I])
             ) 
        ; applyAlphaNFPr(fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]), 
                         << 'i, 'x >> emptyQidPairList)
        }                          
 .
 strat removeInternalsInputBranch @ ProtocolConfig .
 sd removeInternalsInputBranch := 
          sugar-newNF
        ; absorbFamily(fam ('In-OK[((bound (N + 2))(dependentBound 'I))]))
        ; absorbFamily(fam ('InShare$-OK[((bound (N + 1))(bound (N + 2))(dependentBound 'I))]))
        ; absorbFamilyDeleteEmpty(
            fam ('InShare$Sum-OK[((bound (N + 1))(bound (N + 2))(dependentBound 'I))])
          )
 .
 strat setupSymXor @ ProtocolConfig .
 sd setupSymXor :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('Share[(N + 1) 'B])
        with
         nf(('x : bool <- read ('Share[(N + 1) (fun 'wire0 'B)])) 
            ('xs : bool <- read ('ShareSum[N 'B])) 
            'y : bool <- read ('Share[(N + 1) (fun 'wire1 'B)]), 
            return (ap 'xor pair('x, 'y)))
         
        in (
        change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf(('xm : bool <- read ('Share[(N + 1) 'B])) 
             'xs : bool <- read ('ShareSum[N 'B]), 
             return (ap 'xor pair('xs, 'xm)))
        in 
        P)
       ]
{
        substNF('Share[(N + 1) 'B], 'ShareSum[(N + 1) 'B])
; revertShareXor
; setupIndShareSumXor
; applyAlphaNFPr(
             chn ('ShareSum[(N + 1) 'B]), 
                         << 'x, 'a >> << 'y, 'b >> emptyQidPairList)
                         
; substNFFamilyOne(
   fam ('ShareSum[bound (N + 1) fixedBound 'B]),
   'ShareSum[(N + 1) 'B]
  ) 
; applyRearrangeXor(chn ('ShareSum[(N + 1) 'B]))
; applyRemoveFromGroupCases(
       fam ('Shares[bound 'B]),
       fam ('ShareSum[fixedBound (N + 1) bound 'B])
     )
   ; applyAllSameCases(fam ('ShareSum[fixedBound (N + 1) bound 'B]))  
; psymXor  
; revertShareSumIndXor
; applyAddToGroupCases(
       fam ('Shares[bound 'B]),
       fam ('ShareSum[fixedBound (N + 1) bound 'B])
     ) 
} 
 . 
 strat revertShareXor @ ProtocolConfig . 
 sd revertShareXor := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('Share[(N + 1) 'B])
        with
        nf(('x : bool <- read ('ShareSum[(N + 1) 'B])) 
            'xs : bool <- read ('ShareSum[N 'B]), 
            return (ap 'xor pair('xs, 'x)))
        in P
       ]
     {  substNF('ShareSum[(N + 1) 'B], 'Share[(N + 1) 'B])
     ; applyReturnIdem(chn ('Share[(N + 1) 'B]))
     }
       .
  strat revertShareSumIndXor @ ProtocolConfig .
  sd revertShareSumIndXor :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam ( 'ShareSum[bound (N + 1) fixedBound 'B] )
        with
         (when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'B]), return 's))
;;
(when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'B])) 'xs : bool <- read ('ShareSum[('m -- 1) 'B]), return (ap 'xor pair('xs, 'xm)))
)
        in P
        ]{setupIndShareSumXor}
 .  
strat setupIndShareSumXor @ ProtocolConfig .
sd setupIndShareSumXor := 
   SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'ShareSum,
  blist:List{Bounds} <- bound (N + 1) fixedBound 'B,
  cases':Cases <- 
   nf( ('x : bool <- read ('ShareSum['m (fun 'wire0 'B)])) 
                  ('y : bool <- read ('ShareSum['m (fun 'wire1 'B)])) , 
                  return (ap 'xor pair('x, 'y)))
   ]{     
       
       applyRemoveMergeFromGroupCases(fam ('Shares[bound 'B]), 
    fam ('ShareSum[bound (N + 1) bound 'B])
  )
       ;
       CASE-DISTINCTION-channel[
       cn:ChannelName <- 'ShareSum['M 'B]
       ]{
       substNFFamilyOne(
        fam ('Share[bound (N + 1) fixedBound 'B]),
        'ShareSum['M 'B]
       )
       ; symSS1Xor
       , 
       CASE-DISTINCTION-channel-end-when[
       cn:ChannelName <- 'ShareSum['M 'B]
       ]{
       
        substNFFamilyOne(
        fam ('ShareSum[bound 'M fixedBound 'B]), 
        'ShareSum['M 'B]
        )
; applyAlphaNFPr(
             chn ('ShareSum['M 'B]), 
                         << 'x, 'a >> << 'y, 'b >> emptyQidPairList)
; substNFFamilyOne(
        fam ('Share[bound (N + 1) fixedBound 'B]), 
        'ShareSum['M 'B]
)          
    ; applyRearrangeXor(chn ('ShareSum['M 'B]))          
    ; symSS2Xor
       }}
       ; applyAllSameCases( chn ('ShareSum['M 'B]))
       ; applyAddToGroupCases(fam ('Shares[bound 'B]), 
    fam ('ShareSum[bound (N + 1) bound 'B])
  )
  }
.
strat symSS2Xor @ ProtocolConfig .
  sd symSS2Xor :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum['M 'B])
        with
         nf( ('x : bool <- read ('ShareSum['M (fun 'wire0 'B)])) 
              ('y : bool <- read ('ShareSum['M (fun 'wire1 'B)])) , 
                  return (ap 'xor pair('x, 'y)))
        in P
        ]
        { pSubstFamCaseChn1
        ; applyAlphaNFPr(
             chn ('ShareSum['M 'B]), 
                         << 'xs, 'a >> << 'xm, 'x >> emptyQidPairList)     
        ; pSubstFamCaseChn1
        ; applyAlphaNFPr(
             chn ('ShareSum['M 'B]), 
                         << 'xs, 'b >> << 'xm, 'y >> emptyQidPairList)    
              
        }
.

 strat pSubstFamCaseChn1 @ ProtocolConfig .
sd pSubstFamCaseChn1 :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{pSubstFamCaseChn1} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('ShareSum[bound (N + 1) bound 'B]) ) 
          (chn ('ShareSum['M 'B]) ), 
        P1:Protocol <- keepTwo P 
          (fam ('ShareSum[bound (N + 1) bound 'B]) ) 
          (chn ('ShareSum['M 'B]) )
        ]{
 select-case-subst-family-r-gen[
          bt:BoolTerm <- neg (0 =T= 'm)
        ]{substNFFamilyOne(
           fam ('ShareSum[bound (N + 1) bound 'B]),
           'ShareSum['M 'B]
          )
          }}   
 .  
strat symSS1Xor @ ProtocolConfig .
  sd symSS1Xor :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum['M 'B])
        with
         nf( ('x : bool <- read ('ShareSum['M (fun 'wire0 'B)])) 
                  ('y : bool <- read ('ShareSum['M (fun 'wire1 'B)])) , 
                  return (ap 'xor pair('x, 'y)))
        in P
        ]
        { pSubstFamCaseChn0
        ; applyAlphaNFPr(
             chn ('ShareSum['M 'B]), 
                         << 's, 'x >> emptyQidPairList)
        ; pSubstFamCaseChn0
        ; applyAlphaNFPr(
             chn ('ShareSum['M 'B]), 
                         << 's, 'y >> emptyQidPairList)
        }
  .    
  
strat pSubstFamCaseChn0 @ ProtocolConfig .
sd pSubstFamCaseChn0 :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{pSubstFamCaseChn0} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('ShareSum[bound (N + 1) bound 'B]) ) 
          (chn ('ShareSum['M 'B]) ), 
        P1:Protocol <- keepTwo P 
          (fam ('ShareSum[bound (N + 1) bound 'B]) ) 
          (chn ('ShareSum['M 'B]) )
        ]{
 select-case-subst-family-r-gen[
          bt:BoolTerm <- 0 =T= 'm
        ]{substNFFamilyOne(
           fam ('ShareSum[bound (N + 1) bound 'B]),
           'ShareSum['M 'B]
          )
          }}   
 . 
  strat psymXor @ ProtocolConfig .
  sd psymXor :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
      SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'B)])) 
             'y : bool <- read ('ShareSum[(N + 1) (fun 'wire1 'B)]), 
             return (ap 'xor pair('x, 'y)))
        in P
        ]
         {
        substNFFamilyOne(
         fam ('ShareSum[fixedBound (N + 1) bound 'B]),
         'ShareSum[(N + 1) 'B]
        )
        ; applyAlphaNFPr(
             chn ('ShareSum[(N + 1) 'B]), 
                         << 'xs, 'x >> << 'xm, 'a >> emptyQidPairList)
        ;
        substNFFamilyOne(
         fam ('ShareSum[fixedBound (N + 1) bound 'B]),
         'ShareSum[(N + 1) 'B]
        )
        ; applyAlphaNFPr(
             chn ('ShareSum[(N + 1) 'B]), 
                         << 'xs, 'y >> << 'xm, 'b >> emptyQidPairList)   
                                     
        }             
        
  .

strat setupSymAnd @ ProtocolConfig .
 sd setupSymAnd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change 
        chn ('Share[(N + 1) 'B])
        with
        nf(('bs : bool <- read ('CtrbSum[(N + 1) (N + 1) 'B])) 
            'xs : bool <- read ('ShareSum[N 'B]), return 'bs)
        in (
        change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf(('xm : bool <- read ('Share[(N + 1) 'B])) 
             'xs : bool <- read ('ShareSum[N 'B]), 
             return (ap 'xor pair('xs, 'xm)))
        in 
        P)
       ]{
         substNF('Share[(N + 1) 'B], 'ShareSum[(N + 1) 'B])
; revertShareAnd 
; addColAndColSum
*** turn the family ShareSum(up to N + 1, fixed B) into closed form, reads from ColSum
; CONG-NEW-NF{setupIndSSAnd}
; substNFFamilyOne(
    fam ('ShareSum[bound (N + 1) fixedBound 'B]),
    'ShareSum[(N + 1) 'B]
  )
*** put  the family ShareSum(up to N + 1, fixed B) back in its original form 
; revertShareSumInductiveAnd 
*** substs in ShareSum[N+1 B]
; symSSColSumAnd
*** change col to inductive form
; changeColToInductive
*** add Row and RowSum
; addRowAndRowSum
*** here we get ColSum to read from RowSum!
; applyGroupFamiliesNew(
    fam ('RowSum[bound (N + 2) bound (N + 2)]), 
    fam ('ColSum[bound (N + 2) bound (N + 2)])
  )
; CONG-NEW-NF{setupIndColRow}
  
; applyUngroupFamiliesNew(
    fam ('RowSum[bound (N + 2) bound (N + 2)]), 
    fam ('ColSum[bound (N + 2) bound (N + 2)])
  ) 
  
; addSqr
; symSqrInSSNPlus1 
*** we need to get ColSum back to the inductive form first
; revertColSumInductive
; symSqrToInductive 
*** ColSum RowSum are unused and we can absorb them
; absorbFamily( fam ('ColSum[bound (N + 2) bound (N + 2)]) )
; absorbFamily( fam ('RowSum[bound (N + 2) bound (N + 2)]) )
*** next proof step says that we can unsplit Share upto bound 'B
*** but we can choose to keep them separated!
*** last thing to show is that we can turn Sqr to a closed form involving and
; symSqrToClosedAnd
*** we can discard Row and Col
; absorbFamily( fam ('Col[bound (N + 2) bound (N + 2)]) )
; absorbFamilyDeleteEmpty( fam ('Row[bound (N + 2) bound (N + 2)]) )
*** then we can subst Sqr(N+1) in 'ShareSum[(N+1) 'B] to get what we wanted
; substNFFamilyOne(
    fam ('Sqr[bound (N + 2)]),
    'ShareSum[(N + 1) 'B]
  )
  ; applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 'xs, 'x >> << 'ys, 'y >> emptyQidPairList)
*** discard Sqr
; absorbFamilyDeleteEmpty( fam ('Sqr[bound (N + 2)]) )  
       }
 .      
  strat revertShareAnd @ ProtocolConfig .
 sd revertShareAnd := 
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
        chn ('Share[(N + 1) 'B])
       with
 nf(('x : bool <- read ('ShareSum[(N + 1) 'B])) 'xs : bool
    <- read ('ShareSum[N 'B]), return (ap 'xor pair('xs, 'x)))
      in
      P]
      { substNF('ShareSum[(N + 1) 'B], 'Share[(N + 1) 'B])
      ; applyReturnIdem(chn ('Share[(N + 1) 'B]))
      }
 .
  strat addColAndColSum @ ProtocolConfig .
 sd addColAndColSum :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'Col
         typed bool
         params ('i 'j)
                ( (bound (N + 2)) (bound (N + 2)) )  
         assigned
          nf('c : bool  <- read ('CtrbSum['i 'j 'B]),
             return 'c)
         in
         (addInternalFamily
           'ColSum
         typed bool
         params ('i 'j)
                ( (bound (N + 2)) (bound (N + 2)) )  
         assigned
          (when ('i =T= 0) -->
            nf('c : bool <- read ('Col[0 'j]), return 'c)
          )
          ;;
          (when (neg ('i =T= 0)) -->
            nf(  
              ('bs : bool <- read ('ColSum[('i -- 1) 'j]))
              ('bi : bool <- read ('Col['i 'j])),
              return (ap 'xor pair('bs, 'bi))
            )
          )
         in P)
         ]
          { absorbFamily(fam ('Col[(bound (N + 2)) (bound (N + 2))]) )
          ; absorbFamilyDeleteEmpty(fam ('ColSum[(bound (N + 2)) (bound (N + 2))]) )
          }
        
 .
 strat setupIndSSAnd @ ProtocolConfig .
sd setupIndSSAnd := 
SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'ShareSum,
  blist:List{Bounds} <- bound (N + 1) fixedBound 'B,
  cases':Cases <- 
   nf('c : bool <- read ('ColSum['m (N + 1)]), return 'c)
   ]       
       
{ CASE-DISTINCTION-channel[
   cn:ChannelName <- 'ShareSum['M 'B]
  ]{
  substNFFamilyOne(
   fam ('Share[bound (N + 1) fixedBound 'B]),
   'ShareSum['M 'B]
  )
  ; symSSInd1And
  , 
  CASE-DISTINCTION-channel-end-when[
   cn:ChannelName <- 'ShareSum['M 'B]
  ]{
  substNFFamilyOne(
   fam ('Share[bound (N + 1) fixedBound 'B]),
   'ShareSum['M 'B]
  )
  ;
  substNFFamilyOne(
   fam ('ShareSum[bound 'M fixedBound 'B]),
   'ShareSum['M 'B]
  )
  ; symSSInd2And
  }
  }
 ; applyAllSameCases(chn ('ShareSum['M 'B]))  
}      
.
  strat symSSInd2And @ ProtocolConfig .
  sd symSSInd2And :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum['M 'B])
        with
         nf('c : bool <- read ('ColSum['M (N + 1)]), return 'c)
        in P
        ] 
        {
        substFamCaseChnColSumSSAnd2
        ; substNFFamilyOne(
          fam ('Col[bound (N + 2) bound (N + 2)]),
          'ShareSum['M 'B]
         )
        ; applyAlphaNFPr(
            chn ('ShareSum['M 'B]), 
                         << 'c, 't >> emptyQidPairList) 
        ; applyAlphaNFPr(
            chn ('ShareSum['M 'B]), 
                         << 'bs, 'c >> emptyQidPairList)   
        ; applyAlphaNFPr(
            chn ('ShareSum['M 'B]), 
                         << 't, 'bs >> emptyQidPairList)  
        }                                                
  .      
  strat symSSInd1And @ ProtocolConfig .
  sd symSSInd1And :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum['M 'B])
        with
         nf('c : bool <- read ('ColSum['M (N + 1)]), return 'c)
        in P
        ]
        { substFamCaseChnColSumSSAnd
        ; substNFFamilyOne(
          fam ('Col[bound (N + 2) bound (N + 2)]),
          'ShareSum['M 'B]
         )
        ; applyAlphaNFPr(
            chn ('ShareSum['M 'B]), 
                         << 'c, 'bs >> emptyQidPairList) 
        }
        
 .
 strat substFamCaseChnColSumSSAnd2 @ ProtocolConfig .
sd substFamCaseChnColSumSSAnd2 :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substFamCaseChnColSumSSAnd2} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('ColSum[bound (N + 2) bound (N + 2)]) ) 
          (chn ('ShareSum['M 'B])), 
        P1:Protocol <- keepTwo P 
          (fam ('ColSum[bound (N + 2) bound (N + 2)])) 
          (chn ('ShareSum['M 'B]) )
        ]{
 select-case-subst-family-r-gen[
          bt:BoolTerm <- neg (0 =T= 'i)
        ]{substNFFamilyOne(
           fam ('ColSum[bound (N + 2) bound (N + 2)]), 
           'ShareSum['M 'B]
          )} 
        }       
.
strat substFamCaseChnColSumSSAnd @ ProtocolConfig .
sd substFamCaseChnColSumSSAnd :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substFamCaseChnColSumSSAnd} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('ColSum[bound (N + 2) bound (N + 2)]) ) 
          (chn ('ShareSum['M 'B])), 
        P1:Protocol <- keepTwo P 
          (fam ('ColSum[bound (N + 2) bound (N + 2)])) 
          (chn ('ShareSum['M 'B]) )
        ]{
 select-case-subst-family-r-gen[
          bt:BoolTerm <- 0 =T= 'i
        ]{substNFFamilyOne(
           fam ('ColSum[bound (N + 2) bound (N + 2)]), 
           'ShareSum['M 'B]
          )} 
        }       
.
  
 strat revertShareSumInductiveAnd @ ProtocolConfig .
sd revertShareSumInductiveAnd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <-
        change fam ('ShareSum[bound (N + 1) fixedBound 'B])
        with
        (when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'B]), return 's))
;;
(when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'B])) 'xs : bool <- read ('ShareSum[('m -- 1) 'B]), return (ap
    'xor pair('xs, 'xm)))
)
        in P
       ] {CONG-NEW-NF{setupIndSSAnd}}
.       
strat symSSColSumAnd @ ProtocolConfig .
sd symSSColSumAnd :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{symSSColSumAnd} 
     :
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
      ( SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf('c : bool  <- read ('ColSum[(N + 1) (N + 1)]),
             return 'c)
        in P
        ]
        { substFamCaseChnColSumSSAnd3
        ; substNFFamilyOne(
           fam ('Col[bound (N + 2) bound (N + 2)]),
           'ShareSum[(N + 1) 'B]
        )
        ; applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 'c, 't >> emptyQidPairList) 
        ; applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 'bs, 'c >> emptyQidPairList)   
        ; applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 't, 'bs >> emptyQidPairList) 
                         } 
      )  
.        
strat substFamCaseChnColSumSSAnd3 @ ProtocolConfig .
sd substFamCaseChnColSumSSAnd3 :=
  match pConf s.t. startsWithNew pConf
     ? CONG-NEW-NF{substFamCaseChnColSumSSAnd3} 
     : matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using CONG-COMP-RIGHT[
        Q:Protocol  <- removeTwo P 
          (fam ('ColSum[bound (N + 2) bound (N + 2)]) ) 
          (chn ('ShareSum[(N + 1) 'B])), 
        P1:Protocol <- keepTwo P 
          (fam ('ColSum[bound (N + 2) bound (N + 2)])) 
          (chn ('ShareSum[(N + 1) 'B]) )
        ]{
 select-case-subst-family-r-gen[
          bt:BoolTerm <- neg (0 =T= 'i)
        ]{substNFFamilyOne(
           fam ('ColSum[bound (N + 2) bound (N + 2)]), 
           'ShareSum[(N + 1) 'B]
          )} 
        }       
. 
strat changeColToInductive @ ProtocolConfig .
 sd changeColToInductive :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf 
            by pConf 
            using 
            SYM[
            Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change ( fam ('Col[bound (N + 2) bound (N + 2)]) )
             with 
              (when ('j =T= 0) --> 
                nf('c : bool  <- read ('Ctrb['i 0 'B]),
                   return 'c)
              )
              ;;
              (when (neg ('j =T= 0)) --> 
                nf(('bs : bool <- read ('Col['i ('j -- 1)])) 
                    'bj : bool <- read ('Ctrb['i 'j 'B]),
                    return (ap 'xor pair('bs, 'bj)))
              )
             in P
            ] {
         indProofCol
         }
 .  
 
strat indProofCol @ ProtocolConfig .
sd indProofCol :=
  CONG-NEW-NF{
       SINGLE-INDUCTION-new-R[
  idx:Qid <- 'J,
  q:Qid <- 'j,
  cn:ChannelName <- 'Col,
  blist:List{Bounds} <- bound (N + 2) (bound (N + 2)),
  cases':Cases <- 
   nf('c : bool <- read ('CtrbSum['i 'j 'B]), return 'c)
   ]
       {
       ***now the induction proof
       CASE-DISTINCTION-one-R[
        fns:NameWithScripts <- 'Col,
        blist:List{Bounds} <- bound (N + 2) fixedBound 'J
        ]{
         sym1ColAnd, 
         CASE-DISTINCTION-one-R-end-when[
        fns:NameWithScripts <- 'Col,
        blist:List{Bounds} <- bound (N + 2) fixedBound 'J
        ]{
         
         substNFFamiliesGen(
          fam ('Col[bound (N + 2) bound 'J]),
          fam ('Col[bound (N + 2) fixedBound 'J])
         )
         ; sym2ColAnd
         }}
         ; applyAllSameCases( fam ('Col[bound (N + 2) fixedBound 'J]) )
         }}
.          
strat sym2ColAnd @ ProtocolConfig .
sd sym2ColAnd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
        Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
        fam ('Col[bound (N + 2) fixedBound 'J])
       with nf('c : bool <- read ('CtrbSum['i 'J 'B]), return 'c)
       in P 
       ] 
       { substFamCaseFam(
           fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]), 
           fam ('Col[bound (N + 2) fixedBound 'J]), 
           neg (0 =T= 'm), 
           nf(('b : bool <- read ('Ctrb['i 'J 'B])) 's : bool <- read ('CtrbSum['i ('J -- 1)
    'B]), return (ap 'xor pair('s, 'b)))
         )
       ; applyAlphaNFPr(
            fam ('Col[bound (N + 2) fixedBound 'J]), 
                         << 'b, 'bj >> << 's, 'c >> emptyQidPairList)      
        }                 
.       
strat sym1ColAnd @ ProtocolConfig .
sd sym1ColAnd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
        fam ('Col[bound (N + 2) fixedBound 'J])
       with nf('c : bool <- read ('CtrbSum['i 'J 'B]), return 'c)
       in P 
       ] 
       { substFamCaseFam(
           fam ('CtrbSum[bound (N + 2) bound (N + 2) fixedBound 'B]), 
           fam ('Col[bound (N + 2) fixedBound 'J]), 
           0 =T= 'm, 
           nf('b : bool <- read ('Ctrb['i 0 'B]), return 'b)
         )
      ; applyAlphaNFPr(
            fam ('Col[bound (N + 2) fixedBound 'J]), 
                         << 'b, 'c >> emptyQidPairList)    
       } 
.                 
  strat addRowAndRowSum @ ProtocolConfig .
 sd addRowAndRowSum :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'Row
         typed bool
         params ('i 'j)
                ( (bound (N + 2)) (bound (N + 2)) )  
         assigned
          (when ('i =T= 0) -->
            nf('c : bool <- read ('Ctrb[0 'j 'B]), return 'c)
          )
          ;;
          (when (neg ('i =T= 0)) -->
            nf(  
              ('r : bool <- read ('Row[('i -- 1) 'j]))
              ('bi : bool <- read ('Ctrb['i 'j 'B])),
              return (ap 'xor pair('r, 'bi))
            )
          )
         in
         (addInternalFamily
           'RowSum
         typed bool
         params ('i 'j)
                ( (bound (N + 2)) (bound (N + 2)) )  
         assigned
          (when ('j =T= 0) -->
            nf('r : bool <- read ('Row['i 0]), return 'r)
          )
          ;;
          (when (neg ('j =T= 0)) -->
            nf(  
              ('r : bool <- read ('RowSum['i ('j -- 1)]))
              ('bj : bool <- read ('Row['i 'j])),
              return (ap 'xor pair('r, 'bj))
            )
          )
         in P)
         ]
          { absorbFamily(fam ('Row[(bound (N + 2)) (bound (N + 2))]) )
          ; absorbFamily(fam ('RowSum[(bound (N + 2)) (bound (N + 2))]) )
          }
        
 .

 strat setupIndColRow @ ProtocolConfig .
sd setupIndColRow := 
       SINGLE-INDUCTION-new[
  idx:Qid <- 'X,
  q:Qid <- 'i,
  cn:ChannelName <- 'Comp['RowSum 'ColSum],
  P2:Protocol <- wantColRowSum
 ]
{
        *** RowSum stays unchanged, so this distinction is fine here!
       CASE-DISTINCTION-one-R[
        fns:NameWithScripts <- 'ColSum,
        blist:List{Bounds} <- fixedBound 'X bound (N + 2)
       ]
       {
       *** 'X = 0
        addRowSumGroup
  *** part one, induction
; setupIndRowPartOneZeroCase
; applyDropName(fam ('HiddenGroup[bound 'X bound (N + 2)]) )
*** now we get to part two, another induction
; applyGroupFamiliesNew(
    fam ('RowSum[fixedBound 'X bound (N + 2)]), 
    fam ('ColSum[fixedBound 'X bound (N + 2)])
  )
  *** sym + ind
; setupIndSymPartTwo  
; applyUngroupFamiliesNew(
    fam ('RowSum[fixedBound 'X bound (N + 2)]), 
    fam ('ColSum[fixedBound 'X bound (N + 2)])
  )
       ,
       CASE-DISTINCTION-one-R-end-when[
        fns:NameWithScripts <- 'ColSum,
        blist:List{Bounds} <- fixedBound 'X bound (N + 2)
       ]
       { 
       *** again the hack to make induction work
  addRowSumGroup
  
 *** part one, induction
; setupIndRowPartOneNZCase
; applyDropName(fam ('HiddenGroup[bound 'X bound (N + 2)]) )
*** now we get to part two, another induction
; applyGroupFamiliesNew(
    fam ('RowSum[fixedBound 'X bound (N + 2)]), 
    fam ('ColSum[fixedBound 'X bound (N + 2)])
  )
; setupIndColRowPartTwoNZ  
; applyUngroupFamiliesNew(
    fam ('RowSum[fixedBound 'X bound (N + 2)]), 
    fam ('ColSum[fixedBound 'X bound (N + 2)])
  )
       
       }
       }
       ; applyAllSameCases(fam ('ColSum[fixedBound 'X bound (N + 2)]))
}
.
op wantColRowSum : -> Protocol .
eq wantColRowSum =
(family 'ColSum[bound (N + 2) bound (N + 2)] 'i 'j
bound (N + 2) bound (N + 2)
::=
nf('r : bool <- read ('RowSum['i 'j]), return 'r)
)
||
(family 'RowSum[bound (N + 2) bound (N + 2)] 'i 'j
bound (N + 2) bound (N + 2)
::=
(when (0 =T= 'j) -->
nf('r : bool <- read ('Row['i 0]), return 'r))
;;
(when neg (0 =T= 'j) -->
nf(('bj : bool <- read ('Row['i 'j])) 'r : bool <- read ('RowSum['i ('j -- 1)]),
    return (ap 'xor pair('r, 'bj)))
)
)
.
*** same trick, make it a group
 strat addRowSumGroup @ ProtocolConfig .
 sd addRowSumGroup := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           ( fam ('RowSum[bound 'X bound (N + 2)]) )
           
         named 'HiddenGroup 
         params ('i 'j) (bound 'X bound (N + 2)) 
         in P
       ]
       {
        applyDropName(fam ('HiddenGroup[bound 'X bound (N + 2)]) )
        
       } ***sym
       )
 .     
 *** first induction for row on 0 case
strat setupIndRowPartOneZeroCase @ ProtocolConfig .
sd setupIndRowPartOneZeroCase := 
       SINGLE-INDUCTION-new-R[
  idx:Qid <- 'Y,
  q:Qid <- 'j,
  cn:ChannelName <- 'RowSum,
  blist:List{Bounds} <- fixedBound 'X bound (N + 2),
  cases':Cases <- 
   nf('c : bool <- read ('ColSum[0 'j]), return 'c)
   ]{ 
      CASE-DISTINCTION-channel[
       cn:ChannelName <- 'RowSum['X 'Y]
      ] {
      substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'i)
      )
      ; symRowSumPart1Branch1,
      CASE-DISTINCTION-channel-end-when[
       cn:ChannelName <- 'RowSum['X 'Y]
      ] {
      substNFFamilyOne(
       fam ('RowSum[fixedBound 'X bound 'Y]),
       'RowSum['X 'Y]
      )
      ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'c, 'cs >> emptyQidPairList)
      ; substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'i)
      )
      ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'c, 'bj >> emptyQidPairList)
      ; substNFFamilyOne(
        fam ('ColSum[fixedBound 'X bound (N + 2)]),
        'RowSum['X 'Y]
      )
      ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'c, 'bs >> emptyQidPairList)
      ; symRowSumPart1Branch2      
      }
      }
      ; applyAllSameCases( chn ('RowSum['X 'Y]) )
      }
.
strat symRowSumPart1Branch2 @ ProtocolConfig .
sd symRowSumPart1Branch2 :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('RowSum['X 'Y])
        with nf('c : bool <- read ('ColSum[0 'Y]), return 'c)
        in P
       ] 
       {
       substNFFamilyOne(
         fam ('ColSum[fixedBound 'X bound (N + 2)]),
         'RowSum['X 'Y]
       )   
       ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'j)
        ) }
.
strat symRowSumPart1Branch1 @ ProtocolConfig .
sd symRowSumPart1Branch1 :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('RowSum['X 'Y])
        with nf('c : bool <- read ('ColSum[0 'Y]), return 'c)
        in P
       ] 
       { substNFFamilyOne(
         fam ('ColSum[fixedBound 'X bound (N + 2)]),
         'RowSum['X 'Y]
       )   
       ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'j)
      )}
.       
strat setupIndSymPartTwo @ ProtocolConfig .
sd setupIndSymPartTwo :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
       fam ('Comp['RowSum 'ColSum][fixedBound 'X bound (N + 2)])
       with wantColRowSumPartTwo
       in P
       ]
       { setupIndColRowPartTwo }
 .       
 op wantColRowSumPartTwo : -> Protocol .
eq wantColRowSumPartTwo = 
(family 'ColSum[fixedBound 'X bound (N + 2)] 'i 'j
fixedBound 'X bound (N + 2)
::=
nf('r : bool <- read ('RowSum['X 'j]), return 'r)
)
||
(family 'RowSum[fixedBound 'X bound (N + 2)] 'i 'j
fixedBound 'X bound (N + 2)
::=
(when (0 =T= 'j) -->
nf('r : bool <- read ('Row['X 0]), return 'r))
;;
when neg (0 =T= 'j) -->
nf(('bj : bool <- read ('Row['X 'j])) 'r : bool <- read ('RowSum['X ('j -- 1)]),
    return (ap 'xor pair('r, 'bj)))
)
.
strat setupIndColRowPartTwo @ ProtocolConfig .
sd setupIndColRowPartTwo := 
       SINGLE-INDUCTION-new[
  idx:Qid <- 'Y,
  q:Qid <- 'j,
  cn:ChannelName <- 'Comp['RowSum 'ColSum],
  P2:Protocol <- knowColRowSumPartTwo
 ]{ 
       *** induction starts here
         symColSumSameCasesPartTwo
       ; applyMergeCasesChannelGroup('RowSum['X 'Y], 'ColSum['X 'Y])
       ; CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'CGroup
       ]{
       substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'i)
      )
       ; symRowToCol0Part2
       ; substNF('RowSum['X 'Y], 'ColSum['X 'Y])
       ; symRowToColSum0Part2
       ; applyAlphaAssumChn('RowSum['X 'Y], 'X)
      , CASE-DISTINCTION-one-end-when[
          fns:NameWithScripts <- 'CGroup
       ]{
         substNFFamilyOne(
         fam ('RowSum[fixedBound 'X bound 'Y]),
         'RowSum['X 'Y]
        ) 
        ; substNFFamilyOne(
         fam ('ColSum[fixedBound 'X bound 'Y]),
         'RowSum['X 'Y]
        ) 
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                         << 'c, 'bs >> emptyQidPairList)
        ; substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'i)
      ) 
      ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                         << 'c, 'bj >> emptyQidPairList) 
      ; symRowToColSumNzPart2                
      ; substNF('RowSum['X 'Y], 'ColSum['X 'Y])
      ; lastSymBaseCase
      ; applyAlphaAssumChn('RowSum['X 'Y], 'X)
      ; applyAlphaAssumChn('ColSum['X 'Y], 'X)
        }   
       }
      ; applyAllSameCases(fam ('CGroup[nil]))
      ; applyDropName(fam ('CGroup[nil]))
  }
 . 
strat lastSymBaseCase @ ProtocolConfig .
sd lastSymBaseCase :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
       chn ('RowSum['X 'Y]) with 
       nf('c : bool <- read ('ColSum['X 'Y]), return 'c)
       in P          
       ]{
       substNF('ColSum['X 'Y], 'RowSum['X 'Y])}
.  
strat symRowToColSumNzPart2 @ ProtocolConfig .
sd symRowToColSumNzPart2 := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
       chn ('RowSum['X 'Y]) with 
       nf('c : bool <- read ('Col['X 'Y]), return 'c)
       in P          
       ]
       { substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'j)
      )
      ; applyAlphaAssumChn('RowSum['X 'Y], 'X)
      } 
.
strat symRowToColSum0Part2 @ ProtocolConfig .
sd symRowToColSum0Part2 := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
        Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
       chn ('RowSum['X 'Y]) with 
       nf('c : bool <- read ('ColSum['X 'Y]), return 'c)
       in P          
       ]
       { substNF('ColSum['X 'Y], 'RowSum['X 'Y])
       }
.
strat symRowToCol0Part2 @ ProtocolConfig .
sd symRowToCol0Part2 := 
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using SYM[
        Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change
       chn ('RowSum['X 'Y]) with 
       nf('c : bool <- read ('Col[0 'Y]), return 'c)
       in P          
       ]
       {
       substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'j)
      )}
.
 op knowColRowSumPartTwo : -> Protocol .
eq knowColRowSumPartTwo = 
 (family 'RowSum[fixedBound 'X bound (N + 2)]
    'i 'j
fixedBound 'X bound (N + 2)
::=
nf('c : bool <- read ('ColSum[0 'j]), return 'c)
)
||
(family 'ColSum[fixedBound 'X bound (N + 2)]
    'i 'j
fixedBound 'X bound (N + 2)
::=
nf('c : bool <- read ('Col[0 'j]), return 'c)
)
.
strat symColSumSameCasesPartTwo @ ProtocolConfig .
sd symColSumSameCasesPartTwo :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ColSum['X 'Y])
        with
         (when ('Y =T= 0) --> 
           nf('r : bool <- read ('RowSum['X 'Y]), return 'r))
         ;;
         (when neg ('Y =T= 0) --> 
           nf('r : bool <- read ('RowSum['X 'Y]), return 'r))
        in P
        ]{applyAllSameCases(chn ('ColSum['X 'Y]))}
.        
*** first induction for row on non-zero case
strat setupIndRowPartOneNZCase @ ProtocolConfig .
sd setupIndRowPartOneNZCase := 
     SINGLE-INDUCTION-new-R[
  idx:Qid <- 'Y,
  q:Qid <- 'j,
  cn:ChannelName <- 'RowSum,
  blist:List{Bounds} <- fixedBound 'X bound (N + 2),
  cases':Cases <- 
   nf('c : bool <- read ('ColSum['X 'j]), return 'c)
   ]{   
       *** we need to use it, so ungroup it
         applyDropName(fam ('HiddenGroup[bound 'X bound (N + 2)]) )
       ; CASE-DISTINCTION-channel[
          cn:ChannelName <- 'RowSum['X 'Y]
       ]{
       *** Y = 0
       substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'i)
      )
      *** now a sym proof
      ; symRSYZero
      ,
       CASE-DISTINCTION-channel-end-when[
          cn:ChannelName <- 'RowSum['X 'Y]
       ]{
       *** Y /= 0
        substNFFamilyOne(
          fam ('RowSum[fixedBound 'X bound 'Y]),
          'RowSum['X 'Y]
        ) 
        ;        
        substNFFamilyOne(
          fam ('ColSum[fixedBound 'X bound (N + 2)]),
          'RowSum['X 'Y]
        ) 
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'bi, 'bc >> emptyQidPairList)
        ; substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'i)
      )  
      ; applyRearrangeXor(chn ('RowSum['X 'Y]))  
      ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'r, 'br >> emptyQidPairList)
      ; substNFFamilyOne(
         fam ('ColSum[bound 'X bound (N + 2)]), 
         'RowSum['X 'Y]
        ) 
       *** and again the rest is a sym proof 
        ; symRSYNZero      
        }
       }
       ; applyAllSameCases(chn ('RowSum['X 'Y]))
       *** get back to original structure
       ; addRowSumGroup
     } *** induction end  
.            
 strat symRSYNZero @ ProtocolConfig .
 sd symRSYNZero :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change
         chn( 'RowSum['X 'Y] )
         with 
         nf('c : bool <- read ('ColSum['X 'Y]), return 'c)
         in
         P
       ]
       { substNFFamilyOne(
       fam ('ColSum[fixedBound 'X bound (N + 2)]), 
        'RowSum['X 'Y]
        )
        ; substNFFamilyOne(
         fam ('ColSum[bound 'X bound (N + 2)]), 
         'RowSum['X 'Y]
        ) 
        ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'j)
        )
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'bj, 'bi >> emptyQidPairList)
         ; substFamCaseChn(
        fam ('RowSum[bound 'X bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'j)
        ) 
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'bj, 'br >> << 'bs, 'bc >> emptyQidPairList) 
       }      
 .
 strat symRSYZero @ ProtocolConfig .
 sd symRSYZero :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change
         chn( 'RowSum['X 'Y] )
         with 
         nf('c : bool <- read ('ColSum['X 'Y]), return 'c)
         in
         P
       ]
       { substNFFamilyOne(
       fam ('ColSum[fixedBound 'X bound (N + 2)]), 
        'RowSum['X 'Y]
        )
        ;
        *** ind hypo
        substNFFamilyOne(
         fam ('ColSum[bound 'X bound (N + 2)]), 
         'RowSum['X 'Y]
        ) 
        ; applyAlphaAssumChn('RowSum['X 'Y], 'Y)
        
        ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'j)
        )
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
            << 'c, 'bi >> emptyQidPairList)
        ; substFamCaseChn(
        fam ('RowSum[bound 'X bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'j)
        )
        }
       
.   

strat setupIndColRowPartTwoNZ @ ProtocolConfig .
sd setupIndColRowPartTwoNZ := 
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
       fam ('Comp['RowSum 'ColSum][fixedBound 'X bound (N + 2)])
       with wantColRowSumPartTwoNZ
       in P
       ]
 {     
       SINGLE-INDUCTION-new[
  idx:Qid <- 'Y,
  q:Qid <- 'j,
  cn:ChannelName <- 'Comp['RowSum 'ColSum],
  P2:Protocol <- knowColRowSumPartTwoNZ
 ]{      symColSumSameCasesPartTwo
       ; applyMergeCasesChannelGroup('RowSum['X 'Y], 'ColSum['X 'Y])
       ; CASE-DISTINCTION-one[
          fns:NameWithScripts <- 'CGroup
       ]{
        substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'i)
        ) 
        ; symBranchYZeroAnd  
        ; substNF('RowSum['X 'Y], 'ColSum['X 'Y])
        ; symForRowSumPart2Zero
        ; symForColSumPart2Zero
        ,
       CASE-DISTINCTION-one-end-when[
          fns:NameWithScripts <- 'CGroup
       ]{
         applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                         << 'r, 'new >> emptyQidPairList)
       ; substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'i)
        ) 
        ; substNFFamilyOne(
          fam ('RowSum[fixedBound 'X bound 'Y]),
          'RowSum['X 'Y]
        ) 
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                         << 'bi, 'b >> << 'r, 'br >> emptyQidPairList)
                         
        ; substNFFamilyOne(
         fam ('ColSum[fixedBound 'X bound 'Y]),
        'RowSum['X 'Y]
        ) 
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                         << 'bi, 'bc >> emptyQidPairList)
                        
        ; substNFFamilyOne(
         fam ('ColSum[bound 'X bound (N + 2)]),
        'RowSum['X 'Y]
        )
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                         << 'r, 'bs >> emptyQidPairList)
        ; applyRearrangeXor(chn ('RowSum['X 'Y]))                 
        ; symRSPartTwoNZ
        ; substNF('RowSum['X 'Y], 'ColSum['X 'Y])   
        ; symForRowSumPart2Zero             
       }
       }
       ; applyAllSameCases(fam ('CGroup[nil]))
       ; applyDropName(fam ('CGroup[nil]))
   } *** induction end    
 } *** sym end 
 .
 strat symRSPartTwoNZ @ ProtocolConfig .
 sd symRSPartTwoNZ :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change chn ('RowSum['X 'Y])
        with
        nf(('bi : bool <- read ('Col['X 'Y])) 
            'bs : bool <- read ('ColSum[('X -- 1) 'Y]), 
            return (ap 'xor pair('bs, 'bi)))
        in P
       ] 
       { substNFFamilyOne(
         fam ('ColSum[bound 'X bound (N + 2)]),
        'RowSum['X 'Y]
        )
       ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'j)
      ) 
      ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                        << 'bj, 'b >> << 'bs, 'bc >> emptyQidPairList)
      ; substFamCaseChn(
        fam ('RowSum[bound 'X bound (N + 2)]), 
        'RowSum['X 'Y], neg (0 =T= 'j)
      )   
       ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                        << 'bj, 'br >> << 'r, 'bs >> emptyQidPairList)        
       }
 .
 
 strat symForRowSumPart2Zero @ ProtocolConfig .
 sd symForRowSumPart2Zero :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change chn ('RowSum['X 'Y]) 
       with 
        nf( 'c : bool <- read ('ColSum['X 'Y]),
             return 'c)
       in P
       ] 
       {substNF('ColSum['X 'Y], 'RowSum['X 'Y])}
.     
strat symForColSumPart2Zero @ ProtocolConfig .
 sd symForColSumPart2Zero :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change chn ('ColSum['X 'Y]) 
       with 
        nf(('bi : bool <- read ('Col['X 'Y])) 'bs : bool <- read ('ColSum[('X -- 1) 'Y]),
    return (ap 'xor pair('bs, 'bi)))
       in P
       ] 
       { applyAlphaAssumChn('ColSum['X 'Y], 'Y)}
.        
 strat symBranchYZeroAnd @ ProtocolConfig .
 sd symBranchYZeroAnd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change chn ('RowSum['X 'Y]) 
       with 
        nf( ('bi : bool <- read ('Col['X 0]))
              'bs : bool <- read ('ColSum[('X -- 1) 0 ]),
          return (ap 'xor pair('bs, 'bi)))
       in P
       ] 
       {
       substNFFamilyOne(
        fam ('ColSum[bound 'X bound (N + 2)]),
        'RowSum['X 'Y]
       )
       ; substFamCaseChn(
        fam ('RowSum[bound 'X bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'j)
        ) 
       ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowSum['X 'Y], (0 =T= 'j)
       )
        ; applyAlphaNFPr(
            chn ('RowSum['X 'Y]), 
                         << 'c, 'bi >> emptyQidPairList)
        }              
.       

op wantColRowSumPartTwoNZ : -> Protocol .
eq wantColRowSumPartTwoNZ = 
(family 'ColSum[fixedBound 'X bound (N + 2)] 'i 'j
fixedBound 'X bound (N + 2)
::=
nf('r : bool <- read ('RowSum['X 'j]), return 'r)
)
||
(family 'RowSum[fixedBound 'X bound (N + 2)] 'i 'j
fixedBound 'X bound (N + 2)
::=
(when (0 =T= 'j) -->
nf('r : bool <- read ('Row['X 0]), return 'r))
;;
when neg (0 =T= 'j) -->
nf(('bj : bool <- read ('Row['X 'j])) 'r : bool <- read ('RowSum['X ('j -- 1)]),
    return (ap 'xor pair('r, 'bj)))
)
.
op knowColRowSumPartTwoNZ : -> Protocol .
eq knowColRowSumPartTwoNZ = 
(family 'ColSum[fixedBound 'X bound (N + 2)] 'i 'j
fixedBound 'X bound (N + 2)
::=
nf(('bi : bool <- read ('Col['X 'j])) 'bs : bool <- read ('ColSum[('X -- 1) 'j]), return (ap 'xor
    pair('bs, 'bi)))
)
||
(
family 'RowSum[fixedBound 'X bound (N + 2)] 'i 'j
fixedBound 'X bound (N + 2)
::=
nf('c : bool <- read ('ColSum['X 'j]), return 'c)
)
.

strat addSqr @ ProtocolConfig .
sd addSqr :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'Sqr
         typed bool
         params ('i)
                (bound (N + 2))
         assigned
          nf('c : bool  <- read ('ColSum['i 'i]),
             return 'c)
         in P]{
         absorbFamily( fam ('Sqr[(bound (N + 2))]) )
         }
 .        
strat symSqrInSSNPlus1 @ ProtocolConfig .
  sd symSqrInSSNPlus1 :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        chn ('ShareSum[(N + 1) 'B])
        with
         nf('c : bool  <- read ('Sqr[N + 1]),
             return 'c)
        in P
        ]
        { substNFFamilyOne(
          fam ('Sqr[bound (N + 2)]),
          'ShareSum[(N + 1) 'B]
          )
        }
  .
  strat revertColSumInductive @ ProtocolConfig .
sd revertColSumInductive :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change fam ('ColSum[bound (N + 2) bound (N + 2)])
       with 
       (when (0 =T= 'i) -->
nf('c : bool <- read ('Col[0 'j]), return 'c))
;;
(when neg (0 =T= 'i) -->
nf(('bi : bool <- read ('Col['i 'j])) 'bs : bool <- read ('ColSum[('i -- 1) 'j]),
    return (ap 'xor pair('bs, 'bi)))
)        
       in P
       ]{
        applyGroupFamiliesNew(
    fam ('RowSum[bound (N + 2) bound (N + 2)]), 
    fam ('ColSum[bound (N + 2) bound (N + 2)])
  )
; CONG-NEW-NF{setupIndColRow}
  
; applyUngroupFamiliesNew(
    fam ('RowSum[bound (N + 2) bound (N + 2)]), 
    fam ('ColSum[bound (N + 2) bound (N + 2)])
  ) 
       
       }
. 
 strat unsafeColSumInductive @ ProtocolConfig .
sd unsafeColSumInductive :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        UNSAFE[
       Delta':ChannelContext <- Delta,
       O':Set{CNameBound} <- O,
       I':Set{CNameBound} <- I,
       A':Set{BoolTerm} <- A,
       P1:Protocol <- 
       change fam ('ColSum[bound (N + 2) bound (N + 2)])
       with 
       (when (0 =T= 'i) -->
nf('c : bool <- read ('Col[0 'j]), return 'c))
;;
(when neg (0 =T= 'i) -->
nf(('bi : bool <- read ('Col['i 'j])) 'bs : bool <- read ('ColSum[('i -- 1) 'j]),
    return (ap 'xor pair('bs, 'bi)))
)    
       in P
       ]
.
strat symSqrToInductive @ ProtocolConfig .
sd symSqrToInductive :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <-
        change fam ('Sqr[bound (N + 2)])
        with
        (when ('i =T= 0) --> 
         nf('c : bool <- read ('Col[0 0]), return 'c)
        )
        ;;
        (when neg ('i =T= 0) -->
         nf( ('bs : bool <- read('Sqr['i -- 1]) ) 
             ('br : bool <- read('Row[('i -- 1) 'i]) )
             ('bc : bool <- read('Col['i 'i]) ),
             return (ap 'xor pair( ap 'xor pair('bs, 'br), 'bc))
           )
        )
        in P
       ] 
       {
       CONG-NEW-NF{
       SINGLE-INDUCTION-new-R[
  idx:Qid <- 'B,
  q:Qid <- 'i,
  cn:ChannelName <- 'Sqr,
  blist:List{Bounds} <- bound (N + 2),
  cases':Cases <- 
   nf('c : bool <- read ('ColSum['i 'i]), return 'c)
              ]
       {
       *** ind proof
       CASE-DISTINCTION-channel[
        cn:ChannelName <- 'Sqr['B]
       ]{
       symSqrIndZero, 
       CASE-DISTINCTION-channel-end-when[
        cn:ChannelName <- 'Sqr['B]
       ]{
       symSqrIndNZero
       }}
       *** wrap it up with a sym proof
       ; symMergeBranchesSqr
       }
       }
       }
.   
strat symSqrIndZero @ ProtocolConfig .
sd symSqrIndZero :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change chn ('Sqr['B])
       with nf('c : bool <- read ('ColSum[0 0]), return 'c)
       in P
       ]
       { substFamCaseChn(
        fam ('ColSum[bound (N + 2) bound (N + 2)]), 
        'Sqr['B], (0 =T= 'i)
        ) 
       } 
       
.
strat symSqrIndNZero @ ProtocolConfig .
sd symSqrIndNZero :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
         SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change chn ('Sqr['B])
       with nf('c : bool <- read ('ColSum['B 'B]), return 'c)
       in P
       ]
       {
       substFamCaseChn(
        fam ('ColSum[bound (N + 2) bound (N + 2)]), 
        'Sqr['B], neg (0 =T= 'i)
        ) 
        ; unsafeColSumClosed
        ; substNFFamilyOne(fam ('ColSum[bound (N + 2) bound (N + 2)]),
          'Sqr['B]
         )
        ; substFamCaseChn(
        fam ('RowSum[bound (N + 2) bound (N + 2)]), 
        'Sqr['B], neg (0 =T= 'j)
        ) 
        ; symColToRowNZ  
        ; applyAlphaNFPr(
            chn ('Sqr['B]), 
                         << 'bi, 'bc >> << 'bj, 'br >> << 'r, 'bs >> emptyQidPairList)
                        
        ; unsafeColSumInductive
        }
. 
strat revertColSumClosed @ ProtocolConfig .
sd revertColSumClosed :=
  applyGroupFamiliesNew(
    fam ('RowSum[bound (N + 2) bound (N + 2)]), 
    fam ('ColSum[bound (N + 2) bound (N + 2)])
  )
; CONG-NEW-NF{setupIndColRow}
  
; applyUngroupFamiliesNew(
    fam ('RowSum[bound (N + 2) bound (N + 2)]), 
    fam ('ColSum[bound (N + 2) bound (N + 2)])
  ) 
.        
strat unsafeColSumClosed @ ProtocolConfig .
sd unsafeColSumClosed :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        UNSAFE[
       Delta':ChannelContext <- Delta,
       O':Set{CNameBound} <- O,
       I':Set{CNameBound} <- I,
       A':Set{BoolTerm} <- A,
       P1:Protocol <- 
       change fam ('ColSum[bound (N + 2) bound (N + 2)])
       with 
        nf('r : bool <- read ('RowSum['i 'j]), return 'r)
       in P
       ]
.
strat symColToRowNZ @ ProtocolConfig .
sd symColToRowNZ :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
         SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change chn ('Sqr['B])
       with  nf(('bi : bool <- read ('Col['B 'B])) 
             ('bj : bool <- read ('Row[('B -- 1) 'B])) 
              'r : bool <- read ('Sqr['B -- 1]), 
              return (ap 'xor pair(ap 'xor pair('r, 'bj), 'bi)))
       in P       
       ]
       {
       substNFFamilyOne(
       fam ('Sqr[bound 'B]),
       'Sqr['B]
       )
       ;
       substNFFamilyOne(
       fam ('ColSum[bound (N + 2) bound (N + 2)]), 
       'Sqr['B]
       )
       }
       
.
strat symMergeBranchesSqr @ ProtocolConfig .
sd symMergeBranchesSqr :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change chn ('Sqr['B])
       with nf('c : bool <- read ('ColSum['B 'B]), return 'c)
       in P
       ] 
       {
       matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
       SYM[
       Delta1:ChannelContext <- Delta',
       O1:Set{CNameBound} <- O',
       P1:Protocol <- change chn ('Sqr['B])
       with 
       (when ('B =T= 0) -->
       nf('c : bool <- read ('ColSum['B 'B]), return 'c)
       )
       ;; 
       (when neg ('B =T= 0) -->
       nf('c : bool <- read ('ColSum['B 'B]), return 'c)
       )
       in P'
       ]{
       applyAllSameCases(chn ('Sqr['B]))
       }
       ;
       CASE-DISTINCTION-channel[
        cn:ChannelName <- 'Sqr['B]
       ]{
        applyAlphaAssumChn('Sqr['B], 'B),
       idle
       }
       }
.
strat symSqrToClosedAnd @ ProtocolConfig .
sd symSqrToClosedAnd :=
       CONG-NEW-NF{
       
       SINGLE-INDUCTION-new-R[
  idx:Qid <- 'Z,
  q:Qid <- 'i,
  cn:ChannelName <- 'Sqr,
  blist:List{Bounds} <- bound (N + 2),
  cases':Cases <- 
   nf(
 ('xs : bool <- read ('ShareSum['i (fun 'wire0 'B)]))
 ('ys : bool <- read ('ShareSum['i (fun 'wire1 'B)])),
 return (ap 'and pair('xs, 'ys))
)
   ]{
       *** induction proof starts here
       CASE-DISTINCTION-channel[
        cn:ChannelName <- 'Sqr['Z]
       ]{
        substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'Sqr['Z], (0 =T= 'j)
        )
        ; substFamCaseChn(
        fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]), 
        'Sqr['Z], ('m =T= 'n)
        )
        ; sym1SqrToAnd
        , 
        CASE-DISTINCTION-channel-end-when[
        cn:ChannelName <- 'Sqr['Z]
       ]{ applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 'bs, 's >> emptyQidPairList) 
        ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'Sqr['Z], neg (0 =T= 'j)
        ) 
        ; applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 'bs, 'bc >> << 's, 'bs >> << 'bj, 'b >> emptyQidPairList)
        ; applyMiddleXor( chn ('Sqr['Z]) )  
        
        *** add internals
        ; addInternalsDiagRefRowCol
        
        ; symRowColInSqr
        
        ; symRowColToInd
        
        ; rewriteDiagRef
        
        ; indRowColToClosed
        
        ; absorbFamilyDeleteEmpty( fam ('DiagRef[bound 'Z]) ) 
        
        *** now we do three substitutions in Sqr['Z]
        
        ; substNFFamilyOne(
          fam ('Sqr[bound 'Z]),
          'Sqr['Z]
        )
        ; substNFFamilyOne(
          fam ('RowCol[bound 'Z]),
          'Sqr['Z]
        )
        ; substFamCaseChn(
        fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]), 
        'Sqr['Z], ('m =T= 'n)
        )
        ; applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 'x, 'xn >> << 'y, 'yn >> emptyQidPairList)
        ; absorbFamilyDeleteEmpty( fam ('RowCol[bound 'Z]))
        *** slight rearrange
        ; applyDerivedXorRule(chn ('Sqr['Z])) 
        
        *** now the sym proof
        
        ; symSqrBranchNZ
        
        ; applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 'x, 'xs >> << 'y, 'ys >> emptyQidPairList)
        
        }
       }
       *** now we need Z on both branches, do a sym
       ; symZBranchNZSqr
       } *** end induction
       } *** end cong
.    
strat symZBranchNZSqr @ ProtocolConfig .
sd symZBranchNZSqr :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change 
       chn ('Sqr['Z])
       with nf(('xs : bool <- read ('ShareSum['Z (fun 'wire0 'B)])) 
                'ys : bool <- read ('ShareSum['Z (fun 'wire1 'B)]), 
                return (ap 'and pair('xs, 'ys)))
       in P
       ] 
       {
       matchrew pConf' s.t. pConfig(Sigma', Delta', P', I', O', A') := pConf' by pConf' 
       using
       SYM[
       Delta1:ChannelContext <- Delta',
       O1:Set{CNameBound} <- O',
       P1:Protocol <- change 
        chn ('Sqr['Z])
        with
         (when ('Z =T= 0) --> 
          nf(('xs : bool <- read ('ShareSum['Z (fun 'wire0 'B)])) 
                'ys : bool <- read ('ShareSum['Z (fun 'wire1 'B)]), 
                return (ap 'and pair('xs, 'ys)))
         )
         ;;
         (when neg('Z =T= 0) --> 
          nf(('xs : bool <- read ('ShareSum['Z (fun 'wire0 'B)])) 
                'ys : bool <- read ('ShareSum['Z (fun 'wire1 'B)]), 
                return (ap 'and pair('xs, 'ys))
              )
         )
         
        in P'
        ]
        {applyAllSameCases(chn ('Sqr['Z]))}
        ; CASE-DISTINCTION-channel[
        cn:ChannelName <- 'Sqr['Z]
       ]{applyAlphaAssumChn('Sqr['Z], 'Z), idle}
       }
.
 strat sym1SqrToAnd @ ProtocolConfig .
sd sym1SqrToAnd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change 
        chn ('Sqr['Z])
        with nf(
 ('xs : bool <- read ('ShareSum[0 (fun 'wire0 'B)]))
 ('ys : bool <- read ('ShareSum[0 (fun 'wire1 'B)])),
 return (ap 'and pair('xs, 'ys))
)
        in P
       ] 
       {  applyRemoveMergeFromGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          )
       ; substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'Sqr['Z], (0 =T= 'm)
        )
       ; applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 's, 'x >> emptyQidPairList) 
       ; substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'Sqr['Z], (0 =T= 'm)
        )
        ; applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 's, 'y >> emptyQidPairList)  
       ;  applyAddToGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          )  
       }    
.     
strat addInternalsDiagRefRowCol @ ProtocolConfig .
 sd addInternalsDiagRefRowCol := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'DiagRef
         typed bool
         params ('i)
                (bound 'Z)  
         assigned
          nf( ('b : bool  <-  read ('Ctrb['i 'Z 'B]))
              ('sb : bool  <- read ('Ctrb['Z 'i 'B])),
             return (ap 'xor pair('b, 'sb)))
         in (
         addInternalFamily
           'RowCol
         typed bool
         params ('i)
                (bound 'Z)   
         assigned
          nf( ('br : bool  <-  read ('Row['i 'Z ]))
              ('bc : bool  <- read ('Col['Z 'i ])),
             return (ap 'xor pair('br, 'bc)))
         in P)
        ]{
            absorbFamilyDeleteEmpty( fam ('RowCol[bound 'Z]) )
          ; absorbFamilyDeleteEmpty( fam ('DiagRef[bound 'Z]) )
        }  
. 
strat symRowColInSqr @ ProtocolConfig .
sd symRowColInSqr :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
       change 
       chn ('Sqr['Z])
       with 
       nf(('b : bool <- read ('Ctrb['Z 'Z 'B])) 
          ('brc : bool <- read ('RowCol['Z -- 1])) 
          'bs : bool <- read ('Sqr['Z -- 1]), 
          return (ap 'xor pair(ap 'xor pair('bs, 'brc), 
                               'b)))
       in P
       ] 
       { substNFFamilyOne(
         fam ('RowCol[bound 'Z]),
         'Sqr['Z]
       )
       }
.       
strat symRowColToInd @ ProtocolConfig .
sd symRowColToInd :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change  
          fam ('RowCol[bound 'Z])
        with  
        
        (when ('i =T= 0) --> 
         nf('d : bool <- read ('DiagRef[0]), return 'd)
        )
        ;;
        (when neg ('i =T= 0) -->
         nf(
           ('bs : bool <- read ('RowCol['i -- 1]))
           ('bi : bool <- read ('DiagRef['i])),
           return (ap 'xor pair('bs, 'bi))
         )
        )
        
        in P
       ]
       { 
       CONG-NEW-NF{
       SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'i,
  cn:ChannelName <- 'RowCol,
  blist:List{Bounds} <- bound 'Z,
  cases':Cases <- 
   nf(('bc : bool <- read ('Col['Z 'i])) 'br : bool <- read ('Row['i 'Z]), 
       return (ap 'xor pair('br, 'bc)))
   ]{
       *** ind proof
       CASE-DISTINCTION-channel[
        cn:ChannelName <- 'RowCol['M]
       ]
       {
       substNFFamilyOne(
        fam ('DiagRef[bound 'Z]),
        'RowCol['M]
       )
       ; symRowColZero 
       ,
       CASE-DISTINCTION-channel-end-when[
       cn:ChannelName <- 'RowCol['M]
       ]{
          substNFFamilyOne(
           fam ('RowCol[bound 'M]),
           'RowCol['M]
          )
          ;
          substNFFamilyOne(
        fam ('DiagRef[bound 'Z]),
        'RowCol['M]
       )
       ; applyRearrangeXor(chn ('RowCol['M]))
       ; symRowColNZero
       }
       }
       ; applyAllSameCases(chn ('RowCol['M]))
     }  
     }
     }
.  
 strat symRowColNZero @ ProtocolConfig .
 sd symRowColNZero :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change chn ('RowCol['M])
        with
        nf( ('br : bool  <-  read ('Row['M 'Z ]))
            ('bc : bool  <- read ('Col['Z 'M ])),
             return (ap 'xor pair('br, 'bc)))
        in P
       ] 
       { substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowCol['M], neg (0 =T= 'i)
      )
      ; applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'r, 'br >> << 'bi, 'b >> emptyQidPairList) 
      ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowCol['M], neg (0 =T= 'j)
      )  
      ; applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'bs, 'bc >> << 'bj, 'sb >> emptyQidPairList)      
      }                             
  .     
 strat symRowColZero @ ProtocolConfig .
 sd symRowColZero :=
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
        change chn ('RowCol['M])
        with
        nf( ('br : bool  <-  read ('Row['M 'Z ]))
            ('bc : bool  <- read ('Col['Z 'M ])),
             return (ap 'xor pair('br, 'bc)))
        in P
       ] 
       { substFamCaseChn(
        fam ('Row[bound (N + 2) bound (N + 2)]), 
        'RowCol['M], (0 =T= 'i)
       )
       ; applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'c, 'b >> emptyQidPairList) 
       ; substFamCaseChn(
        fam ('Col[bound (N + 2) bound (N + 2)]), 
        'RowCol['M], (0 =T= 'j)
       )  
       ; applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'c, 'sb >> emptyQidPairList)  
       }                  
 .
 strat rewriteDiagRef @ ProtocolConfig .
sd rewriteDiagRef := 
CONG-NEW-NF{
   substFamCaseFam(
        fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]), 
        fam ('DiagRef[bound 'Z]) , ('n <T 'm), 
        nf('s : bool <- read ('SendBit['i 'Z 'B]), return 's)
       ) 
   
   ; substFamCaseFam(
        fam ('Ctrb[bound (N + 2) bound (N + 2) fixedBound 'B]), 
        fam ('DiagRef[bound 'Z]) , ('m <T 'n), 
        nf('r : bool <- read ('RcvdBit['Z 'i 'B]), return 'r)
       ) 
       
   ; substNFFamiliesGen(
      fam ('RcvdBit[bound (N + 2) bound (N + 2) fixedBound 'B]),
      fam ('DiagRef[bound 'Z]) 
   )     
   ; applyReturnCommXor(
      fam ('DiagRef[bound 'Z])
   )                         
   ; applyReturnIdemRev(fam ('DiagRef[bound 'Z]))
   
   ; applyDropSubsumeCase(
       fam ('SendBit[bound (N + 2) bound (N + 2) fixedBound 'B]), 
      fam ('DiagRef[bound 'Z]), ('n <T 'm)
     )
      
   
}      
.
strat indRowColToClosed @ ProtocolConfig .
sd indRowColToClosed :=
      CONG-NEW-NF{ 
       SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'i,
  cn:ChannelName <- 'RowCol,
  blist:List{Bounds} <- bound 'Z,
  cases':Cases <- 
   nf(
  ('xs : bool <- read ('ShareSum['i (fun 'wire0 'B)]))
  ('ys : bool <- read ('ShareSum['i (fun 'wire1 'B)]))
  ('xn : bool <- read ('Share['Z (fun 'wire0 'B)]))
  ('yn : bool <- read ('Share['Z (fun 'wire1 'B)])),
  return (ap 'xor pair(
               ap 'and pair('xs, 'yn),
               ap 'and pair('xn, 'ys)
            ))
)
   ]{
       *** ind proof here
       CASE-DISTINCTION-channel[
        cn:ChannelName <- 'RowCol['M]
        ]{
        substNFFamilyOne(
        fam ('DiagRef[bound 'Z]),
        'RowCol['M]
        )
        ; symBranch1RowColAnd
        ,
        CASE-DISTINCTION-channel-end-when[
        cn:ChannelName <- 'RowCol['M]
        ]{
         substNFFamilyOne(
        fam ('DiagRef[bound 'Z]),
        'RowCol['M]
        )
        ; applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'xm, 'xi >> << 'ym, 'yi >> 
                         emptyQidPairList)
        ; substNFFamilyOne(
        fam ('RowCol[bound 'M]),
        'RowCol['M]
        )  
        ; applyRearrangeXor(chn ('RowCol['M]))                
        ; applyDerivedXorAndRule(chn ('RowCol['M]))  
        ; symBranch2RowColAnd               
        }
        }
        ; applyAllSameCases(chn ('RowCol['M])) 
  } *** ind
  } *** cong
.
strat symBranch2RowColAnd @ ProtocolConfig .
sd symBranch2RowColAnd :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <-
       change chn ('RowCol['M])
       with nf(
  ('xs : bool <- read ('ShareSum['M (fun 'wire0 'B)]))
  ('ys : bool <- read ('ShareSum['M (fun 'wire1 'B)]))
  ('xn : bool <- read ('Share['Z (fun 'wire0 'B)]))
  ('yn : bool <- read ('Share['Z (fun 'wire1 'B)])),
  return (ap 'xor pair(
               ap 'and pair('xs, 'yn),
               ap 'and pair('xn, 'ys)
            ))
)
       in P
       ] 
       {
       applyRemoveMergeFromGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          )
       ;   
        substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'RowCol['M], neg (0 =T= 'm)
    )
    ;  applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'xs, 'as >> << 'xm, 'am >> emptyQidPairList) 
    ;   
        substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'RowCol['M], neg (0 =T= 'm)
    )
    ;  applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'xs, 'cs >> << 'xm, 'cm >> emptyQidPairList) 
    ;  applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 'am, 'xi >> << 'as, 'xs >>
                         << 'cm, 'yi >> << 'cs, 'ys >> emptyQidPairList)  
    ; applyAddToGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          ) 
     }      
.       
strat symBranch1RowColAnd @ ProtocolConfig .
sd symBranch1RowColAnd :=
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <-
       change chn ('RowCol['M])
       with nf(
  ('xs : bool <- read ('ShareSum['M (fun 'wire0 'B)]))
  ('ys : bool <- read ('ShareSum['M (fun 'wire1 'B)]))
  ('xn : bool <- read ('Share['Z (fun 'wire0 'B)]))
  ('yn : bool <- read ('Share['Z (fun 'wire1 'B)])),
  return (ap 'xor pair(
               ap 'and pair('xs, 'yn),
               ap 'and pair('xn, 'ys)
            ))
)
       in P
       ] 
       { applyRemoveMergeFromGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          )
       ; substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'RowCol['M], (0 =T= 'm)
        )  
       ; applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 's, 'xs >> emptyQidPairList) 
       ; substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'RowCol['M], (0 =T= 'm)
        )  
       ; applyAlphaNFPr(
            chn ('RowCol['M]), 
                         << 's, 'ys >> << 'xs, 'xm >> << 'ys, 'ym >> emptyQidPairList)
       ; applyAddToGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          ) 
       }     
.
 strat symSqrBranchNZ @ ProtocolConfig .
sd symSqrBranchNZ :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using    
     SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <-
       change chn ('Sqr['Z])
       with
       nf(('x : bool <- read ('ShareSum['Z (fun 'wire0 'B)])) 
           'y : bool <- read ('ShareSum['Z (fun 'wire1 'B)]),
          return (ap 'and pair('x, 'y)))
       in P]
       { applyRemoveMergeFromGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          )
       ;   
        substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'Sqr['Z], neg (0 =T= 'm)
       )
       ; applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 'xs, 'as >> << 'xm, 'am >>  emptyQidPairList) 
       ; substFamCaseChn(
        fam ('ShareSum[bound (N + 1) bound 'B]), 
        'Sqr['Z], neg (0 =T= 'm)
       )  
       ; applyAlphaNFPr(
            chn ('Sqr['Z]), 
                         << 'xs, 'ys >> << 'xm, 'yn >>
                         << 'as, 'xs >> << 'am, 'xn >>  emptyQidPairList) 
       ; applyDistribTwice(chn ('Sqr['Z]))                                                  
       ; applyAddToGroupCases(
           fam ('Shares[bound 'B]), 
           fam ( 'ShareSum[bound (N + 1) bound 'B]) 
          )
       }
.          
 *** add wire as internal channels
strat addWire @ ProtocolConfig .
sd addWire := 
   matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         addInternalFamily
           'Wire
         typed bool
         params ('k)
                (bound K) 
         assigned
          nf('s : bool  <- read ('ShareSum[(N + 1) 'k]),
             return 's)
         in P
      ]{ absorbFamilyDeleteEmpty( 
        fam ('Wire[bound K])
       )
      }
.
*** 
strat addWiresGroup @ ProtocolConfig .
 sd addWiresGroup := 
     matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using (
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- 
         group  
           (fam ('Wire[bound K]))
           
         named 'Wires
         params ('k) (bound K) 
         in P
       ]
       {
        applyDropName(fam ('Wires[bound K]) )
        
       } ***sym
       )
 . 
 strat inductionWireShares @ ProtocolConfig .
sd inductionWireShares :=
*** sym + induction again
    matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf 
            by pConf 
            using 
            SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
            P1:Protocol <- 
             change ( fam (('Comp['Shares 'Wire])[bound K]) )
             with 
              wantSharesWire
             in P
            ]
            {
    CONG-NEW-NF{ 
       SINGLE-INDUCTION-new[
  idx:Qid <- 'B,
  q:Qid <- 'k,
  cn:ChannelName <- 'Comp['Shares 'Wire],
  blist:List{Bounds} <- bound K,
  P2:Protocol <- knowSharesWire
 ]{ 
    ***  
       *** here the induction proof
       *** take out ShareSum[N+1 B] from Shares
         applyRemoveFromGroupCases(fam ('Shares[fixedBound 'B]), chn ('ShareSum[(N + 1) 'B]))
       *** and group it with Wire[B]
       ; applyMergeCasesChannelGroup('Wire['B], 'ShareSum[(N + 1) 'B] )
       *** now we can do case distinction on CGroup
       ; CASE-DISTINCTION-one[
         fns:NameWithScripts <- 'CGroup
        ]{
         *** for input gate
           substNF('Wire['B], 'ShareSum[(N + 1) 'B] )
         ; symInputWS, 
         CASE-DISTINCTION-one[
         fns:NameWithScripts <- 'CGroup
        ]{ *** for not gate
           substNF('Wire['B], 'ShareSum[(N + 1) 'B] )
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'ShareSum[(N + 1) 'B]
           )
         
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'Wire['B]
           )  
        ; symInputWS  
        ;  applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 's, 'x >> emptyQidPairList)   
         ,
         CASE-DISTINCTION-one[
         fns:NameWithScripts <- 'CGroup
        ]{ *** for xor gate
           substNF('Wire['B], 'ShareSum[(N + 1) 'B] )
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'ShareSum[(N + 1) 'B]
           )
         ;  applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 's, 'x >> emptyQidPairList)  
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'ShareSum[(N + 1) 'B]
           )
         ;  applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 's, 'y >> emptyQidPairList)  
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'Wire['B]
           )
         ;  applyAlphaNFPr(
            chn ('Wire['B]), 
                         << 's, 'x >> emptyQidPairList)      
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'Wire['B]
           )
         ;  applyAlphaNFPr(
            chn ('Wire['B]), 
                         << 's, 'y >> emptyQidPairList)
         ;  symInputWS                               
         , 
         CASE-DISTINCTION-one-end-when[
         fns:NameWithScripts <- 'CGroup
        ]{ *** for and gate
         substNF('Wire['B], 'ShareSum[(N + 1) 'B] )
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'ShareSum[(N + 1) 'B]
           )
         ;  applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 's, 'x >> emptyQidPairList)  
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'ShareSum[(N + 1) 'B]
           )
         ;  applyAlphaNFPr(
            chn ('ShareSum[(N + 1) 'B]), 
                         << 's, 'y >> emptyQidPairList) 
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'Wire['B]
           )
         ;  applyAlphaNFPr(
            chn ('Wire['B]), 
                         << 's, 'x >> emptyQidPairList)      
         ; substNFFamilyOne(
            fam ('Wire[bound 'B]),
            'Wire['B]
           )
         ;  applyAlphaNFPr(
            chn ('Wire['B]), 
                         << 's, 'y >> emptyQidPairList)
         ;  symInputWS                           
         }}}}
         *** and combine the branches to get rid of the group
         ; applyNewCombine( fam('CGroup[nil]) )
         *** then move ShareSum back to Shares
         ; applyAddChnToGroupSameCases(fam ('Shares[fixedBound 'B]), 'ShareSum[(N + 1) 'B])
         *** simplify wire
         ; applyAllSameCases( chn ('Wire['B])  )
        }} } *** ind, cong, sym     
.
strat symInputWS @ ProtocolConfig .
sd symInputWS :=
  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
       chn ('Wire['B])
       with  nf('s : bool <- read ('ShareSum[(N + 1) 'B]), return 's)
       in P
       ] 
       { substNF( 'ShareSum[(N + 1) 'B], 'Wire['B])}
.
op wantSharesWire : -> Protocol .
eq wantSharesWire =
(family 'Shares[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)))
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)))
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('w : bool <- read ('Wire['k]), return 'w)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)) )
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('w : bool <- read ('Wire['k]), return 'w)
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)) )
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)) )
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('w : bool <- read ('Wire['k]), return 'w)
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y)) ))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)) )
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)) )
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >) ))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)) )
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('w : bool <- read ('Wire['k]), return 'w)

)
||
(
family 'Wire[bound K] 'k
bound K
::=
 ( when (apply 'isInputGate 'k) -->  
       nf('i : bool <- read ('In[(fun 'wire0 'k) (fun 'wire1 'k)]), return 'i)
    )   
   ;;
   (when (apply 'isNotGate 'k) -->
       nf('x : bool <- read ('Wire [(fun 'wire0 'k)]),  return (ap 'neg 'x))
   )  
   ;;
   (when (apply 'isXorGate 'k) --> 
       nf(('x : bool <- read ('Wire [(fun 'wire0 'k)])) 
           'y : bool <- read ('Wire [(fun 'wire1 'k)]), 
           return (ap 'xor pair('x, 'y)) )
   )
   ;;
   ( when (apply 'isAndGate 'k) --> 
    nf(('x : bool <- read ('Wire [(fun 'wire0 'k)])) 
        'y : bool <- read ('Wire [(fun 'wire1 'k)]), 
        return (ap 'and pair('x, 'y)) )
   ) 
)
.
    
op knowSharesWire : -> Protocol .
eq knowSharesWire =
(family 'Shares[bound K] 'k
bound K
::=
(when (apply 'isInputGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('in : bool <- read ('InShare['n (fun 'wire0 'k) (fun 'wire1 'k)]), return 'in)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)) )
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('i : bool <- read ('In[(fun 'wire0 'k) (fun 'wire1 'k)]), return 'i)
)
;;
(when (apply 'isNotGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('s : bool <- read ('Share['n (fun 'wire0 'k)]), return 's)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)) )
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)) )
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)]),  return (ap 'neg 'x))
)
;;
(when (apply 'isXorGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('Ctrb['n 'm 'k]), return 'b)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('b : bool <- read ('CtrbSum['n 'm 'k]), return 'b)
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('rb : bool <- read ('RcvdBit['n 'm 'k]), return 'rb)
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'xor pair('x, 'y)))
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)))
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)))
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)])) 'y : bool <- read ('ShareSum[(N + 1) (
    fun 'wire1 'k)]), return (ap 'xor pair('x, 'y)))
)
;;
when (apply 'isAndGate 'k) -->
(family 'Ctrb[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf('s : bool <- read ('SendBit['n 'm 'k]), return 's))
;;
(when ('m =T= 'n) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    return (ap 'and pair('x, 'y))))
;;
when ('m <T 'n) -->
nf('r : bool <- read ('RcvdBit['n 'm 'k]), return 'r)
)
||
(family 'CtrbSum[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when (0 =T= 'm) -->
nf('b : bool <- read ('Ctrb['n 0 'k]), return 'b))
;;
when neg (0 =T= 'm) -->
nf(('b : bool <- read ('Ctrb['n 'm 'k])) 's : bool <- read ('CtrbSum['n ('m -- 1) 'k]), return (ap
    'xor pair('s, 'b)))
)
||
(family 'RcvdBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
nf(('b : bool <- read ('SendBit['m 'n 'k])) ('xm : bool <- read ('Share['m (fun 'wire0 'k)])) ('xn :
    bool <- read ('Share['n (fun 'wire0 'k)])) ('ym : bool <- read ('Share['m (fun 'wire1 'k)])) 'yn
    : bool <- read ('Share['n (fun 'wire1 'k)]), return (ap 'xor pair(ap 'xor pair(ap 'and pair('xm,
    'yn), ap 'and pair('xn, 'ym)), 'b)))
)
||
(family 'SendBit[bound (N + 2) bound (N + 2) bound K] 'n 'm 'k
bound (N + 2) bound (N + 2) bound K
::=
(when ('n <T 'm) -->
nf(('x : bool <- read ('Share['n (fun 'wire0 'k)])) 'y : bool <- read ('Share['n (fun 'wire1 'k)]),
    samp ('flip < () >)))
;;
when ('m <=T 'n) -->
nf('sb : bool <- read ('SendBit['n 'm 'k]), return 'sb)
)
||
(family 'Share[bound (N + 1) bound K] 'n 'k
bound (N + 1) bound K
::=
nf('bs : bool <- read ('CtrbSum['n (N + 1) 'k]), return 'bs)
)
||
(family 'Share[fixedBound (N + 1) bound K] 'n 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor
    pair('xs, 'x)))
)
||
(family 'ShareSum[bound (N + 1) bound K] 'm 'k
bound (N + 1) bound K
::=
(when (0 =T= 'm) -->
nf('s : bool <- read ('Share[0 'k]), return 's))
;;
when neg (0 =T= 'm) -->
nf(('xm : bool <- read ('Share['m 'k])) 'xs : bool <- read ('ShareSum[('m -- 1) 'k]), return (ap
    'xor pair('xs, 'xm)))
)
||
family 'ShareSum[fixedBound (N + 1) bound K] 'm 'k
fixedBound (N + 1) bound K
::=
nf(('x : bool <- read ('ShareSum[(N + 1) (fun 'wire0 'k)])) 'y : bool <- read ('ShareSum[(N + 1) (
    fun 'wire1 'k)]), return (ap 'and pair('x, 'y)))
)
||
(
family 'Wire[bound K] 'k
bound K
::=
nf('s : bool <- read ('ShareSum[(N + 1) 'k]), return 's)
)
.
 strat symWireOSS @ ProtocolConfig .
 sd symWireOSS :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
        with 
         (when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf('out : bool <- read ('Out['n 'k]), return 'out))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('OutShareSum ^^ 'party .. 'adv)['n (N + 1) 'k]), return 's)
        in P
       ] 
       { CONG-NEW-NF{ select-branch-family-r[
    fns:NameWithScripts <- 'OutShareSum ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{ 
    substNFFamiliesGen(     
     fam ('Out [bound (N + 2) bound K]),
     fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
    )
   }
   }
 }
.  
 strat symWireOS @ ProtocolConfig .
 sd symWireOS :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
        with 
         (when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf(('out : bool <- read ('Out['n 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor pair('xs,
    'out)) ))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('OutShare ^^ 'party .. 'adv)['n (N + 1) 'k]), return 's)
        in P
       ] 
       
       { CONG-NEW-NF{ select-branch-family-r[
    fns:NameWithScripts <- 'OutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{ 
    substNFFamiliesGen(     
     fam ('Out [bound (N + 2) bound K]),
     fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
    )
    
   }
   }
  }
.    
strat symWireROS @ ProtocolConfig .
 sd symWireROS :=
 matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
       P1:Protocol <- change 
        fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
        with 
         (when ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) -->
nf(('out : bool <- read ('Out['n 'k])) 'xs : bool <- read ('ShareSum[N 'k]), return (ap 'xor pair('xs,
    'out))))
;;
when (neg (apply 'isOutputWire 'k) disj apply 'isHonest 'n) -->
nf('s : bool <- read (('RcvdOutShare ^^ 'party .. 'adv)['n (N + 1) 'k]), return 's)
        in P
       ] 
       
       { CONG-NEW-NF{ select-branch-family-r[
    fns:NameWithScripts <- 'RcvdOutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{ 
    substNFFamiliesGen(     
     fam ('Out [bound (N + 2) bound K]),
     fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
    )
    
   }
   }
  }
.
endsm

set trace off .

*** red sizeIPDLP(sig, delta, genA, real) .

srew [1] 
 aConfig(
   pConfig(
    sig, 
    delta, 
    real,
    fam ('In[(bound (N + 2)) (dependentBound 'I)]), 
    getOutputs(real),
    genA),width 0, length 0) using   
 TRANS{   
 TRANS{   
 STRICT{sugar-newNF}, 
 CONG-NEW-NF-EQ-APPROX{
 matchrew aConf:ApproxEqConfig s.t. aConfig(pConfig(Sigma, Delta, P, I, O, A), 
   width w:Int, length l:Int) := aConf:ApproxEqConfig by aConf:ApproxEqConfig 
       using
 CONG-COMP-EQ-APPROX[P1:Protocol <- 
    keepOne P 
     (fam ('1OutOf4OTReal[bound (N + 2) bound (N + 2) bound K])) ]{
   
   GEN-APPROX-cases-3{APPROX-CASE-DISTINCTION-one{
  EMBED-APPROX[Delta2:ChannelContext <- deltaSRW,
        phi:IPDLEmbedding <- phi,
        I:Set{CNameBound} <- ( chn ('OTChc-0['s 'r 'w]) , 
   chn ('OTChc-1['s 'r 'w]) ,
  chn ('OTMsg-0['s 'r 'w]) ,
 chn ('OTMsg-1['s 'r 'w]) ,
 chn ('OTMsg-2['s 'r 'w]) ,
 chn ('OTMsg-3['s 'r 'w]) 
 ),
        O:Set{CNameBound} <- getOutputs(1OutOf4OTIdeal-Honest-Honest),
        P1:Protocol <- 1OutOf4OTReal-Honest-Honest,
        P2:Protocol <- 1OutOf4OTIdeal-Honest-Honest ]{HH2HH}
 ,  
      
 APPROX-CASE-DISTINCTION-one{
  EMBED-APPROX[Delta2:ChannelContext <- deltaSRW,
        phi:IPDLEmbedding <- phi,
        I:Set{CNameBound} <- ( chn ('OTChc-0['s 'r 'w]) , 
   chn ('OTChc-1['s 'r 'w]) ,
  chn ('OTMsg-0['s 'r 'w]) ,
 chn ('OTMsg-1['s 'r 'w]) ,
 chn ('OTMsg-2['s 'r 'w]) ,
 chn ('OTMsg-3['s 'r 'w]) 
 ),
        O:Set{CNameBound} <- getOutputs(1OutOf4OTIdeal-SemiHonest-Honest),
        P1:Protocol <- 1OutOf4OTReal-SemiHonest-Honest,
        P2:Protocol <- 1OutOf4OTIdeal-SemiHonest-Honest ]{SHH2SHH}
 ,  APPROX-CASE-DISTINCTION-one{
  EMBED-APPROX[Delta2:ChannelContext <- deltaSRW,
        phi:IPDLEmbedding <- phi,
        I:Set{CNameBound} <- ( chn ('OTChc-0['s 'r 'w]) , 
   chn ('OTChc-1['s 'r 'w]) ,
  chn ('OTMsg-0['s 'r 'w]) ,
 chn ('OTMsg-1['s 'r 'w]) ,
 chn ('OTMsg-2['s 'r 'w]) ,
 chn ('OTMsg-3['s 'r 'w]) 
 ),
        O:Set{CNameBound} <- getOutputs(1OutOf4OTIdeal-Honest-SemiHonest),
        P1:Protocol <- 1OutOf4OTReal-Honest-SemiHonest,
        P2:Protocol <- 1OutOf4OTIdeal-Honest-SemiHonest ]{HSH2HSH}
 ,   APPROX-CASE-DISTINCTION-one-end-when{
  EMBED-APPROX[Delta2:ChannelContext <- deltaSRW,
        phi:IPDLEmbedding <- phi,
        I:Set{CNameBound} <- ( chn ('OTChc-0['s 'r 'w]) , 
   chn ('OTChc-1['s 'r 'w]) ,
  chn ('OTMsg-0['s 'r 'w]) ,
 chn ('OTMsg-1['s 'r 'w]) ,
 chn ('OTMsg-2['s 'r 'w]) ,
 chn ('OTMsg-3['s 'r 'w]) 
 ),
        O:Set{CNameBound} <- getOutputs(1OutOf4OTIdeal-SemiHonest-SemiHonest),
        P1:Protocol <- 1OutOf4OTReal-SemiHonest-SemiHonest,
        P2:Protocol <- 1OutOf4OTIdeal-SemiHonest-SemiHonest ]{SHSH2SHSH}
  }  } }}}
   
       
     }
 }
 } , 

 STRICT{
   applyNewCombineFam( fam ('1OutOf4OTReal[bound (N + 2) bound (N + 2) bound K]) )
 ; ((COMP-NEW-newNF-inside-new ; lift-inner-new-nf) !) 
 
       ; applyAddToGroupCases(
          fam (('OTChc-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         ) 
       ; applyAddToGroupCases(
          fam (('OTChc-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         ) 
       ; applyAddToGroupCases(
          fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         )
       ; applyAddToGroupCases(
          fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         )
         
       ; applyAddToGroupCases(
          fam (('OTMsg-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         )
       ; applyAddToGroupCases(
          fam (('OTMsg-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         )
       ; applyAddToGroupCases(
          fam (('OTMsg-2 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
        )
       ; applyAddToGroupCases(
          fam (('OTMsg-3 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
       )
       ; applyAddToGroupCases(
          fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         )
       ; applyAddToGroupCases(
          fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
         )
       ; applyAddToGroupCases(
          fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
        )
       ; applyAddToGroupCases(
          fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
       ) 
       
       ; applyAddToGroupCases(
          fam ('OTOut[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
       )  
       
       ; applyAddToGroupCases(
          fam (('OTOut ^^ 'ot .. 'adv)[(bound (N + 2)) (bound (N + 2)) (bound K)]), 
          fam ('Circuit[(bound (N + 2)) (bound K)])
       ) 
       
       *** restructure the real protocol 10.4     
       ; matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using  
        SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
         P1:Protocol <- restr]{
          sugar-newNF
        ; moveNewToFront
       }
        ; sugar-newNF
       ; ((COMP-NEW-newNF-inside-new ; lift-inner-new-nf) !) 
   
       *** 10.4.1 Simplifying The Real Protocol: Initial Phase
       
       ; applySubstFamily3IdxCase(
          fam ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]), 
          fam (('SendInShare ^^ 'party .. 'adv)
            [((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]), 
         apply 'isSemiHonest 'n)
       
       ; alpha-family-three[
           fns:NameWithScripts <- 'SendInShare, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'i,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'i]
       
       ; applySubstFamily3IdxCase(
           fam ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]),
           fam (('RcvdInShare ^^ 'party .. 'adv)
            [((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]), 
         apply 'isSemiHonest 'n) 
         
       ; substNFFamiliesGen(
           fam ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))]), 
           fam ('InShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))])
                           )               

       ; absorbFamily(
          fam ('SendInShare[((bound (N + 2)) (bound (N + 2)) (dependentBound 'I))])
         ) 
                
       *** 10.4.2 Simplifying The Real Protocol: Inductive Phase
        
       ; select-branch-family-p[bt:BoolTerm <- apply 'isInputGate 'k, 
                                fns:NameWithScripts <- 'Circuit]{
           eliminateOTDivergent          
         } 
            
       ; select-branch-family-p[bt:BoolTerm <- apply 'isNotGate 'k,
                               fns:NameWithScripts <- 'Circuit]{
           eliminateOTDivergent          
         }  
       ; select-branch-family-p[bt:BoolTerm <- apply 'isXorGate 'k,
                                fns:NameWithScripts <- 'Circuit]{
           eliminateOTDivergent          
         } 
   
       ; select-branch-family-p[bt:BoolTerm <- apply 'isAndGate 'k]{
         substDivergeJoinCases(
            fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
          )
   ;
          substDivergeJoinCases(
            fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
          ) 
            ;
          substDivergeJoinCases(
             fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
          )  
         ;
          substDivergeJoinCases(
            fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsg-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
          )
        ;
         substDivergeJoinCases(
            fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsgRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
          )
       ;
          substDivergeJoinCases(
            fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsgRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
          )  
           ;
          substDivergeJoinCases(
             fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
            fam (('OTMsgRcvd-2 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
          )
          ;
          substDivergeJoinCases( 
             fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
             fam (('OTMsgRcvd-3 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
          ) 
         
          ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-0, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
          ;
          substDivergeJoinCases(
             fam ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
             fam (('OTChc-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
          )
          
          ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-1, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
          ;

          substDivergeJoinCases(
             fam ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
             fam (('OTChc-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))])
          )
          ;
          substDivergeJoinCases(
             fam ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]) , 
             fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
          )
          ;
          substDivergeJoinCases(
             fam ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[(bound (N + 2) (bound (N + 2)) (bound K))]) 
          )
          ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-0, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k] 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTChc-1, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]       
         
          ; alpha-family-three[
           fns:NameWithScripts <- 'RcvdBit, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k] 
            
          ; CONG-NEW-NF{
             select-branch-family-r[bt:BoolTerm <- apply 'isSemiHonest 'm, 
                                    fns:NameWithScripts <- 'OTOut ^^ 'ot .. 'adv]{
                  substNFReadRevFamilies(
                    fam ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                    fam (('OTOut ^^ 'ot .. 'adv)[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                    fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))])
                  )   
             }
           }       
         
          ; substNFFamiliesGen(
             fam ('OTOut[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))])
          )  
          
           ; alpha-family-three[
           fns:NameWithScripts <- 'RcvdBit, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k]  
            
  
          ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-0, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k] 
          
          ; applySubstOrDiverge(
            fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
            'z
            )   
           
        ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-1, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k] 
           
        ; applyGenSameCasesSubstFirstBranch(
            fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))])
             ) 
         ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-2, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]       
         ; applyGenSameCasesSubstFirstBranch(
            fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))])
             )  
            ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-3, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]  
            ; applyGenSameCasesSubstFirstBranch(
            fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))])
             ) 
             ; applyAlphaBranchCond(
                 fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                 'x, 'xm, when ('m <T 'n) )  
             ; applyAlphaBranchCond(
                 fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                 'y, 'ym, when ('m <T 'n) ) 
         ; applyGenSameCasesSubstFirstBranch(
            fam ('OTChc-0[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))])
             )  
             ; applyAlphaBranchCond(
             fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
             'x, 'xn, when ('m <T 'n) 
             )  
             ; applyGenSameCasesSubstFirstBranch(
            fam ('OTChc-1[((bound (N + 2)) (bound (N + 2)) (bound K))]),
            fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))])
             )  
           ; applyAlphaBranchCond(
                fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))]), 
                'x, 'yn, when ('m <T 'n) )  
                    
           *** undo all alphas 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-0, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-1, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-2, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; alpha-family-three[
           fns:NameWithScripts <- 'OTMsg-3, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
         ; sym1 *** first branch of RcvdBit  
           ; alpha-family-three[
           fns:NameWithScripts <- 'SendBit, 
           q1:Qid <- 'n,
           q2:Qid <- 'm,
           q3:Qid <- 'k,
           q4:Qid <- 'm,
           q5:Qid <- 'n,
           q6:Qid <- 'k]   
           ; sym2 *** second branch of RcvdBit  
           ; alpha-family-three[
           fns:NameWithScripts <- 'SendBit, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k] 
           ; applyAllSameCases(fam ('RcvdBit[((bound (N + 2)) (bound (N + 2)) (bound K))])) 
         
         }   
         
         *** now we need to restructure Circuit in Adv + Shares + 1OutOf4OT
                          
         ; applyNewCombine(fam ('Circuit[(bound (N + 2)) (bound K)]))  
             
         
      *** here we get to 5 mil rewrites when turning to a sym proof
         ; slowSym *** this brings me to pInt0
   
     ; sugar-newNF
     ; ((COMP-NEW-newNF-inside-new ; lift-inner-new-nf) !)
   
       ; applyNewCombine(fam ('Adv[bound K]))
                
       ; applyNewCombine(fam ('Shares[bound K]))
       ; applyNewCombine(fam ('1OutOf4OT[bound K]))
        
       ; absorbFamily(fam ('OTOut[((bound (N + 2)) (bound (N + 2))(bound K) )]))
           
       ; absorbFamily(fam ('OTMsg-0[((bound (N + 2)) (bound (N + 2))(bound K) )]))
       ; absorbFamily(fam ('OTMsg-1[((bound (N + 2)) (bound (N + 2))(bound K) )]))
             
       ; absorbFamily(fam ('OTMsg-2[((bound (N + 2)) (bound (N + 2))(bound K) )]))
       ; absorbFamily(fam ('OTMsg-3[((bound (N + 2)) (bound (N + 2))(bound K) )]))
       ; absorbFamily(fam ('OTChc-0[((bound (N + 2)) (bound (N + 2))(bound K) )]))
       ; absorbFamily(fam ('OTChc-1[((bound (N + 2)) (bound (N + 2))(bound K) )]))
   
       ; matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using 
       SYM[
       Delta1:ChannelContext <- Delta,
       O1:Set{CNameBound} <- O,
         P1:Protocol <- pInt1]{
               sugar-newNF
       ; moveNewToFront
       ; applyNewCombine(fam ('Adv[bound K]))
       ; applyNewCombine(fam ('Shares[bound K]))
       }
         
       ; sugar-newNF
      ; moveNewToFront
      
        *** 10.4.3 Simplifying The Real Protocol: Final Phase 
          
        ; substDivergeJoinCases(
             fam ('SendOutShare[bound (N + 2) bound (N + 2) bound K]) , 
            fam (('SendOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) 
          )
        
        ; alpha-family-three[
           fns:NameWithScripts <- 'SendOutShare, 
           q1:Qid <- 'm,
           q2:Qid <- 'n,
           q3:Qid <- 'k,
           q4:Qid <- 'n,
           q5:Qid <- 'm,
           q6:Qid <- 'k]   
                           
        ; substDivergeJoinCases(
            fam ('SendOutShare[bound (N + 2) bound (N + 2) bound K]) , 
            fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K])
          ) 
        ***
        ; applySubstOrDiverge(
            fam ('SendOutShare[bound (N + 2) bound (N + 2) bound K]),
            fam ('OutShare[bound (N + 2) bound (N + 2) bound K]),            
            'z
          )
        *** at this point 'SendOutShare are unused and can be eliminated
        ; absorbFamily(fam ('SendOutShare[bound (N + 2) bound (N + 2) bound K]))  
        
        *** first some preliminaries, common to 10.4.4 and 10.4.5
         
             ; addShareSum 
     
     ; applySplitAllBranches(fam ('Adv[bound K]), 
         fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K])
       )  
     ; applySplitAllBranches(fam ('Adv[bound K]), 
         fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) bound (N + 2) bound K])
       )
        
         ***  we must split Share                 
       ; applySplitBranches(fam ('Shares[bound K]), 
         fam ('Share[bound (N + 2) bound K])
       ) 
       *** and remove the extra branching     
      ; select-branch-family-p[fns:NameWithScripts <- 'Shares,
                               bt:BoolTerm <- apply 'isNotGate 'k]
         {  applyRemoveBranch(fam ('Share[(bound (N + 1)) (bound K)]))
         }
         
        *** 10.4.4 timing of shares 1
        
     ;  matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using    
      (  *** start matchrew
        *** add two new internal channels InShareOK and ShareOK
          sym3

       ; select-branch-family-p[fns:NameWithScripts <- 'Adv,
                               bt:BoolTerm <- apply 'isAndGate 'k]
         {sym4}
       
      *** add internal channels   
      ; sym5
      
      *** introduce InitOK
      ; sym6 
      
      *** introduce SharesOK
      
      ; sym7  
       
      
      *** then we express Shares equivalently by introducing dependencies of timing
      ; sym8
      
      *** we introduce 'In-OK
      ; sym9
      
      *** and 'Wires-OK
      ; sym10
      
      
      *** we split 'ShareOK
      ; applySplitInsideGroup(fam ('SharesOK[bound K]), 
           fam ('ShareOK[bound (N + 2) bound K]))        
      
      *** then we group Shares with SharesOK
      ; applyGroupFamiliesNew(fam ('Shares[bound K]), fam ('SharesOK[bound K]))
 
      *** we will do an induction proof by sym, so we first set to what we want
      ; changeComp
       
      ; applyDropName(
         fam ('InitOK[(bound (N + 2))(bound (N + 2))(dependentBound 'I)])
        )
     
      ; alpha-family-three[fns:NameWithScripts <- 'InShare,
     q4:Qid <- 'm,
     q5:Qid <- 'n,
     q6:Qid <- 'i
      ]   
      ; substNFFamiliesGen(
             fam ('InShare[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I])
            ) 
      ; applyAlphaNFPr(fam ('InShareOK[bound (N + 2) bound (N + 2) dependentBound 'I]), 
                 << 'in, 'is >> emptyQidPairList)         
      ; alpha-family-three[fns:NameWithScripts <- 'InShare,
     q4:Qid <- 'n,
     q5:Qid <- 'm,
     q6:Qid <- 'i
      ]   
  
      ; asym0  
       
      
      *** for up to N + 1 in 'InShare$-OK
      ; applyOtherwiseToNeg(fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]))
      
      *** first we split
      
      ; applySplitFst(fam ('InShare$-OK[bound (N + 2) bound (N + 2) dependentBound 'I])) 
          
      ; applyDropSubsumeFromBranchP(
         fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]), 
         fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]), 
         neg ('m =T= N + 1)
        )
        
      *** for N + 1 in 'InShare$-OK 
      ; substNFFamiliesGen(
             fam ('InShare$[bound (N + 2) bound (N + 2) dependentBound 'I]),
             fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
        )
      ; applyAlphaNFPr(fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I]), 
                 << 's, 'is >> << 'x, 'in >> emptyQidPairList)   
                  
         
      ; asym1 
      ; applyUnsplitFstNewNF(
      fam ('InShare$-OK[bound (N + 1) bound (N + 2) dependentBound 'I]),
      fam ('InShare$-OK[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
     )  

       *** for 'InShare$Sum-OK we need an induction proof
       
       ; asym2
     
       *** and now we can deal with the missing bit on 'InShare$-OK
       ; asym01  
          
      *** here we put back InitOK
      ; sym6 
         
      *** we can furthermore make all channels from InitOK read In-OK 
      
      ; indProofInitOK
      
      *** then we un group Shares and SharesOK
      
      ; applyUngroupFamiliesNew(fam ('Shares[bound K]), fam ('SharesOK[bound K]))
      
      *** so we can group Wires-OK and SharesOK
      ; applyGroupFamiliesNew(fam ('Wires-OK[bound K]), fam ('SharesOK[bound K]))

      ; indWiresShares

      *** now we ungroup
      
      ; applyUngroupFamiliesNew(fam ('Wires-OK[bound K]), fam ('SharesOK[bound K]))
      
      *** we need to take out SharesOK     
      
      ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound K]),
           fam ('ShareOK[bound (N + 1) bound K]))  
       ; applyAllSameCases(fam ('ShareOK[bound (N + 1) bound K]))
       ; applyRemoveFromGroupCases(
           fam ('SharesOK[bound K]),
           fam ('ShareOK[fixedBound (N + 1) bound K]) )  
       ; applyAllSameCases(fam ('ShareOK[fixedBound (N + 1) bound K]))
              
       *** and rename SharesOK to Ctrbs-Ok
       
       ; applyRenameGroup(fam ('SharesOK[bound K]), 'Ctrbs-OK)   
             
       *** now we do some substs in Adv
       
       ; select-branch-family-p[
          fns:NameWithScripts <- 'Adv,
          bt:BoolTerm <- apply 'isAndGate 'k
         ]{ 
          CONG-NEW-NF{
          select-branch-family-r[
          fns:NameWithScripts <- 'OTChcRcvd-0 ^^ 'ot .. 'adv,
          blist:List{Bounds} <- bound (N + 2) fixedBound (N + 1) bound K,
          bt:BoolTerm <- 'n <T N + 1 
          ]
          { 
            substNFFamiliesGen(
             fam ('ShareOK[(fixedBound (N + 1)) (bound K)] ),
             fam (('OTChcRcvd-0 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
            )
          }
          ; 
          select-branch-family-r[
          fns:NameWithScripts <- 'OTChcRcvd-1 ^^ 'ot .. 'adv,
          blist:List{Bounds} <- bound (N + 2) fixedBound (N + 1) bound K,
          bt:BoolTerm <- 'n <T N + 1 
          ]
          { 
            substNFFamiliesGen(
             fam ('ShareOK[(fixedBound (N + 1)) (bound K)] ),
             fam (('OTChcRcvd-1 ^^ 'ot .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
            )
          }
          }
         }    
      
      *** now induction for Shares
      
      *** group with a new dummy group
      
      ; addHidden
      ; addHiddenGroup
      
      ; applyGroupFamiliesNew(fam ('HiddenGroup[bound K]), fam ('Shares[bound K])) 
    
      ; indSharesT1
      
      ; applyUngroupFamiliesNew(fam ('HiddenGroup[bound K]), fam ('Shares[bound K]))
      ; applyDropName(fam ('HiddenGroup[bound K]) )
      ; absorbFamilyDeleteEmpty( fam ('Hidden[bound K]) ) 

     *** 10.4.5 timing of shares 2
     
     ; timing2(Delta, P, I, O, A)
     
   ) *** end of matchrew   
 
     ; substDivergeJoinCases(
            fam ('OutShare[bound (N + 2) bound (N + 2) bound K]) , 
            fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K])
          )
    ; addGroupOS      
    ; addBranchGroupOS 
    
    ; CONG-NEW-NF{
      CASE-DISTINCTION-one[fns:NameWithScripts <- 'GroupOS]{
        
        applyOtherwiseToNeg(
      fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K])
    )
    
      ; SINGLE-INDUCTION-new-R[
  idx:Qid <- 'M,
  q:Qid <- 'm,
  cn:ChannelName <- 'OutShareSum,
  blist:List{Bounds} <- bound (N + 2) bound (N + 2) bound K,
  cases':Cases <- 
   nf('s : bool <- read ('ShareSum['m 'k]), return 's)
   ]
       {
       *** ind starts here
       CASE-DISTINCTION-one-R[
        fns:NameWithScripts <- 'OutShareSum
       ]{
         subst3
       ; subst3sym
       ,
       CASE-DISTINCTION-one-R-end-when[
        fns:NameWithScripts <- 'OutShareSum
       ]{   *** rename to avoid clash
            applyAlphaNFPr(fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
                 << 's, 'is >> emptyQidPairList)     
          ; subst4
          ;  *** rename to avoid clash
            applyAlphaNFPr(fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
                 << 's, 'iis >> emptyQidPairList)  
          ; substNFFamiliesGen(
             fam ('OutShareSum[bound (N + 2) bound 'M bound K]),
             fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K])
              )
          ;  *** rename to avoid clash
            applyAlphaNFPr(fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]), 
                 << 'iis, 'xm >> << 's, 'xs >> emptyQidPairList) 
         ; subst4sym         
                     
       }
       }
       ; applyAllSameCases(fam ('OutShareSum[bound (N + 2) fixedBound 'M bound K]) )
       }      
        ,
        CASE-DISTINCTION-one-end-when[fns:NameWithScripts <- 'GroupOS]{
         
         CASE-DISTINCTION-one-R[fns:NameWithScripts <- 'OutShareSum]
         {applySelectCaseDiverge(
  fam ('OutShare[bound (N + 2) bound (N + 2) bound K]), 
  fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]), 
   neg (apply 'isOutputWire 'k) , 'o, bool), 
        CASE-DISTINCTION-one-R-end[fns:NameWithScripts <- 'OutShareSum]{ 
          applySelectCaseDiverge(
  fam ('OutShare[bound (N + 2) bound (N + 2) bound K]), 
  fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]), 
   neg (apply 'isOutputWire 'k) , 'o, bool)
          }
        }
        ; applyAllSameCases(fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]))
         
        }
      }
      }
      
      ; applyNewCombine(fam ('GroupOS [bound (N + 2) bound (N + 2) bound K]) )
      
      *** then 'OutShareSum ^^ 'party .. 'adv
      ; substDivergeJoinCases(
            fam ('OutShareSum[bound (N + 2) bound (N + 2) bound K]) , 
            fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K])
          )
      *** and Out    
      ; addBranchOut 
      
      ; CONG-NEW-NF{
        CASE-DISTINCTION-one-R[
        fns:NameWithScripts <- 'Out,
        blist:List{Bounds} <- bound (N + 2) bound K
       ]{ subst5, 
          CASE-DISTINCTION-one-R-end-when[
        fns:NameWithScripts <- 'Out,
        blist:List{Bounds} <- bound (N + 2) bound K
       ]{
          subst6 }
          }
          } 
      
      *** now we can absorb unused families
      ; absorbFamily( 
         fam ('OutShare [bound (N + 2) bound (N + 2) bound K]) 
         ) 
      ; absorbFamily( 
         fam ('OutShareSum [bound (N + 2) bound (N + 2) bound K]) 
         )
         
     *** we split sharesum
     
     ; applySplit(fam ('ShareSum[bound (N + 2) bound K])) 
     
     *** then we add ShareSum to Shares   
     ;  applyAddToGroupCases(
          fam ('ShareSum[fixedBound (N + 1) bound K]), 
          fam ('Shares[bound K])
        ) 
     ;  applyAddToGroupCases(
          fam ('ShareSum[bound (N + 1) bound K]), 
          fam ('Shares[bound K])
        )    

    *** then we do the big induction proof
     ; setupIndSumShares  
        
    *** and we add Wire 
    ; addWire      
    
    *** and group it with Shares for induction
    ; applyGroupFamiliesNew(
       fam ('Shares[ bound K]),
       fam ('Wire[ bound K])
      )   
     
                  
    *** end of sum of shares 
    
    *** and do the induction proof   
    ; inductionWireShares  
   
    *** now we can ungroup
    ; applyUngroupFamiliesNew(
       fam ('Shares[ bound K]),
       fam ('Wire[ bound K])
      )   
    
    *** we can take out 'ShareSum[fixedBound N+1 bound K] 
    
    ; applyRemoveMergeFromGroupCases( 
        fam ('Shares[ bound K]), 
        fam ('ShareSum[fixedBound (N + 1) bound K] )
      ) 
      
    *** and we can add Wire to the Wires group   
    ; addWiresGroup
                  
    *** the rest goes here
    ; applySplitFst( fam (('InShare$ ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) dependentBound 'I])  ) 
; CONG-NEW-NF{
  select-branch-family-r[
    fns:NameWithScripts <- 'InShare$ ^^ 'party .. 'adv,
    blist:List{Bounds}  <- fixedBound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam ('InShare$ [bound (N + 2) bound (N + 2) dependentBound 'I]),
     fam (('InShare$ ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
    )
   
   }
  } 
  
  
; applySplitFst( fam (('SendInShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2)
    dependentBound 'I])  ) 
    
; CONG-NEW-NF{
  select-branch-family-r[
    fns:NameWithScripts <- 'SendInShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- fixedBound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam ('InShare$ [bound (N + 2) bound (N + 2) dependentBound 'I]),
     fam (('SendInShare ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
    )
   
   }
  }  
  
;  applySplitFst( fam ('InShare [bound (N + 2) bound (N + 2) dependentBound 'I])  )   

; substNFFamiliesGen(     
     fam ('InShare$ [bound (N + 2) bound (N + 2) dependentBound 'I]),
     fam ('InShare [fixedBound (N + 1) bound (N + 2) dependentBound 'I])
    )
    
;  applySplitFst( fam ('InShare$ [bound (N + 2) bound (N + 2) dependentBound 'I])  )     
; absorbFamily( fam ('InShare$ [fixedBound (N + 1) bound (N + 2) dependentBound 'I]) )
; absorbFamily( fam ('InShare [fixedBound (N + 1) bound (N + 2) dependentBound 'I]) ) 

*** RcvdBit must be split
; applyRemoveFromGroupCases(fam ('Shares[bound K]), fam ('RcvdBit[bound (N + 2) bound (N + 2) bound K]) )
; applySplit( fam ('RcvdBit[bound (N + 2) bound (N + 2) bound K]) )

; applyAddFamToGroupSameCases(
   fam ('Shares[bound K]), 
   fam ('RcvdBit[bound (N + 2) bound (N + 1) bound K])
   )
   
; applyAddFamToGroupSameCases(
   fam ('Shares[bound K]), 
   fam ('RcvdBit[bound (N + 2) fixedBound (N + 1) bound K])
   )  

; CONG-NEW-NF{
   CASE-DISTINCTION-one[
     fns:NameWithScripts <- 'Shares
   ]{idle, 
    CASE-DISTINCTION-one[
     fns:NameWithScripts <- 'Shares
   ]{idle, 
    CASE-DISTINCTION-one[
     fns:NameWithScripts <- 'Shares
   ]{idle, 
    CASE-DISTINCTION-one-end-when[
     fns:NameWithScripts <- 'Shares
   ]{applySubstDivergeCase(
   fam ('SendBit[bound (N + 2) bound (N + 2) bound K]), 
   fam ('RcvdBit[bound (N + 2) fixedBound (N + 1) bound K]), 
   'm <=T 'n, 'r , bool)}}}}
}   
   
; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('SendBit[bound (N + 2) bound (N + 2) bound K])
  )  
; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('RcvdBit[bound (N + 2) bound (N + 1) bound K])
  ) 
  
; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('RcvdBit[bound (N + 2) fixedBound (N + 1) bound K])
  )     
  
; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('CtrbSum[bound (N + 2) bound (N + 2) bound K])
  )
; applySplitFstBranches(
   fam ('Shares[ bound K]),
   fam ('Ctrb[bound (N + 2) bound (N + 2) bound K])
  )

; applyExtractSubgroup( 
   fam ('Shares[ bound K]), 
   ( fam ('Ctrb[fixedBound (N + 1) bound (N + 2) bound K]) 
     fam ('CtrbSum[fixedBound (N + 1) bound (N + 2) bound K])
     fam ('SendBit[fixedBound (N + 1) bound (N + 2) bound K])
     fam ('RcvdBit[fixedBound (N + 1) bound (N + 1) bound K])
     fam ('RcvdBit[fixedBound (N + 1) fixedBound (N + 1) bound K])
   ), 
   'Ctrbs) 
 
*** 'Ctrbs needs to go
; absorbGroup( fam ('Ctrbs[bound K]) )
; applySplit( fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) )
; applySplit( fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) )
; applyRemoveMergeFromGroupCases(
    fam ('Shares[bound K]), 
    fam ('Share[fixedBound (N + 1) bound K]))    
 
; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'RcvdOutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam ('Share[fixedBound (N + 1) bound K]),
     fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
    )
   
   }
} 
; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'OutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam ('Share[fixedBound (N + 1) bound K]),
     fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
    )
   
   }
} 
     
; absorbFamily( fam ('Share[fixedBound (N + 1) bound K]) )

; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'RcvdOutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam ('ShareSum[fixedBound (N + 1) bound K]),
     fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
    )
   
   }
} 
; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'OutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam ('ShareSum[fixedBound (N + 1) bound K]),
     fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
    )
   
   }
} 
; applySplit( fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) bound (N + 2) bound K]) )
; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'OutShareSum ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam ('ShareSum[fixedBound (N + 1) bound K]),
     fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K])
    )
   
   }
} 
; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'Out,
    blist:List{Bounds}  <- bound (N + 2) bound K,
    bt:BoolTerm <- (apply 'isOutputWire 'k) 
   ]{
   
    substNFFamiliesGen(     
     fam ('ShareSum[fixedBound (N + 1) bound K]),
     fam ('Out[bound (N + 2) bound K])
    )
   
   }
} 
; absorbFamily( fam ('ShareSum[fixedBound (N + 1) bound K]) )

*** prepare for sym
*** we can take ShareSum out of Shares
; applyRemoveMergeFromGroupCases(
    fam ('Shares[bound K]), 
    fam ('ShareSum[bound (N + 1) bound K])
 ) 
; applyMergeGroups(fam ('Adv[bound K]), fam ('Shares[bound K]), 'Circ) 
; alpha-family-three[fns:NameWithScripts <- 'InShare,
     q4:Qid <- 'm,
     q5:Qid <- 'n,
     q6:Qid <- 'i
      ]  

 
*** sym proofs from 10.4.8
; symWireOSS
 
; symWireOS

; symWireROS

*** simplification
; applyDropBranch(fam ('InShare$ [bound (N + 1) bound (N + 2) dependentBound 'I]), 
                  'm, N + 1)
; applyRemoveOtherwiseBranch(fam ('InShare$ [bound (N + 1) bound (N + 2) dependentBound 'I]))


*** finalize the proof
; matchrew pConf s.t. pConfig(Sigma, Delta, P, I, O, A) := pConf by pConf 
       using
        SYM[
       Delta1:ChannelContext <- deltaIdealPlusSim,
       O1:Set{CNameBound} <- getOutputs(idealPlusSim),
       P1:Protocol <- idealPlusSim
       ] 
{ sugar-newNF
      ; ((COMP-NEW-newNF-inside-new ; lift-inner-new-nf) !)
             
     ; 
CONG-NEW-NF{
 select-branch-family-r[
    fns:NameWithScripts <- 'InShare$,
    blist:List{Bounds}  <- bound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam ('InShare$[bound (N + 1) bound (N + 2) dependentBound 'I])
    )
   }
   
   ; select-branch-family-r[
    fns:NameWithScripts <- 'In ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam (('In ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I] )
    )
   }
   
    ; select-branch-family-r[
    fns:NameWithScripts <- 'InShare$ ^^ 'party .. 'adv,
    blist:List{Bounds}  <- fixedBound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam (('InShare$ ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
    )
    ; applyAlphaNFPr(
       fam (('InShare$ ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I]),
                         << 'in, 'x >> emptyQidPairList)
   }
   
   ; select-branch-family-r[
    fns:NameWithScripts <- 'SendInShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- fixedBound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam (('SendInShare ^^ 'party .. 'adv)[fixedBound (N + 1) bound (N + 2) dependentBound 'I])
    )
    ; applyAlphaNFPr(
      fam (('SendInShare ^^ 'party .. 'adv)
           [fixedBound (N + 1) bound (N + 2) dependentBound 'I]), 
                         << 'in, 'x >> emptyQidPairList)
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'InShare$,
    blist:List{Bounds}  <- bound (N + 1) bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('InRcvd ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam ('InShare$[bound (N + 1) bound (N + 2) dependentBound 'I])
    )
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'InRcvd ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) dependentBound 'I,
    bt:BoolTerm <- (apply 'isHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('InRcvd ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]),
     fam (('InRcvd ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I])
    )
    ; applyAlphaNFPr(
       fam (('InRcvd ^^ 'party .. 'adv)[bound (N + 2) dependentBound 'I]),
                         << 'in, 'x >> emptyQidPairList)
    
   }
   
    ;  select-branch-family-r[
    fns:NameWithScripts <- 'Out ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) bound K,
    bt:BoolTerm <- (apply 'isSemiHonest 'n) 
   ]{
   
    substNFFamiliesGen(     
     fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]),
     fam( ('Out ^^ 'party .. 'adv)[bound (N + 2) bound K] )
    )
     ; applyAlphaNFPr(
      fam( ('Out ^^ 'party .. 'adv)[bound (N + 2) bound K] ),
                         << 'out, 's >> emptyQidPairList)
   }
  
  ;  select-branch-family-r[
    fns:NameWithScripts <- 'OutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]),
     fam (('OutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] )
    )
    
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'OutShareSum ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]),
     fam (('OutShareSum ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] )
    )
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'RcvdOutShare ^^ 'party .. 'adv,
    blist:List{Bounds}  <- bound (N + 2) fixedBound (N + 1) bound K,
    bt:BoolTerm <- ((apply 'isOutputWire 'k) conj apply 'isSemiHonest 'n)
   ]{
   
    substNFFamiliesGen(     
     fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]),
     fam (('RcvdOutShare ^^ 'party .. 'adv)[bound (N + 2) fixedBound (N + 1) bound K] )
    )
   }
   
   ;  select-branch-family-r[
    fns:NameWithScripts <- 'Out,
    bt:BoolTerm <- (apply 'isOutputWire 'k) 
   ]{
   applyAlphaNFPr(
            fam ('Out[bound (N + 2) bound K]), 
                         << 'out, 'w >> emptyQidPairList)     
   }
   
} 
; applyAllSameCases( fam ('InShare$[bound (N + 1) bound (N + 2) dependentBound 'I]) )
; applyAlphaNFPr(
            fam ('InShare$[bound (N + 1) bound (N + 2) dependentBound 'I]), 
                         << 'in, 'x >> emptyQidPairList)
; absorbFamily( fam (('Out ^^ 'id .. 'adv)[bound (N + 2) bound K]) )
; absorbFamily( fam (('InRcvd ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]) )
; absorbFamilyDeleteEmpty( fam (('In ^^ 'id .. 'adv)[bound (N + 2) dependentBound 'I]) )

}
    
 ***  DONE main proof ends here, below just checks  

 }
 }  
 .
 
